
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:18:39.745] plan(): Setting new future strategy stack:
[16:18:39.745] List of future strategies:
[16:18:39.745] 1. sequential:
[16:18:39.745]    - args: function (..., envir = parent.frame())
[16:18:39.745]    - tweaked: FALSE
[16:18:39.745]    - call: future::plan("sequential")
[16:18:39.759] plan(): nbrOfWorkers() = 1
> 
> message("*** future_mapply() ...")
*** future_mapply() ...
> 
> message("- Parallel RNG truth (for later)...")
- Parallel RNG truth (for later)...
> plan(sequential)
[16:18:39.767] plan(): Setting new future strategy stack:
[16:18:39.768] List of future strategies:
[16:18:39.768] 1. sequential:
[16:18:39.768]    - args: function (..., envir = parent.frame())
[16:18:39.768]    - tweaked: FALSE
[16:18:39.768]    - call: plan(sequential)
[16:18:39.779] plan(): nbrOfWorkers() = 1
> y_rng_0 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                          MoreArgs = list(min = 1), future.seed = 0xBEEF)
[16:18:39.779] future_mapply() ...
[16:18:39.780] Generating random seeds ...
[16:18:39.780] Generating random seed streams for 4 elements ...
[16:18:39.780] Generating random seed streams for 4 elements ... DONE
[16:18:39.781] Generating random seeds ... DONE
[16:18:39.781] Will set RNG state on exit: 10407, -550183120, -1717965917, -274188662, 1010157287, 1705784185, -1742123538
[16:18:39.781] Number of chunks: 1
[16:18:39.781] getGlobalsAndPackagesXApply() ...
[16:18:39.781]  - future.globals: TRUE
[16:18:39.782] getGlobalsAndPackages() ...
[16:18:39.782] Searching for globals...
[16:18:39.788] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[16:18:39.788] Searching for globals ... DONE
[16:18:39.788] Resolving globals: FALSE
[16:18:39.789] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[16:18:39.790] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[16:18:39.790] - globals: [1] ‘FUN’
[16:18:39.790] - packages: [1] ‘stats’
[16:18:39.790] getGlobalsAndPackages() ... DONE
[16:18:39.790]  - globals found/used: [n=1] ‘FUN’
[16:18:39.790]  - needed namespaces: [n=1] ‘stats’
[16:18:39.790] Finding globals ... DONE
[16:18:39.791] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:39.791] List of 2
[16:18:39.791]  $ ...future.FUN:function (n, min = 0, max = 1)  
[16:18:39.791]  $ MoreArgs     :List of 1
[16:18:39.791]   ..$ min: num 1
[16:18:39.791]  - attr(*, "where")=List of 2
[16:18:39.791]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:39.791]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:39.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:39.791]  - attr(*, "resolved")= logi FALSE
[16:18:39.791]  - attr(*, "total_size")= num NA
[16:18:39.799] Packages to be attached in all futures: [n=1] ‘stats’
[16:18:39.799] getGlobalsAndPackagesXApply() ... DONE
[16:18:39.799] Number of futures (= number of chunks): 1
[16:18:39.799] Launching 1 futures (chunks) ...
[16:18:39.799] Chunk #1 of 1 ...
[16:18:39.800]  - Finding globals in '...' for chunk #1 ...
[16:18:39.800] getGlobalsAndPackages() ...
[16:18:39.800] Searching for globals...
[16:18:39.800] 
[16:18:39.800] Searching for globals ... DONE
[16:18:39.800] - globals: [0] <none>
[16:18:39.800] getGlobalsAndPackages() ... DONE
[16:18:39.801]    + additional globals found: [n=0] 
[16:18:39.801]    + additional namespaces needed: [n=0] 
[16:18:39.801]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:39.801]  - seeds: [4] <seeds>
[16:18:39.801]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:39.801] getGlobalsAndPackages() ...
[16:18:39.801] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:39.801] Resolving globals: FALSE
[16:18:39.802] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[16:18:39.802] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[16:18:39.803] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:39.803] - packages: [1] ‘stats’
[16:18:39.803] getGlobalsAndPackages() ... DONE
[16:18:39.804] run() for ‘Future’ ...
[16:18:39.804] - state: ‘created’
[16:18:39.804] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:39.804] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:39.804] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:39.805]   - Field: ‘label’
[16:18:39.805]   - Field: ‘local’
[16:18:39.805]   - Field: ‘owner’
[16:18:39.805]   - Field: ‘envir’
[16:18:39.805]   - Field: ‘packages’
[16:18:39.805]   - Field: ‘gc’
[16:18:39.805]   - Field: ‘conditions’
[16:18:39.805]   - Field: ‘expr’
[16:18:39.805]   - Field: ‘uuid’
[16:18:39.805]   - Field: ‘seed’
[16:18:39.805]   - Field: ‘version’
[16:18:39.806]   - Field: ‘result’
[16:18:39.806]   - Field: ‘asynchronous’
[16:18:39.806]   - Field: ‘calls’
[16:18:39.806]   - Field: ‘globals’
[16:18:39.806]   - Field: ‘stdout’
[16:18:39.806]   - Field: ‘earlySignal’
[16:18:39.806]   - Field: ‘lazy’
[16:18:39.806]   - Field: ‘state’
[16:18:39.806] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:39.806] - Launch lazy future ...
[16:18:39.807] Packages needed by the future expression (n = 1): ‘stats’
[16:18:39.807] Packages needed by future strategies (n = 0): <none>
[16:18:39.808] {
[16:18:39.808]     {
[16:18:39.808]         {
[16:18:39.808]             ...future.startTime <- base::Sys.time()
[16:18:39.808]             {
[16:18:39.808]                 {
[16:18:39.808]                   {
[16:18:39.808]                     {
[16:18:39.808]                       base::local({
[16:18:39.808]                         has_future <- base::requireNamespace("future", 
[16:18:39.808]                           quietly = TRUE)
[16:18:39.808]                         if (has_future) {
[16:18:39.808]                           ns <- base::getNamespace("future")
[16:18:39.808]                           version <- ns[[".package"]][["version"]]
[16:18:39.808]                           if (is.null(version)) 
[16:18:39.808]                             version <- utils::packageVersion("future")
[16:18:39.808]                         }
[16:18:39.808]                         else {
[16:18:39.808]                           version <- NULL
[16:18:39.808]                         }
[16:18:39.808]                         if (!has_future || version < "1.8.0") {
[16:18:39.808]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:39.808]                             "", base::R.version$version.string), 
[16:18:39.808]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:39.808]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:39.808]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:39.808]                               "release", "version")], collapse = " "), 
[16:18:39.808]                             hostname = base::Sys.info()[["nodename"]])
[16:18:39.808]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:39.808]                             info)
[16:18:39.808]                           info <- base::paste(info, collapse = "; ")
[16:18:39.808]                           if (!has_future) {
[16:18:39.808]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:39.808]                               info)
[16:18:39.808]                           }
[16:18:39.808]                           else {
[16:18:39.808]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:39.808]                               info, version)
[16:18:39.808]                           }
[16:18:39.808]                           base::stop(msg)
[16:18:39.808]                         }
[16:18:39.808]                       })
[16:18:39.808]                     }
[16:18:39.808]                     base::local({
[16:18:39.808]                       for (pkg in "stats") {
[16:18:39.808]                         base::loadNamespace(pkg)
[16:18:39.808]                         base::library(pkg, character.only = TRUE)
[16:18:39.808]                       }
[16:18:39.808]                     })
[16:18:39.808]                   }
[16:18:39.808]                   ...future.strategy.old <- future::plan("list")
[16:18:39.808]                   options(future.plan = NULL)
[16:18:39.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:39.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:39.808]                 }
[16:18:39.808]                 ...future.workdir <- getwd()
[16:18:39.808]             }
[16:18:39.808]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:39.808]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:39.808]         }
[16:18:39.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:39.808]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:39.808]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:39.808]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:39.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:39.808]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:39.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:39.808]             base::names(...future.oldOptions))
[16:18:39.808]     }
[16:18:39.808]     if (FALSE) {
[16:18:39.808]     }
[16:18:39.808]     else {
[16:18:39.808]         if (TRUE) {
[16:18:39.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:39.808]                 open = "w")
[16:18:39.808]         }
[16:18:39.808]         else {
[16:18:39.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:39.808]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:39.808]         }
[16:18:39.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:39.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:39.808]             base::sink(type = "output", split = FALSE)
[16:18:39.808]             base::close(...future.stdout)
[16:18:39.808]         }, add = TRUE)
[16:18:39.808]     }
[16:18:39.808]     ...future.frame <- base::sys.nframe()
[16:18:39.808]     ...future.conditions <- base::list()
[16:18:39.808]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:39.808]     if (FALSE) {
[16:18:39.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:39.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:39.808]     }
[16:18:39.808]     ...future.result <- base::tryCatch({
[16:18:39.808]         base::withCallingHandlers({
[16:18:39.808]             ...future.value <- base::withVisible(base::local({
[16:18:39.808]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:39.808]                 if (!identical(...future.globals.maxSize.org, 
[16:18:39.808]                   ...future.globals.maxSize)) {
[16:18:39.808]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:39.808]                   on.exit(options(oopts), add = TRUE)
[16:18:39.808]                 }
[16:18:39.808]                 {
[16:18:39.808]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:39.808]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[16:18:39.808]                       envir = globalenv(), inherits = FALSE)
[16:18:39.808]                     ...future.FUN(...)
[16:18:39.808]                   }
[16:18:39.808]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:39.808]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:39.808]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:39.808]                     USE.NAMES = FALSE)
[16:18:39.808]                   do.call(mapply, args = args)
[16:18:39.808]                 }
[16:18:39.808]             }))
[16:18:39.808]             future::FutureResult(value = ...future.value$value, 
[16:18:39.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:39.808]                   ...future.rng), globalenv = if (FALSE) 
[16:18:39.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:39.808]                     ...future.globalenv.names))
[16:18:39.808]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:39.808]         }, condition = base::local({
[16:18:39.808]             c <- base::c
[16:18:39.808]             inherits <- base::inherits
[16:18:39.808]             invokeRestart <- base::invokeRestart
[16:18:39.808]             length <- base::length
[16:18:39.808]             list <- base::list
[16:18:39.808]             seq.int <- base::seq.int
[16:18:39.808]             signalCondition <- base::signalCondition
[16:18:39.808]             sys.calls <- base::sys.calls
[16:18:39.808]             `[[` <- base::`[[`
[16:18:39.808]             `+` <- base::`+`
[16:18:39.808]             `<<-` <- base::`<<-`
[16:18:39.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:39.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:39.808]                   3L)]
[16:18:39.808]             }
[16:18:39.808]             function(cond) {
[16:18:39.808]                 is_error <- inherits(cond, "error")
[16:18:39.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:39.808]                   NULL)
[16:18:39.808]                 if (is_error) {
[16:18:39.808]                   sessionInformation <- function() {
[16:18:39.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:39.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:39.808]                       search = base::search(), system = base::Sys.info())
[16:18:39.808]                   }
[16:18:39.808]                   ...future.conditions[[length(...future.conditions) + 
[16:18:39.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:39.808]                     cond$call), session = sessionInformation(), 
[16:18:39.808]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:39.808]                   signalCondition(cond)
[16:18:39.808]                 }
[16:18:39.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:39.808]                 "immediateCondition"))) {
[16:18:39.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:39.808]                   ...future.conditions[[length(...future.conditions) + 
[16:18:39.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:39.808]                   if (TRUE && !signal) {
[16:18:39.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:39.808]                     {
[16:18:39.808]                       inherits <- base::inherits
[16:18:39.808]                       invokeRestart <- base::invokeRestart
[16:18:39.808]                       is.null <- base::is.null
[16:18:39.808]                       muffled <- FALSE
[16:18:39.808]                       if (inherits(cond, "message")) {
[16:18:39.808]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:39.808]                         if (muffled) 
[16:18:39.808]                           invokeRestart("muffleMessage")
[16:18:39.808]                       }
[16:18:39.808]                       else if (inherits(cond, "warning")) {
[16:18:39.808]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:39.808]                         if (muffled) 
[16:18:39.808]                           invokeRestart("muffleWarning")
[16:18:39.808]                       }
[16:18:39.808]                       else if (inherits(cond, "condition")) {
[16:18:39.808]                         if (!is.null(pattern)) {
[16:18:39.808]                           computeRestarts <- base::computeRestarts
[16:18:39.808]                           grepl <- base::grepl
[16:18:39.808]                           restarts <- computeRestarts(cond)
[16:18:39.808]                           for (restart in restarts) {
[16:18:39.808]                             name <- restart$name
[16:18:39.808]                             if (is.null(name)) 
[16:18:39.808]                               next
[16:18:39.808]                             if (!grepl(pattern, name)) 
[16:18:39.808]                               next
[16:18:39.808]                             invokeRestart(restart)
[16:18:39.808]                             muffled <- TRUE
[16:18:39.808]                             break
[16:18:39.808]                           }
[16:18:39.808]                         }
[16:18:39.808]                       }
[16:18:39.808]                       invisible(muffled)
[16:18:39.808]                     }
[16:18:39.808]                     muffleCondition(cond, pattern = "^muffle")
[16:18:39.808]                   }
[16:18:39.808]                 }
[16:18:39.808]                 else {
[16:18:39.808]                   if (TRUE) {
[16:18:39.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:39.808]                     {
[16:18:39.808]                       inherits <- base::inherits
[16:18:39.808]                       invokeRestart <- base::invokeRestart
[16:18:39.808]                       is.null <- base::is.null
[16:18:39.808]                       muffled <- FALSE
[16:18:39.808]                       if (inherits(cond, "message")) {
[16:18:39.808]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:39.808]                         if (muffled) 
[16:18:39.808]                           invokeRestart("muffleMessage")
[16:18:39.808]                       }
[16:18:39.808]                       else if (inherits(cond, "warning")) {
[16:18:39.808]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:39.808]                         if (muffled) 
[16:18:39.808]                           invokeRestart("muffleWarning")
[16:18:39.808]                       }
[16:18:39.808]                       else if (inherits(cond, "condition")) {
[16:18:39.808]                         if (!is.null(pattern)) {
[16:18:39.808]                           computeRestarts <- base::computeRestarts
[16:18:39.808]                           grepl <- base::grepl
[16:18:39.808]                           restarts <- computeRestarts(cond)
[16:18:39.808]                           for (restart in restarts) {
[16:18:39.808]                             name <- restart$name
[16:18:39.808]                             if (is.null(name)) 
[16:18:39.808]                               next
[16:18:39.808]                             if (!grepl(pattern, name)) 
[16:18:39.808]                               next
[16:18:39.808]                             invokeRestart(restart)
[16:18:39.808]                             muffled <- TRUE
[16:18:39.808]                             break
[16:18:39.808]                           }
[16:18:39.808]                         }
[16:18:39.808]                       }
[16:18:39.808]                       invisible(muffled)
[16:18:39.808]                     }
[16:18:39.808]                     muffleCondition(cond, pattern = "^muffle")
[16:18:39.808]                   }
[16:18:39.808]                 }
[16:18:39.808]             }
[16:18:39.808]         }))
[16:18:39.808]     }, error = function(ex) {
[16:18:39.808]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:39.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:39.808]                 ...future.rng), started = ...future.startTime, 
[16:18:39.808]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:39.808]             version = "1.8"), class = "FutureResult")
[16:18:39.808]     }, finally = {
[16:18:39.808]         if (!identical(...future.workdir, getwd())) 
[16:18:39.808]             setwd(...future.workdir)
[16:18:39.808]         {
[16:18:39.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:39.808]                 ...future.oldOptions$nwarnings <- NULL
[16:18:39.808]             }
[16:18:39.808]             base::options(...future.oldOptions)
[16:18:39.808]             if (.Platform$OS.type == "windows") {
[16:18:39.808]                 old_names <- names(...future.oldEnvVars)
[16:18:39.808]                 envs <- base::Sys.getenv()
[16:18:39.808]                 names <- names(envs)
[16:18:39.808]                 common <- intersect(names, old_names)
[16:18:39.808]                 added <- setdiff(names, old_names)
[16:18:39.808]                 removed <- setdiff(old_names, names)
[16:18:39.808]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:39.808]                   envs[common]]
[16:18:39.808]                 NAMES <- toupper(changed)
[16:18:39.808]                 args <- list()
[16:18:39.808]                 for (kk in seq_along(NAMES)) {
[16:18:39.808]                   name <- changed[[kk]]
[16:18:39.808]                   NAME <- NAMES[[kk]]
[16:18:39.808]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:39.808]                     next
[16:18:39.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:39.808]                 }
[16:18:39.808]                 NAMES <- toupper(added)
[16:18:39.808]                 for (kk in seq_along(NAMES)) {
[16:18:39.808]                   name <- added[[kk]]
[16:18:39.808]                   NAME <- NAMES[[kk]]
[16:18:39.808]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:39.808]                     next
[16:18:39.808]                   args[[name]] <- ""
[16:18:39.808]                 }
[16:18:39.808]                 NAMES <- toupper(removed)
[16:18:39.808]                 for (kk in seq_along(NAMES)) {
[16:18:39.808]                   name <- removed[[kk]]
[16:18:39.808]                   NAME <- NAMES[[kk]]
[16:18:39.808]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:39.808]                     next
[16:18:39.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:39.808]                 }
[16:18:39.808]                 if (length(args) > 0) 
[16:18:39.808]                   base::do.call(base::Sys.setenv, args = args)
[16:18:39.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:39.808]             }
[16:18:39.808]             else {
[16:18:39.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:39.808]             }
[16:18:39.808]             {
[16:18:39.808]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:39.808]                   0L) {
[16:18:39.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:39.808]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:39.808]                   base::options(opts)
[16:18:39.808]                 }
[16:18:39.808]                 {
[16:18:39.808]                   {
[16:18:39.808]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:39.808]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:39.808]                     -1742123538L), envir = base::globalenv(), 
[16:18:39.808]                       inherits = FALSE)
[16:18:39.808]                     NULL
[16:18:39.808]                   }
[16:18:39.808]                   options(future.plan = NULL)
[16:18:39.808]                   if (is.na(NA_character_)) 
[16:18:39.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:39.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:39.808]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:39.808]                     .init = FALSE)
[16:18:39.808]                 }
[16:18:39.808]             }
[16:18:39.808]         }
[16:18:39.808]     })
[16:18:39.808]     if (TRUE) {
[16:18:39.808]         base::sink(type = "output", split = FALSE)
[16:18:39.808]         if (TRUE) {
[16:18:39.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:39.808]         }
[16:18:39.808]         else {
[16:18:39.808]             ...future.result["stdout"] <- base::list(NULL)
[16:18:39.808]         }
[16:18:39.808]         base::close(...future.stdout)
[16:18:39.808]         ...future.stdout <- NULL
[16:18:39.808]     }
[16:18:39.808]     ...future.result$conditions <- ...future.conditions
[16:18:39.808]     ...future.result$finished <- base::Sys.time()
[16:18:39.808]     ...future.result
[16:18:39.808] }
[16:18:39.810] assign_globals() ...
[16:18:39.810] List of 5
[16:18:39.810]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[16:18:39.810]  $ MoreArgs                 :List of 1
[16:18:39.810]   ..$ min: num 1
[16:18:39.810]  $ ...future.elements_ii    :List of 2
[16:18:39.810]   ..$ n  :List of 4
[16:18:39.810]   .. ..$ : int 1
[16:18:39.810]   .. ..$ : int 2
[16:18:39.810]   .. ..$ : int 3
[16:18:39.810]   .. ..$ : int 4
[16:18:39.810]   ..$ max:List of 4
[16:18:39.810]   .. ..$ : int 2
[16:18:39.810]   .. ..$ : int 3
[16:18:39.810]   .. ..$ : int 4
[16:18:39.810]   .. ..$ : int 5
[16:18:39.810]  $ ...future.seeds_ii       :List of 4
[16:18:39.810]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[16:18:39.810]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[16:18:39.810]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[16:18:39.810]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[16:18:39.810]  $ ...future.globals.maxSize: NULL
[16:18:39.810]  - attr(*, "where")=List of 5
[16:18:39.810]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:39.810]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:39.810]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:39.810]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:39.810]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:39.810]  - attr(*, "resolved")= logi FALSE
[16:18:39.810]  - attr(*, "total_size")= num 2912
[16:18:39.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:39.810]  - attr(*, "already-done")= logi TRUE
[16:18:39.818] - copied ‘...future.FUN’ to environment
[16:18:39.819] - copied ‘MoreArgs’ to environment
[16:18:39.819] - copied ‘...future.elements_ii’ to environment
[16:18:39.819] - copied ‘...future.seeds_ii’ to environment
[16:18:39.819] - copied ‘...future.globals.maxSize’ to environment
[16:18:39.819] assign_globals() ... done
[16:18:39.819] plan(): Setting new future strategy stack:
[16:18:39.819] List of future strategies:
[16:18:39.819] 1. sequential:
[16:18:39.819]    - args: function (..., envir = parent.frame())
[16:18:39.819]    - tweaked: FALSE
[16:18:39.819]    - call: NULL
[16:18:39.820] plan(): nbrOfWorkers() = 1
[16:18:39.821] plan(): Setting new future strategy stack:
[16:18:39.821] List of future strategies:
[16:18:39.821] 1. sequential:
[16:18:39.821]    - args: function (..., envir = parent.frame())
[16:18:39.821]    - tweaked: FALSE
[16:18:39.821]    - call: plan(sequential)
[16:18:39.822] plan(): nbrOfWorkers() = 1
[16:18:39.822] SequentialFuture started (and completed)
[16:18:39.822] - Launch lazy future ... done
[16:18:39.822] run() for ‘SequentialFuture’ ... done
[16:18:39.822] Created future:
[16:18:39.823] SequentialFuture:
[16:18:39.823] Label: ‘future_mapply-1’
[16:18:39.823] Expression:
[16:18:39.823] {
[16:18:39.823]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:39.823]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:39.823]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:39.823]         on.exit(options(oopts), add = TRUE)
[16:18:39.823]     }
[16:18:39.823]     {
[16:18:39.823]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:39.823]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[16:18:39.823]                 inherits = FALSE)
[16:18:39.823]             ...future.FUN(...)
[16:18:39.823]         }
[16:18:39.823]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:39.823]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:39.823]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:39.823]         do.call(mapply, args = args)
[16:18:39.823]     }
[16:18:39.823] }
[16:18:39.823] Lazy evaluation: FALSE
[16:18:39.823] Asynchronous evaluation: FALSE
[16:18:39.823] Local evaluation: TRUE
[16:18:39.823] Environment: R_GlobalEnv
[16:18:39.823] Capture standard output: TRUE
[16:18:39.823] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:39.823] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:39.823] Packages: 1 packages (‘stats’)
[16:18:39.823] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:18:39.823] Resolved: TRUE
[16:18:39.823] Value: 280 bytes of class ‘list’
[16:18:39.823] Early signaling: FALSE
[16:18:39.823] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:39.823] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:39.824] Chunk #1 of 1 ... DONE
[16:18:39.824] Launching 1 futures (chunks) ... DONE
[16:18:39.824] Resolving 1 futures (chunks) ...
[16:18:39.825] resolve() on list ...
[16:18:39.825]  recursive: 0
[16:18:39.825]  length: 1
[16:18:39.825] 
[16:18:39.825] resolved() for ‘SequentialFuture’ ...
[16:18:39.825] - state: ‘finished’
[16:18:39.826] - run: TRUE
[16:18:39.826] - result: ‘FutureResult’
[16:18:39.826] resolved() for ‘SequentialFuture’ ... done
[16:18:39.826] Future #1
[16:18:39.828] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:39.828] - nx: 1
[16:18:39.828] - relay: TRUE
[16:18:39.828] - stdout: TRUE
[16:18:39.828] - signal: TRUE
[16:18:39.829] - resignal: FALSE
[16:18:39.829] - force: TRUE
[16:18:39.829] - relayed: [n=1] FALSE
[16:18:39.829] - queued futures: [n=1] FALSE
[16:18:39.829]  - until=1
[16:18:39.829]  - relaying element #1
[16:18:39.829] - relayed: [n=1] TRUE
[16:18:39.829] - queued futures: [n=1] TRUE
[16:18:39.829] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:39.830]  length: 0 (resolved future 1)
[16:18:39.830] Relaying remaining futures
[16:18:39.830] signalConditionsASAP(NULL, pos=0) ...
[16:18:39.830] - nx: 1
[16:18:39.830] - relay: TRUE
[16:18:39.830] - stdout: TRUE
[16:18:39.830] - signal: TRUE
[16:18:39.830] - resignal: FALSE
[16:18:39.830] - force: TRUE
[16:18:39.830] - relayed: [n=1] TRUE
[16:18:39.830] - queued futures: [n=1] TRUE
 - flush all
[16:18:39.831] - relayed: [n=1] TRUE
[16:18:39.831] - queued futures: [n=1] TRUE
[16:18:39.831] signalConditionsASAP(NULL, pos=0) ... done
[16:18:39.831] resolve() on list ... DONE
[16:18:39.831]  - Number of value chunks collected: 1
[16:18:39.831] Resolving 1 futures (chunks) ... DONE
[16:18:39.831] Reducing values from 1 chunks ...
[16:18:39.831]  - Number of values collected after concatenation: 4
[16:18:39.831]  - Number of values expected: 4
[16:18:39.832] Reducing values from 1 chunks ... DONE
[16:18:39.832] future_mapply() ... DONE
> print(y_rng_0)
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(mapply) ...")
+   y0 <- mapply(rep, 1:4, 4:1)
+   y1 <- future_mapply(rep, 1:4, 4:1)
+   stopifnot(identical(y1, y0))
+   y2 <- future_mapply("rep", 1:4, 4:1)
+   stopifnot(identical(y2, y0))
+   
+   y0 <- mapply(rep, times = 1:4, x = 4:1)
+   y1 <- future_mapply(rep, times = 1:4, x = 4:1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(function(x, y) seq_len(x) + y,
+                c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                       c(a =  1, b = 2, c = 3),  # names from first
+                       c(A = 10, B = 0, C = -10))
+   stopifnot(identical(y1, y0))
+ 
+   message("- future_.mapply()")
+   dots <- list(c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y2 <- .mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   names(y0) <- NULL  ## .mapply() don't set names
+   stopifnot(all.equal(y2, y0))
+   y3 <- future_.mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   stopifnot(all.equal(y3, y2))
+ 
+   word <- function(C, k) paste(rep.int(C, k), collapse = "")
+   for (chunk.size in list(1L, structure(2L, ordering = "random"), structure(3L, ordering = 5:1))) {
+     y0 <- mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE)
+     y1 <- future_mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE, future.chunk.size = chunk.size)
+     stopifnot(identical(y1, y0))
+ 
+     dots <- list(LETTERS[1:5], 5:1)
+     MoreArgs <- list()
+     y2 <- .mapply(word, dots = dots, MoreArgs = list())
+     names(y0) <- NULL  ## .mapply() don't set names
+     stopifnot(all.equal(y2, y0))
+     y3 <- future_.mapply(word, dots = dots, MoreArgs = list())
+     stopifnot(all.equal(y3, y2))
+   }
+ 
+   message("- Subsetting (Issue #17) ...")
+   X <- as.Date("2018-06-01")
+   y0 <- mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   y1 <- future_mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   stopifnot(identical(y1, y0))
+ 
+   dots <- list(X)
+   y2 <- .mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y2, y0))
+   y3 <- future_.mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y3, y2))
+ 
+   message("- Non-recycling of MoreArgs (Issue #51) ...")
+   y0 <- base::mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4)
+   )
+   y1 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = FALSE
+   )
+   stopifnot(identical(y1, y0))
+   y2 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = TRUE
+   )
+   stopifnot(identical(y2, y0))
+ 
+   dots <- list(x = 1:2)
+   MoreArgs <- list(y = 3:4)
+   y3 <- .mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   y4 <- future_.mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y4, y3))
+ 
+   message("- Recycle arguments to same length ...")
+   y0 <- mapply(rep, 1:4, 2:1)
+   y1 <- future_mapply(rep, 1:4, 2:1)
+   stopifnot(identical(y1, y0))
+ 
+   
+   message("- Parallel RNG ...")
+   y_rng_1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                            MoreArgs = list(min = 1), future.seed = 0xBEEF)
+   print(y_rng_1)
+   stopifnot(all.equal(y_rng_1, y_rng_0))
+ 
+   message("- future_Map() ...")
+   xs <- replicate(5, stats::runif(10), simplify = FALSE)
+   ws <- replicate(5, stats::rpois(10, 5) + 1, simplify = FALSE)
+   y0 <- Map(weighted.mean, xs, ws)
+   y1 <- future_Map(stats::weighted.mean, xs, ws)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_mapply() - 'max-or-0-if' recycling rule ...")
+   ## R (>= 4.2.0): mapply() & Map() follow usual "max-or-0-if" recycling rule
+   ## and keeps returning a named list in the "empty" case.
+   
+   truth <- list()
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(`+`, 1:3, NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(`+`, 1:3, NULL)
+   stopifnot(identical(y, truth))
+   
+   truth <- setNames(list(), character())
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character())
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character()) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character()) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+ 
+   ## Gives an error in R-devel (2021-11-26 r81252)
+   if (getRversion() >= "4.2.0" && FALSE) {
+     y0 <- mapply(paste, c(a = "A"), character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, c(a = "A"), character())
+   stopifnot(identical(y, truth))
+ 
+   ## R (>= 4.2.0): Map() now recycles similar to basic Ops:
+   truth <- as.list(1 + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, 1, 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, 1, 1:3)
+   stopifnot(identical(y, truth))
+   
+   truth <- as.list(numeric() + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, numeric(), 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, numeric(), 1:3)
+   stopifnot(identical(y, truth))
+ 
+   message("- future_mapply(x, ...) where x[[i]] subsets via S3 method ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   `[[.Foo` <- function(x, ...) 0
+   y0 <- mapply(x, FUN = identity)
+   stopifnot(identical(y0, c(a = 0, b = 0)))
+   y1 <- future_mapply(x, FUN = identity)
+   if (getOption("future.apply.chunkWith", "[[") == "[") {
+     stopifnot(identical(y1, unlist(x)))
+   } else {
+     stopifnot(identical(y1, y0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:18:39.989] plan(): Setting new future strategy stack:
[16:18:39.989] List of future strategies:
[16:18:39.989] 1. sequential:
[16:18:39.989]    - args: function (..., envir = parent.frame())
[16:18:39.989]    - tweaked: FALSE
[16:18:39.989]    - call: plan(strategy)
[16:18:39.990] plan(): nbrOfWorkers() = 1
- From example(mapply) ...
[16:18:39.990] future_mapply() ...
[16:18:39.990] Number of chunks: 1
[16:18:39.990] getGlobalsAndPackagesXApply() ...
[16:18:39.990]  - future.globals: TRUE
[16:18:39.991] getGlobalsAndPackages() ...
[16:18:39.991] Searching for globals...
[16:18:39.991] - globals found: [1] ‘FUN’
[16:18:39.991] Searching for globals ... DONE
[16:18:39.991] Resolving globals: FALSE
[16:18:39.992] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:39.992] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:39.992] - globals: [1] ‘FUN’
[16:18:39.992] 
[16:18:39.992] getGlobalsAndPackages() ... DONE
[16:18:39.992]  - globals found/used: [n=1] ‘FUN’
[16:18:39.993]  - needed namespaces: [n=0] 
[16:18:39.993] Finding globals ... DONE
[16:18:39.993] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:39.993] List of 2
[16:18:39.993]  $ ...future.FUN:function (x, ...)  
[16:18:39.993]  $ MoreArgs     : NULL
[16:18:39.993]  - attr(*, "where")=List of 2
[16:18:39.993]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:39.993]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:39.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:39.993]  - attr(*, "resolved")= logi FALSE
[16:18:39.993]  - attr(*, "total_size")= num NA
[16:18:39.995] Packages to be attached in all futures: [n=0] 
[16:18:39.995] getGlobalsAndPackagesXApply() ... DONE
[16:18:39.996] Number of futures (= number of chunks): 1
[16:18:39.996] Launching 1 futures (chunks) ...
[16:18:39.996] Chunk #1 of 1 ...
[16:18:39.996]  - Finding globals in '...' for chunk #1 ...
[16:18:39.996] getGlobalsAndPackages() ...
[16:18:39.996] Searching for globals...
[16:18:39.996] 
[16:18:39.997] Searching for globals ... DONE
[16:18:39.997] - globals: [0] <none>
[16:18:39.997] getGlobalsAndPackages() ... DONE
[16:18:39.997]    + additional globals found: [n=0] 
[16:18:39.997]    + additional namespaces needed: [n=0] 
[16:18:39.997]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:39.997]  - seeds: <none>
[16:18:39.997]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:39.997] getGlobalsAndPackages() ...
[16:18:39.997] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:39.997] Resolving globals: FALSE
[16:18:39.998] The total size of the 5 globals is 504 bytes (504 bytes)
[16:18:39.998] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:39.998] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:39.999] 
[16:18:39.999] getGlobalsAndPackages() ... DONE
[16:18:39.999] run() for ‘Future’ ...
[16:18:39.999] - state: ‘created’
[16:18:39.999] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:39.999] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.000] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.000]   - Field: ‘label’
[16:18:40.000]   - Field: ‘local’
[16:18:40.000]   - Field: ‘owner’
[16:18:40.000]   - Field: ‘envir’
[16:18:40.000]   - Field: ‘packages’
[16:18:40.000]   - Field: ‘gc’
[16:18:40.000]   - Field: ‘conditions’
[16:18:40.000]   - Field: ‘expr’
[16:18:40.000]   - Field: ‘uuid’
[16:18:40.001]   - Field: ‘seed’
[16:18:40.001]   - Field: ‘version’
[16:18:40.001]   - Field: ‘result’
[16:18:40.001]   - Field: ‘asynchronous’
[16:18:40.001]   - Field: ‘calls’
[16:18:40.001]   - Field: ‘globals’
[16:18:40.001]   - Field: ‘stdout’
[16:18:40.001]   - Field: ‘earlySignal’
[16:18:40.001]   - Field: ‘lazy’
[16:18:40.001]   - Field: ‘state’
[16:18:40.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.002] - Launch lazy future ...
[16:18:40.002] Packages needed by the future expression (n = 0): <none>
[16:18:40.002] Packages needed by future strategies (n = 0): <none>
[16:18:40.002] {
[16:18:40.002]     {
[16:18:40.002]         {
[16:18:40.002]             ...future.startTime <- base::Sys.time()
[16:18:40.002]             {
[16:18:40.002]                 {
[16:18:40.002]                   {
[16:18:40.002]                     base::local({
[16:18:40.002]                       has_future <- base::requireNamespace("future", 
[16:18:40.002]                         quietly = TRUE)
[16:18:40.002]                       if (has_future) {
[16:18:40.002]                         ns <- base::getNamespace("future")
[16:18:40.002]                         version <- ns[[".package"]][["version"]]
[16:18:40.002]                         if (is.null(version)) 
[16:18:40.002]                           version <- utils::packageVersion("future")
[16:18:40.002]                       }
[16:18:40.002]                       else {
[16:18:40.002]                         version <- NULL
[16:18:40.002]                       }
[16:18:40.002]                       if (!has_future || version < "1.8.0") {
[16:18:40.002]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.002]                           "", base::R.version$version.string), 
[16:18:40.002]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.002]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.002]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.002]                             "release", "version")], collapse = " "), 
[16:18:40.002]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.002]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.002]                           info)
[16:18:40.002]                         info <- base::paste(info, collapse = "; ")
[16:18:40.002]                         if (!has_future) {
[16:18:40.002]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.002]                             info)
[16:18:40.002]                         }
[16:18:40.002]                         else {
[16:18:40.002]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.002]                             info, version)
[16:18:40.002]                         }
[16:18:40.002]                         base::stop(msg)
[16:18:40.002]                       }
[16:18:40.002]                     })
[16:18:40.002]                   }
[16:18:40.002]                   ...future.strategy.old <- future::plan("list")
[16:18:40.002]                   options(future.plan = NULL)
[16:18:40.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.002]                 }
[16:18:40.002]                 ...future.workdir <- getwd()
[16:18:40.002]             }
[16:18:40.002]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.002]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.002]         }
[16:18:40.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.002]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.002]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.002]             base::names(...future.oldOptions))
[16:18:40.002]     }
[16:18:40.002]     if (FALSE) {
[16:18:40.002]     }
[16:18:40.002]     else {
[16:18:40.002]         if (TRUE) {
[16:18:40.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.002]                 open = "w")
[16:18:40.002]         }
[16:18:40.002]         else {
[16:18:40.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.002]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.002]         }
[16:18:40.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.002]             base::sink(type = "output", split = FALSE)
[16:18:40.002]             base::close(...future.stdout)
[16:18:40.002]         }, add = TRUE)
[16:18:40.002]     }
[16:18:40.002]     ...future.frame <- base::sys.nframe()
[16:18:40.002]     ...future.conditions <- base::list()
[16:18:40.002]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.002]     if (FALSE) {
[16:18:40.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.002]     }
[16:18:40.002]     ...future.result <- base::tryCatch({
[16:18:40.002]         base::withCallingHandlers({
[16:18:40.002]             ...future.value <- base::withVisible(base::local({
[16:18:40.002]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.002]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.002]                   ...future.globals.maxSize)) {
[16:18:40.002]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.002]                   on.exit(options(oopts), add = TRUE)
[16:18:40.002]                 }
[16:18:40.002]                 {
[16:18:40.002]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.002]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.002]                     USE.NAMES = FALSE)
[16:18:40.002]                   do.call(mapply, args = args)
[16:18:40.002]                 }
[16:18:40.002]             }))
[16:18:40.002]             future::FutureResult(value = ...future.value$value, 
[16:18:40.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.002]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.002]                     ...future.globalenv.names))
[16:18:40.002]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.002]         }, condition = base::local({
[16:18:40.002]             c <- base::c
[16:18:40.002]             inherits <- base::inherits
[16:18:40.002]             invokeRestart <- base::invokeRestart
[16:18:40.002]             length <- base::length
[16:18:40.002]             list <- base::list
[16:18:40.002]             seq.int <- base::seq.int
[16:18:40.002]             signalCondition <- base::signalCondition
[16:18:40.002]             sys.calls <- base::sys.calls
[16:18:40.002]             `[[` <- base::`[[`
[16:18:40.002]             `+` <- base::`+`
[16:18:40.002]             `<<-` <- base::`<<-`
[16:18:40.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.002]                   3L)]
[16:18:40.002]             }
[16:18:40.002]             function(cond) {
[16:18:40.002]                 is_error <- inherits(cond, "error")
[16:18:40.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.002]                   NULL)
[16:18:40.002]                 if (is_error) {
[16:18:40.002]                   sessionInformation <- function() {
[16:18:40.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.002]                       search = base::search(), system = base::Sys.info())
[16:18:40.002]                   }
[16:18:40.002]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.002]                     cond$call), session = sessionInformation(), 
[16:18:40.002]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.002]                   signalCondition(cond)
[16:18:40.002]                 }
[16:18:40.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.002]                 "immediateCondition"))) {
[16:18:40.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.002]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.002]                   if (TRUE && !signal) {
[16:18:40.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.002]                     {
[16:18:40.002]                       inherits <- base::inherits
[16:18:40.002]                       invokeRestart <- base::invokeRestart
[16:18:40.002]                       is.null <- base::is.null
[16:18:40.002]                       muffled <- FALSE
[16:18:40.002]                       if (inherits(cond, "message")) {
[16:18:40.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.002]                         if (muffled) 
[16:18:40.002]                           invokeRestart("muffleMessage")
[16:18:40.002]                       }
[16:18:40.002]                       else if (inherits(cond, "warning")) {
[16:18:40.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.002]                         if (muffled) 
[16:18:40.002]                           invokeRestart("muffleWarning")
[16:18:40.002]                       }
[16:18:40.002]                       else if (inherits(cond, "condition")) {
[16:18:40.002]                         if (!is.null(pattern)) {
[16:18:40.002]                           computeRestarts <- base::computeRestarts
[16:18:40.002]                           grepl <- base::grepl
[16:18:40.002]                           restarts <- computeRestarts(cond)
[16:18:40.002]                           for (restart in restarts) {
[16:18:40.002]                             name <- restart$name
[16:18:40.002]                             if (is.null(name)) 
[16:18:40.002]                               next
[16:18:40.002]                             if (!grepl(pattern, name)) 
[16:18:40.002]                               next
[16:18:40.002]                             invokeRestart(restart)
[16:18:40.002]                             muffled <- TRUE
[16:18:40.002]                             break
[16:18:40.002]                           }
[16:18:40.002]                         }
[16:18:40.002]                       }
[16:18:40.002]                       invisible(muffled)
[16:18:40.002]                     }
[16:18:40.002]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.002]                   }
[16:18:40.002]                 }
[16:18:40.002]                 else {
[16:18:40.002]                   if (TRUE) {
[16:18:40.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.002]                     {
[16:18:40.002]                       inherits <- base::inherits
[16:18:40.002]                       invokeRestart <- base::invokeRestart
[16:18:40.002]                       is.null <- base::is.null
[16:18:40.002]                       muffled <- FALSE
[16:18:40.002]                       if (inherits(cond, "message")) {
[16:18:40.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.002]                         if (muffled) 
[16:18:40.002]                           invokeRestart("muffleMessage")
[16:18:40.002]                       }
[16:18:40.002]                       else if (inherits(cond, "warning")) {
[16:18:40.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.002]                         if (muffled) 
[16:18:40.002]                           invokeRestart("muffleWarning")
[16:18:40.002]                       }
[16:18:40.002]                       else if (inherits(cond, "condition")) {
[16:18:40.002]                         if (!is.null(pattern)) {
[16:18:40.002]                           computeRestarts <- base::computeRestarts
[16:18:40.002]                           grepl <- base::grepl
[16:18:40.002]                           restarts <- computeRestarts(cond)
[16:18:40.002]                           for (restart in restarts) {
[16:18:40.002]                             name <- restart$name
[16:18:40.002]                             if (is.null(name)) 
[16:18:40.002]                               next
[16:18:40.002]                             if (!grepl(pattern, name)) 
[16:18:40.002]                               next
[16:18:40.002]                             invokeRestart(restart)
[16:18:40.002]                             muffled <- TRUE
[16:18:40.002]                             break
[16:18:40.002]                           }
[16:18:40.002]                         }
[16:18:40.002]                       }
[16:18:40.002]                       invisible(muffled)
[16:18:40.002]                     }
[16:18:40.002]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.002]                   }
[16:18:40.002]                 }
[16:18:40.002]             }
[16:18:40.002]         }))
[16:18:40.002]     }, error = function(ex) {
[16:18:40.002]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.002]                 ...future.rng), started = ...future.startTime, 
[16:18:40.002]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.002]             version = "1.8"), class = "FutureResult")
[16:18:40.002]     }, finally = {
[16:18:40.002]         if (!identical(...future.workdir, getwd())) 
[16:18:40.002]             setwd(...future.workdir)
[16:18:40.002]         {
[16:18:40.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.002]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.002]             }
[16:18:40.002]             base::options(...future.oldOptions)
[16:18:40.002]             if (.Platform$OS.type == "windows") {
[16:18:40.002]                 old_names <- names(...future.oldEnvVars)
[16:18:40.002]                 envs <- base::Sys.getenv()
[16:18:40.002]                 names <- names(envs)
[16:18:40.002]                 common <- intersect(names, old_names)
[16:18:40.002]                 added <- setdiff(names, old_names)
[16:18:40.002]                 removed <- setdiff(old_names, names)
[16:18:40.002]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.002]                   envs[common]]
[16:18:40.002]                 NAMES <- toupper(changed)
[16:18:40.002]                 args <- list()
[16:18:40.002]                 for (kk in seq_along(NAMES)) {
[16:18:40.002]                   name <- changed[[kk]]
[16:18:40.002]                   NAME <- NAMES[[kk]]
[16:18:40.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.002]                     next
[16:18:40.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.002]                 }
[16:18:40.002]                 NAMES <- toupper(added)
[16:18:40.002]                 for (kk in seq_along(NAMES)) {
[16:18:40.002]                   name <- added[[kk]]
[16:18:40.002]                   NAME <- NAMES[[kk]]
[16:18:40.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.002]                     next
[16:18:40.002]                   args[[name]] <- ""
[16:18:40.002]                 }
[16:18:40.002]                 NAMES <- toupper(removed)
[16:18:40.002]                 for (kk in seq_along(NAMES)) {
[16:18:40.002]                   name <- removed[[kk]]
[16:18:40.002]                   NAME <- NAMES[[kk]]
[16:18:40.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.002]                     next
[16:18:40.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.002]                 }
[16:18:40.002]                 if (length(args) > 0) 
[16:18:40.002]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.002]             }
[16:18:40.002]             else {
[16:18:40.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.002]             }
[16:18:40.002]             {
[16:18:40.002]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.002]                   0L) {
[16:18:40.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.002]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.002]                   base::options(opts)
[16:18:40.002]                 }
[16:18:40.002]                 {
[16:18:40.002]                   {
[16:18:40.002]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.002]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.002]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.002]                       inherits = FALSE)
[16:18:40.002]                     NULL
[16:18:40.002]                   }
[16:18:40.002]                   options(future.plan = NULL)
[16:18:40.002]                   if (is.na(NA_character_)) 
[16:18:40.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.002]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.002]                     .init = FALSE)
[16:18:40.002]                 }
[16:18:40.002]             }
[16:18:40.002]         }
[16:18:40.002]     })
[16:18:40.002]     if (TRUE) {
[16:18:40.002]         base::sink(type = "output", split = FALSE)
[16:18:40.002]         if (TRUE) {
[16:18:40.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.002]         }
[16:18:40.002]         else {
[16:18:40.002]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.002]         }
[16:18:40.002]         base::close(...future.stdout)
[16:18:40.002]         ...future.stdout <- NULL
[16:18:40.002]     }
[16:18:40.002]     ...future.result$conditions <- ...future.conditions
[16:18:40.002]     ...future.result$finished <- base::Sys.time()
[16:18:40.002]     ...future.result
[16:18:40.002] }
[16:18:40.004] assign_globals() ...
[16:18:40.004] List of 5
[16:18:40.004]  $ ...future.FUN            :function (x, ...)  
[16:18:40.004]  $ MoreArgs                 : NULL
[16:18:40.004]  $ ...future.elements_ii    :List of 2
[16:18:40.004]   ..$ :List of 4
[16:18:40.004]   .. ..$ : int 1
[16:18:40.004]   .. ..$ : int 2
[16:18:40.004]   .. ..$ : int 3
[16:18:40.004]   .. ..$ : int 4
[16:18:40.004]   ..$ :List of 4
[16:18:40.004]   .. ..$ : int 4
[16:18:40.004]   .. ..$ : int 3
[16:18:40.004]   .. ..$ : int 2
[16:18:40.004]   .. ..$ : int 1
[16:18:40.004]  $ ...future.seeds_ii       : NULL
[16:18:40.004]  $ ...future.globals.maxSize: NULL
[16:18:40.004]  - attr(*, "where")=List of 5
[16:18:40.004]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.004]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.004]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.004]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.004]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.004]  - attr(*, "resolved")= logi FALSE
[16:18:40.004]  - attr(*, "total_size")= num 504
[16:18:40.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.004]  - attr(*, "already-done")= logi TRUE
[16:18:40.012] - copied ‘...future.FUN’ to environment
[16:18:40.012] - copied ‘MoreArgs’ to environment
[16:18:40.012] - copied ‘...future.elements_ii’ to environment
[16:18:40.012] - copied ‘...future.seeds_ii’ to environment
[16:18:40.012] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.013] assign_globals() ... done
[16:18:40.013] plan(): Setting new future strategy stack:
[16:18:40.013] List of future strategies:
[16:18:40.013] 1. sequential:
[16:18:40.013]    - args: function (..., envir = parent.frame())
[16:18:40.013]    - tweaked: FALSE
[16:18:40.013]    - call: NULL
[16:18:40.013] plan(): nbrOfWorkers() = 1
[16:18:40.014] plan(): Setting new future strategy stack:
[16:18:40.014] List of future strategies:
[16:18:40.014] 1. sequential:
[16:18:40.014]    - args: function (..., envir = parent.frame())
[16:18:40.014]    - tweaked: FALSE
[16:18:40.014]    - call: plan(strategy)
[16:18:40.014] plan(): nbrOfWorkers() = 1
[16:18:40.015] SequentialFuture started (and completed)
[16:18:40.015] - Launch lazy future ... done
[16:18:40.015] run() for ‘SequentialFuture’ ... done
[16:18:40.015] Created future:
[16:18:40.015] SequentialFuture:
[16:18:40.015] Label: ‘future_mapply-1’
[16:18:40.015] Expression:
[16:18:40.015] {
[16:18:40.015]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.015]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.015]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.015]         on.exit(options(oopts), add = TRUE)
[16:18:40.015]     }
[16:18:40.015]     {
[16:18:40.015]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.015]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.015]         do.call(mapply, args = args)
[16:18:40.015]     }
[16:18:40.015] }
[16:18:40.015] Lazy evaluation: FALSE
[16:18:40.015] Asynchronous evaluation: FALSE
[16:18:40.015] Local evaluation: TRUE
[16:18:40.015] Environment: R_GlobalEnv
[16:18:40.015] Capture standard output: TRUE
[16:18:40.015] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.015] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.015] Packages: <none>
[16:18:40.015] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.015] Resolved: TRUE
[16:18:40.015] Value: 240 bytes of class ‘list’
[16:18:40.015] Early signaling: FALSE
[16:18:40.015] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.015] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.016] Chunk #1 of 1 ... DONE
[16:18:40.016] Launching 1 futures (chunks) ... DONE
[16:18:40.016] Resolving 1 futures (chunks) ...
[16:18:40.016] resolve() on list ...
[16:18:40.016]  recursive: 0
[16:18:40.016]  length: 1
[16:18:40.016] 
[16:18:40.017] resolved() for ‘SequentialFuture’ ...
[16:18:40.017] - state: ‘finished’
[16:18:40.017] - run: TRUE
[16:18:40.017] - result: ‘FutureResult’
[16:18:40.017] resolved() for ‘SequentialFuture’ ... done
[16:18:40.017] Future #1
[16:18:40.017] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.017] - nx: 1
[16:18:40.017] - relay: TRUE
[16:18:40.017] - stdout: TRUE
[16:18:40.017] - signal: TRUE
[16:18:40.018] - resignal: FALSE
[16:18:40.018] - force: TRUE
[16:18:40.018] - relayed: [n=1] FALSE
[16:18:40.018] - queued futures: [n=1] FALSE
[16:18:40.018]  - until=1
[16:18:40.018]  - relaying element #1
[16:18:40.018] - relayed: [n=1] TRUE
[16:18:40.018] - queued futures: [n=1] TRUE
[16:18:40.018] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.018]  length: 0 (resolved future 1)
[16:18:40.019] Relaying remaining futures
[16:18:40.019] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.019] - nx: 1
[16:18:40.019] - relay: TRUE
[16:18:40.019] - stdout: TRUE
[16:18:40.019] - signal: TRUE
[16:18:40.019] - resignal: FALSE
[16:18:40.019] - force: TRUE
[16:18:40.019] - relayed: [n=1] TRUE
[16:18:40.019] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.019] - relayed: [n=1] TRUE
[16:18:40.019] - queued futures: [n=1] TRUE
[16:18:40.020] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.020] resolve() on list ... DONE
[16:18:40.020]  - Number of value chunks collected: 1
[16:18:40.020] Resolving 1 futures (chunks) ... DONE
[16:18:40.020] Reducing values from 1 chunks ...
[16:18:40.020]  - Number of values collected after concatenation: 4
[16:18:40.020]  - Number of values expected: 4
[16:18:40.020] Reducing values from 1 chunks ... DONE
[16:18:40.020] future_mapply() ... DONE
[16:18:40.020] future_mapply() ...
[16:18:40.021] Number of chunks: 1
[16:18:40.021] getGlobalsAndPackagesXApply() ...
[16:18:40.021]  - future.globals: TRUE
[16:18:40.021] getGlobalsAndPackages() ...
[16:18:40.021] Searching for globals...
[16:18:40.021] - globals found: [1] ‘FUN’
[16:18:40.022] Searching for globals ... DONE
[16:18:40.022] Resolving globals: FALSE
[16:18:40.022] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:40.022] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:40.022] - globals: [1] ‘FUN’
[16:18:40.022] 
[16:18:40.023] getGlobalsAndPackages() ... DONE
[16:18:40.023]  - globals found/used: [n=1] ‘FUN’
[16:18:40.023]  - needed namespaces: [n=0] 
[16:18:40.023] Finding globals ... DONE
[16:18:40.023] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.023] List of 2
[16:18:40.023]  $ ...future.FUN:function (x, ...)  
[16:18:40.023]  $ MoreArgs     : NULL
[16:18:40.023]  - attr(*, "where")=List of 2
[16:18:40.023]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.023]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.023]  - attr(*, "resolved")= logi FALSE
[16:18:40.023]  - attr(*, "total_size")= num NA
[16:18:40.025] Packages to be attached in all futures: [n=0] 
[16:18:40.025] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.026] Number of futures (= number of chunks): 1
[16:18:40.026] Launching 1 futures (chunks) ...
[16:18:40.026] Chunk #1 of 1 ...
[16:18:40.026]  - Finding globals in '...' for chunk #1 ...
[16:18:40.026] getGlobalsAndPackages() ...
[16:18:40.026] Searching for globals...
[16:18:40.026] 
[16:18:40.027] Searching for globals ... DONE
[16:18:40.027] - globals: [0] <none>
[16:18:40.027] getGlobalsAndPackages() ... DONE
[16:18:40.027]    + additional globals found: [n=0] 
[16:18:40.027]    + additional namespaces needed: [n=0] 
[16:18:40.027]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.027]  - seeds: <none>
[16:18:40.027]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.027] getGlobalsAndPackages() ...
[16:18:40.027] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.027] Resolving globals: FALSE
[16:18:40.028] The total size of the 5 globals is 504 bytes (504 bytes)
[16:18:40.028] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.029] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.029] 
[16:18:40.029] getGlobalsAndPackages() ... DONE
[16:18:40.029] run() for ‘Future’ ...
[16:18:40.029] - state: ‘created’
[16:18:40.029] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.029] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.030] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.030]   - Field: ‘label’
[16:18:40.030]   - Field: ‘local’
[16:18:40.030]   - Field: ‘owner’
[16:18:40.030]   - Field: ‘envir’
[16:18:40.030]   - Field: ‘packages’
[16:18:40.030]   - Field: ‘gc’
[16:18:40.030]   - Field: ‘conditions’
[16:18:40.030]   - Field: ‘expr’
[16:18:40.030]   - Field: ‘uuid’
[16:18:40.031]   - Field: ‘seed’
[16:18:40.031]   - Field: ‘version’
[16:18:40.031]   - Field: ‘result’
[16:18:40.031]   - Field: ‘asynchronous’
[16:18:40.031]   - Field: ‘calls’
[16:18:40.031]   - Field: ‘globals’
[16:18:40.031]   - Field: ‘stdout’
[16:18:40.031]   - Field: ‘earlySignal’
[16:18:40.031]   - Field: ‘lazy’
[16:18:40.031]   - Field: ‘state’
[16:18:40.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.033] - Launch lazy future ...
[16:18:40.033] Packages needed by the future expression (n = 0): <none>
[16:18:40.033] Packages needed by future strategies (n = 0): <none>
[16:18:40.033] {
[16:18:40.033]     {
[16:18:40.033]         {
[16:18:40.033]             ...future.startTime <- base::Sys.time()
[16:18:40.033]             {
[16:18:40.033]                 {
[16:18:40.033]                   {
[16:18:40.033]                     base::local({
[16:18:40.033]                       has_future <- base::requireNamespace("future", 
[16:18:40.033]                         quietly = TRUE)
[16:18:40.033]                       if (has_future) {
[16:18:40.033]                         ns <- base::getNamespace("future")
[16:18:40.033]                         version <- ns[[".package"]][["version"]]
[16:18:40.033]                         if (is.null(version)) 
[16:18:40.033]                           version <- utils::packageVersion("future")
[16:18:40.033]                       }
[16:18:40.033]                       else {
[16:18:40.033]                         version <- NULL
[16:18:40.033]                       }
[16:18:40.033]                       if (!has_future || version < "1.8.0") {
[16:18:40.033]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.033]                           "", base::R.version$version.string), 
[16:18:40.033]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.033]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.033]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.033]                             "release", "version")], collapse = " "), 
[16:18:40.033]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.033]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.033]                           info)
[16:18:40.033]                         info <- base::paste(info, collapse = "; ")
[16:18:40.033]                         if (!has_future) {
[16:18:40.033]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.033]                             info)
[16:18:40.033]                         }
[16:18:40.033]                         else {
[16:18:40.033]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.033]                             info, version)
[16:18:40.033]                         }
[16:18:40.033]                         base::stop(msg)
[16:18:40.033]                       }
[16:18:40.033]                     })
[16:18:40.033]                   }
[16:18:40.033]                   ...future.strategy.old <- future::plan("list")
[16:18:40.033]                   options(future.plan = NULL)
[16:18:40.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.033]                 }
[16:18:40.033]                 ...future.workdir <- getwd()
[16:18:40.033]             }
[16:18:40.033]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.033]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.033]         }
[16:18:40.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.033]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.033]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.033]             base::names(...future.oldOptions))
[16:18:40.033]     }
[16:18:40.033]     if (FALSE) {
[16:18:40.033]     }
[16:18:40.033]     else {
[16:18:40.033]         if (TRUE) {
[16:18:40.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.033]                 open = "w")
[16:18:40.033]         }
[16:18:40.033]         else {
[16:18:40.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.033]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.033]         }
[16:18:40.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.033]             base::sink(type = "output", split = FALSE)
[16:18:40.033]             base::close(...future.stdout)
[16:18:40.033]         }, add = TRUE)
[16:18:40.033]     }
[16:18:40.033]     ...future.frame <- base::sys.nframe()
[16:18:40.033]     ...future.conditions <- base::list()
[16:18:40.033]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.033]     if (FALSE) {
[16:18:40.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.033]     }
[16:18:40.033]     ...future.result <- base::tryCatch({
[16:18:40.033]         base::withCallingHandlers({
[16:18:40.033]             ...future.value <- base::withVisible(base::local({
[16:18:40.033]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.033]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.033]                   ...future.globals.maxSize)) {
[16:18:40.033]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.033]                   on.exit(options(oopts), add = TRUE)
[16:18:40.033]                 }
[16:18:40.033]                 {
[16:18:40.033]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.033]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.033]                     USE.NAMES = FALSE)
[16:18:40.033]                   do.call(mapply, args = args)
[16:18:40.033]                 }
[16:18:40.033]             }))
[16:18:40.033]             future::FutureResult(value = ...future.value$value, 
[16:18:40.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.033]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.033]                     ...future.globalenv.names))
[16:18:40.033]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.033]         }, condition = base::local({
[16:18:40.033]             c <- base::c
[16:18:40.033]             inherits <- base::inherits
[16:18:40.033]             invokeRestart <- base::invokeRestart
[16:18:40.033]             length <- base::length
[16:18:40.033]             list <- base::list
[16:18:40.033]             seq.int <- base::seq.int
[16:18:40.033]             signalCondition <- base::signalCondition
[16:18:40.033]             sys.calls <- base::sys.calls
[16:18:40.033]             `[[` <- base::`[[`
[16:18:40.033]             `+` <- base::`+`
[16:18:40.033]             `<<-` <- base::`<<-`
[16:18:40.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.033]                   3L)]
[16:18:40.033]             }
[16:18:40.033]             function(cond) {
[16:18:40.033]                 is_error <- inherits(cond, "error")
[16:18:40.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.033]                   NULL)
[16:18:40.033]                 if (is_error) {
[16:18:40.033]                   sessionInformation <- function() {
[16:18:40.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.033]                       search = base::search(), system = base::Sys.info())
[16:18:40.033]                   }
[16:18:40.033]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.033]                     cond$call), session = sessionInformation(), 
[16:18:40.033]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.033]                   signalCondition(cond)
[16:18:40.033]                 }
[16:18:40.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.033]                 "immediateCondition"))) {
[16:18:40.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.033]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.033]                   if (TRUE && !signal) {
[16:18:40.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.033]                     {
[16:18:40.033]                       inherits <- base::inherits
[16:18:40.033]                       invokeRestart <- base::invokeRestart
[16:18:40.033]                       is.null <- base::is.null
[16:18:40.033]                       muffled <- FALSE
[16:18:40.033]                       if (inherits(cond, "message")) {
[16:18:40.033]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.033]                         if (muffled) 
[16:18:40.033]                           invokeRestart("muffleMessage")
[16:18:40.033]                       }
[16:18:40.033]                       else if (inherits(cond, "warning")) {
[16:18:40.033]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.033]                         if (muffled) 
[16:18:40.033]                           invokeRestart("muffleWarning")
[16:18:40.033]                       }
[16:18:40.033]                       else if (inherits(cond, "condition")) {
[16:18:40.033]                         if (!is.null(pattern)) {
[16:18:40.033]                           computeRestarts <- base::computeRestarts
[16:18:40.033]                           grepl <- base::grepl
[16:18:40.033]                           restarts <- computeRestarts(cond)
[16:18:40.033]                           for (restart in restarts) {
[16:18:40.033]                             name <- restart$name
[16:18:40.033]                             if (is.null(name)) 
[16:18:40.033]                               next
[16:18:40.033]                             if (!grepl(pattern, name)) 
[16:18:40.033]                               next
[16:18:40.033]                             invokeRestart(restart)
[16:18:40.033]                             muffled <- TRUE
[16:18:40.033]                             break
[16:18:40.033]                           }
[16:18:40.033]                         }
[16:18:40.033]                       }
[16:18:40.033]                       invisible(muffled)
[16:18:40.033]                     }
[16:18:40.033]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.033]                   }
[16:18:40.033]                 }
[16:18:40.033]                 else {
[16:18:40.033]                   if (TRUE) {
[16:18:40.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.033]                     {
[16:18:40.033]                       inherits <- base::inherits
[16:18:40.033]                       invokeRestart <- base::invokeRestart
[16:18:40.033]                       is.null <- base::is.null
[16:18:40.033]                       muffled <- FALSE
[16:18:40.033]                       if (inherits(cond, "message")) {
[16:18:40.033]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.033]                         if (muffled) 
[16:18:40.033]                           invokeRestart("muffleMessage")
[16:18:40.033]                       }
[16:18:40.033]                       else if (inherits(cond, "warning")) {
[16:18:40.033]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.033]                         if (muffled) 
[16:18:40.033]                           invokeRestart("muffleWarning")
[16:18:40.033]                       }
[16:18:40.033]                       else if (inherits(cond, "condition")) {
[16:18:40.033]                         if (!is.null(pattern)) {
[16:18:40.033]                           computeRestarts <- base::computeRestarts
[16:18:40.033]                           grepl <- base::grepl
[16:18:40.033]                           restarts <- computeRestarts(cond)
[16:18:40.033]                           for (restart in restarts) {
[16:18:40.033]                             name <- restart$name
[16:18:40.033]                             if (is.null(name)) 
[16:18:40.033]                               next
[16:18:40.033]                             if (!grepl(pattern, name)) 
[16:18:40.033]                               next
[16:18:40.033]                             invokeRestart(restart)
[16:18:40.033]                             muffled <- TRUE
[16:18:40.033]                             break
[16:18:40.033]                           }
[16:18:40.033]                         }
[16:18:40.033]                       }
[16:18:40.033]                       invisible(muffled)
[16:18:40.033]                     }
[16:18:40.033]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.033]                   }
[16:18:40.033]                 }
[16:18:40.033]             }
[16:18:40.033]         }))
[16:18:40.033]     }, error = function(ex) {
[16:18:40.033]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.033]                 ...future.rng), started = ...future.startTime, 
[16:18:40.033]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.033]             version = "1.8"), class = "FutureResult")
[16:18:40.033]     }, finally = {
[16:18:40.033]         if (!identical(...future.workdir, getwd())) 
[16:18:40.033]             setwd(...future.workdir)
[16:18:40.033]         {
[16:18:40.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.033]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.033]             }
[16:18:40.033]             base::options(...future.oldOptions)
[16:18:40.033]             if (.Platform$OS.type == "windows") {
[16:18:40.033]                 old_names <- names(...future.oldEnvVars)
[16:18:40.033]                 envs <- base::Sys.getenv()
[16:18:40.033]                 names <- names(envs)
[16:18:40.033]                 common <- intersect(names, old_names)
[16:18:40.033]                 added <- setdiff(names, old_names)
[16:18:40.033]                 removed <- setdiff(old_names, names)
[16:18:40.033]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.033]                   envs[common]]
[16:18:40.033]                 NAMES <- toupper(changed)
[16:18:40.033]                 args <- list()
[16:18:40.033]                 for (kk in seq_along(NAMES)) {
[16:18:40.033]                   name <- changed[[kk]]
[16:18:40.033]                   NAME <- NAMES[[kk]]
[16:18:40.033]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.033]                     next
[16:18:40.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.033]                 }
[16:18:40.033]                 NAMES <- toupper(added)
[16:18:40.033]                 for (kk in seq_along(NAMES)) {
[16:18:40.033]                   name <- added[[kk]]
[16:18:40.033]                   NAME <- NAMES[[kk]]
[16:18:40.033]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.033]                     next
[16:18:40.033]                   args[[name]] <- ""
[16:18:40.033]                 }
[16:18:40.033]                 NAMES <- toupper(removed)
[16:18:40.033]                 for (kk in seq_along(NAMES)) {
[16:18:40.033]                   name <- removed[[kk]]
[16:18:40.033]                   NAME <- NAMES[[kk]]
[16:18:40.033]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.033]                     next
[16:18:40.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.033]                 }
[16:18:40.033]                 if (length(args) > 0) 
[16:18:40.033]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.033]             }
[16:18:40.033]             else {
[16:18:40.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.033]             }
[16:18:40.033]             {
[16:18:40.033]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.033]                   0L) {
[16:18:40.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.033]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.033]                   base::options(opts)
[16:18:40.033]                 }
[16:18:40.033]                 {
[16:18:40.033]                   {
[16:18:40.033]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.033]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.033]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.033]                       inherits = FALSE)
[16:18:40.033]                     NULL
[16:18:40.033]                   }
[16:18:40.033]                   options(future.plan = NULL)
[16:18:40.033]                   if (is.na(NA_character_)) 
[16:18:40.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.033]                     .init = FALSE)
[16:18:40.033]                 }
[16:18:40.033]             }
[16:18:40.033]         }
[16:18:40.033]     })
[16:18:40.033]     if (TRUE) {
[16:18:40.033]         base::sink(type = "output", split = FALSE)
[16:18:40.033]         if (TRUE) {
[16:18:40.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.033]         }
[16:18:40.033]         else {
[16:18:40.033]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.033]         }
[16:18:40.033]         base::close(...future.stdout)
[16:18:40.033]         ...future.stdout <- NULL
[16:18:40.033]     }
[16:18:40.033]     ...future.result$conditions <- ...future.conditions
[16:18:40.033]     ...future.result$finished <- base::Sys.time()
[16:18:40.033]     ...future.result
[16:18:40.033] }
[16:18:40.035] assign_globals() ...
[16:18:40.035] List of 5
[16:18:40.035]  $ ...future.FUN            :function (x, ...)  
[16:18:40.035]  $ MoreArgs                 : NULL
[16:18:40.035]  $ ...future.elements_ii    :List of 2
[16:18:40.035]   ..$ :List of 4
[16:18:40.035]   .. ..$ : int 1
[16:18:40.035]   .. ..$ : int 2
[16:18:40.035]   .. ..$ : int 3
[16:18:40.035]   .. ..$ : int 4
[16:18:40.035]   ..$ :List of 4
[16:18:40.035]   .. ..$ : int 4
[16:18:40.035]   .. ..$ : int 3
[16:18:40.035]   .. ..$ : int 2
[16:18:40.035]   .. ..$ : int 1
[16:18:40.035]  $ ...future.seeds_ii       : NULL
[16:18:40.035]  $ ...future.globals.maxSize: NULL
[16:18:40.035]  - attr(*, "where")=List of 5
[16:18:40.035]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.035]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.035]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.035]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.035]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.035]  - attr(*, "resolved")= logi FALSE
[16:18:40.035]  - attr(*, "total_size")= num 504
[16:18:40.035]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.035]  - attr(*, "already-done")= logi TRUE
[16:18:40.041] - copied ‘...future.FUN’ to environment
[16:18:40.042] - copied ‘MoreArgs’ to environment
[16:18:40.042] - copied ‘...future.elements_ii’ to environment
[16:18:40.042] - copied ‘...future.seeds_ii’ to environment
[16:18:40.042] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.042] assign_globals() ... done
[16:18:40.042] plan(): Setting new future strategy stack:
[16:18:40.042] List of future strategies:
[16:18:40.042] 1. sequential:
[16:18:40.042]    - args: function (..., envir = parent.frame())
[16:18:40.042]    - tweaked: FALSE
[16:18:40.042]    - call: NULL
[16:18:40.043] plan(): nbrOfWorkers() = 1
[16:18:40.043] plan(): Setting new future strategy stack:
[16:18:40.043] List of future strategies:
[16:18:40.043] 1. sequential:
[16:18:40.043]    - args: function (..., envir = parent.frame())
[16:18:40.043]    - tweaked: FALSE
[16:18:40.043]    - call: plan(strategy)
[16:18:40.044] plan(): nbrOfWorkers() = 1
[16:18:40.044] SequentialFuture started (and completed)
[16:18:40.044] - Launch lazy future ... done
[16:18:40.044] run() for ‘SequentialFuture’ ... done
[16:18:40.044] Created future:
[16:18:40.044] SequentialFuture:
[16:18:40.044] Label: ‘future_mapply-1’
[16:18:40.044] Expression:
[16:18:40.044] {
[16:18:40.044]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.044]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.044]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.044]         on.exit(options(oopts), add = TRUE)
[16:18:40.044]     }
[16:18:40.044]     {
[16:18:40.044]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.044]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.044]         do.call(mapply, args = args)
[16:18:40.044]     }
[16:18:40.044] }
[16:18:40.044] Lazy evaluation: FALSE
[16:18:40.044] Asynchronous evaluation: FALSE
[16:18:40.044] Local evaluation: TRUE
[16:18:40.044] Environment: R_GlobalEnv
[16:18:40.044] Capture standard output: TRUE
[16:18:40.044] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.044] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.044] Packages: <none>
[16:18:40.044] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.044] Resolved: TRUE
[16:18:40.044] Value: 240 bytes of class ‘list’
[16:18:40.044] Early signaling: FALSE
[16:18:40.044] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.044] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.045] Chunk #1 of 1 ... DONE
[16:18:40.045] Launching 1 futures (chunks) ... DONE
[16:18:40.045] Resolving 1 futures (chunks) ...
[16:18:40.046] resolve() on list ...
[16:18:40.046]  recursive: 0
[16:18:40.046]  length: 1
[16:18:40.046] 
[16:18:40.046] resolved() for ‘SequentialFuture’ ...
[16:18:40.046] - state: ‘finished’
[16:18:40.046] - run: TRUE
[16:18:40.046] - result: ‘FutureResult’
[16:18:40.046] resolved() for ‘SequentialFuture’ ... done
[16:18:40.046] Future #1
[16:18:40.046] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.047] - nx: 1
[16:18:40.047] - relay: TRUE
[16:18:40.047] - stdout: TRUE
[16:18:40.047] - signal: TRUE
[16:18:40.047] - resignal: FALSE
[16:18:40.047] - force: TRUE
[16:18:40.047] - relayed: [n=1] FALSE
[16:18:40.047] - queued futures: [n=1] FALSE
[16:18:40.047]  - until=1
[16:18:40.047]  - relaying element #1
[16:18:40.047] - relayed: [n=1] TRUE
[16:18:40.048] - queued futures: [n=1] TRUE
[16:18:40.048] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.048]  length: 0 (resolved future 1)
[16:18:40.048] Relaying remaining futures
[16:18:40.048] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.048] - nx: 1
[16:18:40.048] - relay: TRUE
[16:18:40.048] - stdout: TRUE
[16:18:40.048] - signal: TRUE
[16:18:40.048] - resignal: FALSE
[16:18:40.048] - force: TRUE
[16:18:40.049] - relayed: [n=1] TRUE
[16:18:40.049] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.049] - relayed: [n=1] TRUE
[16:18:40.049] - queued futures: [n=1] TRUE
[16:18:40.049] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.049] resolve() on list ... DONE
[16:18:40.049]  - Number of value chunks collected: 1
[16:18:40.049] Resolving 1 futures (chunks) ... DONE
[16:18:40.049] Reducing values from 1 chunks ...
[16:18:40.049]  - Number of values collected after concatenation: 4
[16:18:40.049]  - Number of values expected: 4
[16:18:40.050] Reducing values from 1 chunks ... DONE
[16:18:40.050] future_mapply() ... DONE
[16:18:40.050] future_mapply() ...
[16:18:40.050] Number of chunks: 1
[16:18:40.050] getGlobalsAndPackagesXApply() ...
[16:18:40.050]  - future.globals: TRUE
[16:18:40.050] getGlobalsAndPackages() ...
[16:18:40.050] Searching for globals...
[16:18:40.051] - globals found: [1] ‘FUN’
[16:18:40.051] Searching for globals ... DONE
[16:18:40.051] Resolving globals: FALSE
[16:18:40.051] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:40.052] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:40.052] - globals: [1] ‘FUN’
[16:18:40.052] 
[16:18:40.052] getGlobalsAndPackages() ... DONE
[16:18:40.052]  - globals found/used: [n=1] ‘FUN’
[16:18:40.052]  - needed namespaces: [n=0] 
[16:18:40.052] Finding globals ... DONE
[16:18:40.052] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.052] List of 2
[16:18:40.052]  $ ...future.FUN:function (x, ...)  
[16:18:40.052]  $ MoreArgs     : NULL
[16:18:40.052]  - attr(*, "where")=List of 2
[16:18:40.052]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.052]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.052]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.052]  - attr(*, "resolved")= logi FALSE
[16:18:40.052]  - attr(*, "total_size")= num NA
[16:18:40.055] Packages to be attached in all futures: [n=0] 
[16:18:40.055] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.056] Number of futures (= number of chunks): 1
[16:18:40.056] Launching 1 futures (chunks) ...
[16:18:40.057] Chunk #1 of 1 ...
[16:18:40.057]  - Finding globals in '...' for chunk #1 ...
[16:18:40.057] getGlobalsAndPackages() ...
[16:18:40.057] Searching for globals...
[16:18:40.057] 
[16:18:40.057] Searching for globals ... DONE
[16:18:40.057] - globals: [0] <none>
[16:18:40.057] getGlobalsAndPackages() ... DONE
[16:18:40.058]    + additional globals found: [n=0] 
[16:18:40.058]    + additional namespaces needed: [n=0] 
[16:18:40.058]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.058]  - seeds: <none>
[16:18:40.058]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.058] getGlobalsAndPackages() ...
[16:18:40.058] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.058] Resolving globals: FALSE
[16:18:40.059] The total size of the 5 globals is 504 bytes (504 bytes)
[16:18:40.059] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.059] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.059] 
[16:18:40.059] getGlobalsAndPackages() ... DONE
[16:18:40.060] run() for ‘Future’ ...
[16:18:40.060] - state: ‘created’
[16:18:40.060] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.060] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.060] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.060]   - Field: ‘label’
[16:18:40.060]   - Field: ‘local’
[16:18:40.061]   - Field: ‘owner’
[16:18:40.061]   - Field: ‘envir’
[16:18:40.061]   - Field: ‘packages’
[16:18:40.061]   - Field: ‘gc’
[16:18:40.061]   - Field: ‘conditions’
[16:18:40.061]   - Field: ‘expr’
[16:18:40.061]   - Field: ‘uuid’
[16:18:40.061]   - Field: ‘seed’
[16:18:40.061]   - Field: ‘version’
[16:18:40.061]   - Field: ‘result’
[16:18:40.061]   - Field: ‘asynchronous’
[16:18:40.062]   - Field: ‘calls’
[16:18:40.062]   - Field: ‘globals’
[16:18:40.062]   - Field: ‘stdout’
[16:18:40.062]   - Field: ‘earlySignal’
[16:18:40.062]   - Field: ‘lazy’
[16:18:40.062]   - Field: ‘state’
[16:18:40.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.062] - Launch lazy future ...
[16:18:40.062] Packages needed by the future expression (n = 0): <none>
[16:18:40.062] Packages needed by future strategies (n = 0): <none>
[16:18:40.063] {
[16:18:40.063]     {
[16:18:40.063]         {
[16:18:40.063]             ...future.startTime <- base::Sys.time()
[16:18:40.063]             {
[16:18:40.063]                 {
[16:18:40.063]                   {
[16:18:40.063]                     base::local({
[16:18:40.063]                       has_future <- base::requireNamespace("future", 
[16:18:40.063]                         quietly = TRUE)
[16:18:40.063]                       if (has_future) {
[16:18:40.063]                         ns <- base::getNamespace("future")
[16:18:40.063]                         version <- ns[[".package"]][["version"]]
[16:18:40.063]                         if (is.null(version)) 
[16:18:40.063]                           version <- utils::packageVersion("future")
[16:18:40.063]                       }
[16:18:40.063]                       else {
[16:18:40.063]                         version <- NULL
[16:18:40.063]                       }
[16:18:40.063]                       if (!has_future || version < "1.8.0") {
[16:18:40.063]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.063]                           "", base::R.version$version.string), 
[16:18:40.063]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.063]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.063]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.063]                             "release", "version")], collapse = " "), 
[16:18:40.063]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.063]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.063]                           info)
[16:18:40.063]                         info <- base::paste(info, collapse = "; ")
[16:18:40.063]                         if (!has_future) {
[16:18:40.063]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.063]                             info)
[16:18:40.063]                         }
[16:18:40.063]                         else {
[16:18:40.063]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.063]                             info, version)
[16:18:40.063]                         }
[16:18:40.063]                         base::stop(msg)
[16:18:40.063]                       }
[16:18:40.063]                     })
[16:18:40.063]                   }
[16:18:40.063]                   ...future.strategy.old <- future::plan("list")
[16:18:40.063]                   options(future.plan = NULL)
[16:18:40.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.063]                 }
[16:18:40.063]                 ...future.workdir <- getwd()
[16:18:40.063]             }
[16:18:40.063]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.063]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.063]         }
[16:18:40.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.063]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.063]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.063]             base::names(...future.oldOptions))
[16:18:40.063]     }
[16:18:40.063]     if (FALSE) {
[16:18:40.063]     }
[16:18:40.063]     else {
[16:18:40.063]         if (TRUE) {
[16:18:40.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.063]                 open = "w")
[16:18:40.063]         }
[16:18:40.063]         else {
[16:18:40.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.063]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.063]         }
[16:18:40.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.063]             base::sink(type = "output", split = FALSE)
[16:18:40.063]             base::close(...future.stdout)
[16:18:40.063]         }, add = TRUE)
[16:18:40.063]     }
[16:18:40.063]     ...future.frame <- base::sys.nframe()
[16:18:40.063]     ...future.conditions <- base::list()
[16:18:40.063]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.063]     if (FALSE) {
[16:18:40.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.063]     }
[16:18:40.063]     ...future.result <- base::tryCatch({
[16:18:40.063]         base::withCallingHandlers({
[16:18:40.063]             ...future.value <- base::withVisible(base::local({
[16:18:40.063]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.063]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.063]                   ...future.globals.maxSize)) {
[16:18:40.063]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.063]                   on.exit(options(oopts), add = TRUE)
[16:18:40.063]                 }
[16:18:40.063]                 {
[16:18:40.063]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.063]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.063]                     USE.NAMES = FALSE)
[16:18:40.063]                   do.call(mapply, args = args)
[16:18:40.063]                 }
[16:18:40.063]             }))
[16:18:40.063]             future::FutureResult(value = ...future.value$value, 
[16:18:40.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.063]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.063]                     ...future.globalenv.names))
[16:18:40.063]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.063]         }, condition = base::local({
[16:18:40.063]             c <- base::c
[16:18:40.063]             inherits <- base::inherits
[16:18:40.063]             invokeRestart <- base::invokeRestart
[16:18:40.063]             length <- base::length
[16:18:40.063]             list <- base::list
[16:18:40.063]             seq.int <- base::seq.int
[16:18:40.063]             signalCondition <- base::signalCondition
[16:18:40.063]             sys.calls <- base::sys.calls
[16:18:40.063]             `[[` <- base::`[[`
[16:18:40.063]             `+` <- base::`+`
[16:18:40.063]             `<<-` <- base::`<<-`
[16:18:40.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.063]                   3L)]
[16:18:40.063]             }
[16:18:40.063]             function(cond) {
[16:18:40.063]                 is_error <- inherits(cond, "error")
[16:18:40.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.063]                   NULL)
[16:18:40.063]                 if (is_error) {
[16:18:40.063]                   sessionInformation <- function() {
[16:18:40.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.063]                       search = base::search(), system = base::Sys.info())
[16:18:40.063]                   }
[16:18:40.063]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.063]                     cond$call), session = sessionInformation(), 
[16:18:40.063]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.063]                   signalCondition(cond)
[16:18:40.063]                 }
[16:18:40.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.063]                 "immediateCondition"))) {
[16:18:40.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.063]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.063]                   if (TRUE && !signal) {
[16:18:40.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.063]                     {
[16:18:40.063]                       inherits <- base::inherits
[16:18:40.063]                       invokeRestart <- base::invokeRestart
[16:18:40.063]                       is.null <- base::is.null
[16:18:40.063]                       muffled <- FALSE
[16:18:40.063]                       if (inherits(cond, "message")) {
[16:18:40.063]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.063]                         if (muffled) 
[16:18:40.063]                           invokeRestart("muffleMessage")
[16:18:40.063]                       }
[16:18:40.063]                       else if (inherits(cond, "warning")) {
[16:18:40.063]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.063]                         if (muffled) 
[16:18:40.063]                           invokeRestart("muffleWarning")
[16:18:40.063]                       }
[16:18:40.063]                       else if (inherits(cond, "condition")) {
[16:18:40.063]                         if (!is.null(pattern)) {
[16:18:40.063]                           computeRestarts <- base::computeRestarts
[16:18:40.063]                           grepl <- base::grepl
[16:18:40.063]                           restarts <- computeRestarts(cond)
[16:18:40.063]                           for (restart in restarts) {
[16:18:40.063]                             name <- restart$name
[16:18:40.063]                             if (is.null(name)) 
[16:18:40.063]                               next
[16:18:40.063]                             if (!grepl(pattern, name)) 
[16:18:40.063]                               next
[16:18:40.063]                             invokeRestart(restart)
[16:18:40.063]                             muffled <- TRUE
[16:18:40.063]                             break
[16:18:40.063]                           }
[16:18:40.063]                         }
[16:18:40.063]                       }
[16:18:40.063]                       invisible(muffled)
[16:18:40.063]                     }
[16:18:40.063]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.063]                   }
[16:18:40.063]                 }
[16:18:40.063]                 else {
[16:18:40.063]                   if (TRUE) {
[16:18:40.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.063]                     {
[16:18:40.063]                       inherits <- base::inherits
[16:18:40.063]                       invokeRestart <- base::invokeRestart
[16:18:40.063]                       is.null <- base::is.null
[16:18:40.063]                       muffled <- FALSE
[16:18:40.063]                       if (inherits(cond, "message")) {
[16:18:40.063]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.063]                         if (muffled) 
[16:18:40.063]                           invokeRestart("muffleMessage")
[16:18:40.063]                       }
[16:18:40.063]                       else if (inherits(cond, "warning")) {
[16:18:40.063]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.063]                         if (muffled) 
[16:18:40.063]                           invokeRestart("muffleWarning")
[16:18:40.063]                       }
[16:18:40.063]                       else if (inherits(cond, "condition")) {
[16:18:40.063]                         if (!is.null(pattern)) {
[16:18:40.063]                           computeRestarts <- base::computeRestarts
[16:18:40.063]                           grepl <- base::grepl
[16:18:40.063]                           restarts <- computeRestarts(cond)
[16:18:40.063]                           for (restart in restarts) {
[16:18:40.063]                             name <- restart$name
[16:18:40.063]                             if (is.null(name)) 
[16:18:40.063]                               next
[16:18:40.063]                             if (!grepl(pattern, name)) 
[16:18:40.063]                               next
[16:18:40.063]                             invokeRestart(restart)
[16:18:40.063]                             muffled <- TRUE
[16:18:40.063]                             break
[16:18:40.063]                           }
[16:18:40.063]                         }
[16:18:40.063]                       }
[16:18:40.063]                       invisible(muffled)
[16:18:40.063]                     }
[16:18:40.063]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.063]                   }
[16:18:40.063]                 }
[16:18:40.063]             }
[16:18:40.063]         }))
[16:18:40.063]     }, error = function(ex) {
[16:18:40.063]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.063]                 ...future.rng), started = ...future.startTime, 
[16:18:40.063]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.063]             version = "1.8"), class = "FutureResult")
[16:18:40.063]     }, finally = {
[16:18:40.063]         if (!identical(...future.workdir, getwd())) 
[16:18:40.063]             setwd(...future.workdir)
[16:18:40.063]         {
[16:18:40.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.063]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.063]             }
[16:18:40.063]             base::options(...future.oldOptions)
[16:18:40.063]             if (.Platform$OS.type == "windows") {
[16:18:40.063]                 old_names <- names(...future.oldEnvVars)
[16:18:40.063]                 envs <- base::Sys.getenv()
[16:18:40.063]                 names <- names(envs)
[16:18:40.063]                 common <- intersect(names, old_names)
[16:18:40.063]                 added <- setdiff(names, old_names)
[16:18:40.063]                 removed <- setdiff(old_names, names)
[16:18:40.063]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.063]                   envs[common]]
[16:18:40.063]                 NAMES <- toupper(changed)
[16:18:40.063]                 args <- list()
[16:18:40.063]                 for (kk in seq_along(NAMES)) {
[16:18:40.063]                   name <- changed[[kk]]
[16:18:40.063]                   NAME <- NAMES[[kk]]
[16:18:40.063]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.063]                     next
[16:18:40.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.063]                 }
[16:18:40.063]                 NAMES <- toupper(added)
[16:18:40.063]                 for (kk in seq_along(NAMES)) {
[16:18:40.063]                   name <- added[[kk]]
[16:18:40.063]                   NAME <- NAMES[[kk]]
[16:18:40.063]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.063]                     next
[16:18:40.063]                   args[[name]] <- ""
[16:18:40.063]                 }
[16:18:40.063]                 NAMES <- toupper(removed)
[16:18:40.063]                 for (kk in seq_along(NAMES)) {
[16:18:40.063]                   name <- removed[[kk]]
[16:18:40.063]                   NAME <- NAMES[[kk]]
[16:18:40.063]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.063]                     next
[16:18:40.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.063]                 }
[16:18:40.063]                 if (length(args) > 0) 
[16:18:40.063]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.063]             }
[16:18:40.063]             else {
[16:18:40.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.063]             }
[16:18:40.063]             {
[16:18:40.063]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.063]                   0L) {
[16:18:40.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.063]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.063]                   base::options(opts)
[16:18:40.063]                 }
[16:18:40.063]                 {
[16:18:40.063]                   {
[16:18:40.063]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.063]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.063]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.063]                       inherits = FALSE)
[16:18:40.063]                     NULL
[16:18:40.063]                   }
[16:18:40.063]                   options(future.plan = NULL)
[16:18:40.063]                   if (is.na(NA_character_)) 
[16:18:40.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.063]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.063]                     .init = FALSE)
[16:18:40.063]                 }
[16:18:40.063]             }
[16:18:40.063]         }
[16:18:40.063]     })
[16:18:40.063]     if (TRUE) {
[16:18:40.063]         base::sink(type = "output", split = FALSE)
[16:18:40.063]         if (TRUE) {
[16:18:40.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.063]         }
[16:18:40.063]         else {
[16:18:40.063]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.063]         }
[16:18:40.063]         base::close(...future.stdout)
[16:18:40.063]         ...future.stdout <- NULL
[16:18:40.063]     }
[16:18:40.063]     ...future.result$conditions <- ...future.conditions
[16:18:40.063]     ...future.result$finished <- base::Sys.time()
[16:18:40.063]     ...future.result
[16:18:40.063] }
[16:18:40.064] assign_globals() ...
[16:18:40.065] List of 5
[16:18:40.065]  $ ...future.FUN            :function (x, ...)  
[16:18:40.065]  $ MoreArgs                 : NULL
[16:18:40.065]  $ ...future.elements_ii    :List of 2
[16:18:40.065]   ..$ times:List of 4
[16:18:40.065]   .. ..$ : int 1
[16:18:40.065]   .. ..$ : int 2
[16:18:40.065]   .. ..$ : int 3
[16:18:40.065]   .. ..$ : int 4
[16:18:40.065]   ..$ x    :List of 4
[16:18:40.065]   .. ..$ : int 4
[16:18:40.065]   .. ..$ : int 3
[16:18:40.065]   .. ..$ : int 2
[16:18:40.065]   .. ..$ : int 1
[16:18:40.065]  $ ...future.seeds_ii       : NULL
[16:18:40.065]  $ ...future.globals.maxSize: NULL
[16:18:40.065]  - attr(*, "where")=List of 5
[16:18:40.065]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.065]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.065]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.065]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.065]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.065]  - attr(*, "resolved")= logi FALSE
[16:18:40.065]  - attr(*, "total_size")= num 504
[16:18:40.065]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.065]  - attr(*, "already-done")= logi TRUE
[16:18:40.071] - copied ‘...future.FUN’ to environment
[16:18:40.071] - copied ‘MoreArgs’ to environment
[16:18:40.071] - copied ‘...future.elements_ii’ to environment
[16:18:40.071] - copied ‘...future.seeds_ii’ to environment
[16:18:40.071] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.072] assign_globals() ... done
[16:18:40.072] plan(): Setting new future strategy stack:
[16:18:40.072] List of future strategies:
[16:18:40.072] 1. sequential:
[16:18:40.072]    - args: function (..., envir = parent.frame())
[16:18:40.072]    - tweaked: FALSE
[16:18:40.072]    - call: NULL
[16:18:40.072] plan(): nbrOfWorkers() = 1
[16:18:40.073] plan(): Setting new future strategy stack:
[16:18:40.073] List of future strategies:
[16:18:40.073] 1. sequential:
[16:18:40.073]    - args: function (..., envir = parent.frame())
[16:18:40.073]    - tweaked: FALSE
[16:18:40.073]    - call: plan(strategy)
[16:18:40.073] plan(): nbrOfWorkers() = 1
[16:18:40.073] SequentialFuture started (and completed)
[16:18:40.074] - Launch lazy future ... done
[16:18:40.074] run() for ‘SequentialFuture’ ... done
[16:18:40.074] Created future:
[16:18:40.074] SequentialFuture:
[16:18:40.074] Label: ‘future_mapply-1’
[16:18:40.074] Expression:
[16:18:40.074] {
[16:18:40.074]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.074]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.074]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.074]         on.exit(options(oopts), add = TRUE)
[16:18:40.074]     }
[16:18:40.074]     {
[16:18:40.074]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.074]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.074]         do.call(mapply, args = args)
[16:18:40.074]     }
[16:18:40.074] }
[16:18:40.074] Lazy evaluation: FALSE
[16:18:40.074] Asynchronous evaluation: FALSE
[16:18:40.074] Local evaluation: TRUE
[16:18:40.074] Environment: R_GlobalEnv
[16:18:40.074] Capture standard output: TRUE
[16:18:40.074] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.074] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.074] Packages: <none>
[16:18:40.074] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.074] Resolved: TRUE
[16:18:40.074] Value: 240 bytes of class ‘list’
[16:18:40.074] Early signaling: FALSE
[16:18:40.074] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.074] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.075] Chunk #1 of 1 ... DONE
[16:18:40.075] Launching 1 futures (chunks) ... DONE
[16:18:40.075] Resolving 1 futures (chunks) ...
[16:18:40.075] resolve() on list ...
[16:18:40.075]  recursive: 0
[16:18:40.075]  length: 1
[16:18:40.075] 
[16:18:40.075] resolved() for ‘SequentialFuture’ ...
[16:18:40.076] - state: ‘finished’
[16:18:40.076] - run: TRUE
[16:18:40.076] - result: ‘FutureResult’
[16:18:40.076] resolved() for ‘SequentialFuture’ ... done
[16:18:40.076] Future #1
[16:18:40.076] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.076] - nx: 1
[16:18:40.076] - relay: TRUE
[16:18:40.076] - stdout: TRUE
[16:18:40.076] - signal: TRUE
[16:18:40.076] - resignal: FALSE
[16:18:40.077] - force: TRUE
[16:18:40.077] - relayed: [n=1] FALSE
[16:18:40.077] - queued futures: [n=1] FALSE
[16:18:40.077]  - until=1
[16:18:40.077]  - relaying element #1
[16:18:40.077] - relayed: [n=1] TRUE
[16:18:40.077] - queued futures: [n=1] TRUE
[16:18:40.077] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.077]  length: 0 (resolved future 1)
[16:18:40.077] Relaying remaining futures
[16:18:40.078] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.078] - nx: 1
[16:18:40.078] - relay: TRUE
[16:18:40.078] - stdout: TRUE
[16:18:40.078] - signal: TRUE
[16:18:40.078] - resignal: FALSE
[16:18:40.078] - force: TRUE
[16:18:40.078] - relayed: [n=1] TRUE
[16:18:40.078] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.078] - relayed: [n=1] TRUE
[16:18:40.078] - queued futures: [n=1] TRUE
[16:18:40.079] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.079] resolve() on list ... DONE
[16:18:40.079]  - Number of value chunks collected: 1
[16:18:40.080] Resolving 1 futures (chunks) ... DONE
[16:18:40.080] Reducing values from 1 chunks ...
[16:18:40.081]  - Number of values collected after concatenation: 4
[16:18:40.081]  - Number of values expected: 4
[16:18:40.081] Reducing values from 1 chunks ... DONE
[16:18:40.081] future_mapply() ... DONE
[16:18:40.081] future_mapply() ...
[16:18:40.081] Number of chunks: 1
[16:18:40.081] getGlobalsAndPackagesXApply() ...
[16:18:40.081]  - future.globals: TRUE
[16:18:40.081] getGlobalsAndPackages() ...
[16:18:40.081] Searching for globals...
[16:18:40.082] - globals found: [1] ‘FUN’
[16:18:40.082] Searching for globals ... DONE
[16:18:40.082] Resolving globals: FALSE
[16:18:40.083] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:40.083] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:40.083] - globals: [1] ‘FUN’
[16:18:40.083] 
[16:18:40.083] getGlobalsAndPackages() ... DONE
[16:18:40.083]  - globals found/used: [n=1] ‘FUN’
[16:18:40.083]  - needed namespaces: [n=0] 
[16:18:40.083] Finding globals ... DONE
[16:18:40.084] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.084] List of 2
[16:18:40.084]  $ ...future.FUN:function (x, ...)  
[16:18:40.084]  $ MoreArgs     :List of 1
[16:18:40.084]   ..$ x: num 42
[16:18:40.084]  - attr(*, "where")=List of 2
[16:18:40.084]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.084]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.084]  - attr(*, "resolved")= logi FALSE
[16:18:40.084]  - attr(*, "total_size")= num NA
[16:18:40.087] Packages to be attached in all futures: [n=0] 
[16:18:40.087] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.087] Number of futures (= number of chunks): 1
[16:18:40.087] Launching 1 futures (chunks) ...
[16:18:40.087] Chunk #1 of 1 ...
[16:18:40.087]  - Finding globals in '...' for chunk #1 ...
[16:18:40.087] getGlobalsAndPackages() ...
[16:18:40.087] Searching for globals...
[16:18:40.088] 
[16:18:40.088] Searching for globals ... DONE
[16:18:40.088] - globals: [0] <none>
[16:18:40.088] getGlobalsAndPackages() ... DONE
[16:18:40.088]    + additional globals found: [n=0] 
[16:18:40.088]    + additional namespaces needed: [n=0] 
[16:18:40.088]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.088]  - seeds: <none>
[16:18:40.088]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.088] getGlobalsAndPackages() ...
[16:18:40.089] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.089] Resolving globals: FALSE
[16:18:40.089] The total size of the 5 globals is 336 bytes (336 bytes)
[16:18:40.090] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 336 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[16:18:40.090] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.090] 
[16:18:40.090] getGlobalsAndPackages() ... DONE
[16:18:40.090] run() for ‘Future’ ...
[16:18:40.090] - state: ‘created’
[16:18:40.090] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.091] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.091]   - Field: ‘label’
[16:18:40.091]   - Field: ‘local’
[16:18:40.091]   - Field: ‘owner’
[16:18:40.091]   - Field: ‘envir’
[16:18:40.091]   - Field: ‘packages’
[16:18:40.091]   - Field: ‘gc’
[16:18:40.091]   - Field: ‘conditions’
[16:18:40.091]   - Field: ‘expr’
[16:18:40.092]   - Field: ‘uuid’
[16:18:40.092]   - Field: ‘seed’
[16:18:40.092]   - Field: ‘version’
[16:18:40.092]   - Field: ‘result’
[16:18:40.092]   - Field: ‘asynchronous’
[16:18:40.092]   - Field: ‘calls’
[16:18:40.092]   - Field: ‘globals’
[16:18:40.092]   - Field: ‘stdout’
[16:18:40.092]   - Field: ‘earlySignal’
[16:18:40.092]   - Field: ‘lazy’
[16:18:40.092]   - Field: ‘state’
[16:18:40.093] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.093] - Launch lazy future ...
[16:18:40.093] Packages needed by the future expression (n = 0): <none>
[16:18:40.093] Packages needed by future strategies (n = 0): <none>
[16:18:40.093] {
[16:18:40.093]     {
[16:18:40.093]         {
[16:18:40.093]             ...future.startTime <- base::Sys.time()
[16:18:40.093]             {
[16:18:40.093]                 {
[16:18:40.093]                   {
[16:18:40.093]                     base::local({
[16:18:40.093]                       has_future <- base::requireNamespace("future", 
[16:18:40.093]                         quietly = TRUE)
[16:18:40.093]                       if (has_future) {
[16:18:40.093]                         ns <- base::getNamespace("future")
[16:18:40.093]                         version <- ns[[".package"]][["version"]]
[16:18:40.093]                         if (is.null(version)) 
[16:18:40.093]                           version <- utils::packageVersion("future")
[16:18:40.093]                       }
[16:18:40.093]                       else {
[16:18:40.093]                         version <- NULL
[16:18:40.093]                       }
[16:18:40.093]                       if (!has_future || version < "1.8.0") {
[16:18:40.093]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.093]                           "", base::R.version$version.string), 
[16:18:40.093]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.093]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.093]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.093]                             "release", "version")], collapse = " "), 
[16:18:40.093]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.093]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.093]                           info)
[16:18:40.093]                         info <- base::paste(info, collapse = "; ")
[16:18:40.093]                         if (!has_future) {
[16:18:40.093]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.093]                             info)
[16:18:40.093]                         }
[16:18:40.093]                         else {
[16:18:40.093]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.093]                             info, version)
[16:18:40.093]                         }
[16:18:40.093]                         base::stop(msg)
[16:18:40.093]                       }
[16:18:40.093]                     })
[16:18:40.093]                   }
[16:18:40.093]                   ...future.strategy.old <- future::plan("list")
[16:18:40.093]                   options(future.plan = NULL)
[16:18:40.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.093]                 }
[16:18:40.093]                 ...future.workdir <- getwd()
[16:18:40.093]             }
[16:18:40.093]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.093]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.093]         }
[16:18:40.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.093]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.093]             base::names(...future.oldOptions))
[16:18:40.093]     }
[16:18:40.093]     if (FALSE) {
[16:18:40.093]     }
[16:18:40.093]     else {
[16:18:40.093]         if (TRUE) {
[16:18:40.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.093]                 open = "w")
[16:18:40.093]         }
[16:18:40.093]         else {
[16:18:40.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.093]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.093]         }
[16:18:40.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.093]             base::sink(type = "output", split = FALSE)
[16:18:40.093]             base::close(...future.stdout)
[16:18:40.093]         }, add = TRUE)
[16:18:40.093]     }
[16:18:40.093]     ...future.frame <- base::sys.nframe()
[16:18:40.093]     ...future.conditions <- base::list()
[16:18:40.093]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.093]     if (FALSE) {
[16:18:40.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.093]     }
[16:18:40.093]     ...future.result <- base::tryCatch({
[16:18:40.093]         base::withCallingHandlers({
[16:18:40.093]             ...future.value <- base::withVisible(base::local({
[16:18:40.093]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.093]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.093]                   ...future.globals.maxSize)) {
[16:18:40.093]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.093]                   on.exit(options(oopts), add = TRUE)
[16:18:40.093]                 }
[16:18:40.093]                 {
[16:18:40.093]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.093]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.093]                     USE.NAMES = FALSE)
[16:18:40.093]                   do.call(mapply, args = args)
[16:18:40.093]                 }
[16:18:40.093]             }))
[16:18:40.093]             future::FutureResult(value = ...future.value$value, 
[16:18:40.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.093]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.093]                     ...future.globalenv.names))
[16:18:40.093]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.093]         }, condition = base::local({
[16:18:40.093]             c <- base::c
[16:18:40.093]             inherits <- base::inherits
[16:18:40.093]             invokeRestart <- base::invokeRestart
[16:18:40.093]             length <- base::length
[16:18:40.093]             list <- base::list
[16:18:40.093]             seq.int <- base::seq.int
[16:18:40.093]             signalCondition <- base::signalCondition
[16:18:40.093]             sys.calls <- base::sys.calls
[16:18:40.093]             `[[` <- base::`[[`
[16:18:40.093]             `+` <- base::`+`
[16:18:40.093]             `<<-` <- base::`<<-`
[16:18:40.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.093]                   3L)]
[16:18:40.093]             }
[16:18:40.093]             function(cond) {
[16:18:40.093]                 is_error <- inherits(cond, "error")
[16:18:40.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.093]                   NULL)
[16:18:40.093]                 if (is_error) {
[16:18:40.093]                   sessionInformation <- function() {
[16:18:40.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.093]                       search = base::search(), system = base::Sys.info())
[16:18:40.093]                   }
[16:18:40.093]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.093]                     cond$call), session = sessionInformation(), 
[16:18:40.093]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.093]                   signalCondition(cond)
[16:18:40.093]                 }
[16:18:40.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.093]                 "immediateCondition"))) {
[16:18:40.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.093]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.093]                   if (TRUE && !signal) {
[16:18:40.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.093]                     {
[16:18:40.093]                       inherits <- base::inherits
[16:18:40.093]                       invokeRestart <- base::invokeRestart
[16:18:40.093]                       is.null <- base::is.null
[16:18:40.093]                       muffled <- FALSE
[16:18:40.093]                       if (inherits(cond, "message")) {
[16:18:40.093]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.093]                         if (muffled) 
[16:18:40.093]                           invokeRestart("muffleMessage")
[16:18:40.093]                       }
[16:18:40.093]                       else if (inherits(cond, "warning")) {
[16:18:40.093]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.093]                         if (muffled) 
[16:18:40.093]                           invokeRestart("muffleWarning")
[16:18:40.093]                       }
[16:18:40.093]                       else if (inherits(cond, "condition")) {
[16:18:40.093]                         if (!is.null(pattern)) {
[16:18:40.093]                           computeRestarts <- base::computeRestarts
[16:18:40.093]                           grepl <- base::grepl
[16:18:40.093]                           restarts <- computeRestarts(cond)
[16:18:40.093]                           for (restart in restarts) {
[16:18:40.093]                             name <- restart$name
[16:18:40.093]                             if (is.null(name)) 
[16:18:40.093]                               next
[16:18:40.093]                             if (!grepl(pattern, name)) 
[16:18:40.093]                               next
[16:18:40.093]                             invokeRestart(restart)
[16:18:40.093]                             muffled <- TRUE
[16:18:40.093]                             break
[16:18:40.093]                           }
[16:18:40.093]                         }
[16:18:40.093]                       }
[16:18:40.093]                       invisible(muffled)
[16:18:40.093]                     }
[16:18:40.093]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.093]                   }
[16:18:40.093]                 }
[16:18:40.093]                 else {
[16:18:40.093]                   if (TRUE) {
[16:18:40.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.093]                     {
[16:18:40.093]                       inherits <- base::inherits
[16:18:40.093]                       invokeRestart <- base::invokeRestart
[16:18:40.093]                       is.null <- base::is.null
[16:18:40.093]                       muffled <- FALSE
[16:18:40.093]                       if (inherits(cond, "message")) {
[16:18:40.093]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.093]                         if (muffled) 
[16:18:40.093]                           invokeRestart("muffleMessage")
[16:18:40.093]                       }
[16:18:40.093]                       else if (inherits(cond, "warning")) {
[16:18:40.093]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.093]                         if (muffled) 
[16:18:40.093]                           invokeRestart("muffleWarning")
[16:18:40.093]                       }
[16:18:40.093]                       else if (inherits(cond, "condition")) {
[16:18:40.093]                         if (!is.null(pattern)) {
[16:18:40.093]                           computeRestarts <- base::computeRestarts
[16:18:40.093]                           grepl <- base::grepl
[16:18:40.093]                           restarts <- computeRestarts(cond)
[16:18:40.093]                           for (restart in restarts) {
[16:18:40.093]                             name <- restart$name
[16:18:40.093]                             if (is.null(name)) 
[16:18:40.093]                               next
[16:18:40.093]                             if (!grepl(pattern, name)) 
[16:18:40.093]                               next
[16:18:40.093]                             invokeRestart(restart)
[16:18:40.093]                             muffled <- TRUE
[16:18:40.093]                             break
[16:18:40.093]                           }
[16:18:40.093]                         }
[16:18:40.093]                       }
[16:18:40.093]                       invisible(muffled)
[16:18:40.093]                     }
[16:18:40.093]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.093]                   }
[16:18:40.093]                 }
[16:18:40.093]             }
[16:18:40.093]         }))
[16:18:40.093]     }, error = function(ex) {
[16:18:40.093]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.093]                 ...future.rng), started = ...future.startTime, 
[16:18:40.093]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.093]             version = "1.8"), class = "FutureResult")
[16:18:40.093]     }, finally = {
[16:18:40.093]         if (!identical(...future.workdir, getwd())) 
[16:18:40.093]             setwd(...future.workdir)
[16:18:40.093]         {
[16:18:40.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.093]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.093]             }
[16:18:40.093]             base::options(...future.oldOptions)
[16:18:40.093]             if (.Platform$OS.type == "windows") {
[16:18:40.093]                 old_names <- names(...future.oldEnvVars)
[16:18:40.093]                 envs <- base::Sys.getenv()
[16:18:40.093]                 names <- names(envs)
[16:18:40.093]                 common <- intersect(names, old_names)
[16:18:40.093]                 added <- setdiff(names, old_names)
[16:18:40.093]                 removed <- setdiff(old_names, names)
[16:18:40.093]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.093]                   envs[common]]
[16:18:40.093]                 NAMES <- toupper(changed)
[16:18:40.093]                 args <- list()
[16:18:40.093]                 for (kk in seq_along(NAMES)) {
[16:18:40.093]                   name <- changed[[kk]]
[16:18:40.093]                   NAME <- NAMES[[kk]]
[16:18:40.093]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.093]                     next
[16:18:40.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.093]                 }
[16:18:40.093]                 NAMES <- toupper(added)
[16:18:40.093]                 for (kk in seq_along(NAMES)) {
[16:18:40.093]                   name <- added[[kk]]
[16:18:40.093]                   NAME <- NAMES[[kk]]
[16:18:40.093]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.093]                     next
[16:18:40.093]                   args[[name]] <- ""
[16:18:40.093]                 }
[16:18:40.093]                 NAMES <- toupper(removed)
[16:18:40.093]                 for (kk in seq_along(NAMES)) {
[16:18:40.093]                   name <- removed[[kk]]
[16:18:40.093]                   NAME <- NAMES[[kk]]
[16:18:40.093]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.093]                     next
[16:18:40.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.093]                 }
[16:18:40.093]                 if (length(args) > 0) 
[16:18:40.093]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.093]             }
[16:18:40.093]             else {
[16:18:40.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.093]             }
[16:18:40.093]             {
[16:18:40.093]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.093]                   0L) {
[16:18:40.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.093]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.093]                   base::options(opts)
[16:18:40.093]                 }
[16:18:40.093]                 {
[16:18:40.093]                   {
[16:18:40.093]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.093]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.093]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.093]                       inherits = FALSE)
[16:18:40.093]                     NULL
[16:18:40.093]                   }
[16:18:40.093]                   options(future.plan = NULL)
[16:18:40.093]                   if (is.na(NA_character_)) 
[16:18:40.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.093]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.093]                     .init = FALSE)
[16:18:40.093]                 }
[16:18:40.093]             }
[16:18:40.093]         }
[16:18:40.093]     })
[16:18:40.093]     if (TRUE) {
[16:18:40.093]         base::sink(type = "output", split = FALSE)
[16:18:40.093]         if (TRUE) {
[16:18:40.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.093]         }
[16:18:40.093]         else {
[16:18:40.093]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.093]         }
[16:18:40.093]         base::close(...future.stdout)
[16:18:40.093]         ...future.stdout <- NULL
[16:18:40.093]     }
[16:18:40.093]     ...future.result$conditions <- ...future.conditions
[16:18:40.093]     ...future.result$finished <- base::Sys.time()
[16:18:40.093]     ...future.result
[16:18:40.093] }
[16:18:40.095] assign_globals() ...
[16:18:40.095] List of 5
[16:18:40.095]  $ ...future.FUN            :function (x, ...)  
[16:18:40.095]  $ MoreArgs                 :List of 1
[16:18:40.095]   ..$ x: num 42
[16:18:40.095]  $ ...future.elements_ii    :List of 1
[16:18:40.095]   ..$ times:List of 4
[16:18:40.095]   .. ..$ : int 1
[16:18:40.095]   .. ..$ : int 2
[16:18:40.095]   .. ..$ : int 3
[16:18:40.095]   .. ..$ : int 4
[16:18:40.095]  $ ...future.seeds_ii       : NULL
[16:18:40.095]  $ ...future.globals.maxSize: NULL
[16:18:40.095]  - attr(*, "where")=List of 5
[16:18:40.095]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.095]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.095]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.095]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.095]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.095]  - attr(*, "resolved")= logi FALSE
[16:18:40.095]  - attr(*, "total_size")= num 336
[16:18:40.095]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.095]  - attr(*, "already-done")= logi TRUE
[16:18:40.100] - copied ‘...future.FUN’ to environment
[16:18:40.101] - copied ‘MoreArgs’ to environment
[16:18:40.101] - copied ‘...future.elements_ii’ to environment
[16:18:40.101] - copied ‘...future.seeds_ii’ to environment
[16:18:40.101] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.101] assign_globals() ... done
[16:18:40.101] plan(): Setting new future strategy stack:
[16:18:40.101] List of future strategies:
[16:18:40.101] 1. sequential:
[16:18:40.101]    - args: function (..., envir = parent.frame())
[16:18:40.101]    - tweaked: FALSE
[16:18:40.101]    - call: NULL
[16:18:40.102] plan(): nbrOfWorkers() = 1
[16:18:40.102] plan(): Setting new future strategy stack:
[16:18:40.102] List of future strategies:
[16:18:40.102] 1. sequential:
[16:18:40.102]    - args: function (..., envir = parent.frame())
[16:18:40.102]    - tweaked: FALSE
[16:18:40.102]    - call: plan(strategy)
[16:18:40.103] plan(): nbrOfWorkers() = 1
[16:18:40.103] SequentialFuture started (and completed)
[16:18:40.104] - Launch lazy future ... done
[16:18:40.105] run() for ‘SequentialFuture’ ... done
[16:18:40.105] Created future:
[16:18:40.105] SequentialFuture:
[16:18:40.105] Label: ‘future_mapply-1’
[16:18:40.105] Expression:
[16:18:40.105] {
[16:18:40.105]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.105]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.105]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.105]         on.exit(options(oopts), add = TRUE)
[16:18:40.105]     }
[16:18:40.105]     {
[16:18:40.105]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.105]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.105]         do.call(mapply, args = args)
[16:18:40.105]     }
[16:18:40.105] }
[16:18:40.105] Lazy evaluation: FALSE
[16:18:40.105] Asynchronous evaluation: FALSE
[16:18:40.105] Local evaluation: TRUE
[16:18:40.105] Environment: R_GlobalEnv
[16:18:40.105] Capture standard output: TRUE
[16:18:40.105] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.105] Globals: 5 objects totaling 336 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.105] Packages: <none>
[16:18:40.105] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.105] Resolved: TRUE
[16:18:40.105] Value: 280 bytes of class ‘list’
[16:18:40.105] Early signaling: FALSE
[16:18:40.105] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.105] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.106] Chunk #1 of 1 ... DONE
[16:18:40.106] Launching 1 futures (chunks) ... DONE
[16:18:40.106] Resolving 1 futures (chunks) ...
[16:18:40.106] resolve() on list ...
[16:18:40.106]  recursive: 0
[16:18:40.106]  length: 1
[16:18:40.106] 
[16:18:40.106] resolved() for ‘SequentialFuture’ ...
[16:18:40.106] - state: ‘finished’
[16:18:40.106] - run: TRUE
[16:18:40.107] - result: ‘FutureResult’
[16:18:40.107] resolved() for ‘SequentialFuture’ ... done
[16:18:40.107] Future #1
[16:18:40.107] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.107] - nx: 1
[16:18:40.107] - relay: TRUE
[16:18:40.107] - stdout: TRUE
[16:18:40.107] - signal: TRUE
[16:18:40.107] - resignal: FALSE
[16:18:40.107] - force: TRUE
[16:18:40.107] - relayed: [n=1] FALSE
[16:18:40.107] - queued futures: [n=1] FALSE
[16:18:40.108]  - until=1
[16:18:40.108]  - relaying element #1
[16:18:40.108] - relayed: [n=1] TRUE
[16:18:40.108] - queued futures: [n=1] TRUE
[16:18:40.108] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.108]  length: 0 (resolved future 1)
[16:18:40.108] Relaying remaining futures
[16:18:40.108] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.108] - nx: 1
[16:18:40.109] - relay: TRUE
[16:18:40.109] - stdout: TRUE
[16:18:40.109] - signal: TRUE
[16:18:40.109] - resignal: FALSE
[16:18:40.109] - force: TRUE
[16:18:40.109] - relayed: [n=1] TRUE
[16:18:40.109] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.109] - relayed: [n=1] TRUE
[16:18:40.109] - queued futures: [n=1] TRUE
[16:18:40.109] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.109] resolve() on list ... DONE
[16:18:40.110]  - Number of value chunks collected: 1
[16:18:40.110] Resolving 1 futures (chunks) ... DONE
[16:18:40.110] Reducing values from 1 chunks ...
[16:18:40.110]  - Number of values collected after concatenation: 4
[16:18:40.110]  - Number of values expected: 4
[16:18:40.110] Reducing values from 1 chunks ... DONE
[16:18:40.110] future_mapply() ... DONE
[16:18:40.110] future_mapply() ...
[16:18:40.110] Number of chunks: 1
[16:18:40.110] getGlobalsAndPackagesXApply() ...
[16:18:40.111]  - future.globals: TRUE
[16:18:40.111] getGlobalsAndPackages() ...
[16:18:40.111] Searching for globals...
[16:18:40.112] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[16:18:40.112] Searching for globals ... DONE
[16:18:40.112] Resolving globals: FALSE
[16:18:40.112] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[16:18:40.113] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[16:18:40.113] - globals: [1] ‘FUN’
[16:18:40.113] 
[16:18:40.113] getGlobalsAndPackages() ... DONE
[16:18:40.113]  - globals found/used: [n=1] ‘FUN’
[16:18:40.113]  - needed namespaces: [n=0] 
[16:18:40.113] Finding globals ... DONE
[16:18:40.114] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.114] List of 2
[16:18:40.114]  $ ...future.FUN:function (x, y)  
[16:18:40.114]  $ MoreArgs     : NULL
[16:18:40.114]  - attr(*, "where")=List of 2
[16:18:40.114]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.114]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.114]  - attr(*, "resolved")= logi FALSE
[16:18:40.114]  - attr(*, "total_size")= num NA
[16:18:40.116] Packages to be attached in all futures: [n=0] 
[16:18:40.116] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.116] Number of futures (= number of chunks): 1
[16:18:40.116] Launching 1 futures (chunks) ...
[16:18:40.116] Chunk #1 of 1 ...
[16:18:40.117]  - Finding globals in '...' for chunk #1 ...
[16:18:40.117] getGlobalsAndPackages() ...
[16:18:40.117] Searching for globals...
[16:18:40.117] 
[16:18:40.117] Searching for globals ... DONE
[16:18:40.117] - globals: [0] <none>
[16:18:40.117] getGlobalsAndPackages() ... DONE
[16:18:40.117]    + additional globals found: [n=0] 
[16:18:40.117]    + additional namespaces needed: [n=0] 
[16:18:40.118]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.118]  - seeds: <none>
[16:18:40.118]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.118] getGlobalsAndPackages() ...
[16:18:40.118] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.118] Resolving globals: FALSE
[16:18:40.118] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[16:18:40.119] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.119] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.119] 
[16:18:40.119] getGlobalsAndPackages() ... DONE
[16:18:40.119] run() for ‘Future’ ...
[16:18:40.120] - state: ‘created’
[16:18:40.120] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.120] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.120] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.120]   - Field: ‘label’
[16:18:40.120]   - Field: ‘local’
[16:18:40.120]   - Field: ‘owner’
[16:18:40.120]   - Field: ‘envir’
[16:18:40.121]   - Field: ‘packages’
[16:18:40.121]   - Field: ‘gc’
[16:18:40.121]   - Field: ‘conditions’
[16:18:40.121]   - Field: ‘expr’
[16:18:40.121]   - Field: ‘uuid’
[16:18:40.121]   - Field: ‘seed’
[16:18:40.121]   - Field: ‘version’
[16:18:40.121]   - Field: ‘result’
[16:18:40.121]   - Field: ‘asynchronous’
[16:18:40.121]   - Field: ‘calls’
[16:18:40.121]   - Field: ‘globals’
[16:18:40.122]   - Field: ‘stdout’
[16:18:40.122]   - Field: ‘earlySignal’
[16:18:40.122]   - Field: ‘lazy’
[16:18:40.122]   - Field: ‘state’
[16:18:40.122] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.122] - Launch lazy future ...
[16:18:40.122] Packages needed by the future expression (n = 0): <none>
[16:18:40.122] Packages needed by future strategies (n = 0): <none>
[16:18:40.123] {
[16:18:40.123]     {
[16:18:40.123]         {
[16:18:40.123]             ...future.startTime <- base::Sys.time()
[16:18:40.123]             {
[16:18:40.123]                 {
[16:18:40.123]                   {
[16:18:40.123]                     base::local({
[16:18:40.123]                       has_future <- base::requireNamespace("future", 
[16:18:40.123]                         quietly = TRUE)
[16:18:40.123]                       if (has_future) {
[16:18:40.123]                         ns <- base::getNamespace("future")
[16:18:40.123]                         version <- ns[[".package"]][["version"]]
[16:18:40.123]                         if (is.null(version)) 
[16:18:40.123]                           version <- utils::packageVersion("future")
[16:18:40.123]                       }
[16:18:40.123]                       else {
[16:18:40.123]                         version <- NULL
[16:18:40.123]                       }
[16:18:40.123]                       if (!has_future || version < "1.8.0") {
[16:18:40.123]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.123]                           "", base::R.version$version.string), 
[16:18:40.123]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.123]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.123]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.123]                             "release", "version")], collapse = " "), 
[16:18:40.123]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.123]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.123]                           info)
[16:18:40.123]                         info <- base::paste(info, collapse = "; ")
[16:18:40.123]                         if (!has_future) {
[16:18:40.123]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.123]                             info)
[16:18:40.123]                         }
[16:18:40.123]                         else {
[16:18:40.123]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.123]                             info, version)
[16:18:40.123]                         }
[16:18:40.123]                         base::stop(msg)
[16:18:40.123]                       }
[16:18:40.123]                     })
[16:18:40.123]                   }
[16:18:40.123]                   ...future.strategy.old <- future::plan("list")
[16:18:40.123]                   options(future.plan = NULL)
[16:18:40.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.123]                 }
[16:18:40.123]                 ...future.workdir <- getwd()
[16:18:40.123]             }
[16:18:40.123]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.123]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.123]         }
[16:18:40.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.123]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.123]             base::names(...future.oldOptions))
[16:18:40.123]     }
[16:18:40.123]     if (FALSE) {
[16:18:40.123]     }
[16:18:40.123]     else {
[16:18:40.123]         if (TRUE) {
[16:18:40.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.123]                 open = "w")
[16:18:40.123]         }
[16:18:40.123]         else {
[16:18:40.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.123]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.123]         }
[16:18:40.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.123]             base::sink(type = "output", split = FALSE)
[16:18:40.123]             base::close(...future.stdout)
[16:18:40.123]         }, add = TRUE)
[16:18:40.123]     }
[16:18:40.123]     ...future.frame <- base::sys.nframe()
[16:18:40.123]     ...future.conditions <- base::list()
[16:18:40.123]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.123]     if (FALSE) {
[16:18:40.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.123]     }
[16:18:40.123]     ...future.result <- base::tryCatch({
[16:18:40.123]         base::withCallingHandlers({
[16:18:40.123]             ...future.value <- base::withVisible(base::local({
[16:18:40.123]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.123]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.123]                   ...future.globals.maxSize)) {
[16:18:40.123]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.123]                   on.exit(options(oopts), add = TRUE)
[16:18:40.123]                 }
[16:18:40.123]                 {
[16:18:40.123]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.123]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.123]                     USE.NAMES = FALSE)
[16:18:40.123]                   do.call(mapply, args = args)
[16:18:40.123]                 }
[16:18:40.123]             }))
[16:18:40.123]             future::FutureResult(value = ...future.value$value, 
[16:18:40.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.123]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.123]                     ...future.globalenv.names))
[16:18:40.123]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.123]         }, condition = base::local({
[16:18:40.123]             c <- base::c
[16:18:40.123]             inherits <- base::inherits
[16:18:40.123]             invokeRestart <- base::invokeRestart
[16:18:40.123]             length <- base::length
[16:18:40.123]             list <- base::list
[16:18:40.123]             seq.int <- base::seq.int
[16:18:40.123]             signalCondition <- base::signalCondition
[16:18:40.123]             sys.calls <- base::sys.calls
[16:18:40.123]             `[[` <- base::`[[`
[16:18:40.123]             `+` <- base::`+`
[16:18:40.123]             `<<-` <- base::`<<-`
[16:18:40.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.123]                   3L)]
[16:18:40.123]             }
[16:18:40.123]             function(cond) {
[16:18:40.123]                 is_error <- inherits(cond, "error")
[16:18:40.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.123]                   NULL)
[16:18:40.123]                 if (is_error) {
[16:18:40.123]                   sessionInformation <- function() {
[16:18:40.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.123]                       search = base::search(), system = base::Sys.info())
[16:18:40.123]                   }
[16:18:40.123]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.123]                     cond$call), session = sessionInformation(), 
[16:18:40.123]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.123]                   signalCondition(cond)
[16:18:40.123]                 }
[16:18:40.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.123]                 "immediateCondition"))) {
[16:18:40.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.123]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.123]                   if (TRUE && !signal) {
[16:18:40.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.123]                     {
[16:18:40.123]                       inherits <- base::inherits
[16:18:40.123]                       invokeRestart <- base::invokeRestart
[16:18:40.123]                       is.null <- base::is.null
[16:18:40.123]                       muffled <- FALSE
[16:18:40.123]                       if (inherits(cond, "message")) {
[16:18:40.123]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.123]                         if (muffled) 
[16:18:40.123]                           invokeRestart("muffleMessage")
[16:18:40.123]                       }
[16:18:40.123]                       else if (inherits(cond, "warning")) {
[16:18:40.123]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.123]                         if (muffled) 
[16:18:40.123]                           invokeRestart("muffleWarning")
[16:18:40.123]                       }
[16:18:40.123]                       else if (inherits(cond, "condition")) {
[16:18:40.123]                         if (!is.null(pattern)) {
[16:18:40.123]                           computeRestarts <- base::computeRestarts
[16:18:40.123]                           grepl <- base::grepl
[16:18:40.123]                           restarts <- computeRestarts(cond)
[16:18:40.123]                           for (restart in restarts) {
[16:18:40.123]                             name <- restart$name
[16:18:40.123]                             if (is.null(name)) 
[16:18:40.123]                               next
[16:18:40.123]                             if (!grepl(pattern, name)) 
[16:18:40.123]                               next
[16:18:40.123]                             invokeRestart(restart)
[16:18:40.123]                             muffled <- TRUE
[16:18:40.123]                             break
[16:18:40.123]                           }
[16:18:40.123]                         }
[16:18:40.123]                       }
[16:18:40.123]                       invisible(muffled)
[16:18:40.123]                     }
[16:18:40.123]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.123]                   }
[16:18:40.123]                 }
[16:18:40.123]                 else {
[16:18:40.123]                   if (TRUE) {
[16:18:40.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.123]                     {
[16:18:40.123]                       inherits <- base::inherits
[16:18:40.123]                       invokeRestart <- base::invokeRestart
[16:18:40.123]                       is.null <- base::is.null
[16:18:40.123]                       muffled <- FALSE
[16:18:40.123]                       if (inherits(cond, "message")) {
[16:18:40.123]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.123]                         if (muffled) 
[16:18:40.123]                           invokeRestart("muffleMessage")
[16:18:40.123]                       }
[16:18:40.123]                       else if (inherits(cond, "warning")) {
[16:18:40.123]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.123]                         if (muffled) 
[16:18:40.123]                           invokeRestart("muffleWarning")
[16:18:40.123]                       }
[16:18:40.123]                       else if (inherits(cond, "condition")) {
[16:18:40.123]                         if (!is.null(pattern)) {
[16:18:40.123]                           computeRestarts <- base::computeRestarts
[16:18:40.123]                           grepl <- base::grepl
[16:18:40.123]                           restarts <- computeRestarts(cond)
[16:18:40.123]                           for (restart in restarts) {
[16:18:40.123]                             name <- restart$name
[16:18:40.123]                             if (is.null(name)) 
[16:18:40.123]                               next
[16:18:40.123]                             if (!grepl(pattern, name)) 
[16:18:40.123]                               next
[16:18:40.123]                             invokeRestart(restart)
[16:18:40.123]                             muffled <- TRUE
[16:18:40.123]                             break
[16:18:40.123]                           }
[16:18:40.123]                         }
[16:18:40.123]                       }
[16:18:40.123]                       invisible(muffled)
[16:18:40.123]                     }
[16:18:40.123]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.123]                   }
[16:18:40.123]                 }
[16:18:40.123]             }
[16:18:40.123]         }))
[16:18:40.123]     }, error = function(ex) {
[16:18:40.123]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.123]                 ...future.rng), started = ...future.startTime, 
[16:18:40.123]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.123]             version = "1.8"), class = "FutureResult")
[16:18:40.123]     }, finally = {
[16:18:40.123]         if (!identical(...future.workdir, getwd())) 
[16:18:40.123]             setwd(...future.workdir)
[16:18:40.123]         {
[16:18:40.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.123]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.123]             }
[16:18:40.123]             base::options(...future.oldOptions)
[16:18:40.123]             if (.Platform$OS.type == "windows") {
[16:18:40.123]                 old_names <- names(...future.oldEnvVars)
[16:18:40.123]                 envs <- base::Sys.getenv()
[16:18:40.123]                 names <- names(envs)
[16:18:40.123]                 common <- intersect(names, old_names)
[16:18:40.123]                 added <- setdiff(names, old_names)
[16:18:40.123]                 removed <- setdiff(old_names, names)
[16:18:40.123]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.123]                   envs[common]]
[16:18:40.123]                 NAMES <- toupper(changed)
[16:18:40.123]                 args <- list()
[16:18:40.123]                 for (kk in seq_along(NAMES)) {
[16:18:40.123]                   name <- changed[[kk]]
[16:18:40.123]                   NAME <- NAMES[[kk]]
[16:18:40.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.123]                     next
[16:18:40.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.123]                 }
[16:18:40.123]                 NAMES <- toupper(added)
[16:18:40.123]                 for (kk in seq_along(NAMES)) {
[16:18:40.123]                   name <- added[[kk]]
[16:18:40.123]                   NAME <- NAMES[[kk]]
[16:18:40.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.123]                     next
[16:18:40.123]                   args[[name]] <- ""
[16:18:40.123]                 }
[16:18:40.123]                 NAMES <- toupper(removed)
[16:18:40.123]                 for (kk in seq_along(NAMES)) {
[16:18:40.123]                   name <- removed[[kk]]
[16:18:40.123]                   NAME <- NAMES[[kk]]
[16:18:40.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.123]                     next
[16:18:40.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.123]                 }
[16:18:40.123]                 if (length(args) > 0) 
[16:18:40.123]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.123]             }
[16:18:40.123]             else {
[16:18:40.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.123]             }
[16:18:40.123]             {
[16:18:40.123]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.123]                   0L) {
[16:18:40.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.123]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.123]                   base::options(opts)
[16:18:40.123]                 }
[16:18:40.123]                 {
[16:18:40.123]                   {
[16:18:40.123]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.123]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.123]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.123]                       inherits = FALSE)
[16:18:40.123]                     NULL
[16:18:40.123]                   }
[16:18:40.123]                   options(future.plan = NULL)
[16:18:40.123]                   if (is.na(NA_character_)) 
[16:18:40.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.123]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.123]                     .init = FALSE)
[16:18:40.123]                 }
[16:18:40.123]             }
[16:18:40.123]         }
[16:18:40.123]     })
[16:18:40.123]     if (TRUE) {
[16:18:40.123]         base::sink(type = "output", split = FALSE)
[16:18:40.123]         if (TRUE) {
[16:18:40.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.123]         }
[16:18:40.123]         else {
[16:18:40.123]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.123]         }
[16:18:40.123]         base::close(...future.stdout)
[16:18:40.123]         ...future.stdout <- NULL
[16:18:40.123]     }
[16:18:40.123]     ...future.result$conditions <- ...future.conditions
[16:18:40.123]     ...future.result$finished <- base::Sys.time()
[16:18:40.123]     ...future.result
[16:18:40.123] }
[16:18:40.124] assign_globals() ...
[16:18:40.124] List of 5
[16:18:40.124]  $ ...future.FUN            :function (x, y)  
[16:18:40.124]  $ MoreArgs                 : NULL
[16:18:40.124]  $ ...future.elements_ii    :List of 2
[16:18:40.124]   ..$ :List of 3
[16:18:40.124]   .. ..$ a: num 1
[16:18:40.124]   .. ..$ b: num 2
[16:18:40.124]   .. ..$ c: num 3
[16:18:40.124]   ..$ :List of 3
[16:18:40.124]   .. ..$ A: num 10
[16:18:40.124]   .. ..$ B: num 0
[16:18:40.124]   .. ..$ C: num -10
[16:18:40.124]  $ ...future.seeds_ii       : NULL
[16:18:40.124]  $ ...future.globals.maxSize: NULL
[16:18:40.124]  - attr(*, "where")=List of 5
[16:18:40.124]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.124]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.124]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.124]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.124]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.124]  - attr(*, "resolved")= logi FALSE
[16:18:40.124]  - attr(*, "total_size")= num 2312
[16:18:40.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.124]  - attr(*, "already-done")= logi TRUE
[16:18:40.132] - reassign environment for ‘...future.FUN’
[16:18:40.132] - copied ‘...future.FUN’ to environment
[16:18:40.132] - copied ‘MoreArgs’ to environment
[16:18:40.132] - copied ‘...future.elements_ii’ to environment
[16:18:40.132] - copied ‘...future.seeds_ii’ to environment
[16:18:40.132] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.132] assign_globals() ... done
[16:18:40.132] plan(): Setting new future strategy stack:
[16:18:40.133] List of future strategies:
[16:18:40.133] 1. sequential:
[16:18:40.133]    - args: function (..., envir = parent.frame())
[16:18:40.133]    - tweaked: FALSE
[16:18:40.133]    - call: NULL
[16:18:40.133] plan(): nbrOfWorkers() = 1
[16:18:40.134] plan(): Setting new future strategy stack:
[16:18:40.134] List of future strategies:
[16:18:40.134] 1. sequential:
[16:18:40.134]    - args: function (..., envir = parent.frame())
[16:18:40.134]    - tweaked: FALSE
[16:18:40.134]    - call: plan(strategy)
[16:18:40.134] plan(): nbrOfWorkers() = 1
[16:18:40.134] SequentialFuture started (and completed)
[16:18:40.134] - Launch lazy future ... done
[16:18:40.134] run() for ‘SequentialFuture’ ... done
[16:18:40.134] Created future:
[16:18:40.135] SequentialFuture:
[16:18:40.135] Label: ‘future_mapply-1’
[16:18:40.135] Expression:
[16:18:40.135] {
[16:18:40.135]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.135]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.135]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.135]         on.exit(options(oopts), add = TRUE)
[16:18:40.135]     }
[16:18:40.135]     {
[16:18:40.135]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.135]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.135]         do.call(mapply, args = args)
[16:18:40.135]     }
[16:18:40.135] }
[16:18:40.135] Lazy evaluation: FALSE
[16:18:40.135] Asynchronous evaluation: FALSE
[16:18:40.135] Local evaluation: TRUE
[16:18:40.135] Environment: R_GlobalEnv
[16:18:40.135] Capture standard output: TRUE
[16:18:40.135] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.135] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.135] Packages: <none>
[16:18:40.135] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.135] Resolved: TRUE
[16:18:40.135] Value: 200 bytes of class ‘list’
[16:18:40.135] Early signaling: FALSE
[16:18:40.135] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.135] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.135] Chunk #1 of 1 ... DONE
[16:18:40.135] Launching 1 futures (chunks) ... DONE
[16:18:40.136] Resolving 1 futures (chunks) ...
[16:18:40.136] resolve() on list ...
[16:18:40.136]  recursive: 0
[16:18:40.136]  length: 1
[16:18:40.136] 
[16:18:40.136] resolved() for ‘SequentialFuture’ ...
[16:18:40.136] - state: ‘finished’
[16:18:40.136] - run: TRUE
[16:18:40.136] - result: ‘FutureResult’
[16:18:40.136] resolved() for ‘SequentialFuture’ ... done
[16:18:40.136] Future #1
[16:18:40.137] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.137] - nx: 1
[16:18:40.137] - relay: TRUE
[16:18:40.137] - stdout: TRUE
[16:18:40.137] - signal: TRUE
[16:18:40.137] - resignal: FALSE
[16:18:40.137] - force: TRUE
[16:18:40.137] - relayed: [n=1] FALSE
[16:18:40.137] - queued futures: [n=1] FALSE
[16:18:40.137]  - until=1
[16:18:40.137]  - relaying element #1
[16:18:40.138] - relayed: [n=1] TRUE
[16:18:40.138] - queued futures: [n=1] TRUE
[16:18:40.138] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.138]  length: 0 (resolved future 1)
[16:18:40.138] Relaying remaining futures
[16:18:40.138] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.138] - nx: 1
[16:18:40.138] - relay: TRUE
[16:18:40.138] - stdout: TRUE
[16:18:40.138] - signal: TRUE
[16:18:40.138] - resignal: FALSE
[16:18:40.139] - force: TRUE
[16:18:40.139] - relayed: [n=1] TRUE
[16:18:40.139] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.139] - relayed: [n=1] TRUE
[16:18:40.139] - queued futures: [n=1] TRUE
[16:18:40.139] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.139] resolve() on list ... DONE
[16:18:40.139]  - Number of value chunks collected: 1
[16:18:40.139] Resolving 1 futures (chunks) ... DONE
[16:18:40.139] Reducing values from 1 chunks ...
[16:18:40.139]  - Number of values collected after concatenation: 3
[16:18:40.140]  - Number of values expected: 3
[16:18:40.140] Reducing values from 1 chunks ... DONE
[16:18:40.140] future_mapply() ... DONE
- future_.mapply()
[16:18:40.140] future_mapply() ...
[16:18:40.141] Number of chunks: 1
[16:18:40.141] getGlobalsAndPackagesXApply() ...
[16:18:40.141]  - future.globals: TRUE
[16:18:40.141] getGlobalsAndPackages() ...
[16:18:40.141] Searching for globals...
[16:18:40.142] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[16:18:40.142] Searching for globals ... DONE
[16:18:40.142] Resolving globals: FALSE
[16:18:40.143] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[16:18:40.143] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[16:18:40.143] - globals: [1] ‘FUN’
[16:18:40.143] 
[16:18:40.143] getGlobalsAndPackages() ... DONE
[16:18:40.143]  - globals found/used: [n=1] ‘FUN’
[16:18:40.144]  - needed namespaces: [n=0] 
[16:18:40.144] Finding globals ... DONE
[16:18:40.144] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.144] List of 2
[16:18:40.144]  $ ...future.FUN:function (x, y)  
[16:18:40.144]  $ MoreArgs     : list()
[16:18:40.144]  - attr(*, "where")=List of 2
[16:18:40.144]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.144]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.144]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.144]  - attr(*, "resolved")= logi FALSE
[16:18:40.144]  - attr(*, "total_size")= num NA
[16:18:40.146] Packages to be attached in all futures: [n=0] 
[16:18:40.146] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.146] Number of futures (= number of chunks): 1
[16:18:40.147] Launching 1 futures (chunks) ...
[16:18:40.147] Chunk #1 of 1 ...
[16:18:40.147]  - Finding globals in '...' for chunk #1 ...
[16:18:40.147] getGlobalsAndPackages() ...
[16:18:40.147] Searching for globals...
[16:18:40.147] 
[16:18:40.147] Searching for globals ... DONE
[16:18:40.147] - globals: [0] <none>
[16:18:40.148] getGlobalsAndPackages() ... DONE
[16:18:40.148]    + additional globals found: [n=0] 
[16:18:40.148]    + additional namespaces needed: [n=0] 
[16:18:40.148]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.148]  - seeds: <none>
[16:18:40.148]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.148] getGlobalsAndPackages() ...
[16:18:40.148] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.148] Resolving globals: FALSE
[16:18:40.150] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[16:18:40.151] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:40.151] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.151] 
[16:18:40.151] getGlobalsAndPackages() ... DONE
[16:18:40.151] run() for ‘Future’ ...
[16:18:40.151] - state: ‘created’
[16:18:40.151] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.152] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.152] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.152]   - Field: ‘label’
[16:18:40.152]   - Field: ‘local’
[16:18:40.152]   - Field: ‘owner’
[16:18:40.152]   - Field: ‘envir’
[16:18:40.152]   - Field: ‘packages’
[16:18:40.153]   - Field: ‘gc’
[16:18:40.153]   - Field: ‘conditions’
[16:18:40.153]   - Field: ‘expr’
[16:18:40.153]   - Field: ‘uuid’
[16:18:40.153]   - Field: ‘seed’
[16:18:40.153]   - Field: ‘version’
[16:18:40.153]   - Field: ‘result’
[16:18:40.153]   - Field: ‘asynchronous’
[16:18:40.153]   - Field: ‘calls’
[16:18:40.153]   - Field: ‘globals’
[16:18:40.153]   - Field: ‘stdout’
[16:18:40.154]   - Field: ‘earlySignal’
[16:18:40.154]   - Field: ‘lazy’
[16:18:40.154]   - Field: ‘state’
[16:18:40.154] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.154] - Launch lazy future ...
[16:18:40.154] Packages needed by the future expression (n = 0): <none>
[16:18:40.154] Packages needed by future strategies (n = 0): <none>
[16:18:40.155] {
[16:18:40.155]     {
[16:18:40.155]         {
[16:18:40.155]             ...future.startTime <- base::Sys.time()
[16:18:40.155]             {
[16:18:40.155]                 {
[16:18:40.155]                   {
[16:18:40.155]                     base::local({
[16:18:40.155]                       has_future <- base::requireNamespace("future", 
[16:18:40.155]                         quietly = TRUE)
[16:18:40.155]                       if (has_future) {
[16:18:40.155]                         ns <- base::getNamespace("future")
[16:18:40.155]                         version <- ns[[".package"]][["version"]]
[16:18:40.155]                         if (is.null(version)) 
[16:18:40.155]                           version <- utils::packageVersion("future")
[16:18:40.155]                       }
[16:18:40.155]                       else {
[16:18:40.155]                         version <- NULL
[16:18:40.155]                       }
[16:18:40.155]                       if (!has_future || version < "1.8.0") {
[16:18:40.155]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.155]                           "", base::R.version$version.string), 
[16:18:40.155]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.155]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.155]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.155]                             "release", "version")], collapse = " "), 
[16:18:40.155]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.155]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.155]                           info)
[16:18:40.155]                         info <- base::paste(info, collapse = "; ")
[16:18:40.155]                         if (!has_future) {
[16:18:40.155]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.155]                             info)
[16:18:40.155]                         }
[16:18:40.155]                         else {
[16:18:40.155]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.155]                             info, version)
[16:18:40.155]                         }
[16:18:40.155]                         base::stop(msg)
[16:18:40.155]                       }
[16:18:40.155]                     })
[16:18:40.155]                   }
[16:18:40.155]                   ...future.strategy.old <- future::plan("list")
[16:18:40.155]                   options(future.plan = NULL)
[16:18:40.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.155]                 }
[16:18:40.155]                 ...future.workdir <- getwd()
[16:18:40.155]             }
[16:18:40.155]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.155]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.155]         }
[16:18:40.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.155]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.155]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.155]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.155]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.155]             base::names(...future.oldOptions))
[16:18:40.155]     }
[16:18:40.155]     if (FALSE) {
[16:18:40.155]     }
[16:18:40.155]     else {
[16:18:40.155]         if (TRUE) {
[16:18:40.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.155]                 open = "w")
[16:18:40.155]         }
[16:18:40.155]         else {
[16:18:40.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.155]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.155]         }
[16:18:40.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.155]             base::sink(type = "output", split = FALSE)
[16:18:40.155]             base::close(...future.stdout)
[16:18:40.155]         }, add = TRUE)
[16:18:40.155]     }
[16:18:40.155]     ...future.frame <- base::sys.nframe()
[16:18:40.155]     ...future.conditions <- base::list()
[16:18:40.155]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.155]     if (FALSE) {
[16:18:40.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.155]     }
[16:18:40.155]     ...future.result <- base::tryCatch({
[16:18:40.155]         base::withCallingHandlers({
[16:18:40.155]             ...future.value <- base::withVisible(base::local({
[16:18:40.155]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.155]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.155]                   ...future.globals.maxSize)) {
[16:18:40.155]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.155]                   on.exit(options(oopts), add = TRUE)
[16:18:40.155]                 }
[16:18:40.155]                 {
[16:18:40.155]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.155]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.155]                     USE.NAMES = FALSE)
[16:18:40.155]                   do.call(mapply, args = args)
[16:18:40.155]                 }
[16:18:40.155]             }))
[16:18:40.155]             future::FutureResult(value = ...future.value$value, 
[16:18:40.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.155]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.155]                     ...future.globalenv.names))
[16:18:40.155]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.155]         }, condition = base::local({
[16:18:40.155]             c <- base::c
[16:18:40.155]             inherits <- base::inherits
[16:18:40.155]             invokeRestart <- base::invokeRestart
[16:18:40.155]             length <- base::length
[16:18:40.155]             list <- base::list
[16:18:40.155]             seq.int <- base::seq.int
[16:18:40.155]             signalCondition <- base::signalCondition
[16:18:40.155]             sys.calls <- base::sys.calls
[16:18:40.155]             `[[` <- base::`[[`
[16:18:40.155]             `+` <- base::`+`
[16:18:40.155]             `<<-` <- base::`<<-`
[16:18:40.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.155]                   3L)]
[16:18:40.155]             }
[16:18:40.155]             function(cond) {
[16:18:40.155]                 is_error <- inherits(cond, "error")
[16:18:40.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.155]                   NULL)
[16:18:40.155]                 if (is_error) {
[16:18:40.155]                   sessionInformation <- function() {
[16:18:40.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.155]                       search = base::search(), system = base::Sys.info())
[16:18:40.155]                   }
[16:18:40.155]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.155]                     cond$call), session = sessionInformation(), 
[16:18:40.155]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.155]                   signalCondition(cond)
[16:18:40.155]                 }
[16:18:40.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.155]                 "immediateCondition"))) {
[16:18:40.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.155]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.155]                   if (TRUE && !signal) {
[16:18:40.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.155]                     {
[16:18:40.155]                       inherits <- base::inherits
[16:18:40.155]                       invokeRestart <- base::invokeRestart
[16:18:40.155]                       is.null <- base::is.null
[16:18:40.155]                       muffled <- FALSE
[16:18:40.155]                       if (inherits(cond, "message")) {
[16:18:40.155]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.155]                         if (muffled) 
[16:18:40.155]                           invokeRestart("muffleMessage")
[16:18:40.155]                       }
[16:18:40.155]                       else if (inherits(cond, "warning")) {
[16:18:40.155]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.155]                         if (muffled) 
[16:18:40.155]                           invokeRestart("muffleWarning")
[16:18:40.155]                       }
[16:18:40.155]                       else if (inherits(cond, "condition")) {
[16:18:40.155]                         if (!is.null(pattern)) {
[16:18:40.155]                           computeRestarts <- base::computeRestarts
[16:18:40.155]                           grepl <- base::grepl
[16:18:40.155]                           restarts <- computeRestarts(cond)
[16:18:40.155]                           for (restart in restarts) {
[16:18:40.155]                             name <- restart$name
[16:18:40.155]                             if (is.null(name)) 
[16:18:40.155]                               next
[16:18:40.155]                             if (!grepl(pattern, name)) 
[16:18:40.155]                               next
[16:18:40.155]                             invokeRestart(restart)
[16:18:40.155]                             muffled <- TRUE
[16:18:40.155]                             break
[16:18:40.155]                           }
[16:18:40.155]                         }
[16:18:40.155]                       }
[16:18:40.155]                       invisible(muffled)
[16:18:40.155]                     }
[16:18:40.155]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.155]                   }
[16:18:40.155]                 }
[16:18:40.155]                 else {
[16:18:40.155]                   if (TRUE) {
[16:18:40.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.155]                     {
[16:18:40.155]                       inherits <- base::inherits
[16:18:40.155]                       invokeRestart <- base::invokeRestart
[16:18:40.155]                       is.null <- base::is.null
[16:18:40.155]                       muffled <- FALSE
[16:18:40.155]                       if (inherits(cond, "message")) {
[16:18:40.155]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.155]                         if (muffled) 
[16:18:40.155]                           invokeRestart("muffleMessage")
[16:18:40.155]                       }
[16:18:40.155]                       else if (inherits(cond, "warning")) {
[16:18:40.155]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.155]                         if (muffled) 
[16:18:40.155]                           invokeRestart("muffleWarning")
[16:18:40.155]                       }
[16:18:40.155]                       else if (inherits(cond, "condition")) {
[16:18:40.155]                         if (!is.null(pattern)) {
[16:18:40.155]                           computeRestarts <- base::computeRestarts
[16:18:40.155]                           grepl <- base::grepl
[16:18:40.155]                           restarts <- computeRestarts(cond)
[16:18:40.155]                           for (restart in restarts) {
[16:18:40.155]                             name <- restart$name
[16:18:40.155]                             if (is.null(name)) 
[16:18:40.155]                               next
[16:18:40.155]                             if (!grepl(pattern, name)) 
[16:18:40.155]                               next
[16:18:40.155]                             invokeRestart(restart)
[16:18:40.155]                             muffled <- TRUE
[16:18:40.155]                             break
[16:18:40.155]                           }
[16:18:40.155]                         }
[16:18:40.155]                       }
[16:18:40.155]                       invisible(muffled)
[16:18:40.155]                     }
[16:18:40.155]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.155]                   }
[16:18:40.155]                 }
[16:18:40.155]             }
[16:18:40.155]         }))
[16:18:40.155]     }, error = function(ex) {
[16:18:40.155]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.155]                 ...future.rng), started = ...future.startTime, 
[16:18:40.155]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.155]             version = "1.8"), class = "FutureResult")
[16:18:40.155]     }, finally = {
[16:18:40.155]         if (!identical(...future.workdir, getwd())) 
[16:18:40.155]             setwd(...future.workdir)
[16:18:40.155]         {
[16:18:40.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.155]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.155]             }
[16:18:40.155]             base::options(...future.oldOptions)
[16:18:40.155]             if (.Platform$OS.type == "windows") {
[16:18:40.155]                 old_names <- names(...future.oldEnvVars)
[16:18:40.155]                 envs <- base::Sys.getenv()
[16:18:40.155]                 names <- names(envs)
[16:18:40.155]                 common <- intersect(names, old_names)
[16:18:40.155]                 added <- setdiff(names, old_names)
[16:18:40.155]                 removed <- setdiff(old_names, names)
[16:18:40.155]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.155]                   envs[common]]
[16:18:40.155]                 NAMES <- toupper(changed)
[16:18:40.155]                 args <- list()
[16:18:40.155]                 for (kk in seq_along(NAMES)) {
[16:18:40.155]                   name <- changed[[kk]]
[16:18:40.155]                   NAME <- NAMES[[kk]]
[16:18:40.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.155]                     next
[16:18:40.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.155]                 }
[16:18:40.155]                 NAMES <- toupper(added)
[16:18:40.155]                 for (kk in seq_along(NAMES)) {
[16:18:40.155]                   name <- added[[kk]]
[16:18:40.155]                   NAME <- NAMES[[kk]]
[16:18:40.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.155]                     next
[16:18:40.155]                   args[[name]] <- ""
[16:18:40.155]                 }
[16:18:40.155]                 NAMES <- toupper(removed)
[16:18:40.155]                 for (kk in seq_along(NAMES)) {
[16:18:40.155]                   name <- removed[[kk]]
[16:18:40.155]                   NAME <- NAMES[[kk]]
[16:18:40.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.155]                     next
[16:18:40.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.155]                 }
[16:18:40.155]                 if (length(args) > 0) 
[16:18:40.155]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.155]             }
[16:18:40.155]             else {
[16:18:40.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.155]             }
[16:18:40.155]             {
[16:18:40.155]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.155]                   0L) {
[16:18:40.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.155]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.155]                   base::options(opts)
[16:18:40.155]                 }
[16:18:40.155]                 {
[16:18:40.155]                   {
[16:18:40.155]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.155]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.155]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.155]                       inherits = FALSE)
[16:18:40.155]                     NULL
[16:18:40.155]                   }
[16:18:40.155]                   options(future.plan = NULL)
[16:18:40.155]                   if (is.na(NA_character_)) 
[16:18:40.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.155]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.155]                     .init = FALSE)
[16:18:40.155]                 }
[16:18:40.155]             }
[16:18:40.155]         }
[16:18:40.155]     })
[16:18:40.155]     if (TRUE) {
[16:18:40.155]         base::sink(type = "output", split = FALSE)
[16:18:40.155]         if (TRUE) {
[16:18:40.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.155]         }
[16:18:40.155]         else {
[16:18:40.155]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.155]         }
[16:18:40.155]         base::close(...future.stdout)
[16:18:40.155]         ...future.stdout <- NULL
[16:18:40.155]     }
[16:18:40.155]     ...future.result$conditions <- ...future.conditions
[16:18:40.155]     ...future.result$finished <- base::Sys.time()
[16:18:40.155]     ...future.result
[16:18:40.155] }
[16:18:40.156] assign_globals() ...
[16:18:40.156] List of 5
[16:18:40.156]  $ ...future.FUN            :function (x, y)  
[16:18:40.156]  $ MoreArgs                 : list()
[16:18:40.156]  $ ...future.elements_ii    :List of 2
[16:18:40.156]   ..$ :List of 3
[16:18:40.156]   .. ..$ a: num 1
[16:18:40.156]   .. ..$ b: num 2
[16:18:40.156]   .. ..$ c: num 3
[16:18:40.156]   ..$ :List of 3
[16:18:40.156]   .. ..$ A: num 10
[16:18:40.156]   .. ..$ B: num 0
[16:18:40.156]   .. ..$ C: num -10
[16:18:40.156]  $ ...future.seeds_ii       : NULL
[16:18:40.156]  $ ...future.globals.maxSize: NULL
[16:18:40.156]  - attr(*, "where")=List of 5
[16:18:40.156]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.156]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.156]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.156]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.156]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.156]  - attr(*, "resolved")= logi FALSE
[16:18:40.156]  - attr(*, "total_size")= num 2312
[16:18:40.156]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.156]  - attr(*, "already-done")= logi TRUE
[16:18:40.162] - reassign environment for ‘...future.FUN’
[16:18:40.162] - copied ‘...future.FUN’ to environment
[16:18:40.162] - copied ‘MoreArgs’ to environment
[16:18:40.163] - copied ‘...future.elements_ii’ to environment
[16:18:40.163] - copied ‘...future.seeds_ii’ to environment
[16:18:40.163] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.163] assign_globals() ... done
[16:18:40.163] plan(): Setting new future strategy stack:
[16:18:40.163] List of future strategies:
[16:18:40.163] 1. sequential:
[16:18:40.163]    - args: function (..., envir = parent.frame())
[16:18:40.163]    - tweaked: FALSE
[16:18:40.163]    - call: NULL
[16:18:40.163] plan(): nbrOfWorkers() = 1
[16:18:40.164] plan(): Setting new future strategy stack:
[16:18:40.164] List of future strategies:
[16:18:40.164] 1. sequential:
[16:18:40.164]    - args: function (..., envir = parent.frame())
[16:18:40.164]    - tweaked: FALSE
[16:18:40.164]    - call: plan(strategy)
[16:18:40.165] plan(): nbrOfWorkers() = 1
[16:18:40.165] SequentialFuture started (and completed)
[16:18:40.165] - Launch lazy future ... done
[16:18:40.165] run() for ‘SequentialFuture’ ... done
[16:18:40.165] Created future:
[16:18:40.165] SequentialFuture:
[16:18:40.165] Label: ‘future_.mapply-1’
[16:18:40.165] Expression:
[16:18:40.165] {
[16:18:40.165]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.165]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.165]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.165]         on.exit(options(oopts), add = TRUE)
[16:18:40.165]     }
[16:18:40.165]     {
[16:18:40.165]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.165]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.165]         do.call(mapply, args = args)
[16:18:40.165]     }
[16:18:40.165] }
[16:18:40.165] Lazy evaluation: FALSE
[16:18:40.165] Asynchronous evaluation: FALSE
[16:18:40.165] Local evaluation: TRUE
[16:18:40.165] Environment: R_GlobalEnv
[16:18:40.165] Capture standard output: TRUE
[16:18:40.165] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.165] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.165] Packages: <none>
[16:18:40.165] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.165] Resolved: TRUE
[16:18:40.165] Value: 200 bytes of class ‘list’
[16:18:40.165] Early signaling: FALSE
[16:18:40.165] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.165] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.166] Chunk #1 of 1 ... DONE
[16:18:40.166] Launching 1 futures (chunks) ... DONE
[16:18:40.166] Resolving 1 futures (chunks) ...
[16:18:40.166] resolve() on list ...
[16:18:40.166]  recursive: 0
[16:18:40.167]  length: 1
[16:18:40.167] 
[16:18:40.167] resolved() for ‘SequentialFuture’ ...
[16:18:40.167] - state: ‘finished’
[16:18:40.167] - run: TRUE
[16:18:40.167] - result: ‘FutureResult’
[16:18:40.167] resolved() for ‘SequentialFuture’ ... done
[16:18:40.167] Future #1
[16:18:40.167] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.167] - nx: 1
[16:18:40.167] - relay: TRUE
[16:18:40.168] - stdout: TRUE
[16:18:40.168] - signal: TRUE
[16:18:40.168] - resignal: FALSE
[16:18:40.168] - force: TRUE
[16:18:40.168] - relayed: [n=1] FALSE
[16:18:40.168] - queued futures: [n=1] FALSE
[16:18:40.168]  - until=1
[16:18:40.168]  - relaying element #1
[16:18:40.168] - relayed: [n=1] TRUE
[16:18:40.168] - queued futures: [n=1] TRUE
[16:18:40.169] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.169]  length: 0 (resolved future 1)
[16:18:40.169] Relaying remaining futures
[16:18:40.169] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.169] - nx: 1
[16:18:40.169] - relay: TRUE
[16:18:40.169] - stdout: TRUE
[16:18:40.169] - signal: TRUE
[16:18:40.169] - resignal: FALSE
[16:18:40.169] - force: TRUE
[16:18:40.169] - relayed: [n=1] TRUE
[16:18:40.169] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.170] - relayed: [n=1] TRUE
[16:18:40.170] - queued futures: [n=1] TRUE
[16:18:40.170] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.170] resolve() on list ... DONE
[16:18:40.170]  - Number of value chunks collected: 1
[16:18:40.170] Resolving 1 futures (chunks) ... DONE
[16:18:40.170] Reducing values from 1 chunks ...
[16:18:40.170]  - Number of values collected after concatenation: 3
[16:18:40.170]  - Number of values expected: 3
[16:18:40.170] Reducing values from 1 chunks ... DONE
[16:18:40.171] future_mapply() ... DONE
[16:18:40.171] future_mapply() ...
[16:18:40.174] Number of chunks: 5
[16:18:40.174] getGlobalsAndPackagesXApply() ...
[16:18:40.174]  - future.globals: TRUE
[16:18:40.175] getGlobalsAndPackages() ...
[16:18:40.175] Searching for globals...
[16:18:40.176] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:40.176] Searching for globals ... DONE
[16:18:40.176] Resolving globals: FALSE
[16:18:40.176] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:40.177] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:40.177] - globals: [1] ‘FUN’
[16:18:40.177] 
[16:18:40.177] getGlobalsAndPackages() ... DONE
[16:18:40.177]  - globals found/used: [n=1] ‘FUN’
[16:18:40.177]  - needed namespaces: [n=0] 
[16:18:40.177] Finding globals ... DONE
[16:18:40.178] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.178] List of 2
[16:18:40.178]  $ ...future.FUN:function (C, k)  
[16:18:40.178]  $ MoreArgs     : NULL
[16:18:40.178]  - attr(*, "where")=List of 2
[16:18:40.178]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.178]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.178]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.178]  - attr(*, "resolved")= logi FALSE
[16:18:40.178]  - attr(*, "total_size")= num NA
[16:18:40.180] Packages to be attached in all futures: [n=0] 
[16:18:40.180] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.180] Number of futures (= number of chunks): 5
[16:18:40.180] Launching 5 futures (chunks) ...
[16:18:40.181] Chunk #1 of 5 ...
[16:18:40.181]  - Finding globals in '...' for chunk #1 ...
[16:18:40.181] getGlobalsAndPackages() ...
[16:18:40.181] Searching for globals...
[16:18:40.181] 
[16:18:40.181] Searching for globals ... DONE
[16:18:40.181] - globals: [0] <none>
[16:18:40.181] getGlobalsAndPackages() ... DONE
[16:18:40.182]    + additional globals found: [n=0] 
[16:18:40.182]    + additional namespaces needed: [n=0] 
[16:18:40.182]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.182]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:40.182]  - seeds: <none>
[16:18:40.182]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.182] getGlobalsAndPackages() ...
[16:18:40.182] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.182] Resolving globals: FALSE
[16:18:40.183] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:40.183] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.183] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.183] 
[16:18:40.183] getGlobalsAndPackages() ... DONE
[16:18:40.184] run() for ‘Future’ ...
[16:18:40.184] - state: ‘created’
[16:18:40.184] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.184] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.184] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.184]   - Field: ‘label’
[16:18:40.185]   - Field: ‘local’
[16:18:40.185]   - Field: ‘owner’
[16:18:40.185]   - Field: ‘envir’
[16:18:40.185]   - Field: ‘packages’
[16:18:40.185]   - Field: ‘gc’
[16:18:40.185]   - Field: ‘conditions’
[16:18:40.185]   - Field: ‘expr’
[16:18:40.185]   - Field: ‘uuid’
[16:18:40.185]   - Field: ‘seed’
[16:18:40.185]   - Field: ‘version’
[16:18:40.185]   - Field: ‘result’
[16:18:40.186]   - Field: ‘asynchronous’
[16:18:40.186]   - Field: ‘calls’
[16:18:40.186]   - Field: ‘globals’
[16:18:40.186]   - Field: ‘stdout’
[16:18:40.186]   - Field: ‘earlySignal’
[16:18:40.186]   - Field: ‘lazy’
[16:18:40.186]   - Field: ‘state’
[16:18:40.186] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.186] - Launch lazy future ...
[16:18:40.186] Packages needed by the future expression (n = 0): <none>
[16:18:40.187] Packages needed by future strategies (n = 0): <none>
[16:18:40.187] {
[16:18:40.187]     {
[16:18:40.187]         {
[16:18:40.187]             ...future.startTime <- base::Sys.time()
[16:18:40.187]             {
[16:18:40.187]                 {
[16:18:40.187]                   {
[16:18:40.187]                     base::local({
[16:18:40.187]                       has_future <- base::requireNamespace("future", 
[16:18:40.187]                         quietly = TRUE)
[16:18:40.187]                       if (has_future) {
[16:18:40.187]                         ns <- base::getNamespace("future")
[16:18:40.187]                         version <- ns[[".package"]][["version"]]
[16:18:40.187]                         if (is.null(version)) 
[16:18:40.187]                           version <- utils::packageVersion("future")
[16:18:40.187]                       }
[16:18:40.187]                       else {
[16:18:40.187]                         version <- NULL
[16:18:40.187]                       }
[16:18:40.187]                       if (!has_future || version < "1.8.0") {
[16:18:40.187]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.187]                           "", base::R.version$version.string), 
[16:18:40.187]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.187]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.187]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.187]                             "release", "version")], collapse = " "), 
[16:18:40.187]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.187]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.187]                           info)
[16:18:40.187]                         info <- base::paste(info, collapse = "; ")
[16:18:40.187]                         if (!has_future) {
[16:18:40.187]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.187]                             info)
[16:18:40.187]                         }
[16:18:40.187]                         else {
[16:18:40.187]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.187]                             info, version)
[16:18:40.187]                         }
[16:18:40.187]                         base::stop(msg)
[16:18:40.187]                       }
[16:18:40.187]                     })
[16:18:40.187]                   }
[16:18:40.187]                   ...future.strategy.old <- future::plan("list")
[16:18:40.187]                   options(future.plan = NULL)
[16:18:40.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.187]                 }
[16:18:40.187]                 ...future.workdir <- getwd()
[16:18:40.187]             }
[16:18:40.187]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.187]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.187]         }
[16:18:40.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.187]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:40.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.187]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.187]             base::names(...future.oldOptions))
[16:18:40.187]     }
[16:18:40.187]     if (FALSE) {
[16:18:40.187]     }
[16:18:40.187]     else {
[16:18:40.187]         if (TRUE) {
[16:18:40.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.187]                 open = "w")
[16:18:40.187]         }
[16:18:40.187]         else {
[16:18:40.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.187]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.187]         }
[16:18:40.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.187]             base::sink(type = "output", split = FALSE)
[16:18:40.187]             base::close(...future.stdout)
[16:18:40.187]         }, add = TRUE)
[16:18:40.187]     }
[16:18:40.187]     ...future.frame <- base::sys.nframe()
[16:18:40.187]     ...future.conditions <- base::list()
[16:18:40.187]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.187]     if (FALSE) {
[16:18:40.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.187]     }
[16:18:40.187]     ...future.result <- base::tryCatch({
[16:18:40.187]         base::withCallingHandlers({
[16:18:40.187]             ...future.value <- base::withVisible(base::local({
[16:18:40.187]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.187]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.187]                   ...future.globals.maxSize)) {
[16:18:40.187]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.187]                   on.exit(options(oopts), add = TRUE)
[16:18:40.187]                 }
[16:18:40.187]                 {
[16:18:40.187]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.187]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.187]                     USE.NAMES = FALSE)
[16:18:40.187]                   do.call(mapply, args = args)
[16:18:40.187]                 }
[16:18:40.187]             }))
[16:18:40.187]             future::FutureResult(value = ...future.value$value, 
[16:18:40.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.187]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.187]                     ...future.globalenv.names))
[16:18:40.187]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.187]         }, condition = base::local({
[16:18:40.187]             c <- base::c
[16:18:40.187]             inherits <- base::inherits
[16:18:40.187]             invokeRestart <- base::invokeRestart
[16:18:40.187]             length <- base::length
[16:18:40.187]             list <- base::list
[16:18:40.187]             seq.int <- base::seq.int
[16:18:40.187]             signalCondition <- base::signalCondition
[16:18:40.187]             sys.calls <- base::sys.calls
[16:18:40.187]             `[[` <- base::`[[`
[16:18:40.187]             `+` <- base::`+`
[16:18:40.187]             `<<-` <- base::`<<-`
[16:18:40.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.187]                   3L)]
[16:18:40.187]             }
[16:18:40.187]             function(cond) {
[16:18:40.187]                 is_error <- inherits(cond, "error")
[16:18:40.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.187]                   NULL)
[16:18:40.187]                 if (is_error) {
[16:18:40.187]                   sessionInformation <- function() {
[16:18:40.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.187]                       search = base::search(), system = base::Sys.info())
[16:18:40.187]                   }
[16:18:40.187]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.187]                     cond$call), session = sessionInformation(), 
[16:18:40.187]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.187]                   signalCondition(cond)
[16:18:40.187]                 }
[16:18:40.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.187]                 "immediateCondition"))) {
[16:18:40.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.187]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.187]                   if (TRUE && !signal) {
[16:18:40.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.187]                     {
[16:18:40.187]                       inherits <- base::inherits
[16:18:40.187]                       invokeRestart <- base::invokeRestart
[16:18:40.187]                       is.null <- base::is.null
[16:18:40.187]                       muffled <- FALSE
[16:18:40.187]                       if (inherits(cond, "message")) {
[16:18:40.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.187]                         if (muffled) 
[16:18:40.187]                           invokeRestart("muffleMessage")
[16:18:40.187]                       }
[16:18:40.187]                       else if (inherits(cond, "warning")) {
[16:18:40.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.187]                         if (muffled) 
[16:18:40.187]                           invokeRestart("muffleWarning")
[16:18:40.187]                       }
[16:18:40.187]                       else if (inherits(cond, "condition")) {
[16:18:40.187]                         if (!is.null(pattern)) {
[16:18:40.187]                           computeRestarts <- base::computeRestarts
[16:18:40.187]                           grepl <- base::grepl
[16:18:40.187]                           restarts <- computeRestarts(cond)
[16:18:40.187]                           for (restart in restarts) {
[16:18:40.187]                             name <- restart$name
[16:18:40.187]                             if (is.null(name)) 
[16:18:40.187]                               next
[16:18:40.187]                             if (!grepl(pattern, name)) 
[16:18:40.187]                               next
[16:18:40.187]                             invokeRestart(restart)
[16:18:40.187]                             muffled <- TRUE
[16:18:40.187]                             break
[16:18:40.187]                           }
[16:18:40.187]                         }
[16:18:40.187]                       }
[16:18:40.187]                       invisible(muffled)
[16:18:40.187]                     }
[16:18:40.187]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.187]                   }
[16:18:40.187]                 }
[16:18:40.187]                 else {
[16:18:40.187]                   if (TRUE) {
[16:18:40.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.187]                     {
[16:18:40.187]                       inherits <- base::inherits
[16:18:40.187]                       invokeRestart <- base::invokeRestart
[16:18:40.187]                       is.null <- base::is.null
[16:18:40.187]                       muffled <- FALSE
[16:18:40.187]                       if (inherits(cond, "message")) {
[16:18:40.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.187]                         if (muffled) 
[16:18:40.187]                           invokeRestart("muffleMessage")
[16:18:40.187]                       }
[16:18:40.187]                       else if (inherits(cond, "warning")) {
[16:18:40.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.187]                         if (muffled) 
[16:18:40.187]                           invokeRestart("muffleWarning")
[16:18:40.187]                       }
[16:18:40.187]                       else if (inherits(cond, "condition")) {
[16:18:40.187]                         if (!is.null(pattern)) {
[16:18:40.187]                           computeRestarts <- base::computeRestarts
[16:18:40.187]                           grepl <- base::grepl
[16:18:40.187]                           restarts <- computeRestarts(cond)
[16:18:40.187]                           for (restart in restarts) {
[16:18:40.187]                             name <- restart$name
[16:18:40.187]                             if (is.null(name)) 
[16:18:40.187]                               next
[16:18:40.187]                             if (!grepl(pattern, name)) 
[16:18:40.187]                               next
[16:18:40.187]                             invokeRestart(restart)
[16:18:40.187]                             muffled <- TRUE
[16:18:40.187]                             break
[16:18:40.187]                           }
[16:18:40.187]                         }
[16:18:40.187]                       }
[16:18:40.187]                       invisible(muffled)
[16:18:40.187]                     }
[16:18:40.187]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.187]                   }
[16:18:40.187]                 }
[16:18:40.187]             }
[16:18:40.187]         }))
[16:18:40.187]     }, error = function(ex) {
[16:18:40.187]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.187]                 ...future.rng), started = ...future.startTime, 
[16:18:40.187]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.187]             version = "1.8"), class = "FutureResult")
[16:18:40.187]     }, finally = {
[16:18:40.187]         if (!identical(...future.workdir, getwd())) 
[16:18:40.187]             setwd(...future.workdir)
[16:18:40.187]         {
[16:18:40.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.187]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.187]             }
[16:18:40.187]             base::options(...future.oldOptions)
[16:18:40.187]             if (.Platform$OS.type == "windows") {
[16:18:40.187]                 old_names <- names(...future.oldEnvVars)
[16:18:40.187]                 envs <- base::Sys.getenv()
[16:18:40.187]                 names <- names(envs)
[16:18:40.187]                 common <- intersect(names, old_names)
[16:18:40.187]                 added <- setdiff(names, old_names)
[16:18:40.187]                 removed <- setdiff(old_names, names)
[16:18:40.187]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.187]                   envs[common]]
[16:18:40.187]                 NAMES <- toupper(changed)
[16:18:40.187]                 args <- list()
[16:18:40.187]                 for (kk in seq_along(NAMES)) {
[16:18:40.187]                   name <- changed[[kk]]
[16:18:40.187]                   NAME <- NAMES[[kk]]
[16:18:40.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.187]                     next
[16:18:40.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.187]                 }
[16:18:40.187]                 NAMES <- toupper(added)
[16:18:40.187]                 for (kk in seq_along(NAMES)) {
[16:18:40.187]                   name <- added[[kk]]
[16:18:40.187]                   NAME <- NAMES[[kk]]
[16:18:40.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.187]                     next
[16:18:40.187]                   args[[name]] <- ""
[16:18:40.187]                 }
[16:18:40.187]                 NAMES <- toupper(removed)
[16:18:40.187]                 for (kk in seq_along(NAMES)) {
[16:18:40.187]                   name <- removed[[kk]]
[16:18:40.187]                   NAME <- NAMES[[kk]]
[16:18:40.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.187]                     next
[16:18:40.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.187]                 }
[16:18:40.187]                 if (length(args) > 0) 
[16:18:40.187]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.187]             }
[16:18:40.187]             else {
[16:18:40.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.187]             }
[16:18:40.187]             {
[16:18:40.187]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.187]                   0L) {
[16:18:40.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.187]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.187]                   base::options(opts)
[16:18:40.187]                 }
[16:18:40.187]                 {
[16:18:40.187]                   {
[16:18:40.187]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.187]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.187]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.187]                       inherits = FALSE)
[16:18:40.187]                     NULL
[16:18:40.187]                   }
[16:18:40.187]                   options(future.plan = NULL)
[16:18:40.187]                   if (is.na(NA_character_)) 
[16:18:40.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.187]                     .init = FALSE)
[16:18:40.187]                 }
[16:18:40.187]             }
[16:18:40.187]         }
[16:18:40.187]     })
[16:18:40.187]     if (TRUE) {
[16:18:40.187]         base::sink(type = "output", split = FALSE)
[16:18:40.187]         if (TRUE) {
[16:18:40.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.187]         }
[16:18:40.187]         else {
[16:18:40.187]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.187]         }
[16:18:40.187]         base::close(...future.stdout)
[16:18:40.187]         ...future.stdout <- NULL
[16:18:40.187]     }
[16:18:40.187]     ...future.result$conditions <- ...future.conditions
[16:18:40.187]     ...future.result$finished <- base::Sys.time()
[16:18:40.187]     ...future.result
[16:18:40.187] }
[16:18:40.189] assign_globals() ...
[16:18:40.189] List of 5
[16:18:40.189]  $ ...future.FUN            :function (C, k)  
[16:18:40.189]  $ MoreArgs                 : NULL
[16:18:40.189]  $ ...future.elements_ii    :List of 2
[16:18:40.189]   ..$ :List of 1
[16:18:40.189]   .. ..$ : chr "A"
[16:18:40.189]   ..$ :List of 1
[16:18:40.189]   .. ..$ : int 5
[16:18:40.189]  $ ...future.seeds_ii       : NULL
[16:18:40.189]  $ ...future.globals.maxSize: NULL
[16:18:40.189]  - attr(*, "where")=List of 5
[16:18:40.189]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.189]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.189]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.189]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.189]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.189]  - attr(*, "resolved")= logi FALSE
[16:18:40.189]  - attr(*, "total_size")= num 3488
[16:18:40.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.189]  - attr(*, "already-done")= logi TRUE
[16:18:40.193] - reassign environment for ‘...future.FUN’
[16:18:40.193] - copied ‘...future.FUN’ to environment
[16:18:40.194] - copied ‘MoreArgs’ to environment
[16:18:40.194] - copied ‘...future.elements_ii’ to environment
[16:18:40.194] - copied ‘...future.seeds_ii’ to environment
[16:18:40.194] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.194] assign_globals() ... done
[16:18:40.194] plan(): Setting new future strategy stack:
[16:18:40.194] List of future strategies:
[16:18:40.194] 1. sequential:
[16:18:40.194]    - args: function (..., envir = parent.frame())
[16:18:40.194]    - tweaked: FALSE
[16:18:40.194]    - call: NULL
[16:18:40.195] plan(): nbrOfWorkers() = 1
[16:18:40.195] plan(): Setting new future strategy stack:
[16:18:40.197] List of future strategies:
[16:18:40.197] 1. sequential:
[16:18:40.197]    - args: function (..., envir = parent.frame())
[16:18:40.197]    - tweaked: FALSE
[16:18:40.197]    - call: plan(strategy)
[16:18:40.197] plan(): nbrOfWorkers() = 1
[16:18:40.197] SequentialFuture started (and completed)
[16:18:40.197] - Launch lazy future ... done
[16:18:40.197] run() for ‘SequentialFuture’ ... done
[16:18:40.198] Created future:
[16:18:40.198] SequentialFuture:
[16:18:40.198] Label: ‘future_mapply-1’
[16:18:40.198] Expression:
[16:18:40.198] {
[16:18:40.198]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.198]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.198]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.198]         on.exit(options(oopts), add = TRUE)
[16:18:40.198]     }
[16:18:40.198]     {
[16:18:40.198]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.198]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.198]         do.call(mapply, args = args)
[16:18:40.198]     }
[16:18:40.198] }
[16:18:40.198] Lazy evaluation: FALSE
[16:18:40.198] Asynchronous evaluation: FALSE
[16:18:40.198] Local evaluation: TRUE
[16:18:40.198] Environment: R_GlobalEnv
[16:18:40.198] Capture standard output: TRUE
[16:18:40.198] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.198] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.198] Packages: <none>
[16:18:40.198] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.198] Resolved: TRUE
[16:18:40.198] Value: 112 bytes of class ‘list’
[16:18:40.198] Early signaling: FALSE
[16:18:40.198] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.198] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.199] Chunk #1 of 5 ... DONE
[16:18:40.199] Chunk #2 of 5 ...
[16:18:40.199]  - Finding globals in '...' for chunk #2 ...
[16:18:40.199] getGlobalsAndPackages() ...
[16:18:40.199] Searching for globals...
[16:18:40.199] 
[16:18:40.199] Searching for globals ... DONE
[16:18:40.200] - globals: [0] <none>
[16:18:40.200] getGlobalsAndPackages() ... DONE
[16:18:40.200]    + additional globals found: [n=0] 
[16:18:40.200]    + additional namespaces needed: [n=0] 
[16:18:40.200]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:40.200]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:40.200]  - seeds: <none>
[16:18:40.200]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.200] getGlobalsAndPackages() ...
[16:18:40.200] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.201] Resolving globals: FALSE
[16:18:40.201] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:40.201] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.202] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.202] 
[16:18:40.202] getGlobalsAndPackages() ... DONE
[16:18:40.202] run() for ‘Future’ ...
[16:18:40.202] - state: ‘created’
[16:18:40.202] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.202] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.203]   - Field: ‘label’
[16:18:40.203]   - Field: ‘local’
[16:18:40.203]   - Field: ‘owner’
[16:18:40.203]   - Field: ‘envir’
[16:18:40.203]   - Field: ‘packages’
[16:18:40.203]   - Field: ‘gc’
[16:18:40.203]   - Field: ‘conditions’
[16:18:40.203]   - Field: ‘expr’
[16:18:40.203]   - Field: ‘uuid’
[16:18:40.203]   - Field: ‘seed’
[16:18:40.204]   - Field: ‘version’
[16:18:40.204]   - Field: ‘result’
[16:18:40.204]   - Field: ‘asynchronous’
[16:18:40.204]   - Field: ‘calls’
[16:18:40.204]   - Field: ‘globals’
[16:18:40.204]   - Field: ‘stdout’
[16:18:40.204]   - Field: ‘earlySignal’
[16:18:40.204]   - Field: ‘lazy’
[16:18:40.204]   - Field: ‘state’
[16:18:40.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.204] - Launch lazy future ...
[16:18:40.205] Packages needed by the future expression (n = 0): <none>
[16:18:40.205] Packages needed by future strategies (n = 0): <none>
[16:18:40.205] {
[16:18:40.205]     {
[16:18:40.205]         {
[16:18:40.205]             ...future.startTime <- base::Sys.time()
[16:18:40.205]             {
[16:18:40.205]                 {
[16:18:40.205]                   {
[16:18:40.205]                     base::local({
[16:18:40.205]                       has_future <- base::requireNamespace("future", 
[16:18:40.205]                         quietly = TRUE)
[16:18:40.205]                       if (has_future) {
[16:18:40.205]                         ns <- base::getNamespace("future")
[16:18:40.205]                         version <- ns[[".package"]][["version"]]
[16:18:40.205]                         if (is.null(version)) 
[16:18:40.205]                           version <- utils::packageVersion("future")
[16:18:40.205]                       }
[16:18:40.205]                       else {
[16:18:40.205]                         version <- NULL
[16:18:40.205]                       }
[16:18:40.205]                       if (!has_future || version < "1.8.0") {
[16:18:40.205]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.205]                           "", base::R.version$version.string), 
[16:18:40.205]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.205]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.205]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.205]                             "release", "version")], collapse = " "), 
[16:18:40.205]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.205]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.205]                           info)
[16:18:40.205]                         info <- base::paste(info, collapse = "; ")
[16:18:40.205]                         if (!has_future) {
[16:18:40.205]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.205]                             info)
[16:18:40.205]                         }
[16:18:40.205]                         else {
[16:18:40.205]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.205]                             info, version)
[16:18:40.205]                         }
[16:18:40.205]                         base::stop(msg)
[16:18:40.205]                       }
[16:18:40.205]                     })
[16:18:40.205]                   }
[16:18:40.205]                   ...future.strategy.old <- future::plan("list")
[16:18:40.205]                   options(future.plan = NULL)
[16:18:40.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.205]                 }
[16:18:40.205]                 ...future.workdir <- getwd()
[16:18:40.205]             }
[16:18:40.205]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.205]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.205]         }
[16:18:40.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.205]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:40.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.205]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.205]             base::names(...future.oldOptions))
[16:18:40.205]     }
[16:18:40.205]     if (FALSE) {
[16:18:40.205]     }
[16:18:40.205]     else {
[16:18:40.205]         if (TRUE) {
[16:18:40.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.205]                 open = "w")
[16:18:40.205]         }
[16:18:40.205]         else {
[16:18:40.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.205]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.205]         }
[16:18:40.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.205]             base::sink(type = "output", split = FALSE)
[16:18:40.205]             base::close(...future.stdout)
[16:18:40.205]         }, add = TRUE)
[16:18:40.205]     }
[16:18:40.205]     ...future.frame <- base::sys.nframe()
[16:18:40.205]     ...future.conditions <- base::list()
[16:18:40.205]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.205]     if (FALSE) {
[16:18:40.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.205]     }
[16:18:40.205]     ...future.result <- base::tryCatch({
[16:18:40.205]         base::withCallingHandlers({
[16:18:40.205]             ...future.value <- base::withVisible(base::local({
[16:18:40.205]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.205]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.205]                   ...future.globals.maxSize)) {
[16:18:40.205]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.205]                   on.exit(options(oopts), add = TRUE)
[16:18:40.205]                 }
[16:18:40.205]                 {
[16:18:40.205]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.205]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.205]                     USE.NAMES = FALSE)
[16:18:40.205]                   do.call(mapply, args = args)
[16:18:40.205]                 }
[16:18:40.205]             }))
[16:18:40.205]             future::FutureResult(value = ...future.value$value, 
[16:18:40.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.205]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.205]                     ...future.globalenv.names))
[16:18:40.205]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.205]         }, condition = base::local({
[16:18:40.205]             c <- base::c
[16:18:40.205]             inherits <- base::inherits
[16:18:40.205]             invokeRestart <- base::invokeRestart
[16:18:40.205]             length <- base::length
[16:18:40.205]             list <- base::list
[16:18:40.205]             seq.int <- base::seq.int
[16:18:40.205]             signalCondition <- base::signalCondition
[16:18:40.205]             sys.calls <- base::sys.calls
[16:18:40.205]             `[[` <- base::`[[`
[16:18:40.205]             `+` <- base::`+`
[16:18:40.205]             `<<-` <- base::`<<-`
[16:18:40.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.205]                   3L)]
[16:18:40.205]             }
[16:18:40.205]             function(cond) {
[16:18:40.205]                 is_error <- inherits(cond, "error")
[16:18:40.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.205]                   NULL)
[16:18:40.205]                 if (is_error) {
[16:18:40.205]                   sessionInformation <- function() {
[16:18:40.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.205]                       search = base::search(), system = base::Sys.info())
[16:18:40.205]                   }
[16:18:40.205]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.205]                     cond$call), session = sessionInformation(), 
[16:18:40.205]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.205]                   signalCondition(cond)
[16:18:40.205]                 }
[16:18:40.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.205]                 "immediateCondition"))) {
[16:18:40.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.205]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.205]                   if (TRUE && !signal) {
[16:18:40.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.205]                     {
[16:18:40.205]                       inherits <- base::inherits
[16:18:40.205]                       invokeRestart <- base::invokeRestart
[16:18:40.205]                       is.null <- base::is.null
[16:18:40.205]                       muffled <- FALSE
[16:18:40.205]                       if (inherits(cond, "message")) {
[16:18:40.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.205]                         if (muffled) 
[16:18:40.205]                           invokeRestart("muffleMessage")
[16:18:40.205]                       }
[16:18:40.205]                       else if (inherits(cond, "warning")) {
[16:18:40.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.205]                         if (muffled) 
[16:18:40.205]                           invokeRestart("muffleWarning")
[16:18:40.205]                       }
[16:18:40.205]                       else if (inherits(cond, "condition")) {
[16:18:40.205]                         if (!is.null(pattern)) {
[16:18:40.205]                           computeRestarts <- base::computeRestarts
[16:18:40.205]                           grepl <- base::grepl
[16:18:40.205]                           restarts <- computeRestarts(cond)
[16:18:40.205]                           for (restart in restarts) {
[16:18:40.205]                             name <- restart$name
[16:18:40.205]                             if (is.null(name)) 
[16:18:40.205]                               next
[16:18:40.205]                             if (!grepl(pattern, name)) 
[16:18:40.205]                               next
[16:18:40.205]                             invokeRestart(restart)
[16:18:40.205]                             muffled <- TRUE
[16:18:40.205]                             break
[16:18:40.205]                           }
[16:18:40.205]                         }
[16:18:40.205]                       }
[16:18:40.205]                       invisible(muffled)
[16:18:40.205]                     }
[16:18:40.205]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.205]                   }
[16:18:40.205]                 }
[16:18:40.205]                 else {
[16:18:40.205]                   if (TRUE) {
[16:18:40.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.205]                     {
[16:18:40.205]                       inherits <- base::inherits
[16:18:40.205]                       invokeRestart <- base::invokeRestart
[16:18:40.205]                       is.null <- base::is.null
[16:18:40.205]                       muffled <- FALSE
[16:18:40.205]                       if (inherits(cond, "message")) {
[16:18:40.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.205]                         if (muffled) 
[16:18:40.205]                           invokeRestart("muffleMessage")
[16:18:40.205]                       }
[16:18:40.205]                       else if (inherits(cond, "warning")) {
[16:18:40.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.205]                         if (muffled) 
[16:18:40.205]                           invokeRestart("muffleWarning")
[16:18:40.205]                       }
[16:18:40.205]                       else if (inherits(cond, "condition")) {
[16:18:40.205]                         if (!is.null(pattern)) {
[16:18:40.205]                           computeRestarts <- base::computeRestarts
[16:18:40.205]                           grepl <- base::grepl
[16:18:40.205]                           restarts <- computeRestarts(cond)
[16:18:40.205]                           for (restart in restarts) {
[16:18:40.205]                             name <- restart$name
[16:18:40.205]                             if (is.null(name)) 
[16:18:40.205]                               next
[16:18:40.205]                             if (!grepl(pattern, name)) 
[16:18:40.205]                               next
[16:18:40.205]                             invokeRestart(restart)
[16:18:40.205]                             muffled <- TRUE
[16:18:40.205]                             break
[16:18:40.205]                           }
[16:18:40.205]                         }
[16:18:40.205]                       }
[16:18:40.205]                       invisible(muffled)
[16:18:40.205]                     }
[16:18:40.205]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.205]                   }
[16:18:40.205]                 }
[16:18:40.205]             }
[16:18:40.205]         }))
[16:18:40.205]     }, error = function(ex) {
[16:18:40.205]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.205]                 ...future.rng), started = ...future.startTime, 
[16:18:40.205]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.205]             version = "1.8"), class = "FutureResult")
[16:18:40.205]     }, finally = {
[16:18:40.205]         if (!identical(...future.workdir, getwd())) 
[16:18:40.205]             setwd(...future.workdir)
[16:18:40.205]         {
[16:18:40.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.205]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.205]             }
[16:18:40.205]             base::options(...future.oldOptions)
[16:18:40.205]             if (.Platform$OS.type == "windows") {
[16:18:40.205]                 old_names <- names(...future.oldEnvVars)
[16:18:40.205]                 envs <- base::Sys.getenv()
[16:18:40.205]                 names <- names(envs)
[16:18:40.205]                 common <- intersect(names, old_names)
[16:18:40.205]                 added <- setdiff(names, old_names)
[16:18:40.205]                 removed <- setdiff(old_names, names)
[16:18:40.205]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.205]                   envs[common]]
[16:18:40.205]                 NAMES <- toupper(changed)
[16:18:40.205]                 args <- list()
[16:18:40.205]                 for (kk in seq_along(NAMES)) {
[16:18:40.205]                   name <- changed[[kk]]
[16:18:40.205]                   NAME <- NAMES[[kk]]
[16:18:40.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.205]                     next
[16:18:40.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.205]                 }
[16:18:40.205]                 NAMES <- toupper(added)
[16:18:40.205]                 for (kk in seq_along(NAMES)) {
[16:18:40.205]                   name <- added[[kk]]
[16:18:40.205]                   NAME <- NAMES[[kk]]
[16:18:40.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.205]                     next
[16:18:40.205]                   args[[name]] <- ""
[16:18:40.205]                 }
[16:18:40.205]                 NAMES <- toupper(removed)
[16:18:40.205]                 for (kk in seq_along(NAMES)) {
[16:18:40.205]                   name <- removed[[kk]]
[16:18:40.205]                   NAME <- NAMES[[kk]]
[16:18:40.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.205]                     next
[16:18:40.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.205]                 }
[16:18:40.205]                 if (length(args) > 0) 
[16:18:40.205]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.205]             }
[16:18:40.205]             else {
[16:18:40.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.205]             }
[16:18:40.205]             {
[16:18:40.205]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.205]                   0L) {
[16:18:40.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.205]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.205]                   base::options(opts)
[16:18:40.205]                 }
[16:18:40.205]                 {
[16:18:40.205]                   {
[16:18:40.205]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.205]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.205]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.205]                       inherits = FALSE)
[16:18:40.205]                     NULL
[16:18:40.205]                   }
[16:18:40.205]                   options(future.plan = NULL)
[16:18:40.205]                   if (is.na(NA_character_)) 
[16:18:40.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.205]                     .init = FALSE)
[16:18:40.205]                 }
[16:18:40.205]             }
[16:18:40.205]         }
[16:18:40.205]     })
[16:18:40.205]     if (TRUE) {
[16:18:40.205]         base::sink(type = "output", split = FALSE)
[16:18:40.205]         if (TRUE) {
[16:18:40.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.205]         }
[16:18:40.205]         else {
[16:18:40.205]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.205]         }
[16:18:40.205]         base::close(...future.stdout)
[16:18:40.205]         ...future.stdout <- NULL
[16:18:40.205]     }
[16:18:40.205]     ...future.result$conditions <- ...future.conditions
[16:18:40.205]     ...future.result$finished <- base::Sys.time()
[16:18:40.205]     ...future.result
[16:18:40.205] }
[16:18:40.207] assign_globals() ...
[16:18:40.207] List of 5
[16:18:40.207]  $ ...future.FUN            :function (C, k)  
[16:18:40.207]  $ MoreArgs                 : NULL
[16:18:40.207]  $ ...future.elements_ii    :List of 2
[16:18:40.207]   ..$ :List of 1
[16:18:40.207]   .. ..$ : chr "B"
[16:18:40.207]   ..$ :List of 1
[16:18:40.207]   .. ..$ : int 4
[16:18:40.207]  $ ...future.seeds_ii       : NULL
[16:18:40.207]  $ ...future.globals.maxSize: NULL
[16:18:40.207]  - attr(*, "where")=List of 5
[16:18:40.207]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.207]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.207]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.207]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.207]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.207]  - attr(*, "resolved")= logi FALSE
[16:18:40.207]  - attr(*, "total_size")= num 3488
[16:18:40.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.207]  - attr(*, "already-done")= logi TRUE
[16:18:40.212] - reassign environment for ‘...future.FUN’
[16:18:40.212] - copied ‘...future.FUN’ to environment
[16:18:40.212] - copied ‘MoreArgs’ to environment
[16:18:40.212] - copied ‘...future.elements_ii’ to environment
[16:18:40.212] - copied ‘...future.seeds_ii’ to environment
[16:18:40.212] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.212] assign_globals() ... done
[16:18:40.213] plan(): Setting new future strategy stack:
[16:18:40.213] List of future strategies:
[16:18:40.213] 1. sequential:
[16:18:40.213]    - args: function (..., envir = parent.frame())
[16:18:40.213]    - tweaked: FALSE
[16:18:40.213]    - call: NULL
[16:18:40.213] plan(): nbrOfWorkers() = 1
[16:18:40.214] plan(): Setting new future strategy stack:
[16:18:40.214] List of future strategies:
[16:18:40.214] 1. sequential:
[16:18:40.214]    - args: function (..., envir = parent.frame())
[16:18:40.214]    - tweaked: FALSE
[16:18:40.214]    - call: plan(strategy)
[16:18:40.214] plan(): nbrOfWorkers() = 1
[16:18:40.214] SequentialFuture started (and completed)
[16:18:40.215] - Launch lazy future ... done
[16:18:40.215] run() for ‘SequentialFuture’ ... done
[16:18:40.215] Created future:
[16:18:40.215] SequentialFuture:
[16:18:40.215] Label: ‘future_mapply-2’
[16:18:40.215] Expression:
[16:18:40.215] {
[16:18:40.215]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.215]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.215]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.215]         on.exit(options(oopts), add = TRUE)
[16:18:40.215]     }
[16:18:40.215]     {
[16:18:40.215]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.215]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.215]         do.call(mapply, args = args)
[16:18:40.215]     }
[16:18:40.215] }
[16:18:40.215] Lazy evaluation: FALSE
[16:18:40.215] Asynchronous evaluation: FALSE
[16:18:40.215] Local evaluation: TRUE
[16:18:40.215] Environment: R_GlobalEnv
[16:18:40.215] Capture standard output: TRUE
[16:18:40.215] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.215] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.215] Packages: <none>
[16:18:40.215] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.215] Resolved: TRUE
[16:18:40.215] Value: 112 bytes of class ‘list’
[16:18:40.215] Early signaling: FALSE
[16:18:40.215] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.215] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.216] Chunk #2 of 5 ... DONE
[16:18:40.216] Chunk #3 of 5 ...
[16:18:40.216]  - Finding globals in '...' for chunk #3 ...
[16:18:40.216] getGlobalsAndPackages() ...
[16:18:40.216] Searching for globals...
[16:18:40.216] 
[16:18:40.217] Searching for globals ... DONE
[16:18:40.217] - globals: [0] <none>
[16:18:40.217] getGlobalsAndPackages() ... DONE
[16:18:40.217]    + additional globals found: [n=0] 
[16:18:40.217]    + additional namespaces needed: [n=0] 
[16:18:40.217]  - Finding globals in '...' for chunk #3 ... DONE
[16:18:40.217]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:40.217]  - seeds: <none>
[16:18:40.217]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.217] getGlobalsAndPackages() ...
[16:18:40.217] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.218] Resolving globals: FALSE
[16:18:40.218] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:40.218] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.218] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.248] 
[16:18:40.248] getGlobalsAndPackages() ... DONE
[16:18:40.249] run() for ‘Future’ ...
[16:18:40.249] - state: ‘created’
[16:18:40.249] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.249] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.250] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.250]   - Field: ‘label’
[16:18:40.250]   - Field: ‘local’
[16:18:40.250]   - Field: ‘owner’
[16:18:40.250]   - Field: ‘envir’
[16:18:40.250]   - Field: ‘packages’
[16:18:40.250]   - Field: ‘gc’
[16:18:40.250]   - Field: ‘conditions’
[16:18:40.251]   - Field: ‘expr’
[16:18:40.251]   - Field: ‘uuid’
[16:18:40.251]   - Field: ‘seed’
[16:18:40.251]   - Field: ‘version’
[16:18:40.251]   - Field: ‘result’
[16:18:40.251]   - Field: ‘asynchronous’
[16:18:40.251]   - Field: ‘calls’
[16:18:40.251]   - Field: ‘globals’
[16:18:40.251]   - Field: ‘stdout’
[16:18:40.251]   - Field: ‘earlySignal’
[16:18:40.252]   - Field: ‘lazy’
[16:18:40.252]   - Field: ‘state’
[16:18:40.252] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.252] - Launch lazy future ...
[16:18:40.252] Packages needed by the future expression (n = 0): <none>
[16:18:40.252] Packages needed by future strategies (n = 0): <none>
[16:18:40.253] {
[16:18:40.253]     {
[16:18:40.253]         {
[16:18:40.253]             ...future.startTime <- base::Sys.time()
[16:18:40.253]             {
[16:18:40.253]                 {
[16:18:40.253]                   {
[16:18:40.253]                     base::local({
[16:18:40.253]                       has_future <- base::requireNamespace("future", 
[16:18:40.253]                         quietly = TRUE)
[16:18:40.253]                       if (has_future) {
[16:18:40.253]                         ns <- base::getNamespace("future")
[16:18:40.253]                         version <- ns[[".package"]][["version"]]
[16:18:40.253]                         if (is.null(version)) 
[16:18:40.253]                           version <- utils::packageVersion("future")
[16:18:40.253]                       }
[16:18:40.253]                       else {
[16:18:40.253]                         version <- NULL
[16:18:40.253]                       }
[16:18:40.253]                       if (!has_future || version < "1.8.0") {
[16:18:40.253]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.253]                           "", base::R.version$version.string), 
[16:18:40.253]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.253]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.253]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.253]                             "release", "version")], collapse = " "), 
[16:18:40.253]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.253]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.253]                           info)
[16:18:40.253]                         info <- base::paste(info, collapse = "; ")
[16:18:40.253]                         if (!has_future) {
[16:18:40.253]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.253]                             info)
[16:18:40.253]                         }
[16:18:40.253]                         else {
[16:18:40.253]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.253]                             info, version)
[16:18:40.253]                         }
[16:18:40.253]                         base::stop(msg)
[16:18:40.253]                       }
[16:18:40.253]                     })
[16:18:40.253]                   }
[16:18:40.253]                   ...future.strategy.old <- future::plan("list")
[16:18:40.253]                   options(future.plan = NULL)
[16:18:40.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.253]                 }
[16:18:40.253]                 ...future.workdir <- getwd()
[16:18:40.253]             }
[16:18:40.253]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.253]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.253]         }
[16:18:40.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.253]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:40.253]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.253]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.253]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.253]             base::names(...future.oldOptions))
[16:18:40.253]     }
[16:18:40.253]     if (FALSE) {
[16:18:40.253]     }
[16:18:40.253]     else {
[16:18:40.253]         if (TRUE) {
[16:18:40.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.253]                 open = "w")
[16:18:40.253]         }
[16:18:40.253]         else {
[16:18:40.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.253]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.253]         }
[16:18:40.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.253]             base::sink(type = "output", split = FALSE)
[16:18:40.253]             base::close(...future.stdout)
[16:18:40.253]         }, add = TRUE)
[16:18:40.253]     }
[16:18:40.253]     ...future.frame <- base::sys.nframe()
[16:18:40.253]     ...future.conditions <- base::list()
[16:18:40.253]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.253]     if (FALSE) {
[16:18:40.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.253]     }
[16:18:40.253]     ...future.result <- base::tryCatch({
[16:18:40.253]         base::withCallingHandlers({
[16:18:40.253]             ...future.value <- base::withVisible(base::local({
[16:18:40.253]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.253]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.253]                   ...future.globals.maxSize)) {
[16:18:40.253]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.253]                   on.exit(options(oopts), add = TRUE)
[16:18:40.253]                 }
[16:18:40.253]                 {
[16:18:40.253]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.253]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.253]                     USE.NAMES = FALSE)
[16:18:40.253]                   do.call(mapply, args = args)
[16:18:40.253]                 }
[16:18:40.253]             }))
[16:18:40.253]             future::FutureResult(value = ...future.value$value, 
[16:18:40.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.253]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.253]                     ...future.globalenv.names))
[16:18:40.253]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.253]         }, condition = base::local({
[16:18:40.253]             c <- base::c
[16:18:40.253]             inherits <- base::inherits
[16:18:40.253]             invokeRestart <- base::invokeRestart
[16:18:40.253]             length <- base::length
[16:18:40.253]             list <- base::list
[16:18:40.253]             seq.int <- base::seq.int
[16:18:40.253]             signalCondition <- base::signalCondition
[16:18:40.253]             sys.calls <- base::sys.calls
[16:18:40.253]             `[[` <- base::`[[`
[16:18:40.253]             `+` <- base::`+`
[16:18:40.253]             `<<-` <- base::`<<-`
[16:18:40.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.253]                   3L)]
[16:18:40.253]             }
[16:18:40.253]             function(cond) {
[16:18:40.253]                 is_error <- inherits(cond, "error")
[16:18:40.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.253]                   NULL)
[16:18:40.253]                 if (is_error) {
[16:18:40.253]                   sessionInformation <- function() {
[16:18:40.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.253]                       search = base::search(), system = base::Sys.info())
[16:18:40.253]                   }
[16:18:40.253]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.253]                     cond$call), session = sessionInformation(), 
[16:18:40.253]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.253]                   signalCondition(cond)
[16:18:40.253]                 }
[16:18:40.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.253]                 "immediateCondition"))) {
[16:18:40.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.253]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.253]                   if (TRUE && !signal) {
[16:18:40.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.253]                     {
[16:18:40.253]                       inherits <- base::inherits
[16:18:40.253]                       invokeRestart <- base::invokeRestart
[16:18:40.253]                       is.null <- base::is.null
[16:18:40.253]                       muffled <- FALSE
[16:18:40.253]                       if (inherits(cond, "message")) {
[16:18:40.253]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.253]                         if (muffled) 
[16:18:40.253]                           invokeRestart("muffleMessage")
[16:18:40.253]                       }
[16:18:40.253]                       else if (inherits(cond, "warning")) {
[16:18:40.253]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.253]                         if (muffled) 
[16:18:40.253]                           invokeRestart("muffleWarning")
[16:18:40.253]                       }
[16:18:40.253]                       else if (inherits(cond, "condition")) {
[16:18:40.253]                         if (!is.null(pattern)) {
[16:18:40.253]                           computeRestarts <- base::computeRestarts
[16:18:40.253]                           grepl <- base::grepl
[16:18:40.253]                           restarts <- computeRestarts(cond)
[16:18:40.253]                           for (restart in restarts) {
[16:18:40.253]                             name <- restart$name
[16:18:40.253]                             if (is.null(name)) 
[16:18:40.253]                               next
[16:18:40.253]                             if (!grepl(pattern, name)) 
[16:18:40.253]                               next
[16:18:40.253]                             invokeRestart(restart)
[16:18:40.253]                             muffled <- TRUE
[16:18:40.253]                             break
[16:18:40.253]                           }
[16:18:40.253]                         }
[16:18:40.253]                       }
[16:18:40.253]                       invisible(muffled)
[16:18:40.253]                     }
[16:18:40.253]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.253]                   }
[16:18:40.253]                 }
[16:18:40.253]                 else {
[16:18:40.253]                   if (TRUE) {
[16:18:40.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.253]                     {
[16:18:40.253]                       inherits <- base::inherits
[16:18:40.253]                       invokeRestart <- base::invokeRestart
[16:18:40.253]                       is.null <- base::is.null
[16:18:40.253]                       muffled <- FALSE
[16:18:40.253]                       if (inherits(cond, "message")) {
[16:18:40.253]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.253]                         if (muffled) 
[16:18:40.253]                           invokeRestart("muffleMessage")
[16:18:40.253]                       }
[16:18:40.253]                       else if (inherits(cond, "warning")) {
[16:18:40.253]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.253]                         if (muffled) 
[16:18:40.253]                           invokeRestart("muffleWarning")
[16:18:40.253]                       }
[16:18:40.253]                       else if (inherits(cond, "condition")) {
[16:18:40.253]                         if (!is.null(pattern)) {
[16:18:40.253]                           computeRestarts <- base::computeRestarts
[16:18:40.253]                           grepl <- base::grepl
[16:18:40.253]                           restarts <- computeRestarts(cond)
[16:18:40.253]                           for (restart in restarts) {
[16:18:40.253]                             name <- restart$name
[16:18:40.253]                             if (is.null(name)) 
[16:18:40.253]                               next
[16:18:40.253]                             if (!grepl(pattern, name)) 
[16:18:40.253]                               next
[16:18:40.253]                             invokeRestart(restart)
[16:18:40.253]                             muffled <- TRUE
[16:18:40.253]                             break
[16:18:40.253]                           }
[16:18:40.253]                         }
[16:18:40.253]                       }
[16:18:40.253]                       invisible(muffled)
[16:18:40.253]                     }
[16:18:40.253]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.253]                   }
[16:18:40.253]                 }
[16:18:40.253]             }
[16:18:40.253]         }))
[16:18:40.253]     }, error = function(ex) {
[16:18:40.253]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.253]                 ...future.rng), started = ...future.startTime, 
[16:18:40.253]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.253]             version = "1.8"), class = "FutureResult")
[16:18:40.253]     }, finally = {
[16:18:40.253]         if (!identical(...future.workdir, getwd())) 
[16:18:40.253]             setwd(...future.workdir)
[16:18:40.253]         {
[16:18:40.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.253]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.253]             }
[16:18:40.253]             base::options(...future.oldOptions)
[16:18:40.253]             if (.Platform$OS.type == "windows") {
[16:18:40.253]                 old_names <- names(...future.oldEnvVars)
[16:18:40.253]                 envs <- base::Sys.getenv()
[16:18:40.253]                 names <- names(envs)
[16:18:40.253]                 common <- intersect(names, old_names)
[16:18:40.253]                 added <- setdiff(names, old_names)
[16:18:40.253]                 removed <- setdiff(old_names, names)
[16:18:40.253]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.253]                   envs[common]]
[16:18:40.253]                 NAMES <- toupper(changed)
[16:18:40.253]                 args <- list()
[16:18:40.253]                 for (kk in seq_along(NAMES)) {
[16:18:40.253]                   name <- changed[[kk]]
[16:18:40.253]                   NAME <- NAMES[[kk]]
[16:18:40.253]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.253]                     next
[16:18:40.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.253]                 }
[16:18:40.253]                 NAMES <- toupper(added)
[16:18:40.253]                 for (kk in seq_along(NAMES)) {
[16:18:40.253]                   name <- added[[kk]]
[16:18:40.253]                   NAME <- NAMES[[kk]]
[16:18:40.253]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.253]                     next
[16:18:40.253]                   args[[name]] <- ""
[16:18:40.253]                 }
[16:18:40.253]                 NAMES <- toupper(removed)
[16:18:40.253]                 for (kk in seq_along(NAMES)) {
[16:18:40.253]                   name <- removed[[kk]]
[16:18:40.253]                   NAME <- NAMES[[kk]]
[16:18:40.253]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.253]                     next
[16:18:40.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.253]                 }
[16:18:40.253]                 if (length(args) > 0) 
[16:18:40.253]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.253]             }
[16:18:40.253]             else {
[16:18:40.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.253]             }
[16:18:40.253]             {
[16:18:40.253]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.253]                   0L) {
[16:18:40.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.253]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.253]                   base::options(opts)
[16:18:40.253]                 }
[16:18:40.253]                 {
[16:18:40.253]                   {
[16:18:40.253]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.253]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.253]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.253]                       inherits = FALSE)
[16:18:40.253]                     NULL
[16:18:40.253]                   }
[16:18:40.253]                   options(future.plan = NULL)
[16:18:40.253]                   if (is.na(NA_character_)) 
[16:18:40.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.253]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.253]                     .init = FALSE)
[16:18:40.253]                 }
[16:18:40.253]             }
[16:18:40.253]         }
[16:18:40.253]     })
[16:18:40.253]     if (TRUE) {
[16:18:40.253]         base::sink(type = "output", split = FALSE)
[16:18:40.253]         if (TRUE) {
[16:18:40.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.253]         }
[16:18:40.253]         else {
[16:18:40.253]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.253]         }
[16:18:40.253]         base::close(...future.stdout)
[16:18:40.253]         ...future.stdout <- NULL
[16:18:40.253]     }
[16:18:40.253]     ...future.result$conditions <- ...future.conditions
[16:18:40.253]     ...future.result$finished <- base::Sys.time()
[16:18:40.253]     ...future.result
[16:18:40.253] }
[16:18:40.254] assign_globals() ...
[16:18:40.254] List of 5
[16:18:40.254]  $ ...future.FUN            :function (C, k)  
[16:18:40.254]  $ MoreArgs                 : NULL
[16:18:40.254]  $ ...future.elements_ii    :List of 2
[16:18:40.254]   ..$ :List of 1
[16:18:40.254]   .. ..$ : chr "C"
[16:18:40.254]   ..$ :List of 1
[16:18:40.254]   .. ..$ : int 3
[16:18:40.254]  $ ...future.seeds_ii       : NULL
[16:18:40.254]  $ ...future.globals.maxSize: NULL
[16:18:40.254]  - attr(*, "where")=List of 5
[16:18:40.254]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.254]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.254]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.254]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.254]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.254]  - attr(*, "resolved")= logi FALSE
[16:18:40.254]  - attr(*, "total_size")= num 3488
[16:18:40.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.254]  - attr(*, "already-done")= logi TRUE
[16:18:40.260] - reassign environment for ‘...future.FUN’
[16:18:40.260] - copied ‘...future.FUN’ to environment
[16:18:40.260] - copied ‘MoreArgs’ to environment
[16:18:40.260] - copied ‘...future.elements_ii’ to environment
[16:18:40.260] - copied ‘...future.seeds_ii’ to environment
[16:18:40.260] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.260] assign_globals() ... done
[16:18:40.260] plan(): Setting new future strategy stack:
[16:18:40.261] List of future strategies:
[16:18:40.261] 1. sequential:
[16:18:40.261]    - args: function (..., envir = parent.frame())
[16:18:40.261]    - tweaked: FALSE
[16:18:40.261]    - call: NULL
[16:18:40.261] plan(): nbrOfWorkers() = 1
[16:18:40.262] plan(): Setting new future strategy stack:
[16:18:40.262] List of future strategies:
[16:18:40.262] 1. sequential:
[16:18:40.262]    - args: function (..., envir = parent.frame())
[16:18:40.262]    - tweaked: FALSE
[16:18:40.262]    - call: plan(strategy)
[16:18:40.262] plan(): nbrOfWorkers() = 1
[16:18:40.262] SequentialFuture started (and completed)
[16:18:40.262] - Launch lazy future ... done
[16:18:40.263] run() for ‘SequentialFuture’ ... done
[16:18:40.263] Created future:
[16:18:40.263] SequentialFuture:
[16:18:40.263] Label: ‘future_mapply-3’
[16:18:40.263] Expression:
[16:18:40.263] {
[16:18:40.263]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.263]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.263]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.263]         on.exit(options(oopts), add = TRUE)
[16:18:40.263]     }
[16:18:40.263]     {
[16:18:40.263]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.263]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.263]         do.call(mapply, args = args)
[16:18:40.263]     }
[16:18:40.263] }
[16:18:40.263] Lazy evaluation: FALSE
[16:18:40.263] Asynchronous evaluation: FALSE
[16:18:40.263] Local evaluation: TRUE
[16:18:40.263] Environment: R_GlobalEnv
[16:18:40.263] Capture standard output: TRUE
[16:18:40.263] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.263] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.263] Packages: <none>
[16:18:40.263] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.263] Resolved: TRUE
[16:18:40.263] Value: 112 bytes of class ‘list’
[16:18:40.263] Early signaling: FALSE
[16:18:40.263] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.263] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.264] Chunk #3 of 5 ... DONE
[16:18:40.264] Chunk #4 of 5 ...
[16:18:40.264]  - Finding globals in '...' for chunk #4 ...
[16:18:40.264] getGlobalsAndPackages() ...
[16:18:40.264] Searching for globals...
[16:18:40.264] 
[16:18:40.265] Searching for globals ... DONE
[16:18:40.265] - globals: [0] <none>
[16:18:40.265] getGlobalsAndPackages() ... DONE
[16:18:40.265]    + additional globals found: [n=0] 
[16:18:40.265]    + additional namespaces needed: [n=0] 
[16:18:40.265]  - Finding globals in '...' for chunk #4 ... DONE
[16:18:40.265]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:40.265]  - seeds: <none>
[16:18:40.265]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.265] getGlobalsAndPackages() ...
[16:18:40.265] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.266] Resolving globals: FALSE
[16:18:40.266] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:40.267] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.267] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.267] 
[16:18:40.267] getGlobalsAndPackages() ... DONE
[16:18:40.267] run() for ‘Future’ ...
[16:18:40.267] - state: ‘created’
[16:18:40.267] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.268] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.268] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.268]   - Field: ‘label’
[16:18:40.268]   - Field: ‘local’
[16:18:40.268]   - Field: ‘owner’
[16:18:40.268]   - Field: ‘envir’
[16:18:40.268]   - Field: ‘packages’
[16:18:40.268]   - Field: ‘gc’
[16:18:40.268]   - Field: ‘conditions’
[16:18:40.269]   - Field: ‘expr’
[16:18:40.269]   - Field: ‘uuid’
[16:18:40.269]   - Field: ‘seed’
[16:18:40.269]   - Field: ‘version’
[16:18:40.269]   - Field: ‘result’
[16:18:40.269]   - Field: ‘asynchronous’
[16:18:40.269]   - Field: ‘calls’
[16:18:40.269]   - Field: ‘globals’
[16:18:40.269]   - Field: ‘stdout’
[16:18:40.269]   - Field: ‘earlySignal’
[16:18:40.269]   - Field: ‘lazy’
[16:18:40.270]   - Field: ‘state’
[16:18:40.270] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.270] - Launch lazy future ...
[16:18:40.270] Packages needed by the future expression (n = 0): <none>
[16:18:40.270] Packages needed by future strategies (n = 0): <none>
[16:18:40.270] {
[16:18:40.270]     {
[16:18:40.270]         {
[16:18:40.270]             ...future.startTime <- base::Sys.time()
[16:18:40.270]             {
[16:18:40.270]                 {
[16:18:40.270]                   {
[16:18:40.270]                     base::local({
[16:18:40.270]                       has_future <- base::requireNamespace("future", 
[16:18:40.270]                         quietly = TRUE)
[16:18:40.270]                       if (has_future) {
[16:18:40.270]                         ns <- base::getNamespace("future")
[16:18:40.270]                         version <- ns[[".package"]][["version"]]
[16:18:40.270]                         if (is.null(version)) 
[16:18:40.270]                           version <- utils::packageVersion("future")
[16:18:40.270]                       }
[16:18:40.270]                       else {
[16:18:40.270]                         version <- NULL
[16:18:40.270]                       }
[16:18:40.270]                       if (!has_future || version < "1.8.0") {
[16:18:40.270]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.270]                           "", base::R.version$version.string), 
[16:18:40.270]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.270]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.270]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.270]                             "release", "version")], collapse = " "), 
[16:18:40.270]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.270]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.270]                           info)
[16:18:40.270]                         info <- base::paste(info, collapse = "; ")
[16:18:40.270]                         if (!has_future) {
[16:18:40.270]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.270]                             info)
[16:18:40.270]                         }
[16:18:40.270]                         else {
[16:18:40.270]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.270]                             info, version)
[16:18:40.270]                         }
[16:18:40.270]                         base::stop(msg)
[16:18:40.270]                       }
[16:18:40.270]                     })
[16:18:40.270]                   }
[16:18:40.270]                   ...future.strategy.old <- future::plan("list")
[16:18:40.270]                   options(future.plan = NULL)
[16:18:40.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.270]                 }
[16:18:40.270]                 ...future.workdir <- getwd()
[16:18:40.270]             }
[16:18:40.270]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.270]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.270]         }
[16:18:40.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.270]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:40.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.270]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.270]             base::names(...future.oldOptions))
[16:18:40.270]     }
[16:18:40.270]     if (FALSE) {
[16:18:40.270]     }
[16:18:40.270]     else {
[16:18:40.270]         if (TRUE) {
[16:18:40.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.270]                 open = "w")
[16:18:40.270]         }
[16:18:40.270]         else {
[16:18:40.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.270]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.270]         }
[16:18:40.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.270]             base::sink(type = "output", split = FALSE)
[16:18:40.270]             base::close(...future.stdout)
[16:18:40.270]         }, add = TRUE)
[16:18:40.270]     }
[16:18:40.270]     ...future.frame <- base::sys.nframe()
[16:18:40.270]     ...future.conditions <- base::list()
[16:18:40.270]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.270]     if (FALSE) {
[16:18:40.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.270]     }
[16:18:40.270]     ...future.result <- base::tryCatch({
[16:18:40.270]         base::withCallingHandlers({
[16:18:40.270]             ...future.value <- base::withVisible(base::local({
[16:18:40.270]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.270]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.270]                   ...future.globals.maxSize)) {
[16:18:40.270]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.270]                   on.exit(options(oopts), add = TRUE)
[16:18:40.270]                 }
[16:18:40.270]                 {
[16:18:40.270]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.270]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.270]                     USE.NAMES = FALSE)
[16:18:40.270]                   do.call(mapply, args = args)
[16:18:40.270]                 }
[16:18:40.270]             }))
[16:18:40.270]             future::FutureResult(value = ...future.value$value, 
[16:18:40.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.270]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.270]                     ...future.globalenv.names))
[16:18:40.270]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.270]         }, condition = base::local({
[16:18:40.270]             c <- base::c
[16:18:40.270]             inherits <- base::inherits
[16:18:40.270]             invokeRestart <- base::invokeRestart
[16:18:40.270]             length <- base::length
[16:18:40.270]             list <- base::list
[16:18:40.270]             seq.int <- base::seq.int
[16:18:40.270]             signalCondition <- base::signalCondition
[16:18:40.270]             sys.calls <- base::sys.calls
[16:18:40.270]             `[[` <- base::`[[`
[16:18:40.270]             `+` <- base::`+`
[16:18:40.270]             `<<-` <- base::`<<-`
[16:18:40.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.270]                   3L)]
[16:18:40.270]             }
[16:18:40.270]             function(cond) {
[16:18:40.270]                 is_error <- inherits(cond, "error")
[16:18:40.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.270]                   NULL)
[16:18:40.270]                 if (is_error) {
[16:18:40.270]                   sessionInformation <- function() {
[16:18:40.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.270]                       search = base::search(), system = base::Sys.info())
[16:18:40.270]                   }
[16:18:40.270]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.270]                     cond$call), session = sessionInformation(), 
[16:18:40.270]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.270]                   signalCondition(cond)
[16:18:40.270]                 }
[16:18:40.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.270]                 "immediateCondition"))) {
[16:18:40.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.270]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.270]                   if (TRUE && !signal) {
[16:18:40.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.270]                     {
[16:18:40.270]                       inherits <- base::inherits
[16:18:40.270]                       invokeRestart <- base::invokeRestart
[16:18:40.270]                       is.null <- base::is.null
[16:18:40.270]                       muffled <- FALSE
[16:18:40.270]                       if (inherits(cond, "message")) {
[16:18:40.270]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.270]                         if (muffled) 
[16:18:40.270]                           invokeRestart("muffleMessage")
[16:18:40.270]                       }
[16:18:40.270]                       else if (inherits(cond, "warning")) {
[16:18:40.270]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.270]                         if (muffled) 
[16:18:40.270]                           invokeRestart("muffleWarning")
[16:18:40.270]                       }
[16:18:40.270]                       else if (inherits(cond, "condition")) {
[16:18:40.270]                         if (!is.null(pattern)) {
[16:18:40.270]                           computeRestarts <- base::computeRestarts
[16:18:40.270]                           grepl <- base::grepl
[16:18:40.270]                           restarts <- computeRestarts(cond)
[16:18:40.270]                           for (restart in restarts) {
[16:18:40.270]                             name <- restart$name
[16:18:40.270]                             if (is.null(name)) 
[16:18:40.270]                               next
[16:18:40.270]                             if (!grepl(pattern, name)) 
[16:18:40.270]                               next
[16:18:40.270]                             invokeRestart(restart)
[16:18:40.270]                             muffled <- TRUE
[16:18:40.270]                             break
[16:18:40.270]                           }
[16:18:40.270]                         }
[16:18:40.270]                       }
[16:18:40.270]                       invisible(muffled)
[16:18:40.270]                     }
[16:18:40.270]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.270]                   }
[16:18:40.270]                 }
[16:18:40.270]                 else {
[16:18:40.270]                   if (TRUE) {
[16:18:40.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.270]                     {
[16:18:40.270]                       inherits <- base::inherits
[16:18:40.270]                       invokeRestart <- base::invokeRestart
[16:18:40.270]                       is.null <- base::is.null
[16:18:40.270]                       muffled <- FALSE
[16:18:40.270]                       if (inherits(cond, "message")) {
[16:18:40.270]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.270]                         if (muffled) 
[16:18:40.270]                           invokeRestart("muffleMessage")
[16:18:40.270]                       }
[16:18:40.270]                       else if (inherits(cond, "warning")) {
[16:18:40.270]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.270]                         if (muffled) 
[16:18:40.270]                           invokeRestart("muffleWarning")
[16:18:40.270]                       }
[16:18:40.270]                       else if (inherits(cond, "condition")) {
[16:18:40.270]                         if (!is.null(pattern)) {
[16:18:40.270]                           computeRestarts <- base::computeRestarts
[16:18:40.270]                           grepl <- base::grepl
[16:18:40.270]                           restarts <- computeRestarts(cond)
[16:18:40.270]                           for (restart in restarts) {
[16:18:40.270]                             name <- restart$name
[16:18:40.270]                             if (is.null(name)) 
[16:18:40.270]                               next
[16:18:40.270]                             if (!grepl(pattern, name)) 
[16:18:40.270]                               next
[16:18:40.270]                             invokeRestart(restart)
[16:18:40.270]                             muffled <- TRUE
[16:18:40.270]                             break
[16:18:40.270]                           }
[16:18:40.270]                         }
[16:18:40.270]                       }
[16:18:40.270]                       invisible(muffled)
[16:18:40.270]                     }
[16:18:40.270]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.270]                   }
[16:18:40.270]                 }
[16:18:40.270]             }
[16:18:40.270]         }))
[16:18:40.270]     }, error = function(ex) {
[16:18:40.270]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.270]                 ...future.rng), started = ...future.startTime, 
[16:18:40.270]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.270]             version = "1.8"), class = "FutureResult")
[16:18:40.270]     }, finally = {
[16:18:40.270]         if (!identical(...future.workdir, getwd())) 
[16:18:40.270]             setwd(...future.workdir)
[16:18:40.270]         {
[16:18:40.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.270]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.270]             }
[16:18:40.270]             base::options(...future.oldOptions)
[16:18:40.270]             if (.Platform$OS.type == "windows") {
[16:18:40.270]                 old_names <- names(...future.oldEnvVars)
[16:18:40.270]                 envs <- base::Sys.getenv()
[16:18:40.270]                 names <- names(envs)
[16:18:40.270]                 common <- intersect(names, old_names)
[16:18:40.270]                 added <- setdiff(names, old_names)
[16:18:40.270]                 removed <- setdiff(old_names, names)
[16:18:40.270]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.270]                   envs[common]]
[16:18:40.270]                 NAMES <- toupper(changed)
[16:18:40.270]                 args <- list()
[16:18:40.270]                 for (kk in seq_along(NAMES)) {
[16:18:40.270]                   name <- changed[[kk]]
[16:18:40.270]                   NAME <- NAMES[[kk]]
[16:18:40.270]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.270]                     next
[16:18:40.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.270]                 }
[16:18:40.270]                 NAMES <- toupper(added)
[16:18:40.270]                 for (kk in seq_along(NAMES)) {
[16:18:40.270]                   name <- added[[kk]]
[16:18:40.270]                   NAME <- NAMES[[kk]]
[16:18:40.270]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.270]                     next
[16:18:40.270]                   args[[name]] <- ""
[16:18:40.270]                 }
[16:18:40.270]                 NAMES <- toupper(removed)
[16:18:40.270]                 for (kk in seq_along(NAMES)) {
[16:18:40.270]                   name <- removed[[kk]]
[16:18:40.270]                   NAME <- NAMES[[kk]]
[16:18:40.270]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.270]                     next
[16:18:40.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.270]                 }
[16:18:40.270]                 if (length(args) > 0) 
[16:18:40.270]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.270]             }
[16:18:40.270]             else {
[16:18:40.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.270]             }
[16:18:40.270]             {
[16:18:40.270]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.270]                   0L) {
[16:18:40.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.270]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.270]                   base::options(opts)
[16:18:40.270]                 }
[16:18:40.270]                 {
[16:18:40.270]                   {
[16:18:40.270]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.270]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.270]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.270]                       inherits = FALSE)
[16:18:40.270]                     NULL
[16:18:40.270]                   }
[16:18:40.270]                   options(future.plan = NULL)
[16:18:40.270]                   if (is.na(NA_character_)) 
[16:18:40.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.270]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.270]                     .init = FALSE)
[16:18:40.270]                 }
[16:18:40.270]             }
[16:18:40.270]         }
[16:18:40.270]     })
[16:18:40.270]     if (TRUE) {
[16:18:40.270]         base::sink(type = "output", split = FALSE)
[16:18:40.270]         if (TRUE) {
[16:18:40.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.270]         }
[16:18:40.270]         else {
[16:18:40.270]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.270]         }
[16:18:40.270]         base::close(...future.stdout)
[16:18:40.270]         ...future.stdout <- NULL
[16:18:40.270]     }
[16:18:40.270]     ...future.result$conditions <- ...future.conditions
[16:18:40.270]     ...future.result$finished <- base::Sys.time()
[16:18:40.270]     ...future.result
[16:18:40.270] }
[16:18:40.272] assign_globals() ...
[16:18:40.272] List of 5
[16:18:40.272]  $ ...future.FUN            :function (C, k)  
[16:18:40.272]  $ MoreArgs                 : NULL
[16:18:40.272]  $ ...future.elements_ii    :List of 2
[16:18:40.272]   ..$ :List of 1
[16:18:40.272]   .. ..$ : chr "D"
[16:18:40.272]   ..$ :List of 1
[16:18:40.272]   .. ..$ : int 2
[16:18:40.272]  $ ...future.seeds_ii       : NULL
[16:18:40.272]  $ ...future.globals.maxSize: NULL
[16:18:40.272]  - attr(*, "where")=List of 5
[16:18:40.272]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.272]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.272]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.272]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.272]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.272]  - attr(*, "resolved")= logi FALSE
[16:18:40.272]  - attr(*, "total_size")= num 3488
[16:18:40.272]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.272]  - attr(*, "already-done")= logi TRUE
[16:18:40.279] - reassign environment for ‘...future.FUN’
[16:18:40.279] - copied ‘...future.FUN’ to environment
[16:18:40.279] - copied ‘MoreArgs’ to environment
[16:18:40.280] - copied ‘...future.elements_ii’ to environment
[16:18:40.280] - copied ‘...future.seeds_ii’ to environment
[16:18:40.280] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.280] assign_globals() ... done
[16:18:40.280] plan(): Setting new future strategy stack:
[16:18:40.280] List of future strategies:
[16:18:40.280] 1. sequential:
[16:18:40.280]    - args: function (..., envir = parent.frame())
[16:18:40.280]    - tweaked: FALSE
[16:18:40.280]    - call: NULL
[16:18:40.281] plan(): nbrOfWorkers() = 1
[16:18:40.281] plan(): Setting new future strategy stack:
[16:18:40.281] List of future strategies:
[16:18:40.281] 1. sequential:
[16:18:40.281]    - args: function (..., envir = parent.frame())
[16:18:40.281]    - tweaked: FALSE
[16:18:40.281]    - call: plan(strategy)
[16:18:40.282] plan(): nbrOfWorkers() = 1
[16:18:40.282] SequentialFuture started (and completed)
[16:18:40.282] - Launch lazy future ... done
[16:18:40.282] run() for ‘SequentialFuture’ ... done
[16:18:40.282] Created future:
[16:18:40.282] SequentialFuture:
[16:18:40.282] Label: ‘future_mapply-4’
[16:18:40.282] Expression:
[16:18:40.282] {
[16:18:40.282]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.282]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.282]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.282]         on.exit(options(oopts), add = TRUE)
[16:18:40.282]     }
[16:18:40.282]     {
[16:18:40.282]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.282]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.282]         do.call(mapply, args = args)
[16:18:40.282]     }
[16:18:40.282] }
[16:18:40.282] Lazy evaluation: FALSE
[16:18:40.282] Asynchronous evaluation: FALSE
[16:18:40.282] Local evaluation: TRUE
[16:18:40.282] Environment: R_GlobalEnv
[16:18:40.282] Capture standard output: TRUE
[16:18:40.282] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.282] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.282] Packages: <none>
[16:18:40.282] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.282] Resolved: TRUE
[16:18:40.282] Value: 112 bytes of class ‘list’
[16:18:40.282] Early signaling: FALSE
[16:18:40.282] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.282] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.283] Chunk #4 of 5 ... DONE
[16:18:40.283] Chunk #5 of 5 ...
[16:18:40.283]  - Finding globals in '...' for chunk #5 ...
[16:18:40.284] getGlobalsAndPackages() ...
[16:18:40.284] Searching for globals...
[16:18:40.284] 
[16:18:40.284] Searching for globals ... DONE
[16:18:40.284] - globals: [0] <none>
[16:18:40.284] getGlobalsAndPackages() ... DONE
[16:18:40.284]    + additional globals found: [n=0] 
[16:18:40.284]    + additional namespaces needed: [n=0] 
[16:18:40.285]  - Finding globals in '...' for chunk #5 ... DONE
[16:18:40.285]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:40.285]  - seeds: <none>
[16:18:40.285]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.285] getGlobalsAndPackages() ...
[16:18:40.285] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.285] Resolving globals: FALSE
[16:18:40.286] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:40.286] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.286] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.286] 
[16:18:40.286] getGlobalsAndPackages() ... DONE
[16:18:40.287] run() for ‘Future’ ...
[16:18:40.287] - state: ‘created’
[16:18:40.287] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.287] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.287] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.287]   - Field: ‘label’
[16:18:40.287]   - Field: ‘local’
[16:18:40.288]   - Field: ‘owner’
[16:18:40.288]   - Field: ‘envir’
[16:18:40.288]   - Field: ‘packages’
[16:18:40.288]   - Field: ‘gc’
[16:18:40.288]   - Field: ‘conditions’
[16:18:40.288]   - Field: ‘expr’
[16:18:40.288]   - Field: ‘uuid’
[16:18:40.288]   - Field: ‘seed’
[16:18:40.288]   - Field: ‘version’
[16:18:40.288]   - Field: ‘result’
[16:18:40.289]   - Field: ‘asynchronous’
[16:18:40.289]   - Field: ‘calls’
[16:18:40.289]   - Field: ‘globals’
[16:18:40.289]   - Field: ‘stdout’
[16:18:40.289]   - Field: ‘earlySignal’
[16:18:40.289]   - Field: ‘lazy’
[16:18:40.289]   - Field: ‘state’
[16:18:40.289] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.289] - Launch lazy future ...
[16:18:40.289] Packages needed by the future expression (n = 0): <none>
[16:18:40.290] Packages needed by future strategies (n = 0): <none>
[16:18:40.290] {
[16:18:40.290]     {
[16:18:40.290]         {
[16:18:40.290]             ...future.startTime <- base::Sys.time()
[16:18:40.290]             {
[16:18:40.290]                 {
[16:18:40.290]                   {
[16:18:40.290]                     base::local({
[16:18:40.290]                       has_future <- base::requireNamespace("future", 
[16:18:40.290]                         quietly = TRUE)
[16:18:40.290]                       if (has_future) {
[16:18:40.290]                         ns <- base::getNamespace("future")
[16:18:40.290]                         version <- ns[[".package"]][["version"]]
[16:18:40.290]                         if (is.null(version)) 
[16:18:40.290]                           version <- utils::packageVersion("future")
[16:18:40.290]                       }
[16:18:40.290]                       else {
[16:18:40.290]                         version <- NULL
[16:18:40.290]                       }
[16:18:40.290]                       if (!has_future || version < "1.8.0") {
[16:18:40.290]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.290]                           "", base::R.version$version.string), 
[16:18:40.290]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.290]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.290]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.290]                             "release", "version")], collapse = " "), 
[16:18:40.290]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.290]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.290]                           info)
[16:18:40.290]                         info <- base::paste(info, collapse = "; ")
[16:18:40.290]                         if (!has_future) {
[16:18:40.290]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.290]                             info)
[16:18:40.290]                         }
[16:18:40.290]                         else {
[16:18:40.290]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.290]                             info, version)
[16:18:40.290]                         }
[16:18:40.290]                         base::stop(msg)
[16:18:40.290]                       }
[16:18:40.290]                     })
[16:18:40.290]                   }
[16:18:40.290]                   ...future.strategy.old <- future::plan("list")
[16:18:40.290]                   options(future.plan = NULL)
[16:18:40.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.290]                 }
[16:18:40.290]                 ...future.workdir <- getwd()
[16:18:40.290]             }
[16:18:40.290]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.290]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.290]         }
[16:18:40.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.290]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:40.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.290]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.290]             base::names(...future.oldOptions))
[16:18:40.290]     }
[16:18:40.290]     if (FALSE) {
[16:18:40.290]     }
[16:18:40.290]     else {
[16:18:40.290]         if (TRUE) {
[16:18:40.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.290]                 open = "w")
[16:18:40.290]         }
[16:18:40.290]         else {
[16:18:40.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.290]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.290]         }
[16:18:40.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.290]             base::sink(type = "output", split = FALSE)
[16:18:40.290]             base::close(...future.stdout)
[16:18:40.290]         }, add = TRUE)
[16:18:40.290]     }
[16:18:40.290]     ...future.frame <- base::sys.nframe()
[16:18:40.290]     ...future.conditions <- base::list()
[16:18:40.290]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.290]     if (FALSE) {
[16:18:40.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.290]     }
[16:18:40.290]     ...future.result <- base::tryCatch({
[16:18:40.290]         base::withCallingHandlers({
[16:18:40.290]             ...future.value <- base::withVisible(base::local({
[16:18:40.290]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.290]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.290]                   ...future.globals.maxSize)) {
[16:18:40.290]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.290]                   on.exit(options(oopts), add = TRUE)
[16:18:40.290]                 }
[16:18:40.290]                 {
[16:18:40.290]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.290]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.290]                     USE.NAMES = FALSE)
[16:18:40.290]                   do.call(mapply, args = args)
[16:18:40.290]                 }
[16:18:40.290]             }))
[16:18:40.290]             future::FutureResult(value = ...future.value$value, 
[16:18:40.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.290]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.290]                     ...future.globalenv.names))
[16:18:40.290]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.290]         }, condition = base::local({
[16:18:40.290]             c <- base::c
[16:18:40.290]             inherits <- base::inherits
[16:18:40.290]             invokeRestart <- base::invokeRestart
[16:18:40.290]             length <- base::length
[16:18:40.290]             list <- base::list
[16:18:40.290]             seq.int <- base::seq.int
[16:18:40.290]             signalCondition <- base::signalCondition
[16:18:40.290]             sys.calls <- base::sys.calls
[16:18:40.290]             `[[` <- base::`[[`
[16:18:40.290]             `+` <- base::`+`
[16:18:40.290]             `<<-` <- base::`<<-`
[16:18:40.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.290]                   3L)]
[16:18:40.290]             }
[16:18:40.290]             function(cond) {
[16:18:40.290]                 is_error <- inherits(cond, "error")
[16:18:40.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.290]                   NULL)
[16:18:40.290]                 if (is_error) {
[16:18:40.290]                   sessionInformation <- function() {
[16:18:40.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.290]                       search = base::search(), system = base::Sys.info())
[16:18:40.290]                   }
[16:18:40.290]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.290]                     cond$call), session = sessionInformation(), 
[16:18:40.290]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.290]                   signalCondition(cond)
[16:18:40.290]                 }
[16:18:40.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.290]                 "immediateCondition"))) {
[16:18:40.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.290]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.290]                   if (TRUE && !signal) {
[16:18:40.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.290]                     {
[16:18:40.290]                       inherits <- base::inherits
[16:18:40.290]                       invokeRestart <- base::invokeRestart
[16:18:40.290]                       is.null <- base::is.null
[16:18:40.290]                       muffled <- FALSE
[16:18:40.290]                       if (inherits(cond, "message")) {
[16:18:40.290]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.290]                         if (muffled) 
[16:18:40.290]                           invokeRestart("muffleMessage")
[16:18:40.290]                       }
[16:18:40.290]                       else if (inherits(cond, "warning")) {
[16:18:40.290]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.290]                         if (muffled) 
[16:18:40.290]                           invokeRestart("muffleWarning")
[16:18:40.290]                       }
[16:18:40.290]                       else if (inherits(cond, "condition")) {
[16:18:40.290]                         if (!is.null(pattern)) {
[16:18:40.290]                           computeRestarts <- base::computeRestarts
[16:18:40.290]                           grepl <- base::grepl
[16:18:40.290]                           restarts <- computeRestarts(cond)
[16:18:40.290]                           for (restart in restarts) {
[16:18:40.290]                             name <- restart$name
[16:18:40.290]                             if (is.null(name)) 
[16:18:40.290]                               next
[16:18:40.290]                             if (!grepl(pattern, name)) 
[16:18:40.290]                               next
[16:18:40.290]                             invokeRestart(restart)
[16:18:40.290]                             muffled <- TRUE
[16:18:40.290]                             break
[16:18:40.290]                           }
[16:18:40.290]                         }
[16:18:40.290]                       }
[16:18:40.290]                       invisible(muffled)
[16:18:40.290]                     }
[16:18:40.290]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.290]                   }
[16:18:40.290]                 }
[16:18:40.290]                 else {
[16:18:40.290]                   if (TRUE) {
[16:18:40.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.290]                     {
[16:18:40.290]                       inherits <- base::inherits
[16:18:40.290]                       invokeRestart <- base::invokeRestart
[16:18:40.290]                       is.null <- base::is.null
[16:18:40.290]                       muffled <- FALSE
[16:18:40.290]                       if (inherits(cond, "message")) {
[16:18:40.290]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.290]                         if (muffled) 
[16:18:40.290]                           invokeRestart("muffleMessage")
[16:18:40.290]                       }
[16:18:40.290]                       else if (inherits(cond, "warning")) {
[16:18:40.290]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.290]                         if (muffled) 
[16:18:40.290]                           invokeRestart("muffleWarning")
[16:18:40.290]                       }
[16:18:40.290]                       else if (inherits(cond, "condition")) {
[16:18:40.290]                         if (!is.null(pattern)) {
[16:18:40.290]                           computeRestarts <- base::computeRestarts
[16:18:40.290]                           grepl <- base::grepl
[16:18:40.290]                           restarts <- computeRestarts(cond)
[16:18:40.290]                           for (restart in restarts) {
[16:18:40.290]                             name <- restart$name
[16:18:40.290]                             if (is.null(name)) 
[16:18:40.290]                               next
[16:18:40.290]                             if (!grepl(pattern, name)) 
[16:18:40.290]                               next
[16:18:40.290]                             invokeRestart(restart)
[16:18:40.290]                             muffled <- TRUE
[16:18:40.290]                             break
[16:18:40.290]                           }
[16:18:40.290]                         }
[16:18:40.290]                       }
[16:18:40.290]                       invisible(muffled)
[16:18:40.290]                     }
[16:18:40.290]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.290]                   }
[16:18:40.290]                 }
[16:18:40.290]             }
[16:18:40.290]         }))
[16:18:40.290]     }, error = function(ex) {
[16:18:40.290]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.290]                 ...future.rng), started = ...future.startTime, 
[16:18:40.290]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.290]             version = "1.8"), class = "FutureResult")
[16:18:40.290]     }, finally = {
[16:18:40.290]         if (!identical(...future.workdir, getwd())) 
[16:18:40.290]             setwd(...future.workdir)
[16:18:40.290]         {
[16:18:40.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.290]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.290]             }
[16:18:40.290]             base::options(...future.oldOptions)
[16:18:40.290]             if (.Platform$OS.type == "windows") {
[16:18:40.290]                 old_names <- names(...future.oldEnvVars)
[16:18:40.290]                 envs <- base::Sys.getenv()
[16:18:40.290]                 names <- names(envs)
[16:18:40.290]                 common <- intersect(names, old_names)
[16:18:40.290]                 added <- setdiff(names, old_names)
[16:18:40.290]                 removed <- setdiff(old_names, names)
[16:18:40.290]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.290]                   envs[common]]
[16:18:40.290]                 NAMES <- toupper(changed)
[16:18:40.290]                 args <- list()
[16:18:40.290]                 for (kk in seq_along(NAMES)) {
[16:18:40.290]                   name <- changed[[kk]]
[16:18:40.290]                   NAME <- NAMES[[kk]]
[16:18:40.290]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.290]                     next
[16:18:40.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.290]                 }
[16:18:40.290]                 NAMES <- toupper(added)
[16:18:40.290]                 for (kk in seq_along(NAMES)) {
[16:18:40.290]                   name <- added[[kk]]
[16:18:40.290]                   NAME <- NAMES[[kk]]
[16:18:40.290]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.290]                     next
[16:18:40.290]                   args[[name]] <- ""
[16:18:40.290]                 }
[16:18:40.290]                 NAMES <- toupper(removed)
[16:18:40.290]                 for (kk in seq_along(NAMES)) {
[16:18:40.290]                   name <- removed[[kk]]
[16:18:40.290]                   NAME <- NAMES[[kk]]
[16:18:40.290]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.290]                     next
[16:18:40.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.290]                 }
[16:18:40.290]                 if (length(args) > 0) 
[16:18:40.290]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.290]             }
[16:18:40.290]             else {
[16:18:40.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.290]             }
[16:18:40.290]             {
[16:18:40.290]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.290]                   0L) {
[16:18:40.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.290]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.290]                   base::options(opts)
[16:18:40.290]                 }
[16:18:40.290]                 {
[16:18:40.290]                   {
[16:18:40.290]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.290]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.290]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.290]                       inherits = FALSE)
[16:18:40.290]                     NULL
[16:18:40.290]                   }
[16:18:40.290]                   options(future.plan = NULL)
[16:18:40.290]                   if (is.na(NA_character_)) 
[16:18:40.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.290]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.290]                     .init = FALSE)
[16:18:40.290]                 }
[16:18:40.290]             }
[16:18:40.290]         }
[16:18:40.290]     })
[16:18:40.290]     if (TRUE) {
[16:18:40.290]         base::sink(type = "output", split = FALSE)
[16:18:40.290]         if (TRUE) {
[16:18:40.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.290]         }
[16:18:40.290]         else {
[16:18:40.290]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.290]         }
[16:18:40.290]         base::close(...future.stdout)
[16:18:40.290]         ...future.stdout <- NULL
[16:18:40.290]     }
[16:18:40.290]     ...future.result$conditions <- ...future.conditions
[16:18:40.290]     ...future.result$finished <- base::Sys.time()
[16:18:40.290]     ...future.result
[16:18:40.290] }
[16:18:40.292] assign_globals() ...
[16:18:40.292] List of 5
[16:18:40.292]  $ ...future.FUN            :function (C, k)  
[16:18:40.292]  $ MoreArgs                 : NULL
[16:18:40.292]  $ ...future.elements_ii    :List of 2
[16:18:40.292]   ..$ :List of 1
[16:18:40.292]   .. ..$ : chr "E"
[16:18:40.292]   ..$ :List of 1
[16:18:40.292]   .. ..$ : int 1
[16:18:40.292]  $ ...future.seeds_ii       : NULL
[16:18:40.292]  $ ...future.globals.maxSize: NULL
[16:18:40.292]  - attr(*, "where")=List of 5
[16:18:40.292]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.292]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.292]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.292]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.292]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.292]  - attr(*, "resolved")= logi FALSE
[16:18:40.292]  - attr(*, "total_size")= num 3488
[16:18:40.292]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.292]  - attr(*, "already-done")= logi TRUE
[16:18:40.297] - reassign environment for ‘...future.FUN’
[16:18:40.297] - copied ‘...future.FUN’ to environment
[16:18:40.297] - copied ‘MoreArgs’ to environment
[16:18:40.297] - copied ‘...future.elements_ii’ to environment
[16:18:40.297] - copied ‘...future.seeds_ii’ to environment
[16:18:40.297] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.297] assign_globals() ... done
[16:18:40.297] plan(): Setting new future strategy stack:
[16:18:40.297] List of future strategies:
[16:18:40.297] 1. sequential:
[16:18:40.297]    - args: function (..., envir = parent.frame())
[16:18:40.297]    - tweaked: FALSE
[16:18:40.297]    - call: NULL
[16:18:40.298] plan(): nbrOfWorkers() = 1
[16:18:40.299] plan(): Setting new future strategy stack:
[16:18:40.299] List of future strategies:
[16:18:40.299] 1. sequential:
[16:18:40.299]    - args: function (..., envir = parent.frame())
[16:18:40.299]    - tweaked: FALSE
[16:18:40.299]    - call: plan(strategy)
[16:18:40.299] plan(): nbrOfWorkers() = 1
[16:18:40.299] SequentialFuture started (and completed)
[16:18:40.299] - Launch lazy future ... done
[16:18:40.299] run() for ‘SequentialFuture’ ... done
[16:18:40.300] Created future:
[16:18:40.300] SequentialFuture:
[16:18:40.300] Label: ‘future_mapply-5’
[16:18:40.300] Expression:
[16:18:40.300] {
[16:18:40.300]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.300]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.300]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.300]         on.exit(options(oopts), add = TRUE)
[16:18:40.300]     }
[16:18:40.300]     {
[16:18:40.300]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.300]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.300]         do.call(mapply, args = args)
[16:18:40.300]     }
[16:18:40.300] }
[16:18:40.300] Lazy evaluation: FALSE
[16:18:40.300] Asynchronous evaluation: FALSE
[16:18:40.300] Local evaluation: TRUE
[16:18:40.300] Environment: R_GlobalEnv
[16:18:40.300] Capture standard output: TRUE
[16:18:40.300] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.300] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.300] Packages: <none>
[16:18:40.300] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.300] Resolved: TRUE
[16:18:40.300] Value: 112 bytes of class ‘list’
[16:18:40.300] Early signaling: FALSE
[16:18:40.300] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.300] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.301] Chunk #5 of 5 ... DONE
[16:18:40.301] Launching 5 futures (chunks) ... DONE
[16:18:40.301] Resolving 5 futures (chunks) ...
[16:18:40.301] resolve() on list ...
[16:18:40.301]  recursive: 0
[16:18:40.301]  length: 5
[16:18:40.301] 
[16:18:40.301] resolved() for ‘SequentialFuture’ ...
[16:18:40.303] - state: ‘finished’
[16:18:40.303] - run: TRUE
[16:18:40.303] - result: ‘FutureResult’
[16:18:40.303] resolved() for ‘SequentialFuture’ ... done
[16:18:40.303] Future #1
[16:18:40.303] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.303] - nx: 5
[16:18:40.304] - relay: TRUE
[16:18:40.304] - stdout: TRUE
[16:18:40.304] - signal: TRUE
[16:18:40.304] - resignal: FALSE
[16:18:40.304] - force: TRUE
[16:18:40.304] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[16:18:40.304] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[16:18:40.304]  - until=1
[16:18:40.304]  - relaying element #1
[16:18:40.305] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:40.305] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:40.305] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.305]  length: 4 (resolved future 1)
[16:18:40.305] resolved() for ‘SequentialFuture’ ...
[16:18:40.305] - state: ‘finished’
[16:18:40.305] - run: TRUE
[16:18:40.305] - result: ‘FutureResult’
[16:18:40.305] resolved() for ‘SequentialFuture’ ... done
[16:18:40.306] Future #2
[16:18:40.306] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:18:40.306] - nx: 5
[16:18:40.306] - relay: TRUE
[16:18:40.306] - stdout: TRUE
[16:18:40.306] - signal: TRUE
[16:18:40.306] - resignal: FALSE
[16:18:40.306] - force: TRUE
[16:18:40.306] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:40.306] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:40.306]  - until=2
[16:18:40.307]  - relaying element #2
[16:18:40.307] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:40.307] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:40.307] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:18:40.307]  length: 3 (resolved future 2)
[16:18:40.307] resolved() for ‘SequentialFuture’ ...
[16:18:40.307] - state: ‘finished’
[16:18:40.307] - run: TRUE
[16:18:40.307] - result: ‘FutureResult’
[16:18:40.308] resolved() for ‘SequentialFuture’ ... done
[16:18:40.308] Future #3
[16:18:40.308] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:18:40.308] - nx: 5
[16:18:40.308] - relay: TRUE
[16:18:40.308] - stdout: TRUE
[16:18:40.308] - signal: TRUE
[16:18:40.308] - resignal: FALSE
[16:18:40.308] - force: TRUE
[16:18:40.308] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:40.308] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:40.309]  - until=3
[16:18:40.309]  - relaying element #3
[16:18:40.309] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:40.309] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:40.309] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:18:40.309]  length: 2 (resolved future 3)
[16:18:40.309] resolved() for ‘SequentialFuture’ ...
[16:18:40.309] - state: ‘finished’
[16:18:40.309] - run: TRUE
[16:18:40.310] - result: ‘FutureResult’
[16:18:40.310] resolved() for ‘SequentialFuture’ ... done
[16:18:40.310] Future #4
[16:18:40.310] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:18:40.310] - nx: 5
[16:18:40.310] - relay: TRUE
[16:18:40.310] - stdout: TRUE
[16:18:40.310] - signal: TRUE
[16:18:40.310] - resignal: FALSE
[16:18:40.310] - force: TRUE
[16:18:40.310] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:40.311] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:40.311]  - until=4
[16:18:40.311]  - relaying element #4
[16:18:40.311] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:40.311] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:40.311] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:18:40.311]  length: 1 (resolved future 4)
[16:18:40.311] resolved() for ‘SequentialFuture’ ...
[16:18:40.311] - state: ‘finished’
[16:18:40.311] - run: TRUE
[16:18:40.312] - result: ‘FutureResult’
[16:18:40.312] resolved() for ‘SequentialFuture’ ... done
[16:18:40.312] Future #5
[16:18:40.312] signalConditionsASAP(SequentialFuture, pos=5) ...
[16:18:40.312] - nx: 5
[16:18:40.312] - relay: TRUE
[16:18:40.312] - stdout: TRUE
[16:18:40.312] - signal: TRUE
[16:18:40.312] - resignal: FALSE
[16:18:40.312] - force: TRUE
[16:18:40.312] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:40.313] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:40.313]  - until=5
[16:18:40.313]  - relaying element #5
[16:18:40.313] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:40.313] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:40.313] signalConditionsASAP(SequentialFuture, pos=5) ... done
[16:18:40.313]  length: 0 (resolved future 5)
[16:18:40.313] Relaying remaining futures
[16:18:40.313] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.313] - nx: 5
[16:18:40.314] - relay: TRUE
[16:18:40.314] - stdout: TRUE
[16:18:40.314] - signal: TRUE
[16:18:40.314] - resignal: FALSE
[16:18:40.314] - force: TRUE
[16:18:40.314] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:40.314] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[16:18:40.314] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:40.314] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:40.314] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.314] resolve() on list ... DONE
[16:18:40.315]  - Number of value chunks collected: 5
[16:18:40.315] Resolving 5 futures (chunks) ... DONE
[16:18:40.315] Reducing values from 5 chunks ...
[16:18:40.315]  - Number of values collected after concatenation: 5
[16:18:40.315]  - Number of values expected: 5
[16:18:40.315] Reducing values from 5 chunks ... DONE
[16:18:40.315] future_mapply() ... DONE
[16:18:40.316] future_mapply() ...
[16:18:40.316] Number of chunks: 1
[16:18:40.316] getGlobalsAndPackagesXApply() ...
[16:18:40.316]  - future.globals: TRUE
[16:18:40.316] getGlobalsAndPackages() ...
[16:18:40.316] Searching for globals...
[16:18:40.318] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:40.318] Searching for globals ... DONE
[16:18:40.318] Resolving globals: FALSE
[16:18:40.318] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:40.319] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:40.319] - globals: [1] ‘FUN’
[16:18:40.319] 
[16:18:40.319] getGlobalsAndPackages() ... DONE
[16:18:40.319]  - globals found/used: [n=1] ‘FUN’
[16:18:40.319]  - needed namespaces: [n=0] 
[16:18:40.319] Finding globals ... DONE
[16:18:40.319] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.319] List of 2
[16:18:40.319]  $ ...future.FUN:function (C, k)  
[16:18:40.319]  $ MoreArgs     : list()
[16:18:40.319]  - attr(*, "where")=List of 2
[16:18:40.319]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.319]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.319]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.319]  - attr(*, "resolved")= logi FALSE
[16:18:40.319]  - attr(*, "total_size")= num NA
[16:18:40.322] Packages to be attached in all futures: [n=0] 
[16:18:40.322] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.322] Number of futures (= number of chunks): 1
[16:18:40.322] Launching 1 futures (chunks) ...
[16:18:40.322] Chunk #1 of 1 ...
[16:18:40.323]  - Finding globals in '...' for chunk #1 ...
[16:18:40.323] getGlobalsAndPackages() ...
[16:18:40.323] Searching for globals...
[16:18:40.323] 
[16:18:40.323] Searching for globals ... DONE
[16:18:40.323] - globals: [0] <none>
[16:18:40.323] getGlobalsAndPackages() ... DONE
[16:18:40.323]    + additional globals found: [n=0] 
[16:18:40.324]    + additional namespaces needed: [n=0] 
[16:18:40.324]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.324]  - seeds: <none>
[16:18:40.324]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.324] getGlobalsAndPackages() ...
[16:18:40.324] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.324] Resolving globals: FALSE
[16:18:40.325] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[16:18:40.325] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:40.325] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.325] 
[16:18:40.327] getGlobalsAndPackages() ... DONE
[16:18:40.327] run() for ‘Future’ ...
[16:18:40.327] - state: ‘created’
[16:18:40.327] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.328] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.328]   - Field: ‘label’
[16:18:40.328]   - Field: ‘local’
[16:18:40.328]   - Field: ‘owner’
[16:18:40.328]   - Field: ‘envir’
[16:18:40.328]   - Field: ‘packages’
[16:18:40.328]   - Field: ‘gc’
[16:18:40.329]   - Field: ‘conditions’
[16:18:40.329]   - Field: ‘expr’
[16:18:40.329]   - Field: ‘uuid’
[16:18:40.329]   - Field: ‘seed’
[16:18:40.329]   - Field: ‘version’
[16:18:40.329]   - Field: ‘result’
[16:18:40.329]   - Field: ‘asynchronous’
[16:18:40.329]   - Field: ‘calls’
[16:18:40.329]   - Field: ‘globals’
[16:18:40.329]   - Field: ‘stdout’
[16:18:40.330]   - Field: ‘earlySignal’
[16:18:40.330]   - Field: ‘lazy’
[16:18:40.330]   - Field: ‘state’
[16:18:40.330] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.330] - Launch lazy future ...
[16:18:40.330] Packages needed by the future expression (n = 0): <none>
[16:18:40.330] Packages needed by future strategies (n = 0): <none>
[16:18:40.331] {
[16:18:40.331]     {
[16:18:40.331]         {
[16:18:40.331]             ...future.startTime <- base::Sys.time()
[16:18:40.331]             {
[16:18:40.331]                 {
[16:18:40.331]                   {
[16:18:40.331]                     base::local({
[16:18:40.331]                       has_future <- base::requireNamespace("future", 
[16:18:40.331]                         quietly = TRUE)
[16:18:40.331]                       if (has_future) {
[16:18:40.331]                         ns <- base::getNamespace("future")
[16:18:40.331]                         version <- ns[[".package"]][["version"]]
[16:18:40.331]                         if (is.null(version)) 
[16:18:40.331]                           version <- utils::packageVersion("future")
[16:18:40.331]                       }
[16:18:40.331]                       else {
[16:18:40.331]                         version <- NULL
[16:18:40.331]                       }
[16:18:40.331]                       if (!has_future || version < "1.8.0") {
[16:18:40.331]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.331]                           "", base::R.version$version.string), 
[16:18:40.331]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.331]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.331]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.331]                             "release", "version")], collapse = " "), 
[16:18:40.331]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.331]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.331]                           info)
[16:18:40.331]                         info <- base::paste(info, collapse = "; ")
[16:18:40.331]                         if (!has_future) {
[16:18:40.331]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.331]                             info)
[16:18:40.331]                         }
[16:18:40.331]                         else {
[16:18:40.331]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.331]                             info, version)
[16:18:40.331]                         }
[16:18:40.331]                         base::stop(msg)
[16:18:40.331]                       }
[16:18:40.331]                     })
[16:18:40.331]                   }
[16:18:40.331]                   ...future.strategy.old <- future::plan("list")
[16:18:40.331]                   options(future.plan = NULL)
[16:18:40.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.331]                 }
[16:18:40.331]                 ...future.workdir <- getwd()
[16:18:40.331]             }
[16:18:40.331]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.331]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.331]         }
[16:18:40.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.331]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.331]             base::names(...future.oldOptions))
[16:18:40.331]     }
[16:18:40.331]     if (FALSE) {
[16:18:40.331]     }
[16:18:40.331]     else {
[16:18:40.331]         if (TRUE) {
[16:18:40.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.331]                 open = "w")
[16:18:40.331]         }
[16:18:40.331]         else {
[16:18:40.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.331]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.331]         }
[16:18:40.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.331]             base::sink(type = "output", split = FALSE)
[16:18:40.331]             base::close(...future.stdout)
[16:18:40.331]         }, add = TRUE)
[16:18:40.331]     }
[16:18:40.331]     ...future.frame <- base::sys.nframe()
[16:18:40.331]     ...future.conditions <- base::list()
[16:18:40.331]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.331]     if (FALSE) {
[16:18:40.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.331]     }
[16:18:40.331]     ...future.result <- base::tryCatch({
[16:18:40.331]         base::withCallingHandlers({
[16:18:40.331]             ...future.value <- base::withVisible(base::local({
[16:18:40.331]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.331]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.331]                   ...future.globals.maxSize)) {
[16:18:40.331]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.331]                   on.exit(options(oopts), add = TRUE)
[16:18:40.331]                 }
[16:18:40.331]                 {
[16:18:40.331]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.331]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.331]                     USE.NAMES = FALSE)
[16:18:40.331]                   do.call(mapply, args = args)
[16:18:40.331]                 }
[16:18:40.331]             }))
[16:18:40.331]             future::FutureResult(value = ...future.value$value, 
[16:18:40.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.331]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.331]                     ...future.globalenv.names))
[16:18:40.331]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.331]         }, condition = base::local({
[16:18:40.331]             c <- base::c
[16:18:40.331]             inherits <- base::inherits
[16:18:40.331]             invokeRestart <- base::invokeRestart
[16:18:40.331]             length <- base::length
[16:18:40.331]             list <- base::list
[16:18:40.331]             seq.int <- base::seq.int
[16:18:40.331]             signalCondition <- base::signalCondition
[16:18:40.331]             sys.calls <- base::sys.calls
[16:18:40.331]             `[[` <- base::`[[`
[16:18:40.331]             `+` <- base::`+`
[16:18:40.331]             `<<-` <- base::`<<-`
[16:18:40.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.331]                   3L)]
[16:18:40.331]             }
[16:18:40.331]             function(cond) {
[16:18:40.331]                 is_error <- inherits(cond, "error")
[16:18:40.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.331]                   NULL)
[16:18:40.331]                 if (is_error) {
[16:18:40.331]                   sessionInformation <- function() {
[16:18:40.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.331]                       search = base::search(), system = base::Sys.info())
[16:18:40.331]                   }
[16:18:40.331]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.331]                     cond$call), session = sessionInformation(), 
[16:18:40.331]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.331]                   signalCondition(cond)
[16:18:40.331]                 }
[16:18:40.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.331]                 "immediateCondition"))) {
[16:18:40.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.331]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.331]                   if (TRUE && !signal) {
[16:18:40.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.331]                     {
[16:18:40.331]                       inherits <- base::inherits
[16:18:40.331]                       invokeRestart <- base::invokeRestart
[16:18:40.331]                       is.null <- base::is.null
[16:18:40.331]                       muffled <- FALSE
[16:18:40.331]                       if (inherits(cond, "message")) {
[16:18:40.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.331]                         if (muffled) 
[16:18:40.331]                           invokeRestart("muffleMessage")
[16:18:40.331]                       }
[16:18:40.331]                       else if (inherits(cond, "warning")) {
[16:18:40.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.331]                         if (muffled) 
[16:18:40.331]                           invokeRestart("muffleWarning")
[16:18:40.331]                       }
[16:18:40.331]                       else if (inherits(cond, "condition")) {
[16:18:40.331]                         if (!is.null(pattern)) {
[16:18:40.331]                           computeRestarts <- base::computeRestarts
[16:18:40.331]                           grepl <- base::grepl
[16:18:40.331]                           restarts <- computeRestarts(cond)
[16:18:40.331]                           for (restart in restarts) {
[16:18:40.331]                             name <- restart$name
[16:18:40.331]                             if (is.null(name)) 
[16:18:40.331]                               next
[16:18:40.331]                             if (!grepl(pattern, name)) 
[16:18:40.331]                               next
[16:18:40.331]                             invokeRestart(restart)
[16:18:40.331]                             muffled <- TRUE
[16:18:40.331]                             break
[16:18:40.331]                           }
[16:18:40.331]                         }
[16:18:40.331]                       }
[16:18:40.331]                       invisible(muffled)
[16:18:40.331]                     }
[16:18:40.331]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.331]                   }
[16:18:40.331]                 }
[16:18:40.331]                 else {
[16:18:40.331]                   if (TRUE) {
[16:18:40.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.331]                     {
[16:18:40.331]                       inherits <- base::inherits
[16:18:40.331]                       invokeRestart <- base::invokeRestart
[16:18:40.331]                       is.null <- base::is.null
[16:18:40.331]                       muffled <- FALSE
[16:18:40.331]                       if (inherits(cond, "message")) {
[16:18:40.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.331]                         if (muffled) 
[16:18:40.331]                           invokeRestart("muffleMessage")
[16:18:40.331]                       }
[16:18:40.331]                       else if (inherits(cond, "warning")) {
[16:18:40.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.331]                         if (muffled) 
[16:18:40.331]                           invokeRestart("muffleWarning")
[16:18:40.331]                       }
[16:18:40.331]                       else if (inherits(cond, "condition")) {
[16:18:40.331]                         if (!is.null(pattern)) {
[16:18:40.331]                           computeRestarts <- base::computeRestarts
[16:18:40.331]                           grepl <- base::grepl
[16:18:40.331]                           restarts <- computeRestarts(cond)
[16:18:40.331]                           for (restart in restarts) {
[16:18:40.331]                             name <- restart$name
[16:18:40.331]                             if (is.null(name)) 
[16:18:40.331]                               next
[16:18:40.331]                             if (!grepl(pattern, name)) 
[16:18:40.331]                               next
[16:18:40.331]                             invokeRestart(restart)
[16:18:40.331]                             muffled <- TRUE
[16:18:40.331]                             break
[16:18:40.331]                           }
[16:18:40.331]                         }
[16:18:40.331]                       }
[16:18:40.331]                       invisible(muffled)
[16:18:40.331]                     }
[16:18:40.331]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.331]                   }
[16:18:40.331]                 }
[16:18:40.331]             }
[16:18:40.331]         }))
[16:18:40.331]     }, error = function(ex) {
[16:18:40.331]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.331]                 ...future.rng), started = ...future.startTime, 
[16:18:40.331]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.331]             version = "1.8"), class = "FutureResult")
[16:18:40.331]     }, finally = {
[16:18:40.331]         if (!identical(...future.workdir, getwd())) 
[16:18:40.331]             setwd(...future.workdir)
[16:18:40.331]         {
[16:18:40.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.331]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.331]             }
[16:18:40.331]             base::options(...future.oldOptions)
[16:18:40.331]             if (.Platform$OS.type == "windows") {
[16:18:40.331]                 old_names <- names(...future.oldEnvVars)
[16:18:40.331]                 envs <- base::Sys.getenv()
[16:18:40.331]                 names <- names(envs)
[16:18:40.331]                 common <- intersect(names, old_names)
[16:18:40.331]                 added <- setdiff(names, old_names)
[16:18:40.331]                 removed <- setdiff(old_names, names)
[16:18:40.331]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.331]                   envs[common]]
[16:18:40.331]                 NAMES <- toupper(changed)
[16:18:40.331]                 args <- list()
[16:18:40.331]                 for (kk in seq_along(NAMES)) {
[16:18:40.331]                   name <- changed[[kk]]
[16:18:40.331]                   NAME <- NAMES[[kk]]
[16:18:40.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.331]                     next
[16:18:40.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.331]                 }
[16:18:40.331]                 NAMES <- toupper(added)
[16:18:40.331]                 for (kk in seq_along(NAMES)) {
[16:18:40.331]                   name <- added[[kk]]
[16:18:40.331]                   NAME <- NAMES[[kk]]
[16:18:40.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.331]                     next
[16:18:40.331]                   args[[name]] <- ""
[16:18:40.331]                 }
[16:18:40.331]                 NAMES <- toupper(removed)
[16:18:40.331]                 for (kk in seq_along(NAMES)) {
[16:18:40.331]                   name <- removed[[kk]]
[16:18:40.331]                   NAME <- NAMES[[kk]]
[16:18:40.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.331]                     next
[16:18:40.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.331]                 }
[16:18:40.331]                 if (length(args) > 0) 
[16:18:40.331]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.331]             }
[16:18:40.331]             else {
[16:18:40.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.331]             }
[16:18:40.331]             {
[16:18:40.331]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.331]                   0L) {
[16:18:40.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.331]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.331]                   base::options(opts)
[16:18:40.331]                 }
[16:18:40.331]                 {
[16:18:40.331]                   {
[16:18:40.331]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.331]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.331]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.331]                       inherits = FALSE)
[16:18:40.331]                     NULL
[16:18:40.331]                   }
[16:18:40.331]                   options(future.plan = NULL)
[16:18:40.331]                   if (is.na(NA_character_)) 
[16:18:40.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.331]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.331]                     .init = FALSE)
[16:18:40.331]                 }
[16:18:40.331]             }
[16:18:40.331]         }
[16:18:40.331]     })
[16:18:40.331]     if (TRUE) {
[16:18:40.331]         base::sink(type = "output", split = FALSE)
[16:18:40.331]         if (TRUE) {
[16:18:40.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.331]         }
[16:18:40.331]         else {
[16:18:40.331]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.331]         }
[16:18:40.331]         base::close(...future.stdout)
[16:18:40.331]         ...future.stdout <- NULL
[16:18:40.331]     }
[16:18:40.331]     ...future.result$conditions <- ...future.conditions
[16:18:40.331]     ...future.result$finished <- base::Sys.time()
[16:18:40.331]     ...future.result
[16:18:40.331] }
[16:18:40.332] assign_globals() ...
[16:18:40.332] List of 5
[16:18:40.332]  $ ...future.FUN            :function (C, k)  
[16:18:40.332]  $ MoreArgs                 : list()
[16:18:40.332]  $ ...future.elements_ii    :List of 2
[16:18:40.332]   ..$ :List of 5
[16:18:40.332]   .. ..$ : chr "A"
[16:18:40.332]   .. ..$ : chr "B"
[16:18:40.332]   .. ..$ : chr "C"
[16:18:40.332]   .. ..$ : chr "D"
[16:18:40.332]   .. ..$ : chr "E"
[16:18:40.332]   ..$ :List of 5
[16:18:40.332]   .. ..$ : int 5
[16:18:40.332]   .. ..$ : int 4
[16:18:40.332]   .. ..$ : int 3
[16:18:40.332]   .. ..$ : int 2
[16:18:40.332]   .. ..$ : int 1
[16:18:40.332]  $ ...future.seeds_ii       : NULL
[16:18:40.332]  $ ...future.globals.maxSize: NULL
[16:18:40.332]  - attr(*, "where")=List of 5
[16:18:40.332]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.332]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.332]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.332]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.332]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.332]  - attr(*, "resolved")= logi FALSE
[16:18:40.332]  - attr(*, "total_size")= num 4160
[16:18:40.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.332]  - attr(*, "already-done")= logi TRUE
[16:18:40.339] - reassign environment for ‘...future.FUN’
[16:18:40.339] - copied ‘...future.FUN’ to environment
[16:18:40.340] - copied ‘MoreArgs’ to environment
[16:18:40.340] - copied ‘...future.elements_ii’ to environment
[16:18:40.340] - copied ‘...future.seeds_ii’ to environment
[16:18:40.340] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.340] assign_globals() ... done
[16:18:40.340] plan(): Setting new future strategy stack:
[16:18:40.340] List of future strategies:
[16:18:40.340] 1. sequential:
[16:18:40.340]    - args: function (..., envir = parent.frame())
[16:18:40.340]    - tweaked: FALSE
[16:18:40.340]    - call: NULL
[16:18:40.341] plan(): nbrOfWorkers() = 1
[16:18:40.341] plan(): Setting new future strategy stack:
[16:18:40.341] List of future strategies:
[16:18:40.341] 1. sequential:
[16:18:40.341]    - args: function (..., envir = parent.frame())
[16:18:40.341]    - tweaked: FALSE
[16:18:40.341]    - call: plan(strategy)
[16:18:40.342] plan(): nbrOfWorkers() = 1
[16:18:40.342] SequentialFuture started (and completed)
[16:18:40.342] - Launch lazy future ... done
[16:18:40.342] run() for ‘SequentialFuture’ ... done
[16:18:40.342] Created future:
[16:18:40.342] SequentialFuture:
[16:18:40.342] Label: ‘future_.mapply-1’
[16:18:40.342] Expression:
[16:18:40.342] {
[16:18:40.342]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.342]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.342]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.342]         on.exit(options(oopts), add = TRUE)
[16:18:40.342]     }
[16:18:40.342]     {
[16:18:40.342]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.342]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.342]         do.call(mapply, args = args)
[16:18:40.342]     }
[16:18:40.342] }
[16:18:40.342] Lazy evaluation: FALSE
[16:18:40.342] Asynchronous evaluation: FALSE
[16:18:40.342] Local evaluation: TRUE
[16:18:40.342] Environment: R_GlobalEnv
[16:18:40.342] Capture standard output: TRUE
[16:18:40.342] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.342] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.342] Packages: <none>
[16:18:40.342] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.342] Resolved: TRUE
[16:18:40.342] Value: 560 bytes of class ‘list’
[16:18:40.342] Early signaling: FALSE
[16:18:40.342] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.342] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.343] Chunk #1 of 1 ... DONE
[16:18:40.343] Launching 1 futures (chunks) ... DONE
[16:18:40.343] Resolving 1 futures (chunks) ...
[16:18:40.344] resolve() on list ...
[16:18:40.344]  recursive: 0
[16:18:40.344]  length: 1
[16:18:40.344] 
[16:18:40.344] resolved() for ‘SequentialFuture’ ...
[16:18:40.344] - state: ‘finished’
[16:18:40.344] - run: TRUE
[16:18:40.344] - result: ‘FutureResult’
[16:18:40.344] resolved() for ‘SequentialFuture’ ... done
[16:18:40.344] Future #1
[16:18:40.345] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.345] - nx: 1
[16:18:40.345] - relay: TRUE
[16:18:40.345] - stdout: TRUE
[16:18:40.345] - signal: TRUE
[16:18:40.345] - resignal: FALSE
[16:18:40.345] - force: TRUE
[16:18:40.345] - relayed: [n=1] FALSE
[16:18:40.345] - queued futures: [n=1] FALSE
[16:18:40.345]  - until=1
[16:18:40.345]  - relaying element #1
[16:18:40.346] - relayed: [n=1] TRUE
[16:18:40.346] - queued futures: [n=1] TRUE
[16:18:40.346] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.346]  length: 0 (resolved future 1)
[16:18:40.346] Relaying remaining futures
[16:18:40.346] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.346] - nx: 1
[16:18:40.346] - relay: TRUE
[16:18:40.346] - stdout: TRUE
[16:18:40.346] - signal: TRUE
[16:18:40.347] - resignal: FALSE
[16:18:40.347] - force: TRUE
[16:18:40.347] - relayed: [n=1] TRUE
[16:18:40.347] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.347] - relayed: [n=1] TRUE
[16:18:40.347] - queued futures: [n=1] TRUE
[16:18:40.347] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.347] resolve() on list ... DONE
[16:18:40.347]  - Number of value chunks collected: 1
[16:18:40.347] Resolving 1 futures (chunks) ... DONE
[16:18:40.347] Reducing values from 1 chunks ...
[16:18:40.348]  - Number of values collected after concatenation: 5
[16:18:40.348]  - Number of values expected: 5
[16:18:40.348] Reducing values from 1 chunks ... DONE
[16:18:40.348] future_mapply() ... DONE
[16:18:40.348] future_mapply() ...
[16:18:40.349] Number of chunks: 3
[16:18:40.349] Index remapping (attribute 'ordering'): [n = 5] 2, 1, 4, 3, 5
[16:18:40.349] getGlobalsAndPackagesXApply() ...
[16:18:40.349]  - future.globals: TRUE
[16:18:40.349] getGlobalsAndPackages() ...
[16:18:40.349] Searching for globals...
[16:18:40.352] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:40.352] Searching for globals ... DONE
[16:18:40.352] Resolving globals: FALSE
[16:18:40.352] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:40.353] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:40.353] - globals: [1] ‘FUN’
[16:18:40.353] 
[16:18:40.353] getGlobalsAndPackages() ... DONE
[16:18:40.353]  - globals found/used: [n=1] ‘FUN’
[16:18:40.353]  - needed namespaces: [n=0] 
[16:18:40.353] Finding globals ... DONE
[16:18:40.353] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.354] List of 2
[16:18:40.354]  $ ...future.FUN:function (C, k)  
[16:18:40.354]  $ MoreArgs     : NULL
[16:18:40.354]  - attr(*, "where")=List of 2
[16:18:40.354]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.354]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.354]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.354]  - attr(*, "resolved")= logi FALSE
[16:18:40.354]  - attr(*, "total_size")= num NA
[16:18:40.356] Packages to be attached in all futures: [n=0] 
[16:18:40.356] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.356] Number of futures (= number of chunks): 3
[16:18:40.356] Launching 3 futures (chunks) ...
[16:18:40.356] Chunk #1 of 3 ...
[16:18:40.357]  - Finding globals in '...' for chunk #1 ...
[16:18:40.357] getGlobalsAndPackages() ...
[16:18:40.357] Searching for globals...
[16:18:40.357] 
[16:18:40.357] Searching for globals ... DONE
[16:18:40.357] - globals: [0] <none>
[16:18:40.357] getGlobalsAndPackages() ... DONE
[16:18:40.357]    + additional globals found: [n=0] 
[16:18:40.358]    + additional namespaces needed: [n=0] 
[16:18:40.358]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.358]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:18:40.358]  - seeds: <none>
[16:18:40.358]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.358] getGlobalsAndPackages() ...
[16:18:40.358] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.358] Resolving globals: FALSE
[16:18:40.359] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:40.359] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.359] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.359] 
[16:18:40.359] getGlobalsAndPackages() ... DONE
[16:18:40.360] run() for ‘Future’ ...
[16:18:40.360] - state: ‘created’
[16:18:40.360] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.360] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.360] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.361]   - Field: ‘label’
[16:18:40.361]   - Field: ‘local’
[16:18:40.361]   - Field: ‘owner’
[16:18:40.361]   - Field: ‘envir’
[16:18:40.361]   - Field: ‘packages’
[16:18:40.361]   - Field: ‘gc’
[16:18:40.361]   - Field: ‘conditions’
[16:18:40.361]   - Field: ‘expr’
[16:18:40.361]   - Field: ‘uuid’
[16:18:40.361]   - Field: ‘seed’
[16:18:40.361]   - Field: ‘version’
[16:18:40.362]   - Field: ‘result’
[16:18:40.362]   - Field: ‘asynchronous’
[16:18:40.362]   - Field: ‘calls’
[16:18:40.362]   - Field: ‘globals’
[16:18:40.362]   - Field: ‘stdout’
[16:18:40.362]   - Field: ‘earlySignal’
[16:18:40.362]   - Field: ‘lazy’
[16:18:40.362]   - Field: ‘state’
[16:18:40.362] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.362] - Launch lazy future ...
[16:18:40.363] Packages needed by the future expression (n = 0): <none>
[16:18:40.363] Packages needed by future strategies (n = 0): <none>
[16:18:40.363] {
[16:18:40.363]     {
[16:18:40.363]         {
[16:18:40.363]             ...future.startTime <- base::Sys.time()
[16:18:40.363]             {
[16:18:40.363]                 {
[16:18:40.363]                   {
[16:18:40.363]                     base::local({
[16:18:40.363]                       has_future <- base::requireNamespace("future", 
[16:18:40.363]                         quietly = TRUE)
[16:18:40.363]                       if (has_future) {
[16:18:40.363]                         ns <- base::getNamespace("future")
[16:18:40.363]                         version <- ns[[".package"]][["version"]]
[16:18:40.363]                         if (is.null(version)) 
[16:18:40.363]                           version <- utils::packageVersion("future")
[16:18:40.363]                       }
[16:18:40.363]                       else {
[16:18:40.363]                         version <- NULL
[16:18:40.363]                       }
[16:18:40.363]                       if (!has_future || version < "1.8.0") {
[16:18:40.363]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.363]                           "", base::R.version$version.string), 
[16:18:40.363]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.363]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.363]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.363]                             "release", "version")], collapse = " "), 
[16:18:40.363]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.363]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.363]                           info)
[16:18:40.363]                         info <- base::paste(info, collapse = "; ")
[16:18:40.363]                         if (!has_future) {
[16:18:40.363]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.363]                             info)
[16:18:40.363]                         }
[16:18:40.363]                         else {
[16:18:40.363]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.363]                             info, version)
[16:18:40.363]                         }
[16:18:40.363]                         base::stop(msg)
[16:18:40.363]                       }
[16:18:40.363]                     })
[16:18:40.363]                   }
[16:18:40.363]                   ...future.strategy.old <- future::plan("list")
[16:18:40.363]                   options(future.plan = NULL)
[16:18:40.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.363]                 }
[16:18:40.363]                 ...future.workdir <- getwd()
[16:18:40.363]             }
[16:18:40.363]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.363]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.363]         }
[16:18:40.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.363]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:18:40.363]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.363]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.363]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.363]             base::names(...future.oldOptions))
[16:18:40.363]     }
[16:18:40.363]     if (FALSE) {
[16:18:40.363]     }
[16:18:40.363]     else {
[16:18:40.363]         if (TRUE) {
[16:18:40.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.363]                 open = "w")
[16:18:40.363]         }
[16:18:40.363]         else {
[16:18:40.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.363]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.363]         }
[16:18:40.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.363]             base::sink(type = "output", split = FALSE)
[16:18:40.363]             base::close(...future.stdout)
[16:18:40.363]         }, add = TRUE)
[16:18:40.363]     }
[16:18:40.363]     ...future.frame <- base::sys.nframe()
[16:18:40.363]     ...future.conditions <- base::list()
[16:18:40.363]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.363]     if (FALSE) {
[16:18:40.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.363]     }
[16:18:40.363]     ...future.result <- base::tryCatch({
[16:18:40.363]         base::withCallingHandlers({
[16:18:40.363]             ...future.value <- base::withVisible(base::local({
[16:18:40.363]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.363]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.363]                   ...future.globals.maxSize)) {
[16:18:40.363]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.363]                   on.exit(options(oopts), add = TRUE)
[16:18:40.363]                 }
[16:18:40.363]                 {
[16:18:40.363]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.363]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.363]                     USE.NAMES = FALSE)
[16:18:40.363]                   do.call(mapply, args = args)
[16:18:40.363]                 }
[16:18:40.363]             }))
[16:18:40.363]             future::FutureResult(value = ...future.value$value, 
[16:18:40.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.363]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.363]                     ...future.globalenv.names))
[16:18:40.363]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.363]         }, condition = base::local({
[16:18:40.363]             c <- base::c
[16:18:40.363]             inherits <- base::inherits
[16:18:40.363]             invokeRestart <- base::invokeRestart
[16:18:40.363]             length <- base::length
[16:18:40.363]             list <- base::list
[16:18:40.363]             seq.int <- base::seq.int
[16:18:40.363]             signalCondition <- base::signalCondition
[16:18:40.363]             sys.calls <- base::sys.calls
[16:18:40.363]             `[[` <- base::`[[`
[16:18:40.363]             `+` <- base::`+`
[16:18:40.363]             `<<-` <- base::`<<-`
[16:18:40.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.363]                   3L)]
[16:18:40.363]             }
[16:18:40.363]             function(cond) {
[16:18:40.363]                 is_error <- inherits(cond, "error")
[16:18:40.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.363]                   NULL)
[16:18:40.363]                 if (is_error) {
[16:18:40.363]                   sessionInformation <- function() {
[16:18:40.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.363]                       search = base::search(), system = base::Sys.info())
[16:18:40.363]                   }
[16:18:40.363]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.363]                     cond$call), session = sessionInformation(), 
[16:18:40.363]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.363]                   signalCondition(cond)
[16:18:40.363]                 }
[16:18:40.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.363]                 "immediateCondition"))) {
[16:18:40.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.363]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.363]                   if (TRUE && !signal) {
[16:18:40.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.363]                     {
[16:18:40.363]                       inherits <- base::inherits
[16:18:40.363]                       invokeRestart <- base::invokeRestart
[16:18:40.363]                       is.null <- base::is.null
[16:18:40.363]                       muffled <- FALSE
[16:18:40.363]                       if (inherits(cond, "message")) {
[16:18:40.363]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.363]                         if (muffled) 
[16:18:40.363]                           invokeRestart("muffleMessage")
[16:18:40.363]                       }
[16:18:40.363]                       else if (inherits(cond, "warning")) {
[16:18:40.363]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.363]                         if (muffled) 
[16:18:40.363]                           invokeRestart("muffleWarning")
[16:18:40.363]                       }
[16:18:40.363]                       else if (inherits(cond, "condition")) {
[16:18:40.363]                         if (!is.null(pattern)) {
[16:18:40.363]                           computeRestarts <- base::computeRestarts
[16:18:40.363]                           grepl <- base::grepl
[16:18:40.363]                           restarts <- computeRestarts(cond)
[16:18:40.363]                           for (restart in restarts) {
[16:18:40.363]                             name <- restart$name
[16:18:40.363]                             if (is.null(name)) 
[16:18:40.363]                               next
[16:18:40.363]                             if (!grepl(pattern, name)) 
[16:18:40.363]                               next
[16:18:40.363]                             invokeRestart(restart)
[16:18:40.363]                             muffled <- TRUE
[16:18:40.363]                             break
[16:18:40.363]                           }
[16:18:40.363]                         }
[16:18:40.363]                       }
[16:18:40.363]                       invisible(muffled)
[16:18:40.363]                     }
[16:18:40.363]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.363]                   }
[16:18:40.363]                 }
[16:18:40.363]                 else {
[16:18:40.363]                   if (TRUE) {
[16:18:40.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.363]                     {
[16:18:40.363]                       inherits <- base::inherits
[16:18:40.363]                       invokeRestart <- base::invokeRestart
[16:18:40.363]                       is.null <- base::is.null
[16:18:40.363]                       muffled <- FALSE
[16:18:40.363]                       if (inherits(cond, "message")) {
[16:18:40.363]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.363]                         if (muffled) 
[16:18:40.363]                           invokeRestart("muffleMessage")
[16:18:40.363]                       }
[16:18:40.363]                       else if (inherits(cond, "warning")) {
[16:18:40.363]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.363]                         if (muffled) 
[16:18:40.363]                           invokeRestart("muffleWarning")
[16:18:40.363]                       }
[16:18:40.363]                       else if (inherits(cond, "condition")) {
[16:18:40.363]                         if (!is.null(pattern)) {
[16:18:40.363]                           computeRestarts <- base::computeRestarts
[16:18:40.363]                           grepl <- base::grepl
[16:18:40.363]                           restarts <- computeRestarts(cond)
[16:18:40.363]                           for (restart in restarts) {
[16:18:40.363]                             name <- restart$name
[16:18:40.363]                             if (is.null(name)) 
[16:18:40.363]                               next
[16:18:40.363]                             if (!grepl(pattern, name)) 
[16:18:40.363]                               next
[16:18:40.363]                             invokeRestart(restart)
[16:18:40.363]                             muffled <- TRUE
[16:18:40.363]                             break
[16:18:40.363]                           }
[16:18:40.363]                         }
[16:18:40.363]                       }
[16:18:40.363]                       invisible(muffled)
[16:18:40.363]                     }
[16:18:40.363]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.363]                   }
[16:18:40.363]                 }
[16:18:40.363]             }
[16:18:40.363]         }))
[16:18:40.363]     }, error = function(ex) {
[16:18:40.363]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.363]                 ...future.rng), started = ...future.startTime, 
[16:18:40.363]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.363]             version = "1.8"), class = "FutureResult")
[16:18:40.363]     }, finally = {
[16:18:40.363]         if (!identical(...future.workdir, getwd())) 
[16:18:40.363]             setwd(...future.workdir)
[16:18:40.363]         {
[16:18:40.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.363]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.363]             }
[16:18:40.363]             base::options(...future.oldOptions)
[16:18:40.363]             if (.Platform$OS.type == "windows") {
[16:18:40.363]                 old_names <- names(...future.oldEnvVars)
[16:18:40.363]                 envs <- base::Sys.getenv()
[16:18:40.363]                 names <- names(envs)
[16:18:40.363]                 common <- intersect(names, old_names)
[16:18:40.363]                 added <- setdiff(names, old_names)
[16:18:40.363]                 removed <- setdiff(old_names, names)
[16:18:40.363]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.363]                   envs[common]]
[16:18:40.363]                 NAMES <- toupper(changed)
[16:18:40.363]                 args <- list()
[16:18:40.363]                 for (kk in seq_along(NAMES)) {
[16:18:40.363]                   name <- changed[[kk]]
[16:18:40.363]                   NAME <- NAMES[[kk]]
[16:18:40.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.363]                     next
[16:18:40.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.363]                 }
[16:18:40.363]                 NAMES <- toupper(added)
[16:18:40.363]                 for (kk in seq_along(NAMES)) {
[16:18:40.363]                   name <- added[[kk]]
[16:18:40.363]                   NAME <- NAMES[[kk]]
[16:18:40.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.363]                     next
[16:18:40.363]                   args[[name]] <- ""
[16:18:40.363]                 }
[16:18:40.363]                 NAMES <- toupper(removed)
[16:18:40.363]                 for (kk in seq_along(NAMES)) {
[16:18:40.363]                   name <- removed[[kk]]
[16:18:40.363]                   NAME <- NAMES[[kk]]
[16:18:40.363]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.363]                     next
[16:18:40.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.363]                 }
[16:18:40.363]                 if (length(args) > 0) 
[16:18:40.363]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.363]             }
[16:18:40.363]             else {
[16:18:40.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.363]             }
[16:18:40.363]             {
[16:18:40.363]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.363]                   0L) {
[16:18:40.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.363]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.363]                   base::options(opts)
[16:18:40.363]                 }
[16:18:40.363]                 {
[16:18:40.363]                   {
[16:18:40.363]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.363]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.363]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.363]                       inherits = FALSE)
[16:18:40.363]                     NULL
[16:18:40.363]                   }
[16:18:40.363]                   options(future.plan = NULL)
[16:18:40.363]                   if (is.na(NA_character_)) 
[16:18:40.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.363]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.363]                     .init = FALSE)
[16:18:40.363]                 }
[16:18:40.363]             }
[16:18:40.363]         }
[16:18:40.363]     })
[16:18:40.363]     if (TRUE) {
[16:18:40.363]         base::sink(type = "output", split = FALSE)
[16:18:40.363]         if (TRUE) {
[16:18:40.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.363]         }
[16:18:40.363]         else {
[16:18:40.363]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.363]         }
[16:18:40.363]         base::close(...future.stdout)
[16:18:40.363]         ...future.stdout <- NULL
[16:18:40.363]     }
[16:18:40.363]     ...future.result$conditions <- ...future.conditions
[16:18:40.363]     ...future.result$finished <- base::Sys.time()
[16:18:40.363]     ...future.result
[16:18:40.363] }
[16:18:40.365] assign_globals() ...
[16:18:40.365] List of 5
[16:18:40.365]  $ ...future.FUN            :function (C, k)  
[16:18:40.365]  $ MoreArgs                 : NULL
[16:18:40.365]  $ ...future.elements_ii    :List of 2
[16:18:40.365]   ..$ :List of 2
[16:18:40.365]   .. ..$ : chr "B"
[16:18:40.365]   .. ..$ : chr "A"
[16:18:40.365]   ..$ :List of 2
[16:18:40.365]   .. ..$ : int 4
[16:18:40.365]   .. ..$ : int 5
[16:18:40.365]  $ ...future.seeds_ii       : NULL
[16:18:40.365]  $ ...future.globals.maxSize: NULL
[16:18:40.365]  - attr(*, "where")=List of 5
[16:18:40.365]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.365]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.365]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.365]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.365]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.365]  - attr(*, "resolved")= logi FALSE
[16:18:40.365]  - attr(*, "total_size")= num 3656
[16:18:40.365]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.365]  - attr(*, "already-done")= logi TRUE
[16:18:40.370] - reassign environment for ‘...future.FUN’
[16:18:40.370] - copied ‘...future.FUN’ to environment
[16:18:40.370] - copied ‘MoreArgs’ to environment
[16:18:40.370] - copied ‘...future.elements_ii’ to environment
[16:18:40.371] - copied ‘...future.seeds_ii’ to environment
[16:18:40.371] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.371] assign_globals() ... done
[16:18:40.371] plan(): Setting new future strategy stack:
[16:18:40.371] List of future strategies:
[16:18:40.371] 1. sequential:
[16:18:40.371]    - args: function (..., envir = parent.frame())
[16:18:40.371]    - tweaked: FALSE
[16:18:40.371]    - call: NULL
[16:18:40.371] plan(): nbrOfWorkers() = 1
[16:18:40.372] plan(): Setting new future strategy stack:
[16:18:40.372] List of future strategies:
[16:18:40.372] 1. sequential:
[16:18:40.372]    - args: function (..., envir = parent.frame())
[16:18:40.372]    - tweaked: FALSE
[16:18:40.372]    - call: plan(strategy)
[16:18:40.373] plan(): nbrOfWorkers() = 1
[16:18:40.373] SequentialFuture started (and completed)
[16:18:40.373] - Launch lazy future ... done
[16:18:40.373] run() for ‘SequentialFuture’ ... done
[16:18:40.373] Created future:
[16:18:40.373] SequentialFuture:
[16:18:40.373] Label: ‘future_mapply-1’
[16:18:40.373] Expression:
[16:18:40.373] {
[16:18:40.373]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.373]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.373]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.373]         on.exit(options(oopts), add = TRUE)
[16:18:40.373]     }
[16:18:40.373]     {
[16:18:40.373]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.373]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.373]         do.call(mapply, args = args)
[16:18:40.373]     }
[16:18:40.373] }
[16:18:40.373] Lazy evaluation: FALSE
[16:18:40.373] Asynchronous evaluation: FALSE
[16:18:40.373] Local evaluation: TRUE
[16:18:40.373] Environment: R_GlobalEnv
[16:18:40.373] Capture standard output: TRUE
[16:18:40.373] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.373] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.373] Packages: <none>
[16:18:40.373] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.373] Resolved: TRUE
[16:18:40.373] Value: 224 bytes of class ‘list’
[16:18:40.373] Early signaling: FALSE
[16:18:40.373] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.373] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.374] Chunk #1 of 3 ... DONE
[16:18:40.374] Chunk #2 of 3 ...
[16:18:40.374]  - Finding globals in '...' for chunk #2 ...
[16:18:40.374] getGlobalsAndPackages() ...
[16:18:40.375] Searching for globals...
[16:18:40.376] 
[16:18:40.376] Searching for globals ... DONE
[16:18:40.377] - globals: [0] <none>
[16:18:40.377] getGlobalsAndPackages() ... DONE
[16:18:40.377]    + additional globals found: [n=0] 
[16:18:40.377]    + additional namespaces needed: [n=0] 
[16:18:40.377]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:40.377]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:18:40.377]  - seeds: <none>
[16:18:40.377]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.377] getGlobalsAndPackages() ...
[16:18:40.378] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.378] Resolving globals: FALSE
[16:18:40.378] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:40.379] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.379] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.379] 
[16:18:40.379] getGlobalsAndPackages() ... DONE
[16:18:40.379] run() for ‘Future’ ...
[16:18:40.379] - state: ‘created’
[16:18:40.379] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.380] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.380]   - Field: ‘label’
[16:18:40.380]   - Field: ‘local’
[16:18:40.380]   - Field: ‘owner’
[16:18:40.380]   - Field: ‘envir’
[16:18:40.380]   - Field: ‘packages’
[16:18:40.380]   - Field: ‘gc’
[16:18:40.381]   - Field: ‘conditions’
[16:18:40.381]   - Field: ‘expr’
[16:18:40.381]   - Field: ‘uuid’
[16:18:40.381]   - Field: ‘seed’
[16:18:40.381]   - Field: ‘version’
[16:18:40.381]   - Field: ‘result’
[16:18:40.381]   - Field: ‘asynchronous’
[16:18:40.381]   - Field: ‘calls’
[16:18:40.381]   - Field: ‘globals’
[16:18:40.381]   - Field: ‘stdout’
[16:18:40.381]   - Field: ‘earlySignal’
[16:18:40.382]   - Field: ‘lazy’
[16:18:40.382]   - Field: ‘state’
[16:18:40.382] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.382] - Launch lazy future ...
[16:18:40.382] Packages needed by the future expression (n = 0): <none>
[16:18:40.382] Packages needed by future strategies (n = 0): <none>
[16:18:40.383] {
[16:18:40.383]     {
[16:18:40.383]         {
[16:18:40.383]             ...future.startTime <- base::Sys.time()
[16:18:40.383]             {
[16:18:40.383]                 {
[16:18:40.383]                   {
[16:18:40.383]                     base::local({
[16:18:40.383]                       has_future <- base::requireNamespace("future", 
[16:18:40.383]                         quietly = TRUE)
[16:18:40.383]                       if (has_future) {
[16:18:40.383]                         ns <- base::getNamespace("future")
[16:18:40.383]                         version <- ns[[".package"]][["version"]]
[16:18:40.383]                         if (is.null(version)) 
[16:18:40.383]                           version <- utils::packageVersion("future")
[16:18:40.383]                       }
[16:18:40.383]                       else {
[16:18:40.383]                         version <- NULL
[16:18:40.383]                       }
[16:18:40.383]                       if (!has_future || version < "1.8.0") {
[16:18:40.383]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.383]                           "", base::R.version$version.string), 
[16:18:40.383]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.383]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.383]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.383]                             "release", "version")], collapse = " "), 
[16:18:40.383]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.383]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.383]                           info)
[16:18:40.383]                         info <- base::paste(info, collapse = "; ")
[16:18:40.383]                         if (!has_future) {
[16:18:40.383]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.383]                             info)
[16:18:40.383]                         }
[16:18:40.383]                         else {
[16:18:40.383]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.383]                             info, version)
[16:18:40.383]                         }
[16:18:40.383]                         base::stop(msg)
[16:18:40.383]                       }
[16:18:40.383]                     })
[16:18:40.383]                   }
[16:18:40.383]                   ...future.strategy.old <- future::plan("list")
[16:18:40.383]                   options(future.plan = NULL)
[16:18:40.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.383]                 }
[16:18:40.383]                 ...future.workdir <- getwd()
[16:18:40.383]             }
[16:18:40.383]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.383]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.383]         }
[16:18:40.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.383]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:18:40.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.383]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.383]             base::names(...future.oldOptions))
[16:18:40.383]     }
[16:18:40.383]     if (FALSE) {
[16:18:40.383]     }
[16:18:40.383]     else {
[16:18:40.383]         if (TRUE) {
[16:18:40.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.383]                 open = "w")
[16:18:40.383]         }
[16:18:40.383]         else {
[16:18:40.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.383]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.383]         }
[16:18:40.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.383]             base::sink(type = "output", split = FALSE)
[16:18:40.383]             base::close(...future.stdout)
[16:18:40.383]         }, add = TRUE)
[16:18:40.383]     }
[16:18:40.383]     ...future.frame <- base::sys.nframe()
[16:18:40.383]     ...future.conditions <- base::list()
[16:18:40.383]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.383]     if (FALSE) {
[16:18:40.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.383]     }
[16:18:40.383]     ...future.result <- base::tryCatch({
[16:18:40.383]         base::withCallingHandlers({
[16:18:40.383]             ...future.value <- base::withVisible(base::local({
[16:18:40.383]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.383]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.383]                   ...future.globals.maxSize)) {
[16:18:40.383]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.383]                   on.exit(options(oopts), add = TRUE)
[16:18:40.383]                 }
[16:18:40.383]                 {
[16:18:40.383]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.383]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.383]                     USE.NAMES = FALSE)
[16:18:40.383]                   do.call(mapply, args = args)
[16:18:40.383]                 }
[16:18:40.383]             }))
[16:18:40.383]             future::FutureResult(value = ...future.value$value, 
[16:18:40.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.383]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.383]                     ...future.globalenv.names))
[16:18:40.383]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.383]         }, condition = base::local({
[16:18:40.383]             c <- base::c
[16:18:40.383]             inherits <- base::inherits
[16:18:40.383]             invokeRestart <- base::invokeRestart
[16:18:40.383]             length <- base::length
[16:18:40.383]             list <- base::list
[16:18:40.383]             seq.int <- base::seq.int
[16:18:40.383]             signalCondition <- base::signalCondition
[16:18:40.383]             sys.calls <- base::sys.calls
[16:18:40.383]             `[[` <- base::`[[`
[16:18:40.383]             `+` <- base::`+`
[16:18:40.383]             `<<-` <- base::`<<-`
[16:18:40.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.383]                   3L)]
[16:18:40.383]             }
[16:18:40.383]             function(cond) {
[16:18:40.383]                 is_error <- inherits(cond, "error")
[16:18:40.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.383]                   NULL)
[16:18:40.383]                 if (is_error) {
[16:18:40.383]                   sessionInformation <- function() {
[16:18:40.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.383]                       search = base::search(), system = base::Sys.info())
[16:18:40.383]                   }
[16:18:40.383]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.383]                     cond$call), session = sessionInformation(), 
[16:18:40.383]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.383]                   signalCondition(cond)
[16:18:40.383]                 }
[16:18:40.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.383]                 "immediateCondition"))) {
[16:18:40.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.383]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.383]                   if (TRUE && !signal) {
[16:18:40.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.383]                     {
[16:18:40.383]                       inherits <- base::inherits
[16:18:40.383]                       invokeRestart <- base::invokeRestart
[16:18:40.383]                       is.null <- base::is.null
[16:18:40.383]                       muffled <- FALSE
[16:18:40.383]                       if (inherits(cond, "message")) {
[16:18:40.383]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.383]                         if (muffled) 
[16:18:40.383]                           invokeRestart("muffleMessage")
[16:18:40.383]                       }
[16:18:40.383]                       else if (inherits(cond, "warning")) {
[16:18:40.383]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.383]                         if (muffled) 
[16:18:40.383]                           invokeRestart("muffleWarning")
[16:18:40.383]                       }
[16:18:40.383]                       else if (inherits(cond, "condition")) {
[16:18:40.383]                         if (!is.null(pattern)) {
[16:18:40.383]                           computeRestarts <- base::computeRestarts
[16:18:40.383]                           grepl <- base::grepl
[16:18:40.383]                           restarts <- computeRestarts(cond)
[16:18:40.383]                           for (restart in restarts) {
[16:18:40.383]                             name <- restart$name
[16:18:40.383]                             if (is.null(name)) 
[16:18:40.383]                               next
[16:18:40.383]                             if (!grepl(pattern, name)) 
[16:18:40.383]                               next
[16:18:40.383]                             invokeRestart(restart)
[16:18:40.383]                             muffled <- TRUE
[16:18:40.383]                             break
[16:18:40.383]                           }
[16:18:40.383]                         }
[16:18:40.383]                       }
[16:18:40.383]                       invisible(muffled)
[16:18:40.383]                     }
[16:18:40.383]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.383]                   }
[16:18:40.383]                 }
[16:18:40.383]                 else {
[16:18:40.383]                   if (TRUE) {
[16:18:40.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.383]                     {
[16:18:40.383]                       inherits <- base::inherits
[16:18:40.383]                       invokeRestart <- base::invokeRestart
[16:18:40.383]                       is.null <- base::is.null
[16:18:40.383]                       muffled <- FALSE
[16:18:40.383]                       if (inherits(cond, "message")) {
[16:18:40.383]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.383]                         if (muffled) 
[16:18:40.383]                           invokeRestart("muffleMessage")
[16:18:40.383]                       }
[16:18:40.383]                       else if (inherits(cond, "warning")) {
[16:18:40.383]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.383]                         if (muffled) 
[16:18:40.383]                           invokeRestart("muffleWarning")
[16:18:40.383]                       }
[16:18:40.383]                       else if (inherits(cond, "condition")) {
[16:18:40.383]                         if (!is.null(pattern)) {
[16:18:40.383]                           computeRestarts <- base::computeRestarts
[16:18:40.383]                           grepl <- base::grepl
[16:18:40.383]                           restarts <- computeRestarts(cond)
[16:18:40.383]                           for (restart in restarts) {
[16:18:40.383]                             name <- restart$name
[16:18:40.383]                             if (is.null(name)) 
[16:18:40.383]                               next
[16:18:40.383]                             if (!grepl(pattern, name)) 
[16:18:40.383]                               next
[16:18:40.383]                             invokeRestart(restart)
[16:18:40.383]                             muffled <- TRUE
[16:18:40.383]                             break
[16:18:40.383]                           }
[16:18:40.383]                         }
[16:18:40.383]                       }
[16:18:40.383]                       invisible(muffled)
[16:18:40.383]                     }
[16:18:40.383]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.383]                   }
[16:18:40.383]                 }
[16:18:40.383]             }
[16:18:40.383]         }))
[16:18:40.383]     }, error = function(ex) {
[16:18:40.383]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.383]                 ...future.rng), started = ...future.startTime, 
[16:18:40.383]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.383]             version = "1.8"), class = "FutureResult")
[16:18:40.383]     }, finally = {
[16:18:40.383]         if (!identical(...future.workdir, getwd())) 
[16:18:40.383]             setwd(...future.workdir)
[16:18:40.383]         {
[16:18:40.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.383]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.383]             }
[16:18:40.383]             base::options(...future.oldOptions)
[16:18:40.383]             if (.Platform$OS.type == "windows") {
[16:18:40.383]                 old_names <- names(...future.oldEnvVars)
[16:18:40.383]                 envs <- base::Sys.getenv()
[16:18:40.383]                 names <- names(envs)
[16:18:40.383]                 common <- intersect(names, old_names)
[16:18:40.383]                 added <- setdiff(names, old_names)
[16:18:40.383]                 removed <- setdiff(old_names, names)
[16:18:40.383]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.383]                   envs[common]]
[16:18:40.383]                 NAMES <- toupper(changed)
[16:18:40.383]                 args <- list()
[16:18:40.383]                 for (kk in seq_along(NAMES)) {
[16:18:40.383]                   name <- changed[[kk]]
[16:18:40.383]                   NAME <- NAMES[[kk]]
[16:18:40.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.383]                     next
[16:18:40.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.383]                 }
[16:18:40.383]                 NAMES <- toupper(added)
[16:18:40.383]                 for (kk in seq_along(NAMES)) {
[16:18:40.383]                   name <- added[[kk]]
[16:18:40.383]                   NAME <- NAMES[[kk]]
[16:18:40.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.383]                     next
[16:18:40.383]                   args[[name]] <- ""
[16:18:40.383]                 }
[16:18:40.383]                 NAMES <- toupper(removed)
[16:18:40.383]                 for (kk in seq_along(NAMES)) {
[16:18:40.383]                   name <- removed[[kk]]
[16:18:40.383]                   NAME <- NAMES[[kk]]
[16:18:40.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.383]                     next
[16:18:40.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.383]                 }
[16:18:40.383]                 if (length(args) > 0) 
[16:18:40.383]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.383]             }
[16:18:40.383]             else {
[16:18:40.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.383]             }
[16:18:40.383]             {
[16:18:40.383]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.383]                   0L) {
[16:18:40.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.383]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.383]                   base::options(opts)
[16:18:40.383]                 }
[16:18:40.383]                 {
[16:18:40.383]                   {
[16:18:40.383]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.383]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.383]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.383]                       inherits = FALSE)
[16:18:40.383]                     NULL
[16:18:40.383]                   }
[16:18:40.383]                   options(future.plan = NULL)
[16:18:40.383]                   if (is.na(NA_character_)) 
[16:18:40.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.383]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.383]                     .init = FALSE)
[16:18:40.383]                 }
[16:18:40.383]             }
[16:18:40.383]         }
[16:18:40.383]     })
[16:18:40.383]     if (TRUE) {
[16:18:40.383]         base::sink(type = "output", split = FALSE)
[16:18:40.383]         if (TRUE) {
[16:18:40.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.383]         }
[16:18:40.383]         else {
[16:18:40.383]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.383]         }
[16:18:40.383]         base::close(...future.stdout)
[16:18:40.383]         ...future.stdout <- NULL
[16:18:40.383]     }
[16:18:40.383]     ...future.result$conditions <- ...future.conditions
[16:18:40.383]     ...future.result$finished <- base::Sys.time()
[16:18:40.383]     ...future.result
[16:18:40.383] }
[16:18:40.384] assign_globals() ...
[16:18:40.384] List of 5
[16:18:40.384]  $ ...future.FUN            :function (C, k)  
[16:18:40.384]  $ MoreArgs                 : NULL
[16:18:40.384]  $ ...future.elements_ii    :List of 2
[16:18:40.384]   ..$ :List of 1
[16:18:40.384]   .. ..$ : chr "D"
[16:18:40.384]   ..$ :List of 1
[16:18:40.384]   .. ..$ : int 2
[16:18:40.384]  $ ...future.seeds_ii       : NULL
[16:18:40.384]  $ ...future.globals.maxSize: NULL
[16:18:40.384]  - attr(*, "where")=List of 5
[16:18:40.384]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.384]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.384]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.384]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.384]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.384]  - attr(*, "resolved")= logi FALSE
[16:18:40.384]  - attr(*, "total_size")= num 3488
[16:18:40.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.384]  - attr(*, "already-done")= logi TRUE
[16:18:40.389] - reassign environment for ‘...future.FUN’
[16:18:40.389] - copied ‘...future.FUN’ to environment
[16:18:40.389] - copied ‘MoreArgs’ to environment
[16:18:40.389] - copied ‘...future.elements_ii’ to environment
[16:18:40.390] - copied ‘...future.seeds_ii’ to environment
[16:18:40.390] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.390] assign_globals() ... done
[16:18:40.390] plan(): Setting new future strategy stack:
[16:18:40.390] List of future strategies:
[16:18:40.390] 1. sequential:
[16:18:40.390]    - args: function (..., envir = parent.frame())
[16:18:40.390]    - tweaked: FALSE
[16:18:40.390]    - call: NULL
[16:18:40.390] plan(): nbrOfWorkers() = 1
[16:18:40.391] plan(): Setting new future strategy stack:
[16:18:40.391] List of future strategies:
[16:18:40.391] 1. sequential:
[16:18:40.391]    - args: function (..., envir = parent.frame())
[16:18:40.391]    - tweaked: FALSE
[16:18:40.391]    - call: plan(strategy)
[16:18:40.392] plan(): nbrOfWorkers() = 1
[16:18:40.392] SequentialFuture started (and completed)
[16:18:40.392] - Launch lazy future ... done
[16:18:40.392] run() for ‘SequentialFuture’ ... done
[16:18:40.392] Created future:
[16:18:40.392] SequentialFuture:
[16:18:40.392] Label: ‘future_mapply-2’
[16:18:40.392] Expression:
[16:18:40.392] {
[16:18:40.392]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.392]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.392]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.392]         on.exit(options(oopts), add = TRUE)
[16:18:40.392]     }
[16:18:40.392]     {
[16:18:40.392]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.392]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.392]         do.call(mapply, args = args)
[16:18:40.392]     }
[16:18:40.392] }
[16:18:40.392] Lazy evaluation: FALSE
[16:18:40.392] Asynchronous evaluation: FALSE
[16:18:40.392] Local evaluation: TRUE
[16:18:40.392] Environment: R_GlobalEnv
[16:18:40.392] Capture standard output: TRUE
[16:18:40.392] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.392] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.392] Packages: <none>
[16:18:40.392] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.392] Resolved: TRUE
[16:18:40.392] Value: 112 bytes of class ‘list’
[16:18:40.392] Early signaling: FALSE
[16:18:40.392] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.392] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.393] Chunk #2 of 3 ... DONE
[16:18:40.393] Chunk #3 of 3 ...
[16:18:40.393]  - Finding globals in '...' for chunk #3 ...
[16:18:40.393] getGlobalsAndPackages() ...
[16:18:40.393] Searching for globals...
[16:18:40.394] 
[16:18:40.394] Searching for globals ... DONE
[16:18:40.394] - globals: [0] <none>
[16:18:40.394] getGlobalsAndPackages() ... DONE
[16:18:40.394]    + additional globals found: [n=0] 
[16:18:40.394]    + additional namespaces needed: [n=0] 
[16:18:40.394]  - Finding globals in '...' for chunk #3 ... DONE
[16:18:40.394]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:18:40.395]  - seeds: <none>
[16:18:40.395]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.395] getGlobalsAndPackages() ...
[16:18:40.395] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.395] Resolving globals: FALSE
[16:18:40.395] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:40.396] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.396] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.396] 
[16:18:40.396] getGlobalsAndPackages() ... DONE
[16:18:40.396] run() for ‘Future’ ...
[16:18:40.397] - state: ‘created’
[16:18:40.397] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.397] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.397] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.397]   - Field: ‘label’
[16:18:40.397]   - Field: ‘local’
[16:18:40.397]   - Field: ‘owner’
[16:18:40.397]   - Field: ‘envir’
[16:18:40.398]   - Field: ‘packages’
[16:18:40.398]   - Field: ‘gc’
[16:18:40.398]   - Field: ‘conditions’
[16:18:40.398]   - Field: ‘expr’
[16:18:40.398]   - Field: ‘uuid’
[16:18:40.398]   - Field: ‘seed’
[16:18:40.398]   - Field: ‘version’
[16:18:40.398]   - Field: ‘result’
[16:18:40.398]   - Field: ‘asynchronous’
[16:18:40.398]   - Field: ‘calls’
[16:18:40.398]   - Field: ‘globals’
[16:18:40.399]   - Field: ‘stdout’
[16:18:40.399]   - Field: ‘earlySignal’
[16:18:40.399]   - Field: ‘lazy’
[16:18:40.399]   - Field: ‘state’
[16:18:40.399] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.399] - Launch lazy future ...
[16:18:40.399] Packages needed by the future expression (n = 0): <none>
[16:18:40.399] Packages needed by future strategies (n = 0): <none>
[16:18:40.400] {
[16:18:40.400]     {
[16:18:40.400]         {
[16:18:40.400]             ...future.startTime <- base::Sys.time()
[16:18:40.400]             {
[16:18:40.400]                 {
[16:18:40.400]                   {
[16:18:40.400]                     base::local({
[16:18:40.400]                       has_future <- base::requireNamespace("future", 
[16:18:40.400]                         quietly = TRUE)
[16:18:40.400]                       if (has_future) {
[16:18:40.400]                         ns <- base::getNamespace("future")
[16:18:40.400]                         version <- ns[[".package"]][["version"]]
[16:18:40.400]                         if (is.null(version)) 
[16:18:40.400]                           version <- utils::packageVersion("future")
[16:18:40.400]                       }
[16:18:40.400]                       else {
[16:18:40.400]                         version <- NULL
[16:18:40.400]                       }
[16:18:40.400]                       if (!has_future || version < "1.8.0") {
[16:18:40.400]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.400]                           "", base::R.version$version.string), 
[16:18:40.400]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.400]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.400]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.400]                             "release", "version")], collapse = " "), 
[16:18:40.400]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.400]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.400]                           info)
[16:18:40.400]                         info <- base::paste(info, collapse = "; ")
[16:18:40.400]                         if (!has_future) {
[16:18:40.400]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.400]                             info)
[16:18:40.400]                         }
[16:18:40.400]                         else {
[16:18:40.400]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.400]                             info, version)
[16:18:40.400]                         }
[16:18:40.400]                         base::stop(msg)
[16:18:40.400]                       }
[16:18:40.400]                     })
[16:18:40.400]                   }
[16:18:40.400]                   ...future.strategy.old <- future::plan("list")
[16:18:40.400]                   options(future.plan = NULL)
[16:18:40.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.400]                 }
[16:18:40.400]                 ...future.workdir <- getwd()
[16:18:40.400]             }
[16:18:40.400]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.400]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.400]         }
[16:18:40.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.400]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:18:40.400]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.400]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.400]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.400]             base::names(...future.oldOptions))
[16:18:40.400]     }
[16:18:40.400]     if (FALSE) {
[16:18:40.400]     }
[16:18:40.400]     else {
[16:18:40.400]         if (TRUE) {
[16:18:40.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.400]                 open = "w")
[16:18:40.400]         }
[16:18:40.400]         else {
[16:18:40.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.400]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.400]         }
[16:18:40.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.400]             base::sink(type = "output", split = FALSE)
[16:18:40.400]             base::close(...future.stdout)
[16:18:40.400]         }, add = TRUE)
[16:18:40.400]     }
[16:18:40.400]     ...future.frame <- base::sys.nframe()
[16:18:40.400]     ...future.conditions <- base::list()
[16:18:40.400]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.400]     if (FALSE) {
[16:18:40.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.400]     }
[16:18:40.400]     ...future.result <- base::tryCatch({
[16:18:40.400]         base::withCallingHandlers({
[16:18:40.400]             ...future.value <- base::withVisible(base::local({
[16:18:40.400]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.400]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.400]                   ...future.globals.maxSize)) {
[16:18:40.400]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.400]                   on.exit(options(oopts), add = TRUE)
[16:18:40.400]                 }
[16:18:40.400]                 {
[16:18:40.400]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.400]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.400]                     USE.NAMES = FALSE)
[16:18:40.400]                   do.call(mapply, args = args)
[16:18:40.400]                 }
[16:18:40.400]             }))
[16:18:40.400]             future::FutureResult(value = ...future.value$value, 
[16:18:40.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.400]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.400]                     ...future.globalenv.names))
[16:18:40.400]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.400]         }, condition = base::local({
[16:18:40.400]             c <- base::c
[16:18:40.400]             inherits <- base::inherits
[16:18:40.400]             invokeRestart <- base::invokeRestart
[16:18:40.400]             length <- base::length
[16:18:40.400]             list <- base::list
[16:18:40.400]             seq.int <- base::seq.int
[16:18:40.400]             signalCondition <- base::signalCondition
[16:18:40.400]             sys.calls <- base::sys.calls
[16:18:40.400]             `[[` <- base::`[[`
[16:18:40.400]             `+` <- base::`+`
[16:18:40.400]             `<<-` <- base::`<<-`
[16:18:40.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.400]                   3L)]
[16:18:40.400]             }
[16:18:40.400]             function(cond) {
[16:18:40.400]                 is_error <- inherits(cond, "error")
[16:18:40.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.400]                   NULL)
[16:18:40.400]                 if (is_error) {
[16:18:40.400]                   sessionInformation <- function() {
[16:18:40.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.400]                       search = base::search(), system = base::Sys.info())
[16:18:40.400]                   }
[16:18:40.400]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.400]                     cond$call), session = sessionInformation(), 
[16:18:40.400]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.400]                   signalCondition(cond)
[16:18:40.400]                 }
[16:18:40.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.400]                 "immediateCondition"))) {
[16:18:40.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.400]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.400]                   if (TRUE && !signal) {
[16:18:40.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.400]                     {
[16:18:40.400]                       inherits <- base::inherits
[16:18:40.400]                       invokeRestart <- base::invokeRestart
[16:18:40.400]                       is.null <- base::is.null
[16:18:40.400]                       muffled <- FALSE
[16:18:40.400]                       if (inherits(cond, "message")) {
[16:18:40.400]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.400]                         if (muffled) 
[16:18:40.400]                           invokeRestart("muffleMessage")
[16:18:40.400]                       }
[16:18:40.400]                       else if (inherits(cond, "warning")) {
[16:18:40.400]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.400]                         if (muffled) 
[16:18:40.400]                           invokeRestart("muffleWarning")
[16:18:40.400]                       }
[16:18:40.400]                       else if (inherits(cond, "condition")) {
[16:18:40.400]                         if (!is.null(pattern)) {
[16:18:40.400]                           computeRestarts <- base::computeRestarts
[16:18:40.400]                           grepl <- base::grepl
[16:18:40.400]                           restarts <- computeRestarts(cond)
[16:18:40.400]                           for (restart in restarts) {
[16:18:40.400]                             name <- restart$name
[16:18:40.400]                             if (is.null(name)) 
[16:18:40.400]                               next
[16:18:40.400]                             if (!grepl(pattern, name)) 
[16:18:40.400]                               next
[16:18:40.400]                             invokeRestart(restart)
[16:18:40.400]                             muffled <- TRUE
[16:18:40.400]                             break
[16:18:40.400]                           }
[16:18:40.400]                         }
[16:18:40.400]                       }
[16:18:40.400]                       invisible(muffled)
[16:18:40.400]                     }
[16:18:40.400]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.400]                   }
[16:18:40.400]                 }
[16:18:40.400]                 else {
[16:18:40.400]                   if (TRUE) {
[16:18:40.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.400]                     {
[16:18:40.400]                       inherits <- base::inherits
[16:18:40.400]                       invokeRestart <- base::invokeRestart
[16:18:40.400]                       is.null <- base::is.null
[16:18:40.400]                       muffled <- FALSE
[16:18:40.400]                       if (inherits(cond, "message")) {
[16:18:40.400]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.400]                         if (muffled) 
[16:18:40.400]                           invokeRestart("muffleMessage")
[16:18:40.400]                       }
[16:18:40.400]                       else if (inherits(cond, "warning")) {
[16:18:40.400]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.400]                         if (muffled) 
[16:18:40.400]                           invokeRestart("muffleWarning")
[16:18:40.400]                       }
[16:18:40.400]                       else if (inherits(cond, "condition")) {
[16:18:40.400]                         if (!is.null(pattern)) {
[16:18:40.400]                           computeRestarts <- base::computeRestarts
[16:18:40.400]                           grepl <- base::grepl
[16:18:40.400]                           restarts <- computeRestarts(cond)
[16:18:40.400]                           for (restart in restarts) {
[16:18:40.400]                             name <- restart$name
[16:18:40.400]                             if (is.null(name)) 
[16:18:40.400]                               next
[16:18:40.400]                             if (!grepl(pattern, name)) 
[16:18:40.400]                               next
[16:18:40.400]                             invokeRestart(restart)
[16:18:40.400]                             muffled <- TRUE
[16:18:40.400]                             break
[16:18:40.400]                           }
[16:18:40.400]                         }
[16:18:40.400]                       }
[16:18:40.400]                       invisible(muffled)
[16:18:40.400]                     }
[16:18:40.400]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.400]                   }
[16:18:40.400]                 }
[16:18:40.400]             }
[16:18:40.400]         }))
[16:18:40.400]     }, error = function(ex) {
[16:18:40.400]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.400]                 ...future.rng), started = ...future.startTime, 
[16:18:40.400]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.400]             version = "1.8"), class = "FutureResult")
[16:18:40.400]     }, finally = {
[16:18:40.400]         if (!identical(...future.workdir, getwd())) 
[16:18:40.400]             setwd(...future.workdir)
[16:18:40.400]         {
[16:18:40.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.400]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.400]             }
[16:18:40.400]             base::options(...future.oldOptions)
[16:18:40.400]             if (.Platform$OS.type == "windows") {
[16:18:40.400]                 old_names <- names(...future.oldEnvVars)
[16:18:40.400]                 envs <- base::Sys.getenv()
[16:18:40.400]                 names <- names(envs)
[16:18:40.400]                 common <- intersect(names, old_names)
[16:18:40.400]                 added <- setdiff(names, old_names)
[16:18:40.400]                 removed <- setdiff(old_names, names)
[16:18:40.400]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.400]                   envs[common]]
[16:18:40.400]                 NAMES <- toupper(changed)
[16:18:40.400]                 args <- list()
[16:18:40.400]                 for (kk in seq_along(NAMES)) {
[16:18:40.400]                   name <- changed[[kk]]
[16:18:40.400]                   NAME <- NAMES[[kk]]
[16:18:40.400]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.400]                     next
[16:18:40.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.400]                 }
[16:18:40.400]                 NAMES <- toupper(added)
[16:18:40.400]                 for (kk in seq_along(NAMES)) {
[16:18:40.400]                   name <- added[[kk]]
[16:18:40.400]                   NAME <- NAMES[[kk]]
[16:18:40.400]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.400]                     next
[16:18:40.400]                   args[[name]] <- ""
[16:18:40.400]                 }
[16:18:40.400]                 NAMES <- toupper(removed)
[16:18:40.400]                 for (kk in seq_along(NAMES)) {
[16:18:40.400]                   name <- removed[[kk]]
[16:18:40.400]                   NAME <- NAMES[[kk]]
[16:18:40.400]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.400]                     next
[16:18:40.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.400]                 }
[16:18:40.400]                 if (length(args) > 0) 
[16:18:40.400]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.400]             }
[16:18:40.400]             else {
[16:18:40.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.400]             }
[16:18:40.400]             {
[16:18:40.400]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.400]                   0L) {
[16:18:40.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.400]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.400]                   base::options(opts)
[16:18:40.400]                 }
[16:18:40.400]                 {
[16:18:40.400]                   {
[16:18:40.400]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.400]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.400]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.400]                       inherits = FALSE)
[16:18:40.400]                     NULL
[16:18:40.400]                   }
[16:18:40.400]                   options(future.plan = NULL)
[16:18:40.400]                   if (is.na(NA_character_)) 
[16:18:40.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.400]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.400]                     .init = FALSE)
[16:18:40.400]                 }
[16:18:40.400]             }
[16:18:40.400]         }
[16:18:40.400]     })
[16:18:40.400]     if (TRUE) {
[16:18:40.400]         base::sink(type = "output", split = FALSE)
[16:18:40.400]         if (TRUE) {
[16:18:40.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.400]         }
[16:18:40.400]         else {
[16:18:40.400]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.400]         }
[16:18:40.400]         base::close(...future.stdout)
[16:18:40.400]         ...future.stdout <- NULL
[16:18:40.400]     }
[16:18:40.400]     ...future.result$conditions <- ...future.conditions
[16:18:40.400]     ...future.result$finished <- base::Sys.time()
[16:18:40.400]     ...future.result
[16:18:40.400] }
[16:18:40.401] assign_globals() ...
[16:18:40.403] List of 5
[16:18:40.403]  $ ...future.FUN            :function (C, k)  
[16:18:40.403]  $ MoreArgs                 : NULL
[16:18:40.403]  $ ...future.elements_ii    :List of 2
[16:18:40.403]   ..$ :List of 2
[16:18:40.403]   .. ..$ : chr "C"
[16:18:40.403]   .. ..$ : chr "E"
[16:18:40.403]   ..$ :List of 2
[16:18:40.403]   .. ..$ : int 3
[16:18:40.403]   .. ..$ : int 1
[16:18:40.403]  $ ...future.seeds_ii       : NULL
[16:18:40.403]  $ ...future.globals.maxSize: NULL
[16:18:40.403]  - attr(*, "where")=List of 5
[16:18:40.403]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.403]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.403]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.403]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.403]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.403]  - attr(*, "resolved")= logi FALSE
[16:18:40.403]  - attr(*, "total_size")= num 3656
[16:18:40.403]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.403]  - attr(*, "already-done")= logi TRUE
[16:18:40.409] - reassign environment for ‘...future.FUN’
[16:18:40.409] - copied ‘...future.FUN’ to environment
[16:18:40.409] - copied ‘MoreArgs’ to environment
[16:18:40.409] - copied ‘...future.elements_ii’ to environment
[16:18:40.409] - copied ‘...future.seeds_ii’ to environment
[16:18:40.410] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.410] assign_globals() ... done
[16:18:40.410] plan(): Setting new future strategy stack:
[16:18:40.410] List of future strategies:
[16:18:40.410] 1. sequential:
[16:18:40.410]    - args: function (..., envir = parent.frame())
[16:18:40.410]    - tweaked: FALSE
[16:18:40.410]    - call: NULL
[16:18:40.410] plan(): nbrOfWorkers() = 1
[16:18:40.411] plan(): Setting new future strategy stack:
[16:18:40.411] List of future strategies:
[16:18:40.411] 1. sequential:
[16:18:40.411]    - args: function (..., envir = parent.frame())
[16:18:40.411]    - tweaked: FALSE
[16:18:40.411]    - call: plan(strategy)
[16:18:40.412] plan(): nbrOfWorkers() = 1
[16:18:40.412] SequentialFuture started (and completed)
[16:18:40.412] - Launch lazy future ... done
[16:18:40.412] run() for ‘SequentialFuture’ ... done
[16:18:40.412] Created future:
[16:18:40.412] SequentialFuture:
[16:18:40.412] Label: ‘future_mapply-3’
[16:18:40.412] Expression:
[16:18:40.412] {
[16:18:40.412]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.412]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.412]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.412]         on.exit(options(oopts), add = TRUE)
[16:18:40.412]     }
[16:18:40.412]     {
[16:18:40.412]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.412]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.412]         do.call(mapply, args = args)
[16:18:40.412]     }
[16:18:40.412] }
[16:18:40.412] Lazy evaluation: FALSE
[16:18:40.412] Asynchronous evaluation: FALSE
[16:18:40.412] Local evaluation: TRUE
[16:18:40.412] Environment: R_GlobalEnv
[16:18:40.412] Capture standard output: TRUE
[16:18:40.412] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.412] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.412] Packages: <none>
[16:18:40.412] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.412] Resolved: TRUE
[16:18:40.412] Value: 224 bytes of class ‘list’
[16:18:40.412] Early signaling: FALSE
[16:18:40.412] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.412] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.413] Chunk #3 of 3 ... DONE
[16:18:40.413] Launching 3 futures (chunks) ... DONE
[16:18:40.413] Resolving 3 futures (chunks) ...
[16:18:40.414] resolve() on list ...
[16:18:40.414]  recursive: 0
[16:18:40.414]  length: 3
[16:18:40.414] 
[16:18:40.414] resolved() for ‘SequentialFuture’ ...
[16:18:40.414] - state: ‘finished’
[16:18:40.414] - run: TRUE
[16:18:40.414] - result: ‘FutureResult’
[16:18:40.414] resolved() for ‘SequentialFuture’ ... done
[16:18:40.414] Future #1
[16:18:40.415] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.415] - nx: 3
[16:18:40.415] - relay: TRUE
[16:18:40.415] - stdout: TRUE
[16:18:40.415] - signal: TRUE
[16:18:40.415] - resignal: FALSE
[16:18:40.415] - force: TRUE
[16:18:40.415] - relayed: [n=3] FALSE, FALSE, FALSE
[16:18:40.415] - queued futures: [n=3] FALSE, FALSE, FALSE
[16:18:40.415]  - until=1
[16:18:40.415]  - relaying element #1
[16:18:40.416] - relayed: [n=3] TRUE, FALSE, FALSE
[16:18:40.416] - queued futures: [n=3] TRUE, FALSE, FALSE
[16:18:40.416] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.416]  length: 2 (resolved future 1)
[16:18:40.416] resolved() for ‘SequentialFuture’ ...
[16:18:40.416] - state: ‘finished’
[16:18:40.416] - run: TRUE
[16:18:40.416] - result: ‘FutureResult’
[16:18:40.416] resolved() for ‘SequentialFuture’ ... done
[16:18:40.417] Future #2
[16:18:40.417] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:18:40.417] - nx: 3
[16:18:40.417] - relay: TRUE
[16:18:40.417] - stdout: TRUE
[16:18:40.417] - signal: TRUE
[16:18:40.417] - resignal: FALSE
[16:18:40.417] - force: TRUE
[16:18:40.417] - relayed: [n=3] TRUE, FALSE, FALSE
[16:18:40.417] - queued futures: [n=3] TRUE, FALSE, FALSE
[16:18:40.417]  - until=2
[16:18:40.417]  - relaying element #2
[16:18:40.418] - relayed: [n=3] TRUE, TRUE, FALSE
[16:18:40.418] - queued futures: [n=3] TRUE, TRUE, FALSE
[16:18:40.418] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:18:40.418]  length: 1 (resolved future 2)
[16:18:40.418] resolved() for ‘SequentialFuture’ ...
[16:18:40.418] - state: ‘finished’
[16:18:40.418] - run: TRUE
[16:18:40.418] - result: ‘FutureResult’
[16:18:40.418] resolved() for ‘SequentialFuture’ ... done
[16:18:40.419] Future #3
[16:18:40.419] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:18:40.419] - nx: 3
[16:18:40.419] - relay: TRUE
[16:18:40.419] - stdout: TRUE
[16:18:40.419] - signal: TRUE
[16:18:40.419] - resignal: FALSE
[16:18:40.419] - force: TRUE
[16:18:40.419] - relayed: [n=3] TRUE, TRUE, FALSE
[16:18:40.419] - queued futures: [n=3] TRUE, TRUE, FALSE
[16:18:40.419]  - until=3
[16:18:40.420]  - relaying element #3
[16:18:40.420] - relayed: [n=3] TRUE, TRUE, TRUE
[16:18:40.420] - queued futures: [n=3] TRUE, TRUE, TRUE
[16:18:40.420] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:18:40.420]  length: 0 (resolved future 3)
[16:18:40.420] Relaying remaining futures
[16:18:40.420] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.420] - nx: 3
[16:18:40.420] - relay: TRUE
[16:18:40.420] - stdout: TRUE
[16:18:40.421] - signal: TRUE
[16:18:40.421] - resignal: FALSE
[16:18:40.421] - force: TRUE
[16:18:40.421] - relayed: [n=3] TRUE, TRUE, TRUE
[16:18:40.421] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[16:18:40.421] - relayed: [n=3] TRUE, TRUE, TRUE
[16:18:40.421] - queued futures: [n=3] TRUE, TRUE, TRUE
[16:18:40.421] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.421] resolve() on list ... DONE
[16:18:40.422]  - Number of value chunks collected: 3
[16:18:40.422] Resolving 3 futures (chunks) ... DONE
[16:18:40.422] Reducing values from 3 chunks ...
[16:18:40.422]  - Number of values collected after concatenation: 5
[16:18:40.422]  - Number of values expected: 5
[16:18:40.422] Reverse index remapping (attribute 'ordering'): [n = 5] 2, 1, 4, 3, 5
[16:18:40.422] Reducing values from 3 chunks ... DONE
[16:18:40.422] future_mapply() ... DONE
[16:18:40.423] future_mapply() ...
[16:18:40.423] Number of chunks: 1
[16:18:40.423] getGlobalsAndPackagesXApply() ...
[16:18:40.423]  - future.globals: TRUE
[16:18:40.423] getGlobalsAndPackages() ...
[16:18:40.423] Searching for globals...
[16:18:40.424] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:40.424] Searching for globals ... DONE
[16:18:40.425] Resolving globals: FALSE
[16:18:40.425] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:40.425] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:40.425] - globals: [1] ‘FUN’
[16:18:40.427] 
[16:18:40.427] getGlobalsAndPackages() ... DONE
[16:18:40.427]  - globals found/used: [n=1] ‘FUN’
[16:18:40.427]  - needed namespaces: [n=0] 
[16:18:40.427] Finding globals ... DONE
[16:18:40.428] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.428] List of 2
[16:18:40.428]  $ ...future.FUN:function (C, k)  
[16:18:40.428]  $ MoreArgs     : list()
[16:18:40.428]  - attr(*, "where")=List of 2
[16:18:40.428]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.428]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.428]  - attr(*, "resolved")= logi FALSE
[16:18:40.428]  - attr(*, "total_size")= num NA
[16:18:40.430] Packages to be attached in all futures: [n=0] 
[16:18:40.430] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.431] Number of futures (= number of chunks): 1
[16:18:40.431] Launching 1 futures (chunks) ...
[16:18:40.431] Chunk #1 of 1 ...
[16:18:40.431]  - Finding globals in '...' for chunk #1 ...
[16:18:40.431] getGlobalsAndPackages() ...
[16:18:40.431] Searching for globals...
[16:18:40.432] 
[16:18:40.432] Searching for globals ... DONE
[16:18:40.432] - globals: [0] <none>
[16:18:40.432] getGlobalsAndPackages() ... DONE
[16:18:40.432]    + additional globals found: [n=0] 
[16:18:40.432]    + additional namespaces needed: [n=0] 
[16:18:40.432]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.432]  - seeds: <none>
[16:18:40.432]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.432] getGlobalsAndPackages() ...
[16:18:40.433] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.433] Resolving globals: FALSE
[16:18:40.433] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[16:18:40.434] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:40.434] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.434] 
[16:18:40.434] getGlobalsAndPackages() ... DONE
[16:18:40.434] run() for ‘Future’ ...
[16:18:40.434] - state: ‘created’
[16:18:40.434] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.435] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.435] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.435]   - Field: ‘label’
[16:18:40.435]   - Field: ‘local’
[16:18:40.435]   - Field: ‘owner’
[16:18:40.435]   - Field: ‘envir’
[16:18:40.435]   - Field: ‘packages’
[16:18:40.435]   - Field: ‘gc’
[16:18:40.435]   - Field: ‘conditions’
[16:18:40.436]   - Field: ‘expr’
[16:18:40.436]   - Field: ‘uuid’
[16:18:40.436]   - Field: ‘seed’
[16:18:40.436]   - Field: ‘version’
[16:18:40.436]   - Field: ‘result’
[16:18:40.436]   - Field: ‘asynchronous’
[16:18:40.436]   - Field: ‘calls’
[16:18:40.436]   - Field: ‘globals’
[16:18:40.436]   - Field: ‘stdout’
[16:18:40.436]   - Field: ‘earlySignal’
[16:18:40.436]   - Field: ‘lazy’
[16:18:40.437]   - Field: ‘state’
[16:18:40.437] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.437] - Launch lazy future ...
[16:18:40.437] Packages needed by the future expression (n = 0): <none>
[16:18:40.437] Packages needed by future strategies (n = 0): <none>
[16:18:40.437] {
[16:18:40.437]     {
[16:18:40.437]         {
[16:18:40.437]             ...future.startTime <- base::Sys.time()
[16:18:40.437]             {
[16:18:40.437]                 {
[16:18:40.437]                   {
[16:18:40.437]                     base::local({
[16:18:40.437]                       has_future <- base::requireNamespace("future", 
[16:18:40.437]                         quietly = TRUE)
[16:18:40.437]                       if (has_future) {
[16:18:40.437]                         ns <- base::getNamespace("future")
[16:18:40.437]                         version <- ns[[".package"]][["version"]]
[16:18:40.437]                         if (is.null(version)) 
[16:18:40.437]                           version <- utils::packageVersion("future")
[16:18:40.437]                       }
[16:18:40.437]                       else {
[16:18:40.437]                         version <- NULL
[16:18:40.437]                       }
[16:18:40.437]                       if (!has_future || version < "1.8.0") {
[16:18:40.437]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.437]                           "", base::R.version$version.string), 
[16:18:40.437]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.437]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.437]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.437]                             "release", "version")], collapse = " "), 
[16:18:40.437]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.437]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.437]                           info)
[16:18:40.437]                         info <- base::paste(info, collapse = "; ")
[16:18:40.437]                         if (!has_future) {
[16:18:40.437]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.437]                             info)
[16:18:40.437]                         }
[16:18:40.437]                         else {
[16:18:40.437]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.437]                             info, version)
[16:18:40.437]                         }
[16:18:40.437]                         base::stop(msg)
[16:18:40.437]                       }
[16:18:40.437]                     })
[16:18:40.437]                   }
[16:18:40.437]                   ...future.strategy.old <- future::plan("list")
[16:18:40.437]                   options(future.plan = NULL)
[16:18:40.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.437]                 }
[16:18:40.437]                 ...future.workdir <- getwd()
[16:18:40.437]             }
[16:18:40.437]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.437]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.437]         }
[16:18:40.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.437]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.437]             base::names(...future.oldOptions))
[16:18:40.437]     }
[16:18:40.437]     if (FALSE) {
[16:18:40.437]     }
[16:18:40.437]     else {
[16:18:40.437]         if (TRUE) {
[16:18:40.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.437]                 open = "w")
[16:18:40.437]         }
[16:18:40.437]         else {
[16:18:40.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.437]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.437]         }
[16:18:40.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.437]             base::sink(type = "output", split = FALSE)
[16:18:40.437]             base::close(...future.stdout)
[16:18:40.437]         }, add = TRUE)
[16:18:40.437]     }
[16:18:40.437]     ...future.frame <- base::sys.nframe()
[16:18:40.437]     ...future.conditions <- base::list()
[16:18:40.437]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.437]     if (FALSE) {
[16:18:40.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.437]     }
[16:18:40.437]     ...future.result <- base::tryCatch({
[16:18:40.437]         base::withCallingHandlers({
[16:18:40.437]             ...future.value <- base::withVisible(base::local({
[16:18:40.437]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.437]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.437]                   ...future.globals.maxSize)) {
[16:18:40.437]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.437]                   on.exit(options(oopts), add = TRUE)
[16:18:40.437]                 }
[16:18:40.437]                 {
[16:18:40.437]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.437]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.437]                     USE.NAMES = FALSE)
[16:18:40.437]                   do.call(mapply, args = args)
[16:18:40.437]                 }
[16:18:40.437]             }))
[16:18:40.437]             future::FutureResult(value = ...future.value$value, 
[16:18:40.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.437]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.437]                     ...future.globalenv.names))
[16:18:40.437]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.437]         }, condition = base::local({
[16:18:40.437]             c <- base::c
[16:18:40.437]             inherits <- base::inherits
[16:18:40.437]             invokeRestart <- base::invokeRestart
[16:18:40.437]             length <- base::length
[16:18:40.437]             list <- base::list
[16:18:40.437]             seq.int <- base::seq.int
[16:18:40.437]             signalCondition <- base::signalCondition
[16:18:40.437]             sys.calls <- base::sys.calls
[16:18:40.437]             `[[` <- base::`[[`
[16:18:40.437]             `+` <- base::`+`
[16:18:40.437]             `<<-` <- base::`<<-`
[16:18:40.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.437]                   3L)]
[16:18:40.437]             }
[16:18:40.437]             function(cond) {
[16:18:40.437]                 is_error <- inherits(cond, "error")
[16:18:40.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.437]                   NULL)
[16:18:40.437]                 if (is_error) {
[16:18:40.437]                   sessionInformation <- function() {
[16:18:40.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.437]                       search = base::search(), system = base::Sys.info())
[16:18:40.437]                   }
[16:18:40.437]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.437]                     cond$call), session = sessionInformation(), 
[16:18:40.437]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.437]                   signalCondition(cond)
[16:18:40.437]                 }
[16:18:40.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.437]                 "immediateCondition"))) {
[16:18:40.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.437]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.437]                   if (TRUE && !signal) {
[16:18:40.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.437]                     {
[16:18:40.437]                       inherits <- base::inherits
[16:18:40.437]                       invokeRestart <- base::invokeRestart
[16:18:40.437]                       is.null <- base::is.null
[16:18:40.437]                       muffled <- FALSE
[16:18:40.437]                       if (inherits(cond, "message")) {
[16:18:40.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.437]                         if (muffled) 
[16:18:40.437]                           invokeRestart("muffleMessage")
[16:18:40.437]                       }
[16:18:40.437]                       else if (inherits(cond, "warning")) {
[16:18:40.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.437]                         if (muffled) 
[16:18:40.437]                           invokeRestart("muffleWarning")
[16:18:40.437]                       }
[16:18:40.437]                       else if (inherits(cond, "condition")) {
[16:18:40.437]                         if (!is.null(pattern)) {
[16:18:40.437]                           computeRestarts <- base::computeRestarts
[16:18:40.437]                           grepl <- base::grepl
[16:18:40.437]                           restarts <- computeRestarts(cond)
[16:18:40.437]                           for (restart in restarts) {
[16:18:40.437]                             name <- restart$name
[16:18:40.437]                             if (is.null(name)) 
[16:18:40.437]                               next
[16:18:40.437]                             if (!grepl(pattern, name)) 
[16:18:40.437]                               next
[16:18:40.437]                             invokeRestart(restart)
[16:18:40.437]                             muffled <- TRUE
[16:18:40.437]                             break
[16:18:40.437]                           }
[16:18:40.437]                         }
[16:18:40.437]                       }
[16:18:40.437]                       invisible(muffled)
[16:18:40.437]                     }
[16:18:40.437]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.437]                   }
[16:18:40.437]                 }
[16:18:40.437]                 else {
[16:18:40.437]                   if (TRUE) {
[16:18:40.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.437]                     {
[16:18:40.437]                       inherits <- base::inherits
[16:18:40.437]                       invokeRestart <- base::invokeRestart
[16:18:40.437]                       is.null <- base::is.null
[16:18:40.437]                       muffled <- FALSE
[16:18:40.437]                       if (inherits(cond, "message")) {
[16:18:40.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.437]                         if (muffled) 
[16:18:40.437]                           invokeRestart("muffleMessage")
[16:18:40.437]                       }
[16:18:40.437]                       else if (inherits(cond, "warning")) {
[16:18:40.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.437]                         if (muffled) 
[16:18:40.437]                           invokeRestart("muffleWarning")
[16:18:40.437]                       }
[16:18:40.437]                       else if (inherits(cond, "condition")) {
[16:18:40.437]                         if (!is.null(pattern)) {
[16:18:40.437]                           computeRestarts <- base::computeRestarts
[16:18:40.437]                           grepl <- base::grepl
[16:18:40.437]                           restarts <- computeRestarts(cond)
[16:18:40.437]                           for (restart in restarts) {
[16:18:40.437]                             name <- restart$name
[16:18:40.437]                             if (is.null(name)) 
[16:18:40.437]                               next
[16:18:40.437]                             if (!grepl(pattern, name)) 
[16:18:40.437]                               next
[16:18:40.437]                             invokeRestart(restart)
[16:18:40.437]                             muffled <- TRUE
[16:18:40.437]                             break
[16:18:40.437]                           }
[16:18:40.437]                         }
[16:18:40.437]                       }
[16:18:40.437]                       invisible(muffled)
[16:18:40.437]                     }
[16:18:40.437]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.437]                   }
[16:18:40.437]                 }
[16:18:40.437]             }
[16:18:40.437]         }))
[16:18:40.437]     }, error = function(ex) {
[16:18:40.437]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.437]                 ...future.rng), started = ...future.startTime, 
[16:18:40.437]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.437]             version = "1.8"), class = "FutureResult")
[16:18:40.437]     }, finally = {
[16:18:40.437]         if (!identical(...future.workdir, getwd())) 
[16:18:40.437]             setwd(...future.workdir)
[16:18:40.437]         {
[16:18:40.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.437]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.437]             }
[16:18:40.437]             base::options(...future.oldOptions)
[16:18:40.437]             if (.Platform$OS.type == "windows") {
[16:18:40.437]                 old_names <- names(...future.oldEnvVars)
[16:18:40.437]                 envs <- base::Sys.getenv()
[16:18:40.437]                 names <- names(envs)
[16:18:40.437]                 common <- intersect(names, old_names)
[16:18:40.437]                 added <- setdiff(names, old_names)
[16:18:40.437]                 removed <- setdiff(old_names, names)
[16:18:40.437]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.437]                   envs[common]]
[16:18:40.437]                 NAMES <- toupper(changed)
[16:18:40.437]                 args <- list()
[16:18:40.437]                 for (kk in seq_along(NAMES)) {
[16:18:40.437]                   name <- changed[[kk]]
[16:18:40.437]                   NAME <- NAMES[[kk]]
[16:18:40.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.437]                     next
[16:18:40.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.437]                 }
[16:18:40.437]                 NAMES <- toupper(added)
[16:18:40.437]                 for (kk in seq_along(NAMES)) {
[16:18:40.437]                   name <- added[[kk]]
[16:18:40.437]                   NAME <- NAMES[[kk]]
[16:18:40.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.437]                     next
[16:18:40.437]                   args[[name]] <- ""
[16:18:40.437]                 }
[16:18:40.437]                 NAMES <- toupper(removed)
[16:18:40.437]                 for (kk in seq_along(NAMES)) {
[16:18:40.437]                   name <- removed[[kk]]
[16:18:40.437]                   NAME <- NAMES[[kk]]
[16:18:40.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.437]                     next
[16:18:40.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.437]                 }
[16:18:40.437]                 if (length(args) > 0) 
[16:18:40.437]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.437]             }
[16:18:40.437]             else {
[16:18:40.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.437]             }
[16:18:40.437]             {
[16:18:40.437]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.437]                   0L) {
[16:18:40.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.437]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.437]                   base::options(opts)
[16:18:40.437]                 }
[16:18:40.437]                 {
[16:18:40.437]                   {
[16:18:40.437]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.437]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.437]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.437]                       inherits = FALSE)
[16:18:40.437]                     NULL
[16:18:40.437]                   }
[16:18:40.437]                   options(future.plan = NULL)
[16:18:40.437]                   if (is.na(NA_character_)) 
[16:18:40.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.437]                     .init = FALSE)
[16:18:40.437]                 }
[16:18:40.437]             }
[16:18:40.437]         }
[16:18:40.437]     })
[16:18:40.437]     if (TRUE) {
[16:18:40.437]         base::sink(type = "output", split = FALSE)
[16:18:40.437]         if (TRUE) {
[16:18:40.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.437]         }
[16:18:40.437]         else {
[16:18:40.437]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.437]         }
[16:18:40.437]         base::close(...future.stdout)
[16:18:40.437]         ...future.stdout <- NULL
[16:18:40.437]     }
[16:18:40.437]     ...future.result$conditions <- ...future.conditions
[16:18:40.437]     ...future.result$finished <- base::Sys.time()
[16:18:40.437]     ...future.result
[16:18:40.437] }
[16:18:40.439] assign_globals() ...
[16:18:40.439] List of 5
[16:18:40.439]  $ ...future.FUN            :function (C, k)  
[16:18:40.439]  $ MoreArgs                 : list()
[16:18:40.439]  $ ...future.elements_ii    :List of 2
[16:18:40.439]   ..$ :List of 5
[16:18:40.439]   .. ..$ : chr "A"
[16:18:40.439]   .. ..$ : chr "B"
[16:18:40.439]   .. ..$ : chr "C"
[16:18:40.439]   .. ..$ : chr "D"
[16:18:40.439]   .. ..$ : chr "E"
[16:18:40.439]   ..$ :List of 5
[16:18:40.439]   .. ..$ : int 5
[16:18:40.439]   .. ..$ : int 4
[16:18:40.439]   .. ..$ : int 3
[16:18:40.439]   .. ..$ : int 2
[16:18:40.439]   .. ..$ : int 1
[16:18:40.439]  $ ...future.seeds_ii       : NULL
[16:18:40.439]  $ ...future.globals.maxSize: NULL
[16:18:40.439]  - attr(*, "where")=List of 5
[16:18:40.439]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.439]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.439]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.439]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.439]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.439]  - attr(*, "resolved")= logi FALSE
[16:18:40.439]  - attr(*, "total_size")= num 4160
[16:18:40.439]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.439]  - attr(*, "already-done")= logi TRUE
[16:18:40.446] - reassign environment for ‘...future.FUN’
[16:18:40.446] - copied ‘...future.FUN’ to environment
[16:18:40.446] - copied ‘MoreArgs’ to environment
[16:18:40.446] - copied ‘...future.elements_ii’ to environment
[16:18:40.446] - copied ‘...future.seeds_ii’ to environment
[16:18:40.447] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.447] assign_globals() ... done
[16:18:40.447] plan(): Setting new future strategy stack:
[16:18:40.447] List of future strategies:
[16:18:40.447] 1. sequential:
[16:18:40.447]    - args: function (..., envir = parent.frame())
[16:18:40.447]    - tweaked: FALSE
[16:18:40.447]    - call: NULL
[16:18:40.447] plan(): nbrOfWorkers() = 1
[16:18:40.448] plan(): Setting new future strategy stack:
[16:18:40.448] List of future strategies:
[16:18:40.448] 1. sequential:
[16:18:40.448]    - args: function (..., envir = parent.frame())
[16:18:40.448]    - tweaked: FALSE
[16:18:40.448]    - call: plan(strategy)
[16:18:40.449] plan(): nbrOfWorkers() = 1
[16:18:40.449] SequentialFuture started (and completed)
[16:18:40.449] - Launch lazy future ... done
[16:18:40.449] run() for ‘SequentialFuture’ ... done
[16:18:40.449] Created future:
[16:18:40.449] SequentialFuture:
[16:18:40.449] Label: ‘future_.mapply-1’
[16:18:40.449] Expression:
[16:18:40.449] {
[16:18:40.449]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.449]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.449]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.449]         on.exit(options(oopts), add = TRUE)
[16:18:40.449]     }
[16:18:40.449]     {
[16:18:40.449]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.449]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.449]         do.call(mapply, args = args)
[16:18:40.449]     }
[16:18:40.449] }
[16:18:40.449] Lazy evaluation: FALSE
[16:18:40.449] Asynchronous evaluation: FALSE
[16:18:40.449] Local evaluation: TRUE
[16:18:40.449] Environment: R_GlobalEnv
[16:18:40.449] Capture standard output: TRUE
[16:18:40.449] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.449] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.449] Packages: <none>
[16:18:40.449] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.449] Resolved: TRUE
[16:18:40.449] Value: 560 bytes of class ‘list’
[16:18:40.449] Early signaling: FALSE
[16:18:40.449] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.449] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.452] Chunk #1 of 1 ... DONE
[16:18:40.452] Launching 1 futures (chunks) ... DONE
[16:18:40.452] Resolving 1 futures (chunks) ...
[16:18:40.452] resolve() on list ...
[16:18:40.452]  recursive: 0
[16:18:40.452]  length: 1
[16:18:40.452] 
[16:18:40.452] resolved() for ‘SequentialFuture’ ...
[16:18:40.452] - state: ‘finished’
[16:18:40.453] - run: TRUE
[16:18:40.453] - result: ‘FutureResult’
[16:18:40.453] resolved() for ‘SequentialFuture’ ... done
[16:18:40.453] Future #1
[16:18:40.453] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.453] - nx: 1
[16:18:40.453] - relay: TRUE
[16:18:40.453] - stdout: TRUE
[16:18:40.453] - signal: TRUE
[16:18:40.453] - resignal: FALSE
[16:18:40.454] - force: TRUE
[16:18:40.454] - relayed: [n=1] FALSE
[16:18:40.454] - queued futures: [n=1] FALSE
[16:18:40.454]  - until=1
[16:18:40.454]  - relaying element #1
[16:18:40.454] - relayed: [n=1] TRUE
[16:18:40.454] - queued futures: [n=1] TRUE
[16:18:40.454] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.454]  length: 0 (resolved future 1)
[16:18:40.454] Relaying remaining futures
[16:18:40.455] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.455] - nx: 1
[16:18:40.455] - relay: TRUE
[16:18:40.455] - stdout: TRUE
[16:18:40.455] - signal: TRUE
[16:18:40.455] - resignal: FALSE
[16:18:40.455] - force: TRUE
[16:18:40.455] - relayed: [n=1] TRUE
[16:18:40.455] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.455] - relayed: [n=1] TRUE
[16:18:40.455] - queued futures: [n=1] TRUE
[16:18:40.456] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.456] resolve() on list ... DONE
[16:18:40.456]  - Number of value chunks collected: 1
[16:18:40.456] Resolving 1 futures (chunks) ... DONE
[16:18:40.456] Reducing values from 1 chunks ...
[16:18:40.456]  - Number of values collected after concatenation: 5
[16:18:40.456]  - Number of values expected: 5
[16:18:40.456] Reducing values from 1 chunks ... DONE
[16:18:40.456] future_mapply() ... DONE
[16:18:40.457] future_mapply() ...
[16:18:40.457] Number of chunks: 2
[16:18:40.457] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[16:18:40.457] getGlobalsAndPackagesXApply() ...
[16:18:40.457]  - future.globals: TRUE
[16:18:40.457] getGlobalsAndPackages() ...
[16:18:40.458] Searching for globals...
[16:18:40.459] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:40.459] Searching for globals ... DONE
[16:18:40.459] Resolving globals: FALSE
[16:18:40.459] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:40.460] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:40.460] - globals: [1] ‘FUN’
[16:18:40.460] 
[16:18:40.460] getGlobalsAndPackages() ... DONE
[16:18:40.460]  - globals found/used: [n=1] ‘FUN’
[16:18:40.460]  - needed namespaces: [n=0] 
[16:18:40.460] Finding globals ... DONE
[16:18:40.460] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.461] List of 2
[16:18:40.461]  $ ...future.FUN:function (C, k)  
[16:18:40.461]  $ MoreArgs     : NULL
[16:18:40.461]  - attr(*, "where")=List of 2
[16:18:40.461]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.461]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.461]  - attr(*, "resolved")= logi FALSE
[16:18:40.461]  - attr(*, "total_size")= num NA
[16:18:40.463] Packages to be attached in all futures: [n=0] 
[16:18:40.463] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.463] Number of futures (= number of chunks): 2
[16:18:40.463] Launching 2 futures (chunks) ...
[16:18:40.463] Chunk #1 of 2 ...
[16:18:40.464]  - Finding globals in '...' for chunk #1 ...
[16:18:40.464] getGlobalsAndPackages() ...
[16:18:40.464] Searching for globals...
[16:18:40.464] 
[16:18:40.464] Searching for globals ... DONE
[16:18:40.464] - globals: [0] <none>
[16:18:40.464] getGlobalsAndPackages() ... DONE
[16:18:40.464]    + additional globals found: [n=0] 
[16:18:40.464]    + additional namespaces needed: [n=0] 
[16:18:40.465]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.465]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:40.465]  - seeds: <none>
[16:18:40.465]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.465] getGlobalsAndPackages() ...
[16:18:40.465] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.465] Resolving globals: FALSE
[16:18:40.466] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:40.466] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.466] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.466] 
[16:18:40.466] getGlobalsAndPackages() ... DONE
[16:18:40.467] run() for ‘Future’ ...
[16:18:40.467] - state: ‘created’
[16:18:40.467] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.467] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.467] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.467]   - Field: ‘label’
[16:18:40.468]   - Field: ‘local’
[16:18:40.468]   - Field: ‘owner’
[16:18:40.468]   - Field: ‘envir’
[16:18:40.468]   - Field: ‘packages’
[16:18:40.468]   - Field: ‘gc’
[16:18:40.468]   - Field: ‘conditions’
[16:18:40.468]   - Field: ‘expr’
[16:18:40.468]   - Field: ‘uuid’
[16:18:40.468]   - Field: ‘seed’
[16:18:40.468]   - Field: ‘version’
[16:18:40.469]   - Field: ‘result’
[16:18:40.469]   - Field: ‘asynchronous’
[16:18:40.469]   - Field: ‘calls’
[16:18:40.469]   - Field: ‘globals’
[16:18:40.469]   - Field: ‘stdout’
[16:18:40.469]   - Field: ‘earlySignal’
[16:18:40.469]   - Field: ‘lazy’
[16:18:40.469]   - Field: ‘state’
[16:18:40.469] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.469] - Launch lazy future ...
[16:18:40.470] Packages needed by the future expression (n = 0): <none>
[16:18:40.470] Packages needed by future strategies (n = 0): <none>
[16:18:40.470] {
[16:18:40.470]     {
[16:18:40.470]         {
[16:18:40.470]             ...future.startTime <- base::Sys.time()
[16:18:40.470]             {
[16:18:40.470]                 {
[16:18:40.470]                   {
[16:18:40.470]                     base::local({
[16:18:40.470]                       has_future <- base::requireNamespace("future", 
[16:18:40.470]                         quietly = TRUE)
[16:18:40.470]                       if (has_future) {
[16:18:40.470]                         ns <- base::getNamespace("future")
[16:18:40.470]                         version <- ns[[".package"]][["version"]]
[16:18:40.470]                         if (is.null(version)) 
[16:18:40.470]                           version <- utils::packageVersion("future")
[16:18:40.470]                       }
[16:18:40.470]                       else {
[16:18:40.470]                         version <- NULL
[16:18:40.470]                       }
[16:18:40.470]                       if (!has_future || version < "1.8.0") {
[16:18:40.470]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.470]                           "", base::R.version$version.string), 
[16:18:40.470]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.470]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.470]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.470]                             "release", "version")], collapse = " "), 
[16:18:40.470]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.470]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.470]                           info)
[16:18:40.470]                         info <- base::paste(info, collapse = "; ")
[16:18:40.470]                         if (!has_future) {
[16:18:40.470]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.470]                             info)
[16:18:40.470]                         }
[16:18:40.470]                         else {
[16:18:40.470]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.470]                             info, version)
[16:18:40.470]                         }
[16:18:40.470]                         base::stop(msg)
[16:18:40.470]                       }
[16:18:40.470]                     })
[16:18:40.470]                   }
[16:18:40.470]                   ...future.strategy.old <- future::plan("list")
[16:18:40.470]                   options(future.plan = NULL)
[16:18:40.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.470]                 }
[16:18:40.470]                 ...future.workdir <- getwd()
[16:18:40.470]             }
[16:18:40.470]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.470]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.470]         }
[16:18:40.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.470]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:40.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.470]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.470]             base::names(...future.oldOptions))
[16:18:40.470]     }
[16:18:40.470]     if (FALSE) {
[16:18:40.470]     }
[16:18:40.470]     else {
[16:18:40.470]         if (TRUE) {
[16:18:40.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.470]                 open = "w")
[16:18:40.470]         }
[16:18:40.470]         else {
[16:18:40.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.470]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.470]         }
[16:18:40.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.470]             base::sink(type = "output", split = FALSE)
[16:18:40.470]             base::close(...future.stdout)
[16:18:40.470]         }, add = TRUE)
[16:18:40.470]     }
[16:18:40.470]     ...future.frame <- base::sys.nframe()
[16:18:40.470]     ...future.conditions <- base::list()
[16:18:40.470]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.470]     if (FALSE) {
[16:18:40.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.470]     }
[16:18:40.470]     ...future.result <- base::tryCatch({
[16:18:40.470]         base::withCallingHandlers({
[16:18:40.470]             ...future.value <- base::withVisible(base::local({
[16:18:40.470]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.470]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.470]                   ...future.globals.maxSize)) {
[16:18:40.470]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.470]                   on.exit(options(oopts), add = TRUE)
[16:18:40.470]                 }
[16:18:40.470]                 {
[16:18:40.470]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.470]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.470]                     USE.NAMES = FALSE)
[16:18:40.470]                   do.call(mapply, args = args)
[16:18:40.470]                 }
[16:18:40.470]             }))
[16:18:40.470]             future::FutureResult(value = ...future.value$value, 
[16:18:40.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.470]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.470]                     ...future.globalenv.names))
[16:18:40.470]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.470]         }, condition = base::local({
[16:18:40.470]             c <- base::c
[16:18:40.470]             inherits <- base::inherits
[16:18:40.470]             invokeRestart <- base::invokeRestart
[16:18:40.470]             length <- base::length
[16:18:40.470]             list <- base::list
[16:18:40.470]             seq.int <- base::seq.int
[16:18:40.470]             signalCondition <- base::signalCondition
[16:18:40.470]             sys.calls <- base::sys.calls
[16:18:40.470]             `[[` <- base::`[[`
[16:18:40.470]             `+` <- base::`+`
[16:18:40.470]             `<<-` <- base::`<<-`
[16:18:40.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.470]                   3L)]
[16:18:40.470]             }
[16:18:40.470]             function(cond) {
[16:18:40.470]                 is_error <- inherits(cond, "error")
[16:18:40.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.470]                   NULL)
[16:18:40.470]                 if (is_error) {
[16:18:40.470]                   sessionInformation <- function() {
[16:18:40.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.470]                       search = base::search(), system = base::Sys.info())
[16:18:40.470]                   }
[16:18:40.470]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.470]                     cond$call), session = sessionInformation(), 
[16:18:40.470]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.470]                   signalCondition(cond)
[16:18:40.470]                 }
[16:18:40.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.470]                 "immediateCondition"))) {
[16:18:40.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.470]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.470]                   if (TRUE && !signal) {
[16:18:40.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.470]                     {
[16:18:40.470]                       inherits <- base::inherits
[16:18:40.470]                       invokeRestart <- base::invokeRestart
[16:18:40.470]                       is.null <- base::is.null
[16:18:40.470]                       muffled <- FALSE
[16:18:40.470]                       if (inherits(cond, "message")) {
[16:18:40.470]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.470]                         if (muffled) 
[16:18:40.470]                           invokeRestart("muffleMessage")
[16:18:40.470]                       }
[16:18:40.470]                       else if (inherits(cond, "warning")) {
[16:18:40.470]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.470]                         if (muffled) 
[16:18:40.470]                           invokeRestart("muffleWarning")
[16:18:40.470]                       }
[16:18:40.470]                       else if (inherits(cond, "condition")) {
[16:18:40.470]                         if (!is.null(pattern)) {
[16:18:40.470]                           computeRestarts <- base::computeRestarts
[16:18:40.470]                           grepl <- base::grepl
[16:18:40.470]                           restarts <- computeRestarts(cond)
[16:18:40.470]                           for (restart in restarts) {
[16:18:40.470]                             name <- restart$name
[16:18:40.470]                             if (is.null(name)) 
[16:18:40.470]                               next
[16:18:40.470]                             if (!grepl(pattern, name)) 
[16:18:40.470]                               next
[16:18:40.470]                             invokeRestart(restart)
[16:18:40.470]                             muffled <- TRUE
[16:18:40.470]                             break
[16:18:40.470]                           }
[16:18:40.470]                         }
[16:18:40.470]                       }
[16:18:40.470]                       invisible(muffled)
[16:18:40.470]                     }
[16:18:40.470]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.470]                   }
[16:18:40.470]                 }
[16:18:40.470]                 else {
[16:18:40.470]                   if (TRUE) {
[16:18:40.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.470]                     {
[16:18:40.470]                       inherits <- base::inherits
[16:18:40.470]                       invokeRestart <- base::invokeRestart
[16:18:40.470]                       is.null <- base::is.null
[16:18:40.470]                       muffled <- FALSE
[16:18:40.470]                       if (inherits(cond, "message")) {
[16:18:40.470]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.470]                         if (muffled) 
[16:18:40.470]                           invokeRestart("muffleMessage")
[16:18:40.470]                       }
[16:18:40.470]                       else if (inherits(cond, "warning")) {
[16:18:40.470]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.470]                         if (muffled) 
[16:18:40.470]                           invokeRestart("muffleWarning")
[16:18:40.470]                       }
[16:18:40.470]                       else if (inherits(cond, "condition")) {
[16:18:40.470]                         if (!is.null(pattern)) {
[16:18:40.470]                           computeRestarts <- base::computeRestarts
[16:18:40.470]                           grepl <- base::grepl
[16:18:40.470]                           restarts <- computeRestarts(cond)
[16:18:40.470]                           for (restart in restarts) {
[16:18:40.470]                             name <- restart$name
[16:18:40.470]                             if (is.null(name)) 
[16:18:40.470]                               next
[16:18:40.470]                             if (!grepl(pattern, name)) 
[16:18:40.470]                               next
[16:18:40.470]                             invokeRestart(restart)
[16:18:40.470]                             muffled <- TRUE
[16:18:40.470]                             break
[16:18:40.470]                           }
[16:18:40.470]                         }
[16:18:40.470]                       }
[16:18:40.470]                       invisible(muffled)
[16:18:40.470]                     }
[16:18:40.470]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.470]                   }
[16:18:40.470]                 }
[16:18:40.470]             }
[16:18:40.470]         }))
[16:18:40.470]     }, error = function(ex) {
[16:18:40.470]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.470]                 ...future.rng), started = ...future.startTime, 
[16:18:40.470]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.470]             version = "1.8"), class = "FutureResult")
[16:18:40.470]     }, finally = {
[16:18:40.470]         if (!identical(...future.workdir, getwd())) 
[16:18:40.470]             setwd(...future.workdir)
[16:18:40.470]         {
[16:18:40.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.470]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.470]             }
[16:18:40.470]             base::options(...future.oldOptions)
[16:18:40.470]             if (.Platform$OS.type == "windows") {
[16:18:40.470]                 old_names <- names(...future.oldEnvVars)
[16:18:40.470]                 envs <- base::Sys.getenv()
[16:18:40.470]                 names <- names(envs)
[16:18:40.470]                 common <- intersect(names, old_names)
[16:18:40.470]                 added <- setdiff(names, old_names)
[16:18:40.470]                 removed <- setdiff(old_names, names)
[16:18:40.470]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.470]                   envs[common]]
[16:18:40.470]                 NAMES <- toupper(changed)
[16:18:40.470]                 args <- list()
[16:18:40.470]                 for (kk in seq_along(NAMES)) {
[16:18:40.470]                   name <- changed[[kk]]
[16:18:40.470]                   NAME <- NAMES[[kk]]
[16:18:40.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.470]                     next
[16:18:40.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.470]                 }
[16:18:40.470]                 NAMES <- toupper(added)
[16:18:40.470]                 for (kk in seq_along(NAMES)) {
[16:18:40.470]                   name <- added[[kk]]
[16:18:40.470]                   NAME <- NAMES[[kk]]
[16:18:40.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.470]                     next
[16:18:40.470]                   args[[name]] <- ""
[16:18:40.470]                 }
[16:18:40.470]                 NAMES <- toupper(removed)
[16:18:40.470]                 for (kk in seq_along(NAMES)) {
[16:18:40.470]                   name <- removed[[kk]]
[16:18:40.470]                   NAME <- NAMES[[kk]]
[16:18:40.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.470]                     next
[16:18:40.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.470]                 }
[16:18:40.470]                 if (length(args) > 0) 
[16:18:40.470]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.470]             }
[16:18:40.470]             else {
[16:18:40.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.470]             }
[16:18:40.470]             {
[16:18:40.470]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.470]                   0L) {
[16:18:40.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.470]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.470]                   base::options(opts)
[16:18:40.470]                 }
[16:18:40.470]                 {
[16:18:40.470]                   {
[16:18:40.470]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.470]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.470]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.470]                       inherits = FALSE)
[16:18:40.470]                     NULL
[16:18:40.470]                   }
[16:18:40.470]                   options(future.plan = NULL)
[16:18:40.470]                   if (is.na(NA_character_)) 
[16:18:40.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.470]                     .init = FALSE)
[16:18:40.470]                 }
[16:18:40.470]             }
[16:18:40.470]         }
[16:18:40.470]     })
[16:18:40.470]     if (TRUE) {
[16:18:40.470]         base::sink(type = "output", split = FALSE)
[16:18:40.470]         if (TRUE) {
[16:18:40.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.470]         }
[16:18:40.470]         else {
[16:18:40.470]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.470]         }
[16:18:40.470]         base::close(...future.stdout)
[16:18:40.470]         ...future.stdout <- NULL
[16:18:40.470]     }
[16:18:40.470]     ...future.result$conditions <- ...future.conditions
[16:18:40.470]     ...future.result$finished <- base::Sys.time()
[16:18:40.470]     ...future.result
[16:18:40.470] }
[16:18:40.472] assign_globals() ...
[16:18:40.472] List of 5
[16:18:40.472]  $ ...future.FUN            :function (C, k)  
[16:18:40.472]  $ MoreArgs                 : NULL
[16:18:40.472]  $ ...future.elements_ii    :List of 2
[16:18:40.472]   ..$ :List of 2
[16:18:40.472]   .. ..$ : chr "E"
[16:18:40.472]   .. ..$ : chr "D"
[16:18:40.472]   ..$ :List of 2
[16:18:40.472]   .. ..$ : int 1
[16:18:40.472]   .. ..$ : int 2
[16:18:40.472]  $ ...future.seeds_ii       : NULL
[16:18:40.472]  $ ...future.globals.maxSize: NULL
[16:18:40.472]  - attr(*, "where")=List of 5
[16:18:40.472]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.472]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.472]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.472]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.472]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.472]  - attr(*, "resolved")= logi FALSE
[16:18:40.472]  - attr(*, "total_size")= num 3656
[16:18:40.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.472]  - attr(*, "already-done")= logi TRUE
[16:18:40.479] - reassign environment for ‘...future.FUN’
[16:18:40.480] - copied ‘...future.FUN’ to environment
[16:18:40.480] - copied ‘MoreArgs’ to environment
[16:18:40.480] - copied ‘...future.elements_ii’ to environment
[16:18:40.480] - copied ‘...future.seeds_ii’ to environment
[16:18:40.480] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.480] assign_globals() ... done
[16:18:40.480] plan(): Setting new future strategy stack:
[16:18:40.480] List of future strategies:
[16:18:40.480] 1. sequential:
[16:18:40.480]    - args: function (..., envir = parent.frame())
[16:18:40.480]    - tweaked: FALSE
[16:18:40.480]    - call: NULL
[16:18:40.481] plan(): nbrOfWorkers() = 1
[16:18:40.482] plan(): Setting new future strategy stack:
[16:18:40.482] List of future strategies:
[16:18:40.482] 1. sequential:
[16:18:40.482]    - args: function (..., envir = parent.frame())
[16:18:40.482]    - tweaked: FALSE
[16:18:40.482]    - call: plan(strategy)
[16:18:40.482] plan(): nbrOfWorkers() = 1
[16:18:40.482] SequentialFuture started (and completed)
[16:18:40.482] - Launch lazy future ... done
[16:18:40.482] run() for ‘SequentialFuture’ ... done
[16:18:40.483] Created future:
[16:18:40.483] SequentialFuture:
[16:18:40.483] Label: ‘future_mapply-1’
[16:18:40.483] Expression:
[16:18:40.483] {
[16:18:40.483]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.483]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.483]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.483]         on.exit(options(oopts), add = TRUE)
[16:18:40.483]     }
[16:18:40.483]     {
[16:18:40.483]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.483]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.483]         do.call(mapply, args = args)
[16:18:40.483]     }
[16:18:40.483] }
[16:18:40.483] Lazy evaluation: FALSE
[16:18:40.483] Asynchronous evaluation: FALSE
[16:18:40.483] Local evaluation: TRUE
[16:18:40.483] Environment: R_GlobalEnv
[16:18:40.483] Capture standard output: TRUE
[16:18:40.483] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.483] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.483] Packages: <none>
[16:18:40.483] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.483] Resolved: TRUE
[16:18:40.483] Value: 224 bytes of class ‘list’
[16:18:40.483] Early signaling: FALSE
[16:18:40.483] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.483] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.483] Chunk #1 of 2 ... DONE
[16:18:40.484] Chunk #2 of 2 ...
[16:18:40.484]  - Finding globals in '...' for chunk #2 ...
[16:18:40.484] getGlobalsAndPackages() ...
[16:18:40.484] Searching for globals...
[16:18:40.484] 
[16:18:40.484] Searching for globals ... DONE
[16:18:40.484] - globals: [0] <none>
[16:18:40.485] getGlobalsAndPackages() ... DONE
[16:18:40.485]    + additional globals found: [n=0] 
[16:18:40.485]    + additional namespaces needed: [n=0] 
[16:18:40.485]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:40.485]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:40.485]  - seeds: <none>
[16:18:40.485]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.485] getGlobalsAndPackages() ...
[16:18:40.485] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.485] Resolving globals: FALSE
[16:18:40.486] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[16:18:40.486] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.486] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.487] 
[16:18:40.487] getGlobalsAndPackages() ... DONE
[16:18:40.487] run() for ‘Future’ ...
[16:18:40.487] - state: ‘created’
[16:18:40.487] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.487] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.488] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.488]   - Field: ‘label’
[16:18:40.488]   - Field: ‘local’
[16:18:40.488]   - Field: ‘owner’
[16:18:40.488]   - Field: ‘envir’
[16:18:40.488]   - Field: ‘packages’
[16:18:40.488]   - Field: ‘gc’
[16:18:40.488]   - Field: ‘conditions’
[16:18:40.488]   - Field: ‘expr’
[16:18:40.488]   - Field: ‘uuid’
[16:18:40.489]   - Field: ‘seed’
[16:18:40.489]   - Field: ‘version’
[16:18:40.489]   - Field: ‘result’
[16:18:40.489]   - Field: ‘asynchronous’
[16:18:40.489]   - Field: ‘calls’
[16:18:40.489]   - Field: ‘globals’
[16:18:40.489]   - Field: ‘stdout’
[16:18:40.489]   - Field: ‘earlySignal’
[16:18:40.489]   - Field: ‘lazy’
[16:18:40.489]   - Field: ‘state’
[16:18:40.489] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.490] - Launch lazy future ...
[16:18:40.490] Packages needed by the future expression (n = 0): <none>
[16:18:40.490] Packages needed by future strategies (n = 0): <none>
[16:18:40.490] {
[16:18:40.490]     {
[16:18:40.490]         {
[16:18:40.490]             ...future.startTime <- base::Sys.time()
[16:18:40.490]             {
[16:18:40.490]                 {
[16:18:40.490]                   {
[16:18:40.490]                     base::local({
[16:18:40.490]                       has_future <- base::requireNamespace("future", 
[16:18:40.490]                         quietly = TRUE)
[16:18:40.490]                       if (has_future) {
[16:18:40.490]                         ns <- base::getNamespace("future")
[16:18:40.490]                         version <- ns[[".package"]][["version"]]
[16:18:40.490]                         if (is.null(version)) 
[16:18:40.490]                           version <- utils::packageVersion("future")
[16:18:40.490]                       }
[16:18:40.490]                       else {
[16:18:40.490]                         version <- NULL
[16:18:40.490]                       }
[16:18:40.490]                       if (!has_future || version < "1.8.0") {
[16:18:40.490]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.490]                           "", base::R.version$version.string), 
[16:18:40.490]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.490]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.490]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.490]                             "release", "version")], collapse = " "), 
[16:18:40.490]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.490]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.490]                           info)
[16:18:40.490]                         info <- base::paste(info, collapse = "; ")
[16:18:40.490]                         if (!has_future) {
[16:18:40.490]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.490]                             info)
[16:18:40.490]                         }
[16:18:40.490]                         else {
[16:18:40.490]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.490]                             info, version)
[16:18:40.490]                         }
[16:18:40.490]                         base::stop(msg)
[16:18:40.490]                       }
[16:18:40.490]                     })
[16:18:40.490]                   }
[16:18:40.490]                   ...future.strategy.old <- future::plan("list")
[16:18:40.490]                   options(future.plan = NULL)
[16:18:40.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.490]                 }
[16:18:40.490]                 ...future.workdir <- getwd()
[16:18:40.490]             }
[16:18:40.490]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.490]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.490]         }
[16:18:40.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.490]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:40.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.490]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.490]             base::names(...future.oldOptions))
[16:18:40.490]     }
[16:18:40.490]     if (FALSE) {
[16:18:40.490]     }
[16:18:40.490]     else {
[16:18:40.490]         if (TRUE) {
[16:18:40.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.490]                 open = "w")
[16:18:40.490]         }
[16:18:40.490]         else {
[16:18:40.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.490]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.490]         }
[16:18:40.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.490]             base::sink(type = "output", split = FALSE)
[16:18:40.490]             base::close(...future.stdout)
[16:18:40.490]         }, add = TRUE)
[16:18:40.490]     }
[16:18:40.490]     ...future.frame <- base::sys.nframe()
[16:18:40.490]     ...future.conditions <- base::list()
[16:18:40.490]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.490]     if (FALSE) {
[16:18:40.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.490]     }
[16:18:40.490]     ...future.result <- base::tryCatch({
[16:18:40.490]         base::withCallingHandlers({
[16:18:40.490]             ...future.value <- base::withVisible(base::local({
[16:18:40.490]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.490]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.490]                   ...future.globals.maxSize)) {
[16:18:40.490]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.490]                   on.exit(options(oopts), add = TRUE)
[16:18:40.490]                 }
[16:18:40.490]                 {
[16:18:40.490]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.490]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.490]                     USE.NAMES = FALSE)
[16:18:40.490]                   do.call(mapply, args = args)
[16:18:40.490]                 }
[16:18:40.490]             }))
[16:18:40.490]             future::FutureResult(value = ...future.value$value, 
[16:18:40.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.490]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.490]                     ...future.globalenv.names))
[16:18:40.490]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.490]         }, condition = base::local({
[16:18:40.490]             c <- base::c
[16:18:40.490]             inherits <- base::inherits
[16:18:40.490]             invokeRestart <- base::invokeRestart
[16:18:40.490]             length <- base::length
[16:18:40.490]             list <- base::list
[16:18:40.490]             seq.int <- base::seq.int
[16:18:40.490]             signalCondition <- base::signalCondition
[16:18:40.490]             sys.calls <- base::sys.calls
[16:18:40.490]             `[[` <- base::`[[`
[16:18:40.490]             `+` <- base::`+`
[16:18:40.490]             `<<-` <- base::`<<-`
[16:18:40.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.490]                   3L)]
[16:18:40.490]             }
[16:18:40.490]             function(cond) {
[16:18:40.490]                 is_error <- inherits(cond, "error")
[16:18:40.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.490]                   NULL)
[16:18:40.490]                 if (is_error) {
[16:18:40.490]                   sessionInformation <- function() {
[16:18:40.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.490]                       search = base::search(), system = base::Sys.info())
[16:18:40.490]                   }
[16:18:40.490]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.490]                     cond$call), session = sessionInformation(), 
[16:18:40.490]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.490]                   signalCondition(cond)
[16:18:40.490]                 }
[16:18:40.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.490]                 "immediateCondition"))) {
[16:18:40.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.490]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.490]                   if (TRUE && !signal) {
[16:18:40.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.490]                     {
[16:18:40.490]                       inherits <- base::inherits
[16:18:40.490]                       invokeRestart <- base::invokeRestart
[16:18:40.490]                       is.null <- base::is.null
[16:18:40.490]                       muffled <- FALSE
[16:18:40.490]                       if (inherits(cond, "message")) {
[16:18:40.490]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.490]                         if (muffled) 
[16:18:40.490]                           invokeRestart("muffleMessage")
[16:18:40.490]                       }
[16:18:40.490]                       else if (inherits(cond, "warning")) {
[16:18:40.490]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.490]                         if (muffled) 
[16:18:40.490]                           invokeRestart("muffleWarning")
[16:18:40.490]                       }
[16:18:40.490]                       else if (inherits(cond, "condition")) {
[16:18:40.490]                         if (!is.null(pattern)) {
[16:18:40.490]                           computeRestarts <- base::computeRestarts
[16:18:40.490]                           grepl <- base::grepl
[16:18:40.490]                           restarts <- computeRestarts(cond)
[16:18:40.490]                           for (restart in restarts) {
[16:18:40.490]                             name <- restart$name
[16:18:40.490]                             if (is.null(name)) 
[16:18:40.490]                               next
[16:18:40.490]                             if (!grepl(pattern, name)) 
[16:18:40.490]                               next
[16:18:40.490]                             invokeRestart(restart)
[16:18:40.490]                             muffled <- TRUE
[16:18:40.490]                             break
[16:18:40.490]                           }
[16:18:40.490]                         }
[16:18:40.490]                       }
[16:18:40.490]                       invisible(muffled)
[16:18:40.490]                     }
[16:18:40.490]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.490]                   }
[16:18:40.490]                 }
[16:18:40.490]                 else {
[16:18:40.490]                   if (TRUE) {
[16:18:40.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.490]                     {
[16:18:40.490]                       inherits <- base::inherits
[16:18:40.490]                       invokeRestart <- base::invokeRestart
[16:18:40.490]                       is.null <- base::is.null
[16:18:40.490]                       muffled <- FALSE
[16:18:40.490]                       if (inherits(cond, "message")) {
[16:18:40.490]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.490]                         if (muffled) 
[16:18:40.490]                           invokeRestart("muffleMessage")
[16:18:40.490]                       }
[16:18:40.490]                       else if (inherits(cond, "warning")) {
[16:18:40.490]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.490]                         if (muffled) 
[16:18:40.490]                           invokeRestart("muffleWarning")
[16:18:40.490]                       }
[16:18:40.490]                       else if (inherits(cond, "condition")) {
[16:18:40.490]                         if (!is.null(pattern)) {
[16:18:40.490]                           computeRestarts <- base::computeRestarts
[16:18:40.490]                           grepl <- base::grepl
[16:18:40.490]                           restarts <- computeRestarts(cond)
[16:18:40.490]                           for (restart in restarts) {
[16:18:40.490]                             name <- restart$name
[16:18:40.490]                             if (is.null(name)) 
[16:18:40.490]                               next
[16:18:40.490]                             if (!grepl(pattern, name)) 
[16:18:40.490]                               next
[16:18:40.490]                             invokeRestart(restart)
[16:18:40.490]                             muffled <- TRUE
[16:18:40.490]                             break
[16:18:40.490]                           }
[16:18:40.490]                         }
[16:18:40.490]                       }
[16:18:40.490]                       invisible(muffled)
[16:18:40.490]                     }
[16:18:40.490]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.490]                   }
[16:18:40.490]                 }
[16:18:40.490]             }
[16:18:40.490]         }))
[16:18:40.490]     }, error = function(ex) {
[16:18:40.490]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.490]                 ...future.rng), started = ...future.startTime, 
[16:18:40.490]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.490]             version = "1.8"), class = "FutureResult")
[16:18:40.490]     }, finally = {
[16:18:40.490]         if (!identical(...future.workdir, getwd())) 
[16:18:40.490]             setwd(...future.workdir)
[16:18:40.490]         {
[16:18:40.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.490]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.490]             }
[16:18:40.490]             base::options(...future.oldOptions)
[16:18:40.490]             if (.Platform$OS.type == "windows") {
[16:18:40.490]                 old_names <- names(...future.oldEnvVars)
[16:18:40.490]                 envs <- base::Sys.getenv()
[16:18:40.490]                 names <- names(envs)
[16:18:40.490]                 common <- intersect(names, old_names)
[16:18:40.490]                 added <- setdiff(names, old_names)
[16:18:40.490]                 removed <- setdiff(old_names, names)
[16:18:40.490]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.490]                   envs[common]]
[16:18:40.490]                 NAMES <- toupper(changed)
[16:18:40.490]                 args <- list()
[16:18:40.490]                 for (kk in seq_along(NAMES)) {
[16:18:40.490]                   name <- changed[[kk]]
[16:18:40.490]                   NAME <- NAMES[[kk]]
[16:18:40.490]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.490]                     next
[16:18:40.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.490]                 }
[16:18:40.490]                 NAMES <- toupper(added)
[16:18:40.490]                 for (kk in seq_along(NAMES)) {
[16:18:40.490]                   name <- added[[kk]]
[16:18:40.490]                   NAME <- NAMES[[kk]]
[16:18:40.490]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.490]                     next
[16:18:40.490]                   args[[name]] <- ""
[16:18:40.490]                 }
[16:18:40.490]                 NAMES <- toupper(removed)
[16:18:40.490]                 for (kk in seq_along(NAMES)) {
[16:18:40.490]                   name <- removed[[kk]]
[16:18:40.490]                   NAME <- NAMES[[kk]]
[16:18:40.490]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.490]                     next
[16:18:40.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.490]                 }
[16:18:40.490]                 if (length(args) > 0) 
[16:18:40.490]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.490]             }
[16:18:40.490]             else {
[16:18:40.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.490]             }
[16:18:40.490]             {
[16:18:40.490]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.490]                   0L) {
[16:18:40.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.490]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.490]                   base::options(opts)
[16:18:40.490]                 }
[16:18:40.490]                 {
[16:18:40.490]                   {
[16:18:40.490]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.490]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.490]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.490]                       inherits = FALSE)
[16:18:40.490]                     NULL
[16:18:40.490]                   }
[16:18:40.490]                   options(future.plan = NULL)
[16:18:40.490]                   if (is.na(NA_character_)) 
[16:18:40.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.490]                     .init = FALSE)
[16:18:40.490]                 }
[16:18:40.490]             }
[16:18:40.490]         }
[16:18:40.490]     })
[16:18:40.490]     if (TRUE) {
[16:18:40.490]         base::sink(type = "output", split = FALSE)
[16:18:40.490]         if (TRUE) {
[16:18:40.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.490]         }
[16:18:40.490]         else {
[16:18:40.490]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.490]         }
[16:18:40.490]         base::close(...future.stdout)
[16:18:40.490]         ...future.stdout <- NULL
[16:18:40.490]     }
[16:18:40.490]     ...future.result$conditions <- ...future.conditions
[16:18:40.490]     ...future.result$finished <- base::Sys.time()
[16:18:40.490]     ...future.result
[16:18:40.490] }
[16:18:40.492] assign_globals() ...
[16:18:40.492] List of 5
[16:18:40.492]  $ ...future.FUN            :function (C, k)  
[16:18:40.492]  $ MoreArgs                 : NULL
[16:18:40.492]  $ ...future.elements_ii    :List of 2
[16:18:40.492]   ..$ :List of 3
[16:18:40.492]   .. ..$ : chr "C"
[16:18:40.492]   .. ..$ : chr "B"
[16:18:40.492]   .. ..$ : chr "A"
[16:18:40.492]   ..$ :List of 3
[16:18:40.492]   .. ..$ : int 3
[16:18:40.492]   .. ..$ : int 4
[16:18:40.492]   .. ..$ : int 5
[16:18:40.492]  $ ...future.seeds_ii       : NULL
[16:18:40.492]  $ ...future.globals.maxSize: NULL
[16:18:40.492]  - attr(*, "where")=List of 5
[16:18:40.492]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.492]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.492]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.492]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.492]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.492]  - attr(*, "resolved")= logi FALSE
[16:18:40.492]  - attr(*, "total_size")= num 3824
[16:18:40.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.492]  - attr(*, "already-done")= logi TRUE
[16:18:40.498] - reassign environment for ‘...future.FUN’
[16:18:40.498] - copied ‘...future.FUN’ to environment
[16:18:40.498] - copied ‘MoreArgs’ to environment
[16:18:40.498] - copied ‘...future.elements_ii’ to environment
[16:18:40.498] - copied ‘...future.seeds_ii’ to environment
[16:18:40.498] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.499] assign_globals() ... done
[16:18:40.501] plan(): Setting new future strategy stack:
[16:18:40.501] List of future strategies:
[16:18:40.501] 1. sequential:
[16:18:40.501]    - args: function (..., envir = parent.frame())
[16:18:40.501]    - tweaked: FALSE
[16:18:40.501]    - call: NULL
[16:18:40.501] plan(): nbrOfWorkers() = 1
[16:18:40.502] plan(): Setting new future strategy stack:
[16:18:40.502] List of future strategies:
[16:18:40.502] 1. sequential:
[16:18:40.502]    - args: function (..., envir = parent.frame())
[16:18:40.502]    - tweaked: FALSE
[16:18:40.502]    - call: plan(strategy)
[16:18:40.502] plan(): nbrOfWorkers() = 1
[16:18:40.503] SequentialFuture started (and completed)
[16:18:40.503] - Launch lazy future ... done
[16:18:40.503] run() for ‘SequentialFuture’ ... done
[16:18:40.503] Created future:
[16:18:40.503] SequentialFuture:
[16:18:40.503] Label: ‘future_mapply-2’
[16:18:40.503] Expression:
[16:18:40.503] {
[16:18:40.503]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.503]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.503]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.503]         on.exit(options(oopts), add = TRUE)
[16:18:40.503]     }
[16:18:40.503]     {
[16:18:40.503]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.503]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.503]         do.call(mapply, args = args)
[16:18:40.503]     }
[16:18:40.503] }
[16:18:40.503] Lazy evaluation: FALSE
[16:18:40.503] Asynchronous evaluation: FALSE
[16:18:40.503] Local evaluation: TRUE
[16:18:40.503] Environment: R_GlobalEnv
[16:18:40.503] Capture standard output: TRUE
[16:18:40.503] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.503] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.503] Packages: <none>
[16:18:40.503] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.503] Resolved: TRUE
[16:18:40.503] Value: 336 bytes of class ‘list’
[16:18:40.503] Early signaling: FALSE
[16:18:40.503] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.503] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.504] Chunk #2 of 2 ... DONE
[16:18:40.504] Launching 2 futures (chunks) ... DONE
[16:18:40.505] Resolving 2 futures (chunks) ...
[16:18:40.505] resolve() on list ...
[16:18:40.505]  recursive: 0
[16:18:40.505]  length: 2
[16:18:40.505] 
[16:18:40.505] resolved() for ‘SequentialFuture’ ...
[16:18:40.505] - state: ‘finished’
[16:18:40.505] - run: TRUE
[16:18:40.505] - result: ‘FutureResult’
[16:18:40.505] resolved() for ‘SequentialFuture’ ... done
[16:18:40.506] Future #1
[16:18:40.506] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.506] - nx: 2
[16:18:40.506] - relay: TRUE
[16:18:40.506] - stdout: TRUE
[16:18:40.506] - signal: TRUE
[16:18:40.506] - resignal: FALSE
[16:18:40.506] - force: TRUE
[16:18:40.506] - relayed: [n=2] FALSE, FALSE
[16:18:40.506] - queued futures: [n=2] FALSE, FALSE
[16:18:40.507]  - until=1
[16:18:40.507]  - relaying element #1
[16:18:40.507] - relayed: [n=2] TRUE, FALSE
[16:18:40.507] - queued futures: [n=2] TRUE, FALSE
[16:18:40.507] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.507]  length: 1 (resolved future 1)
[16:18:40.507] resolved() for ‘SequentialFuture’ ...
[16:18:40.507] - state: ‘finished’
[16:18:40.507] - run: TRUE
[16:18:40.508] - result: ‘FutureResult’
[16:18:40.508] resolved() for ‘SequentialFuture’ ... done
[16:18:40.508] Future #2
[16:18:40.508] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:18:40.508] - nx: 2
[16:18:40.508] - relay: TRUE
[16:18:40.508] - stdout: TRUE
[16:18:40.508] - signal: TRUE
[16:18:40.508] - resignal: FALSE
[16:18:40.508] - force: TRUE
[16:18:40.508] - relayed: [n=2] TRUE, FALSE
[16:18:40.509] - queued futures: [n=2] TRUE, FALSE
[16:18:40.509]  - until=2
[16:18:40.509]  - relaying element #2
[16:18:40.509] - relayed: [n=2] TRUE, TRUE
[16:18:40.509] - queued futures: [n=2] TRUE, TRUE
[16:18:40.509] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:18:40.509]  length: 0 (resolved future 2)
[16:18:40.509] Relaying remaining futures
[16:18:40.509] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.510] - nx: 2
[16:18:40.510] - relay: TRUE
[16:18:40.510] - stdout: TRUE
[16:18:40.510] - signal: TRUE
[16:18:40.510] - resignal: FALSE
[16:18:40.510] - force: TRUE
[16:18:40.510] - relayed: [n=2] TRUE, TRUE
[16:18:40.510] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:40.510] - relayed: [n=2] TRUE, TRUE
[16:18:40.510] - queued futures: [n=2] TRUE, TRUE
[16:18:40.510] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.511] resolve() on list ... DONE
[16:18:40.511]  - Number of value chunks collected: 2
[16:18:40.511] Resolving 2 futures (chunks) ... DONE
[16:18:40.511] Reducing values from 2 chunks ...
[16:18:40.511]  - Number of values collected after concatenation: 5
[16:18:40.511]  - Number of values expected: 5
[16:18:40.511] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[16:18:40.511] Reducing values from 2 chunks ... DONE
[16:18:40.512] future_mapply() ... DONE
[16:18:40.512] future_mapply() ...
[16:18:40.512] Number of chunks: 1
[16:18:40.512] getGlobalsAndPackagesXApply() ...
[16:18:40.512]  - future.globals: TRUE
[16:18:40.512] getGlobalsAndPackages() ...
[16:18:40.512] Searching for globals...
[16:18:40.514] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:40.514] Searching for globals ... DONE
[16:18:40.514] Resolving globals: FALSE
[16:18:40.514] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:40.515] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:40.515] - globals: [1] ‘FUN’
[16:18:40.515] 
[16:18:40.515] getGlobalsAndPackages() ... DONE
[16:18:40.515]  - globals found/used: [n=1] ‘FUN’
[16:18:40.515]  - needed namespaces: [n=0] 
[16:18:40.515] Finding globals ... DONE
[16:18:40.516] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.516] List of 2
[16:18:40.516]  $ ...future.FUN:function (C, k)  
[16:18:40.516]  $ MoreArgs     : list()
[16:18:40.516]  - attr(*, "where")=List of 2
[16:18:40.516]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.516]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.516]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.516]  - attr(*, "resolved")= logi FALSE
[16:18:40.516]  - attr(*, "total_size")= num NA
[16:18:40.518] Packages to be attached in all futures: [n=0] 
[16:18:40.519] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.519] Number of futures (= number of chunks): 1
[16:18:40.519] Launching 1 futures (chunks) ...
[16:18:40.519] Chunk #1 of 1 ...
[16:18:40.519]  - Finding globals in '...' for chunk #1 ...
[16:18:40.519] getGlobalsAndPackages() ...
[16:18:40.519] Searching for globals...
[16:18:40.520] 
[16:18:40.520] Searching for globals ... DONE
[16:18:40.520] - globals: [0] <none>
[16:18:40.520] getGlobalsAndPackages() ... DONE
[16:18:40.520]    + additional globals found: [n=0] 
[16:18:40.520]    + additional namespaces needed: [n=0] 
[16:18:40.520]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.520]  - seeds: <none>
[16:18:40.520]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.521] getGlobalsAndPackages() ...
[16:18:40.521] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.521] Resolving globals: FALSE
[16:18:40.521] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[16:18:40.522] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:40.522] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.522] 
[16:18:40.522] getGlobalsAndPackages() ... DONE
[16:18:40.522] run() for ‘Future’ ...
[16:18:40.522] - state: ‘created’
[16:18:40.523] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.523] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.523] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.523]   - Field: ‘label’
[16:18:40.523]   - Field: ‘local’
[16:18:40.523]   - Field: ‘owner’
[16:18:40.523]   - Field: ‘envir’
[16:18:40.524]   - Field: ‘packages’
[16:18:40.524]   - Field: ‘gc’
[16:18:40.524]   - Field: ‘conditions’
[16:18:40.526]   - Field: ‘expr’
[16:18:40.526]   - Field: ‘uuid’
[16:18:40.526]   - Field: ‘seed’
[16:18:40.526]   - Field: ‘version’
[16:18:40.526]   - Field: ‘result’
[16:18:40.526]   - Field: ‘asynchronous’
[16:18:40.527]   - Field: ‘calls’
[16:18:40.527]   - Field: ‘globals’
[16:18:40.527]   - Field: ‘stdout’
[16:18:40.527]   - Field: ‘earlySignal’
[16:18:40.527]   - Field: ‘lazy’
[16:18:40.527]   - Field: ‘state’
[16:18:40.527] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.527] - Launch lazy future ...
[16:18:40.528] Packages needed by the future expression (n = 0): <none>
[16:18:40.528] Packages needed by future strategies (n = 0): <none>
[16:18:40.528] {
[16:18:40.528]     {
[16:18:40.528]         {
[16:18:40.528]             ...future.startTime <- base::Sys.time()
[16:18:40.528]             {
[16:18:40.528]                 {
[16:18:40.528]                   {
[16:18:40.528]                     base::local({
[16:18:40.528]                       has_future <- base::requireNamespace("future", 
[16:18:40.528]                         quietly = TRUE)
[16:18:40.528]                       if (has_future) {
[16:18:40.528]                         ns <- base::getNamespace("future")
[16:18:40.528]                         version <- ns[[".package"]][["version"]]
[16:18:40.528]                         if (is.null(version)) 
[16:18:40.528]                           version <- utils::packageVersion("future")
[16:18:40.528]                       }
[16:18:40.528]                       else {
[16:18:40.528]                         version <- NULL
[16:18:40.528]                       }
[16:18:40.528]                       if (!has_future || version < "1.8.0") {
[16:18:40.528]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.528]                           "", base::R.version$version.string), 
[16:18:40.528]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.528]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.528]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.528]                             "release", "version")], collapse = " "), 
[16:18:40.528]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.528]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.528]                           info)
[16:18:40.528]                         info <- base::paste(info, collapse = "; ")
[16:18:40.528]                         if (!has_future) {
[16:18:40.528]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.528]                             info)
[16:18:40.528]                         }
[16:18:40.528]                         else {
[16:18:40.528]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.528]                             info, version)
[16:18:40.528]                         }
[16:18:40.528]                         base::stop(msg)
[16:18:40.528]                       }
[16:18:40.528]                     })
[16:18:40.528]                   }
[16:18:40.528]                   ...future.strategy.old <- future::plan("list")
[16:18:40.528]                   options(future.plan = NULL)
[16:18:40.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.528]                 }
[16:18:40.528]                 ...future.workdir <- getwd()
[16:18:40.528]             }
[16:18:40.528]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.528]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.528]         }
[16:18:40.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.528]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.528]             base::names(...future.oldOptions))
[16:18:40.528]     }
[16:18:40.528]     if (FALSE) {
[16:18:40.528]     }
[16:18:40.528]     else {
[16:18:40.528]         if (TRUE) {
[16:18:40.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.528]                 open = "w")
[16:18:40.528]         }
[16:18:40.528]         else {
[16:18:40.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.528]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.528]         }
[16:18:40.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.528]             base::sink(type = "output", split = FALSE)
[16:18:40.528]             base::close(...future.stdout)
[16:18:40.528]         }, add = TRUE)
[16:18:40.528]     }
[16:18:40.528]     ...future.frame <- base::sys.nframe()
[16:18:40.528]     ...future.conditions <- base::list()
[16:18:40.528]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.528]     if (FALSE) {
[16:18:40.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.528]     }
[16:18:40.528]     ...future.result <- base::tryCatch({
[16:18:40.528]         base::withCallingHandlers({
[16:18:40.528]             ...future.value <- base::withVisible(base::local({
[16:18:40.528]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.528]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.528]                   ...future.globals.maxSize)) {
[16:18:40.528]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.528]                   on.exit(options(oopts), add = TRUE)
[16:18:40.528]                 }
[16:18:40.528]                 {
[16:18:40.528]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.528]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.528]                     USE.NAMES = FALSE)
[16:18:40.528]                   do.call(mapply, args = args)
[16:18:40.528]                 }
[16:18:40.528]             }))
[16:18:40.528]             future::FutureResult(value = ...future.value$value, 
[16:18:40.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.528]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.528]                     ...future.globalenv.names))
[16:18:40.528]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.528]         }, condition = base::local({
[16:18:40.528]             c <- base::c
[16:18:40.528]             inherits <- base::inherits
[16:18:40.528]             invokeRestart <- base::invokeRestart
[16:18:40.528]             length <- base::length
[16:18:40.528]             list <- base::list
[16:18:40.528]             seq.int <- base::seq.int
[16:18:40.528]             signalCondition <- base::signalCondition
[16:18:40.528]             sys.calls <- base::sys.calls
[16:18:40.528]             `[[` <- base::`[[`
[16:18:40.528]             `+` <- base::`+`
[16:18:40.528]             `<<-` <- base::`<<-`
[16:18:40.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.528]                   3L)]
[16:18:40.528]             }
[16:18:40.528]             function(cond) {
[16:18:40.528]                 is_error <- inherits(cond, "error")
[16:18:40.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.528]                   NULL)
[16:18:40.528]                 if (is_error) {
[16:18:40.528]                   sessionInformation <- function() {
[16:18:40.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.528]                       search = base::search(), system = base::Sys.info())
[16:18:40.528]                   }
[16:18:40.528]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.528]                     cond$call), session = sessionInformation(), 
[16:18:40.528]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.528]                   signalCondition(cond)
[16:18:40.528]                 }
[16:18:40.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.528]                 "immediateCondition"))) {
[16:18:40.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.528]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.528]                   if (TRUE && !signal) {
[16:18:40.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.528]                     {
[16:18:40.528]                       inherits <- base::inherits
[16:18:40.528]                       invokeRestart <- base::invokeRestart
[16:18:40.528]                       is.null <- base::is.null
[16:18:40.528]                       muffled <- FALSE
[16:18:40.528]                       if (inherits(cond, "message")) {
[16:18:40.528]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.528]                         if (muffled) 
[16:18:40.528]                           invokeRestart("muffleMessage")
[16:18:40.528]                       }
[16:18:40.528]                       else if (inherits(cond, "warning")) {
[16:18:40.528]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.528]                         if (muffled) 
[16:18:40.528]                           invokeRestart("muffleWarning")
[16:18:40.528]                       }
[16:18:40.528]                       else if (inherits(cond, "condition")) {
[16:18:40.528]                         if (!is.null(pattern)) {
[16:18:40.528]                           computeRestarts <- base::computeRestarts
[16:18:40.528]                           grepl <- base::grepl
[16:18:40.528]                           restarts <- computeRestarts(cond)
[16:18:40.528]                           for (restart in restarts) {
[16:18:40.528]                             name <- restart$name
[16:18:40.528]                             if (is.null(name)) 
[16:18:40.528]                               next
[16:18:40.528]                             if (!grepl(pattern, name)) 
[16:18:40.528]                               next
[16:18:40.528]                             invokeRestart(restart)
[16:18:40.528]                             muffled <- TRUE
[16:18:40.528]                             break
[16:18:40.528]                           }
[16:18:40.528]                         }
[16:18:40.528]                       }
[16:18:40.528]                       invisible(muffled)
[16:18:40.528]                     }
[16:18:40.528]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.528]                   }
[16:18:40.528]                 }
[16:18:40.528]                 else {
[16:18:40.528]                   if (TRUE) {
[16:18:40.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.528]                     {
[16:18:40.528]                       inherits <- base::inherits
[16:18:40.528]                       invokeRestart <- base::invokeRestart
[16:18:40.528]                       is.null <- base::is.null
[16:18:40.528]                       muffled <- FALSE
[16:18:40.528]                       if (inherits(cond, "message")) {
[16:18:40.528]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.528]                         if (muffled) 
[16:18:40.528]                           invokeRestart("muffleMessage")
[16:18:40.528]                       }
[16:18:40.528]                       else if (inherits(cond, "warning")) {
[16:18:40.528]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.528]                         if (muffled) 
[16:18:40.528]                           invokeRestart("muffleWarning")
[16:18:40.528]                       }
[16:18:40.528]                       else if (inherits(cond, "condition")) {
[16:18:40.528]                         if (!is.null(pattern)) {
[16:18:40.528]                           computeRestarts <- base::computeRestarts
[16:18:40.528]                           grepl <- base::grepl
[16:18:40.528]                           restarts <- computeRestarts(cond)
[16:18:40.528]                           for (restart in restarts) {
[16:18:40.528]                             name <- restart$name
[16:18:40.528]                             if (is.null(name)) 
[16:18:40.528]                               next
[16:18:40.528]                             if (!grepl(pattern, name)) 
[16:18:40.528]                               next
[16:18:40.528]                             invokeRestart(restart)
[16:18:40.528]                             muffled <- TRUE
[16:18:40.528]                             break
[16:18:40.528]                           }
[16:18:40.528]                         }
[16:18:40.528]                       }
[16:18:40.528]                       invisible(muffled)
[16:18:40.528]                     }
[16:18:40.528]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.528]                   }
[16:18:40.528]                 }
[16:18:40.528]             }
[16:18:40.528]         }))
[16:18:40.528]     }, error = function(ex) {
[16:18:40.528]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.528]                 ...future.rng), started = ...future.startTime, 
[16:18:40.528]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.528]             version = "1.8"), class = "FutureResult")
[16:18:40.528]     }, finally = {
[16:18:40.528]         if (!identical(...future.workdir, getwd())) 
[16:18:40.528]             setwd(...future.workdir)
[16:18:40.528]         {
[16:18:40.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.528]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.528]             }
[16:18:40.528]             base::options(...future.oldOptions)
[16:18:40.528]             if (.Platform$OS.type == "windows") {
[16:18:40.528]                 old_names <- names(...future.oldEnvVars)
[16:18:40.528]                 envs <- base::Sys.getenv()
[16:18:40.528]                 names <- names(envs)
[16:18:40.528]                 common <- intersect(names, old_names)
[16:18:40.528]                 added <- setdiff(names, old_names)
[16:18:40.528]                 removed <- setdiff(old_names, names)
[16:18:40.528]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.528]                   envs[common]]
[16:18:40.528]                 NAMES <- toupper(changed)
[16:18:40.528]                 args <- list()
[16:18:40.528]                 for (kk in seq_along(NAMES)) {
[16:18:40.528]                   name <- changed[[kk]]
[16:18:40.528]                   NAME <- NAMES[[kk]]
[16:18:40.528]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.528]                     next
[16:18:40.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.528]                 }
[16:18:40.528]                 NAMES <- toupper(added)
[16:18:40.528]                 for (kk in seq_along(NAMES)) {
[16:18:40.528]                   name <- added[[kk]]
[16:18:40.528]                   NAME <- NAMES[[kk]]
[16:18:40.528]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.528]                     next
[16:18:40.528]                   args[[name]] <- ""
[16:18:40.528]                 }
[16:18:40.528]                 NAMES <- toupper(removed)
[16:18:40.528]                 for (kk in seq_along(NAMES)) {
[16:18:40.528]                   name <- removed[[kk]]
[16:18:40.528]                   NAME <- NAMES[[kk]]
[16:18:40.528]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.528]                     next
[16:18:40.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.528]                 }
[16:18:40.528]                 if (length(args) > 0) 
[16:18:40.528]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.528]             }
[16:18:40.528]             else {
[16:18:40.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.528]             }
[16:18:40.528]             {
[16:18:40.528]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.528]                   0L) {
[16:18:40.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.528]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.528]                   base::options(opts)
[16:18:40.528]                 }
[16:18:40.528]                 {
[16:18:40.528]                   {
[16:18:40.528]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.528]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.528]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.528]                       inherits = FALSE)
[16:18:40.528]                     NULL
[16:18:40.528]                   }
[16:18:40.528]                   options(future.plan = NULL)
[16:18:40.528]                   if (is.na(NA_character_)) 
[16:18:40.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.528]                     .init = FALSE)
[16:18:40.528]                 }
[16:18:40.528]             }
[16:18:40.528]         }
[16:18:40.528]     })
[16:18:40.528]     if (TRUE) {
[16:18:40.528]         base::sink(type = "output", split = FALSE)
[16:18:40.528]         if (TRUE) {
[16:18:40.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.528]         }
[16:18:40.528]         else {
[16:18:40.528]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.528]         }
[16:18:40.528]         base::close(...future.stdout)
[16:18:40.528]         ...future.stdout <- NULL
[16:18:40.528]     }
[16:18:40.528]     ...future.result$conditions <- ...future.conditions
[16:18:40.528]     ...future.result$finished <- base::Sys.time()
[16:18:40.528]     ...future.result
[16:18:40.528] }
[16:18:40.530] assign_globals() ...
[16:18:40.530] List of 5
[16:18:40.530]  $ ...future.FUN            :function (C, k)  
[16:18:40.530]  $ MoreArgs                 : list()
[16:18:40.530]  $ ...future.elements_ii    :List of 2
[16:18:40.530]   ..$ :List of 5
[16:18:40.530]   .. ..$ : chr "A"
[16:18:40.530]   .. ..$ : chr "B"
[16:18:40.530]   .. ..$ : chr "C"
[16:18:40.530]   .. ..$ : chr "D"
[16:18:40.530]   .. ..$ : chr "E"
[16:18:40.530]   ..$ :List of 5
[16:18:40.530]   .. ..$ : int 5
[16:18:40.530]   .. ..$ : int 4
[16:18:40.530]   .. ..$ : int 3
[16:18:40.530]   .. ..$ : int 2
[16:18:40.530]   .. ..$ : int 1
[16:18:40.530]  $ ...future.seeds_ii       : NULL
[16:18:40.530]  $ ...future.globals.maxSize: NULL
[16:18:40.530]  - attr(*, "where")=List of 5
[16:18:40.530]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.530]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.530]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.530]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.530]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.530]  - attr(*, "resolved")= logi FALSE
[16:18:40.530]  - attr(*, "total_size")= num 4160
[16:18:40.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.530]  - attr(*, "already-done")= logi TRUE
[16:18:40.537] - reassign environment for ‘...future.FUN’
[16:18:40.537] - copied ‘...future.FUN’ to environment
[16:18:40.537] - copied ‘MoreArgs’ to environment
[16:18:40.538] - copied ‘...future.elements_ii’ to environment
[16:18:40.538] - copied ‘...future.seeds_ii’ to environment
[16:18:40.538] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.538] assign_globals() ... done
[16:18:40.538] plan(): Setting new future strategy stack:
[16:18:40.538] List of future strategies:
[16:18:40.538] 1. sequential:
[16:18:40.538]    - args: function (..., envir = parent.frame())
[16:18:40.538]    - tweaked: FALSE
[16:18:40.538]    - call: NULL
[16:18:40.539] plan(): nbrOfWorkers() = 1
[16:18:40.539] plan(): Setting new future strategy stack:
[16:18:40.539] List of future strategies:
[16:18:40.539] 1. sequential:
[16:18:40.539]    - args: function (..., envir = parent.frame())
[16:18:40.539]    - tweaked: FALSE
[16:18:40.539]    - call: plan(strategy)
[16:18:40.540] plan(): nbrOfWorkers() = 1
[16:18:40.540] SequentialFuture started (and completed)
[16:18:40.540] - Launch lazy future ... done
[16:18:40.540] run() for ‘SequentialFuture’ ... done
[16:18:40.540] Created future:
[16:18:40.540] SequentialFuture:
[16:18:40.540] Label: ‘future_.mapply-1’
[16:18:40.540] Expression:
[16:18:40.540] {
[16:18:40.540]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.540]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.540]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.540]         on.exit(options(oopts), add = TRUE)
[16:18:40.540]     }
[16:18:40.540]     {
[16:18:40.540]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.540]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.540]         do.call(mapply, args = args)
[16:18:40.540]     }
[16:18:40.540] }
[16:18:40.540] Lazy evaluation: FALSE
[16:18:40.540] Asynchronous evaluation: FALSE
[16:18:40.540] Local evaluation: TRUE
[16:18:40.540] Environment: R_GlobalEnv
[16:18:40.540] Capture standard output: TRUE
[16:18:40.540] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.540] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.540] Packages: <none>
[16:18:40.540] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.540] Resolved: TRUE
[16:18:40.540] Value: 560 bytes of class ‘list’
[16:18:40.540] Early signaling: FALSE
[16:18:40.540] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.540] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.541] Chunk #1 of 1 ... DONE
[16:18:40.541] Launching 1 futures (chunks) ... DONE
[16:18:40.542] Resolving 1 futures (chunks) ...
[16:18:40.542] resolve() on list ...
[16:18:40.542]  recursive: 0
[16:18:40.542]  length: 1
[16:18:40.542] 
[16:18:40.542] resolved() for ‘SequentialFuture’ ...
[16:18:40.542] - state: ‘finished’
[16:18:40.542] - run: TRUE
[16:18:40.542] - result: ‘FutureResult’
[16:18:40.542] resolved() for ‘SequentialFuture’ ... done
[16:18:40.542] Future #1
[16:18:40.543] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.543] - nx: 1
[16:18:40.543] - relay: TRUE
[16:18:40.543] - stdout: TRUE
[16:18:40.543] - signal: TRUE
[16:18:40.543] - resignal: FALSE
[16:18:40.543] - force: TRUE
[16:18:40.543] - relayed: [n=1] FALSE
[16:18:40.543] - queued futures: [n=1] FALSE
[16:18:40.543]  - until=1
[16:18:40.543]  - relaying element #1
[16:18:40.544] - relayed: [n=1] TRUE
[16:18:40.544] - queued futures: [n=1] TRUE
[16:18:40.544] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.544]  length: 0 (resolved future 1)
[16:18:40.544] Relaying remaining futures
[16:18:40.544] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.544] - nx: 1
[16:18:40.544] - relay: TRUE
[16:18:40.544] - stdout: TRUE
[16:18:40.545] - signal: TRUE
[16:18:40.545] - resignal: FALSE
[16:18:40.545] - force: TRUE
[16:18:40.545] - relayed: [n=1] TRUE
[16:18:40.545] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.545] - relayed: [n=1] TRUE
[16:18:40.545] - queued futures: [n=1] TRUE
[16:18:40.545] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.545] resolve() on list ... DONE
[16:18:40.545]  - Number of value chunks collected: 1
[16:18:40.545] Resolving 1 futures (chunks) ... DONE
[16:18:40.546] Reducing values from 1 chunks ...
[16:18:40.546]  - Number of values collected after concatenation: 5
[16:18:40.546]  - Number of values expected: 5
[16:18:40.546] Reducing values from 1 chunks ... DONE
[16:18:40.546] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[16:18:40.547] future_mapply() ...
[16:18:40.547] Number of chunks: 1
[16:18:40.547] getGlobalsAndPackagesXApply() ...
[16:18:40.547]  - future.globals: TRUE
[16:18:40.547] getGlobalsAndPackages() ...
[16:18:40.547] Searching for globals...
[16:18:40.548] - globals found: [1] ‘FUN’
[16:18:40.548] Searching for globals ... DONE
[16:18:40.548] Resolving globals: FALSE
[16:18:40.549] The total size of the 1 globals is 848 bytes (848 bytes)
[16:18:40.551] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:18:40.551] - globals: [1] ‘FUN’
[16:18:40.551] 
[16:18:40.551] getGlobalsAndPackages() ... DONE
[16:18:40.551]  - globals found/used: [n=1] ‘FUN’
[16:18:40.551]  - needed namespaces: [n=0] 
[16:18:40.551] Finding globals ... DONE
[16:18:40.552] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.552] List of 2
[16:18:40.552]  $ ...future.FUN:function (x)  
[16:18:40.552]  $ MoreArgs     : NULL
[16:18:40.552]  - attr(*, "where")=List of 2
[16:18:40.552]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.552]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.552]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.552]  - attr(*, "resolved")= logi FALSE
[16:18:40.552]  - attr(*, "total_size")= num NA
[16:18:40.554] Packages to be attached in all futures: [n=0] 
[16:18:40.554] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.555] Number of futures (= number of chunks): 1
[16:18:40.555] Launching 1 futures (chunks) ...
[16:18:40.555] Chunk #1 of 1 ...
[16:18:40.555]  - Finding globals in '...' for chunk #1 ...
[16:18:40.555] getGlobalsAndPackages() ...
[16:18:40.555] Searching for globals...
[16:18:40.556] 
[16:18:40.556] Searching for globals ... DONE
[16:18:40.556] - globals: [0] <none>
[16:18:40.556] getGlobalsAndPackages() ... DONE
[16:18:40.556]    + additional globals found: [n=0] 
[16:18:40.556]    + additional namespaces needed: [n=0] 
[16:18:40.556]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.556]  - seeds: <none>
[16:18:40.556]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.556] getGlobalsAndPackages() ...
[16:18:40.557] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.557] Resolving globals: FALSE
[16:18:40.557] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[16:18:40.557] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.558] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.558] 
[16:18:40.558] getGlobalsAndPackages() ... DONE
[16:18:40.558] run() for ‘Future’ ...
[16:18:40.558] - state: ‘created’
[16:18:40.558] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.559] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.559]   - Field: ‘label’
[16:18:40.559]   - Field: ‘local’
[16:18:40.559]   - Field: ‘owner’
[16:18:40.559]   - Field: ‘envir’
[16:18:40.559]   - Field: ‘packages’
[16:18:40.559]   - Field: ‘gc’
[16:18:40.559]   - Field: ‘conditions’
[16:18:40.559]   - Field: ‘expr’
[16:18:40.560]   - Field: ‘uuid’
[16:18:40.560]   - Field: ‘seed’
[16:18:40.560]   - Field: ‘version’
[16:18:40.560]   - Field: ‘result’
[16:18:40.560]   - Field: ‘asynchronous’
[16:18:40.560]   - Field: ‘calls’
[16:18:40.560]   - Field: ‘globals’
[16:18:40.560]   - Field: ‘stdout’
[16:18:40.560]   - Field: ‘earlySignal’
[16:18:40.560]   - Field: ‘lazy’
[16:18:40.560]   - Field: ‘state’
[16:18:40.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.561] - Launch lazy future ...
[16:18:40.561] Packages needed by the future expression (n = 0): <none>
[16:18:40.561] Packages needed by future strategies (n = 0): <none>
[16:18:40.561] {
[16:18:40.561]     {
[16:18:40.561]         {
[16:18:40.561]             ...future.startTime <- base::Sys.time()
[16:18:40.561]             {
[16:18:40.561]                 {
[16:18:40.561]                   {
[16:18:40.561]                     base::local({
[16:18:40.561]                       has_future <- base::requireNamespace("future", 
[16:18:40.561]                         quietly = TRUE)
[16:18:40.561]                       if (has_future) {
[16:18:40.561]                         ns <- base::getNamespace("future")
[16:18:40.561]                         version <- ns[[".package"]][["version"]]
[16:18:40.561]                         if (is.null(version)) 
[16:18:40.561]                           version <- utils::packageVersion("future")
[16:18:40.561]                       }
[16:18:40.561]                       else {
[16:18:40.561]                         version <- NULL
[16:18:40.561]                       }
[16:18:40.561]                       if (!has_future || version < "1.8.0") {
[16:18:40.561]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.561]                           "", base::R.version$version.string), 
[16:18:40.561]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.561]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.561]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.561]                             "release", "version")], collapse = " "), 
[16:18:40.561]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.561]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.561]                           info)
[16:18:40.561]                         info <- base::paste(info, collapse = "; ")
[16:18:40.561]                         if (!has_future) {
[16:18:40.561]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.561]                             info)
[16:18:40.561]                         }
[16:18:40.561]                         else {
[16:18:40.561]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.561]                             info, version)
[16:18:40.561]                         }
[16:18:40.561]                         base::stop(msg)
[16:18:40.561]                       }
[16:18:40.561]                     })
[16:18:40.561]                   }
[16:18:40.561]                   ...future.strategy.old <- future::plan("list")
[16:18:40.561]                   options(future.plan = NULL)
[16:18:40.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.561]                 }
[16:18:40.561]                 ...future.workdir <- getwd()
[16:18:40.561]             }
[16:18:40.561]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.561]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.561]         }
[16:18:40.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.561]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.561]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.561]             base::names(...future.oldOptions))
[16:18:40.561]     }
[16:18:40.561]     if (FALSE) {
[16:18:40.561]     }
[16:18:40.561]     else {
[16:18:40.561]         if (TRUE) {
[16:18:40.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.561]                 open = "w")
[16:18:40.561]         }
[16:18:40.561]         else {
[16:18:40.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.561]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.561]         }
[16:18:40.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.561]             base::sink(type = "output", split = FALSE)
[16:18:40.561]             base::close(...future.stdout)
[16:18:40.561]         }, add = TRUE)
[16:18:40.561]     }
[16:18:40.561]     ...future.frame <- base::sys.nframe()
[16:18:40.561]     ...future.conditions <- base::list()
[16:18:40.561]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.561]     if (FALSE) {
[16:18:40.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.561]     }
[16:18:40.561]     ...future.result <- base::tryCatch({
[16:18:40.561]         base::withCallingHandlers({
[16:18:40.561]             ...future.value <- base::withVisible(base::local({
[16:18:40.561]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.561]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.561]                   ...future.globals.maxSize)) {
[16:18:40.561]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.561]                   on.exit(options(oopts), add = TRUE)
[16:18:40.561]                 }
[16:18:40.561]                 {
[16:18:40.561]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.561]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.561]                     USE.NAMES = FALSE)
[16:18:40.561]                   do.call(mapply, args = args)
[16:18:40.561]                 }
[16:18:40.561]             }))
[16:18:40.561]             future::FutureResult(value = ...future.value$value, 
[16:18:40.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.561]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.561]                     ...future.globalenv.names))
[16:18:40.561]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.561]         }, condition = base::local({
[16:18:40.561]             c <- base::c
[16:18:40.561]             inherits <- base::inherits
[16:18:40.561]             invokeRestart <- base::invokeRestart
[16:18:40.561]             length <- base::length
[16:18:40.561]             list <- base::list
[16:18:40.561]             seq.int <- base::seq.int
[16:18:40.561]             signalCondition <- base::signalCondition
[16:18:40.561]             sys.calls <- base::sys.calls
[16:18:40.561]             `[[` <- base::`[[`
[16:18:40.561]             `+` <- base::`+`
[16:18:40.561]             `<<-` <- base::`<<-`
[16:18:40.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.561]                   3L)]
[16:18:40.561]             }
[16:18:40.561]             function(cond) {
[16:18:40.561]                 is_error <- inherits(cond, "error")
[16:18:40.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.561]                   NULL)
[16:18:40.561]                 if (is_error) {
[16:18:40.561]                   sessionInformation <- function() {
[16:18:40.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.561]                       search = base::search(), system = base::Sys.info())
[16:18:40.561]                   }
[16:18:40.561]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.561]                     cond$call), session = sessionInformation(), 
[16:18:40.561]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.561]                   signalCondition(cond)
[16:18:40.561]                 }
[16:18:40.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.561]                 "immediateCondition"))) {
[16:18:40.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.561]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.561]                   if (TRUE && !signal) {
[16:18:40.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.561]                     {
[16:18:40.561]                       inherits <- base::inherits
[16:18:40.561]                       invokeRestart <- base::invokeRestart
[16:18:40.561]                       is.null <- base::is.null
[16:18:40.561]                       muffled <- FALSE
[16:18:40.561]                       if (inherits(cond, "message")) {
[16:18:40.561]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.561]                         if (muffled) 
[16:18:40.561]                           invokeRestart("muffleMessage")
[16:18:40.561]                       }
[16:18:40.561]                       else if (inherits(cond, "warning")) {
[16:18:40.561]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.561]                         if (muffled) 
[16:18:40.561]                           invokeRestart("muffleWarning")
[16:18:40.561]                       }
[16:18:40.561]                       else if (inherits(cond, "condition")) {
[16:18:40.561]                         if (!is.null(pattern)) {
[16:18:40.561]                           computeRestarts <- base::computeRestarts
[16:18:40.561]                           grepl <- base::grepl
[16:18:40.561]                           restarts <- computeRestarts(cond)
[16:18:40.561]                           for (restart in restarts) {
[16:18:40.561]                             name <- restart$name
[16:18:40.561]                             if (is.null(name)) 
[16:18:40.561]                               next
[16:18:40.561]                             if (!grepl(pattern, name)) 
[16:18:40.561]                               next
[16:18:40.561]                             invokeRestart(restart)
[16:18:40.561]                             muffled <- TRUE
[16:18:40.561]                             break
[16:18:40.561]                           }
[16:18:40.561]                         }
[16:18:40.561]                       }
[16:18:40.561]                       invisible(muffled)
[16:18:40.561]                     }
[16:18:40.561]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.561]                   }
[16:18:40.561]                 }
[16:18:40.561]                 else {
[16:18:40.561]                   if (TRUE) {
[16:18:40.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.561]                     {
[16:18:40.561]                       inherits <- base::inherits
[16:18:40.561]                       invokeRestart <- base::invokeRestart
[16:18:40.561]                       is.null <- base::is.null
[16:18:40.561]                       muffled <- FALSE
[16:18:40.561]                       if (inherits(cond, "message")) {
[16:18:40.561]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.561]                         if (muffled) 
[16:18:40.561]                           invokeRestart("muffleMessage")
[16:18:40.561]                       }
[16:18:40.561]                       else if (inherits(cond, "warning")) {
[16:18:40.561]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.561]                         if (muffled) 
[16:18:40.561]                           invokeRestart("muffleWarning")
[16:18:40.561]                       }
[16:18:40.561]                       else if (inherits(cond, "condition")) {
[16:18:40.561]                         if (!is.null(pattern)) {
[16:18:40.561]                           computeRestarts <- base::computeRestarts
[16:18:40.561]                           grepl <- base::grepl
[16:18:40.561]                           restarts <- computeRestarts(cond)
[16:18:40.561]                           for (restart in restarts) {
[16:18:40.561]                             name <- restart$name
[16:18:40.561]                             if (is.null(name)) 
[16:18:40.561]                               next
[16:18:40.561]                             if (!grepl(pattern, name)) 
[16:18:40.561]                               next
[16:18:40.561]                             invokeRestart(restart)
[16:18:40.561]                             muffled <- TRUE
[16:18:40.561]                             break
[16:18:40.561]                           }
[16:18:40.561]                         }
[16:18:40.561]                       }
[16:18:40.561]                       invisible(muffled)
[16:18:40.561]                     }
[16:18:40.561]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.561]                   }
[16:18:40.561]                 }
[16:18:40.561]             }
[16:18:40.561]         }))
[16:18:40.561]     }, error = function(ex) {
[16:18:40.561]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.561]                 ...future.rng), started = ...future.startTime, 
[16:18:40.561]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.561]             version = "1.8"), class = "FutureResult")
[16:18:40.561]     }, finally = {
[16:18:40.561]         if (!identical(...future.workdir, getwd())) 
[16:18:40.561]             setwd(...future.workdir)
[16:18:40.561]         {
[16:18:40.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.561]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.561]             }
[16:18:40.561]             base::options(...future.oldOptions)
[16:18:40.561]             if (.Platform$OS.type == "windows") {
[16:18:40.561]                 old_names <- names(...future.oldEnvVars)
[16:18:40.561]                 envs <- base::Sys.getenv()
[16:18:40.561]                 names <- names(envs)
[16:18:40.561]                 common <- intersect(names, old_names)
[16:18:40.561]                 added <- setdiff(names, old_names)
[16:18:40.561]                 removed <- setdiff(old_names, names)
[16:18:40.561]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.561]                   envs[common]]
[16:18:40.561]                 NAMES <- toupper(changed)
[16:18:40.561]                 args <- list()
[16:18:40.561]                 for (kk in seq_along(NAMES)) {
[16:18:40.561]                   name <- changed[[kk]]
[16:18:40.561]                   NAME <- NAMES[[kk]]
[16:18:40.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.561]                     next
[16:18:40.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.561]                 }
[16:18:40.561]                 NAMES <- toupper(added)
[16:18:40.561]                 for (kk in seq_along(NAMES)) {
[16:18:40.561]                   name <- added[[kk]]
[16:18:40.561]                   NAME <- NAMES[[kk]]
[16:18:40.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.561]                     next
[16:18:40.561]                   args[[name]] <- ""
[16:18:40.561]                 }
[16:18:40.561]                 NAMES <- toupper(removed)
[16:18:40.561]                 for (kk in seq_along(NAMES)) {
[16:18:40.561]                   name <- removed[[kk]]
[16:18:40.561]                   NAME <- NAMES[[kk]]
[16:18:40.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.561]                     next
[16:18:40.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.561]                 }
[16:18:40.561]                 if (length(args) > 0) 
[16:18:40.561]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.561]             }
[16:18:40.561]             else {
[16:18:40.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.561]             }
[16:18:40.561]             {
[16:18:40.561]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.561]                   0L) {
[16:18:40.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.561]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.561]                   base::options(opts)
[16:18:40.561]                 }
[16:18:40.561]                 {
[16:18:40.561]                   {
[16:18:40.561]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.561]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.561]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.561]                       inherits = FALSE)
[16:18:40.561]                     NULL
[16:18:40.561]                   }
[16:18:40.561]                   options(future.plan = NULL)
[16:18:40.561]                   if (is.na(NA_character_)) 
[16:18:40.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.561]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.561]                     .init = FALSE)
[16:18:40.561]                 }
[16:18:40.561]             }
[16:18:40.561]         }
[16:18:40.561]     })
[16:18:40.561]     if (TRUE) {
[16:18:40.561]         base::sink(type = "output", split = FALSE)
[16:18:40.561]         if (TRUE) {
[16:18:40.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.561]         }
[16:18:40.561]         else {
[16:18:40.561]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.561]         }
[16:18:40.561]         base::close(...future.stdout)
[16:18:40.561]         ...future.stdout <- NULL
[16:18:40.561]     }
[16:18:40.561]     ...future.result$conditions <- ...future.conditions
[16:18:40.561]     ...future.result$finished <- base::Sys.time()
[16:18:40.561]     ...future.result
[16:18:40.561] }
[16:18:40.563] assign_globals() ...
[16:18:40.563] List of 5
[16:18:40.563]  $ ...future.FUN            :function (x)  
[16:18:40.563]  $ MoreArgs                 : NULL
[16:18:40.563]  $ ...future.elements_ii    :List of 1
[16:18:40.563]   ..$ :List of 1
[16:18:40.563]   .. ..$ : Date[1:1], format: "2018-06-01"
[16:18:40.563]  $ ...future.seeds_ii       : NULL
[16:18:40.563]  $ ...future.globals.maxSize: NULL
[16:18:40.563]  - attr(*, "where")=List of 5
[16:18:40.563]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.563]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.563]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.563]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.563]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.563]  - attr(*, "resolved")= logi FALSE
[16:18:40.563]  - attr(*, "total_size")= num 1128
[16:18:40.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.563]  - attr(*, "already-done")= logi TRUE
[16:18:40.568] - copied ‘...future.FUN’ to environment
[16:18:40.568] - copied ‘MoreArgs’ to environment
[16:18:40.568] - copied ‘...future.elements_ii’ to environment
[16:18:40.568] - copied ‘...future.seeds_ii’ to environment
[16:18:40.568] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.568] assign_globals() ... done
[16:18:40.569] plan(): Setting new future strategy stack:
[16:18:40.569] List of future strategies:
[16:18:40.569] 1. sequential:
[16:18:40.569]    - args: function (..., envir = parent.frame())
[16:18:40.569]    - tweaked: FALSE
[16:18:40.569]    - call: NULL
[16:18:40.569] plan(): nbrOfWorkers() = 1
[16:18:40.570] plan(): Setting new future strategy stack:
[16:18:40.570] List of future strategies:
[16:18:40.570] 1. sequential:
[16:18:40.570]    - args: function (..., envir = parent.frame())
[16:18:40.570]    - tweaked: FALSE
[16:18:40.570]    - call: plan(strategy)
[16:18:40.570] plan(): nbrOfWorkers() = 1
[16:18:40.570] SequentialFuture started (and completed)
[16:18:40.570] - Launch lazy future ... done
[16:18:40.571] run() for ‘SequentialFuture’ ... done
[16:18:40.571] Created future:
[16:18:40.571] SequentialFuture:
[16:18:40.571] Label: ‘future_mapply-1’
[16:18:40.571] Expression:
[16:18:40.571] {
[16:18:40.571]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.571]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.571]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.571]         on.exit(options(oopts), add = TRUE)
[16:18:40.571]     }
[16:18:40.571]     {
[16:18:40.571]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.571]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.571]         do.call(mapply, args = args)
[16:18:40.571]     }
[16:18:40.571] }
[16:18:40.571] Lazy evaluation: FALSE
[16:18:40.571] Asynchronous evaluation: FALSE
[16:18:40.571] Local evaluation: TRUE
[16:18:40.571] Environment: R_GlobalEnv
[16:18:40.571] Capture standard output: TRUE
[16:18:40.571] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.571] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.571] Packages: <none>
[16:18:40.571] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.571] Resolved: TRUE
[16:18:40.571] Value: 280 bytes of class ‘list’
[16:18:40.571] Early signaling: FALSE
[16:18:40.571] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.571] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.572] Chunk #1 of 1 ... DONE
[16:18:40.572] Launching 1 futures (chunks) ... DONE
[16:18:40.572] Resolving 1 futures (chunks) ...
[16:18:40.572] resolve() on list ...
[16:18:40.572]  recursive: 0
[16:18:40.572]  length: 1
[16:18:40.572] 
[16:18:40.572] resolved() for ‘SequentialFuture’ ...
[16:18:40.572] - state: ‘finished’
[16:18:40.573] - run: TRUE
[16:18:40.573] - result: ‘FutureResult’
[16:18:40.573] resolved() for ‘SequentialFuture’ ... done
[16:18:40.573] Future #1
[16:18:40.573] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.573] - nx: 1
[16:18:40.573] - relay: TRUE
[16:18:40.575] - stdout: TRUE
[16:18:40.575] - signal: TRUE
[16:18:40.575] - resignal: FALSE
[16:18:40.575] - force: TRUE
[16:18:40.575] - relayed: [n=1] FALSE
[16:18:40.575] - queued futures: [n=1] FALSE
[16:18:40.576]  - until=1
[16:18:40.576]  - relaying element #1
[16:18:40.576] - relayed: [n=1] TRUE
[16:18:40.576] - queued futures: [n=1] TRUE
[16:18:40.576] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.576]  length: 0 (resolved future 1)
[16:18:40.576] Relaying remaining futures
[16:18:40.576] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.576] - nx: 1
[16:18:40.577] - relay: TRUE
[16:18:40.577] - stdout: TRUE
[16:18:40.577] - signal: TRUE
[16:18:40.577] - resignal: FALSE
[16:18:40.577] - force: TRUE
[16:18:40.577] - relayed: [n=1] TRUE
[16:18:40.577] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.577] - relayed: [n=1] TRUE
[16:18:40.577] - queued futures: [n=1] TRUE
[16:18:40.577] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.578] resolve() on list ... DONE
[16:18:40.578]  - Number of value chunks collected: 1
[16:18:40.578] Resolving 1 futures (chunks) ... DONE
[16:18:40.578] Reducing values from 1 chunks ...
[16:18:40.578]  - Number of values collected after concatenation: 1
[16:18:40.578]  - Number of values expected: 1
[16:18:40.578] Reducing values from 1 chunks ... DONE
[16:18:40.578] future_mapply() ... DONE
[16:18:40.578] future_mapply() ...
[16:18:40.579] Number of chunks: 1
[16:18:40.579] getGlobalsAndPackagesXApply() ...
[16:18:40.579]  - future.globals: TRUE
[16:18:40.579] getGlobalsAndPackages() ...
[16:18:40.579] Searching for globals...
[16:18:40.580] - globals found: [1] ‘FUN’
[16:18:40.580] Searching for globals ... DONE
[16:18:40.580] Resolving globals: FALSE
[16:18:40.580] The total size of the 1 globals is 848 bytes (848 bytes)
[16:18:40.581] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:18:40.581] - globals: [1] ‘FUN’
[16:18:40.581] 
[16:18:40.581] getGlobalsAndPackages() ... DONE
[16:18:40.581]  - globals found/used: [n=1] ‘FUN’
[16:18:40.581]  - needed namespaces: [n=0] 
[16:18:40.581] Finding globals ... DONE
[16:18:40.582] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.582] List of 2
[16:18:40.582]  $ ...future.FUN:function (x)  
[16:18:40.582]  $ MoreArgs     : list()
[16:18:40.582]  - attr(*, "where")=List of 2
[16:18:40.582]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.582]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.582]  - attr(*, "resolved")= logi FALSE
[16:18:40.582]  - attr(*, "total_size")= num NA
[16:18:40.584] Packages to be attached in all futures: [n=0] 
[16:18:40.584] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.584] Number of futures (= number of chunks): 1
[16:18:40.584] Launching 1 futures (chunks) ...
[16:18:40.585] Chunk #1 of 1 ...
[16:18:40.585]  - Finding globals in '...' for chunk #1 ...
[16:18:40.585] getGlobalsAndPackages() ...
[16:18:40.585] Searching for globals...
[16:18:40.585] 
[16:18:40.585] Searching for globals ... DONE
[16:18:40.585] - globals: [0] <none>
[16:18:40.585] getGlobalsAndPackages() ... DONE
[16:18:40.585]    + additional globals found: [n=0] 
[16:18:40.586]    + additional namespaces needed: [n=0] 
[16:18:40.586]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.586]  - seeds: <none>
[16:18:40.586]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.586] getGlobalsAndPackages() ...
[16:18:40.586] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.586] Resolving globals: FALSE
[16:18:40.587] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[16:18:40.587] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:40.587] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.587] 
[16:18:40.587] getGlobalsAndPackages() ... DONE
[16:18:40.588] run() for ‘Future’ ...
[16:18:40.588] - state: ‘created’
[16:18:40.588] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.588] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.588]   - Field: ‘label’
[16:18:40.588]   - Field: ‘local’
[16:18:40.589]   - Field: ‘owner’
[16:18:40.589]   - Field: ‘envir’
[16:18:40.589]   - Field: ‘packages’
[16:18:40.589]   - Field: ‘gc’
[16:18:40.589]   - Field: ‘conditions’
[16:18:40.589]   - Field: ‘expr’
[16:18:40.589]   - Field: ‘uuid’
[16:18:40.589]   - Field: ‘seed’
[16:18:40.589]   - Field: ‘version’
[16:18:40.589]   - Field: ‘result’
[16:18:40.590]   - Field: ‘asynchronous’
[16:18:40.590]   - Field: ‘calls’
[16:18:40.590]   - Field: ‘globals’
[16:18:40.590]   - Field: ‘stdout’
[16:18:40.590]   - Field: ‘earlySignal’
[16:18:40.590]   - Field: ‘lazy’
[16:18:40.590]   - Field: ‘state’
[16:18:40.590] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.590] - Launch lazy future ...
[16:18:40.590] Packages needed by the future expression (n = 0): <none>
[16:18:40.591] Packages needed by future strategies (n = 0): <none>
[16:18:40.591] {
[16:18:40.591]     {
[16:18:40.591]         {
[16:18:40.591]             ...future.startTime <- base::Sys.time()
[16:18:40.591]             {
[16:18:40.591]                 {
[16:18:40.591]                   {
[16:18:40.591]                     base::local({
[16:18:40.591]                       has_future <- base::requireNamespace("future", 
[16:18:40.591]                         quietly = TRUE)
[16:18:40.591]                       if (has_future) {
[16:18:40.591]                         ns <- base::getNamespace("future")
[16:18:40.591]                         version <- ns[[".package"]][["version"]]
[16:18:40.591]                         if (is.null(version)) 
[16:18:40.591]                           version <- utils::packageVersion("future")
[16:18:40.591]                       }
[16:18:40.591]                       else {
[16:18:40.591]                         version <- NULL
[16:18:40.591]                       }
[16:18:40.591]                       if (!has_future || version < "1.8.0") {
[16:18:40.591]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.591]                           "", base::R.version$version.string), 
[16:18:40.591]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.591]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.591]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.591]                             "release", "version")], collapse = " "), 
[16:18:40.591]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.591]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.591]                           info)
[16:18:40.591]                         info <- base::paste(info, collapse = "; ")
[16:18:40.591]                         if (!has_future) {
[16:18:40.591]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.591]                             info)
[16:18:40.591]                         }
[16:18:40.591]                         else {
[16:18:40.591]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.591]                             info, version)
[16:18:40.591]                         }
[16:18:40.591]                         base::stop(msg)
[16:18:40.591]                       }
[16:18:40.591]                     })
[16:18:40.591]                   }
[16:18:40.591]                   ...future.strategy.old <- future::plan("list")
[16:18:40.591]                   options(future.plan = NULL)
[16:18:40.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.591]                 }
[16:18:40.591]                 ...future.workdir <- getwd()
[16:18:40.591]             }
[16:18:40.591]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.591]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.591]         }
[16:18:40.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.591]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.591]             base::names(...future.oldOptions))
[16:18:40.591]     }
[16:18:40.591]     if (FALSE) {
[16:18:40.591]     }
[16:18:40.591]     else {
[16:18:40.591]         if (TRUE) {
[16:18:40.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.591]                 open = "w")
[16:18:40.591]         }
[16:18:40.591]         else {
[16:18:40.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.591]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.591]         }
[16:18:40.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.591]             base::sink(type = "output", split = FALSE)
[16:18:40.591]             base::close(...future.stdout)
[16:18:40.591]         }, add = TRUE)
[16:18:40.591]     }
[16:18:40.591]     ...future.frame <- base::sys.nframe()
[16:18:40.591]     ...future.conditions <- base::list()
[16:18:40.591]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.591]     if (FALSE) {
[16:18:40.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.591]     }
[16:18:40.591]     ...future.result <- base::tryCatch({
[16:18:40.591]         base::withCallingHandlers({
[16:18:40.591]             ...future.value <- base::withVisible(base::local({
[16:18:40.591]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.591]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.591]                   ...future.globals.maxSize)) {
[16:18:40.591]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.591]                   on.exit(options(oopts), add = TRUE)
[16:18:40.591]                 }
[16:18:40.591]                 {
[16:18:40.591]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.591]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.591]                     USE.NAMES = FALSE)
[16:18:40.591]                   do.call(mapply, args = args)
[16:18:40.591]                 }
[16:18:40.591]             }))
[16:18:40.591]             future::FutureResult(value = ...future.value$value, 
[16:18:40.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.591]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.591]                     ...future.globalenv.names))
[16:18:40.591]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.591]         }, condition = base::local({
[16:18:40.591]             c <- base::c
[16:18:40.591]             inherits <- base::inherits
[16:18:40.591]             invokeRestart <- base::invokeRestart
[16:18:40.591]             length <- base::length
[16:18:40.591]             list <- base::list
[16:18:40.591]             seq.int <- base::seq.int
[16:18:40.591]             signalCondition <- base::signalCondition
[16:18:40.591]             sys.calls <- base::sys.calls
[16:18:40.591]             `[[` <- base::`[[`
[16:18:40.591]             `+` <- base::`+`
[16:18:40.591]             `<<-` <- base::`<<-`
[16:18:40.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.591]                   3L)]
[16:18:40.591]             }
[16:18:40.591]             function(cond) {
[16:18:40.591]                 is_error <- inherits(cond, "error")
[16:18:40.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.591]                   NULL)
[16:18:40.591]                 if (is_error) {
[16:18:40.591]                   sessionInformation <- function() {
[16:18:40.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.591]                       search = base::search(), system = base::Sys.info())
[16:18:40.591]                   }
[16:18:40.591]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.591]                     cond$call), session = sessionInformation(), 
[16:18:40.591]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.591]                   signalCondition(cond)
[16:18:40.591]                 }
[16:18:40.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.591]                 "immediateCondition"))) {
[16:18:40.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.591]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.591]                   if (TRUE && !signal) {
[16:18:40.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.591]                     {
[16:18:40.591]                       inherits <- base::inherits
[16:18:40.591]                       invokeRestart <- base::invokeRestart
[16:18:40.591]                       is.null <- base::is.null
[16:18:40.591]                       muffled <- FALSE
[16:18:40.591]                       if (inherits(cond, "message")) {
[16:18:40.591]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.591]                         if (muffled) 
[16:18:40.591]                           invokeRestart("muffleMessage")
[16:18:40.591]                       }
[16:18:40.591]                       else if (inherits(cond, "warning")) {
[16:18:40.591]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.591]                         if (muffled) 
[16:18:40.591]                           invokeRestart("muffleWarning")
[16:18:40.591]                       }
[16:18:40.591]                       else if (inherits(cond, "condition")) {
[16:18:40.591]                         if (!is.null(pattern)) {
[16:18:40.591]                           computeRestarts <- base::computeRestarts
[16:18:40.591]                           grepl <- base::grepl
[16:18:40.591]                           restarts <- computeRestarts(cond)
[16:18:40.591]                           for (restart in restarts) {
[16:18:40.591]                             name <- restart$name
[16:18:40.591]                             if (is.null(name)) 
[16:18:40.591]                               next
[16:18:40.591]                             if (!grepl(pattern, name)) 
[16:18:40.591]                               next
[16:18:40.591]                             invokeRestart(restart)
[16:18:40.591]                             muffled <- TRUE
[16:18:40.591]                             break
[16:18:40.591]                           }
[16:18:40.591]                         }
[16:18:40.591]                       }
[16:18:40.591]                       invisible(muffled)
[16:18:40.591]                     }
[16:18:40.591]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.591]                   }
[16:18:40.591]                 }
[16:18:40.591]                 else {
[16:18:40.591]                   if (TRUE) {
[16:18:40.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.591]                     {
[16:18:40.591]                       inherits <- base::inherits
[16:18:40.591]                       invokeRestart <- base::invokeRestart
[16:18:40.591]                       is.null <- base::is.null
[16:18:40.591]                       muffled <- FALSE
[16:18:40.591]                       if (inherits(cond, "message")) {
[16:18:40.591]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.591]                         if (muffled) 
[16:18:40.591]                           invokeRestart("muffleMessage")
[16:18:40.591]                       }
[16:18:40.591]                       else if (inherits(cond, "warning")) {
[16:18:40.591]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.591]                         if (muffled) 
[16:18:40.591]                           invokeRestart("muffleWarning")
[16:18:40.591]                       }
[16:18:40.591]                       else if (inherits(cond, "condition")) {
[16:18:40.591]                         if (!is.null(pattern)) {
[16:18:40.591]                           computeRestarts <- base::computeRestarts
[16:18:40.591]                           grepl <- base::grepl
[16:18:40.591]                           restarts <- computeRestarts(cond)
[16:18:40.591]                           for (restart in restarts) {
[16:18:40.591]                             name <- restart$name
[16:18:40.591]                             if (is.null(name)) 
[16:18:40.591]                               next
[16:18:40.591]                             if (!grepl(pattern, name)) 
[16:18:40.591]                               next
[16:18:40.591]                             invokeRestart(restart)
[16:18:40.591]                             muffled <- TRUE
[16:18:40.591]                             break
[16:18:40.591]                           }
[16:18:40.591]                         }
[16:18:40.591]                       }
[16:18:40.591]                       invisible(muffled)
[16:18:40.591]                     }
[16:18:40.591]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.591]                   }
[16:18:40.591]                 }
[16:18:40.591]             }
[16:18:40.591]         }))
[16:18:40.591]     }, error = function(ex) {
[16:18:40.591]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.591]                 ...future.rng), started = ...future.startTime, 
[16:18:40.591]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.591]             version = "1.8"), class = "FutureResult")
[16:18:40.591]     }, finally = {
[16:18:40.591]         if (!identical(...future.workdir, getwd())) 
[16:18:40.591]             setwd(...future.workdir)
[16:18:40.591]         {
[16:18:40.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.591]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.591]             }
[16:18:40.591]             base::options(...future.oldOptions)
[16:18:40.591]             if (.Platform$OS.type == "windows") {
[16:18:40.591]                 old_names <- names(...future.oldEnvVars)
[16:18:40.591]                 envs <- base::Sys.getenv()
[16:18:40.591]                 names <- names(envs)
[16:18:40.591]                 common <- intersect(names, old_names)
[16:18:40.591]                 added <- setdiff(names, old_names)
[16:18:40.591]                 removed <- setdiff(old_names, names)
[16:18:40.591]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.591]                   envs[common]]
[16:18:40.591]                 NAMES <- toupper(changed)
[16:18:40.591]                 args <- list()
[16:18:40.591]                 for (kk in seq_along(NAMES)) {
[16:18:40.591]                   name <- changed[[kk]]
[16:18:40.591]                   NAME <- NAMES[[kk]]
[16:18:40.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.591]                     next
[16:18:40.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.591]                 }
[16:18:40.591]                 NAMES <- toupper(added)
[16:18:40.591]                 for (kk in seq_along(NAMES)) {
[16:18:40.591]                   name <- added[[kk]]
[16:18:40.591]                   NAME <- NAMES[[kk]]
[16:18:40.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.591]                     next
[16:18:40.591]                   args[[name]] <- ""
[16:18:40.591]                 }
[16:18:40.591]                 NAMES <- toupper(removed)
[16:18:40.591]                 for (kk in seq_along(NAMES)) {
[16:18:40.591]                   name <- removed[[kk]]
[16:18:40.591]                   NAME <- NAMES[[kk]]
[16:18:40.591]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.591]                     next
[16:18:40.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.591]                 }
[16:18:40.591]                 if (length(args) > 0) 
[16:18:40.591]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.591]             }
[16:18:40.591]             else {
[16:18:40.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.591]             }
[16:18:40.591]             {
[16:18:40.591]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.591]                   0L) {
[16:18:40.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.591]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.591]                   base::options(opts)
[16:18:40.591]                 }
[16:18:40.591]                 {
[16:18:40.591]                   {
[16:18:40.591]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.591]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.591]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.591]                       inherits = FALSE)
[16:18:40.591]                     NULL
[16:18:40.591]                   }
[16:18:40.591]                   options(future.plan = NULL)
[16:18:40.591]                   if (is.na(NA_character_)) 
[16:18:40.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.591]                     .init = FALSE)
[16:18:40.591]                 }
[16:18:40.591]             }
[16:18:40.591]         }
[16:18:40.591]     })
[16:18:40.591]     if (TRUE) {
[16:18:40.591]         base::sink(type = "output", split = FALSE)
[16:18:40.591]         if (TRUE) {
[16:18:40.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.591]         }
[16:18:40.591]         else {
[16:18:40.591]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.591]         }
[16:18:40.591]         base::close(...future.stdout)
[16:18:40.591]         ...future.stdout <- NULL
[16:18:40.591]     }
[16:18:40.591]     ...future.result$conditions <- ...future.conditions
[16:18:40.591]     ...future.result$finished <- base::Sys.time()
[16:18:40.591]     ...future.result
[16:18:40.591] }
[16:18:40.593] assign_globals() ...
[16:18:40.593] List of 5
[16:18:40.593]  $ ...future.FUN            :function (x)  
[16:18:40.593]  $ MoreArgs                 : list()
[16:18:40.593]  $ ...future.elements_ii    :List of 1
[16:18:40.593]   ..$ :List of 1
[16:18:40.593]   .. ..$ : Date[1:1], format: "2018-06-01"
[16:18:40.593]  $ ...future.seeds_ii       : NULL
[16:18:40.593]  $ ...future.globals.maxSize: NULL
[16:18:40.593]  - attr(*, "where")=List of 5
[16:18:40.593]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.593]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.593]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.593]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.593]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.593]  - attr(*, "resolved")= logi FALSE
[16:18:40.593]  - attr(*, "total_size")= num 1128
[16:18:40.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.593]  - attr(*, "already-done")= logi TRUE
[16:18:40.599] - copied ‘...future.FUN’ to environment
[16:18:40.599] - copied ‘MoreArgs’ to environment
[16:18:40.599] - copied ‘...future.elements_ii’ to environment
[16:18:40.599] - copied ‘...future.seeds_ii’ to environment
[16:18:40.599] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.599] assign_globals() ... done
[16:18:40.600] plan(): Setting new future strategy stack:
[16:18:40.600] List of future strategies:
[16:18:40.600] 1. sequential:
[16:18:40.600]    - args: function (..., envir = parent.frame())
[16:18:40.600]    - tweaked: FALSE
[16:18:40.600]    - call: NULL
[16:18:40.600] plan(): nbrOfWorkers() = 1
[16:18:40.601] plan(): Setting new future strategy stack:
[16:18:40.601] List of future strategies:
[16:18:40.601] 1. sequential:
[16:18:40.601]    - args: function (..., envir = parent.frame())
[16:18:40.601]    - tweaked: FALSE
[16:18:40.601]    - call: plan(strategy)
[16:18:40.601] plan(): nbrOfWorkers() = 1
[16:18:40.602] SequentialFuture started (and completed)
[16:18:40.602] - Launch lazy future ... done
[16:18:40.602] run() for ‘SequentialFuture’ ... done
[16:18:40.602] Created future:
[16:18:40.602] SequentialFuture:
[16:18:40.602] Label: ‘future_.mapply-1’
[16:18:40.602] Expression:
[16:18:40.602] {
[16:18:40.602]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.602]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.602]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.602]         on.exit(options(oopts), add = TRUE)
[16:18:40.602]     }
[16:18:40.602]     {
[16:18:40.602]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.602]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.602]         do.call(mapply, args = args)
[16:18:40.602]     }
[16:18:40.602] }
[16:18:40.602] Lazy evaluation: FALSE
[16:18:40.602] Asynchronous evaluation: FALSE
[16:18:40.602] Local evaluation: TRUE
[16:18:40.602] Environment: R_GlobalEnv
[16:18:40.602] Capture standard output: TRUE
[16:18:40.602] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.602] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.602] Packages: <none>
[16:18:40.602] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.602] Resolved: TRUE
[16:18:40.602] Value: 280 bytes of class ‘list’
[16:18:40.602] Early signaling: FALSE
[16:18:40.602] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.602] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.603] Chunk #1 of 1 ... DONE
[16:18:40.603] Launching 1 futures (chunks) ... DONE
[16:18:40.603] Resolving 1 futures (chunks) ...
[16:18:40.603] resolve() on list ...
[16:18:40.603]  recursive: 0
[16:18:40.603]  length: 1
[16:18:40.604] 
[16:18:40.604] resolved() for ‘SequentialFuture’ ...
[16:18:40.604] - state: ‘finished’
[16:18:40.604] - run: TRUE
[16:18:40.604] - result: ‘FutureResult’
[16:18:40.604] resolved() for ‘SequentialFuture’ ... done
[16:18:40.604] Future #1
[16:18:40.604] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.604] - nx: 1
[16:18:40.605] - relay: TRUE
[16:18:40.605] - stdout: TRUE
[16:18:40.605] - signal: TRUE
[16:18:40.605] - resignal: FALSE
[16:18:40.605] - force: TRUE
[16:18:40.605] - relayed: [n=1] FALSE
[16:18:40.605] - queued futures: [n=1] FALSE
[16:18:40.605]  - until=1
[16:18:40.605]  - relaying element #1
[16:18:40.605] - relayed: [n=1] TRUE
[16:18:40.605] - queued futures: [n=1] TRUE
[16:18:40.606] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.606]  length: 0 (resolved future 1)
[16:18:40.606] Relaying remaining futures
[16:18:40.606] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.606] - nx: 1
[16:18:40.606] - relay: TRUE
[16:18:40.606] - stdout: TRUE
[16:18:40.606] - signal: TRUE
[16:18:40.606] - resignal: FALSE
[16:18:40.606] - force: TRUE
[16:18:40.606] - relayed: [n=1] TRUE
[16:18:40.607] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.607] - relayed: [n=1] TRUE
[16:18:40.607] - queued futures: [n=1] TRUE
[16:18:40.607] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.607] resolve() on list ... DONE
[16:18:40.607]  - Number of value chunks collected: 1
[16:18:40.607] Resolving 1 futures (chunks) ... DONE
[16:18:40.607] Reducing values from 1 chunks ...
[16:18:40.607]  - Number of values collected after concatenation: 1
[16:18:40.607]  - Number of values expected: 1
[16:18:40.608] Reducing values from 1 chunks ... DONE
[16:18:40.608] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[16:18:40.608] future_mapply() ...
[16:18:40.608] Number of chunks: 1
[16:18:40.608] getGlobalsAndPackagesXApply() ...
[16:18:40.608]  - future.globals: TRUE
[16:18:40.608] getGlobalsAndPackages() ...
[16:18:40.608] Searching for globals...
[16:18:40.609] - globals found: [1] ‘FUN’
[16:18:40.610] Searching for globals ... DONE
[16:18:40.610] Resolving globals: FALSE
[16:18:40.610] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[16:18:40.610] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[16:18:40.610] - globals: [1] ‘FUN’
[16:18:40.610] 
[16:18:40.611] getGlobalsAndPackages() ... DONE
[16:18:40.611]  - globals found/used: [n=1] ‘FUN’
[16:18:40.611]  - needed namespaces: [n=0] 
[16:18:40.611] Finding globals ... DONE
[16:18:40.611] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.611] List of 2
[16:18:40.611]  $ ...future.FUN:function (x, y)  
[16:18:40.611]  $ MoreArgs     :List of 1
[16:18:40.611]   ..$ y: int [1:2] 3 4
[16:18:40.611]  - attr(*, "where")=List of 2
[16:18:40.611]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.611]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.611]  - attr(*, "resolved")= logi FALSE
[16:18:40.611]  - attr(*, "total_size")= num NA
[16:18:40.614] Packages to be attached in all futures: [n=0] 
[16:18:40.614] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.614] Number of futures (= number of chunks): 1
[16:18:40.614] Launching 1 futures (chunks) ...
[16:18:40.614] Chunk #1 of 1 ...
[16:18:40.615]  - Finding globals in '...' for chunk #1 ...
[16:18:40.615] getGlobalsAndPackages() ...
[16:18:40.615] Searching for globals...
[16:18:40.615] 
[16:18:40.615] Searching for globals ... DONE
[16:18:40.615] - globals: [0] <none>
[16:18:40.615] getGlobalsAndPackages() ... DONE
[16:18:40.615]    + additional globals found: [n=0] 
[16:18:40.616]    + additional namespaces needed: [n=0] 
[16:18:40.616]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.616]  - seeds: <none>
[16:18:40.616]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.616] getGlobalsAndPackages() ...
[16:18:40.616] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.616] Resolving globals: FALSE
[16:18:40.617] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[16:18:40.617] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[16:18:40.617] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.617] 
[16:18:40.617] getGlobalsAndPackages() ... DONE
[16:18:40.618] run() for ‘Future’ ...
[16:18:40.618] - state: ‘created’
[16:18:40.618] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.618] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.618] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.618]   - Field: ‘label’
[16:18:40.618]   - Field: ‘local’
[16:18:40.619]   - Field: ‘owner’
[16:18:40.619]   - Field: ‘envir’
[16:18:40.619]   - Field: ‘packages’
[16:18:40.619]   - Field: ‘gc’
[16:18:40.619]   - Field: ‘conditions’
[16:18:40.619]   - Field: ‘expr’
[16:18:40.619]   - Field: ‘uuid’
[16:18:40.619]   - Field: ‘seed’
[16:18:40.619]   - Field: ‘version’
[16:18:40.619]   - Field: ‘result’
[16:18:40.619]   - Field: ‘asynchronous’
[16:18:40.620]   - Field: ‘calls’
[16:18:40.621]   - Field: ‘globals’
[16:18:40.621]   - Field: ‘stdout’
[16:18:40.622]   - Field: ‘earlySignal’
[16:18:40.622]   - Field: ‘lazy’
[16:18:40.622]   - Field: ‘state’
[16:18:40.622] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.622] - Launch lazy future ...
[16:18:40.622] Packages needed by the future expression (n = 0): <none>
[16:18:40.622] Packages needed by future strategies (n = 0): <none>
[16:18:40.623] {
[16:18:40.623]     {
[16:18:40.623]         {
[16:18:40.623]             ...future.startTime <- base::Sys.time()
[16:18:40.623]             {
[16:18:40.623]                 {
[16:18:40.623]                   {
[16:18:40.623]                     base::local({
[16:18:40.623]                       has_future <- base::requireNamespace("future", 
[16:18:40.623]                         quietly = TRUE)
[16:18:40.623]                       if (has_future) {
[16:18:40.623]                         ns <- base::getNamespace("future")
[16:18:40.623]                         version <- ns[[".package"]][["version"]]
[16:18:40.623]                         if (is.null(version)) 
[16:18:40.623]                           version <- utils::packageVersion("future")
[16:18:40.623]                       }
[16:18:40.623]                       else {
[16:18:40.623]                         version <- NULL
[16:18:40.623]                       }
[16:18:40.623]                       if (!has_future || version < "1.8.0") {
[16:18:40.623]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.623]                           "", base::R.version$version.string), 
[16:18:40.623]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.623]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.623]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.623]                             "release", "version")], collapse = " "), 
[16:18:40.623]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.623]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.623]                           info)
[16:18:40.623]                         info <- base::paste(info, collapse = "; ")
[16:18:40.623]                         if (!has_future) {
[16:18:40.623]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.623]                             info)
[16:18:40.623]                         }
[16:18:40.623]                         else {
[16:18:40.623]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.623]                             info, version)
[16:18:40.623]                         }
[16:18:40.623]                         base::stop(msg)
[16:18:40.623]                       }
[16:18:40.623]                     })
[16:18:40.623]                   }
[16:18:40.623]                   ...future.strategy.old <- future::plan("list")
[16:18:40.623]                   options(future.plan = NULL)
[16:18:40.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.623]                 }
[16:18:40.623]                 ...future.workdir <- getwd()
[16:18:40.623]             }
[16:18:40.623]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.623]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.623]         }
[16:18:40.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.623]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.623]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.623]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.623]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.623]             base::names(...future.oldOptions))
[16:18:40.623]     }
[16:18:40.623]     if (FALSE) {
[16:18:40.623]     }
[16:18:40.623]     else {
[16:18:40.623]         if (TRUE) {
[16:18:40.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.623]                 open = "w")
[16:18:40.623]         }
[16:18:40.623]         else {
[16:18:40.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.623]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.623]         }
[16:18:40.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.623]             base::sink(type = "output", split = FALSE)
[16:18:40.623]             base::close(...future.stdout)
[16:18:40.623]         }, add = TRUE)
[16:18:40.623]     }
[16:18:40.623]     ...future.frame <- base::sys.nframe()
[16:18:40.623]     ...future.conditions <- base::list()
[16:18:40.623]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.623]     if (FALSE) {
[16:18:40.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.623]     }
[16:18:40.623]     ...future.result <- base::tryCatch({
[16:18:40.623]         base::withCallingHandlers({
[16:18:40.623]             ...future.value <- base::withVisible(base::local({
[16:18:40.623]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.623]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.623]                   ...future.globals.maxSize)) {
[16:18:40.623]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.623]                   on.exit(options(oopts), add = TRUE)
[16:18:40.623]                 }
[16:18:40.623]                 {
[16:18:40.623]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.623]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.623]                     USE.NAMES = FALSE)
[16:18:40.623]                   do.call(mapply, args = args)
[16:18:40.623]                 }
[16:18:40.623]             }))
[16:18:40.623]             future::FutureResult(value = ...future.value$value, 
[16:18:40.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.623]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.623]                     ...future.globalenv.names))
[16:18:40.623]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.623]         }, condition = base::local({
[16:18:40.623]             c <- base::c
[16:18:40.623]             inherits <- base::inherits
[16:18:40.623]             invokeRestart <- base::invokeRestart
[16:18:40.623]             length <- base::length
[16:18:40.623]             list <- base::list
[16:18:40.623]             seq.int <- base::seq.int
[16:18:40.623]             signalCondition <- base::signalCondition
[16:18:40.623]             sys.calls <- base::sys.calls
[16:18:40.623]             `[[` <- base::`[[`
[16:18:40.623]             `+` <- base::`+`
[16:18:40.623]             `<<-` <- base::`<<-`
[16:18:40.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.623]                   3L)]
[16:18:40.623]             }
[16:18:40.623]             function(cond) {
[16:18:40.623]                 is_error <- inherits(cond, "error")
[16:18:40.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.623]                   NULL)
[16:18:40.623]                 if (is_error) {
[16:18:40.623]                   sessionInformation <- function() {
[16:18:40.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.623]                       search = base::search(), system = base::Sys.info())
[16:18:40.623]                   }
[16:18:40.623]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.623]                     cond$call), session = sessionInformation(), 
[16:18:40.623]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.623]                   signalCondition(cond)
[16:18:40.623]                 }
[16:18:40.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.623]                 "immediateCondition"))) {
[16:18:40.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.623]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.623]                   if (TRUE && !signal) {
[16:18:40.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.623]                     {
[16:18:40.623]                       inherits <- base::inherits
[16:18:40.623]                       invokeRestart <- base::invokeRestart
[16:18:40.623]                       is.null <- base::is.null
[16:18:40.623]                       muffled <- FALSE
[16:18:40.623]                       if (inherits(cond, "message")) {
[16:18:40.623]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.623]                         if (muffled) 
[16:18:40.623]                           invokeRestart("muffleMessage")
[16:18:40.623]                       }
[16:18:40.623]                       else if (inherits(cond, "warning")) {
[16:18:40.623]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.623]                         if (muffled) 
[16:18:40.623]                           invokeRestart("muffleWarning")
[16:18:40.623]                       }
[16:18:40.623]                       else if (inherits(cond, "condition")) {
[16:18:40.623]                         if (!is.null(pattern)) {
[16:18:40.623]                           computeRestarts <- base::computeRestarts
[16:18:40.623]                           grepl <- base::grepl
[16:18:40.623]                           restarts <- computeRestarts(cond)
[16:18:40.623]                           for (restart in restarts) {
[16:18:40.623]                             name <- restart$name
[16:18:40.623]                             if (is.null(name)) 
[16:18:40.623]                               next
[16:18:40.623]                             if (!grepl(pattern, name)) 
[16:18:40.623]                               next
[16:18:40.623]                             invokeRestart(restart)
[16:18:40.623]                             muffled <- TRUE
[16:18:40.623]                             break
[16:18:40.623]                           }
[16:18:40.623]                         }
[16:18:40.623]                       }
[16:18:40.623]                       invisible(muffled)
[16:18:40.623]                     }
[16:18:40.623]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.623]                   }
[16:18:40.623]                 }
[16:18:40.623]                 else {
[16:18:40.623]                   if (TRUE) {
[16:18:40.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.623]                     {
[16:18:40.623]                       inherits <- base::inherits
[16:18:40.623]                       invokeRestart <- base::invokeRestart
[16:18:40.623]                       is.null <- base::is.null
[16:18:40.623]                       muffled <- FALSE
[16:18:40.623]                       if (inherits(cond, "message")) {
[16:18:40.623]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.623]                         if (muffled) 
[16:18:40.623]                           invokeRestart("muffleMessage")
[16:18:40.623]                       }
[16:18:40.623]                       else if (inherits(cond, "warning")) {
[16:18:40.623]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.623]                         if (muffled) 
[16:18:40.623]                           invokeRestart("muffleWarning")
[16:18:40.623]                       }
[16:18:40.623]                       else if (inherits(cond, "condition")) {
[16:18:40.623]                         if (!is.null(pattern)) {
[16:18:40.623]                           computeRestarts <- base::computeRestarts
[16:18:40.623]                           grepl <- base::grepl
[16:18:40.623]                           restarts <- computeRestarts(cond)
[16:18:40.623]                           for (restart in restarts) {
[16:18:40.623]                             name <- restart$name
[16:18:40.623]                             if (is.null(name)) 
[16:18:40.623]                               next
[16:18:40.623]                             if (!grepl(pattern, name)) 
[16:18:40.623]                               next
[16:18:40.623]                             invokeRestart(restart)
[16:18:40.623]                             muffled <- TRUE
[16:18:40.623]                             break
[16:18:40.623]                           }
[16:18:40.623]                         }
[16:18:40.623]                       }
[16:18:40.623]                       invisible(muffled)
[16:18:40.623]                     }
[16:18:40.623]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.623]                   }
[16:18:40.623]                 }
[16:18:40.623]             }
[16:18:40.623]         }))
[16:18:40.623]     }, error = function(ex) {
[16:18:40.623]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.623]                 ...future.rng), started = ...future.startTime, 
[16:18:40.623]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.623]             version = "1.8"), class = "FutureResult")
[16:18:40.623]     }, finally = {
[16:18:40.623]         if (!identical(...future.workdir, getwd())) 
[16:18:40.623]             setwd(...future.workdir)
[16:18:40.623]         {
[16:18:40.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.623]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.623]             }
[16:18:40.623]             base::options(...future.oldOptions)
[16:18:40.623]             if (.Platform$OS.type == "windows") {
[16:18:40.623]                 old_names <- names(...future.oldEnvVars)
[16:18:40.623]                 envs <- base::Sys.getenv()
[16:18:40.623]                 names <- names(envs)
[16:18:40.623]                 common <- intersect(names, old_names)
[16:18:40.623]                 added <- setdiff(names, old_names)
[16:18:40.623]                 removed <- setdiff(old_names, names)
[16:18:40.623]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.623]                   envs[common]]
[16:18:40.623]                 NAMES <- toupper(changed)
[16:18:40.623]                 args <- list()
[16:18:40.623]                 for (kk in seq_along(NAMES)) {
[16:18:40.623]                   name <- changed[[kk]]
[16:18:40.623]                   NAME <- NAMES[[kk]]
[16:18:40.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.623]                     next
[16:18:40.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.623]                 }
[16:18:40.623]                 NAMES <- toupper(added)
[16:18:40.623]                 for (kk in seq_along(NAMES)) {
[16:18:40.623]                   name <- added[[kk]]
[16:18:40.623]                   NAME <- NAMES[[kk]]
[16:18:40.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.623]                     next
[16:18:40.623]                   args[[name]] <- ""
[16:18:40.623]                 }
[16:18:40.623]                 NAMES <- toupper(removed)
[16:18:40.623]                 for (kk in seq_along(NAMES)) {
[16:18:40.623]                   name <- removed[[kk]]
[16:18:40.623]                   NAME <- NAMES[[kk]]
[16:18:40.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.623]                     next
[16:18:40.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.623]                 }
[16:18:40.623]                 if (length(args) > 0) 
[16:18:40.623]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.623]             }
[16:18:40.623]             else {
[16:18:40.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.623]             }
[16:18:40.623]             {
[16:18:40.623]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.623]                   0L) {
[16:18:40.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.623]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.623]                   base::options(opts)
[16:18:40.623]                 }
[16:18:40.623]                 {
[16:18:40.623]                   {
[16:18:40.623]                     base::assign(".Random.seed", c(10407L, -550183120L, 
[16:18:40.623]                     -1717965917L, -274188662L, 1010157287L, 1705784185L, 
[16:18:40.623]                     -1742123538L), envir = base::globalenv(), 
[16:18:40.623]                       inherits = FALSE)
[16:18:40.623]                     NULL
[16:18:40.623]                   }
[16:18:40.623]                   options(future.plan = NULL)
[16:18:40.623]                   if (is.na(NA_character_)) 
[16:18:40.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.623]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.623]                     .init = FALSE)
[16:18:40.623]                 }
[16:18:40.623]             }
[16:18:40.623]         }
[16:18:40.623]     })
[16:18:40.623]     if (TRUE) {
[16:18:40.623]         base::sink(type = "output", split = FALSE)
[16:18:40.623]         if (TRUE) {
[16:18:40.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.623]         }
[16:18:40.623]         else {
[16:18:40.623]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.623]         }
[16:18:40.623]         base::close(...future.stdout)
[16:18:40.623]         ...future.stdout <- NULL
[16:18:40.623]     }
[16:18:40.623]     ...future.result$conditions <- ...future.conditions
[16:18:40.623]     ...future.result$finished <- base::Sys.time()
[16:18:40.623]     ...future.result
[16:18:40.623] }
[16:18:40.624] assign_globals() ...
[16:18:40.625] List of 5
[16:18:40.625]  $ ...future.FUN            :function (x, y)  
[16:18:40.625]  $ MoreArgs                 :List of 1
[16:18:40.625]   ..$ y: int [1:2] 3 4
[16:18:40.625]  $ ...future.elements_ii    :List of 1
[16:18:40.625]   ..$ x:List of 2
[16:18:40.625]   .. ..$ : int 1
[16:18:40.625]   .. ..$ : int 2
[16:18:40.625]  $ ...future.seeds_ii       : NULL
[16:18:40.625]  $ ...future.globals.maxSize: NULL
[16:18:40.625]  - attr(*, "where")=List of 5
[16:18:40.625]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.625]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.625]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.625]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.625]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.625]  - attr(*, "resolved")= logi FALSE
[16:18:40.625]  - attr(*, "total_size")= num 1872
[16:18:40.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.625]  - attr(*, "already-done")= logi TRUE
[16:18:40.630] - reassign environment for ‘...future.FUN’
[16:18:40.630] - copied ‘...future.FUN’ to environment
[16:18:40.630] - copied ‘MoreArgs’ to environment
[16:18:40.630] - copied ‘...future.elements_ii’ to environment
[16:18:40.630] - copied ‘...future.seeds_ii’ to environment
[16:18:40.630] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.630] assign_globals() ... done
[16:18:40.631] plan(): Setting new future strategy stack:
[16:18:40.631] List of future strategies:
[16:18:40.631] 1. sequential:
[16:18:40.631]    - args: function (..., envir = parent.frame())
[16:18:40.631]    - tweaked: FALSE
[16:18:40.631]    - call: NULL
[16:18:40.631] plan(): nbrOfWorkers() = 1
[16:18:40.632] plan(): Setting new future strategy stack:
[16:18:40.632] List of future strategies:
[16:18:40.632] 1. sequential:
[16:18:40.632]    - args: function (..., envir = parent.frame())
[16:18:40.632]    - tweaked: FALSE
[16:18:40.632]    - call: plan(strategy)
[16:18:40.632] plan(): nbrOfWorkers() = 1
[16:18:40.632] SequentialFuture started (and completed)
[16:18:40.632] - Launch lazy future ... done
[16:18:40.633] run() for ‘SequentialFuture’ ... done
[16:18:40.633] Created future:
[16:18:40.633] SequentialFuture:
[16:18:40.633] Label: ‘future_mapply-1’
[16:18:40.633] Expression:
[16:18:40.633] {
[16:18:40.633]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.633]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.633]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.633]         on.exit(options(oopts), add = TRUE)
[16:18:40.633]     }
[16:18:40.633]     {
[16:18:40.633]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.633]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.633]         do.call(mapply, args = args)
[16:18:40.633]     }
[16:18:40.633] }
[16:18:40.633] Lazy evaluation: FALSE
[16:18:40.633] Asynchronous evaluation: FALSE
[16:18:40.633] Local evaluation: TRUE
[16:18:40.633] Environment: R_GlobalEnv
[16:18:40.633] Capture standard output: TRUE
[16:18:40.633] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.633] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.633] Packages: <none>
[16:18:40.633] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.633] Resolved: TRUE
[16:18:40.633] Value: 112 bytes of class ‘list’
[16:18:40.633] Early signaling: FALSE
[16:18:40.633] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.633] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.634] Chunk #1 of 1 ... DONE
[16:18:40.634] Launching 1 futures (chunks) ... DONE
[16:18:40.634] Resolving 1 futures (chunks) ...
[16:18:40.634] resolve() on list ...
[16:18:40.634]  recursive: 0
[16:18:40.634]  length: 1
[16:18:40.634] 
[16:18:40.634] resolved() for ‘SequentialFuture’ ...
[16:18:40.634] - state: ‘finished’
[16:18:40.634] - run: TRUE
[16:18:40.635] - result: ‘FutureResult’
[16:18:40.635] resolved() for ‘SequentialFuture’ ... done
[16:18:40.635] Future #1
[16:18:40.635] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.635] - nx: 1
[16:18:40.635] - relay: TRUE
[16:18:40.635] - stdout: TRUE
[16:18:40.635] - signal: TRUE
[16:18:40.635] - resignal: FALSE
[16:18:40.635] - force: TRUE
[16:18:40.635] - relayed: [n=1] FALSE
[16:18:40.636] - queued futures: [n=1] FALSE
[16:18:40.636]  - until=1
[16:18:40.636]  - relaying element #1
[16:18:40.636] - relayed: [n=1] TRUE
[16:18:40.636] - queued futures: [n=1] TRUE
[16:18:40.636] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.636]  length: 0 (resolved future 1)
[16:18:40.636] Relaying remaining futures
[16:18:40.636] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.637] - nx: 1
[16:18:40.637] - relay: TRUE
[16:18:40.637] - stdout: TRUE
[16:18:40.637] - signal: TRUE
[16:18:40.637] - resignal: FALSE
[16:18:40.637] - force: TRUE
[16:18:40.637] - relayed: [n=1] TRUE
[16:18:40.637] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.637] - relayed: [n=1] TRUE
[16:18:40.637] - queued futures: [n=1] TRUE
[16:18:40.637] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.637] resolve() on list ... DONE
[16:18:40.638]  - Number of value chunks collected: 1
[16:18:40.638] Resolving 1 futures (chunks) ... DONE
[16:18:40.638] Reducing values from 1 chunks ...
[16:18:40.638]  - Number of values collected after concatenation: 2
[16:18:40.638]  - Number of values expected: 2
[16:18:40.638] Reducing values from 1 chunks ... DONE
[16:18:40.638] future_mapply() ... DONE
[16:18:40.638] future_mapply() ...
[16:18:40.638] Generating random seeds ...
[16:18:40.639] Generating random seed streams for 2 elements ...
[16:18:40.639] Generating random seed streams for 2 elements ... DONE
[16:18:40.639] Generating random seeds ... DONE
[16:18:40.639] Will set RNG state on exit: 10407, -274188662, -1232399964, 1712775263, -1742123538, -1521354978, -1310549542
[16:18:40.639] Number of chunks: 1
[16:18:40.639] getGlobalsAndPackagesXApply() ...
[16:18:40.639]  - future.globals: TRUE
[16:18:40.639] getGlobalsAndPackages() ...
[16:18:40.639] Searching for globals...
[16:18:40.640] - globals found: [1] ‘FUN’
[16:18:40.640] Searching for globals ... DONE
[16:18:40.641] Resolving globals: FALSE
[16:18:40.641] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[16:18:40.641] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[16:18:40.641] - globals: [1] ‘FUN’
[16:18:40.641] 
[16:18:40.641] getGlobalsAndPackages() ... DONE
[16:18:40.642]  - globals found/used: [n=1] ‘FUN’
[16:18:40.642]  - needed namespaces: [n=0] 
[16:18:40.642] Finding globals ... DONE
[16:18:40.642] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.642] List of 2
[16:18:40.642]  $ ...future.FUN:function (x, y)  
[16:18:40.642]  $ MoreArgs     :List of 1
[16:18:40.642]   ..$ y: int [1:2] 3 4
[16:18:40.642]  - attr(*, "where")=List of 2
[16:18:40.642]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.642]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.642]  - attr(*, "resolved")= logi FALSE
[16:18:40.642]  - attr(*, "total_size")= num NA
[16:18:40.647] Packages to be attached in all futures: [n=0] 
[16:18:40.647] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.647] Number of futures (= number of chunks): 1
[16:18:40.647] Launching 1 futures (chunks) ...
[16:18:40.647] Chunk #1 of 1 ...
[16:18:40.647]  - Finding globals in '...' for chunk #1 ...
[16:18:40.648] getGlobalsAndPackages() ...
[16:18:40.648] Searching for globals...
[16:18:40.648] 
[16:18:40.648] Searching for globals ... DONE
[16:18:40.648] - globals: [0] <none>
[16:18:40.648] getGlobalsAndPackages() ... DONE
[16:18:40.648]    + additional globals found: [n=0] 
[16:18:40.648]    + additional namespaces needed: [n=0] 
[16:18:40.649]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.649]  - seeds: [2] <seeds>
[16:18:40.649]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.649] getGlobalsAndPackages() ...
[16:18:40.649] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.649] Resolving globals: FALSE
[16:18:40.650] The total size of the 5 globals is 1.98 KiB (2032 bytes)
[16:18:40.650] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (160 bytes of class ‘list’) and ‘...future.elements_ii’ (112 bytes of class ‘list’)
[16:18:40.650] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.650] 
[16:18:40.650] getGlobalsAndPackages() ... DONE
[16:18:40.651] run() for ‘Future’ ...
[16:18:40.651] - state: ‘created’
[16:18:40.651] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.651] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.651] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.652]   - Field: ‘label’
[16:18:40.652]   - Field: ‘local’
[16:18:40.652]   - Field: ‘owner’
[16:18:40.652]   - Field: ‘envir’
[16:18:40.652]   - Field: ‘packages’
[16:18:40.652]   - Field: ‘gc’
[16:18:40.652]   - Field: ‘conditions’
[16:18:40.652]   - Field: ‘expr’
[16:18:40.652]   - Field: ‘uuid’
[16:18:40.652]   - Field: ‘seed’
[16:18:40.653]   - Field: ‘version’
[16:18:40.653]   - Field: ‘result’
[16:18:40.653]   - Field: ‘asynchronous’
[16:18:40.653]   - Field: ‘calls’
[16:18:40.653]   - Field: ‘globals’
[16:18:40.653]   - Field: ‘stdout’
[16:18:40.653]   - Field: ‘earlySignal’
[16:18:40.653]   - Field: ‘lazy’
[16:18:40.653]   - Field: ‘state’
[16:18:40.653] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.653] - Launch lazy future ...
[16:18:40.654] Packages needed by the future expression (n = 0): <none>
[16:18:40.654] Packages needed by future strategies (n = 0): <none>
[16:18:40.654] {
[16:18:40.654]     {
[16:18:40.654]         {
[16:18:40.654]             ...future.startTime <- base::Sys.time()
[16:18:40.654]             {
[16:18:40.654]                 {
[16:18:40.654]                   {
[16:18:40.654]                     base::local({
[16:18:40.654]                       has_future <- base::requireNamespace("future", 
[16:18:40.654]                         quietly = TRUE)
[16:18:40.654]                       if (has_future) {
[16:18:40.654]                         ns <- base::getNamespace("future")
[16:18:40.654]                         version <- ns[[".package"]][["version"]]
[16:18:40.654]                         if (is.null(version)) 
[16:18:40.654]                           version <- utils::packageVersion("future")
[16:18:40.654]                       }
[16:18:40.654]                       else {
[16:18:40.654]                         version <- NULL
[16:18:40.654]                       }
[16:18:40.654]                       if (!has_future || version < "1.8.0") {
[16:18:40.654]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.654]                           "", base::R.version$version.string), 
[16:18:40.654]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.654]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.654]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.654]                             "release", "version")], collapse = " "), 
[16:18:40.654]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.654]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.654]                           info)
[16:18:40.654]                         info <- base::paste(info, collapse = "; ")
[16:18:40.654]                         if (!has_future) {
[16:18:40.654]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.654]                             info)
[16:18:40.654]                         }
[16:18:40.654]                         else {
[16:18:40.654]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.654]                             info, version)
[16:18:40.654]                         }
[16:18:40.654]                         base::stop(msg)
[16:18:40.654]                       }
[16:18:40.654]                     })
[16:18:40.654]                   }
[16:18:40.654]                   ...future.strategy.old <- future::plan("list")
[16:18:40.654]                   options(future.plan = NULL)
[16:18:40.654]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.654]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.654]                 }
[16:18:40.654]                 ...future.workdir <- getwd()
[16:18:40.654]             }
[16:18:40.654]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.654]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.654]         }
[16:18:40.654]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.654]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.654]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.654]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.654]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.654]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.654]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.654]             base::names(...future.oldOptions))
[16:18:40.654]     }
[16:18:40.654]     if (FALSE) {
[16:18:40.654]     }
[16:18:40.654]     else {
[16:18:40.654]         if (TRUE) {
[16:18:40.654]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.654]                 open = "w")
[16:18:40.654]         }
[16:18:40.654]         else {
[16:18:40.654]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.654]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.654]         }
[16:18:40.654]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.654]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.654]             base::sink(type = "output", split = FALSE)
[16:18:40.654]             base::close(...future.stdout)
[16:18:40.654]         }, add = TRUE)
[16:18:40.654]     }
[16:18:40.654]     ...future.frame <- base::sys.nframe()
[16:18:40.654]     ...future.conditions <- base::list()
[16:18:40.654]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.654]     if (FALSE) {
[16:18:40.654]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.654]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.654]     }
[16:18:40.654]     ...future.result <- base::tryCatch({
[16:18:40.654]         base::withCallingHandlers({
[16:18:40.654]             ...future.value <- base::withVisible(base::local({
[16:18:40.654]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.654]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.654]                   ...future.globals.maxSize)) {
[16:18:40.654]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.654]                   on.exit(options(oopts), add = TRUE)
[16:18:40.654]                 }
[16:18:40.654]                 {
[16:18:40.654]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:40.654]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[16:18:40.654]                       envir = globalenv(), inherits = FALSE)
[16:18:40.654]                     ...future.FUN(...)
[16:18:40.654]                   }
[16:18:40.654]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:40.654]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:40.654]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.654]                     USE.NAMES = FALSE)
[16:18:40.654]                   do.call(mapply, args = args)
[16:18:40.654]                 }
[16:18:40.654]             }))
[16:18:40.654]             future::FutureResult(value = ...future.value$value, 
[16:18:40.654]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.654]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.654]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.654]                     ...future.globalenv.names))
[16:18:40.654]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.654]         }, condition = base::local({
[16:18:40.654]             c <- base::c
[16:18:40.654]             inherits <- base::inherits
[16:18:40.654]             invokeRestart <- base::invokeRestart
[16:18:40.654]             length <- base::length
[16:18:40.654]             list <- base::list
[16:18:40.654]             seq.int <- base::seq.int
[16:18:40.654]             signalCondition <- base::signalCondition
[16:18:40.654]             sys.calls <- base::sys.calls
[16:18:40.654]             `[[` <- base::`[[`
[16:18:40.654]             `+` <- base::`+`
[16:18:40.654]             `<<-` <- base::`<<-`
[16:18:40.654]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.654]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.654]                   3L)]
[16:18:40.654]             }
[16:18:40.654]             function(cond) {
[16:18:40.654]                 is_error <- inherits(cond, "error")
[16:18:40.654]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.654]                   NULL)
[16:18:40.654]                 if (is_error) {
[16:18:40.654]                   sessionInformation <- function() {
[16:18:40.654]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.654]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.654]                       search = base::search(), system = base::Sys.info())
[16:18:40.654]                   }
[16:18:40.654]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.654]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.654]                     cond$call), session = sessionInformation(), 
[16:18:40.654]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.654]                   signalCondition(cond)
[16:18:40.654]                 }
[16:18:40.654]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.654]                 "immediateCondition"))) {
[16:18:40.654]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.654]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.654]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.654]                   if (TRUE && !signal) {
[16:18:40.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.654]                     {
[16:18:40.654]                       inherits <- base::inherits
[16:18:40.654]                       invokeRestart <- base::invokeRestart
[16:18:40.654]                       is.null <- base::is.null
[16:18:40.654]                       muffled <- FALSE
[16:18:40.654]                       if (inherits(cond, "message")) {
[16:18:40.654]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.654]                         if (muffled) 
[16:18:40.654]                           invokeRestart("muffleMessage")
[16:18:40.654]                       }
[16:18:40.654]                       else if (inherits(cond, "warning")) {
[16:18:40.654]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.654]                         if (muffled) 
[16:18:40.654]                           invokeRestart("muffleWarning")
[16:18:40.654]                       }
[16:18:40.654]                       else if (inherits(cond, "condition")) {
[16:18:40.654]                         if (!is.null(pattern)) {
[16:18:40.654]                           computeRestarts <- base::computeRestarts
[16:18:40.654]                           grepl <- base::grepl
[16:18:40.654]                           restarts <- computeRestarts(cond)
[16:18:40.654]                           for (restart in restarts) {
[16:18:40.654]                             name <- restart$name
[16:18:40.654]                             if (is.null(name)) 
[16:18:40.654]                               next
[16:18:40.654]                             if (!grepl(pattern, name)) 
[16:18:40.654]                               next
[16:18:40.654]                             invokeRestart(restart)
[16:18:40.654]                             muffled <- TRUE
[16:18:40.654]                             break
[16:18:40.654]                           }
[16:18:40.654]                         }
[16:18:40.654]                       }
[16:18:40.654]                       invisible(muffled)
[16:18:40.654]                     }
[16:18:40.654]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.654]                   }
[16:18:40.654]                 }
[16:18:40.654]                 else {
[16:18:40.654]                   if (TRUE) {
[16:18:40.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.654]                     {
[16:18:40.654]                       inherits <- base::inherits
[16:18:40.654]                       invokeRestart <- base::invokeRestart
[16:18:40.654]                       is.null <- base::is.null
[16:18:40.654]                       muffled <- FALSE
[16:18:40.654]                       if (inherits(cond, "message")) {
[16:18:40.654]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.654]                         if (muffled) 
[16:18:40.654]                           invokeRestart("muffleMessage")
[16:18:40.654]                       }
[16:18:40.654]                       else if (inherits(cond, "warning")) {
[16:18:40.654]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.654]                         if (muffled) 
[16:18:40.654]                           invokeRestart("muffleWarning")
[16:18:40.654]                       }
[16:18:40.654]                       else if (inherits(cond, "condition")) {
[16:18:40.654]                         if (!is.null(pattern)) {
[16:18:40.654]                           computeRestarts <- base::computeRestarts
[16:18:40.654]                           grepl <- base::grepl
[16:18:40.654]                           restarts <- computeRestarts(cond)
[16:18:40.654]                           for (restart in restarts) {
[16:18:40.654]                             name <- restart$name
[16:18:40.654]                             if (is.null(name)) 
[16:18:40.654]                               next
[16:18:40.654]                             if (!grepl(pattern, name)) 
[16:18:40.654]                               next
[16:18:40.654]                             invokeRestart(restart)
[16:18:40.654]                             muffled <- TRUE
[16:18:40.654]                             break
[16:18:40.654]                           }
[16:18:40.654]                         }
[16:18:40.654]                       }
[16:18:40.654]                       invisible(muffled)
[16:18:40.654]                     }
[16:18:40.654]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.654]                   }
[16:18:40.654]                 }
[16:18:40.654]             }
[16:18:40.654]         }))
[16:18:40.654]     }, error = function(ex) {
[16:18:40.654]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.654]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.654]                 ...future.rng), started = ...future.startTime, 
[16:18:40.654]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.654]             version = "1.8"), class = "FutureResult")
[16:18:40.654]     }, finally = {
[16:18:40.654]         if (!identical(...future.workdir, getwd())) 
[16:18:40.654]             setwd(...future.workdir)
[16:18:40.654]         {
[16:18:40.654]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.654]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.654]             }
[16:18:40.654]             base::options(...future.oldOptions)
[16:18:40.654]             if (.Platform$OS.type == "windows") {
[16:18:40.654]                 old_names <- names(...future.oldEnvVars)
[16:18:40.654]                 envs <- base::Sys.getenv()
[16:18:40.654]                 names <- names(envs)
[16:18:40.654]                 common <- intersect(names, old_names)
[16:18:40.654]                 added <- setdiff(names, old_names)
[16:18:40.654]                 removed <- setdiff(old_names, names)
[16:18:40.654]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.654]                   envs[common]]
[16:18:40.654]                 NAMES <- toupper(changed)
[16:18:40.654]                 args <- list()
[16:18:40.654]                 for (kk in seq_along(NAMES)) {
[16:18:40.654]                   name <- changed[[kk]]
[16:18:40.654]                   NAME <- NAMES[[kk]]
[16:18:40.654]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.654]                     next
[16:18:40.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.654]                 }
[16:18:40.654]                 NAMES <- toupper(added)
[16:18:40.654]                 for (kk in seq_along(NAMES)) {
[16:18:40.654]                   name <- added[[kk]]
[16:18:40.654]                   NAME <- NAMES[[kk]]
[16:18:40.654]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.654]                     next
[16:18:40.654]                   args[[name]] <- ""
[16:18:40.654]                 }
[16:18:40.654]                 NAMES <- toupper(removed)
[16:18:40.654]                 for (kk in seq_along(NAMES)) {
[16:18:40.654]                   name <- removed[[kk]]
[16:18:40.654]                   NAME <- NAMES[[kk]]
[16:18:40.654]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.654]                     next
[16:18:40.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.654]                 }
[16:18:40.654]                 if (length(args) > 0) 
[16:18:40.654]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.654]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.654]             }
[16:18:40.654]             else {
[16:18:40.654]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.654]             }
[16:18:40.654]             {
[16:18:40.654]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.654]                   0L) {
[16:18:40.654]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.654]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.654]                   base::options(opts)
[16:18:40.654]                 }
[16:18:40.654]                 {
[16:18:40.654]                   {
[16:18:40.654]                     base::assign(".Random.seed", c(10407L, -274188662L, 
[16:18:40.654]                     -1232399964L, 1712775263L, -1742123538L, 
[16:18:40.654]                     -1521354978L, -1310549542L), envir = base::globalenv(), 
[16:18:40.654]                       inherits = FALSE)
[16:18:40.654]                     NULL
[16:18:40.654]                   }
[16:18:40.654]                   options(future.plan = NULL)
[16:18:40.654]                   if (is.na(NA_character_)) 
[16:18:40.654]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.654]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.654]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.654]                     .init = FALSE)
[16:18:40.654]                 }
[16:18:40.654]             }
[16:18:40.654]         }
[16:18:40.654]     })
[16:18:40.654]     if (TRUE) {
[16:18:40.654]         base::sink(type = "output", split = FALSE)
[16:18:40.654]         if (TRUE) {
[16:18:40.654]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.654]         }
[16:18:40.654]         else {
[16:18:40.654]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.654]         }
[16:18:40.654]         base::close(...future.stdout)
[16:18:40.654]         ...future.stdout <- NULL
[16:18:40.654]     }
[16:18:40.654]     ...future.result$conditions <- ...future.conditions
[16:18:40.654]     ...future.result$finished <- base::Sys.time()
[16:18:40.654]     ...future.result
[16:18:40.654] }
[16:18:40.656] assign_globals() ...
[16:18:40.656] List of 5
[16:18:40.656]  $ ...future.FUN            :function (x, y)  
[16:18:40.656]  $ MoreArgs                 :List of 1
[16:18:40.656]   ..$ y: int [1:2] 3 4
[16:18:40.656]  $ ...future.elements_ii    :List of 1
[16:18:40.656]   ..$ x:List of 2
[16:18:40.656]   .. ..$ : int 1
[16:18:40.656]   .. ..$ : int 2
[16:18:40.656]  $ ...future.seeds_ii       :List of 2
[16:18:40.656]   ..$ : int [1:7] 10407 2129891359 445267567 1726200652 -562867037 -112604374 -1326167570
[16:18:40.656]   ..$ : int [1:7] 10407 -1480475482 1591460021 1116163698 -159363323 132033995 -500755534
[16:18:40.656]  $ ...future.globals.maxSize: NULL
[16:18:40.656]  - attr(*, "where")=List of 5
[16:18:40.656]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.656]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.656]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.656]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.656]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.656]  - attr(*, "resolved")= logi FALSE
[16:18:40.656]  - attr(*, "total_size")= num 2032
[16:18:40.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.656]  - attr(*, "already-done")= logi TRUE
[16:18:40.662] - reassign environment for ‘...future.FUN’
[16:18:40.662] - copied ‘...future.FUN’ to environment
[16:18:40.662] - copied ‘MoreArgs’ to environment
[16:18:40.662] - copied ‘...future.elements_ii’ to environment
[16:18:40.662] - copied ‘...future.seeds_ii’ to environment
[16:18:40.662] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.663] assign_globals() ... done
[16:18:40.663] plan(): Setting new future strategy stack:
[16:18:40.663] List of future strategies:
[16:18:40.663] 1. sequential:
[16:18:40.663]    - args: function (..., envir = parent.frame())
[16:18:40.663]    - tweaked: FALSE
[16:18:40.663]    - call: NULL
[16:18:40.663] plan(): nbrOfWorkers() = 1
[16:18:40.664] plan(): Setting new future strategy stack:
[16:18:40.664] List of future strategies:
[16:18:40.664] 1. sequential:
[16:18:40.664]    - args: function (..., envir = parent.frame())
[16:18:40.664]    - tweaked: FALSE
[16:18:40.664]    - call: plan(strategy)
[16:18:40.665] plan(): nbrOfWorkers() = 1
[16:18:40.665] SequentialFuture started (and completed)
[16:18:40.665] - Launch lazy future ... done
[16:18:40.665] run() for ‘SequentialFuture’ ... done
[16:18:40.665] Created future:
[16:18:40.665] SequentialFuture:
[16:18:40.665] Label: ‘future_mapply-1’
[16:18:40.665] Expression:
[16:18:40.665] {
[16:18:40.665]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.665]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.665]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.665]         on.exit(options(oopts), add = TRUE)
[16:18:40.665]     }
[16:18:40.665]     {
[16:18:40.665]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:40.665]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[16:18:40.665]                 inherits = FALSE)
[16:18:40.665]             ...future.FUN(...)
[16:18:40.665]         }
[16:18:40.665]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:40.665]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:40.665]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.665]         do.call(mapply, args = args)
[16:18:40.665]     }
[16:18:40.665] }
[16:18:40.665] Lazy evaluation: FALSE
[16:18:40.665] Asynchronous evaluation: FALSE
[16:18:40.665] Local evaluation: TRUE
[16:18:40.665] Environment: R_GlobalEnv
[16:18:40.665] Capture standard output: TRUE
[16:18:40.665] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.665] Globals: 5 objects totaling 1.98 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.665] Packages: <none>
[16:18:40.665] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:18:40.665] Resolved: TRUE
[16:18:40.665] Value: 112 bytes of class ‘list’
[16:18:40.665] Early signaling: FALSE
[16:18:40.665] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.665] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.666] Chunk #1 of 1 ... DONE
[16:18:40.666] Launching 1 futures (chunks) ... DONE
[16:18:40.666] Resolving 1 futures (chunks) ...
[16:18:40.666] resolve() on list ...
[16:18:40.667]  recursive: 0
[16:18:40.667]  length: 1
[16:18:40.667] 
[16:18:40.667] resolved() for ‘SequentialFuture’ ...
[16:18:40.667] - state: ‘finished’
[16:18:40.667] - run: TRUE
[16:18:40.667] - result: ‘FutureResult’
[16:18:40.669] resolved() for ‘SequentialFuture’ ... done
[16:18:40.670] Future #1
[16:18:40.670] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.670] - nx: 1
[16:18:40.670] - relay: TRUE
[16:18:40.670] - stdout: TRUE
[16:18:40.670] - signal: TRUE
[16:18:40.670] - resignal: FALSE
[16:18:40.670] - force: TRUE
[16:18:40.671] - relayed: [n=1] FALSE
[16:18:40.671] - queued futures: [n=1] FALSE
[16:18:40.671]  - until=1
[16:18:40.671]  - relaying element #1
[16:18:40.671] - relayed: [n=1] TRUE
[16:18:40.671] - queued futures: [n=1] TRUE
[16:18:40.671] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.671]  length: 0 (resolved future 1)
[16:18:40.672] Relaying remaining futures
[16:18:40.672] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.672] - nx: 1
[16:18:40.672] - relay: TRUE
[16:18:40.672] - stdout: TRUE
[16:18:40.672] - signal: TRUE
[16:18:40.672] - resignal: FALSE
[16:18:40.672] - force: TRUE
[16:18:40.672] - relayed: [n=1] TRUE
[16:18:40.672] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.673] - relayed: [n=1] TRUE
[16:18:40.673] - queued futures: [n=1] TRUE
[16:18:40.673] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.673] resolve() on list ... DONE
[16:18:40.673]  - Number of value chunks collected: 1
[16:18:40.673] Resolving 1 futures (chunks) ... DONE
[16:18:40.673] Reducing values from 1 chunks ...
[16:18:40.673]  - Number of values collected after concatenation: 2
[16:18:40.673]  - Number of values expected: 2
[16:18:40.673] Reducing values from 1 chunks ... DONE
[16:18:40.674] future_mapply() ... DONE
[16:18:40.674] future_mapply() ...
[16:18:40.674] Number of chunks: 1
[16:18:40.674] getGlobalsAndPackagesXApply() ...
[16:18:40.674]  - future.globals: TRUE
[16:18:40.674] getGlobalsAndPackages() ...
[16:18:40.674] Searching for globals...
[16:18:40.675] - globals found: [1] ‘FUN’
[16:18:40.675] Searching for globals ... DONE
[16:18:40.676] Resolving globals: FALSE
[16:18:40.676] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[16:18:40.676] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[16:18:40.676] - globals: [1] ‘FUN’
[16:18:40.676] 
[16:18:40.677] getGlobalsAndPackages() ... DONE
[16:18:40.677]  - globals found/used: [n=1] ‘FUN’
[16:18:40.677]  - needed namespaces: [n=0] 
[16:18:40.677] Finding globals ... DONE
[16:18:40.677] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.677] List of 2
[16:18:40.677]  $ ...future.FUN:function (x, y)  
[16:18:40.677]  $ MoreArgs     :List of 1
[16:18:40.677]   ..$ y: int [1:2] 3 4
[16:18:40.677]  - attr(*, "where")=List of 2
[16:18:40.677]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.677]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.677]  - attr(*, "resolved")= logi FALSE
[16:18:40.677]  - attr(*, "total_size")= num NA
[16:18:40.680] Packages to be attached in all futures: [n=0] 
[16:18:40.680] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.680] Number of futures (= number of chunks): 1
[16:18:40.680] Launching 1 futures (chunks) ...
[16:18:40.681] Chunk #1 of 1 ...
[16:18:40.681]  - Finding globals in '...' for chunk #1 ...
[16:18:40.681] getGlobalsAndPackages() ...
[16:18:40.681] Searching for globals...
[16:18:40.681] 
[16:18:40.681] Searching for globals ... DONE
[16:18:40.681] - globals: [0] <none>
[16:18:40.681] getGlobalsAndPackages() ... DONE
[16:18:40.682]    + additional globals found: [n=0] 
[16:18:40.682]    + additional namespaces needed: [n=0] 
[16:18:40.682]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.682]  - seeds: <none>
[16:18:40.682]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.682] getGlobalsAndPackages() ...
[16:18:40.682] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.682] Resolving globals: FALSE
[16:18:40.683] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[16:18:40.683] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[16:18:40.683] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.683] 
[16:18:40.684] getGlobalsAndPackages() ... DONE
[16:18:40.684] run() for ‘Future’ ...
[16:18:40.684] - state: ‘created’
[16:18:40.684] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.684] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.684] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.685]   - Field: ‘label’
[16:18:40.685]   - Field: ‘local’
[16:18:40.685]   - Field: ‘owner’
[16:18:40.685]   - Field: ‘envir’
[16:18:40.685]   - Field: ‘packages’
[16:18:40.685]   - Field: ‘gc’
[16:18:40.685]   - Field: ‘conditions’
[16:18:40.685]   - Field: ‘expr’
[16:18:40.685]   - Field: ‘uuid’
[16:18:40.685]   - Field: ‘seed’
[16:18:40.686]   - Field: ‘version’
[16:18:40.686]   - Field: ‘result’
[16:18:40.686]   - Field: ‘asynchronous’
[16:18:40.686]   - Field: ‘calls’
[16:18:40.686]   - Field: ‘globals’
[16:18:40.686]   - Field: ‘stdout’
[16:18:40.686]   - Field: ‘earlySignal’
[16:18:40.686]   - Field: ‘lazy’
[16:18:40.686]   - Field: ‘state’
[16:18:40.686] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.686] - Launch lazy future ...
[16:18:40.687] Packages needed by the future expression (n = 0): <none>
[16:18:40.687] Packages needed by future strategies (n = 0): <none>
[16:18:40.687] {
[16:18:40.687]     {
[16:18:40.687]         {
[16:18:40.687]             ...future.startTime <- base::Sys.time()
[16:18:40.687]             {
[16:18:40.687]                 {
[16:18:40.687]                   {
[16:18:40.687]                     base::local({
[16:18:40.687]                       has_future <- base::requireNamespace("future", 
[16:18:40.687]                         quietly = TRUE)
[16:18:40.687]                       if (has_future) {
[16:18:40.687]                         ns <- base::getNamespace("future")
[16:18:40.687]                         version <- ns[[".package"]][["version"]]
[16:18:40.687]                         if (is.null(version)) 
[16:18:40.687]                           version <- utils::packageVersion("future")
[16:18:40.687]                       }
[16:18:40.687]                       else {
[16:18:40.687]                         version <- NULL
[16:18:40.687]                       }
[16:18:40.687]                       if (!has_future || version < "1.8.0") {
[16:18:40.687]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.687]                           "", base::R.version$version.string), 
[16:18:40.687]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.687]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.687]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.687]                             "release", "version")], collapse = " "), 
[16:18:40.687]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.687]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.687]                           info)
[16:18:40.687]                         info <- base::paste(info, collapse = "; ")
[16:18:40.687]                         if (!has_future) {
[16:18:40.687]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.687]                             info)
[16:18:40.687]                         }
[16:18:40.687]                         else {
[16:18:40.687]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.687]                             info, version)
[16:18:40.687]                         }
[16:18:40.687]                         base::stop(msg)
[16:18:40.687]                       }
[16:18:40.687]                     })
[16:18:40.687]                   }
[16:18:40.687]                   ...future.strategy.old <- future::plan("list")
[16:18:40.687]                   options(future.plan = NULL)
[16:18:40.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.687]                 }
[16:18:40.687]                 ...future.workdir <- getwd()
[16:18:40.687]             }
[16:18:40.687]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.687]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.687]         }
[16:18:40.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.687]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.687]             base::names(...future.oldOptions))
[16:18:40.687]     }
[16:18:40.687]     if (FALSE) {
[16:18:40.687]     }
[16:18:40.687]     else {
[16:18:40.687]         if (TRUE) {
[16:18:40.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.687]                 open = "w")
[16:18:40.687]         }
[16:18:40.687]         else {
[16:18:40.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.687]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.687]         }
[16:18:40.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.687]             base::sink(type = "output", split = FALSE)
[16:18:40.687]             base::close(...future.stdout)
[16:18:40.687]         }, add = TRUE)
[16:18:40.687]     }
[16:18:40.687]     ...future.frame <- base::sys.nframe()
[16:18:40.687]     ...future.conditions <- base::list()
[16:18:40.687]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.687]     if (FALSE) {
[16:18:40.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.687]     }
[16:18:40.687]     ...future.result <- base::tryCatch({
[16:18:40.687]         base::withCallingHandlers({
[16:18:40.687]             ...future.value <- base::withVisible(base::local({
[16:18:40.687]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.687]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.687]                   ...future.globals.maxSize)) {
[16:18:40.687]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.687]                   on.exit(options(oopts), add = TRUE)
[16:18:40.687]                 }
[16:18:40.687]                 {
[16:18:40.687]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.687]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.687]                     USE.NAMES = FALSE)
[16:18:40.687]                   do.call(mapply, args = args)
[16:18:40.687]                 }
[16:18:40.687]             }))
[16:18:40.687]             future::FutureResult(value = ...future.value$value, 
[16:18:40.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.687]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.687]                     ...future.globalenv.names))
[16:18:40.687]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.687]         }, condition = base::local({
[16:18:40.687]             c <- base::c
[16:18:40.687]             inherits <- base::inherits
[16:18:40.687]             invokeRestart <- base::invokeRestart
[16:18:40.687]             length <- base::length
[16:18:40.687]             list <- base::list
[16:18:40.687]             seq.int <- base::seq.int
[16:18:40.687]             signalCondition <- base::signalCondition
[16:18:40.687]             sys.calls <- base::sys.calls
[16:18:40.687]             `[[` <- base::`[[`
[16:18:40.687]             `+` <- base::`+`
[16:18:40.687]             `<<-` <- base::`<<-`
[16:18:40.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.687]                   3L)]
[16:18:40.687]             }
[16:18:40.687]             function(cond) {
[16:18:40.687]                 is_error <- inherits(cond, "error")
[16:18:40.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.687]                   NULL)
[16:18:40.687]                 if (is_error) {
[16:18:40.687]                   sessionInformation <- function() {
[16:18:40.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.687]                       search = base::search(), system = base::Sys.info())
[16:18:40.687]                   }
[16:18:40.687]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.687]                     cond$call), session = sessionInformation(), 
[16:18:40.687]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.687]                   signalCondition(cond)
[16:18:40.687]                 }
[16:18:40.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.687]                 "immediateCondition"))) {
[16:18:40.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.687]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.687]                   if (TRUE && !signal) {
[16:18:40.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.687]                     {
[16:18:40.687]                       inherits <- base::inherits
[16:18:40.687]                       invokeRestart <- base::invokeRestart
[16:18:40.687]                       is.null <- base::is.null
[16:18:40.687]                       muffled <- FALSE
[16:18:40.687]                       if (inherits(cond, "message")) {
[16:18:40.687]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.687]                         if (muffled) 
[16:18:40.687]                           invokeRestart("muffleMessage")
[16:18:40.687]                       }
[16:18:40.687]                       else if (inherits(cond, "warning")) {
[16:18:40.687]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.687]                         if (muffled) 
[16:18:40.687]                           invokeRestart("muffleWarning")
[16:18:40.687]                       }
[16:18:40.687]                       else if (inherits(cond, "condition")) {
[16:18:40.687]                         if (!is.null(pattern)) {
[16:18:40.687]                           computeRestarts <- base::computeRestarts
[16:18:40.687]                           grepl <- base::grepl
[16:18:40.687]                           restarts <- computeRestarts(cond)
[16:18:40.687]                           for (restart in restarts) {
[16:18:40.687]                             name <- restart$name
[16:18:40.687]                             if (is.null(name)) 
[16:18:40.687]                               next
[16:18:40.687]                             if (!grepl(pattern, name)) 
[16:18:40.687]                               next
[16:18:40.687]                             invokeRestart(restart)
[16:18:40.687]                             muffled <- TRUE
[16:18:40.687]                             break
[16:18:40.687]                           }
[16:18:40.687]                         }
[16:18:40.687]                       }
[16:18:40.687]                       invisible(muffled)
[16:18:40.687]                     }
[16:18:40.687]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.687]                   }
[16:18:40.687]                 }
[16:18:40.687]                 else {
[16:18:40.687]                   if (TRUE) {
[16:18:40.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.687]                     {
[16:18:40.687]                       inherits <- base::inherits
[16:18:40.687]                       invokeRestart <- base::invokeRestart
[16:18:40.687]                       is.null <- base::is.null
[16:18:40.687]                       muffled <- FALSE
[16:18:40.687]                       if (inherits(cond, "message")) {
[16:18:40.687]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.687]                         if (muffled) 
[16:18:40.687]                           invokeRestart("muffleMessage")
[16:18:40.687]                       }
[16:18:40.687]                       else if (inherits(cond, "warning")) {
[16:18:40.687]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.687]                         if (muffled) 
[16:18:40.687]                           invokeRestart("muffleWarning")
[16:18:40.687]                       }
[16:18:40.687]                       else if (inherits(cond, "condition")) {
[16:18:40.687]                         if (!is.null(pattern)) {
[16:18:40.687]                           computeRestarts <- base::computeRestarts
[16:18:40.687]                           grepl <- base::grepl
[16:18:40.687]                           restarts <- computeRestarts(cond)
[16:18:40.687]                           for (restart in restarts) {
[16:18:40.687]                             name <- restart$name
[16:18:40.687]                             if (is.null(name)) 
[16:18:40.687]                               next
[16:18:40.687]                             if (!grepl(pattern, name)) 
[16:18:40.687]                               next
[16:18:40.687]                             invokeRestart(restart)
[16:18:40.687]                             muffled <- TRUE
[16:18:40.687]                             break
[16:18:40.687]                           }
[16:18:40.687]                         }
[16:18:40.687]                       }
[16:18:40.687]                       invisible(muffled)
[16:18:40.687]                     }
[16:18:40.687]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.687]                   }
[16:18:40.687]                 }
[16:18:40.687]             }
[16:18:40.687]         }))
[16:18:40.687]     }, error = function(ex) {
[16:18:40.687]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.687]                 ...future.rng), started = ...future.startTime, 
[16:18:40.687]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.687]             version = "1.8"), class = "FutureResult")
[16:18:40.687]     }, finally = {
[16:18:40.687]         if (!identical(...future.workdir, getwd())) 
[16:18:40.687]             setwd(...future.workdir)
[16:18:40.687]         {
[16:18:40.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.687]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.687]             }
[16:18:40.687]             base::options(...future.oldOptions)
[16:18:40.687]             if (.Platform$OS.type == "windows") {
[16:18:40.687]                 old_names <- names(...future.oldEnvVars)
[16:18:40.687]                 envs <- base::Sys.getenv()
[16:18:40.687]                 names <- names(envs)
[16:18:40.687]                 common <- intersect(names, old_names)
[16:18:40.687]                 added <- setdiff(names, old_names)
[16:18:40.687]                 removed <- setdiff(old_names, names)
[16:18:40.687]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.687]                   envs[common]]
[16:18:40.687]                 NAMES <- toupper(changed)
[16:18:40.687]                 args <- list()
[16:18:40.687]                 for (kk in seq_along(NAMES)) {
[16:18:40.687]                   name <- changed[[kk]]
[16:18:40.687]                   NAME <- NAMES[[kk]]
[16:18:40.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.687]                     next
[16:18:40.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.687]                 }
[16:18:40.687]                 NAMES <- toupper(added)
[16:18:40.687]                 for (kk in seq_along(NAMES)) {
[16:18:40.687]                   name <- added[[kk]]
[16:18:40.687]                   NAME <- NAMES[[kk]]
[16:18:40.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.687]                     next
[16:18:40.687]                   args[[name]] <- ""
[16:18:40.687]                 }
[16:18:40.687]                 NAMES <- toupper(removed)
[16:18:40.687]                 for (kk in seq_along(NAMES)) {
[16:18:40.687]                   name <- removed[[kk]]
[16:18:40.687]                   NAME <- NAMES[[kk]]
[16:18:40.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.687]                     next
[16:18:40.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.687]                 }
[16:18:40.687]                 if (length(args) > 0) 
[16:18:40.687]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.687]             }
[16:18:40.687]             else {
[16:18:40.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.687]             }
[16:18:40.687]             {
[16:18:40.687]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.687]                   0L) {
[16:18:40.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.687]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.687]                   base::options(opts)
[16:18:40.687]                 }
[16:18:40.687]                 {
[16:18:40.687]                   {
[16:18:40.687]                     base::assign(".Random.seed", c(10407L, -274188662L, 
[16:18:40.687]                     -1232399964L, 1712775263L, -1742123538L, 
[16:18:40.687]                     -1521354978L, -1310549542L), envir = base::globalenv(), 
[16:18:40.687]                       inherits = FALSE)
[16:18:40.687]                     NULL
[16:18:40.687]                   }
[16:18:40.687]                   options(future.plan = NULL)
[16:18:40.687]                   if (is.na(NA_character_)) 
[16:18:40.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.687]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.687]                     .init = FALSE)
[16:18:40.687]                 }
[16:18:40.687]             }
[16:18:40.687]         }
[16:18:40.687]     })
[16:18:40.687]     if (TRUE) {
[16:18:40.687]         base::sink(type = "output", split = FALSE)
[16:18:40.687]         if (TRUE) {
[16:18:40.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.687]         }
[16:18:40.687]         else {
[16:18:40.687]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.687]         }
[16:18:40.687]         base::close(...future.stdout)
[16:18:40.687]         ...future.stdout <- NULL
[16:18:40.687]     }
[16:18:40.687]     ...future.result$conditions <- ...future.conditions
[16:18:40.687]     ...future.result$finished <- base::Sys.time()
[16:18:40.687]     ...future.result
[16:18:40.687] }
[16:18:40.689] assign_globals() ...
[16:18:40.689] List of 5
[16:18:40.689]  $ ...future.FUN            :function (x, y)  
[16:18:40.689]  $ MoreArgs                 :List of 1
[16:18:40.689]   ..$ y: int [1:2] 3 4
[16:18:40.689]  $ ...future.elements_ii    :List of 1
[16:18:40.689]   ..$ x:List of 2
[16:18:40.689]   .. ..$ : int 1
[16:18:40.689]   .. ..$ : int 2
[16:18:40.689]  $ ...future.seeds_ii       : NULL
[16:18:40.689]  $ ...future.globals.maxSize: NULL
[16:18:40.689]  - attr(*, "where")=List of 5
[16:18:40.689]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.689]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.689]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.689]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.689]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.689]  - attr(*, "resolved")= logi FALSE
[16:18:40.689]  - attr(*, "total_size")= num 1872
[16:18:40.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.689]  - attr(*, "already-done")= logi TRUE
[16:18:40.697] - reassign environment for ‘...future.FUN’
[16:18:40.697] - copied ‘...future.FUN’ to environment
[16:18:40.697] - copied ‘MoreArgs’ to environment
[16:18:40.697] - copied ‘...future.elements_ii’ to environment
[16:18:40.697] - copied ‘...future.seeds_ii’ to environment
[16:18:40.697] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.697] assign_globals() ... done
[16:18:40.698] plan(): Setting new future strategy stack:
[16:18:40.698] List of future strategies:
[16:18:40.698] 1. sequential:
[16:18:40.698]    - args: function (..., envir = parent.frame())
[16:18:40.698]    - tweaked: FALSE
[16:18:40.698]    - call: NULL
[16:18:40.698] plan(): nbrOfWorkers() = 1
[16:18:40.699] plan(): Setting new future strategy stack:
[16:18:40.699] List of future strategies:
[16:18:40.699] 1. sequential:
[16:18:40.699]    - args: function (..., envir = parent.frame())
[16:18:40.699]    - tweaked: FALSE
[16:18:40.699]    - call: plan(strategy)
[16:18:40.699] plan(): nbrOfWorkers() = 1
[16:18:40.699] SequentialFuture started (and completed)
[16:18:40.700] - Launch lazy future ... done
[16:18:40.700] run() for ‘SequentialFuture’ ... done
[16:18:40.700] Created future:
[16:18:40.700] SequentialFuture:
[16:18:40.700] Label: ‘future_.mapply-1’
[16:18:40.700] Expression:
[16:18:40.700] {
[16:18:40.700]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.700]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.700]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.700]         on.exit(options(oopts), add = TRUE)
[16:18:40.700]     }
[16:18:40.700]     {
[16:18:40.700]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.700]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.700]         do.call(mapply, args = args)
[16:18:40.700]     }
[16:18:40.700] }
[16:18:40.700] Lazy evaluation: FALSE
[16:18:40.700] Asynchronous evaluation: FALSE
[16:18:40.700] Local evaluation: TRUE
[16:18:40.700] Environment: R_GlobalEnv
[16:18:40.700] Capture standard output: TRUE
[16:18:40.700] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.700] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.700] Packages: <none>
[16:18:40.700] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.700] Resolved: TRUE
[16:18:40.700] Value: 112 bytes of class ‘list’
[16:18:40.700] Early signaling: FALSE
[16:18:40.700] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.700] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.701] Chunk #1 of 1 ... DONE
[16:18:40.701] Launching 1 futures (chunks) ... DONE
[16:18:40.701] Resolving 1 futures (chunks) ...
[16:18:40.701] resolve() on list ...
[16:18:40.701]  recursive: 0
[16:18:40.701]  length: 1
[16:18:40.701] 
[16:18:40.702] resolved() for ‘SequentialFuture’ ...
[16:18:40.702] - state: ‘finished’
[16:18:40.702] - run: TRUE
[16:18:40.702] - result: ‘FutureResult’
[16:18:40.702] resolved() for ‘SequentialFuture’ ... done
[16:18:40.702] Future #1
[16:18:40.702] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.702] - nx: 1
[16:18:40.702] - relay: TRUE
[16:18:40.702] - stdout: TRUE
[16:18:40.703] - signal: TRUE
[16:18:40.703] - resignal: FALSE
[16:18:40.703] - force: TRUE
[16:18:40.703] - relayed: [n=1] FALSE
[16:18:40.703] - queued futures: [n=1] FALSE
[16:18:40.703]  - until=1
[16:18:40.703]  - relaying element #1
[16:18:40.703] - relayed: [n=1] TRUE
[16:18:40.703] - queued futures: [n=1] TRUE
[16:18:40.703] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.704]  length: 0 (resolved future 1)
[16:18:40.704] Relaying remaining futures
[16:18:40.704] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.704] - nx: 1
[16:18:40.704] - relay: TRUE
[16:18:40.704] - stdout: TRUE
[16:18:40.704] - signal: TRUE
[16:18:40.704] - resignal: FALSE
[16:18:40.704] - force: TRUE
[16:18:40.704] - relayed: [n=1] TRUE
[16:18:40.704] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.705] - relayed: [n=1] TRUE
[16:18:40.705] - queued futures: [n=1] TRUE
[16:18:40.705] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.705] resolve() on list ... DONE
[16:18:40.705]  - Number of value chunks collected: 1
[16:18:40.705] Resolving 1 futures (chunks) ... DONE
[16:18:40.705] Reducing values from 1 chunks ...
[16:18:40.705]  - Number of values collected after concatenation: 2
[16:18:40.705]  - Number of values expected: 2
[16:18:40.706] Reducing values from 1 chunks ... DONE
[16:18:40.706] future_mapply() ... DONE
- Recycle arguments to same length ...
[16:18:40.706] future_mapply() ...
[16:18:40.706] Number of chunks: 1
[16:18:40.706] getGlobalsAndPackagesXApply() ...
[16:18:40.706]  - future.globals: TRUE
[16:18:40.706] getGlobalsAndPackages() ...
[16:18:40.706] Searching for globals...
[16:18:40.707] - globals found: [1] ‘FUN’
[16:18:40.707] Searching for globals ... DONE
[16:18:40.707] Resolving globals: FALSE
[16:18:40.708] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:40.708] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:40.708] - globals: [1] ‘FUN’
[16:18:40.708] 
[16:18:40.708] getGlobalsAndPackages() ... DONE
[16:18:40.708]  - globals found/used: [n=1] ‘FUN’
[16:18:40.708]  - needed namespaces: [n=0] 
[16:18:40.709] Finding globals ... DONE
[16:18:40.709] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.709] List of 2
[16:18:40.709]  $ ...future.FUN:function (x, ...)  
[16:18:40.709]  $ MoreArgs     : NULL
[16:18:40.709]  - attr(*, "where")=List of 2
[16:18:40.709]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.709]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.709]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.709]  - attr(*, "resolved")= logi FALSE
[16:18:40.709]  - attr(*, "total_size")= num NA
[16:18:40.711] Packages to be attached in all futures: [n=0] 
[16:18:40.711] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.712] Number of futures (= number of chunks): 1
[16:18:40.712] Launching 1 futures (chunks) ...
[16:18:40.712] Chunk #1 of 1 ...
[16:18:40.712]  - Finding globals in '...' for chunk #1 ...
[16:18:40.712] getGlobalsAndPackages() ...
[16:18:40.712] Searching for globals...
[16:18:40.713] 
[16:18:40.713] Searching for globals ... DONE
[16:18:40.713] - globals: [0] <none>
[16:18:40.713] getGlobalsAndPackages() ... DONE
[16:18:40.713]    + additional globals found: [n=0] 
[16:18:40.713]    + additional namespaces needed: [n=0] 
[16:18:40.713]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.713]  - seeds: <none>
[16:18:40.713]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.713] getGlobalsAndPackages() ...
[16:18:40.714] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.714] Resolving globals: FALSE
[16:18:40.714] The total size of the 5 globals is 504 bytes (504 bytes)
[16:18:40.715] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.715] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.717] 
[16:18:40.717] getGlobalsAndPackages() ... DONE
[16:18:40.717] run() for ‘Future’ ...
[16:18:40.718] - state: ‘created’
[16:18:40.718] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.718] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.718] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.718]   - Field: ‘label’
[16:18:40.718]   - Field: ‘local’
[16:18:40.719]   - Field: ‘owner’
[16:18:40.719]   - Field: ‘envir’
[16:18:40.719]   - Field: ‘packages’
[16:18:40.719]   - Field: ‘gc’
[16:18:40.719]   - Field: ‘conditions’
[16:18:40.719]   - Field: ‘expr’
[16:18:40.719]   - Field: ‘uuid’
[16:18:40.719]   - Field: ‘seed’
[16:18:40.719]   - Field: ‘version’
[16:18:40.720]   - Field: ‘result’
[16:18:40.720]   - Field: ‘asynchronous’
[16:18:40.720]   - Field: ‘calls’
[16:18:40.720]   - Field: ‘globals’
[16:18:40.720]   - Field: ‘stdout’
[16:18:40.720]   - Field: ‘earlySignal’
[16:18:40.720]   - Field: ‘lazy’
[16:18:40.720]   - Field: ‘state’
[16:18:40.720] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.720] - Launch lazy future ...
[16:18:40.721] Packages needed by the future expression (n = 0): <none>
[16:18:40.721] Packages needed by future strategies (n = 0): <none>
[16:18:40.721] {
[16:18:40.721]     {
[16:18:40.721]         {
[16:18:40.721]             ...future.startTime <- base::Sys.time()
[16:18:40.721]             {
[16:18:40.721]                 {
[16:18:40.721]                   {
[16:18:40.721]                     base::local({
[16:18:40.721]                       has_future <- base::requireNamespace("future", 
[16:18:40.721]                         quietly = TRUE)
[16:18:40.721]                       if (has_future) {
[16:18:40.721]                         ns <- base::getNamespace("future")
[16:18:40.721]                         version <- ns[[".package"]][["version"]]
[16:18:40.721]                         if (is.null(version)) 
[16:18:40.721]                           version <- utils::packageVersion("future")
[16:18:40.721]                       }
[16:18:40.721]                       else {
[16:18:40.721]                         version <- NULL
[16:18:40.721]                       }
[16:18:40.721]                       if (!has_future || version < "1.8.0") {
[16:18:40.721]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.721]                           "", base::R.version$version.string), 
[16:18:40.721]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.721]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.721]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.721]                             "release", "version")], collapse = " "), 
[16:18:40.721]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.721]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.721]                           info)
[16:18:40.721]                         info <- base::paste(info, collapse = "; ")
[16:18:40.721]                         if (!has_future) {
[16:18:40.721]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.721]                             info)
[16:18:40.721]                         }
[16:18:40.721]                         else {
[16:18:40.721]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.721]                             info, version)
[16:18:40.721]                         }
[16:18:40.721]                         base::stop(msg)
[16:18:40.721]                       }
[16:18:40.721]                     })
[16:18:40.721]                   }
[16:18:40.721]                   ...future.strategy.old <- future::plan("list")
[16:18:40.721]                   options(future.plan = NULL)
[16:18:40.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.721]                 }
[16:18:40.721]                 ...future.workdir <- getwd()
[16:18:40.721]             }
[16:18:40.721]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.721]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.721]         }
[16:18:40.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.721]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.721]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.721]             base::names(...future.oldOptions))
[16:18:40.721]     }
[16:18:40.721]     if (FALSE) {
[16:18:40.721]     }
[16:18:40.721]     else {
[16:18:40.721]         if (TRUE) {
[16:18:40.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.721]                 open = "w")
[16:18:40.721]         }
[16:18:40.721]         else {
[16:18:40.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.721]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.721]         }
[16:18:40.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.721]             base::sink(type = "output", split = FALSE)
[16:18:40.721]             base::close(...future.stdout)
[16:18:40.721]         }, add = TRUE)
[16:18:40.721]     }
[16:18:40.721]     ...future.frame <- base::sys.nframe()
[16:18:40.721]     ...future.conditions <- base::list()
[16:18:40.721]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.721]     if (FALSE) {
[16:18:40.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.721]     }
[16:18:40.721]     ...future.result <- base::tryCatch({
[16:18:40.721]         base::withCallingHandlers({
[16:18:40.721]             ...future.value <- base::withVisible(base::local({
[16:18:40.721]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.721]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.721]                   ...future.globals.maxSize)) {
[16:18:40.721]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.721]                   on.exit(options(oopts), add = TRUE)
[16:18:40.721]                 }
[16:18:40.721]                 {
[16:18:40.721]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.721]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.721]                     USE.NAMES = FALSE)
[16:18:40.721]                   do.call(mapply, args = args)
[16:18:40.721]                 }
[16:18:40.721]             }))
[16:18:40.721]             future::FutureResult(value = ...future.value$value, 
[16:18:40.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.721]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.721]                     ...future.globalenv.names))
[16:18:40.721]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.721]         }, condition = base::local({
[16:18:40.721]             c <- base::c
[16:18:40.721]             inherits <- base::inherits
[16:18:40.721]             invokeRestart <- base::invokeRestart
[16:18:40.721]             length <- base::length
[16:18:40.721]             list <- base::list
[16:18:40.721]             seq.int <- base::seq.int
[16:18:40.721]             signalCondition <- base::signalCondition
[16:18:40.721]             sys.calls <- base::sys.calls
[16:18:40.721]             `[[` <- base::`[[`
[16:18:40.721]             `+` <- base::`+`
[16:18:40.721]             `<<-` <- base::`<<-`
[16:18:40.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.721]                   3L)]
[16:18:40.721]             }
[16:18:40.721]             function(cond) {
[16:18:40.721]                 is_error <- inherits(cond, "error")
[16:18:40.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.721]                   NULL)
[16:18:40.721]                 if (is_error) {
[16:18:40.721]                   sessionInformation <- function() {
[16:18:40.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.721]                       search = base::search(), system = base::Sys.info())
[16:18:40.721]                   }
[16:18:40.721]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.721]                     cond$call), session = sessionInformation(), 
[16:18:40.721]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.721]                   signalCondition(cond)
[16:18:40.721]                 }
[16:18:40.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.721]                 "immediateCondition"))) {
[16:18:40.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.721]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.721]                   if (TRUE && !signal) {
[16:18:40.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.721]                     {
[16:18:40.721]                       inherits <- base::inherits
[16:18:40.721]                       invokeRestart <- base::invokeRestart
[16:18:40.721]                       is.null <- base::is.null
[16:18:40.721]                       muffled <- FALSE
[16:18:40.721]                       if (inherits(cond, "message")) {
[16:18:40.721]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.721]                         if (muffled) 
[16:18:40.721]                           invokeRestart("muffleMessage")
[16:18:40.721]                       }
[16:18:40.721]                       else if (inherits(cond, "warning")) {
[16:18:40.721]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.721]                         if (muffled) 
[16:18:40.721]                           invokeRestart("muffleWarning")
[16:18:40.721]                       }
[16:18:40.721]                       else if (inherits(cond, "condition")) {
[16:18:40.721]                         if (!is.null(pattern)) {
[16:18:40.721]                           computeRestarts <- base::computeRestarts
[16:18:40.721]                           grepl <- base::grepl
[16:18:40.721]                           restarts <- computeRestarts(cond)
[16:18:40.721]                           for (restart in restarts) {
[16:18:40.721]                             name <- restart$name
[16:18:40.721]                             if (is.null(name)) 
[16:18:40.721]                               next
[16:18:40.721]                             if (!grepl(pattern, name)) 
[16:18:40.721]                               next
[16:18:40.721]                             invokeRestart(restart)
[16:18:40.721]                             muffled <- TRUE
[16:18:40.721]                             break
[16:18:40.721]                           }
[16:18:40.721]                         }
[16:18:40.721]                       }
[16:18:40.721]                       invisible(muffled)
[16:18:40.721]                     }
[16:18:40.721]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.721]                   }
[16:18:40.721]                 }
[16:18:40.721]                 else {
[16:18:40.721]                   if (TRUE) {
[16:18:40.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.721]                     {
[16:18:40.721]                       inherits <- base::inherits
[16:18:40.721]                       invokeRestart <- base::invokeRestart
[16:18:40.721]                       is.null <- base::is.null
[16:18:40.721]                       muffled <- FALSE
[16:18:40.721]                       if (inherits(cond, "message")) {
[16:18:40.721]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.721]                         if (muffled) 
[16:18:40.721]                           invokeRestart("muffleMessage")
[16:18:40.721]                       }
[16:18:40.721]                       else if (inherits(cond, "warning")) {
[16:18:40.721]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.721]                         if (muffled) 
[16:18:40.721]                           invokeRestart("muffleWarning")
[16:18:40.721]                       }
[16:18:40.721]                       else if (inherits(cond, "condition")) {
[16:18:40.721]                         if (!is.null(pattern)) {
[16:18:40.721]                           computeRestarts <- base::computeRestarts
[16:18:40.721]                           grepl <- base::grepl
[16:18:40.721]                           restarts <- computeRestarts(cond)
[16:18:40.721]                           for (restart in restarts) {
[16:18:40.721]                             name <- restart$name
[16:18:40.721]                             if (is.null(name)) 
[16:18:40.721]                               next
[16:18:40.721]                             if (!grepl(pattern, name)) 
[16:18:40.721]                               next
[16:18:40.721]                             invokeRestart(restart)
[16:18:40.721]                             muffled <- TRUE
[16:18:40.721]                             break
[16:18:40.721]                           }
[16:18:40.721]                         }
[16:18:40.721]                       }
[16:18:40.721]                       invisible(muffled)
[16:18:40.721]                     }
[16:18:40.721]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.721]                   }
[16:18:40.721]                 }
[16:18:40.721]             }
[16:18:40.721]         }))
[16:18:40.721]     }, error = function(ex) {
[16:18:40.721]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.721]                 ...future.rng), started = ...future.startTime, 
[16:18:40.721]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.721]             version = "1.8"), class = "FutureResult")
[16:18:40.721]     }, finally = {
[16:18:40.721]         if (!identical(...future.workdir, getwd())) 
[16:18:40.721]             setwd(...future.workdir)
[16:18:40.721]         {
[16:18:40.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.721]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.721]             }
[16:18:40.721]             base::options(...future.oldOptions)
[16:18:40.721]             if (.Platform$OS.type == "windows") {
[16:18:40.721]                 old_names <- names(...future.oldEnvVars)
[16:18:40.721]                 envs <- base::Sys.getenv()
[16:18:40.721]                 names <- names(envs)
[16:18:40.721]                 common <- intersect(names, old_names)
[16:18:40.721]                 added <- setdiff(names, old_names)
[16:18:40.721]                 removed <- setdiff(old_names, names)
[16:18:40.721]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.721]                   envs[common]]
[16:18:40.721]                 NAMES <- toupper(changed)
[16:18:40.721]                 args <- list()
[16:18:40.721]                 for (kk in seq_along(NAMES)) {
[16:18:40.721]                   name <- changed[[kk]]
[16:18:40.721]                   NAME <- NAMES[[kk]]
[16:18:40.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.721]                     next
[16:18:40.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.721]                 }
[16:18:40.721]                 NAMES <- toupper(added)
[16:18:40.721]                 for (kk in seq_along(NAMES)) {
[16:18:40.721]                   name <- added[[kk]]
[16:18:40.721]                   NAME <- NAMES[[kk]]
[16:18:40.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.721]                     next
[16:18:40.721]                   args[[name]] <- ""
[16:18:40.721]                 }
[16:18:40.721]                 NAMES <- toupper(removed)
[16:18:40.721]                 for (kk in seq_along(NAMES)) {
[16:18:40.721]                   name <- removed[[kk]]
[16:18:40.721]                   NAME <- NAMES[[kk]]
[16:18:40.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.721]                     next
[16:18:40.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.721]                 }
[16:18:40.721]                 if (length(args) > 0) 
[16:18:40.721]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.721]             }
[16:18:40.721]             else {
[16:18:40.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.721]             }
[16:18:40.721]             {
[16:18:40.721]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.721]                   0L) {
[16:18:40.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.721]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.721]                   base::options(opts)
[16:18:40.721]                 }
[16:18:40.721]                 {
[16:18:40.721]                   {
[16:18:40.721]                     base::assign(".Random.seed", c(10407L, -274188662L, 
[16:18:40.721]                     -1232399964L, 1712775263L, -1742123538L, 
[16:18:40.721]                     -1521354978L, -1310549542L), envir = base::globalenv(), 
[16:18:40.721]                       inherits = FALSE)
[16:18:40.721]                     NULL
[16:18:40.721]                   }
[16:18:40.721]                   options(future.plan = NULL)
[16:18:40.721]                   if (is.na(NA_character_)) 
[16:18:40.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.721]                     .init = FALSE)
[16:18:40.721]                 }
[16:18:40.721]             }
[16:18:40.721]         }
[16:18:40.721]     })
[16:18:40.721]     if (TRUE) {
[16:18:40.721]         base::sink(type = "output", split = FALSE)
[16:18:40.721]         if (TRUE) {
[16:18:40.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.721]         }
[16:18:40.721]         else {
[16:18:40.721]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.721]         }
[16:18:40.721]         base::close(...future.stdout)
[16:18:40.721]         ...future.stdout <- NULL
[16:18:40.721]     }
[16:18:40.721]     ...future.result$conditions <- ...future.conditions
[16:18:40.721]     ...future.result$finished <- base::Sys.time()
[16:18:40.721]     ...future.result
[16:18:40.721] }
[16:18:40.723] assign_globals() ...
[16:18:40.723] List of 5
[16:18:40.723]  $ ...future.FUN            :function (x, ...)  
[16:18:40.723]  $ MoreArgs                 : NULL
[16:18:40.723]  $ ...future.elements_ii    :List of 2
[16:18:40.723]   ..$ :List of 4
[16:18:40.723]   .. ..$ : int 1
[16:18:40.723]   .. ..$ : int 2
[16:18:40.723]   .. ..$ : int 3
[16:18:40.723]   .. ..$ : int 4
[16:18:40.723]   ..$ :List of 4
[16:18:40.723]   .. ..$ : int 2
[16:18:40.723]   .. ..$ : int 1
[16:18:40.723]   .. ..$ : int 2
[16:18:40.723]   .. ..$ : int 1
[16:18:40.723]  $ ...future.seeds_ii       : NULL
[16:18:40.723]  $ ...future.globals.maxSize: NULL
[16:18:40.723]  - attr(*, "where")=List of 5
[16:18:40.723]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.723]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.723]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.723]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.723]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.723]  - attr(*, "resolved")= logi FALSE
[16:18:40.723]  - attr(*, "total_size")= num 504
[16:18:40.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.723]  - attr(*, "already-done")= logi TRUE
[16:18:40.730] - copied ‘...future.FUN’ to environment
[16:18:40.730] - copied ‘MoreArgs’ to environment
[16:18:40.730] - copied ‘...future.elements_ii’ to environment
[16:18:40.730] - copied ‘...future.seeds_ii’ to environment
[16:18:40.730] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.730] assign_globals() ... done
[16:18:40.731] plan(): Setting new future strategy stack:
[16:18:40.731] List of future strategies:
[16:18:40.731] 1. sequential:
[16:18:40.731]    - args: function (..., envir = parent.frame())
[16:18:40.731]    - tweaked: FALSE
[16:18:40.731]    - call: NULL
[16:18:40.731] plan(): nbrOfWorkers() = 1
[16:18:40.732] plan(): Setting new future strategy stack:
[16:18:40.732] List of future strategies:
[16:18:40.732] 1. sequential:
[16:18:40.732]    - args: function (..., envir = parent.frame())
[16:18:40.732]    - tweaked: FALSE
[16:18:40.732]    - call: plan(strategy)
[16:18:40.732] plan(): nbrOfWorkers() = 1
[16:18:40.732] SequentialFuture started (and completed)
[16:18:40.733] - Launch lazy future ... done
[16:18:40.733] run() for ‘SequentialFuture’ ... done
[16:18:40.733] Created future:
[16:18:40.733] SequentialFuture:
[16:18:40.733] Label: ‘future_mapply-1’
[16:18:40.733] Expression:
[16:18:40.733] {
[16:18:40.733]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.733]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.733]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.733]         on.exit(options(oopts), add = TRUE)
[16:18:40.733]     }
[16:18:40.733]     {
[16:18:40.733]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.733]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.733]         do.call(mapply, args = args)
[16:18:40.733]     }
[16:18:40.733] }
[16:18:40.733] Lazy evaluation: FALSE
[16:18:40.733] Asynchronous evaluation: FALSE
[16:18:40.733] Local evaluation: TRUE
[16:18:40.733] Environment: R_GlobalEnv
[16:18:40.733] Capture standard output: TRUE
[16:18:40.733] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.733] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.733] Packages: <none>
[16:18:40.733] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.733] Resolved: TRUE
[16:18:40.733] Value: 224 bytes of class ‘list’
[16:18:40.733] Early signaling: FALSE
[16:18:40.733] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.733] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.734] Chunk #1 of 1 ... DONE
[16:18:40.734] Launching 1 futures (chunks) ... DONE
[16:18:40.734] Resolving 1 futures (chunks) ...
[16:18:40.734] resolve() on list ...
[16:18:40.734]  recursive: 0
[16:18:40.734]  length: 1
[16:18:40.734] 
[16:18:40.735] resolved() for ‘SequentialFuture’ ...
[16:18:40.735] - state: ‘finished’
[16:18:40.735] - run: TRUE
[16:18:40.735] - result: ‘FutureResult’
[16:18:40.735] resolved() for ‘SequentialFuture’ ... done
[16:18:40.735] Future #1
[16:18:40.735] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.735] - nx: 1
[16:18:40.735] - relay: TRUE
[16:18:40.736] - stdout: TRUE
[16:18:40.736] - signal: TRUE
[16:18:40.736] - resignal: FALSE
[16:18:40.736] - force: TRUE
[16:18:40.736] - relayed: [n=1] FALSE
[16:18:40.736] - queued futures: [n=1] FALSE
[16:18:40.736]  - until=1
[16:18:40.736]  - relaying element #1
[16:18:40.736] - relayed: [n=1] TRUE
[16:18:40.736] - queued futures: [n=1] TRUE
[16:18:40.737] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.737]  length: 0 (resolved future 1)
[16:18:40.737] Relaying remaining futures
[16:18:40.737] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.737] - nx: 1
[16:18:40.737] - relay: TRUE
[16:18:40.737] - stdout: TRUE
[16:18:40.737] - signal: TRUE
[16:18:40.737] - resignal: FALSE
[16:18:40.737] - force: TRUE
[16:18:40.737] - relayed: [n=1] TRUE
[16:18:40.738] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.738] - relayed: [n=1] TRUE
[16:18:40.738] - queued futures: [n=1] TRUE
[16:18:40.738] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.738] resolve() on list ... DONE
[16:18:40.738]  - Number of value chunks collected: 1
[16:18:40.738] Resolving 1 futures (chunks) ... DONE
[16:18:40.738] Reducing values from 1 chunks ...
[16:18:40.738]  - Number of values collected after concatenation: 4
[16:18:40.739]  - Number of values expected: 4
[16:18:40.741] Reducing values from 1 chunks ... DONE
[16:18:40.741] future_mapply() ... DONE
- Parallel RNG ...
[16:18:40.741] future_mapply() ...
[16:18:40.741] Generating random seeds ...
[16:18:40.741] Generating random seed streams for 4 elements ...
[16:18:40.741] Generating random seed streams for 4 elements ... DONE
[16:18:40.741] Generating random seeds ... DONE
[16:18:40.742] Will set RNG state on exit: 10407, 1712775263, -1779034456, -2028842349, -1310549542, 480109491, -1436710402
[16:18:40.742] Number of chunks: 1
[16:18:40.742] getGlobalsAndPackagesXApply() ...
[16:18:40.742]  - future.globals: TRUE
[16:18:40.742] getGlobalsAndPackages() ...
[16:18:40.742] Searching for globals...
[16:18:40.744] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[16:18:40.744] Searching for globals ... DONE
[16:18:40.744] Resolving globals: FALSE
[16:18:40.744] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[16:18:40.745] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[16:18:40.745] - globals: [1] ‘FUN’
[16:18:40.745] - packages: [1] ‘stats’
[16:18:40.745] getGlobalsAndPackages() ... DONE
[16:18:40.745]  - globals found/used: [n=1] ‘FUN’
[16:18:40.745]  - needed namespaces: [n=1] ‘stats’
[16:18:40.745] Finding globals ... DONE
[16:18:40.745] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.746] List of 2
[16:18:40.746]  $ ...future.FUN:function (n, min = 0, max = 1)  
[16:18:40.746]  $ MoreArgs     :List of 1
[16:18:40.746]   ..$ min: num 1
[16:18:40.746]  - attr(*, "where")=List of 2
[16:18:40.746]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.746]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.746]  - attr(*, "resolved")= logi FALSE
[16:18:40.746]  - attr(*, "total_size")= num NA
[16:18:40.748] Packages to be attached in all futures: [n=1] ‘stats’
[16:18:40.749] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.749] Number of futures (= number of chunks): 1
[16:18:40.749] Launching 1 futures (chunks) ...
[16:18:40.749] Chunk #1 of 1 ...
[16:18:40.749]  - Finding globals in '...' for chunk #1 ...
[16:18:40.749] getGlobalsAndPackages() ...
[16:18:40.749] Searching for globals...
[16:18:40.750] 
[16:18:40.750] Searching for globals ... DONE
[16:18:40.750] - globals: [0] <none>
[16:18:40.750] getGlobalsAndPackages() ... DONE
[16:18:40.750]    + additional globals found: [n=0] 
[16:18:40.750]    + additional namespaces needed: [n=0] 
[16:18:40.750]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.750]  - seeds: [4] <seeds>
[16:18:40.750]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.751] getGlobalsAndPackages() ...
[16:18:40.751] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.751] Resolving globals: FALSE
[16:18:40.751] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[16:18:40.752] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[16:18:40.752] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.752] - packages: [1] ‘stats’
[16:18:40.752] getGlobalsAndPackages() ... DONE
[16:18:40.753] run() for ‘Future’ ...
[16:18:40.753] - state: ‘created’
[16:18:40.753] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.753] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.753] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.753]   - Field: ‘label’
[16:18:40.753]   - Field: ‘local’
[16:18:40.754]   - Field: ‘owner’
[16:18:40.754]   - Field: ‘envir’
[16:18:40.754]   - Field: ‘packages’
[16:18:40.754]   - Field: ‘gc’
[16:18:40.754]   - Field: ‘conditions’
[16:18:40.754]   - Field: ‘expr’
[16:18:40.754]   - Field: ‘uuid’
[16:18:40.754]   - Field: ‘seed’
[16:18:40.754]   - Field: ‘version’
[16:18:40.754]   - Field: ‘result’
[16:18:40.754]   - Field: ‘asynchronous’
[16:18:40.755]   - Field: ‘calls’
[16:18:40.755]   - Field: ‘globals’
[16:18:40.755]   - Field: ‘stdout’
[16:18:40.755]   - Field: ‘earlySignal’
[16:18:40.755]   - Field: ‘lazy’
[16:18:40.755]   - Field: ‘state’
[16:18:40.755] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.755] - Launch lazy future ...
[16:18:40.755] Packages needed by the future expression (n = 1): ‘stats’
[16:18:40.755] Packages needed by future strategies (n = 0): <none>
[16:18:40.756] {
[16:18:40.756]     {
[16:18:40.756]         {
[16:18:40.756]             ...future.startTime <- base::Sys.time()
[16:18:40.756]             {
[16:18:40.756]                 {
[16:18:40.756]                   {
[16:18:40.756]                     {
[16:18:40.756]                       base::local({
[16:18:40.756]                         has_future <- base::requireNamespace("future", 
[16:18:40.756]                           quietly = TRUE)
[16:18:40.756]                         if (has_future) {
[16:18:40.756]                           ns <- base::getNamespace("future")
[16:18:40.756]                           version <- ns[[".package"]][["version"]]
[16:18:40.756]                           if (is.null(version)) 
[16:18:40.756]                             version <- utils::packageVersion("future")
[16:18:40.756]                         }
[16:18:40.756]                         else {
[16:18:40.756]                           version <- NULL
[16:18:40.756]                         }
[16:18:40.756]                         if (!has_future || version < "1.8.0") {
[16:18:40.756]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.756]                             "", base::R.version$version.string), 
[16:18:40.756]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:40.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.756]                               "release", "version")], collapse = " "), 
[16:18:40.756]                             hostname = base::Sys.info()[["nodename"]])
[16:18:40.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.756]                             info)
[16:18:40.756]                           info <- base::paste(info, collapse = "; ")
[16:18:40.756]                           if (!has_future) {
[16:18:40.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.756]                               info)
[16:18:40.756]                           }
[16:18:40.756]                           else {
[16:18:40.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.756]                               info, version)
[16:18:40.756]                           }
[16:18:40.756]                           base::stop(msg)
[16:18:40.756]                         }
[16:18:40.756]                       })
[16:18:40.756]                     }
[16:18:40.756]                     base::local({
[16:18:40.756]                       for (pkg in "stats") {
[16:18:40.756]                         base::loadNamespace(pkg)
[16:18:40.756]                         base::library(pkg, character.only = TRUE)
[16:18:40.756]                       }
[16:18:40.756]                     })
[16:18:40.756]                   }
[16:18:40.756]                   ...future.strategy.old <- future::plan("list")
[16:18:40.756]                   options(future.plan = NULL)
[16:18:40.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.756]                 }
[16:18:40.756]                 ...future.workdir <- getwd()
[16:18:40.756]             }
[16:18:40.756]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.756]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.756]         }
[16:18:40.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.756]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.756]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.756]             base::names(...future.oldOptions))
[16:18:40.756]     }
[16:18:40.756]     if (FALSE) {
[16:18:40.756]     }
[16:18:40.756]     else {
[16:18:40.756]         if (TRUE) {
[16:18:40.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.756]                 open = "w")
[16:18:40.756]         }
[16:18:40.756]         else {
[16:18:40.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.756]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.756]         }
[16:18:40.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.756]             base::sink(type = "output", split = FALSE)
[16:18:40.756]             base::close(...future.stdout)
[16:18:40.756]         }, add = TRUE)
[16:18:40.756]     }
[16:18:40.756]     ...future.frame <- base::sys.nframe()
[16:18:40.756]     ...future.conditions <- base::list()
[16:18:40.756]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.756]     if (FALSE) {
[16:18:40.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.756]     }
[16:18:40.756]     ...future.result <- base::tryCatch({
[16:18:40.756]         base::withCallingHandlers({
[16:18:40.756]             ...future.value <- base::withVisible(base::local({
[16:18:40.756]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.756]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.756]                   ...future.globals.maxSize)) {
[16:18:40.756]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.756]                   on.exit(options(oopts), add = TRUE)
[16:18:40.756]                 }
[16:18:40.756]                 {
[16:18:40.756]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:40.756]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[16:18:40.756]                       envir = globalenv(), inherits = FALSE)
[16:18:40.756]                     ...future.FUN(...)
[16:18:40.756]                   }
[16:18:40.756]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:40.756]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:40.756]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.756]                     USE.NAMES = FALSE)
[16:18:40.756]                   do.call(mapply, args = args)
[16:18:40.756]                 }
[16:18:40.756]             }))
[16:18:40.756]             future::FutureResult(value = ...future.value$value, 
[16:18:40.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.756]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.756]                     ...future.globalenv.names))
[16:18:40.756]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.756]         }, condition = base::local({
[16:18:40.756]             c <- base::c
[16:18:40.756]             inherits <- base::inherits
[16:18:40.756]             invokeRestart <- base::invokeRestart
[16:18:40.756]             length <- base::length
[16:18:40.756]             list <- base::list
[16:18:40.756]             seq.int <- base::seq.int
[16:18:40.756]             signalCondition <- base::signalCondition
[16:18:40.756]             sys.calls <- base::sys.calls
[16:18:40.756]             `[[` <- base::`[[`
[16:18:40.756]             `+` <- base::`+`
[16:18:40.756]             `<<-` <- base::`<<-`
[16:18:40.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.756]                   3L)]
[16:18:40.756]             }
[16:18:40.756]             function(cond) {
[16:18:40.756]                 is_error <- inherits(cond, "error")
[16:18:40.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.756]                   NULL)
[16:18:40.756]                 if (is_error) {
[16:18:40.756]                   sessionInformation <- function() {
[16:18:40.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.756]                       search = base::search(), system = base::Sys.info())
[16:18:40.756]                   }
[16:18:40.756]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.756]                     cond$call), session = sessionInformation(), 
[16:18:40.756]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.756]                   signalCondition(cond)
[16:18:40.756]                 }
[16:18:40.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.756]                 "immediateCondition"))) {
[16:18:40.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.756]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.756]                   if (TRUE && !signal) {
[16:18:40.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.756]                     {
[16:18:40.756]                       inherits <- base::inherits
[16:18:40.756]                       invokeRestart <- base::invokeRestart
[16:18:40.756]                       is.null <- base::is.null
[16:18:40.756]                       muffled <- FALSE
[16:18:40.756]                       if (inherits(cond, "message")) {
[16:18:40.756]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.756]                         if (muffled) 
[16:18:40.756]                           invokeRestart("muffleMessage")
[16:18:40.756]                       }
[16:18:40.756]                       else if (inherits(cond, "warning")) {
[16:18:40.756]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.756]                         if (muffled) 
[16:18:40.756]                           invokeRestart("muffleWarning")
[16:18:40.756]                       }
[16:18:40.756]                       else if (inherits(cond, "condition")) {
[16:18:40.756]                         if (!is.null(pattern)) {
[16:18:40.756]                           computeRestarts <- base::computeRestarts
[16:18:40.756]                           grepl <- base::grepl
[16:18:40.756]                           restarts <- computeRestarts(cond)
[16:18:40.756]                           for (restart in restarts) {
[16:18:40.756]                             name <- restart$name
[16:18:40.756]                             if (is.null(name)) 
[16:18:40.756]                               next
[16:18:40.756]                             if (!grepl(pattern, name)) 
[16:18:40.756]                               next
[16:18:40.756]                             invokeRestart(restart)
[16:18:40.756]                             muffled <- TRUE
[16:18:40.756]                             break
[16:18:40.756]                           }
[16:18:40.756]                         }
[16:18:40.756]                       }
[16:18:40.756]                       invisible(muffled)
[16:18:40.756]                     }
[16:18:40.756]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.756]                   }
[16:18:40.756]                 }
[16:18:40.756]                 else {
[16:18:40.756]                   if (TRUE) {
[16:18:40.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.756]                     {
[16:18:40.756]                       inherits <- base::inherits
[16:18:40.756]                       invokeRestart <- base::invokeRestart
[16:18:40.756]                       is.null <- base::is.null
[16:18:40.756]                       muffled <- FALSE
[16:18:40.756]                       if (inherits(cond, "message")) {
[16:18:40.756]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.756]                         if (muffled) 
[16:18:40.756]                           invokeRestart("muffleMessage")
[16:18:40.756]                       }
[16:18:40.756]                       else if (inherits(cond, "warning")) {
[16:18:40.756]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.756]                         if (muffled) 
[16:18:40.756]                           invokeRestart("muffleWarning")
[16:18:40.756]                       }
[16:18:40.756]                       else if (inherits(cond, "condition")) {
[16:18:40.756]                         if (!is.null(pattern)) {
[16:18:40.756]                           computeRestarts <- base::computeRestarts
[16:18:40.756]                           grepl <- base::grepl
[16:18:40.756]                           restarts <- computeRestarts(cond)
[16:18:40.756]                           for (restart in restarts) {
[16:18:40.756]                             name <- restart$name
[16:18:40.756]                             if (is.null(name)) 
[16:18:40.756]                               next
[16:18:40.756]                             if (!grepl(pattern, name)) 
[16:18:40.756]                               next
[16:18:40.756]                             invokeRestart(restart)
[16:18:40.756]                             muffled <- TRUE
[16:18:40.756]                             break
[16:18:40.756]                           }
[16:18:40.756]                         }
[16:18:40.756]                       }
[16:18:40.756]                       invisible(muffled)
[16:18:40.756]                     }
[16:18:40.756]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.756]                   }
[16:18:40.756]                 }
[16:18:40.756]             }
[16:18:40.756]         }))
[16:18:40.756]     }, error = function(ex) {
[16:18:40.756]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.756]                 ...future.rng), started = ...future.startTime, 
[16:18:40.756]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.756]             version = "1.8"), class = "FutureResult")
[16:18:40.756]     }, finally = {
[16:18:40.756]         if (!identical(...future.workdir, getwd())) 
[16:18:40.756]             setwd(...future.workdir)
[16:18:40.756]         {
[16:18:40.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.756]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.756]             }
[16:18:40.756]             base::options(...future.oldOptions)
[16:18:40.756]             if (.Platform$OS.type == "windows") {
[16:18:40.756]                 old_names <- names(...future.oldEnvVars)
[16:18:40.756]                 envs <- base::Sys.getenv()
[16:18:40.756]                 names <- names(envs)
[16:18:40.756]                 common <- intersect(names, old_names)
[16:18:40.756]                 added <- setdiff(names, old_names)
[16:18:40.756]                 removed <- setdiff(old_names, names)
[16:18:40.756]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.756]                   envs[common]]
[16:18:40.756]                 NAMES <- toupper(changed)
[16:18:40.756]                 args <- list()
[16:18:40.756]                 for (kk in seq_along(NAMES)) {
[16:18:40.756]                   name <- changed[[kk]]
[16:18:40.756]                   NAME <- NAMES[[kk]]
[16:18:40.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.756]                     next
[16:18:40.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.756]                 }
[16:18:40.756]                 NAMES <- toupper(added)
[16:18:40.756]                 for (kk in seq_along(NAMES)) {
[16:18:40.756]                   name <- added[[kk]]
[16:18:40.756]                   NAME <- NAMES[[kk]]
[16:18:40.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.756]                     next
[16:18:40.756]                   args[[name]] <- ""
[16:18:40.756]                 }
[16:18:40.756]                 NAMES <- toupper(removed)
[16:18:40.756]                 for (kk in seq_along(NAMES)) {
[16:18:40.756]                   name <- removed[[kk]]
[16:18:40.756]                   NAME <- NAMES[[kk]]
[16:18:40.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.756]                     next
[16:18:40.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.756]                 }
[16:18:40.756]                 if (length(args) > 0) 
[16:18:40.756]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.756]             }
[16:18:40.756]             else {
[16:18:40.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.756]             }
[16:18:40.756]             {
[16:18:40.756]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.756]                   0L) {
[16:18:40.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.756]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.756]                   base::options(opts)
[16:18:40.756]                 }
[16:18:40.756]                 {
[16:18:40.756]                   {
[16:18:40.756]                     base::assign(".Random.seed", c(10407L, 1712775263L, 
[16:18:40.756]                     -1779034456L, -2028842349L, -1310549542L, 
[16:18:40.756]                     480109491L, -1436710402L), envir = base::globalenv(), 
[16:18:40.756]                       inherits = FALSE)
[16:18:40.756]                     NULL
[16:18:40.756]                   }
[16:18:40.756]                   options(future.plan = NULL)
[16:18:40.756]                   if (is.na(NA_character_)) 
[16:18:40.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.756]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.756]                     .init = FALSE)
[16:18:40.756]                 }
[16:18:40.756]             }
[16:18:40.756]         }
[16:18:40.756]     })
[16:18:40.756]     if (TRUE) {
[16:18:40.756]         base::sink(type = "output", split = FALSE)
[16:18:40.756]         if (TRUE) {
[16:18:40.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.756]         }
[16:18:40.756]         else {
[16:18:40.756]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.756]         }
[16:18:40.756]         base::close(...future.stdout)
[16:18:40.756]         ...future.stdout <- NULL
[16:18:40.756]     }
[16:18:40.756]     ...future.result$conditions <- ...future.conditions
[16:18:40.756]     ...future.result$finished <- base::Sys.time()
[16:18:40.756]     ...future.result
[16:18:40.756] }
[16:18:40.758] assign_globals() ...
[16:18:40.758] List of 5
[16:18:40.758]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[16:18:40.758]  $ MoreArgs                 :List of 1
[16:18:40.758]   ..$ min: num 1
[16:18:40.758]  $ ...future.elements_ii    :List of 2
[16:18:40.758]   ..$ n  :List of 4
[16:18:40.758]   .. ..$ : int 1
[16:18:40.758]   .. ..$ : int 2
[16:18:40.758]   .. ..$ : int 3
[16:18:40.758]   .. ..$ : int 4
[16:18:40.758]   ..$ max:List of 4
[16:18:40.758]   .. ..$ : int 2
[16:18:40.758]   .. ..$ : int 3
[16:18:40.758]   .. ..$ : int 4
[16:18:40.758]   .. ..$ : int 5
[16:18:40.758]  $ ...future.seeds_ii       :List of 4
[16:18:40.758]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[16:18:40.758]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[16:18:40.758]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[16:18:40.758]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[16:18:40.758]  $ ...future.globals.maxSize: NULL
[16:18:40.758]  - attr(*, "where")=List of 5
[16:18:40.758]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.758]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.758]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.758]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.758]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.758]  - attr(*, "resolved")= logi FALSE
[16:18:40.758]  - attr(*, "total_size")= num 2912
[16:18:40.758]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.758]  - attr(*, "already-done")= logi TRUE
[16:18:40.772] - copied ‘...future.FUN’ to environment
[16:18:40.772] - copied ‘MoreArgs’ to environment
[16:18:40.773] - copied ‘...future.elements_ii’ to environment
[16:18:40.773] - copied ‘...future.seeds_ii’ to environment
[16:18:40.773] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.773] assign_globals() ... done
[16:18:40.773] plan(): Setting new future strategy stack:
[16:18:40.773] List of future strategies:
[16:18:40.773] 1. sequential:
[16:18:40.773]    - args: function (..., envir = parent.frame())
[16:18:40.773]    - tweaked: FALSE
[16:18:40.773]    - call: NULL
[16:18:40.774] plan(): nbrOfWorkers() = 1
[16:18:40.775] plan(): Setting new future strategy stack:
[16:18:40.775] List of future strategies:
[16:18:40.775] 1. sequential:
[16:18:40.775]    - args: function (..., envir = parent.frame())
[16:18:40.775]    - tweaked: FALSE
[16:18:40.775]    - call: plan(strategy)
[16:18:40.775] plan(): nbrOfWorkers() = 1
[16:18:40.775] SequentialFuture started (and completed)
[16:18:40.775] - Launch lazy future ... done
[16:18:40.775] run() for ‘SequentialFuture’ ... done
[16:18:40.776] Created future:
[16:18:40.776] SequentialFuture:
[16:18:40.776] Label: ‘future_mapply-1’
[16:18:40.776] Expression:
[16:18:40.776] {
[16:18:40.776]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.776]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.776]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.776]         on.exit(options(oopts), add = TRUE)
[16:18:40.776]     }
[16:18:40.776]     {
[16:18:40.776]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:40.776]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[16:18:40.776]                 inherits = FALSE)
[16:18:40.776]             ...future.FUN(...)
[16:18:40.776]         }
[16:18:40.776]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:40.776]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:40.776]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.776]         do.call(mapply, args = args)
[16:18:40.776]     }
[16:18:40.776] }
[16:18:40.776] Lazy evaluation: FALSE
[16:18:40.776] Asynchronous evaluation: FALSE
[16:18:40.776] Local evaluation: TRUE
[16:18:40.776] Environment: R_GlobalEnv
[16:18:40.776] Capture standard output: TRUE
[16:18:40.776] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.776] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.776] Packages: 1 packages (‘stats’)
[16:18:40.776] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:18:40.776] Resolved: TRUE
[16:18:40.776] Value: 280 bytes of class ‘list’
[16:18:40.776] Early signaling: FALSE
[16:18:40.776] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.776] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.777] Chunk #1 of 1 ... DONE
[16:18:40.777] Launching 1 futures (chunks) ... DONE
[16:18:40.777] Resolving 1 futures (chunks) ...
[16:18:40.777] resolve() on list ...
[16:18:40.777]  recursive: 0
[16:18:40.777]  length: 1
[16:18:40.777] 
[16:18:40.777] resolved() for ‘SequentialFuture’ ...
[16:18:40.778] - state: ‘finished’
[16:18:40.778] - run: TRUE
[16:18:40.778] - result: ‘FutureResult’
[16:18:40.778] resolved() for ‘SequentialFuture’ ... done
[16:18:40.778] Future #1
[16:18:40.778] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.778] - nx: 1
[16:18:40.778] - relay: TRUE
[16:18:40.778] - stdout: TRUE
[16:18:40.778] - signal: TRUE
[16:18:40.779] - resignal: FALSE
[16:18:40.779] - force: TRUE
[16:18:40.779] - relayed: [n=1] FALSE
[16:18:40.779] - queued futures: [n=1] FALSE
[16:18:40.779]  - until=1
[16:18:40.779]  - relaying element #1
[16:18:40.779] - relayed: [n=1] TRUE
[16:18:40.779] - queued futures: [n=1] TRUE
[16:18:40.779] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.779]  length: 0 (resolved future 1)
[16:18:40.780] Relaying remaining futures
[16:18:40.780] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.780] - nx: 1
[16:18:40.780] - relay: TRUE
[16:18:40.780] - stdout: TRUE
[16:18:40.780] - signal: TRUE
[16:18:40.780] - resignal: FALSE
[16:18:40.780] - force: TRUE
[16:18:40.780] - relayed: [n=1] TRUE
[16:18:40.780] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.780] - relayed: [n=1] TRUE
[16:18:40.781] - queued futures: [n=1] TRUE
[16:18:40.781] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.781] resolve() on list ... DONE
[16:18:40.781]  - Number of value chunks collected: 1
[16:18:40.781] Resolving 1 futures (chunks) ... DONE
[16:18:40.781] Reducing values from 1 chunks ...
[16:18:40.781]  - Number of values collected after concatenation: 4
[16:18:40.781]  - Number of values expected: 4
[16:18:40.781] Reducing values from 1 chunks ... DONE
[16:18:40.781] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[16:18:40.784] future_mapply() ...
[16:18:40.784] Number of chunks: 1
[16:18:40.784] getGlobalsAndPackagesXApply() ...
[16:18:40.784]  - future.globals: TRUE
[16:18:40.784] getGlobalsAndPackages() ...
[16:18:40.784] Searching for globals...
[16:18:40.786] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:18:40.786] Searching for globals ... DONE
[16:18:40.786] Resolving globals: FALSE
[16:18:40.786] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[16:18:40.786] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[16:18:40.787] - globals: [1] ‘FUN’
[16:18:40.787] - packages: [1] ‘stats’
[16:18:40.787] getGlobalsAndPackages() ... DONE
[16:18:40.787]  - globals found/used: [n=1] ‘FUN’
[16:18:40.787]  - needed namespaces: [n=1] ‘stats’
[16:18:40.787] Finding globals ... DONE
[16:18:40.787] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.787] List of 2
[16:18:40.787]  $ ...future.FUN:function (x, w, ...)  
[16:18:40.787]  $ MoreArgs     : NULL
[16:18:40.787]  - attr(*, "where")=List of 2
[16:18:40.787]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.787]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.787]  - attr(*, "resolved")= logi FALSE
[16:18:40.787]  - attr(*, "total_size")= num NA
[16:18:40.792] Packages to be attached in all futures: [n=1] ‘stats’
[16:18:40.792] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.792] Number of futures (= number of chunks): 1
[16:18:40.792] Launching 1 futures (chunks) ...
[16:18:40.792] Chunk #1 of 1 ...
[16:18:40.793]  - Finding globals in '...' for chunk #1 ...
[16:18:40.793] getGlobalsAndPackages() ...
[16:18:40.793] Searching for globals...
[16:18:40.793] 
[16:18:40.793] Searching for globals ... DONE
[16:18:40.793] - globals: [0] <none>
[16:18:40.794] getGlobalsAndPackages() ... DONE
[16:18:40.794]    + additional globals found: [n=0] 
[16:18:40.794]    + additional namespaces needed: [n=0] 
[16:18:40.794]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.794]  - seeds: <none>
[16:18:40.794]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.794] getGlobalsAndPackages() ...
[16:18:40.794] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.794] Resolving globals: FALSE
[16:18:40.795] The total size of the 5 globals is 3.10 KiB (3176 bytes)
[16:18:40.795] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (1.72 KiB of class ‘list’), ‘...future.FUN’ (1.38 KiB of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.796] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.796] - packages: [1] ‘stats’
[16:18:40.796] getGlobalsAndPackages() ... DONE
[16:18:40.796] run() for ‘Future’ ...
[16:18:40.796] - state: ‘created’
[16:18:40.796] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.797] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.797] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.797]   - Field: ‘label’
[16:18:40.797]   - Field: ‘local’
[16:18:40.797]   - Field: ‘owner’
[16:18:40.797]   - Field: ‘envir’
[16:18:40.797]   - Field: ‘packages’
[16:18:40.797]   - Field: ‘gc’
[16:18:40.798]   - Field: ‘conditions’
[16:18:40.798]   - Field: ‘expr’
[16:18:40.798]   - Field: ‘uuid’
[16:18:40.798]   - Field: ‘seed’
[16:18:40.798]   - Field: ‘version’
[16:18:40.798]   - Field: ‘result’
[16:18:40.798]   - Field: ‘asynchronous’
[16:18:40.798]   - Field: ‘calls’
[16:18:40.798]   - Field: ‘globals’
[16:18:40.798]   - Field: ‘stdout’
[16:18:40.798]   - Field: ‘earlySignal’
[16:18:40.799]   - Field: ‘lazy’
[16:18:40.799]   - Field: ‘state’
[16:18:40.799] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.799] - Launch lazy future ...
[16:18:40.799] Packages needed by the future expression (n = 1): ‘stats’
[16:18:40.799] Packages needed by future strategies (n = 0): <none>
[16:18:40.800] {
[16:18:40.800]     {
[16:18:40.800]         {
[16:18:40.800]             ...future.startTime <- base::Sys.time()
[16:18:40.800]             {
[16:18:40.800]                 {
[16:18:40.800]                   {
[16:18:40.800]                     {
[16:18:40.800]                       base::local({
[16:18:40.800]                         has_future <- base::requireNamespace("future", 
[16:18:40.800]                           quietly = TRUE)
[16:18:40.800]                         if (has_future) {
[16:18:40.800]                           ns <- base::getNamespace("future")
[16:18:40.800]                           version <- ns[[".package"]][["version"]]
[16:18:40.800]                           if (is.null(version)) 
[16:18:40.800]                             version <- utils::packageVersion("future")
[16:18:40.800]                         }
[16:18:40.800]                         else {
[16:18:40.800]                           version <- NULL
[16:18:40.800]                         }
[16:18:40.800]                         if (!has_future || version < "1.8.0") {
[16:18:40.800]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.800]                             "", base::R.version$version.string), 
[16:18:40.800]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:40.800]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.800]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.800]                               "release", "version")], collapse = " "), 
[16:18:40.800]                             hostname = base::Sys.info()[["nodename"]])
[16:18:40.800]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.800]                             info)
[16:18:40.800]                           info <- base::paste(info, collapse = "; ")
[16:18:40.800]                           if (!has_future) {
[16:18:40.800]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.800]                               info)
[16:18:40.800]                           }
[16:18:40.800]                           else {
[16:18:40.800]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.800]                               info, version)
[16:18:40.800]                           }
[16:18:40.800]                           base::stop(msg)
[16:18:40.800]                         }
[16:18:40.800]                       })
[16:18:40.800]                     }
[16:18:40.800]                     base::local({
[16:18:40.800]                       for (pkg in "stats") {
[16:18:40.800]                         base::loadNamespace(pkg)
[16:18:40.800]                         base::library(pkg, character.only = TRUE)
[16:18:40.800]                       }
[16:18:40.800]                     })
[16:18:40.800]                   }
[16:18:40.800]                   ...future.strategy.old <- future::plan("list")
[16:18:40.800]                   options(future.plan = NULL)
[16:18:40.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.800]                 }
[16:18:40.800]                 ...future.workdir <- getwd()
[16:18:40.800]             }
[16:18:40.800]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.800]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.800]         }
[16:18:40.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.800]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.800]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.800]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.800]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.800]             base::names(...future.oldOptions))
[16:18:40.800]     }
[16:18:40.800]     if (FALSE) {
[16:18:40.800]     }
[16:18:40.800]     else {
[16:18:40.800]         if (TRUE) {
[16:18:40.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.800]                 open = "w")
[16:18:40.800]         }
[16:18:40.800]         else {
[16:18:40.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.800]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.800]         }
[16:18:40.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.800]             base::sink(type = "output", split = FALSE)
[16:18:40.800]             base::close(...future.stdout)
[16:18:40.800]         }, add = TRUE)
[16:18:40.800]     }
[16:18:40.800]     ...future.frame <- base::sys.nframe()
[16:18:40.800]     ...future.conditions <- base::list()
[16:18:40.800]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.800]     if (FALSE) {
[16:18:40.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.800]     }
[16:18:40.800]     ...future.result <- base::tryCatch({
[16:18:40.800]         base::withCallingHandlers({
[16:18:40.800]             ...future.value <- base::withVisible(base::local({
[16:18:40.800]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.800]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.800]                   ...future.globals.maxSize)) {
[16:18:40.800]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.800]                   on.exit(options(oopts), add = TRUE)
[16:18:40.800]                 }
[16:18:40.800]                 {
[16:18:40.800]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.800]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.800]                     USE.NAMES = FALSE)
[16:18:40.800]                   do.call(mapply, args = args)
[16:18:40.800]                 }
[16:18:40.800]             }))
[16:18:40.800]             future::FutureResult(value = ...future.value$value, 
[16:18:40.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.800]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.800]                     ...future.globalenv.names))
[16:18:40.800]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.800]         }, condition = base::local({
[16:18:40.800]             c <- base::c
[16:18:40.800]             inherits <- base::inherits
[16:18:40.800]             invokeRestart <- base::invokeRestart
[16:18:40.800]             length <- base::length
[16:18:40.800]             list <- base::list
[16:18:40.800]             seq.int <- base::seq.int
[16:18:40.800]             signalCondition <- base::signalCondition
[16:18:40.800]             sys.calls <- base::sys.calls
[16:18:40.800]             `[[` <- base::`[[`
[16:18:40.800]             `+` <- base::`+`
[16:18:40.800]             `<<-` <- base::`<<-`
[16:18:40.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.800]                   3L)]
[16:18:40.800]             }
[16:18:40.800]             function(cond) {
[16:18:40.800]                 is_error <- inherits(cond, "error")
[16:18:40.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.800]                   NULL)
[16:18:40.800]                 if (is_error) {
[16:18:40.800]                   sessionInformation <- function() {
[16:18:40.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.800]                       search = base::search(), system = base::Sys.info())
[16:18:40.800]                   }
[16:18:40.800]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.800]                     cond$call), session = sessionInformation(), 
[16:18:40.800]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.800]                   signalCondition(cond)
[16:18:40.800]                 }
[16:18:40.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.800]                 "immediateCondition"))) {
[16:18:40.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.800]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.800]                   if (TRUE && !signal) {
[16:18:40.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.800]                     {
[16:18:40.800]                       inherits <- base::inherits
[16:18:40.800]                       invokeRestart <- base::invokeRestart
[16:18:40.800]                       is.null <- base::is.null
[16:18:40.800]                       muffled <- FALSE
[16:18:40.800]                       if (inherits(cond, "message")) {
[16:18:40.800]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.800]                         if (muffled) 
[16:18:40.800]                           invokeRestart("muffleMessage")
[16:18:40.800]                       }
[16:18:40.800]                       else if (inherits(cond, "warning")) {
[16:18:40.800]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.800]                         if (muffled) 
[16:18:40.800]                           invokeRestart("muffleWarning")
[16:18:40.800]                       }
[16:18:40.800]                       else if (inherits(cond, "condition")) {
[16:18:40.800]                         if (!is.null(pattern)) {
[16:18:40.800]                           computeRestarts <- base::computeRestarts
[16:18:40.800]                           grepl <- base::grepl
[16:18:40.800]                           restarts <- computeRestarts(cond)
[16:18:40.800]                           for (restart in restarts) {
[16:18:40.800]                             name <- restart$name
[16:18:40.800]                             if (is.null(name)) 
[16:18:40.800]                               next
[16:18:40.800]                             if (!grepl(pattern, name)) 
[16:18:40.800]                               next
[16:18:40.800]                             invokeRestart(restart)
[16:18:40.800]                             muffled <- TRUE
[16:18:40.800]                             break
[16:18:40.800]                           }
[16:18:40.800]                         }
[16:18:40.800]                       }
[16:18:40.800]                       invisible(muffled)
[16:18:40.800]                     }
[16:18:40.800]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.800]                   }
[16:18:40.800]                 }
[16:18:40.800]                 else {
[16:18:40.800]                   if (TRUE) {
[16:18:40.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.800]                     {
[16:18:40.800]                       inherits <- base::inherits
[16:18:40.800]                       invokeRestart <- base::invokeRestart
[16:18:40.800]                       is.null <- base::is.null
[16:18:40.800]                       muffled <- FALSE
[16:18:40.800]                       if (inherits(cond, "message")) {
[16:18:40.800]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.800]                         if (muffled) 
[16:18:40.800]                           invokeRestart("muffleMessage")
[16:18:40.800]                       }
[16:18:40.800]                       else if (inherits(cond, "warning")) {
[16:18:40.800]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.800]                         if (muffled) 
[16:18:40.800]                           invokeRestart("muffleWarning")
[16:18:40.800]                       }
[16:18:40.800]                       else if (inherits(cond, "condition")) {
[16:18:40.800]                         if (!is.null(pattern)) {
[16:18:40.800]                           computeRestarts <- base::computeRestarts
[16:18:40.800]                           grepl <- base::grepl
[16:18:40.800]                           restarts <- computeRestarts(cond)
[16:18:40.800]                           for (restart in restarts) {
[16:18:40.800]                             name <- restart$name
[16:18:40.800]                             if (is.null(name)) 
[16:18:40.800]                               next
[16:18:40.800]                             if (!grepl(pattern, name)) 
[16:18:40.800]                               next
[16:18:40.800]                             invokeRestart(restart)
[16:18:40.800]                             muffled <- TRUE
[16:18:40.800]                             break
[16:18:40.800]                           }
[16:18:40.800]                         }
[16:18:40.800]                       }
[16:18:40.800]                       invisible(muffled)
[16:18:40.800]                     }
[16:18:40.800]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.800]                   }
[16:18:40.800]                 }
[16:18:40.800]             }
[16:18:40.800]         }))
[16:18:40.800]     }, error = function(ex) {
[16:18:40.800]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.800]                 ...future.rng), started = ...future.startTime, 
[16:18:40.800]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.800]             version = "1.8"), class = "FutureResult")
[16:18:40.800]     }, finally = {
[16:18:40.800]         if (!identical(...future.workdir, getwd())) 
[16:18:40.800]             setwd(...future.workdir)
[16:18:40.800]         {
[16:18:40.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.800]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.800]             }
[16:18:40.800]             base::options(...future.oldOptions)
[16:18:40.800]             if (.Platform$OS.type == "windows") {
[16:18:40.800]                 old_names <- names(...future.oldEnvVars)
[16:18:40.800]                 envs <- base::Sys.getenv()
[16:18:40.800]                 names <- names(envs)
[16:18:40.800]                 common <- intersect(names, old_names)
[16:18:40.800]                 added <- setdiff(names, old_names)
[16:18:40.800]                 removed <- setdiff(old_names, names)
[16:18:40.800]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.800]                   envs[common]]
[16:18:40.800]                 NAMES <- toupper(changed)
[16:18:40.800]                 args <- list()
[16:18:40.800]                 for (kk in seq_along(NAMES)) {
[16:18:40.800]                   name <- changed[[kk]]
[16:18:40.800]                   NAME <- NAMES[[kk]]
[16:18:40.800]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.800]                     next
[16:18:40.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.800]                 }
[16:18:40.800]                 NAMES <- toupper(added)
[16:18:40.800]                 for (kk in seq_along(NAMES)) {
[16:18:40.800]                   name <- added[[kk]]
[16:18:40.800]                   NAME <- NAMES[[kk]]
[16:18:40.800]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.800]                     next
[16:18:40.800]                   args[[name]] <- ""
[16:18:40.800]                 }
[16:18:40.800]                 NAMES <- toupper(removed)
[16:18:40.800]                 for (kk in seq_along(NAMES)) {
[16:18:40.800]                   name <- removed[[kk]]
[16:18:40.800]                   NAME <- NAMES[[kk]]
[16:18:40.800]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.800]                     next
[16:18:40.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.800]                 }
[16:18:40.800]                 if (length(args) > 0) 
[16:18:40.800]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.800]             }
[16:18:40.800]             else {
[16:18:40.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.800]             }
[16:18:40.800]             {
[16:18:40.800]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.800]                   0L) {
[16:18:40.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.800]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.800]                   base::options(opts)
[16:18:40.800]                 }
[16:18:40.800]                 {
[16:18:40.800]                   {
[16:18:40.800]                     base::assign(".Random.seed", c(10407L, 1938424795L, 
[16:18:40.800]                     1465562866L, 1706010716L, 1047074623L, -1268480809L, 
[16:18:40.800]                     227942610L), envir = base::globalenv(), inherits = FALSE)
[16:18:40.800]                     NULL
[16:18:40.800]                   }
[16:18:40.800]                   options(future.plan = NULL)
[16:18:40.800]                   if (is.na(NA_character_)) 
[16:18:40.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.800]                     .init = FALSE)
[16:18:40.800]                 }
[16:18:40.800]             }
[16:18:40.800]         }
[16:18:40.800]     })
[16:18:40.800]     if (TRUE) {
[16:18:40.800]         base::sink(type = "output", split = FALSE)
[16:18:40.800]         if (TRUE) {
[16:18:40.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.800]         }
[16:18:40.800]         else {
[16:18:40.800]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.800]         }
[16:18:40.800]         base::close(...future.stdout)
[16:18:40.800]         ...future.stdout <- NULL
[16:18:40.800]     }
[16:18:40.800]     ...future.result$conditions <- ...future.conditions
[16:18:40.800]     ...future.result$finished <- base::Sys.time()
[16:18:40.800]     ...future.result
[16:18:40.800] }
[16:18:40.801] assign_globals() ...
[16:18:40.802] List of 5
[16:18:40.802]  $ ...future.FUN            :function (x, w, ...)  
[16:18:40.802]  $ MoreArgs                 : NULL
[16:18:40.802]  $ ...future.elements_ii    :List of 2
[16:18:40.802]   ..$ :List of 5
[16:18:40.802]   .. ..$ : num [1:10] 0.0966 0.6873 0.3211 0.038 0.1496 ...
[16:18:40.802]   .. ..$ : num [1:10] 0.371 0.913 0.948 0.321 0.356 ...
[16:18:40.802]   .. ..$ : num [1:10] 0.0146 0.8833 0.7233 0.1504 0.5403 ...
[16:18:40.802]   .. ..$ : num [1:10] 0.7838 0.6214 0.4636 0.4269 0.0708 ...
[16:18:40.802]   .. ..$ : num [1:10] 0.0993 0.9487 0.2574 0.9067 0.7559 ...
[16:18:40.802]   ..$ :List of 5
[16:18:40.802]   .. ..$ : num [1:10] 7 4 6 4 6 7 2 5 3 5
[16:18:40.802]   .. ..$ : num [1:10] 9 5 9 5 4 8 6 5 6 6
[16:18:40.802]   .. ..$ : num [1:10] 10 2 7 6 8 3 6 5 6 8
[16:18:40.802]   .. ..$ : num [1:10] 10 6 4 9 4 5 10 9 4 5
[16:18:40.802]   .. ..$ : num [1:10] 7 4 13 4 4 3 4 4 7 5
[16:18:40.802]  $ ...future.seeds_ii       : NULL
[16:18:40.802]  $ ...future.globals.maxSize: NULL
[16:18:40.802]  - attr(*, "where")=List of 5
[16:18:40.802]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.802]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.802]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.802]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.802]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.802]  - attr(*, "resolved")= logi FALSE
[16:18:40.802]  - attr(*, "total_size")= num 3176
[16:18:40.802]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.802]  - attr(*, "already-done")= logi TRUE
[16:18:40.809] - copied ‘...future.FUN’ to environment
[16:18:40.809] - copied ‘MoreArgs’ to environment
[16:18:40.809] - copied ‘...future.elements_ii’ to environment
[16:18:40.809] - copied ‘...future.seeds_ii’ to environment
[16:18:40.809] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.810] assign_globals() ... done
[16:18:40.810] plan(): Setting new future strategy stack:
[16:18:40.810] List of future strategies:
[16:18:40.810] 1. sequential:
[16:18:40.810]    - args: function (..., envir = parent.frame())
[16:18:40.810]    - tweaked: FALSE
[16:18:40.810]    - call: NULL
[16:18:40.810] plan(): nbrOfWorkers() = 1
[16:18:40.811] plan(): Setting new future strategy stack:
[16:18:40.811] List of future strategies:
[16:18:40.811] 1. sequential:
[16:18:40.811]    - args: function (..., envir = parent.frame())
[16:18:40.811]    - tweaked: FALSE
[16:18:40.811]    - call: plan(strategy)
[16:18:40.812] plan(): nbrOfWorkers() = 1
[16:18:40.812] SequentialFuture started (and completed)
[16:18:40.812] - Launch lazy future ... done
[16:18:40.812] run() for ‘SequentialFuture’ ... done
[16:18:40.812] Created future:
[16:18:40.812] SequentialFuture:
[16:18:40.812] Label: ‘future_Map-1’
[16:18:40.812] Expression:
[16:18:40.812] {
[16:18:40.812]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.812]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.812]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.812]         on.exit(options(oopts), add = TRUE)
[16:18:40.812]     }
[16:18:40.812]     {
[16:18:40.812]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.812]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.812]         do.call(mapply, args = args)
[16:18:40.812]     }
[16:18:40.812] }
[16:18:40.812] Lazy evaluation: FALSE
[16:18:40.812] Asynchronous evaluation: FALSE
[16:18:40.812] Local evaluation: TRUE
[16:18:40.812] Environment: R_GlobalEnv
[16:18:40.812] Capture standard output: TRUE
[16:18:40.812] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.812] Globals: 5 objects totaling 3.10 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.812] Packages: 1 packages (‘stats’)
[16:18:40.812] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.812] Resolved: TRUE
[16:18:40.812] Value: 280 bytes of class ‘list’
[16:18:40.812] Early signaling: FALSE
[16:18:40.812] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.812] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.814] Chunk #1 of 1 ... DONE
[16:18:40.814] Launching 1 futures (chunks) ... DONE
[16:18:40.814] Resolving 1 futures (chunks) ...
[16:18:40.814] resolve() on list ...
[16:18:40.814]  recursive: 0
[16:18:40.814]  length: 1
[16:18:40.814] 
[16:18:40.814] resolved() for ‘SequentialFuture’ ...
[16:18:40.815] - state: ‘finished’
[16:18:40.815] - run: TRUE
[16:18:40.815] - result: ‘FutureResult’
[16:18:40.815] resolved() for ‘SequentialFuture’ ... done
[16:18:40.815] Future #1
[16:18:40.815] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.815] - nx: 1
[16:18:40.816] - relay: TRUE
[16:18:40.817] - stdout: TRUE
[16:18:40.817] - signal: TRUE
[16:18:40.818] - resignal: FALSE
[16:18:40.818] - force: TRUE
[16:18:40.818] - relayed: [n=1] FALSE
[16:18:40.818] - queued futures: [n=1] FALSE
[16:18:40.818]  - until=1
[16:18:40.818]  - relaying element #1
[16:18:40.818] - relayed: [n=1] TRUE
[16:18:40.818] - queued futures: [n=1] TRUE
[16:18:40.818] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.819]  length: 0 (resolved future 1)
[16:18:40.819] Relaying remaining futures
[16:18:40.819] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.819] - nx: 1
[16:18:40.819] - relay: TRUE
[16:18:40.819] - stdout: TRUE
[16:18:40.819] - signal: TRUE
[16:18:40.819] - resignal: FALSE
[16:18:40.819] - force: TRUE
[16:18:40.819] - relayed: [n=1] TRUE
[16:18:40.820] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.820] - relayed: [n=1] TRUE
[16:18:40.820] - queued futures: [n=1] TRUE
[16:18:40.820] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.820] resolve() on list ... DONE
[16:18:40.820]  - Number of value chunks collected: 1
[16:18:40.820] Resolving 1 futures (chunks) ... DONE
[16:18:40.820] Reducing values from 1 chunks ...
[16:18:40.821]  - Number of values collected after concatenation: 5
[16:18:40.821]  - Number of values expected: 5
[16:18:40.821] Reducing values from 1 chunks ... DONE
[16:18:40.821] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[16:18:40.823] future_mapply() ...
[16:18:40.823] Number of chunks: 1
[16:18:40.823] getGlobalsAndPackagesXApply() ...
[16:18:40.823]  - future.globals: TRUE
[16:18:40.823] getGlobalsAndPackages() ...
[16:18:40.823] Searching for globals...
[16:18:40.824] - globals found: [1] ‘FUN’
[16:18:40.824] Searching for globals ... DONE
[16:18:40.824] Resolving globals: FALSE
[16:18:40.824] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:40.825] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:40.825] - globals: [1] ‘FUN’
[16:18:40.825] 
[16:18:40.825] getGlobalsAndPackages() ... DONE
[16:18:40.825]  - globals found/used: [n=1] ‘FUN’
[16:18:40.825]  - needed namespaces: [n=0] 
[16:18:40.825] Finding globals ... DONE
[16:18:40.825] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.825] List of 2
[16:18:40.825]  $ ...future.FUN:function (e1, e2)  
[16:18:40.825]  $ MoreArgs     : NULL
[16:18:40.825]  - attr(*, "where")=List of 2
[16:18:40.825]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.825]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.825]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.825]  - attr(*, "resolved")= logi FALSE
[16:18:40.825]  - attr(*, "total_size")= num NA
[16:18:40.828] Packages to be attached in all futures: [n=0] 
[16:18:40.828] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.828] Number of futures (= number of chunks): 1
[16:18:40.828] Launching 1 futures (chunks) ...
[16:18:40.828] Chunk #1 of 1 ...
[16:18:40.828]  - Finding globals in '...' for chunk #1 ...
[16:18:40.829] getGlobalsAndPackages() ...
[16:18:40.829] Searching for globals...
[16:18:40.829] 
[16:18:40.829] Searching for globals ... DONE
[16:18:40.829] - globals: [0] <none>
[16:18:40.829] getGlobalsAndPackages() ... DONE
[16:18:40.829]    + additional globals found: [n=0] 
[16:18:40.829]    + additional namespaces needed: [n=0] 
[16:18:40.829]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.830]  - seeds: <none>
[16:18:40.830]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.830] getGlobalsAndPackages() ...
[16:18:40.830] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.830] Resolving globals: FALSE
[16:18:40.830] The total size of the 5 globals is 392 bytes (392 bytes)
[16:18:40.831] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 392 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (336 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.831] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.831] 
[16:18:40.831] getGlobalsAndPackages() ... DONE
[16:18:40.831] run() for ‘Future’ ...
[16:18:40.832] - state: ‘created’
[16:18:40.832] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.832] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.832] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.832]   - Field: ‘label’
[16:18:40.832]   - Field: ‘local’
[16:18:40.832]   - Field: ‘owner’
[16:18:40.833]   - Field: ‘envir’
[16:18:40.833]   - Field: ‘packages’
[16:18:40.833]   - Field: ‘gc’
[16:18:40.833]   - Field: ‘conditions’
[16:18:40.833]   - Field: ‘expr’
[16:18:40.833]   - Field: ‘uuid’
[16:18:40.833]   - Field: ‘seed’
[16:18:40.833]   - Field: ‘version’
[16:18:40.833]   - Field: ‘result’
[16:18:40.833]   - Field: ‘asynchronous’
[16:18:40.833]   - Field: ‘calls’
[16:18:40.834]   - Field: ‘globals’
[16:18:40.834]   - Field: ‘stdout’
[16:18:40.834]   - Field: ‘earlySignal’
[16:18:40.834]   - Field: ‘lazy’
[16:18:40.834]   - Field: ‘state’
[16:18:40.834] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.834] - Launch lazy future ...
[16:18:40.834] Packages needed by the future expression (n = 0): <none>
[16:18:40.834] Packages needed by future strategies (n = 0): <none>
[16:18:40.835] {
[16:18:40.835]     {
[16:18:40.835]         {
[16:18:40.835]             ...future.startTime <- base::Sys.time()
[16:18:40.835]             {
[16:18:40.835]                 {
[16:18:40.835]                   {
[16:18:40.835]                     base::local({
[16:18:40.835]                       has_future <- base::requireNamespace("future", 
[16:18:40.835]                         quietly = TRUE)
[16:18:40.835]                       if (has_future) {
[16:18:40.835]                         ns <- base::getNamespace("future")
[16:18:40.835]                         version <- ns[[".package"]][["version"]]
[16:18:40.835]                         if (is.null(version)) 
[16:18:40.835]                           version <- utils::packageVersion("future")
[16:18:40.835]                       }
[16:18:40.835]                       else {
[16:18:40.835]                         version <- NULL
[16:18:40.835]                       }
[16:18:40.835]                       if (!has_future || version < "1.8.0") {
[16:18:40.835]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.835]                           "", base::R.version$version.string), 
[16:18:40.835]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.835]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.835]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.835]                             "release", "version")], collapse = " "), 
[16:18:40.835]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.835]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.835]                           info)
[16:18:40.835]                         info <- base::paste(info, collapse = "; ")
[16:18:40.835]                         if (!has_future) {
[16:18:40.835]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.835]                             info)
[16:18:40.835]                         }
[16:18:40.835]                         else {
[16:18:40.835]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.835]                             info, version)
[16:18:40.835]                         }
[16:18:40.835]                         base::stop(msg)
[16:18:40.835]                       }
[16:18:40.835]                     })
[16:18:40.835]                   }
[16:18:40.835]                   ...future.strategy.old <- future::plan("list")
[16:18:40.835]                   options(future.plan = NULL)
[16:18:40.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.835]                 }
[16:18:40.835]                 ...future.workdir <- getwd()
[16:18:40.835]             }
[16:18:40.835]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.835]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.835]         }
[16:18:40.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.835]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.835]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.835]             base::names(...future.oldOptions))
[16:18:40.835]     }
[16:18:40.835]     if (FALSE) {
[16:18:40.835]     }
[16:18:40.835]     else {
[16:18:40.835]         if (TRUE) {
[16:18:40.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.835]                 open = "w")
[16:18:40.835]         }
[16:18:40.835]         else {
[16:18:40.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.835]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.835]         }
[16:18:40.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.835]             base::sink(type = "output", split = FALSE)
[16:18:40.835]             base::close(...future.stdout)
[16:18:40.835]         }, add = TRUE)
[16:18:40.835]     }
[16:18:40.835]     ...future.frame <- base::sys.nframe()
[16:18:40.835]     ...future.conditions <- base::list()
[16:18:40.835]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.835]     if (FALSE) {
[16:18:40.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.835]     }
[16:18:40.835]     ...future.result <- base::tryCatch({
[16:18:40.835]         base::withCallingHandlers({
[16:18:40.835]             ...future.value <- base::withVisible(base::local({
[16:18:40.835]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.835]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.835]                   ...future.globals.maxSize)) {
[16:18:40.835]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.835]                   on.exit(options(oopts), add = TRUE)
[16:18:40.835]                 }
[16:18:40.835]                 {
[16:18:40.835]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.835]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.835]                     USE.NAMES = FALSE)
[16:18:40.835]                   do.call(mapply, args = args)
[16:18:40.835]                 }
[16:18:40.835]             }))
[16:18:40.835]             future::FutureResult(value = ...future.value$value, 
[16:18:40.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.835]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.835]                     ...future.globalenv.names))
[16:18:40.835]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.835]         }, condition = base::local({
[16:18:40.835]             c <- base::c
[16:18:40.835]             inherits <- base::inherits
[16:18:40.835]             invokeRestart <- base::invokeRestart
[16:18:40.835]             length <- base::length
[16:18:40.835]             list <- base::list
[16:18:40.835]             seq.int <- base::seq.int
[16:18:40.835]             signalCondition <- base::signalCondition
[16:18:40.835]             sys.calls <- base::sys.calls
[16:18:40.835]             `[[` <- base::`[[`
[16:18:40.835]             `+` <- base::`+`
[16:18:40.835]             `<<-` <- base::`<<-`
[16:18:40.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.835]                   3L)]
[16:18:40.835]             }
[16:18:40.835]             function(cond) {
[16:18:40.835]                 is_error <- inherits(cond, "error")
[16:18:40.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.835]                   NULL)
[16:18:40.835]                 if (is_error) {
[16:18:40.835]                   sessionInformation <- function() {
[16:18:40.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.835]                       search = base::search(), system = base::Sys.info())
[16:18:40.835]                   }
[16:18:40.835]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.835]                     cond$call), session = sessionInformation(), 
[16:18:40.835]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.835]                   signalCondition(cond)
[16:18:40.835]                 }
[16:18:40.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.835]                 "immediateCondition"))) {
[16:18:40.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.835]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.835]                   if (TRUE && !signal) {
[16:18:40.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.835]                     {
[16:18:40.835]                       inherits <- base::inherits
[16:18:40.835]                       invokeRestart <- base::invokeRestart
[16:18:40.835]                       is.null <- base::is.null
[16:18:40.835]                       muffled <- FALSE
[16:18:40.835]                       if (inherits(cond, "message")) {
[16:18:40.835]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.835]                         if (muffled) 
[16:18:40.835]                           invokeRestart("muffleMessage")
[16:18:40.835]                       }
[16:18:40.835]                       else if (inherits(cond, "warning")) {
[16:18:40.835]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.835]                         if (muffled) 
[16:18:40.835]                           invokeRestart("muffleWarning")
[16:18:40.835]                       }
[16:18:40.835]                       else if (inherits(cond, "condition")) {
[16:18:40.835]                         if (!is.null(pattern)) {
[16:18:40.835]                           computeRestarts <- base::computeRestarts
[16:18:40.835]                           grepl <- base::grepl
[16:18:40.835]                           restarts <- computeRestarts(cond)
[16:18:40.835]                           for (restart in restarts) {
[16:18:40.835]                             name <- restart$name
[16:18:40.835]                             if (is.null(name)) 
[16:18:40.835]                               next
[16:18:40.835]                             if (!grepl(pattern, name)) 
[16:18:40.835]                               next
[16:18:40.835]                             invokeRestart(restart)
[16:18:40.835]                             muffled <- TRUE
[16:18:40.835]                             break
[16:18:40.835]                           }
[16:18:40.835]                         }
[16:18:40.835]                       }
[16:18:40.835]                       invisible(muffled)
[16:18:40.835]                     }
[16:18:40.835]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.835]                   }
[16:18:40.835]                 }
[16:18:40.835]                 else {
[16:18:40.835]                   if (TRUE) {
[16:18:40.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.835]                     {
[16:18:40.835]                       inherits <- base::inherits
[16:18:40.835]                       invokeRestart <- base::invokeRestart
[16:18:40.835]                       is.null <- base::is.null
[16:18:40.835]                       muffled <- FALSE
[16:18:40.835]                       if (inherits(cond, "message")) {
[16:18:40.835]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.835]                         if (muffled) 
[16:18:40.835]                           invokeRestart("muffleMessage")
[16:18:40.835]                       }
[16:18:40.835]                       else if (inherits(cond, "warning")) {
[16:18:40.835]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.835]                         if (muffled) 
[16:18:40.835]                           invokeRestart("muffleWarning")
[16:18:40.835]                       }
[16:18:40.835]                       else if (inherits(cond, "condition")) {
[16:18:40.835]                         if (!is.null(pattern)) {
[16:18:40.835]                           computeRestarts <- base::computeRestarts
[16:18:40.835]                           grepl <- base::grepl
[16:18:40.835]                           restarts <- computeRestarts(cond)
[16:18:40.835]                           for (restart in restarts) {
[16:18:40.835]                             name <- restart$name
[16:18:40.835]                             if (is.null(name)) 
[16:18:40.835]                               next
[16:18:40.835]                             if (!grepl(pattern, name)) 
[16:18:40.835]                               next
[16:18:40.835]                             invokeRestart(restart)
[16:18:40.835]                             muffled <- TRUE
[16:18:40.835]                             break
[16:18:40.835]                           }
[16:18:40.835]                         }
[16:18:40.835]                       }
[16:18:40.835]                       invisible(muffled)
[16:18:40.835]                     }
[16:18:40.835]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.835]                   }
[16:18:40.835]                 }
[16:18:40.835]             }
[16:18:40.835]         }))
[16:18:40.835]     }, error = function(ex) {
[16:18:40.835]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.835]                 ...future.rng), started = ...future.startTime, 
[16:18:40.835]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.835]             version = "1.8"), class = "FutureResult")
[16:18:40.835]     }, finally = {
[16:18:40.835]         if (!identical(...future.workdir, getwd())) 
[16:18:40.835]             setwd(...future.workdir)
[16:18:40.835]         {
[16:18:40.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.835]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.835]             }
[16:18:40.835]             base::options(...future.oldOptions)
[16:18:40.835]             if (.Platform$OS.type == "windows") {
[16:18:40.835]                 old_names <- names(...future.oldEnvVars)
[16:18:40.835]                 envs <- base::Sys.getenv()
[16:18:40.835]                 names <- names(envs)
[16:18:40.835]                 common <- intersect(names, old_names)
[16:18:40.835]                 added <- setdiff(names, old_names)
[16:18:40.835]                 removed <- setdiff(old_names, names)
[16:18:40.835]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.835]                   envs[common]]
[16:18:40.835]                 NAMES <- toupper(changed)
[16:18:40.835]                 args <- list()
[16:18:40.835]                 for (kk in seq_along(NAMES)) {
[16:18:40.835]                   name <- changed[[kk]]
[16:18:40.835]                   NAME <- NAMES[[kk]]
[16:18:40.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.835]                     next
[16:18:40.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.835]                 }
[16:18:40.835]                 NAMES <- toupper(added)
[16:18:40.835]                 for (kk in seq_along(NAMES)) {
[16:18:40.835]                   name <- added[[kk]]
[16:18:40.835]                   NAME <- NAMES[[kk]]
[16:18:40.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.835]                     next
[16:18:40.835]                   args[[name]] <- ""
[16:18:40.835]                 }
[16:18:40.835]                 NAMES <- toupper(removed)
[16:18:40.835]                 for (kk in seq_along(NAMES)) {
[16:18:40.835]                   name <- removed[[kk]]
[16:18:40.835]                   NAME <- NAMES[[kk]]
[16:18:40.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.835]                     next
[16:18:40.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.835]                 }
[16:18:40.835]                 if (length(args) > 0) 
[16:18:40.835]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.835]             }
[16:18:40.835]             else {
[16:18:40.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.835]             }
[16:18:40.835]             {
[16:18:40.835]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.835]                   0L) {
[16:18:40.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.835]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.835]                   base::options(opts)
[16:18:40.835]                 }
[16:18:40.835]                 {
[16:18:40.835]                   {
[16:18:40.835]                     base::assign(".Random.seed", c(10407L, 1938424795L, 
[16:18:40.835]                     1465562866L, 1706010716L, 1047074623L, -1268480809L, 
[16:18:40.835]                     227942610L), envir = base::globalenv(), inherits = FALSE)
[16:18:40.835]                     NULL
[16:18:40.835]                   }
[16:18:40.835]                   options(future.plan = NULL)
[16:18:40.835]                   if (is.na(NA_character_)) 
[16:18:40.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.835]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.835]                     .init = FALSE)
[16:18:40.835]                 }
[16:18:40.835]             }
[16:18:40.835]         }
[16:18:40.835]     })
[16:18:40.835]     if (TRUE) {
[16:18:40.835]         base::sink(type = "output", split = FALSE)
[16:18:40.835]         if (TRUE) {
[16:18:40.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.835]         }
[16:18:40.835]         else {
[16:18:40.835]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.835]         }
[16:18:40.835]         base::close(...future.stdout)
[16:18:40.835]         ...future.stdout <- NULL
[16:18:40.835]     }
[16:18:40.835]     ...future.result$conditions <- ...future.conditions
[16:18:40.835]     ...future.result$finished <- base::Sys.time()
[16:18:40.835]     ...future.result
[16:18:40.835] }
[16:18:40.836] assign_globals() ...
[16:18:40.836] List of 5
[16:18:40.836]  $ ...future.FUN            :function (e1, e2)  
[16:18:40.836]  $ MoreArgs                 : NULL
[16:18:40.836]  $ ...future.elements_ii    :List of 2
[16:18:40.836]   ..$ :List of 3
[16:18:40.836]   .. ..$ : num 1
[16:18:40.836]   .. ..$ : num 1
[16:18:40.836]   .. ..$ : num 1
[16:18:40.836]   ..$ :List of 3
[16:18:40.836]   .. ..$ : int 1
[16:18:40.836]   .. ..$ : int 2
[16:18:40.836]   .. ..$ : int 3
[16:18:40.836]  $ ...future.seeds_ii       : NULL
[16:18:40.836]  $ ...future.globals.maxSize: NULL
[16:18:40.836]  - attr(*, "where")=List of 5
[16:18:40.836]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.836]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.836]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.836]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.836]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.836]  - attr(*, "resolved")= logi FALSE
[16:18:40.836]  - attr(*, "total_size")= num 392
[16:18:40.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.836]  - attr(*, "already-done")= logi TRUE
[16:18:40.845] - copied ‘...future.FUN’ to environment
[16:18:40.845] - copied ‘MoreArgs’ to environment
[16:18:40.845] - copied ‘...future.elements_ii’ to environment
[16:18:40.845] - copied ‘...future.seeds_ii’ to environment
[16:18:40.845] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.845] assign_globals() ... done
[16:18:40.846] plan(): Setting new future strategy stack:
[16:18:40.846] List of future strategies:
[16:18:40.846] 1. sequential:
[16:18:40.846]    - args: function (..., envir = parent.frame())
[16:18:40.846]    - tweaked: FALSE
[16:18:40.846]    - call: NULL
[16:18:40.846] plan(): nbrOfWorkers() = 1
[16:18:40.847] plan(): Setting new future strategy stack:
[16:18:40.847] List of future strategies:
[16:18:40.847] 1. sequential:
[16:18:40.847]    - args: function (..., envir = parent.frame())
[16:18:40.847]    - tweaked: FALSE
[16:18:40.847]    - call: plan(strategy)
[16:18:40.847] plan(): nbrOfWorkers() = 1
[16:18:40.848] SequentialFuture started (and completed)
[16:18:40.848] - Launch lazy future ... done
[16:18:40.848] run() for ‘SequentialFuture’ ... done
[16:18:40.848] Created future:
[16:18:40.848] SequentialFuture:
[16:18:40.848] Label: ‘future_Map-1’
[16:18:40.848] Expression:
[16:18:40.848] {
[16:18:40.848]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.848]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.848]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.848]         on.exit(options(oopts), add = TRUE)
[16:18:40.848]     }
[16:18:40.848]     {
[16:18:40.848]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.848]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.848]         do.call(mapply, args = args)
[16:18:40.848]     }
[16:18:40.848] }
[16:18:40.848] Lazy evaluation: FALSE
[16:18:40.848] Asynchronous evaluation: FALSE
[16:18:40.848] Local evaluation: TRUE
[16:18:40.848] Environment: R_GlobalEnv
[16:18:40.848] Capture standard output: TRUE
[16:18:40.848] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.848] Globals: 5 objects totaling 392 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.848] Packages: <none>
[16:18:40.848] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.848] Resolved: TRUE
[16:18:40.848] Value: 168 bytes of class ‘list’
[16:18:40.848] Early signaling: FALSE
[16:18:40.848] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.848] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.849] Chunk #1 of 1 ... DONE
[16:18:40.849] Launching 1 futures (chunks) ... DONE
[16:18:40.849] Resolving 1 futures (chunks) ...
[16:18:40.849] resolve() on list ...
[16:18:40.850]  recursive: 0
[16:18:40.850]  length: 1
[16:18:40.850] 
[16:18:40.850] resolved() for ‘SequentialFuture’ ...
[16:18:40.850] - state: ‘finished’
[16:18:40.850] - run: TRUE
[16:18:40.850] - result: ‘FutureResult’
[16:18:40.850] resolved() for ‘SequentialFuture’ ... done
[16:18:40.850] Future #1
[16:18:40.850] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.851] - nx: 1
[16:18:40.851] - relay: TRUE
[16:18:40.851] - stdout: TRUE
[16:18:40.851] - signal: TRUE
[16:18:40.851] - resignal: FALSE
[16:18:40.851] - force: TRUE
[16:18:40.851] - relayed: [n=1] FALSE
[16:18:40.851] - queued futures: [n=1] FALSE
[16:18:40.851]  - until=1
[16:18:40.851]  - relaying element #1
[16:18:40.852] - relayed: [n=1] TRUE
[16:18:40.852] - queued futures: [n=1] TRUE
[16:18:40.852] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.852]  length: 0 (resolved future 1)
[16:18:40.852] Relaying remaining futures
[16:18:40.852] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.852] - nx: 1
[16:18:40.852] - relay: TRUE
[16:18:40.852] - stdout: TRUE
[16:18:40.852] - signal: TRUE
[16:18:40.852] - resignal: FALSE
[16:18:40.853] - force: TRUE
[16:18:40.853] - relayed: [n=1] TRUE
[16:18:40.853] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.853] - relayed: [n=1] TRUE
[16:18:40.853] - queued futures: [n=1] TRUE
[16:18:40.853] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.853] resolve() on list ... DONE
[16:18:40.853]  - Number of value chunks collected: 1
[16:18:40.853] Resolving 1 futures (chunks) ... DONE
[16:18:40.853] Reducing values from 1 chunks ...
[16:18:40.853]  - Number of values collected after concatenation: 3
[16:18:40.854]  - Number of values expected: 3
[16:18:40.854] Reducing values from 1 chunks ... DONE
[16:18:40.854] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[16:18:40.854] future_mapply() ...
[16:18:40.854] Number of chunks: 1
[16:18:40.854] getGlobalsAndPackagesXApply() ...
[16:18:40.855]  - future.globals: TRUE
[16:18:40.855] getGlobalsAndPackages() ...
[16:18:40.855] Searching for globals...
[16:18:40.856] - globals found: [1] ‘FUN’
[16:18:40.856] Searching for globals ... DONE
[16:18:40.856] Resolving globals: FALSE
[16:18:40.856] The total size of the 1 globals is 848 bytes (848 bytes)
[16:18:40.857] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:18:40.857] - globals: [1] ‘FUN’
[16:18:40.857] 
[16:18:40.857] getGlobalsAndPackages() ... DONE
[16:18:40.857]  - globals found/used: [n=1] ‘FUN’
[16:18:40.857]  - needed namespaces: [n=0] 
[16:18:40.857] Finding globals ... DONE
[16:18:40.857] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.858] List of 2
[16:18:40.858]  $ ...future.FUN:function (x)  
[16:18:40.858]  $ MoreArgs     : NULL
[16:18:40.858]  - attr(*, "where")=List of 2
[16:18:40.858]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.858]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.858]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.858]  - attr(*, "resolved")= logi FALSE
[16:18:40.858]  - attr(*, "total_size")= num NA
[16:18:40.860] Packages to be attached in all futures: [n=0] 
[16:18:40.860] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.860] Number of futures (= number of chunks): 1
[16:18:40.860] Launching 1 futures (chunks) ...
[16:18:40.860] Chunk #1 of 1 ...
[16:18:40.861]  - Finding globals in '...' for chunk #1 ...
[16:18:40.861] getGlobalsAndPackages() ...
[16:18:40.861] Searching for globals...
[16:18:40.861] 
[16:18:40.861] Searching for globals ... DONE
[16:18:40.861] - globals: [0] <none>
[16:18:40.861] getGlobalsAndPackages() ... DONE
[16:18:40.861]    + additional globals found: [n=0] 
[16:18:40.862]    + additional namespaces needed: [n=0] 
[16:18:40.862]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.862]  - seeds: <none>
[16:18:40.862]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.862] getGlobalsAndPackages() ...
[16:18:40.862] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.862] Resolving globals: FALSE
[16:18:40.863] The total size of the 5 globals is 960 bytes (960 bytes)
[16:18:40.863] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 960 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.863] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.863] 
[16:18:40.863] getGlobalsAndPackages() ... DONE
[16:18:40.865] run() for ‘Future’ ...
[16:18:40.866] - state: ‘created’
[16:18:40.866] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:18:40.866] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.866] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:18:40.866]   - Field: ‘label’
[16:18:40.866]   - Field: ‘local’
[16:18:40.867]   - Field: ‘owner’
[16:18:40.867]   - Field: ‘envir’
[16:18:40.867]   - Field: ‘packages’
[16:18:40.867]   - Field: ‘gc’
[16:18:40.867]   - Field: ‘conditions’
[16:18:40.867]   - Field: ‘expr’
[16:18:40.867]   - Field: ‘uuid’
[16:18:40.867]   - Field: ‘seed’
[16:18:40.867]   - Field: ‘version’
[16:18:40.867]   - Field: ‘result’
[16:18:40.868]   - Field: ‘asynchronous’
[16:18:40.868]   - Field: ‘calls’
[16:18:40.868]   - Field: ‘globals’
[16:18:40.868]   - Field: ‘stdout’
[16:18:40.868]   - Field: ‘earlySignal’
[16:18:40.868]   - Field: ‘lazy’
[16:18:40.868]   - Field: ‘state’
[16:18:40.868] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:18:40.868] - Launch lazy future ...
[16:18:40.869] Packages needed by the future expression (n = 0): <none>
[16:18:40.869] Packages needed by future strategies (n = 0): <none>
[16:18:40.869] {
[16:18:40.869]     {
[16:18:40.869]         {
[16:18:40.869]             ...future.startTime <- base::Sys.time()
[16:18:40.869]             {
[16:18:40.869]                 {
[16:18:40.869]                   {
[16:18:40.869]                     base::local({
[16:18:40.869]                       has_future <- base::requireNamespace("future", 
[16:18:40.869]                         quietly = TRUE)
[16:18:40.869]                       if (has_future) {
[16:18:40.869]                         ns <- base::getNamespace("future")
[16:18:40.869]                         version <- ns[[".package"]][["version"]]
[16:18:40.869]                         if (is.null(version)) 
[16:18:40.869]                           version <- utils::packageVersion("future")
[16:18:40.869]                       }
[16:18:40.869]                       else {
[16:18:40.869]                         version <- NULL
[16:18:40.869]                       }
[16:18:40.869]                       if (!has_future || version < "1.8.0") {
[16:18:40.869]                         info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.869]                           "", base::R.version$version.string), 
[16:18:40.869]                           platform = base::sprintf("%s (%s-bit)", 
[16:18:40.869]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.869]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.869]                             "release", "version")], collapse = " "), 
[16:18:40.869]                           hostname = base::Sys.info()[["nodename"]])
[16:18:40.869]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.869]                           info)
[16:18:40.869]                         info <- base::paste(info, collapse = "; ")
[16:18:40.869]                         if (!has_future) {
[16:18:40.869]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.869]                             info)
[16:18:40.869]                         }
[16:18:40.869]                         else {
[16:18:40.869]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.869]                             info, version)
[16:18:40.869]                         }
[16:18:40.869]                         base::stop(msg)
[16:18:40.869]                       }
[16:18:40.869]                     })
[16:18:40.869]                   }
[16:18:40.869]                   ...future.strategy.old <- future::plan("list")
[16:18:40.869]                   options(future.plan = NULL)
[16:18:40.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.869]                 }
[16:18:40.869]                 ...future.workdir <- getwd()
[16:18:40.869]             }
[16:18:40.869]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.869]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.869]         }
[16:18:40.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.869]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:40.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.869]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.869]             base::names(...future.oldOptions))
[16:18:40.869]     }
[16:18:40.869]     if (FALSE) {
[16:18:40.869]     }
[16:18:40.869]     else {
[16:18:40.869]         if (TRUE) {
[16:18:40.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.869]                 open = "w")
[16:18:40.869]         }
[16:18:40.869]         else {
[16:18:40.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.869]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.869]         }
[16:18:40.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.869]             base::sink(type = "output", split = FALSE)
[16:18:40.869]             base::close(...future.stdout)
[16:18:40.869]         }, add = TRUE)
[16:18:40.869]     }
[16:18:40.869]     ...future.frame <- base::sys.nframe()
[16:18:40.869]     ...future.conditions <- base::list()
[16:18:40.869]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.869]     if (FALSE) {
[16:18:40.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.869]     }
[16:18:40.869]     ...future.result <- base::tryCatch({
[16:18:40.869]         base::withCallingHandlers({
[16:18:40.869]             ...future.value <- base::withVisible(base::local({
[16:18:40.869]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.869]                 if (!identical(...future.globals.maxSize.org, 
[16:18:40.869]                   ...future.globals.maxSize)) {
[16:18:40.869]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.869]                   on.exit(options(oopts), add = TRUE)
[16:18:40.869]                 }
[16:18:40.869]                 {
[16:18:40.869]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.869]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.869]                     USE.NAMES = FALSE)
[16:18:40.869]                   do.call(mapply, args = args)
[16:18:40.869]                 }
[16:18:40.869]             }))
[16:18:40.869]             future::FutureResult(value = ...future.value$value, 
[16:18:40.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.869]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.869]                     ...future.globalenv.names))
[16:18:40.869]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.869]         }, condition = base::local({
[16:18:40.869]             c <- base::c
[16:18:40.869]             inherits <- base::inherits
[16:18:40.869]             invokeRestart <- base::invokeRestart
[16:18:40.869]             length <- base::length
[16:18:40.869]             list <- base::list
[16:18:40.869]             seq.int <- base::seq.int
[16:18:40.869]             signalCondition <- base::signalCondition
[16:18:40.869]             sys.calls <- base::sys.calls
[16:18:40.869]             `[[` <- base::`[[`
[16:18:40.869]             `+` <- base::`+`
[16:18:40.869]             `<<-` <- base::`<<-`
[16:18:40.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.869]                   3L)]
[16:18:40.869]             }
[16:18:40.869]             function(cond) {
[16:18:40.869]                 is_error <- inherits(cond, "error")
[16:18:40.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.869]                   NULL)
[16:18:40.869]                 if (is_error) {
[16:18:40.869]                   sessionInformation <- function() {
[16:18:40.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.869]                       search = base::search(), system = base::Sys.info())
[16:18:40.869]                   }
[16:18:40.869]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.869]                     cond$call), session = sessionInformation(), 
[16:18:40.869]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.869]                   signalCondition(cond)
[16:18:40.869]                 }
[16:18:40.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.869]                 "immediateCondition"))) {
[16:18:40.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.869]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.869]                   if (TRUE && !signal) {
[16:18:40.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.869]                     {
[16:18:40.869]                       inherits <- base::inherits
[16:18:40.869]                       invokeRestart <- base::invokeRestart
[16:18:40.869]                       is.null <- base::is.null
[16:18:40.869]                       muffled <- FALSE
[16:18:40.869]                       if (inherits(cond, "message")) {
[16:18:40.869]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.869]                         if (muffled) 
[16:18:40.869]                           invokeRestart("muffleMessage")
[16:18:40.869]                       }
[16:18:40.869]                       else if (inherits(cond, "warning")) {
[16:18:40.869]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.869]                         if (muffled) 
[16:18:40.869]                           invokeRestart("muffleWarning")
[16:18:40.869]                       }
[16:18:40.869]                       else if (inherits(cond, "condition")) {
[16:18:40.869]                         if (!is.null(pattern)) {
[16:18:40.869]                           computeRestarts <- base::computeRestarts
[16:18:40.869]                           grepl <- base::grepl
[16:18:40.869]                           restarts <- computeRestarts(cond)
[16:18:40.869]                           for (restart in restarts) {
[16:18:40.869]                             name <- restart$name
[16:18:40.869]                             if (is.null(name)) 
[16:18:40.869]                               next
[16:18:40.869]                             if (!grepl(pattern, name)) 
[16:18:40.869]                               next
[16:18:40.869]                             invokeRestart(restart)
[16:18:40.869]                             muffled <- TRUE
[16:18:40.869]                             break
[16:18:40.869]                           }
[16:18:40.869]                         }
[16:18:40.869]                       }
[16:18:40.869]                       invisible(muffled)
[16:18:40.869]                     }
[16:18:40.869]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.869]                   }
[16:18:40.869]                 }
[16:18:40.869]                 else {
[16:18:40.869]                   if (TRUE) {
[16:18:40.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.869]                     {
[16:18:40.869]                       inherits <- base::inherits
[16:18:40.869]                       invokeRestart <- base::invokeRestart
[16:18:40.869]                       is.null <- base::is.null
[16:18:40.869]                       muffled <- FALSE
[16:18:40.869]                       if (inherits(cond, "message")) {
[16:18:40.869]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.869]                         if (muffled) 
[16:18:40.869]                           invokeRestart("muffleMessage")
[16:18:40.869]                       }
[16:18:40.869]                       else if (inherits(cond, "warning")) {
[16:18:40.869]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.869]                         if (muffled) 
[16:18:40.869]                           invokeRestart("muffleWarning")
[16:18:40.869]                       }
[16:18:40.869]                       else if (inherits(cond, "condition")) {
[16:18:40.869]                         if (!is.null(pattern)) {
[16:18:40.869]                           computeRestarts <- base::computeRestarts
[16:18:40.869]                           grepl <- base::grepl
[16:18:40.869]                           restarts <- computeRestarts(cond)
[16:18:40.869]                           for (restart in restarts) {
[16:18:40.869]                             name <- restart$name
[16:18:40.869]                             if (is.null(name)) 
[16:18:40.869]                               next
[16:18:40.869]                             if (!grepl(pattern, name)) 
[16:18:40.869]                               next
[16:18:40.869]                             invokeRestart(restart)
[16:18:40.869]                             muffled <- TRUE
[16:18:40.869]                             break
[16:18:40.869]                           }
[16:18:40.869]                         }
[16:18:40.869]                       }
[16:18:40.869]                       invisible(muffled)
[16:18:40.869]                     }
[16:18:40.869]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.869]                   }
[16:18:40.869]                 }
[16:18:40.869]             }
[16:18:40.869]         }))
[16:18:40.869]     }, error = function(ex) {
[16:18:40.869]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.869]                 ...future.rng), started = ...future.startTime, 
[16:18:40.869]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.869]             version = "1.8"), class = "FutureResult")
[16:18:40.869]     }, finally = {
[16:18:40.869]         if (!identical(...future.workdir, getwd())) 
[16:18:40.869]             setwd(...future.workdir)
[16:18:40.869]         {
[16:18:40.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.869]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.869]             }
[16:18:40.869]             base::options(...future.oldOptions)
[16:18:40.869]             if (.Platform$OS.type == "windows") {
[16:18:40.869]                 old_names <- names(...future.oldEnvVars)
[16:18:40.869]                 envs <- base::Sys.getenv()
[16:18:40.869]                 names <- names(envs)
[16:18:40.869]                 common <- intersect(names, old_names)
[16:18:40.869]                 added <- setdiff(names, old_names)
[16:18:40.869]                 removed <- setdiff(old_names, names)
[16:18:40.869]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.869]                   envs[common]]
[16:18:40.869]                 NAMES <- toupper(changed)
[16:18:40.869]                 args <- list()
[16:18:40.869]                 for (kk in seq_along(NAMES)) {
[16:18:40.869]                   name <- changed[[kk]]
[16:18:40.869]                   NAME <- NAMES[[kk]]
[16:18:40.869]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.869]                     next
[16:18:40.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.869]                 }
[16:18:40.869]                 NAMES <- toupper(added)
[16:18:40.869]                 for (kk in seq_along(NAMES)) {
[16:18:40.869]                   name <- added[[kk]]
[16:18:40.869]                   NAME <- NAMES[[kk]]
[16:18:40.869]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.869]                     next
[16:18:40.869]                   args[[name]] <- ""
[16:18:40.869]                 }
[16:18:40.869]                 NAMES <- toupper(removed)
[16:18:40.869]                 for (kk in seq_along(NAMES)) {
[16:18:40.869]                   name <- removed[[kk]]
[16:18:40.869]                   NAME <- NAMES[[kk]]
[16:18:40.869]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.869]                     next
[16:18:40.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.869]                 }
[16:18:40.869]                 if (length(args) > 0) 
[16:18:40.869]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.869]             }
[16:18:40.869]             else {
[16:18:40.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.869]             }
[16:18:40.869]             {
[16:18:40.869]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.869]                   0L) {
[16:18:40.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.869]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.869]                   base::options(opts)
[16:18:40.869]                 }
[16:18:40.869]                 {
[16:18:40.869]                   {
[16:18:40.869]                     base::assign(".Random.seed", c(10407L, 1938424795L, 
[16:18:40.869]                     1465562866L, 1706010716L, 1047074623L, -1268480809L, 
[16:18:40.869]                     227942610L), envir = base::globalenv(), inherits = FALSE)
[16:18:40.869]                     NULL
[16:18:40.869]                   }
[16:18:40.869]                   options(future.plan = NULL)
[16:18:40.869]                   if (is.na(NA_character_)) 
[16:18:40.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.869]                     .init = FALSE)
[16:18:40.869]                 }
[16:18:40.869]             }
[16:18:40.869]         }
[16:18:40.869]     })
[16:18:40.869]     if (TRUE) {
[16:18:40.869]         base::sink(type = "output", split = FALSE)
[16:18:40.869]         if (TRUE) {
[16:18:40.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.869]         }
[16:18:40.869]         else {
[16:18:40.869]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.869]         }
[16:18:40.869]         base::close(...future.stdout)
[16:18:40.869]         ...future.stdout <- NULL
[16:18:40.869]     }
[16:18:40.869]     ...future.result$conditions <- ...future.conditions
[16:18:40.869]     ...future.result$finished <- base::Sys.time()
[16:18:40.869]     ...future.result
[16:18:40.869] }
[16:18:40.871] assign_globals() ...
[16:18:40.871] List of 5
[16:18:40.871]  $ ...future.FUN            :function (x)  
[16:18:40.871]  $ MoreArgs                 : NULL
[16:18:40.871]  $ ...future.elements_ii    :List of 1
[16:18:40.871]   ..$ :List of 2
[16:18:40.871]   .. ..$ a: num 0
[16:18:40.871]   .. ..$ b: num 0
[16:18:40.871]  $ ...future.seeds_ii       : NULL
[16:18:40.871]  $ ...future.globals.maxSize: NULL
[16:18:40.871]  - attr(*, "where")=List of 5
[16:18:40.871]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.871]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.871]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.871]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.871]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.871]  - attr(*, "resolved")= logi FALSE
[16:18:40.871]  - attr(*, "total_size")= num 960
[16:18:40.871]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.871]  - attr(*, "already-done")= logi TRUE
[16:18:40.876] - copied ‘...future.FUN’ to environment
[16:18:40.876] - copied ‘MoreArgs’ to environment
[16:18:40.876] - copied ‘...future.elements_ii’ to environment
[16:18:40.876] - copied ‘...future.seeds_ii’ to environment
[16:18:40.876] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.876] assign_globals() ... done
[16:18:40.877] plan(): Setting new future strategy stack:
[16:18:40.877] List of future strategies:
[16:18:40.877] 1. sequential:
[16:18:40.877]    - args: function (..., envir = parent.frame())
[16:18:40.877]    - tweaked: FALSE
[16:18:40.877]    - call: NULL
[16:18:40.877] plan(): nbrOfWorkers() = 1
[16:18:40.878] plan(): Setting new future strategy stack:
[16:18:40.878] List of future strategies:
[16:18:40.878] 1. sequential:
[16:18:40.878]    - args: function (..., envir = parent.frame())
[16:18:40.878]    - tweaked: FALSE
[16:18:40.878]    - call: plan(strategy)
[16:18:40.878] plan(): nbrOfWorkers() = 1
[16:18:40.878] SequentialFuture started (and completed)
[16:18:40.878] - Launch lazy future ... done
[16:18:40.878] run() for ‘SequentialFuture’ ... done
[16:18:40.879] Created future:
[16:18:40.879] SequentialFuture:
[16:18:40.879] Label: ‘future_mapply-1’
[16:18:40.879] Expression:
[16:18:40.879] {
[16:18:40.879]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.879]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.879]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.879]         on.exit(options(oopts), add = TRUE)
[16:18:40.879]     }
[16:18:40.879]     {
[16:18:40.879]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.879]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.879]         do.call(mapply, args = args)
[16:18:40.879]     }
[16:18:40.879] }
[16:18:40.879] Lazy evaluation: FALSE
[16:18:40.879] Asynchronous evaluation: FALSE
[16:18:40.879] Local evaluation: TRUE
[16:18:40.879] Environment: R_GlobalEnv
[16:18:40.879] Capture standard output: TRUE
[16:18:40.879] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.879] Globals: 5 objects totaling 960 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.879] Packages: <none>
[16:18:40.879] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.879] Resolved: TRUE
[16:18:40.879] Value: 112 bytes of class ‘list’
[16:18:40.879] Early signaling: FALSE
[16:18:40.879] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.879] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:18:40.880] Chunk #1 of 1 ... DONE
[16:18:40.880] Launching 1 futures (chunks) ... DONE
[16:18:40.880] Resolving 1 futures (chunks) ...
[16:18:40.880] resolve() on list ...
[16:18:40.880]  recursive: 0
[16:18:40.880]  length: 1
[16:18:40.880] 
[16:18:40.880] resolved() for ‘SequentialFuture’ ...
[16:18:40.880] - state: ‘finished’
[16:18:40.880] - run: TRUE
[16:18:40.881] - result: ‘FutureResult’
[16:18:40.881] resolved() for ‘SequentialFuture’ ... done
[16:18:40.881] Future #1
[16:18:40.881] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:18:40.881] - nx: 1
[16:18:40.881] - relay: TRUE
[16:18:40.881] - stdout: TRUE
[16:18:40.881] - signal: TRUE
[16:18:40.881] - resignal: FALSE
[16:18:40.881] - force: TRUE
[16:18:40.881] - relayed: [n=1] FALSE
[16:18:40.882] - queued futures: [n=1] FALSE
[16:18:40.882]  - until=1
[16:18:40.882]  - relaying element #1
[16:18:40.882] - relayed: [n=1] TRUE
[16:18:40.882] - queued futures: [n=1] TRUE
[16:18:40.882] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:18:40.882]  length: 0 (resolved future 1)
[16:18:40.882] Relaying remaining futures
[16:18:40.882] signalConditionsASAP(NULL, pos=0) ...
[16:18:40.882] - nx: 1
[16:18:40.883] - relay: TRUE
[16:18:40.883] - stdout: TRUE
[16:18:40.883] - signal: TRUE
[16:18:40.883] - resignal: FALSE
[16:18:40.883] - force: TRUE
[16:18:40.883] - relayed: [n=1] TRUE
[16:18:40.883] - queued futures: [n=1] TRUE
 - flush all
[16:18:40.883] - relayed: [n=1] TRUE
[16:18:40.883] - queued futures: [n=1] TRUE
[16:18:40.883] signalConditionsASAP(NULL, pos=0) ... done
[16:18:40.883] resolve() on list ... DONE
[16:18:40.884]  - Number of value chunks collected: 1
[16:18:40.884] Resolving 1 futures (chunks) ... DONE
[16:18:40.884] Reducing values from 1 chunks ...
[16:18:40.884]  - Number of values collected after concatenation: 2
[16:18:40.884]  - Number of values expected: 2
[16:18:40.884] Reducing values from 1 chunks ... DONE
[16:18:40.884] future_mapply() ... DONE
[16:18:40.884] plan(): Setting new future strategy stack:
[16:18:40.884] List of future strategies:
[16:18:40.884] 1. sequential:
[16:18:40.884]    - args: function (..., envir = parent.frame())
[16:18:40.884]    - tweaked: FALSE
[16:18:40.884]    - call: plan(sequential)
[16:18:40.885] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:18:40.885] plan(): Setting new future strategy stack:
[16:18:40.885] List of future strategies:
[16:18:40.885] 1. multicore:
[16:18:40.885]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:40.885]    - tweaked: FALSE
[16:18:40.885]    - call: plan(strategy)
[16:18:40.889] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[16:18:40.889] future_mapply() ...
[16:18:40.895] Number of chunks: 2
[16:18:40.895] getGlobalsAndPackagesXApply() ...
[16:18:40.895]  - future.globals: TRUE
[16:18:40.895] getGlobalsAndPackages() ...
[16:18:40.895] Searching for globals...
[16:18:40.896] - globals found: [1] ‘FUN’
[16:18:40.896] Searching for globals ... DONE
[16:18:40.896] Resolving globals: FALSE
[16:18:40.897] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:40.897] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:40.897] - globals: [1] ‘FUN’
[16:18:40.897] 
[16:18:40.897] getGlobalsAndPackages() ... DONE
[16:18:40.898]  - globals found/used: [n=1] ‘FUN’
[16:18:40.898]  - needed namespaces: [n=0] 
[16:18:40.898] Finding globals ... DONE
[16:18:40.898] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:40.898] List of 2
[16:18:40.898]  $ ...future.FUN:function (x, ...)  
[16:18:40.898]  $ MoreArgs     : NULL
[16:18:40.898]  - attr(*, "where")=List of 2
[16:18:40.898]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:40.898]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:40.898]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.898]  - attr(*, "resolved")= logi FALSE
[16:18:40.898]  - attr(*, "total_size")= num NA
[16:18:40.901] Packages to be attached in all futures: [n=0] 
[16:18:40.901] getGlobalsAndPackagesXApply() ... DONE
[16:18:40.901] Number of futures (= number of chunks): 2
[16:18:40.901] Launching 2 futures (chunks) ...
[16:18:40.901] Chunk #1 of 2 ...
[16:18:40.901]  - Finding globals in '...' for chunk #1 ...
[16:18:40.902] getGlobalsAndPackages() ...
[16:18:40.902] Searching for globals...
[16:18:40.902] 
[16:18:40.902] Searching for globals ... DONE
[16:18:40.902] - globals: [0] <none>
[16:18:40.902] getGlobalsAndPackages() ... DONE
[16:18:40.902]    + additional globals found: [n=0] 
[16:18:40.902]    + additional namespaces needed: [n=0] 
[16:18:40.903]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:40.903]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:40.903]  - seeds: <none>
[16:18:40.903]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.903] getGlobalsAndPackages() ...
[16:18:40.903] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.903] Resolving globals: FALSE
[16:18:40.904] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:40.904] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.904] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.904] 
[16:18:40.904] getGlobalsAndPackages() ... DONE
[16:18:40.905] run() for ‘Future’ ...
[16:18:40.905] - state: ‘created’
[16:18:40.905] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:40.909] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:40.909] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:40.909]   - Field: ‘label’
[16:18:40.909]   - Field: ‘local’
[16:18:40.909]   - Field: ‘owner’
[16:18:40.909]   - Field: ‘envir’
[16:18:40.909]   - Field: ‘workers’
[16:18:40.909]   - Field: ‘packages’
[16:18:40.909]   - Field: ‘gc’
[16:18:40.910]   - Field: ‘job’
[16:18:40.910]   - Field: ‘conditions’
[16:18:40.910]   - Field: ‘expr’
[16:18:40.910]   - Field: ‘uuid’
[16:18:40.910]   - Field: ‘seed’
[16:18:40.910]   - Field: ‘version’
[16:18:40.910]   - Field: ‘result’
[16:18:40.910]   - Field: ‘asynchronous’
[16:18:40.910]   - Field: ‘calls’
[16:18:40.910]   - Field: ‘globals’
[16:18:40.910]   - Field: ‘stdout’
[16:18:40.911]   - Field: ‘earlySignal’
[16:18:40.911]   - Field: ‘lazy’
[16:18:40.911]   - Field: ‘state’
[16:18:40.911] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:40.911] - Launch lazy future ...
[16:18:40.912] Packages needed by the future expression (n = 0): <none>
[16:18:40.912] Packages needed by future strategies (n = 0): <none>
[16:18:40.913] {
[16:18:40.913]     {
[16:18:40.913]         {
[16:18:40.913]             ...future.startTime <- base::Sys.time()
[16:18:40.913]             {
[16:18:40.913]                 {
[16:18:40.913]                   {
[16:18:40.913]                     {
[16:18:40.913]                       base::local({
[16:18:40.913]                         has_future <- base::requireNamespace("future", 
[16:18:40.913]                           quietly = TRUE)
[16:18:40.913]                         if (has_future) {
[16:18:40.913]                           ns <- base::getNamespace("future")
[16:18:40.913]                           version <- ns[[".package"]][["version"]]
[16:18:40.913]                           if (is.null(version)) 
[16:18:40.913]                             version <- utils::packageVersion("future")
[16:18:40.913]                         }
[16:18:40.913]                         else {
[16:18:40.913]                           version <- NULL
[16:18:40.913]                         }
[16:18:40.913]                         if (!has_future || version < "1.8.0") {
[16:18:40.913]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.913]                             "", base::R.version$version.string), 
[16:18:40.913]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:40.913]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.913]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.913]                               "release", "version")], collapse = " "), 
[16:18:40.913]                             hostname = base::Sys.info()[["nodename"]])
[16:18:40.913]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.913]                             info)
[16:18:40.913]                           info <- base::paste(info, collapse = "; ")
[16:18:40.913]                           if (!has_future) {
[16:18:40.913]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.913]                               info)
[16:18:40.913]                           }
[16:18:40.913]                           else {
[16:18:40.913]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.913]                               info, version)
[16:18:40.913]                           }
[16:18:40.913]                           base::stop(msg)
[16:18:40.913]                         }
[16:18:40.913]                       })
[16:18:40.913]                     }
[16:18:40.913]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:40.913]                     base::options(mc.cores = 1L)
[16:18:40.913]                   }
[16:18:40.913]                   ...future.strategy.old <- future::plan("list")
[16:18:40.913]                   options(future.plan = NULL)
[16:18:40.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.913]                 }
[16:18:40.913]                 ...future.workdir <- getwd()
[16:18:40.913]             }
[16:18:40.913]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.913]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.913]         }
[16:18:40.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.913]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:40.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.913]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.913]             base::names(...future.oldOptions))
[16:18:40.913]     }
[16:18:40.913]     if (FALSE) {
[16:18:40.913]     }
[16:18:40.913]     else {
[16:18:40.913]         if (TRUE) {
[16:18:40.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.913]                 open = "w")
[16:18:40.913]         }
[16:18:40.913]         else {
[16:18:40.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.913]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.913]         }
[16:18:40.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.913]             base::sink(type = "output", split = FALSE)
[16:18:40.913]             base::close(...future.stdout)
[16:18:40.913]         }, add = TRUE)
[16:18:40.913]     }
[16:18:40.913]     ...future.frame <- base::sys.nframe()
[16:18:40.913]     ...future.conditions <- base::list()
[16:18:40.913]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.913]     if (FALSE) {
[16:18:40.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.913]     }
[16:18:40.913]     ...future.result <- base::tryCatch({
[16:18:40.913]         base::withCallingHandlers({
[16:18:40.913]             ...future.value <- base::withVisible(base::local({
[16:18:40.913]                 withCallingHandlers({
[16:18:40.913]                   {
[16:18:40.913]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.913]                     if (!identical(...future.globals.maxSize.org, 
[16:18:40.913]                       ...future.globals.maxSize)) {
[16:18:40.913]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.913]                       on.exit(options(oopts), add = TRUE)
[16:18:40.913]                     }
[16:18:40.913]                     {
[16:18:40.913]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.913]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.913]                         USE.NAMES = FALSE)
[16:18:40.913]                       do.call(mapply, args = args)
[16:18:40.913]                     }
[16:18:40.913]                   }
[16:18:40.913]                 }, immediateCondition = function(cond) {
[16:18:40.913]                   save_rds <- function (object, pathname, ...) 
[16:18:40.913]                   {
[16:18:40.913]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:40.913]                     if (file_test("-f", pathname_tmp)) {
[16:18:40.913]                       fi_tmp <- file.info(pathname_tmp)
[16:18:40.913]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:40.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:40.913]                         fi_tmp[["mtime"]])
[16:18:40.913]                     }
[16:18:40.913]                     tryCatch({
[16:18:40.913]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:40.913]                     }, error = function(ex) {
[16:18:40.913]                       msg <- conditionMessage(ex)
[16:18:40.913]                       fi_tmp <- file.info(pathname_tmp)
[16:18:40.913]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:40.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:40.913]                         fi_tmp[["mtime"]], msg)
[16:18:40.913]                       ex$message <- msg
[16:18:40.913]                       stop(ex)
[16:18:40.913]                     })
[16:18:40.913]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:40.913]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:40.913]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:40.913]                       fi_tmp <- file.info(pathname_tmp)
[16:18:40.913]                       fi <- file.info(pathname)
[16:18:40.913]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:40.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:40.913]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:40.913]                         fi[["size"]], fi[["mtime"]])
[16:18:40.913]                       stop(msg)
[16:18:40.913]                     }
[16:18:40.913]                     invisible(pathname)
[16:18:40.913]                   }
[16:18:40.913]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:40.913]                     rootPath = tempdir()) 
[16:18:40.913]                   {
[16:18:40.913]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:40.913]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:40.913]                       tmpdir = path, fileext = ".rds")
[16:18:40.913]                     save_rds(obj, file)
[16:18:40.913]                   }
[16:18:40.913]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:40.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.913]                   {
[16:18:40.913]                     inherits <- base::inherits
[16:18:40.913]                     invokeRestart <- base::invokeRestart
[16:18:40.913]                     is.null <- base::is.null
[16:18:40.913]                     muffled <- FALSE
[16:18:40.913]                     if (inherits(cond, "message")) {
[16:18:40.913]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:40.913]                       if (muffled) 
[16:18:40.913]                         invokeRestart("muffleMessage")
[16:18:40.913]                     }
[16:18:40.913]                     else if (inherits(cond, "warning")) {
[16:18:40.913]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:40.913]                       if (muffled) 
[16:18:40.913]                         invokeRestart("muffleWarning")
[16:18:40.913]                     }
[16:18:40.913]                     else if (inherits(cond, "condition")) {
[16:18:40.913]                       if (!is.null(pattern)) {
[16:18:40.913]                         computeRestarts <- base::computeRestarts
[16:18:40.913]                         grepl <- base::grepl
[16:18:40.913]                         restarts <- computeRestarts(cond)
[16:18:40.913]                         for (restart in restarts) {
[16:18:40.913]                           name <- restart$name
[16:18:40.913]                           if (is.null(name)) 
[16:18:40.913]                             next
[16:18:40.913]                           if (!grepl(pattern, name)) 
[16:18:40.913]                             next
[16:18:40.913]                           invokeRestart(restart)
[16:18:40.913]                           muffled <- TRUE
[16:18:40.913]                           break
[16:18:40.913]                         }
[16:18:40.913]                       }
[16:18:40.913]                     }
[16:18:40.913]                     invisible(muffled)
[16:18:40.913]                   }
[16:18:40.913]                   muffleCondition(cond)
[16:18:40.913]                 })
[16:18:40.913]             }))
[16:18:40.913]             future::FutureResult(value = ...future.value$value, 
[16:18:40.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.913]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.913]                     ...future.globalenv.names))
[16:18:40.913]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.913]         }, condition = base::local({
[16:18:40.913]             c <- base::c
[16:18:40.913]             inherits <- base::inherits
[16:18:40.913]             invokeRestart <- base::invokeRestart
[16:18:40.913]             length <- base::length
[16:18:40.913]             list <- base::list
[16:18:40.913]             seq.int <- base::seq.int
[16:18:40.913]             signalCondition <- base::signalCondition
[16:18:40.913]             sys.calls <- base::sys.calls
[16:18:40.913]             `[[` <- base::`[[`
[16:18:40.913]             `+` <- base::`+`
[16:18:40.913]             `<<-` <- base::`<<-`
[16:18:40.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.913]                   3L)]
[16:18:40.913]             }
[16:18:40.913]             function(cond) {
[16:18:40.913]                 is_error <- inherits(cond, "error")
[16:18:40.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.913]                   NULL)
[16:18:40.913]                 if (is_error) {
[16:18:40.913]                   sessionInformation <- function() {
[16:18:40.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.913]                       search = base::search(), system = base::Sys.info())
[16:18:40.913]                   }
[16:18:40.913]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.913]                     cond$call), session = sessionInformation(), 
[16:18:40.913]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.913]                   signalCondition(cond)
[16:18:40.913]                 }
[16:18:40.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.913]                 "immediateCondition"))) {
[16:18:40.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.913]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.913]                   if (TRUE && !signal) {
[16:18:40.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.913]                     {
[16:18:40.913]                       inherits <- base::inherits
[16:18:40.913]                       invokeRestart <- base::invokeRestart
[16:18:40.913]                       is.null <- base::is.null
[16:18:40.913]                       muffled <- FALSE
[16:18:40.913]                       if (inherits(cond, "message")) {
[16:18:40.913]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.913]                         if (muffled) 
[16:18:40.913]                           invokeRestart("muffleMessage")
[16:18:40.913]                       }
[16:18:40.913]                       else if (inherits(cond, "warning")) {
[16:18:40.913]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.913]                         if (muffled) 
[16:18:40.913]                           invokeRestart("muffleWarning")
[16:18:40.913]                       }
[16:18:40.913]                       else if (inherits(cond, "condition")) {
[16:18:40.913]                         if (!is.null(pattern)) {
[16:18:40.913]                           computeRestarts <- base::computeRestarts
[16:18:40.913]                           grepl <- base::grepl
[16:18:40.913]                           restarts <- computeRestarts(cond)
[16:18:40.913]                           for (restart in restarts) {
[16:18:40.913]                             name <- restart$name
[16:18:40.913]                             if (is.null(name)) 
[16:18:40.913]                               next
[16:18:40.913]                             if (!grepl(pattern, name)) 
[16:18:40.913]                               next
[16:18:40.913]                             invokeRestart(restart)
[16:18:40.913]                             muffled <- TRUE
[16:18:40.913]                             break
[16:18:40.913]                           }
[16:18:40.913]                         }
[16:18:40.913]                       }
[16:18:40.913]                       invisible(muffled)
[16:18:40.913]                     }
[16:18:40.913]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.913]                   }
[16:18:40.913]                 }
[16:18:40.913]                 else {
[16:18:40.913]                   if (TRUE) {
[16:18:40.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.913]                     {
[16:18:40.913]                       inherits <- base::inherits
[16:18:40.913]                       invokeRestart <- base::invokeRestart
[16:18:40.913]                       is.null <- base::is.null
[16:18:40.913]                       muffled <- FALSE
[16:18:40.913]                       if (inherits(cond, "message")) {
[16:18:40.913]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.913]                         if (muffled) 
[16:18:40.913]                           invokeRestart("muffleMessage")
[16:18:40.913]                       }
[16:18:40.913]                       else if (inherits(cond, "warning")) {
[16:18:40.913]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.913]                         if (muffled) 
[16:18:40.913]                           invokeRestart("muffleWarning")
[16:18:40.913]                       }
[16:18:40.913]                       else if (inherits(cond, "condition")) {
[16:18:40.913]                         if (!is.null(pattern)) {
[16:18:40.913]                           computeRestarts <- base::computeRestarts
[16:18:40.913]                           grepl <- base::grepl
[16:18:40.913]                           restarts <- computeRestarts(cond)
[16:18:40.913]                           for (restart in restarts) {
[16:18:40.913]                             name <- restart$name
[16:18:40.913]                             if (is.null(name)) 
[16:18:40.913]                               next
[16:18:40.913]                             if (!grepl(pattern, name)) 
[16:18:40.913]                               next
[16:18:40.913]                             invokeRestart(restart)
[16:18:40.913]                             muffled <- TRUE
[16:18:40.913]                             break
[16:18:40.913]                           }
[16:18:40.913]                         }
[16:18:40.913]                       }
[16:18:40.913]                       invisible(muffled)
[16:18:40.913]                     }
[16:18:40.913]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.913]                   }
[16:18:40.913]                 }
[16:18:40.913]             }
[16:18:40.913]         }))
[16:18:40.913]     }, error = function(ex) {
[16:18:40.913]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.913]                 ...future.rng), started = ...future.startTime, 
[16:18:40.913]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.913]             version = "1.8"), class = "FutureResult")
[16:18:40.913]     }, finally = {
[16:18:40.913]         if (!identical(...future.workdir, getwd())) 
[16:18:40.913]             setwd(...future.workdir)
[16:18:40.913]         {
[16:18:40.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.913]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.913]             }
[16:18:40.913]             base::options(...future.oldOptions)
[16:18:40.913]             if (.Platform$OS.type == "windows") {
[16:18:40.913]                 old_names <- names(...future.oldEnvVars)
[16:18:40.913]                 envs <- base::Sys.getenv()
[16:18:40.913]                 names <- names(envs)
[16:18:40.913]                 common <- intersect(names, old_names)
[16:18:40.913]                 added <- setdiff(names, old_names)
[16:18:40.913]                 removed <- setdiff(old_names, names)
[16:18:40.913]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.913]                   envs[common]]
[16:18:40.913]                 NAMES <- toupper(changed)
[16:18:40.913]                 args <- list()
[16:18:40.913]                 for (kk in seq_along(NAMES)) {
[16:18:40.913]                   name <- changed[[kk]]
[16:18:40.913]                   NAME <- NAMES[[kk]]
[16:18:40.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.913]                     next
[16:18:40.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.913]                 }
[16:18:40.913]                 NAMES <- toupper(added)
[16:18:40.913]                 for (kk in seq_along(NAMES)) {
[16:18:40.913]                   name <- added[[kk]]
[16:18:40.913]                   NAME <- NAMES[[kk]]
[16:18:40.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.913]                     next
[16:18:40.913]                   args[[name]] <- ""
[16:18:40.913]                 }
[16:18:40.913]                 NAMES <- toupper(removed)
[16:18:40.913]                 for (kk in seq_along(NAMES)) {
[16:18:40.913]                   name <- removed[[kk]]
[16:18:40.913]                   NAME <- NAMES[[kk]]
[16:18:40.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.913]                     next
[16:18:40.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.913]                 }
[16:18:40.913]                 if (length(args) > 0) 
[16:18:40.913]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.913]             }
[16:18:40.913]             else {
[16:18:40.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.913]             }
[16:18:40.913]             {
[16:18:40.913]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.913]                   0L) {
[16:18:40.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.913]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.913]                   base::options(opts)
[16:18:40.913]                 }
[16:18:40.913]                 {
[16:18:40.913]                   {
[16:18:40.913]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:40.913]                     NULL
[16:18:40.913]                   }
[16:18:40.913]                   options(future.plan = NULL)
[16:18:40.913]                   if (is.na(NA_character_)) 
[16:18:40.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.913]                     .init = FALSE)
[16:18:40.913]                 }
[16:18:40.913]             }
[16:18:40.913]         }
[16:18:40.913]     })
[16:18:40.913]     if (TRUE) {
[16:18:40.913]         base::sink(type = "output", split = FALSE)
[16:18:40.913]         if (TRUE) {
[16:18:40.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.913]         }
[16:18:40.913]         else {
[16:18:40.913]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.913]         }
[16:18:40.913]         base::close(...future.stdout)
[16:18:40.913]         ...future.stdout <- NULL
[16:18:40.913]     }
[16:18:40.913]     ...future.result$conditions <- ...future.conditions
[16:18:40.913]     ...future.result$finished <- base::Sys.time()
[16:18:40.913]     ...future.result
[16:18:40.913] }
[16:18:40.915] assign_globals() ...
[16:18:40.915] List of 5
[16:18:40.915]  $ ...future.FUN            :function (x, ...)  
[16:18:40.915]  $ MoreArgs                 : NULL
[16:18:40.915]  $ ...future.elements_ii    :List of 2
[16:18:40.915]   ..$ :List of 2
[16:18:40.915]   .. ..$ : int 1
[16:18:40.915]   .. ..$ : int 2
[16:18:40.915]   ..$ :List of 2
[16:18:40.915]   .. ..$ : int 4
[16:18:40.915]   .. ..$ : int 3
[16:18:40.915]  $ ...future.seeds_ii       : NULL
[16:18:40.915]  $ ...future.globals.maxSize: NULL
[16:18:40.915]  - attr(*, "where")=List of 5
[16:18:40.915]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.915]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.915]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.915]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.915]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.915]  - attr(*, "resolved")= logi FALSE
[16:18:40.915]  - attr(*, "total_size")= num 280
[16:18:40.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.915]  - attr(*, "already-done")= logi TRUE
[16:18:40.923] - copied ‘...future.FUN’ to environment
[16:18:40.923] - copied ‘MoreArgs’ to environment
[16:18:40.923] - copied ‘...future.elements_ii’ to environment
[16:18:40.923] - copied ‘...future.seeds_ii’ to environment
[16:18:40.923] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.923] assign_globals() ... done
[16:18:40.924] requestCore(): workers = 2
[16:18:40.927] MulticoreFuture started
[16:18:40.928] - Launch lazy future ... done
[16:18:40.929] plan(): Setting new future strategy stack:
[16:18:40.929] run() for ‘MulticoreFuture’ ... done
[16:18:40.929] Created future:
[16:18:40.929] List of future strategies:
[16:18:40.929] 1. sequential:
[16:18:40.929]    - args: function (..., envir = parent.frame())
[16:18:40.929]    - tweaked: FALSE
[16:18:40.929]    - call: NULL
[16:18:40.931] plan(): nbrOfWorkers() = 1
[16:18:40.934] plan(): Setting new future strategy stack:
[16:18:40.934] List of future strategies:
[16:18:40.934] 1. multicore:
[16:18:40.934]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:40.934]    - tweaked: FALSE
[16:18:40.934]    - call: plan(strategy)
[16:18:40.941] plan(): nbrOfWorkers() = 2
[16:18:40.930] MulticoreFuture:
[16:18:40.930] Label: ‘future_mapply-1’
[16:18:40.930] Expression:
[16:18:40.930] {
[16:18:40.930]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.930]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.930]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.930]         on.exit(options(oopts), add = TRUE)
[16:18:40.930]     }
[16:18:40.930]     {
[16:18:40.930]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.930]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.930]         do.call(mapply, args = args)
[16:18:40.930]     }
[16:18:40.930] }
[16:18:40.930] Lazy evaluation: FALSE
[16:18:40.930] Asynchronous evaluation: TRUE
[16:18:40.930] Local evaluation: TRUE
[16:18:40.930] Environment: R_GlobalEnv
[16:18:40.930] Capture standard output: TRUE
[16:18:40.930] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.930] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.930] Packages: <none>
[16:18:40.930] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.930] Resolved: TRUE
[16:18:40.930] Value: <not collected>
[16:18:40.930] Conditions captured: <none>
[16:18:40.930] Early signaling: FALSE
[16:18:40.930] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.930] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:40.942] Chunk #1 of 2 ... DONE
[16:18:40.943] Chunk #2 of 2 ...
[16:18:40.943]  - Finding globals in '...' for chunk #2 ...
[16:18:40.943] getGlobalsAndPackages() ...
[16:18:40.943] Searching for globals...
[16:18:40.944] 
[16:18:40.944] Searching for globals ... DONE
[16:18:40.944] - globals: [0] <none>
[16:18:40.945] getGlobalsAndPackages() ... DONE
[16:18:40.945]    + additional globals found: [n=0] 
[16:18:40.945]    + additional namespaces needed: [n=0] 
[16:18:40.945]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:40.945]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:40.946]  - seeds: <none>
[16:18:40.946]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.946] getGlobalsAndPackages() ...
[16:18:40.946] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.946] Resolving globals: FALSE
[16:18:40.947] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:40.948] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:40.948] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:40.949] 
[16:18:40.949] getGlobalsAndPackages() ... DONE
[16:18:40.949] run() for ‘Future’ ...
[16:18:40.950] - state: ‘created’
[16:18:40.950] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:40.955] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:40.955] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:40.955]   - Field: ‘label’
[16:18:40.955]   - Field: ‘local’
[16:18:40.955]   - Field: ‘owner’
[16:18:40.955]   - Field: ‘envir’
[16:18:40.955]   - Field: ‘workers’
[16:18:40.956]   - Field: ‘packages’
[16:18:40.956]   - Field: ‘gc’
[16:18:40.956]   - Field: ‘job’
[16:18:40.956]   - Field: ‘conditions’
[16:18:40.956]   - Field: ‘expr’
[16:18:40.956]   - Field: ‘uuid’
[16:18:40.956]   - Field: ‘seed’
[16:18:40.956]   - Field: ‘version’
[16:18:40.957]   - Field: ‘result’
[16:18:40.957]   - Field: ‘asynchronous’
[16:18:40.957]   - Field: ‘calls’
[16:18:40.957]   - Field: ‘globals’
[16:18:40.957]   - Field: ‘stdout’
[16:18:40.957]   - Field: ‘earlySignal’
[16:18:40.957]   - Field: ‘lazy’
[16:18:40.957]   - Field: ‘state’
[16:18:40.958] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:40.958] - Launch lazy future ...
[16:18:40.958] Packages needed by the future expression (n = 0): <none>
[16:18:40.958] Packages needed by future strategies (n = 0): <none>
[16:18:40.959] {
[16:18:40.959]     {
[16:18:40.959]         {
[16:18:40.959]             ...future.startTime <- base::Sys.time()
[16:18:40.959]             {
[16:18:40.959]                 {
[16:18:40.959]                   {
[16:18:40.959]                     {
[16:18:40.959]                       base::local({
[16:18:40.959]                         has_future <- base::requireNamespace("future", 
[16:18:40.959]                           quietly = TRUE)
[16:18:40.959]                         if (has_future) {
[16:18:40.959]                           ns <- base::getNamespace("future")
[16:18:40.959]                           version <- ns[[".package"]][["version"]]
[16:18:40.959]                           if (is.null(version)) 
[16:18:40.959]                             version <- utils::packageVersion("future")
[16:18:40.959]                         }
[16:18:40.959]                         else {
[16:18:40.959]                           version <- NULL
[16:18:40.959]                         }
[16:18:40.959]                         if (!has_future || version < "1.8.0") {
[16:18:40.959]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:40.959]                             "", base::R.version$version.string), 
[16:18:40.959]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:40.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:40.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:40.959]                               "release", "version")], collapse = " "), 
[16:18:40.959]                             hostname = base::Sys.info()[["nodename"]])
[16:18:40.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:40.959]                             info)
[16:18:40.959]                           info <- base::paste(info, collapse = "; ")
[16:18:40.959]                           if (!has_future) {
[16:18:40.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:40.959]                               info)
[16:18:40.959]                           }
[16:18:40.959]                           else {
[16:18:40.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:40.959]                               info, version)
[16:18:40.959]                           }
[16:18:40.959]                           base::stop(msg)
[16:18:40.959]                         }
[16:18:40.959]                       })
[16:18:40.959]                     }
[16:18:40.959]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:40.959]                     base::options(mc.cores = 1L)
[16:18:40.959]                   }
[16:18:40.959]                   ...future.strategy.old <- future::plan("list")
[16:18:40.959]                   options(future.plan = NULL)
[16:18:40.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:40.959]                 }
[16:18:40.959]                 ...future.workdir <- getwd()
[16:18:40.959]             }
[16:18:40.959]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:40.959]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:40.959]         }
[16:18:40.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:40.959]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:40.959]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:40.959]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:40.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:40.959]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:40.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:40.959]             base::names(...future.oldOptions))
[16:18:40.959]     }
[16:18:40.959]     if (FALSE) {
[16:18:40.959]     }
[16:18:40.959]     else {
[16:18:40.959]         if (TRUE) {
[16:18:40.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:40.959]                 open = "w")
[16:18:40.959]         }
[16:18:40.959]         else {
[16:18:40.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:40.959]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:40.959]         }
[16:18:40.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:40.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:40.959]             base::sink(type = "output", split = FALSE)
[16:18:40.959]             base::close(...future.stdout)
[16:18:40.959]         }, add = TRUE)
[16:18:40.959]     }
[16:18:40.959]     ...future.frame <- base::sys.nframe()
[16:18:40.959]     ...future.conditions <- base::list()
[16:18:40.959]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:40.959]     if (FALSE) {
[16:18:40.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:40.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:40.959]     }
[16:18:40.959]     ...future.result <- base::tryCatch({
[16:18:40.959]         base::withCallingHandlers({
[16:18:40.959]             ...future.value <- base::withVisible(base::local({
[16:18:40.959]                 withCallingHandlers({
[16:18:40.959]                   {
[16:18:40.959]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.959]                     if (!identical(...future.globals.maxSize.org, 
[16:18:40.959]                       ...future.globals.maxSize)) {
[16:18:40.959]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.959]                       on.exit(options(oopts), add = TRUE)
[16:18:40.959]                     }
[16:18:40.959]                     {
[16:18:40.959]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.959]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:40.959]                         USE.NAMES = FALSE)
[16:18:40.959]                       do.call(mapply, args = args)
[16:18:40.959]                     }
[16:18:40.959]                   }
[16:18:40.959]                 }, immediateCondition = function(cond) {
[16:18:40.959]                   save_rds <- function (object, pathname, ...) 
[16:18:40.959]                   {
[16:18:40.959]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:40.959]                     if (file_test("-f", pathname_tmp)) {
[16:18:40.959]                       fi_tmp <- file.info(pathname_tmp)
[16:18:40.959]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:40.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:40.959]                         fi_tmp[["mtime"]])
[16:18:40.959]                     }
[16:18:40.959]                     tryCatch({
[16:18:40.959]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:40.959]                     }, error = function(ex) {
[16:18:40.959]                       msg <- conditionMessage(ex)
[16:18:40.959]                       fi_tmp <- file.info(pathname_tmp)
[16:18:40.959]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:40.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:40.959]                         fi_tmp[["mtime"]], msg)
[16:18:40.959]                       ex$message <- msg
[16:18:40.959]                       stop(ex)
[16:18:40.959]                     })
[16:18:40.959]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:40.959]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:40.959]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:40.959]                       fi_tmp <- file.info(pathname_tmp)
[16:18:40.959]                       fi <- file.info(pathname)
[16:18:40.959]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:40.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:40.959]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:40.959]                         fi[["size"]], fi[["mtime"]])
[16:18:40.959]                       stop(msg)
[16:18:40.959]                     }
[16:18:40.959]                     invisible(pathname)
[16:18:40.959]                   }
[16:18:40.959]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:40.959]                     rootPath = tempdir()) 
[16:18:40.959]                   {
[16:18:40.959]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:40.959]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:40.959]                       tmpdir = path, fileext = ".rds")
[16:18:40.959]                     save_rds(obj, file)
[16:18:40.959]                   }
[16:18:40.959]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:40.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.959]                   {
[16:18:40.959]                     inherits <- base::inherits
[16:18:40.959]                     invokeRestart <- base::invokeRestart
[16:18:40.959]                     is.null <- base::is.null
[16:18:40.959]                     muffled <- FALSE
[16:18:40.959]                     if (inherits(cond, "message")) {
[16:18:40.959]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:40.959]                       if (muffled) 
[16:18:40.959]                         invokeRestart("muffleMessage")
[16:18:40.959]                     }
[16:18:40.959]                     else if (inherits(cond, "warning")) {
[16:18:40.959]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:40.959]                       if (muffled) 
[16:18:40.959]                         invokeRestart("muffleWarning")
[16:18:40.959]                     }
[16:18:40.959]                     else if (inherits(cond, "condition")) {
[16:18:40.959]                       if (!is.null(pattern)) {
[16:18:40.959]                         computeRestarts <- base::computeRestarts
[16:18:40.959]                         grepl <- base::grepl
[16:18:40.959]                         restarts <- computeRestarts(cond)
[16:18:40.959]                         for (restart in restarts) {
[16:18:40.959]                           name <- restart$name
[16:18:40.959]                           if (is.null(name)) 
[16:18:40.959]                             next
[16:18:40.959]                           if (!grepl(pattern, name)) 
[16:18:40.959]                             next
[16:18:40.959]                           invokeRestart(restart)
[16:18:40.959]                           muffled <- TRUE
[16:18:40.959]                           break
[16:18:40.959]                         }
[16:18:40.959]                       }
[16:18:40.959]                     }
[16:18:40.959]                     invisible(muffled)
[16:18:40.959]                   }
[16:18:40.959]                   muffleCondition(cond)
[16:18:40.959]                 })
[16:18:40.959]             }))
[16:18:40.959]             future::FutureResult(value = ...future.value$value, 
[16:18:40.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.959]                   ...future.rng), globalenv = if (FALSE) 
[16:18:40.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:40.959]                     ...future.globalenv.names))
[16:18:40.959]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:40.959]         }, condition = base::local({
[16:18:40.959]             c <- base::c
[16:18:40.959]             inherits <- base::inherits
[16:18:40.959]             invokeRestart <- base::invokeRestart
[16:18:40.959]             length <- base::length
[16:18:40.959]             list <- base::list
[16:18:40.959]             seq.int <- base::seq.int
[16:18:40.959]             signalCondition <- base::signalCondition
[16:18:40.959]             sys.calls <- base::sys.calls
[16:18:40.959]             `[[` <- base::`[[`
[16:18:40.959]             `+` <- base::`+`
[16:18:40.959]             `<<-` <- base::`<<-`
[16:18:40.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:40.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:40.959]                   3L)]
[16:18:40.959]             }
[16:18:40.959]             function(cond) {
[16:18:40.959]                 is_error <- inherits(cond, "error")
[16:18:40.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:40.959]                   NULL)
[16:18:40.959]                 if (is_error) {
[16:18:40.959]                   sessionInformation <- function() {
[16:18:40.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:40.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:40.959]                       search = base::search(), system = base::Sys.info())
[16:18:40.959]                   }
[16:18:40.959]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:40.959]                     cond$call), session = sessionInformation(), 
[16:18:40.959]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:40.959]                   signalCondition(cond)
[16:18:40.959]                 }
[16:18:40.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:40.959]                 "immediateCondition"))) {
[16:18:40.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:40.959]                   ...future.conditions[[length(...future.conditions) + 
[16:18:40.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:40.959]                   if (TRUE && !signal) {
[16:18:40.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.959]                     {
[16:18:40.959]                       inherits <- base::inherits
[16:18:40.959]                       invokeRestart <- base::invokeRestart
[16:18:40.959]                       is.null <- base::is.null
[16:18:40.959]                       muffled <- FALSE
[16:18:40.959]                       if (inherits(cond, "message")) {
[16:18:40.959]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.959]                         if (muffled) 
[16:18:40.959]                           invokeRestart("muffleMessage")
[16:18:40.959]                       }
[16:18:40.959]                       else if (inherits(cond, "warning")) {
[16:18:40.959]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.959]                         if (muffled) 
[16:18:40.959]                           invokeRestart("muffleWarning")
[16:18:40.959]                       }
[16:18:40.959]                       else if (inherits(cond, "condition")) {
[16:18:40.959]                         if (!is.null(pattern)) {
[16:18:40.959]                           computeRestarts <- base::computeRestarts
[16:18:40.959]                           grepl <- base::grepl
[16:18:40.959]                           restarts <- computeRestarts(cond)
[16:18:40.959]                           for (restart in restarts) {
[16:18:40.959]                             name <- restart$name
[16:18:40.959]                             if (is.null(name)) 
[16:18:40.959]                               next
[16:18:40.959]                             if (!grepl(pattern, name)) 
[16:18:40.959]                               next
[16:18:40.959]                             invokeRestart(restart)
[16:18:40.959]                             muffled <- TRUE
[16:18:40.959]                             break
[16:18:40.959]                           }
[16:18:40.959]                         }
[16:18:40.959]                       }
[16:18:40.959]                       invisible(muffled)
[16:18:40.959]                     }
[16:18:40.959]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.959]                   }
[16:18:40.959]                 }
[16:18:40.959]                 else {
[16:18:40.959]                   if (TRUE) {
[16:18:40.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:40.959]                     {
[16:18:40.959]                       inherits <- base::inherits
[16:18:40.959]                       invokeRestart <- base::invokeRestart
[16:18:40.959]                       is.null <- base::is.null
[16:18:40.959]                       muffled <- FALSE
[16:18:40.959]                       if (inherits(cond, "message")) {
[16:18:40.959]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:40.959]                         if (muffled) 
[16:18:40.959]                           invokeRestart("muffleMessage")
[16:18:40.959]                       }
[16:18:40.959]                       else if (inherits(cond, "warning")) {
[16:18:40.959]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:40.959]                         if (muffled) 
[16:18:40.959]                           invokeRestart("muffleWarning")
[16:18:40.959]                       }
[16:18:40.959]                       else if (inherits(cond, "condition")) {
[16:18:40.959]                         if (!is.null(pattern)) {
[16:18:40.959]                           computeRestarts <- base::computeRestarts
[16:18:40.959]                           grepl <- base::grepl
[16:18:40.959]                           restarts <- computeRestarts(cond)
[16:18:40.959]                           for (restart in restarts) {
[16:18:40.959]                             name <- restart$name
[16:18:40.959]                             if (is.null(name)) 
[16:18:40.959]                               next
[16:18:40.959]                             if (!grepl(pattern, name)) 
[16:18:40.959]                               next
[16:18:40.959]                             invokeRestart(restart)
[16:18:40.959]                             muffled <- TRUE
[16:18:40.959]                             break
[16:18:40.959]                           }
[16:18:40.959]                         }
[16:18:40.959]                       }
[16:18:40.959]                       invisible(muffled)
[16:18:40.959]                     }
[16:18:40.959]                     muffleCondition(cond, pattern = "^muffle")
[16:18:40.959]                   }
[16:18:40.959]                 }
[16:18:40.959]             }
[16:18:40.959]         }))
[16:18:40.959]     }, error = function(ex) {
[16:18:40.959]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:40.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:40.959]                 ...future.rng), started = ...future.startTime, 
[16:18:40.959]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:40.959]             version = "1.8"), class = "FutureResult")
[16:18:40.959]     }, finally = {
[16:18:40.959]         if (!identical(...future.workdir, getwd())) 
[16:18:40.959]             setwd(...future.workdir)
[16:18:40.959]         {
[16:18:40.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:40.959]                 ...future.oldOptions$nwarnings <- NULL
[16:18:40.959]             }
[16:18:40.959]             base::options(...future.oldOptions)
[16:18:40.959]             if (.Platform$OS.type == "windows") {
[16:18:40.959]                 old_names <- names(...future.oldEnvVars)
[16:18:40.959]                 envs <- base::Sys.getenv()
[16:18:40.959]                 names <- names(envs)
[16:18:40.959]                 common <- intersect(names, old_names)
[16:18:40.959]                 added <- setdiff(names, old_names)
[16:18:40.959]                 removed <- setdiff(old_names, names)
[16:18:40.959]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:40.959]                   envs[common]]
[16:18:40.959]                 NAMES <- toupper(changed)
[16:18:40.959]                 args <- list()
[16:18:40.959]                 for (kk in seq_along(NAMES)) {
[16:18:40.959]                   name <- changed[[kk]]
[16:18:40.959]                   NAME <- NAMES[[kk]]
[16:18:40.959]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.959]                     next
[16:18:40.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.959]                 }
[16:18:40.959]                 NAMES <- toupper(added)
[16:18:40.959]                 for (kk in seq_along(NAMES)) {
[16:18:40.959]                   name <- added[[kk]]
[16:18:40.959]                   NAME <- NAMES[[kk]]
[16:18:40.959]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.959]                     next
[16:18:40.959]                   args[[name]] <- ""
[16:18:40.959]                 }
[16:18:40.959]                 NAMES <- toupper(removed)
[16:18:40.959]                 for (kk in seq_along(NAMES)) {
[16:18:40.959]                   name <- removed[[kk]]
[16:18:40.959]                   NAME <- NAMES[[kk]]
[16:18:40.959]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:40.959]                     next
[16:18:40.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:40.959]                 }
[16:18:40.959]                 if (length(args) > 0) 
[16:18:40.959]                   base::do.call(base::Sys.setenv, args = args)
[16:18:40.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:40.959]             }
[16:18:40.959]             else {
[16:18:40.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:40.959]             }
[16:18:40.959]             {
[16:18:40.959]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:40.959]                   0L) {
[16:18:40.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:40.959]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:40.959]                   base::options(opts)
[16:18:40.959]                 }
[16:18:40.959]                 {
[16:18:40.959]                   {
[16:18:40.959]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:40.959]                     NULL
[16:18:40.959]                   }
[16:18:40.959]                   options(future.plan = NULL)
[16:18:40.959]                   if (is.na(NA_character_)) 
[16:18:40.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:40.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:40.959]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:40.959]                     .init = FALSE)
[16:18:40.959]                 }
[16:18:40.959]             }
[16:18:40.959]         }
[16:18:40.959]     })
[16:18:40.959]     if (TRUE) {
[16:18:40.959]         base::sink(type = "output", split = FALSE)
[16:18:40.959]         if (TRUE) {
[16:18:40.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:40.959]         }
[16:18:40.959]         else {
[16:18:40.959]             ...future.result["stdout"] <- base::list(NULL)
[16:18:40.959]         }
[16:18:40.959]         base::close(...future.stdout)
[16:18:40.959]         ...future.stdout <- NULL
[16:18:40.959]     }
[16:18:40.959]     ...future.result$conditions <- ...future.conditions
[16:18:40.959]     ...future.result$finished <- base::Sys.time()
[16:18:40.959]     ...future.result
[16:18:40.959] }
[16:18:40.962] assign_globals() ...
[16:18:40.962] List of 5
[16:18:40.962]  $ ...future.FUN            :function (x, ...)  
[16:18:40.962]  $ MoreArgs                 : NULL
[16:18:40.962]  $ ...future.elements_ii    :List of 2
[16:18:40.962]   ..$ :List of 2
[16:18:40.962]   .. ..$ : int 3
[16:18:40.962]   .. ..$ : int 4
[16:18:40.962]   ..$ :List of 2
[16:18:40.962]   .. ..$ : int 2
[16:18:40.962]   .. ..$ : int 1
[16:18:40.962]  $ ...future.seeds_ii       : NULL
[16:18:40.962]  $ ...future.globals.maxSize: NULL
[16:18:40.962]  - attr(*, "where")=List of 5
[16:18:40.962]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:40.962]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:40.962]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:40.962]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:40.962]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:40.962]  - attr(*, "resolved")= logi FALSE
[16:18:40.962]  - attr(*, "total_size")= num 280
[16:18:40.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:40.962]  - attr(*, "already-done")= logi TRUE
[16:18:40.970] - copied ‘...future.FUN’ to environment
[16:18:40.970] - copied ‘MoreArgs’ to environment
[16:18:40.970] - copied ‘...future.elements_ii’ to environment
[16:18:40.970] - copied ‘...future.seeds_ii’ to environment
[16:18:40.971] - copied ‘...future.globals.maxSize’ to environment
[16:18:40.971] assign_globals() ... done
[16:18:40.971] requestCore(): workers = 2
[16:18:40.979] MulticoreFuture started
[16:18:40.980] - Launch lazy future ... done
[16:18:40.981] plan(): Setting new future strategy stack:
[16:18:40.981] run() for ‘MulticoreFuture’ ... done
[16:18:40.981] Created future:
[16:18:40.981] List of future strategies:
[16:18:40.981] 1. sequential:
[16:18:40.981]    - args: function (..., envir = parent.frame())
[16:18:40.981]    - tweaked: FALSE
[16:18:40.981]    - call: NULL
[16:18:40.982] plan(): nbrOfWorkers() = 1
[16:18:40.985] plan(): Setting new future strategy stack:
[16:18:40.985] List of future strategies:
[16:18:40.985] 1. multicore:
[16:18:40.985]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:40.985]    - tweaked: FALSE
[16:18:40.985]    - call: plan(strategy)
[16:18:40.993] plan(): nbrOfWorkers() = 2
[16:18:40.982] MulticoreFuture:
[16:18:40.982] Label: ‘future_mapply-2’
[16:18:40.982] Expression:
[16:18:40.982] {
[16:18:40.982]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:40.982]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:40.982]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:40.982]         on.exit(options(oopts), add = TRUE)
[16:18:40.982]     }
[16:18:40.982]     {
[16:18:40.982]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:40.982]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:40.982]         do.call(mapply, args = args)
[16:18:40.982]     }
[16:18:40.982] }
[16:18:40.982] Lazy evaluation: FALSE
[16:18:40.982] Asynchronous evaluation: TRUE
[16:18:40.982] Local evaluation: TRUE
[16:18:40.982] Environment: R_GlobalEnv
[16:18:40.982] Capture standard output: TRUE
[16:18:40.982] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:40.982] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:40.982] Packages: <none>
[16:18:40.982] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:40.982] Resolved: TRUE
[16:18:40.982] Value: <not collected>
[16:18:40.982] Conditions captured: <none>
[16:18:40.982] Early signaling: FALSE
[16:18:40.982] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:40.982] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:40.994] Chunk #2 of 2 ... DONE
[16:18:40.994] Launching 2 futures (chunks) ... DONE
[16:18:40.994] Resolving 2 futures (chunks) ...
[16:18:40.994] resolve() on list ...
[16:18:40.995]  recursive: 0
[16:18:40.995]  length: 2
[16:18:40.995] 
[16:18:40.995] Future #1
[16:18:40.996] result() for MulticoreFuture ...
[16:18:40.998] result() for MulticoreFuture ...
[16:18:40.998] result() for MulticoreFuture ... done
[16:18:40.999] result() for MulticoreFuture ... done
[16:18:40.999] result() for MulticoreFuture ...
[16:18:40.999] result() for MulticoreFuture ... done
[16:18:40.999] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:40.999] - nx: 2
[16:18:40.999] - relay: TRUE
[16:18:41.000] - stdout: TRUE
[16:18:41.000] - signal: TRUE
[16:18:41.000] - resignal: FALSE
[16:18:41.000] - force: TRUE
[16:18:41.000] - relayed: [n=2] FALSE, FALSE
[16:18:41.000] - queued futures: [n=2] FALSE, FALSE
[16:18:41.000]  - until=1
[16:18:41.001]  - relaying element #1
[16:18:41.001] result() for MulticoreFuture ...
[16:18:41.001] result() for MulticoreFuture ... done
[16:18:41.001] result() for MulticoreFuture ...
[16:18:41.002] result() for MulticoreFuture ... done
[16:18:41.002] result() for MulticoreFuture ...
[16:18:41.002] result() for MulticoreFuture ... done
[16:18:41.002] result() for MulticoreFuture ...
[16:18:41.002] result() for MulticoreFuture ... done
[16:18:41.002] - relayed: [n=2] TRUE, FALSE
[16:18:41.003] - queued futures: [n=2] TRUE, FALSE
[16:18:41.003] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:41.003]  length: 1 (resolved future 1)
[16:18:41.003] Future #2
[16:18:41.003] result() for MulticoreFuture ...
[16:18:41.004] result() for MulticoreFuture ...
[16:18:41.004] result() for MulticoreFuture ... done
[16:18:41.005] result() for MulticoreFuture ... done
[16:18:41.005] result() for MulticoreFuture ...
[16:18:41.005] result() for MulticoreFuture ... done
[16:18:41.005] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:41.005] - nx: 2
[16:18:41.005] - relay: TRUE
[16:18:41.005] - stdout: TRUE
[16:18:41.005] - signal: TRUE
[16:18:41.006] - resignal: FALSE
[16:18:41.006] - force: TRUE
[16:18:41.006] - relayed: [n=2] TRUE, FALSE
[16:18:41.006] - queued futures: [n=2] TRUE, FALSE
[16:18:41.006]  - until=2
[16:18:41.006]  - relaying element #2
[16:18:41.006] result() for MulticoreFuture ...
[16:18:41.006] result() for MulticoreFuture ... done
[16:18:41.006] result() for MulticoreFuture ...
[16:18:41.007] result() for MulticoreFuture ... done
[16:18:41.007] result() for MulticoreFuture ...
[16:18:41.007] result() for MulticoreFuture ... done
[16:18:41.007] result() for MulticoreFuture ...
[16:18:41.007] result() for MulticoreFuture ... done
[16:18:41.007] - relayed: [n=2] TRUE, TRUE
[16:18:41.007] - queued futures: [n=2] TRUE, TRUE
[16:18:41.007] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:41.007]  length: 0 (resolved future 2)
[16:18:41.008] Relaying remaining futures
[16:18:41.008] signalConditionsASAP(NULL, pos=0) ...
[16:18:41.008] - nx: 2
[16:18:41.008] - relay: TRUE
[16:18:41.008] - stdout: TRUE
[16:18:41.008] - signal: TRUE
[16:18:41.008] - resignal: FALSE
[16:18:41.008] - force: TRUE
[16:18:41.008] - relayed: [n=2] TRUE, TRUE
[16:18:41.008] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:41.009] - relayed: [n=2] TRUE, TRUE
[16:18:41.009] - queued futures: [n=2] TRUE, TRUE
[16:18:41.009] signalConditionsASAP(NULL, pos=0) ... done
[16:18:41.009] resolve() on list ... DONE
[16:18:41.009] result() for MulticoreFuture ...
[16:18:41.009] result() for MulticoreFuture ... done
[16:18:41.009] result() for MulticoreFuture ...
[16:18:41.009] result() for MulticoreFuture ... done
[16:18:41.010] result() for MulticoreFuture ...
[16:18:41.010] result() for MulticoreFuture ... done
[16:18:41.010] result() for MulticoreFuture ...
[16:18:41.010] result() for MulticoreFuture ... done
[16:18:41.010]  - Number of value chunks collected: 2
[16:18:41.010] Resolving 2 futures (chunks) ... DONE
[16:18:41.010] Reducing values from 2 chunks ...
[16:18:41.010]  - Number of values collected after concatenation: 4
[16:18:41.010]  - Number of values expected: 4
[16:18:41.010] Reducing values from 2 chunks ... DONE
[16:18:41.011] future_mapply() ... DONE
[16:18:41.011] future_mapply() ...
[16:18:41.015] Number of chunks: 2
[16:18:41.015] getGlobalsAndPackagesXApply() ...
[16:18:41.015]  - future.globals: TRUE
[16:18:41.015] getGlobalsAndPackages() ...
[16:18:41.015] Searching for globals...
[16:18:41.016] - globals found: [1] ‘FUN’
[16:18:41.016] Searching for globals ... DONE
[16:18:41.016] Resolving globals: FALSE
[16:18:41.017] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:41.017] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:41.017] - globals: [1] ‘FUN’
[16:18:41.017] 
[16:18:41.017] getGlobalsAndPackages() ... DONE
[16:18:41.018]  - globals found/used: [n=1] ‘FUN’
[16:18:41.018]  - needed namespaces: [n=0] 
[16:18:41.018] Finding globals ... DONE
[16:18:41.018] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:41.018] List of 2
[16:18:41.018]  $ ...future.FUN:function (x, ...)  
[16:18:41.018]  $ MoreArgs     : NULL
[16:18:41.018]  - attr(*, "where")=List of 2
[16:18:41.018]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:41.018]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:41.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.018]  - attr(*, "resolved")= logi FALSE
[16:18:41.018]  - attr(*, "total_size")= num NA
[16:18:41.021] Packages to be attached in all futures: [n=0] 
[16:18:41.021] getGlobalsAndPackagesXApply() ... DONE
[16:18:41.021] Number of futures (= number of chunks): 2
[16:18:41.022] Launching 2 futures (chunks) ...
[16:18:41.022] Chunk #1 of 2 ...
[16:18:41.022]  - Finding globals in '...' for chunk #1 ...
[16:18:41.022] getGlobalsAndPackages() ...
[16:18:41.022] Searching for globals...
[16:18:41.025] 
[16:18:41.025] Searching for globals ... DONE
[16:18:41.025] - globals: [0] <none>
[16:18:41.025] getGlobalsAndPackages() ... DONE
[16:18:41.025]    + additional globals found: [n=0] 
[16:18:41.025]    + additional namespaces needed: [n=0] 
[16:18:41.025]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:41.026]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.026]  - seeds: <none>
[16:18:41.026]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.026] getGlobalsAndPackages() ...
[16:18:41.026] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.026] Resolving globals: FALSE
[16:18:41.027] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:41.027] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:41.027] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.028] 
[16:18:41.028] getGlobalsAndPackages() ... DONE
[16:18:41.028] run() for ‘Future’ ...
[16:18:41.028] - state: ‘created’
[16:18:41.028] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.032] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.032] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.032]   - Field: ‘label’
[16:18:41.032]   - Field: ‘local’
[16:18:41.033]   - Field: ‘owner’
[16:18:41.033]   - Field: ‘envir’
[16:18:41.033]   - Field: ‘workers’
[16:18:41.033]   - Field: ‘packages’
[16:18:41.033]   - Field: ‘gc’
[16:18:41.033]   - Field: ‘job’
[16:18:41.033]   - Field: ‘conditions’
[16:18:41.033]   - Field: ‘expr’
[16:18:41.033]   - Field: ‘uuid’
[16:18:41.033]   - Field: ‘seed’
[16:18:41.034]   - Field: ‘version’
[16:18:41.034]   - Field: ‘result’
[16:18:41.034]   - Field: ‘asynchronous’
[16:18:41.034]   - Field: ‘calls’
[16:18:41.034]   - Field: ‘globals’
[16:18:41.034]   - Field: ‘stdout’
[16:18:41.034]   - Field: ‘earlySignal’
[16:18:41.034]   - Field: ‘lazy’
[16:18:41.034]   - Field: ‘state’
[16:18:41.034] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.034] - Launch lazy future ...
[16:18:41.035] Packages needed by the future expression (n = 0): <none>
[16:18:41.035] Packages needed by future strategies (n = 0): <none>
[16:18:41.035] {
[16:18:41.035]     {
[16:18:41.035]         {
[16:18:41.035]             ...future.startTime <- base::Sys.time()
[16:18:41.035]             {
[16:18:41.035]                 {
[16:18:41.035]                   {
[16:18:41.035]                     {
[16:18:41.035]                       base::local({
[16:18:41.035]                         has_future <- base::requireNamespace("future", 
[16:18:41.035]                           quietly = TRUE)
[16:18:41.035]                         if (has_future) {
[16:18:41.035]                           ns <- base::getNamespace("future")
[16:18:41.035]                           version <- ns[[".package"]][["version"]]
[16:18:41.035]                           if (is.null(version)) 
[16:18:41.035]                             version <- utils::packageVersion("future")
[16:18:41.035]                         }
[16:18:41.035]                         else {
[16:18:41.035]                           version <- NULL
[16:18:41.035]                         }
[16:18:41.035]                         if (!has_future || version < "1.8.0") {
[16:18:41.035]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.035]                             "", base::R.version$version.string), 
[16:18:41.035]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.035]                               "release", "version")], collapse = " "), 
[16:18:41.035]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.035]                             info)
[16:18:41.035]                           info <- base::paste(info, collapse = "; ")
[16:18:41.035]                           if (!has_future) {
[16:18:41.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.035]                               info)
[16:18:41.035]                           }
[16:18:41.035]                           else {
[16:18:41.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.035]                               info, version)
[16:18:41.035]                           }
[16:18:41.035]                           base::stop(msg)
[16:18:41.035]                         }
[16:18:41.035]                       })
[16:18:41.035]                     }
[16:18:41.035]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.035]                     base::options(mc.cores = 1L)
[16:18:41.035]                   }
[16:18:41.035]                   ...future.strategy.old <- future::plan("list")
[16:18:41.035]                   options(future.plan = NULL)
[16:18:41.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.035]                 }
[16:18:41.035]                 ...future.workdir <- getwd()
[16:18:41.035]             }
[16:18:41.035]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.035]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.035]         }
[16:18:41.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.035]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.035]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.035]             base::names(...future.oldOptions))
[16:18:41.035]     }
[16:18:41.035]     if (FALSE) {
[16:18:41.035]     }
[16:18:41.035]     else {
[16:18:41.035]         if (TRUE) {
[16:18:41.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.035]                 open = "w")
[16:18:41.035]         }
[16:18:41.035]         else {
[16:18:41.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.035]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.035]         }
[16:18:41.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.035]             base::sink(type = "output", split = FALSE)
[16:18:41.035]             base::close(...future.stdout)
[16:18:41.035]         }, add = TRUE)
[16:18:41.035]     }
[16:18:41.035]     ...future.frame <- base::sys.nframe()
[16:18:41.035]     ...future.conditions <- base::list()
[16:18:41.035]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.035]     if (FALSE) {
[16:18:41.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.035]     }
[16:18:41.035]     ...future.result <- base::tryCatch({
[16:18:41.035]         base::withCallingHandlers({
[16:18:41.035]             ...future.value <- base::withVisible(base::local({
[16:18:41.035]                 withCallingHandlers({
[16:18:41.035]                   {
[16:18:41.035]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.035]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.035]                       ...future.globals.maxSize)) {
[16:18:41.035]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.035]                       on.exit(options(oopts), add = TRUE)
[16:18:41.035]                     }
[16:18:41.035]                     {
[16:18:41.035]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.035]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.035]                         USE.NAMES = FALSE)
[16:18:41.035]                       do.call(mapply, args = args)
[16:18:41.035]                     }
[16:18:41.035]                   }
[16:18:41.035]                 }, immediateCondition = function(cond) {
[16:18:41.035]                   save_rds <- function (object, pathname, ...) 
[16:18:41.035]                   {
[16:18:41.035]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.035]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.035]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.035]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.035]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.035]                         fi_tmp[["mtime"]])
[16:18:41.035]                     }
[16:18:41.035]                     tryCatch({
[16:18:41.035]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.035]                     }, error = function(ex) {
[16:18:41.035]                       msg <- conditionMessage(ex)
[16:18:41.035]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.035]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.035]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.035]                         fi_tmp[["mtime"]], msg)
[16:18:41.035]                       ex$message <- msg
[16:18:41.035]                       stop(ex)
[16:18:41.035]                     })
[16:18:41.035]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.035]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.035]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.035]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.035]                       fi <- file.info(pathname)
[16:18:41.035]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.035]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.035]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.035]                         fi[["size"]], fi[["mtime"]])
[16:18:41.035]                       stop(msg)
[16:18:41.035]                     }
[16:18:41.035]                     invisible(pathname)
[16:18:41.035]                   }
[16:18:41.035]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.035]                     rootPath = tempdir()) 
[16:18:41.035]                   {
[16:18:41.035]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.035]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.035]                       tmpdir = path, fileext = ".rds")
[16:18:41.035]                     save_rds(obj, file)
[16:18:41.035]                   }
[16:18:41.035]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.035]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.035]                   {
[16:18:41.035]                     inherits <- base::inherits
[16:18:41.035]                     invokeRestart <- base::invokeRestart
[16:18:41.035]                     is.null <- base::is.null
[16:18:41.035]                     muffled <- FALSE
[16:18:41.035]                     if (inherits(cond, "message")) {
[16:18:41.035]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.035]                       if (muffled) 
[16:18:41.035]                         invokeRestart("muffleMessage")
[16:18:41.035]                     }
[16:18:41.035]                     else if (inherits(cond, "warning")) {
[16:18:41.035]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.035]                       if (muffled) 
[16:18:41.035]                         invokeRestart("muffleWarning")
[16:18:41.035]                     }
[16:18:41.035]                     else if (inherits(cond, "condition")) {
[16:18:41.035]                       if (!is.null(pattern)) {
[16:18:41.035]                         computeRestarts <- base::computeRestarts
[16:18:41.035]                         grepl <- base::grepl
[16:18:41.035]                         restarts <- computeRestarts(cond)
[16:18:41.035]                         for (restart in restarts) {
[16:18:41.035]                           name <- restart$name
[16:18:41.035]                           if (is.null(name)) 
[16:18:41.035]                             next
[16:18:41.035]                           if (!grepl(pattern, name)) 
[16:18:41.035]                             next
[16:18:41.035]                           invokeRestart(restart)
[16:18:41.035]                           muffled <- TRUE
[16:18:41.035]                           break
[16:18:41.035]                         }
[16:18:41.035]                       }
[16:18:41.035]                     }
[16:18:41.035]                     invisible(muffled)
[16:18:41.035]                   }
[16:18:41.035]                   muffleCondition(cond)
[16:18:41.035]                 })
[16:18:41.035]             }))
[16:18:41.035]             future::FutureResult(value = ...future.value$value, 
[16:18:41.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.035]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.035]                     ...future.globalenv.names))
[16:18:41.035]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.035]         }, condition = base::local({
[16:18:41.035]             c <- base::c
[16:18:41.035]             inherits <- base::inherits
[16:18:41.035]             invokeRestart <- base::invokeRestart
[16:18:41.035]             length <- base::length
[16:18:41.035]             list <- base::list
[16:18:41.035]             seq.int <- base::seq.int
[16:18:41.035]             signalCondition <- base::signalCondition
[16:18:41.035]             sys.calls <- base::sys.calls
[16:18:41.035]             `[[` <- base::`[[`
[16:18:41.035]             `+` <- base::`+`
[16:18:41.035]             `<<-` <- base::`<<-`
[16:18:41.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.035]                   3L)]
[16:18:41.035]             }
[16:18:41.035]             function(cond) {
[16:18:41.035]                 is_error <- inherits(cond, "error")
[16:18:41.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.035]                   NULL)
[16:18:41.035]                 if (is_error) {
[16:18:41.035]                   sessionInformation <- function() {
[16:18:41.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.035]                       search = base::search(), system = base::Sys.info())
[16:18:41.035]                   }
[16:18:41.035]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.035]                     cond$call), session = sessionInformation(), 
[16:18:41.035]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.035]                   signalCondition(cond)
[16:18:41.035]                 }
[16:18:41.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.035]                 "immediateCondition"))) {
[16:18:41.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.035]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.035]                   if (TRUE && !signal) {
[16:18:41.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.035]                     {
[16:18:41.035]                       inherits <- base::inherits
[16:18:41.035]                       invokeRestart <- base::invokeRestart
[16:18:41.035]                       is.null <- base::is.null
[16:18:41.035]                       muffled <- FALSE
[16:18:41.035]                       if (inherits(cond, "message")) {
[16:18:41.035]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.035]                         if (muffled) 
[16:18:41.035]                           invokeRestart("muffleMessage")
[16:18:41.035]                       }
[16:18:41.035]                       else if (inherits(cond, "warning")) {
[16:18:41.035]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.035]                         if (muffled) 
[16:18:41.035]                           invokeRestart("muffleWarning")
[16:18:41.035]                       }
[16:18:41.035]                       else if (inherits(cond, "condition")) {
[16:18:41.035]                         if (!is.null(pattern)) {
[16:18:41.035]                           computeRestarts <- base::computeRestarts
[16:18:41.035]                           grepl <- base::grepl
[16:18:41.035]                           restarts <- computeRestarts(cond)
[16:18:41.035]                           for (restart in restarts) {
[16:18:41.035]                             name <- restart$name
[16:18:41.035]                             if (is.null(name)) 
[16:18:41.035]                               next
[16:18:41.035]                             if (!grepl(pattern, name)) 
[16:18:41.035]                               next
[16:18:41.035]                             invokeRestart(restart)
[16:18:41.035]                             muffled <- TRUE
[16:18:41.035]                             break
[16:18:41.035]                           }
[16:18:41.035]                         }
[16:18:41.035]                       }
[16:18:41.035]                       invisible(muffled)
[16:18:41.035]                     }
[16:18:41.035]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.035]                   }
[16:18:41.035]                 }
[16:18:41.035]                 else {
[16:18:41.035]                   if (TRUE) {
[16:18:41.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.035]                     {
[16:18:41.035]                       inherits <- base::inherits
[16:18:41.035]                       invokeRestart <- base::invokeRestart
[16:18:41.035]                       is.null <- base::is.null
[16:18:41.035]                       muffled <- FALSE
[16:18:41.035]                       if (inherits(cond, "message")) {
[16:18:41.035]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.035]                         if (muffled) 
[16:18:41.035]                           invokeRestart("muffleMessage")
[16:18:41.035]                       }
[16:18:41.035]                       else if (inherits(cond, "warning")) {
[16:18:41.035]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.035]                         if (muffled) 
[16:18:41.035]                           invokeRestart("muffleWarning")
[16:18:41.035]                       }
[16:18:41.035]                       else if (inherits(cond, "condition")) {
[16:18:41.035]                         if (!is.null(pattern)) {
[16:18:41.035]                           computeRestarts <- base::computeRestarts
[16:18:41.035]                           grepl <- base::grepl
[16:18:41.035]                           restarts <- computeRestarts(cond)
[16:18:41.035]                           for (restart in restarts) {
[16:18:41.035]                             name <- restart$name
[16:18:41.035]                             if (is.null(name)) 
[16:18:41.035]                               next
[16:18:41.035]                             if (!grepl(pattern, name)) 
[16:18:41.035]                               next
[16:18:41.035]                             invokeRestart(restart)
[16:18:41.035]                             muffled <- TRUE
[16:18:41.035]                             break
[16:18:41.035]                           }
[16:18:41.035]                         }
[16:18:41.035]                       }
[16:18:41.035]                       invisible(muffled)
[16:18:41.035]                     }
[16:18:41.035]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.035]                   }
[16:18:41.035]                 }
[16:18:41.035]             }
[16:18:41.035]         }))
[16:18:41.035]     }, error = function(ex) {
[16:18:41.035]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.035]                 ...future.rng), started = ...future.startTime, 
[16:18:41.035]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.035]             version = "1.8"), class = "FutureResult")
[16:18:41.035]     }, finally = {
[16:18:41.035]         if (!identical(...future.workdir, getwd())) 
[16:18:41.035]             setwd(...future.workdir)
[16:18:41.035]         {
[16:18:41.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.035]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.035]             }
[16:18:41.035]             base::options(...future.oldOptions)
[16:18:41.035]             if (.Platform$OS.type == "windows") {
[16:18:41.035]                 old_names <- names(...future.oldEnvVars)
[16:18:41.035]                 envs <- base::Sys.getenv()
[16:18:41.035]                 names <- names(envs)
[16:18:41.035]                 common <- intersect(names, old_names)
[16:18:41.035]                 added <- setdiff(names, old_names)
[16:18:41.035]                 removed <- setdiff(old_names, names)
[16:18:41.035]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.035]                   envs[common]]
[16:18:41.035]                 NAMES <- toupper(changed)
[16:18:41.035]                 args <- list()
[16:18:41.035]                 for (kk in seq_along(NAMES)) {
[16:18:41.035]                   name <- changed[[kk]]
[16:18:41.035]                   NAME <- NAMES[[kk]]
[16:18:41.035]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.035]                     next
[16:18:41.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.035]                 }
[16:18:41.035]                 NAMES <- toupper(added)
[16:18:41.035]                 for (kk in seq_along(NAMES)) {
[16:18:41.035]                   name <- added[[kk]]
[16:18:41.035]                   NAME <- NAMES[[kk]]
[16:18:41.035]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.035]                     next
[16:18:41.035]                   args[[name]] <- ""
[16:18:41.035]                 }
[16:18:41.035]                 NAMES <- toupper(removed)
[16:18:41.035]                 for (kk in seq_along(NAMES)) {
[16:18:41.035]                   name <- removed[[kk]]
[16:18:41.035]                   NAME <- NAMES[[kk]]
[16:18:41.035]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.035]                     next
[16:18:41.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.035]                 }
[16:18:41.035]                 if (length(args) > 0) 
[16:18:41.035]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.035]             }
[16:18:41.035]             else {
[16:18:41.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.035]             }
[16:18:41.035]             {
[16:18:41.035]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.035]                   0L) {
[16:18:41.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.035]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.035]                   base::options(opts)
[16:18:41.035]                 }
[16:18:41.035]                 {
[16:18:41.035]                   {
[16:18:41.035]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.035]                     NULL
[16:18:41.035]                   }
[16:18:41.035]                   options(future.plan = NULL)
[16:18:41.035]                   if (is.na(NA_character_)) 
[16:18:41.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.035]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.035]                     .init = FALSE)
[16:18:41.035]                 }
[16:18:41.035]             }
[16:18:41.035]         }
[16:18:41.035]     })
[16:18:41.035]     if (TRUE) {
[16:18:41.035]         base::sink(type = "output", split = FALSE)
[16:18:41.035]         if (TRUE) {
[16:18:41.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.035]         }
[16:18:41.035]         else {
[16:18:41.035]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.035]         }
[16:18:41.035]         base::close(...future.stdout)
[16:18:41.035]         ...future.stdout <- NULL
[16:18:41.035]     }
[16:18:41.035]     ...future.result$conditions <- ...future.conditions
[16:18:41.035]     ...future.result$finished <- base::Sys.time()
[16:18:41.035]     ...future.result
[16:18:41.035] }
[16:18:41.038] assign_globals() ...
[16:18:41.038] List of 5
[16:18:41.038]  $ ...future.FUN            :function (x, ...)  
[16:18:41.038]  $ MoreArgs                 : NULL
[16:18:41.038]  $ ...future.elements_ii    :List of 2
[16:18:41.038]   ..$ :List of 2
[16:18:41.038]   .. ..$ : int 1
[16:18:41.038]   .. ..$ : int 2
[16:18:41.038]   ..$ :List of 2
[16:18:41.038]   .. ..$ : int 4
[16:18:41.038]   .. ..$ : int 3
[16:18:41.038]  $ ...future.seeds_ii       : NULL
[16:18:41.038]  $ ...future.globals.maxSize: NULL
[16:18:41.038]  - attr(*, "where")=List of 5
[16:18:41.038]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.038]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.038]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.038]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.038]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.038]  - attr(*, "resolved")= logi FALSE
[16:18:41.038]  - attr(*, "total_size")= num 280
[16:18:41.038]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.038]  - attr(*, "already-done")= logi TRUE
[16:18:41.044] - copied ‘...future.FUN’ to environment
[16:18:41.044] - copied ‘MoreArgs’ to environment
[16:18:41.044] - copied ‘...future.elements_ii’ to environment
[16:18:41.044] - copied ‘...future.seeds_ii’ to environment
[16:18:41.044] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.044] assign_globals() ... done
[16:18:41.044] requestCore(): workers = 2
[16:18:41.047] MulticoreFuture started
[16:18:41.047] - Launch lazy future ... done
[16:18:41.047] run() for ‘MulticoreFuture’ ... done
[16:18:41.048] Created future:
[16:18:41.048] plan(): Setting new future strategy stack:
[16:18:41.048] List of future strategies:
[16:18:41.048] 1. sequential:
[16:18:41.048]    - args: function (..., envir = parent.frame())
[16:18:41.048]    - tweaked: FALSE
[16:18:41.048]    - call: NULL
[16:18:41.049] plan(): nbrOfWorkers() = 1
[16:18:41.051] plan(): Setting new future strategy stack:
[16:18:41.051] List of future strategies:
[16:18:41.051] 1. multicore:
[16:18:41.051]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.051]    - tweaked: FALSE
[16:18:41.051]    - call: plan(strategy)
[16:18:41.056] plan(): nbrOfWorkers() = 2
[16:18:41.048] MulticoreFuture:
[16:18:41.048] Label: ‘future_mapply-1’
[16:18:41.048] Expression:
[16:18:41.048] {
[16:18:41.048]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.048]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.048]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.048]         on.exit(options(oopts), add = TRUE)
[16:18:41.048]     }
[16:18:41.048]     {
[16:18:41.048]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.048]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.048]         do.call(mapply, args = args)
[16:18:41.048]     }
[16:18:41.048] }
[16:18:41.048] Lazy evaluation: FALSE
[16:18:41.048] Asynchronous evaluation: TRUE
[16:18:41.048] Local evaluation: TRUE
[16:18:41.048] Environment: R_GlobalEnv
[16:18:41.048] Capture standard output: TRUE
[16:18:41.048] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.048] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.048] Packages: <none>
[16:18:41.048] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.048] Resolved: TRUE
[16:18:41.048] Value: <not collected>
[16:18:41.048] Conditions captured: <none>
[16:18:41.048] Early signaling: FALSE
[16:18:41.048] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.048] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.058] Chunk #1 of 2 ... DONE
[16:18:41.058] Chunk #2 of 2 ...
[16:18:41.058]  - Finding globals in '...' for chunk #2 ...
[16:18:41.058] getGlobalsAndPackages() ...
[16:18:41.058] Searching for globals...
[16:18:41.059] 
[16:18:41.059] Searching for globals ... DONE
[16:18:41.059] - globals: [0] <none>
[16:18:41.059] getGlobalsAndPackages() ... DONE
[16:18:41.059]    + additional globals found: [n=0] 
[16:18:41.060]    + additional namespaces needed: [n=0] 
[16:18:41.060]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:41.060]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.060]  - seeds: <none>
[16:18:41.060]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.060] getGlobalsAndPackages() ...
[16:18:41.060] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.061] Resolving globals: FALSE
[16:18:41.062] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:41.062] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:41.063] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.063] 
[16:18:41.063] getGlobalsAndPackages() ... DONE
[16:18:41.067] run() for ‘Future’ ...
[16:18:41.068] - state: ‘created’
[16:18:41.068] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.075] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.075]   - Field: ‘label’
[16:18:41.075]   - Field: ‘local’
[16:18:41.076]   - Field: ‘owner’
[16:18:41.076]   - Field: ‘envir’
[16:18:41.076]   - Field: ‘workers’
[16:18:41.077]   - Field: ‘packages’
[16:18:41.077]   - Field: ‘gc’
[16:18:41.077]   - Field: ‘job’
[16:18:41.077]   - Field: ‘conditions’
[16:18:41.077]   - Field: ‘expr’
[16:18:41.078]   - Field: ‘uuid’
[16:18:41.078]   - Field: ‘seed’
[16:18:41.078]   - Field: ‘version’
[16:18:41.078]   - Field: ‘result’
[16:18:41.078]   - Field: ‘asynchronous’
[16:18:41.078]   - Field: ‘calls’
[16:18:41.079]   - Field: ‘globals’
[16:18:41.079]   - Field: ‘stdout’
[16:18:41.079]   - Field: ‘earlySignal’
[16:18:41.079]   - Field: ‘lazy’
[16:18:41.079]   - Field: ‘state’
[16:18:41.079] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.079] - Launch lazy future ...
[16:18:41.080] Packages needed by the future expression (n = 0): <none>
[16:18:41.080] Packages needed by future strategies (n = 0): <none>
[16:18:41.081] {
[16:18:41.081]     {
[16:18:41.081]         {
[16:18:41.081]             ...future.startTime <- base::Sys.time()
[16:18:41.081]             {
[16:18:41.081]                 {
[16:18:41.081]                   {
[16:18:41.081]                     {
[16:18:41.081]                       base::local({
[16:18:41.081]                         has_future <- base::requireNamespace("future", 
[16:18:41.081]                           quietly = TRUE)
[16:18:41.081]                         if (has_future) {
[16:18:41.081]                           ns <- base::getNamespace("future")
[16:18:41.081]                           version <- ns[[".package"]][["version"]]
[16:18:41.081]                           if (is.null(version)) 
[16:18:41.081]                             version <- utils::packageVersion("future")
[16:18:41.081]                         }
[16:18:41.081]                         else {
[16:18:41.081]                           version <- NULL
[16:18:41.081]                         }
[16:18:41.081]                         if (!has_future || version < "1.8.0") {
[16:18:41.081]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.081]                             "", base::R.version$version.string), 
[16:18:41.081]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.081]                               "release", "version")], collapse = " "), 
[16:18:41.081]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.081]                             info)
[16:18:41.081]                           info <- base::paste(info, collapse = "; ")
[16:18:41.081]                           if (!has_future) {
[16:18:41.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.081]                               info)
[16:18:41.081]                           }
[16:18:41.081]                           else {
[16:18:41.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.081]                               info, version)
[16:18:41.081]                           }
[16:18:41.081]                           base::stop(msg)
[16:18:41.081]                         }
[16:18:41.081]                       })
[16:18:41.081]                     }
[16:18:41.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.081]                     base::options(mc.cores = 1L)
[16:18:41.081]                   }
[16:18:41.081]                   ...future.strategy.old <- future::plan("list")
[16:18:41.081]                   options(future.plan = NULL)
[16:18:41.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.081]                 }
[16:18:41.081]                 ...future.workdir <- getwd()
[16:18:41.081]             }
[16:18:41.081]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.081]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.081]         }
[16:18:41.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.081]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.081]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.081]             base::names(...future.oldOptions))
[16:18:41.081]     }
[16:18:41.081]     if (FALSE) {
[16:18:41.081]     }
[16:18:41.081]     else {
[16:18:41.081]         if (TRUE) {
[16:18:41.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.081]                 open = "w")
[16:18:41.081]         }
[16:18:41.081]         else {
[16:18:41.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.081]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.081]         }
[16:18:41.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.081]             base::sink(type = "output", split = FALSE)
[16:18:41.081]             base::close(...future.stdout)
[16:18:41.081]         }, add = TRUE)
[16:18:41.081]     }
[16:18:41.081]     ...future.frame <- base::sys.nframe()
[16:18:41.081]     ...future.conditions <- base::list()
[16:18:41.081]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.081]     if (FALSE) {
[16:18:41.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.081]     }
[16:18:41.081]     ...future.result <- base::tryCatch({
[16:18:41.081]         base::withCallingHandlers({
[16:18:41.081]             ...future.value <- base::withVisible(base::local({
[16:18:41.081]                 withCallingHandlers({
[16:18:41.081]                   {
[16:18:41.081]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.081]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.081]                       ...future.globals.maxSize)) {
[16:18:41.081]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.081]                       on.exit(options(oopts), add = TRUE)
[16:18:41.081]                     }
[16:18:41.081]                     {
[16:18:41.081]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.081]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.081]                         USE.NAMES = FALSE)
[16:18:41.081]                       do.call(mapply, args = args)
[16:18:41.081]                     }
[16:18:41.081]                   }
[16:18:41.081]                 }, immediateCondition = function(cond) {
[16:18:41.081]                   save_rds <- function (object, pathname, ...) 
[16:18:41.081]                   {
[16:18:41.081]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.081]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.081]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.081]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.081]                         fi_tmp[["mtime"]])
[16:18:41.081]                     }
[16:18:41.081]                     tryCatch({
[16:18:41.081]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.081]                     }, error = function(ex) {
[16:18:41.081]                       msg <- conditionMessage(ex)
[16:18:41.081]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.081]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.081]                         fi_tmp[["mtime"]], msg)
[16:18:41.081]                       ex$message <- msg
[16:18:41.081]                       stop(ex)
[16:18:41.081]                     })
[16:18:41.081]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.081]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.081]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.081]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.081]                       fi <- file.info(pathname)
[16:18:41.081]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.081]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.081]                         fi[["size"]], fi[["mtime"]])
[16:18:41.081]                       stop(msg)
[16:18:41.081]                     }
[16:18:41.081]                     invisible(pathname)
[16:18:41.081]                   }
[16:18:41.081]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.081]                     rootPath = tempdir()) 
[16:18:41.081]                   {
[16:18:41.081]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.081]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.081]                       tmpdir = path, fileext = ".rds")
[16:18:41.081]                     save_rds(obj, file)
[16:18:41.081]                   }
[16:18:41.081]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.081]                   {
[16:18:41.081]                     inherits <- base::inherits
[16:18:41.081]                     invokeRestart <- base::invokeRestart
[16:18:41.081]                     is.null <- base::is.null
[16:18:41.081]                     muffled <- FALSE
[16:18:41.081]                     if (inherits(cond, "message")) {
[16:18:41.081]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.081]                       if (muffled) 
[16:18:41.081]                         invokeRestart("muffleMessage")
[16:18:41.081]                     }
[16:18:41.081]                     else if (inherits(cond, "warning")) {
[16:18:41.081]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.081]                       if (muffled) 
[16:18:41.081]                         invokeRestart("muffleWarning")
[16:18:41.081]                     }
[16:18:41.081]                     else if (inherits(cond, "condition")) {
[16:18:41.081]                       if (!is.null(pattern)) {
[16:18:41.081]                         computeRestarts <- base::computeRestarts
[16:18:41.081]                         grepl <- base::grepl
[16:18:41.081]                         restarts <- computeRestarts(cond)
[16:18:41.081]                         for (restart in restarts) {
[16:18:41.081]                           name <- restart$name
[16:18:41.081]                           if (is.null(name)) 
[16:18:41.081]                             next
[16:18:41.081]                           if (!grepl(pattern, name)) 
[16:18:41.081]                             next
[16:18:41.081]                           invokeRestart(restart)
[16:18:41.081]                           muffled <- TRUE
[16:18:41.081]                           break
[16:18:41.081]                         }
[16:18:41.081]                       }
[16:18:41.081]                     }
[16:18:41.081]                     invisible(muffled)
[16:18:41.081]                   }
[16:18:41.081]                   muffleCondition(cond)
[16:18:41.081]                 })
[16:18:41.081]             }))
[16:18:41.081]             future::FutureResult(value = ...future.value$value, 
[16:18:41.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.081]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.081]                     ...future.globalenv.names))
[16:18:41.081]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.081]         }, condition = base::local({
[16:18:41.081]             c <- base::c
[16:18:41.081]             inherits <- base::inherits
[16:18:41.081]             invokeRestart <- base::invokeRestart
[16:18:41.081]             length <- base::length
[16:18:41.081]             list <- base::list
[16:18:41.081]             seq.int <- base::seq.int
[16:18:41.081]             signalCondition <- base::signalCondition
[16:18:41.081]             sys.calls <- base::sys.calls
[16:18:41.081]             `[[` <- base::`[[`
[16:18:41.081]             `+` <- base::`+`
[16:18:41.081]             `<<-` <- base::`<<-`
[16:18:41.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.081]                   3L)]
[16:18:41.081]             }
[16:18:41.081]             function(cond) {
[16:18:41.081]                 is_error <- inherits(cond, "error")
[16:18:41.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.081]                   NULL)
[16:18:41.081]                 if (is_error) {
[16:18:41.081]                   sessionInformation <- function() {
[16:18:41.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.081]                       search = base::search(), system = base::Sys.info())
[16:18:41.081]                   }
[16:18:41.081]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.081]                     cond$call), session = sessionInformation(), 
[16:18:41.081]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.081]                   signalCondition(cond)
[16:18:41.081]                 }
[16:18:41.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.081]                 "immediateCondition"))) {
[16:18:41.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.081]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.081]                   if (TRUE && !signal) {
[16:18:41.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.081]                     {
[16:18:41.081]                       inherits <- base::inherits
[16:18:41.081]                       invokeRestart <- base::invokeRestart
[16:18:41.081]                       is.null <- base::is.null
[16:18:41.081]                       muffled <- FALSE
[16:18:41.081]                       if (inherits(cond, "message")) {
[16:18:41.081]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.081]                         if (muffled) 
[16:18:41.081]                           invokeRestart("muffleMessage")
[16:18:41.081]                       }
[16:18:41.081]                       else if (inherits(cond, "warning")) {
[16:18:41.081]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.081]                         if (muffled) 
[16:18:41.081]                           invokeRestart("muffleWarning")
[16:18:41.081]                       }
[16:18:41.081]                       else if (inherits(cond, "condition")) {
[16:18:41.081]                         if (!is.null(pattern)) {
[16:18:41.081]                           computeRestarts <- base::computeRestarts
[16:18:41.081]                           grepl <- base::grepl
[16:18:41.081]                           restarts <- computeRestarts(cond)
[16:18:41.081]                           for (restart in restarts) {
[16:18:41.081]                             name <- restart$name
[16:18:41.081]                             if (is.null(name)) 
[16:18:41.081]                               next
[16:18:41.081]                             if (!grepl(pattern, name)) 
[16:18:41.081]                               next
[16:18:41.081]                             invokeRestart(restart)
[16:18:41.081]                             muffled <- TRUE
[16:18:41.081]                             break
[16:18:41.081]                           }
[16:18:41.081]                         }
[16:18:41.081]                       }
[16:18:41.081]                       invisible(muffled)
[16:18:41.081]                     }
[16:18:41.081]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.081]                   }
[16:18:41.081]                 }
[16:18:41.081]                 else {
[16:18:41.081]                   if (TRUE) {
[16:18:41.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.081]                     {
[16:18:41.081]                       inherits <- base::inherits
[16:18:41.081]                       invokeRestart <- base::invokeRestart
[16:18:41.081]                       is.null <- base::is.null
[16:18:41.081]                       muffled <- FALSE
[16:18:41.081]                       if (inherits(cond, "message")) {
[16:18:41.081]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.081]                         if (muffled) 
[16:18:41.081]                           invokeRestart("muffleMessage")
[16:18:41.081]                       }
[16:18:41.081]                       else if (inherits(cond, "warning")) {
[16:18:41.081]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.081]                         if (muffled) 
[16:18:41.081]                           invokeRestart("muffleWarning")
[16:18:41.081]                       }
[16:18:41.081]                       else if (inherits(cond, "condition")) {
[16:18:41.081]                         if (!is.null(pattern)) {
[16:18:41.081]                           computeRestarts <- base::computeRestarts
[16:18:41.081]                           grepl <- base::grepl
[16:18:41.081]                           restarts <- computeRestarts(cond)
[16:18:41.081]                           for (restart in restarts) {
[16:18:41.081]                             name <- restart$name
[16:18:41.081]                             if (is.null(name)) 
[16:18:41.081]                               next
[16:18:41.081]                             if (!grepl(pattern, name)) 
[16:18:41.081]                               next
[16:18:41.081]                             invokeRestart(restart)
[16:18:41.081]                             muffled <- TRUE
[16:18:41.081]                             break
[16:18:41.081]                           }
[16:18:41.081]                         }
[16:18:41.081]                       }
[16:18:41.081]                       invisible(muffled)
[16:18:41.081]                     }
[16:18:41.081]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.081]                   }
[16:18:41.081]                 }
[16:18:41.081]             }
[16:18:41.081]         }))
[16:18:41.081]     }, error = function(ex) {
[16:18:41.081]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.081]                 ...future.rng), started = ...future.startTime, 
[16:18:41.081]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.081]             version = "1.8"), class = "FutureResult")
[16:18:41.081]     }, finally = {
[16:18:41.081]         if (!identical(...future.workdir, getwd())) 
[16:18:41.081]             setwd(...future.workdir)
[16:18:41.081]         {
[16:18:41.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.081]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.081]             }
[16:18:41.081]             base::options(...future.oldOptions)
[16:18:41.081]             if (.Platform$OS.type == "windows") {
[16:18:41.081]                 old_names <- names(...future.oldEnvVars)
[16:18:41.081]                 envs <- base::Sys.getenv()
[16:18:41.081]                 names <- names(envs)
[16:18:41.081]                 common <- intersect(names, old_names)
[16:18:41.081]                 added <- setdiff(names, old_names)
[16:18:41.081]                 removed <- setdiff(old_names, names)
[16:18:41.081]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.081]                   envs[common]]
[16:18:41.081]                 NAMES <- toupper(changed)
[16:18:41.081]                 args <- list()
[16:18:41.081]                 for (kk in seq_along(NAMES)) {
[16:18:41.081]                   name <- changed[[kk]]
[16:18:41.081]                   NAME <- NAMES[[kk]]
[16:18:41.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.081]                     next
[16:18:41.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.081]                 }
[16:18:41.081]                 NAMES <- toupper(added)
[16:18:41.081]                 for (kk in seq_along(NAMES)) {
[16:18:41.081]                   name <- added[[kk]]
[16:18:41.081]                   NAME <- NAMES[[kk]]
[16:18:41.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.081]                     next
[16:18:41.081]                   args[[name]] <- ""
[16:18:41.081]                 }
[16:18:41.081]                 NAMES <- toupper(removed)
[16:18:41.081]                 for (kk in seq_along(NAMES)) {
[16:18:41.081]                   name <- removed[[kk]]
[16:18:41.081]                   NAME <- NAMES[[kk]]
[16:18:41.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.081]                     next
[16:18:41.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.081]                 }
[16:18:41.081]                 if (length(args) > 0) 
[16:18:41.081]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.081]             }
[16:18:41.081]             else {
[16:18:41.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.081]             }
[16:18:41.081]             {
[16:18:41.081]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.081]                   0L) {
[16:18:41.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.081]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.081]                   base::options(opts)
[16:18:41.081]                 }
[16:18:41.081]                 {
[16:18:41.081]                   {
[16:18:41.081]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.081]                     NULL
[16:18:41.081]                   }
[16:18:41.081]                   options(future.plan = NULL)
[16:18:41.081]                   if (is.na(NA_character_)) 
[16:18:41.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.081]                     .init = FALSE)
[16:18:41.081]                 }
[16:18:41.081]             }
[16:18:41.081]         }
[16:18:41.081]     })
[16:18:41.081]     if (TRUE) {
[16:18:41.081]         base::sink(type = "output", split = FALSE)
[16:18:41.081]         if (TRUE) {
[16:18:41.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.081]         }
[16:18:41.081]         else {
[16:18:41.081]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.081]         }
[16:18:41.081]         base::close(...future.stdout)
[16:18:41.081]         ...future.stdout <- NULL
[16:18:41.081]     }
[16:18:41.081]     ...future.result$conditions <- ...future.conditions
[16:18:41.081]     ...future.result$finished <- base::Sys.time()
[16:18:41.081]     ...future.result
[16:18:41.081] }
[16:18:41.084] assign_globals() ...
[16:18:41.084] List of 5
[16:18:41.084]  $ ...future.FUN            :function (x, ...)  
[16:18:41.084]  $ MoreArgs                 : NULL
[16:18:41.084]  $ ...future.elements_ii    :List of 2
[16:18:41.084]   ..$ :List of 2
[16:18:41.084]   .. ..$ : int 3
[16:18:41.084]   .. ..$ : int 4
[16:18:41.084]   ..$ :List of 2
[16:18:41.084]   .. ..$ : int 2
[16:18:41.084]   .. ..$ : int 1
[16:18:41.084]  $ ...future.seeds_ii       : NULL
[16:18:41.084]  $ ...future.globals.maxSize: NULL
[16:18:41.084]  - attr(*, "where")=List of 5
[16:18:41.084]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.084]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.084]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.084]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.084]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.084]  - attr(*, "resolved")= logi FALSE
[16:18:41.084]  - attr(*, "total_size")= num 280
[16:18:41.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.084]  - attr(*, "already-done")= logi TRUE
[16:18:41.092] - copied ‘...future.FUN’ to environment
[16:18:41.092] - copied ‘MoreArgs’ to environment
[16:18:41.092] - copied ‘...future.elements_ii’ to environment
[16:18:41.092] - copied ‘...future.seeds_ii’ to environment
[16:18:41.093] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.093] assign_globals() ... done
[16:18:41.093] requestCore(): workers = 2
[16:18:41.095] MulticoreFuture started
[16:18:41.096] - Launch lazy future ... done
[16:18:41.096] run() for ‘MulticoreFuture’ ... done
[16:18:41.096] Created future:
[16:18:41.096] plan(): Setting new future strategy stack:
[16:18:41.097] List of future strategies:
[16:18:41.097] 1. sequential:
[16:18:41.097]    - args: function (..., envir = parent.frame())
[16:18:41.097]    - tweaked: FALSE
[16:18:41.097]    - call: NULL
[16:18:41.097] plan(): nbrOfWorkers() = 1
[16:18:41.100] plan(): Setting new future strategy stack:
[16:18:41.100] List of future strategies:
[16:18:41.100] 1. multicore:
[16:18:41.100]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.100]    - tweaked: FALSE
[16:18:41.100]    - call: plan(strategy)
[16:18:41.105] plan(): nbrOfWorkers() = 2
[16:18:41.096] MulticoreFuture:
[16:18:41.096] Label: ‘future_mapply-2’
[16:18:41.096] Expression:
[16:18:41.096] {
[16:18:41.096]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.096]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.096]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.096]         on.exit(options(oopts), add = TRUE)
[16:18:41.096]     }
[16:18:41.096]     {
[16:18:41.096]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.096]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.096]         do.call(mapply, args = args)
[16:18:41.096]     }
[16:18:41.096] }
[16:18:41.096] Lazy evaluation: FALSE
[16:18:41.096] Asynchronous evaluation: TRUE
[16:18:41.096] Local evaluation: TRUE
[16:18:41.096] Environment: R_GlobalEnv
[16:18:41.096] Capture standard output: TRUE
[16:18:41.096] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.096] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.096] Packages: <none>
[16:18:41.096] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.096] Resolved: TRUE
[16:18:41.096] Value: <not collected>
[16:18:41.096] Conditions captured: <none>
[16:18:41.096] Early signaling: FALSE
[16:18:41.096] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.096] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.106] Chunk #2 of 2 ... DONE
[16:18:41.106] Launching 2 futures (chunks) ... DONE
[16:18:41.106] Resolving 2 futures (chunks) ...
[16:18:41.107] resolve() on list ...
[16:18:41.107]  recursive: 0
[16:18:41.107]  length: 2
[16:18:41.107] 
[16:18:41.107] Future #1
[16:18:41.108] result() for MulticoreFuture ...
[16:18:41.109] result() for MulticoreFuture ...
[16:18:41.109] result() for MulticoreFuture ... done
[16:18:41.109] result() for MulticoreFuture ... done
[16:18:41.109] result() for MulticoreFuture ...
[16:18:41.109] result() for MulticoreFuture ... done
[16:18:41.109] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:41.110] - nx: 2
[16:18:41.110] - relay: TRUE
[16:18:41.110] - stdout: TRUE
[16:18:41.110] - signal: TRUE
[16:18:41.110] - resignal: FALSE
[16:18:41.110] - force: TRUE
[16:18:41.110] - relayed: [n=2] FALSE, FALSE
[16:18:41.111] - queued futures: [n=2] FALSE, FALSE
[16:18:41.111]  - until=1
[16:18:41.111]  - relaying element #1
[16:18:41.111] result() for MulticoreFuture ...
[16:18:41.111] result() for MulticoreFuture ... done
[16:18:41.111] result() for MulticoreFuture ...
[16:18:41.111] result() for MulticoreFuture ... done
[16:18:41.112] result() for MulticoreFuture ...
[16:18:41.112] result() for MulticoreFuture ... done
[16:18:41.112] result() for MulticoreFuture ...
[16:18:41.112] result() for MulticoreFuture ... done
[16:18:41.112] - relayed: [n=2] TRUE, FALSE
[16:18:41.112] - queued futures: [n=2] TRUE, FALSE
[16:18:41.113] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:41.113]  length: 1 (resolved future 1)
[16:18:41.113] Future #2
[16:18:41.113] result() for MulticoreFuture ...
[16:18:41.114] result() for MulticoreFuture ...
[16:18:41.114] result() for MulticoreFuture ... done
[16:18:41.114] result() for MulticoreFuture ... done
[16:18:41.115] result() for MulticoreFuture ...
[16:18:41.115] result() for MulticoreFuture ... done
[16:18:41.115] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:41.115] - nx: 2
[16:18:41.115] - relay: TRUE
[16:18:41.115] - stdout: TRUE
[16:18:41.115] - signal: TRUE
[16:18:41.116] - resignal: FALSE
[16:18:41.116] - force: TRUE
[16:18:41.118] - relayed: [n=2] TRUE, FALSE
[16:18:41.119] - queued futures: [n=2] TRUE, FALSE
[16:18:41.119]  - until=2
[16:18:41.119]  - relaying element #2
[16:18:41.119] result() for MulticoreFuture ...
[16:18:41.119] result() for MulticoreFuture ... done
[16:18:41.120] result() for MulticoreFuture ...
[16:18:41.120] result() for MulticoreFuture ... done
[16:18:41.120] result() for MulticoreFuture ...
[16:18:41.120] result() for MulticoreFuture ... done
[16:18:41.120] result() for MulticoreFuture ...
[16:18:41.121] result() for MulticoreFuture ... done
[16:18:41.121] - relayed: [n=2] TRUE, TRUE
[16:18:41.121] - queued futures: [n=2] TRUE, TRUE
[16:18:41.121] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:41.121]  length: 0 (resolved future 2)
[16:18:41.121] Relaying remaining futures
[16:18:41.122] signalConditionsASAP(NULL, pos=0) ...
[16:18:41.122] - nx: 2
[16:18:41.122] - relay: TRUE
[16:18:41.122] - stdout: TRUE
[16:18:41.122] - signal: TRUE
[16:18:41.122] - resignal: FALSE
[16:18:41.122] - force: TRUE
[16:18:41.123] - relayed: [n=2] TRUE, TRUE
[16:18:41.123] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:41.123] - relayed: [n=2] TRUE, TRUE
[16:18:41.123] - queued futures: [n=2] TRUE, TRUE
[16:18:41.123] signalConditionsASAP(NULL, pos=0) ... done
[16:18:41.123] resolve() on list ... DONE
[16:18:41.124] result() for MulticoreFuture ...
[16:18:41.124] result() for MulticoreFuture ... done
[16:18:41.124] result() for MulticoreFuture ...
[16:18:41.124] result() for MulticoreFuture ... done
[16:18:41.124] result() for MulticoreFuture ...
[16:18:41.124] result() for MulticoreFuture ... done
[16:18:41.124] result() for MulticoreFuture ...
[16:18:41.124] result() for MulticoreFuture ... done
[16:18:41.125]  - Number of value chunks collected: 2
[16:18:41.125] Resolving 2 futures (chunks) ... DONE
[16:18:41.125] Reducing values from 2 chunks ...
[16:18:41.125]  - Number of values collected after concatenation: 4
[16:18:41.125]  - Number of values expected: 4
[16:18:41.125] Reducing values from 2 chunks ... DONE
[16:18:41.125] future_mapply() ... DONE
[16:18:41.125] future_mapply() ...
[16:18:41.130] Number of chunks: 2
[16:18:41.130] getGlobalsAndPackagesXApply() ...
[16:18:41.130]  - future.globals: TRUE
[16:18:41.130] getGlobalsAndPackages() ...
[16:18:41.130] Searching for globals...
[16:18:41.131] - globals found: [1] ‘FUN’
[16:18:41.131] Searching for globals ... DONE
[16:18:41.131] Resolving globals: FALSE
[16:18:41.132] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:41.132] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:41.132] - globals: [1] ‘FUN’
[16:18:41.133] 
[16:18:41.133] getGlobalsAndPackages() ... DONE
[16:18:41.133]  - globals found/used: [n=1] ‘FUN’
[16:18:41.133]  - needed namespaces: [n=0] 
[16:18:41.133] Finding globals ... DONE
[16:18:41.133] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:41.133] List of 2
[16:18:41.133]  $ ...future.FUN:function (x, ...)  
[16:18:41.133]  $ MoreArgs     : NULL
[16:18:41.133]  - attr(*, "where")=List of 2
[16:18:41.133]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:41.133]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:41.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.133]  - attr(*, "resolved")= logi FALSE
[16:18:41.133]  - attr(*, "total_size")= num NA
[16:18:41.136] Packages to be attached in all futures: [n=0] 
[16:18:41.136] getGlobalsAndPackagesXApply() ... DONE
[16:18:41.137] Number of futures (= number of chunks): 2
[16:18:41.137] Launching 2 futures (chunks) ...
[16:18:41.137] Chunk #1 of 2 ...
[16:18:41.137]  - Finding globals in '...' for chunk #1 ...
[16:18:41.137] getGlobalsAndPackages() ...
[16:18:41.137] Searching for globals...
[16:18:41.138] 
[16:18:41.138] Searching for globals ... DONE
[16:18:41.138] - globals: [0] <none>
[16:18:41.138] getGlobalsAndPackages() ... DONE
[16:18:41.138]    + additional globals found: [n=0] 
[16:18:41.138]    + additional namespaces needed: [n=0] 
[16:18:41.138]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:41.138]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.138]  - seeds: <none>
[16:18:41.138]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.139] getGlobalsAndPackages() ...
[16:18:41.139] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.139] Resolving globals: FALSE
[16:18:41.139] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:41.140] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:41.140] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.140] 
[16:18:41.140] getGlobalsAndPackages() ... DONE
[16:18:41.140] run() for ‘Future’ ...
[16:18:41.141] - state: ‘created’
[16:18:41.141] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.144] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.144] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.145]   - Field: ‘label’
[16:18:41.145]   - Field: ‘local’
[16:18:41.145]   - Field: ‘owner’
[16:18:41.145]   - Field: ‘envir’
[16:18:41.145]   - Field: ‘workers’
[16:18:41.145]   - Field: ‘packages’
[16:18:41.145]   - Field: ‘gc’
[16:18:41.145]   - Field: ‘job’
[16:18:41.145]   - Field: ‘conditions’
[16:18:41.145]   - Field: ‘expr’
[16:18:41.145]   - Field: ‘uuid’
[16:18:41.146]   - Field: ‘seed’
[16:18:41.146]   - Field: ‘version’
[16:18:41.146]   - Field: ‘result’
[16:18:41.146]   - Field: ‘asynchronous’
[16:18:41.146]   - Field: ‘calls’
[16:18:41.146]   - Field: ‘globals’
[16:18:41.146]   - Field: ‘stdout’
[16:18:41.146]   - Field: ‘earlySignal’
[16:18:41.146]   - Field: ‘lazy’
[16:18:41.146]   - Field: ‘state’
[16:18:41.147] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.147] - Launch lazy future ...
[16:18:41.147] Packages needed by the future expression (n = 0): <none>
[16:18:41.147] Packages needed by future strategies (n = 0): <none>
[16:18:41.149] {
[16:18:41.149]     {
[16:18:41.149]         {
[16:18:41.149]             ...future.startTime <- base::Sys.time()
[16:18:41.149]             {
[16:18:41.149]                 {
[16:18:41.149]                   {
[16:18:41.149]                     {
[16:18:41.149]                       base::local({
[16:18:41.149]                         has_future <- base::requireNamespace("future", 
[16:18:41.149]                           quietly = TRUE)
[16:18:41.149]                         if (has_future) {
[16:18:41.149]                           ns <- base::getNamespace("future")
[16:18:41.149]                           version <- ns[[".package"]][["version"]]
[16:18:41.149]                           if (is.null(version)) 
[16:18:41.149]                             version <- utils::packageVersion("future")
[16:18:41.149]                         }
[16:18:41.149]                         else {
[16:18:41.149]                           version <- NULL
[16:18:41.149]                         }
[16:18:41.149]                         if (!has_future || version < "1.8.0") {
[16:18:41.149]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.149]                             "", base::R.version$version.string), 
[16:18:41.149]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.149]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.149]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.149]                               "release", "version")], collapse = " "), 
[16:18:41.149]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.149]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.149]                             info)
[16:18:41.149]                           info <- base::paste(info, collapse = "; ")
[16:18:41.149]                           if (!has_future) {
[16:18:41.149]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.149]                               info)
[16:18:41.149]                           }
[16:18:41.149]                           else {
[16:18:41.149]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.149]                               info, version)
[16:18:41.149]                           }
[16:18:41.149]                           base::stop(msg)
[16:18:41.149]                         }
[16:18:41.149]                       })
[16:18:41.149]                     }
[16:18:41.149]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.149]                     base::options(mc.cores = 1L)
[16:18:41.149]                   }
[16:18:41.149]                   ...future.strategy.old <- future::plan("list")
[16:18:41.149]                   options(future.plan = NULL)
[16:18:41.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.149]                 }
[16:18:41.149]                 ...future.workdir <- getwd()
[16:18:41.149]             }
[16:18:41.149]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.149]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.149]         }
[16:18:41.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.149]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.149]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.149]             base::names(...future.oldOptions))
[16:18:41.149]     }
[16:18:41.149]     if (FALSE) {
[16:18:41.149]     }
[16:18:41.149]     else {
[16:18:41.149]         if (TRUE) {
[16:18:41.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.149]                 open = "w")
[16:18:41.149]         }
[16:18:41.149]         else {
[16:18:41.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.149]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.149]         }
[16:18:41.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.149]             base::sink(type = "output", split = FALSE)
[16:18:41.149]             base::close(...future.stdout)
[16:18:41.149]         }, add = TRUE)
[16:18:41.149]     }
[16:18:41.149]     ...future.frame <- base::sys.nframe()
[16:18:41.149]     ...future.conditions <- base::list()
[16:18:41.149]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.149]     if (FALSE) {
[16:18:41.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.149]     }
[16:18:41.149]     ...future.result <- base::tryCatch({
[16:18:41.149]         base::withCallingHandlers({
[16:18:41.149]             ...future.value <- base::withVisible(base::local({
[16:18:41.149]                 withCallingHandlers({
[16:18:41.149]                   {
[16:18:41.149]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.149]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.149]                       ...future.globals.maxSize)) {
[16:18:41.149]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.149]                       on.exit(options(oopts), add = TRUE)
[16:18:41.149]                     }
[16:18:41.149]                     {
[16:18:41.149]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.149]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.149]                         USE.NAMES = FALSE)
[16:18:41.149]                       do.call(mapply, args = args)
[16:18:41.149]                     }
[16:18:41.149]                   }
[16:18:41.149]                 }, immediateCondition = function(cond) {
[16:18:41.149]                   save_rds <- function (object, pathname, ...) 
[16:18:41.149]                   {
[16:18:41.149]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.149]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.149]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.149]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.149]                         fi_tmp[["mtime"]])
[16:18:41.149]                     }
[16:18:41.149]                     tryCatch({
[16:18:41.149]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.149]                     }, error = function(ex) {
[16:18:41.149]                       msg <- conditionMessage(ex)
[16:18:41.149]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.149]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.149]                         fi_tmp[["mtime"]], msg)
[16:18:41.149]                       ex$message <- msg
[16:18:41.149]                       stop(ex)
[16:18:41.149]                     })
[16:18:41.149]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.149]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.149]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.149]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.149]                       fi <- file.info(pathname)
[16:18:41.149]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.149]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.149]                         fi[["size"]], fi[["mtime"]])
[16:18:41.149]                       stop(msg)
[16:18:41.149]                     }
[16:18:41.149]                     invisible(pathname)
[16:18:41.149]                   }
[16:18:41.149]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.149]                     rootPath = tempdir()) 
[16:18:41.149]                   {
[16:18:41.149]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.149]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.149]                       tmpdir = path, fileext = ".rds")
[16:18:41.149]                     save_rds(obj, file)
[16:18:41.149]                   }
[16:18:41.149]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.149]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.149]                   {
[16:18:41.149]                     inherits <- base::inherits
[16:18:41.149]                     invokeRestart <- base::invokeRestart
[16:18:41.149]                     is.null <- base::is.null
[16:18:41.149]                     muffled <- FALSE
[16:18:41.149]                     if (inherits(cond, "message")) {
[16:18:41.149]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.149]                       if (muffled) 
[16:18:41.149]                         invokeRestart("muffleMessage")
[16:18:41.149]                     }
[16:18:41.149]                     else if (inherits(cond, "warning")) {
[16:18:41.149]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.149]                       if (muffled) 
[16:18:41.149]                         invokeRestart("muffleWarning")
[16:18:41.149]                     }
[16:18:41.149]                     else if (inherits(cond, "condition")) {
[16:18:41.149]                       if (!is.null(pattern)) {
[16:18:41.149]                         computeRestarts <- base::computeRestarts
[16:18:41.149]                         grepl <- base::grepl
[16:18:41.149]                         restarts <- computeRestarts(cond)
[16:18:41.149]                         for (restart in restarts) {
[16:18:41.149]                           name <- restart$name
[16:18:41.149]                           if (is.null(name)) 
[16:18:41.149]                             next
[16:18:41.149]                           if (!grepl(pattern, name)) 
[16:18:41.149]                             next
[16:18:41.149]                           invokeRestart(restart)
[16:18:41.149]                           muffled <- TRUE
[16:18:41.149]                           break
[16:18:41.149]                         }
[16:18:41.149]                       }
[16:18:41.149]                     }
[16:18:41.149]                     invisible(muffled)
[16:18:41.149]                   }
[16:18:41.149]                   muffleCondition(cond)
[16:18:41.149]                 })
[16:18:41.149]             }))
[16:18:41.149]             future::FutureResult(value = ...future.value$value, 
[16:18:41.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.149]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.149]                     ...future.globalenv.names))
[16:18:41.149]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.149]         }, condition = base::local({
[16:18:41.149]             c <- base::c
[16:18:41.149]             inherits <- base::inherits
[16:18:41.149]             invokeRestart <- base::invokeRestart
[16:18:41.149]             length <- base::length
[16:18:41.149]             list <- base::list
[16:18:41.149]             seq.int <- base::seq.int
[16:18:41.149]             signalCondition <- base::signalCondition
[16:18:41.149]             sys.calls <- base::sys.calls
[16:18:41.149]             `[[` <- base::`[[`
[16:18:41.149]             `+` <- base::`+`
[16:18:41.149]             `<<-` <- base::`<<-`
[16:18:41.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.149]                   3L)]
[16:18:41.149]             }
[16:18:41.149]             function(cond) {
[16:18:41.149]                 is_error <- inherits(cond, "error")
[16:18:41.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.149]                   NULL)
[16:18:41.149]                 if (is_error) {
[16:18:41.149]                   sessionInformation <- function() {
[16:18:41.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.149]                       search = base::search(), system = base::Sys.info())
[16:18:41.149]                   }
[16:18:41.149]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.149]                     cond$call), session = sessionInformation(), 
[16:18:41.149]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.149]                   signalCondition(cond)
[16:18:41.149]                 }
[16:18:41.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.149]                 "immediateCondition"))) {
[16:18:41.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.149]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.149]                   if (TRUE && !signal) {
[16:18:41.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.149]                     {
[16:18:41.149]                       inherits <- base::inherits
[16:18:41.149]                       invokeRestart <- base::invokeRestart
[16:18:41.149]                       is.null <- base::is.null
[16:18:41.149]                       muffled <- FALSE
[16:18:41.149]                       if (inherits(cond, "message")) {
[16:18:41.149]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.149]                         if (muffled) 
[16:18:41.149]                           invokeRestart("muffleMessage")
[16:18:41.149]                       }
[16:18:41.149]                       else if (inherits(cond, "warning")) {
[16:18:41.149]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.149]                         if (muffled) 
[16:18:41.149]                           invokeRestart("muffleWarning")
[16:18:41.149]                       }
[16:18:41.149]                       else if (inherits(cond, "condition")) {
[16:18:41.149]                         if (!is.null(pattern)) {
[16:18:41.149]                           computeRestarts <- base::computeRestarts
[16:18:41.149]                           grepl <- base::grepl
[16:18:41.149]                           restarts <- computeRestarts(cond)
[16:18:41.149]                           for (restart in restarts) {
[16:18:41.149]                             name <- restart$name
[16:18:41.149]                             if (is.null(name)) 
[16:18:41.149]                               next
[16:18:41.149]                             if (!grepl(pattern, name)) 
[16:18:41.149]                               next
[16:18:41.149]                             invokeRestart(restart)
[16:18:41.149]                             muffled <- TRUE
[16:18:41.149]                             break
[16:18:41.149]                           }
[16:18:41.149]                         }
[16:18:41.149]                       }
[16:18:41.149]                       invisible(muffled)
[16:18:41.149]                     }
[16:18:41.149]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.149]                   }
[16:18:41.149]                 }
[16:18:41.149]                 else {
[16:18:41.149]                   if (TRUE) {
[16:18:41.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.149]                     {
[16:18:41.149]                       inherits <- base::inherits
[16:18:41.149]                       invokeRestart <- base::invokeRestart
[16:18:41.149]                       is.null <- base::is.null
[16:18:41.149]                       muffled <- FALSE
[16:18:41.149]                       if (inherits(cond, "message")) {
[16:18:41.149]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.149]                         if (muffled) 
[16:18:41.149]                           invokeRestart("muffleMessage")
[16:18:41.149]                       }
[16:18:41.149]                       else if (inherits(cond, "warning")) {
[16:18:41.149]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.149]                         if (muffled) 
[16:18:41.149]                           invokeRestart("muffleWarning")
[16:18:41.149]                       }
[16:18:41.149]                       else if (inherits(cond, "condition")) {
[16:18:41.149]                         if (!is.null(pattern)) {
[16:18:41.149]                           computeRestarts <- base::computeRestarts
[16:18:41.149]                           grepl <- base::grepl
[16:18:41.149]                           restarts <- computeRestarts(cond)
[16:18:41.149]                           for (restart in restarts) {
[16:18:41.149]                             name <- restart$name
[16:18:41.149]                             if (is.null(name)) 
[16:18:41.149]                               next
[16:18:41.149]                             if (!grepl(pattern, name)) 
[16:18:41.149]                               next
[16:18:41.149]                             invokeRestart(restart)
[16:18:41.149]                             muffled <- TRUE
[16:18:41.149]                             break
[16:18:41.149]                           }
[16:18:41.149]                         }
[16:18:41.149]                       }
[16:18:41.149]                       invisible(muffled)
[16:18:41.149]                     }
[16:18:41.149]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.149]                   }
[16:18:41.149]                 }
[16:18:41.149]             }
[16:18:41.149]         }))
[16:18:41.149]     }, error = function(ex) {
[16:18:41.149]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.149]                 ...future.rng), started = ...future.startTime, 
[16:18:41.149]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.149]             version = "1.8"), class = "FutureResult")
[16:18:41.149]     }, finally = {
[16:18:41.149]         if (!identical(...future.workdir, getwd())) 
[16:18:41.149]             setwd(...future.workdir)
[16:18:41.149]         {
[16:18:41.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.149]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.149]             }
[16:18:41.149]             base::options(...future.oldOptions)
[16:18:41.149]             if (.Platform$OS.type == "windows") {
[16:18:41.149]                 old_names <- names(...future.oldEnvVars)
[16:18:41.149]                 envs <- base::Sys.getenv()
[16:18:41.149]                 names <- names(envs)
[16:18:41.149]                 common <- intersect(names, old_names)
[16:18:41.149]                 added <- setdiff(names, old_names)
[16:18:41.149]                 removed <- setdiff(old_names, names)
[16:18:41.149]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.149]                   envs[common]]
[16:18:41.149]                 NAMES <- toupper(changed)
[16:18:41.149]                 args <- list()
[16:18:41.149]                 for (kk in seq_along(NAMES)) {
[16:18:41.149]                   name <- changed[[kk]]
[16:18:41.149]                   NAME <- NAMES[[kk]]
[16:18:41.149]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.149]                     next
[16:18:41.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.149]                 }
[16:18:41.149]                 NAMES <- toupper(added)
[16:18:41.149]                 for (kk in seq_along(NAMES)) {
[16:18:41.149]                   name <- added[[kk]]
[16:18:41.149]                   NAME <- NAMES[[kk]]
[16:18:41.149]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.149]                     next
[16:18:41.149]                   args[[name]] <- ""
[16:18:41.149]                 }
[16:18:41.149]                 NAMES <- toupper(removed)
[16:18:41.149]                 for (kk in seq_along(NAMES)) {
[16:18:41.149]                   name <- removed[[kk]]
[16:18:41.149]                   NAME <- NAMES[[kk]]
[16:18:41.149]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.149]                     next
[16:18:41.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.149]                 }
[16:18:41.149]                 if (length(args) > 0) 
[16:18:41.149]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.149]             }
[16:18:41.149]             else {
[16:18:41.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.149]             }
[16:18:41.149]             {
[16:18:41.149]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.149]                   0L) {
[16:18:41.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.149]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.149]                   base::options(opts)
[16:18:41.149]                 }
[16:18:41.149]                 {
[16:18:41.149]                   {
[16:18:41.149]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.149]                     NULL
[16:18:41.149]                   }
[16:18:41.149]                   options(future.plan = NULL)
[16:18:41.149]                   if (is.na(NA_character_)) 
[16:18:41.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.149]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.149]                     .init = FALSE)
[16:18:41.149]                 }
[16:18:41.149]             }
[16:18:41.149]         }
[16:18:41.149]     })
[16:18:41.149]     if (TRUE) {
[16:18:41.149]         base::sink(type = "output", split = FALSE)
[16:18:41.149]         if (TRUE) {
[16:18:41.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.149]         }
[16:18:41.149]         else {
[16:18:41.149]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.149]         }
[16:18:41.149]         base::close(...future.stdout)
[16:18:41.149]         ...future.stdout <- NULL
[16:18:41.149]     }
[16:18:41.149]     ...future.result$conditions <- ...future.conditions
[16:18:41.149]     ...future.result$finished <- base::Sys.time()
[16:18:41.149]     ...future.result
[16:18:41.149] }
[16:18:41.152] assign_globals() ...
[16:18:41.152] List of 5
[16:18:41.152]  $ ...future.FUN            :function (x, ...)  
[16:18:41.152]  $ MoreArgs                 : NULL
[16:18:41.152]  $ ...future.elements_ii    :List of 2
[16:18:41.152]   ..$ times:List of 2
[16:18:41.152]   .. ..$ : int 1
[16:18:41.152]   .. ..$ : int 2
[16:18:41.152]   ..$ x    :List of 2
[16:18:41.152]   .. ..$ : int 4
[16:18:41.152]   .. ..$ : int 3
[16:18:41.152]  $ ...future.seeds_ii       : NULL
[16:18:41.152]  $ ...future.globals.maxSize: NULL
[16:18:41.152]  - attr(*, "where")=List of 5
[16:18:41.152]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.152]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.152]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.152]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.152]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.152]  - attr(*, "resolved")= logi FALSE
[16:18:41.152]  - attr(*, "total_size")= num 280
[16:18:41.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.152]  - attr(*, "already-done")= logi TRUE
[16:18:41.158] - copied ‘...future.FUN’ to environment
[16:18:41.158] - copied ‘MoreArgs’ to environment
[16:18:41.158] - copied ‘...future.elements_ii’ to environment
[16:18:41.158] - copied ‘...future.seeds_ii’ to environment
[16:18:41.158] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.158] assign_globals() ... done
[16:18:41.159] requestCore(): workers = 2
[16:18:41.161] MulticoreFuture started
[16:18:41.161] - Launch lazy future ... done
[16:18:41.161] run() for ‘MulticoreFuture’ ... done
[16:18:41.162] Created future:
[16:18:41.162] plan(): Setting new future strategy stack:
[16:18:41.162] List of future strategies:
[16:18:41.162] 1. sequential:
[16:18:41.162]    - args: function (..., envir = parent.frame())
[16:18:41.162]    - tweaked: FALSE
[16:18:41.162]    - call: NULL
[16:18:41.163] plan(): nbrOfWorkers() = 1
[16:18:41.165] plan(): Setting new future strategy stack:
[16:18:41.165] List of future strategies:
[16:18:41.165] 1. multicore:
[16:18:41.165]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.165]    - tweaked: FALSE
[16:18:41.165]    - call: plan(strategy)
[16:18:41.170] plan(): nbrOfWorkers() = 2
[16:18:41.162] MulticoreFuture:
[16:18:41.162] Label: ‘future_mapply-1’
[16:18:41.162] Expression:
[16:18:41.162] {
[16:18:41.162]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.162]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.162]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.162]         on.exit(options(oopts), add = TRUE)
[16:18:41.162]     }
[16:18:41.162]     {
[16:18:41.162]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.162]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.162]         do.call(mapply, args = args)
[16:18:41.162]     }
[16:18:41.162] }
[16:18:41.162] Lazy evaluation: FALSE
[16:18:41.162] Asynchronous evaluation: TRUE
[16:18:41.162] Local evaluation: TRUE
[16:18:41.162] Environment: R_GlobalEnv
[16:18:41.162] Capture standard output: TRUE
[16:18:41.162] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.162] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.162] Packages: <none>
[16:18:41.162] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.162] Resolved: TRUE
[16:18:41.162] Value: <not collected>
[16:18:41.162] Conditions captured: <none>
[16:18:41.162] Early signaling: FALSE
[16:18:41.162] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.162] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.171] Chunk #1 of 2 ... DONE
[16:18:41.171] Chunk #2 of 2 ...
[16:18:41.172]  - Finding globals in '...' for chunk #2 ...
[16:18:41.172] getGlobalsAndPackages() ...
[16:18:41.172] Searching for globals...
[16:18:41.172] 
[16:18:41.173] Searching for globals ... DONE
[16:18:41.173] - globals: [0] <none>
[16:18:41.173] getGlobalsAndPackages() ... DONE
[16:18:41.173]    + additional globals found: [n=0] 
[16:18:41.173]    + additional namespaces needed: [n=0] 
[16:18:41.173]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:41.173]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.174]  - seeds: <none>
[16:18:41.174]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.174] getGlobalsAndPackages() ...
[16:18:41.174] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.174] Resolving globals: FALSE
[16:18:41.175] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:41.176] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:41.176] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.176] 
[16:18:41.176] getGlobalsAndPackages() ... DONE
[16:18:41.177] run() for ‘Future’ ...
[16:18:41.177] - state: ‘created’
[16:18:41.177] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.182] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.182] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.182]   - Field: ‘label’
[16:18:41.183]   - Field: ‘local’
[16:18:41.183]   - Field: ‘owner’
[16:18:41.183]   - Field: ‘envir’
[16:18:41.183]   - Field: ‘workers’
[16:18:41.183]   - Field: ‘packages’
[16:18:41.183]   - Field: ‘gc’
[16:18:41.183]   - Field: ‘job’
[16:18:41.184]   - Field: ‘conditions’
[16:18:41.184]   - Field: ‘expr’
[16:18:41.184]   - Field: ‘uuid’
[16:18:41.184]   - Field: ‘seed’
[16:18:41.184]   - Field: ‘version’
[16:18:41.184]   - Field: ‘result’
[16:18:41.185]   - Field: ‘asynchronous’
[16:18:41.185]   - Field: ‘calls’
[16:18:41.185]   - Field: ‘globals’
[16:18:41.185]   - Field: ‘stdout’
[16:18:41.185]   - Field: ‘earlySignal’
[16:18:41.185]   - Field: ‘lazy’
[16:18:41.185]   - Field: ‘state’
[16:18:41.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.186] - Launch lazy future ...
[16:18:41.186] Packages needed by the future expression (n = 0): <none>
[16:18:41.186] Packages needed by future strategies (n = 0): <none>
[16:18:41.187] {
[16:18:41.187]     {
[16:18:41.187]         {
[16:18:41.187]             ...future.startTime <- base::Sys.time()
[16:18:41.187]             {
[16:18:41.187]                 {
[16:18:41.187]                   {
[16:18:41.187]                     {
[16:18:41.187]                       base::local({
[16:18:41.187]                         has_future <- base::requireNamespace("future", 
[16:18:41.187]                           quietly = TRUE)
[16:18:41.187]                         if (has_future) {
[16:18:41.187]                           ns <- base::getNamespace("future")
[16:18:41.187]                           version <- ns[[".package"]][["version"]]
[16:18:41.187]                           if (is.null(version)) 
[16:18:41.187]                             version <- utils::packageVersion("future")
[16:18:41.187]                         }
[16:18:41.187]                         else {
[16:18:41.187]                           version <- NULL
[16:18:41.187]                         }
[16:18:41.187]                         if (!has_future || version < "1.8.0") {
[16:18:41.187]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.187]                             "", base::R.version$version.string), 
[16:18:41.187]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.187]                               "release", "version")], collapse = " "), 
[16:18:41.187]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.187]                             info)
[16:18:41.187]                           info <- base::paste(info, collapse = "; ")
[16:18:41.187]                           if (!has_future) {
[16:18:41.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.187]                               info)
[16:18:41.187]                           }
[16:18:41.187]                           else {
[16:18:41.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.187]                               info, version)
[16:18:41.187]                           }
[16:18:41.187]                           base::stop(msg)
[16:18:41.187]                         }
[16:18:41.187]                       })
[16:18:41.187]                     }
[16:18:41.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.187]                     base::options(mc.cores = 1L)
[16:18:41.187]                   }
[16:18:41.187]                   ...future.strategy.old <- future::plan("list")
[16:18:41.187]                   options(future.plan = NULL)
[16:18:41.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.187]                 }
[16:18:41.187]                 ...future.workdir <- getwd()
[16:18:41.187]             }
[16:18:41.187]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.187]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.187]         }
[16:18:41.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.187]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.187]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.187]             base::names(...future.oldOptions))
[16:18:41.187]     }
[16:18:41.187]     if (FALSE) {
[16:18:41.187]     }
[16:18:41.187]     else {
[16:18:41.187]         if (TRUE) {
[16:18:41.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.187]                 open = "w")
[16:18:41.187]         }
[16:18:41.187]         else {
[16:18:41.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.187]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.187]         }
[16:18:41.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.187]             base::sink(type = "output", split = FALSE)
[16:18:41.187]             base::close(...future.stdout)
[16:18:41.187]         }, add = TRUE)
[16:18:41.187]     }
[16:18:41.187]     ...future.frame <- base::sys.nframe()
[16:18:41.187]     ...future.conditions <- base::list()
[16:18:41.187]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.187]     if (FALSE) {
[16:18:41.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.187]     }
[16:18:41.187]     ...future.result <- base::tryCatch({
[16:18:41.187]         base::withCallingHandlers({
[16:18:41.187]             ...future.value <- base::withVisible(base::local({
[16:18:41.187]                 withCallingHandlers({
[16:18:41.187]                   {
[16:18:41.187]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.187]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.187]                       ...future.globals.maxSize)) {
[16:18:41.187]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.187]                       on.exit(options(oopts), add = TRUE)
[16:18:41.187]                     }
[16:18:41.187]                     {
[16:18:41.187]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.187]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.187]                         USE.NAMES = FALSE)
[16:18:41.187]                       do.call(mapply, args = args)
[16:18:41.187]                     }
[16:18:41.187]                   }
[16:18:41.187]                 }, immediateCondition = function(cond) {
[16:18:41.187]                   save_rds <- function (object, pathname, ...) 
[16:18:41.187]                   {
[16:18:41.187]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.187]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.187]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.187]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.187]                         fi_tmp[["mtime"]])
[16:18:41.187]                     }
[16:18:41.187]                     tryCatch({
[16:18:41.187]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.187]                     }, error = function(ex) {
[16:18:41.187]                       msg <- conditionMessage(ex)
[16:18:41.187]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.187]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.187]                         fi_tmp[["mtime"]], msg)
[16:18:41.187]                       ex$message <- msg
[16:18:41.187]                       stop(ex)
[16:18:41.187]                     })
[16:18:41.187]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.187]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.187]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.187]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.187]                       fi <- file.info(pathname)
[16:18:41.187]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.187]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.187]                         fi[["size"]], fi[["mtime"]])
[16:18:41.187]                       stop(msg)
[16:18:41.187]                     }
[16:18:41.187]                     invisible(pathname)
[16:18:41.187]                   }
[16:18:41.187]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.187]                     rootPath = tempdir()) 
[16:18:41.187]                   {
[16:18:41.187]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.187]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.187]                       tmpdir = path, fileext = ".rds")
[16:18:41.187]                     save_rds(obj, file)
[16:18:41.187]                   }
[16:18:41.187]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.187]                   {
[16:18:41.187]                     inherits <- base::inherits
[16:18:41.187]                     invokeRestart <- base::invokeRestart
[16:18:41.187]                     is.null <- base::is.null
[16:18:41.187]                     muffled <- FALSE
[16:18:41.187]                     if (inherits(cond, "message")) {
[16:18:41.187]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.187]                       if (muffled) 
[16:18:41.187]                         invokeRestart("muffleMessage")
[16:18:41.187]                     }
[16:18:41.187]                     else if (inherits(cond, "warning")) {
[16:18:41.187]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.187]                       if (muffled) 
[16:18:41.187]                         invokeRestart("muffleWarning")
[16:18:41.187]                     }
[16:18:41.187]                     else if (inherits(cond, "condition")) {
[16:18:41.187]                       if (!is.null(pattern)) {
[16:18:41.187]                         computeRestarts <- base::computeRestarts
[16:18:41.187]                         grepl <- base::grepl
[16:18:41.187]                         restarts <- computeRestarts(cond)
[16:18:41.187]                         for (restart in restarts) {
[16:18:41.187]                           name <- restart$name
[16:18:41.187]                           if (is.null(name)) 
[16:18:41.187]                             next
[16:18:41.187]                           if (!grepl(pattern, name)) 
[16:18:41.187]                             next
[16:18:41.187]                           invokeRestart(restart)
[16:18:41.187]                           muffled <- TRUE
[16:18:41.187]                           break
[16:18:41.187]                         }
[16:18:41.187]                       }
[16:18:41.187]                     }
[16:18:41.187]                     invisible(muffled)
[16:18:41.187]                   }
[16:18:41.187]                   muffleCondition(cond)
[16:18:41.187]                 })
[16:18:41.187]             }))
[16:18:41.187]             future::FutureResult(value = ...future.value$value, 
[16:18:41.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.187]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.187]                     ...future.globalenv.names))
[16:18:41.187]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.187]         }, condition = base::local({
[16:18:41.187]             c <- base::c
[16:18:41.187]             inherits <- base::inherits
[16:18:41.187]             invokeRestart <- base::invokeRestart
[16:18:41.187]             length <- base::length
[16:18:41.187]             list <- base::list
[16:18:41.187]             seq.int <- base::seq.int
[16:18:41.187]             signalCondition <- base::signalCondition
[16:18:41.187]             sys.calls <- base::sys.calls
[16:18:41.187]             `[[` <- base::`[[`
[16:18:41.187]             `+` <- base::`+`
[16:18:41.187]             `<<-` <- base::`<<-`
[16:18:41.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.187]                   3L)]
[16:18:41.187]             }
[16:18:41.187]             function(cond) {
[16:18:41.187]                 is_error <- inherits(cond, "error")
[16:18:41.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.187]                   NULL)
[16:18:41.187]                 if (is_error) {
[16:18:41.187]                   sessionInformation <- function() {
[16:18:41.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.187]                       search = base::search(), system = base::Sys.info())
[16:18:41.187]                   }
[16:18:41.187]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.187]                     cond$call), session = sessionInformation(), 
[16:18:41.187]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.187]                   signalCondition(cond)
[16:18:41.187]                 }
[16:18:41.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.187]                 "immediateCondition"))) {
[16:18:41.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.187]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.187]                   if (TRUE && !signal) {
[16:18:41.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.187]                     {
[16:18:41.187]                       inherits <- base::inherits
[16:18:41.187]                       invokeRestart <- base::invokeRestart
[16:18:41.187]                       is.null <- base::is.null
[16:18:41.187]                       muffled <- FALSE
[16:18:41.187]                       if (inherits(cond, "message")) {
[16:18:41.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.187]                         if (muffled) 
[16:18:41.187]                           invokeRestart("muffleMessage")
[16:18:41.187]                       }
[16:18:41.187]                       else if (inherits(cond, "warning")) {
[16:18:41.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.187]                         if (muffled) 
[16:18:41.187]                           invokeRestart("muffleWarning")
[16:18:41.187]                       }
[16:18:41.187]                       else if (inherits(cond, "condition")) {
[16:18:41.187]                         if (!is.null(pattern)) {
[16:18:41.187]                           computeRestarts <- base::computeRestarts
[16:18:41.187]                           grepl <- base::grepl
[16:18:41.187]                           restarts <- computeRestarts(cond)
[16:18:41.187]                           for (restart in restarts) {
[16:18:41.187]                             name <- restart$name
[16:18:41.187]                             if (is.null(name)) 
[16:18:41.187]                               next
[16:18:41.187]                             if (!grepl(pattern, name)) 
[16:18:41.187]                               next
[16:18:41.187]                             invokeRestart(restart)
[16:18:41.187]                             muffled <- TRUE
[16:18:41.187]                             break
[16:18:41.187]                           }
[16:18:41.187]                         }
[16:18:41.187]                       }
[16:18:41.187]                       invisible(muffled)
[16:18:41.187]                     }
[16:18:41.187]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.187]                   }
[16:18:41.187]                 }
[16:18:41.187]                 else {
[16:18:41.187]                   if (TRUE) {
[16:18:41.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.187]                     {
[16:18:41.187]                       inherits <- base::inherits
[16:18:41.187]                       invokeRestart <- base::invokeRestart
[16:18:41.187]                       is.null <- base::is.null
[16:18:41.187]                       muffled <- FALSE
[16:18:41.187]                       if (inherits(cond, "message")) {
[16:18:41.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.187]                         if (muffled) 
[16:18:41.187]                           invokeRestart("muffleMessage")
[16:18:41.187]                       }
[16:18:41.187]                       else if (inherits(cond, "warning")) {
[16:18:41.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.187]                         if (muffled) 
[16:18:41.187]                           invokeRestart("muffleWarning")
[16:18:41.187]                       }
[16:18:41.187]                       else if (inherits(cond, "condition")) {
[16:18:41.187]                         if (!is.null(pattern)) {
[16:18:41.187]                           computeRestarts <- base::computeRestarts
[16:18:41.187]                           grepl <- base::grepl
[16:18:41.187]                           restarts <- computeRestarts(cond)
[16:18:41.187]                           for (restart in restarts) {
[16:18:41.187]                             name <- restart$name
[16:18:41.187]                             if (is.null(name)) 
[16:18:41.187]                               next
[16:18:41.187]                             if (!grepl(pattern, name)) 
[16:18:41.187]                               next
[16:18:41.187]                             invokeRestart(restart)
[16:18:41.187]                             muffled <- TRUE
[16:18:41.187]                             break
[16:18:41.187]                           }
[16:18:41.187]                         }
[16:18:41.187]                       }
[16:18:41.187]                       invisible(muffled)
[16:18:41.187]                     }
[16:18:41.187]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.187]                   }
[16:18:41.187]                 }
[16:18:41.187]             }
[16:18:41.187]         }))
[16:18:41.187]     }, error = function(ex) {
[16:18:41.187]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.187]                 ...future.rng), started = ...future.startTime, 
[16:18:41.187]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.187]             version = "1.8"), class = "FutureResult")
[16:18:41.187]     }, finally = {
[16:18:41.187]         if (!identical(...future.workdir, getwd())) 
[16:18:41.187]             setwd(...future.workdir)
[16:18:41.187]         {
[16:18:41.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.187]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.187]             }
[16:18:41.187]             base::options(...future.oldOptions)
[16:18:41.187]             if (.Platform$OS.type == "windows") {
[16:18:41.187]                 old_names <- names(...future.oldEnvVars)
[16:18:41.187]                 envs <- base::Sys.getenv()
[16:18:41.187]                 names <- names(envs)
[16:18:41.187]                 common <- intersect(names, old_names)
[16:18:41.187]                 added <- setdiff(names, old_names)
[16:18:41.187]                 removed <- setdiff(old_names, names)
[16:18:41.187]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.187]                   envs[common]]
[16:18:41.187]                 NAMES <- toupper(changed)
[16:18:41.187]                 args <- list()
[16:18:41.187]                 for (kk in seq_along(NAMES)) {
[16:18:41.187]                   name <- changed[[kk]]
[16:18:41.187]                   NAME <- NAMES[[kk]]
[16:18:41.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.187]                     next
[16:18:41.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.187]                 }
[16:18:41.187]                 NAMES <- toupper(added)
[16:18:41.187]                 for (kk in seq_along(NAMES)) {
[16:18:41.187]                   name <- added[[kk]]
[16:18:41.187]                   NAME <- NAMES[[kk]]
[16:18:41.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.187]                     next
[16:18:41.187]                   args[[name]] <- ""
[16:18:41.187]                 }
[16:18:41.187]                 NAMES <- toupper(removed)
[16:18:41.187]                 for (kk in seq_along(NAMES)) {
[16:18:41.187]                   name <- removed[[kk]]
[16:18:41.187]                   NAME <- NAMES[[kk]]
[16:18:41.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.187]                     next
[16:18:41.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.187]                 }
[16:18:41.187]                 if (length(args) > 0) 
[16:18:41.187]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.187]             }
[16:18:41.187]             else {
[16:18:41.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.187]             }
[16:18:41.187]             {
[16:18:41.187]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.187]                   0L) {
[16:18:41.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.187]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.187]                   base::options(opts)
[16:18:41.187]                 }
[16:18:41.187]                 {
[16:18:41.187]                   {
[16:18:41.187]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.187]                     NULL
[16:18:41.187]                   }
[16:18:41.187]                   options(future.plan = NULL)
[16:18:41.187]                   if (is.na(NA_character_)) 
[16:18:41.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.187]                     .init = FALSE)
[16:18:41.187]                 }
[16:18:41.187]             }
[16:18:41.187]         }
[16:18:41.187]     })
[16:18:41.187]     if (TRUE) {
[16:18:41.187]         base::sink(type = "output", split = FALSE)
[16:18:41.187]         if (TRUE) {
[16:18:41.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.187]         }
[16:18:41.187]         else {
[16:18:41.187]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.187]         }
[16:18:41.187]         base::close(...future.stdout)
[16:18:41.187]         ...future.stdout <- NULL
[16:18:41.187]     }
[16:18:41.187]     ...future.result$conditions <- ...future.conditions
[16:18:41.187]     ...future.result$finished <- base::Sys.time()
[16:18:41.187]     ...future.result
[16:18:41.187] }
[16:18:41.190] assign_globals() ...
[16:18:41.190] List of 5
[16:18:41.190]  $ ...future.FUN            :function (x, ...)  
[16:18:41.190]  $ MoreArgs                 : NULL
[16:18:41.190]  $ ...future.elements_ii    :List of 2
[16:18:41.190]   ..$ times:List of 2
[16:18:41.190]   .. ..$ : int 3
[16:18:41.190]   .. ..$ : int 4
[16:18:41.190]   ..$ x    :List of 2
[16:18:41.190]   .. ..$ : int 2
[16:18:41.190]   .. ..$ : int 1
[16:18:41.190]  $ ...future.seeds_ii       : NULL
[16:18:41.190]  $ ...future.globals.maxSize: NULL
[16:18:41.190]  - attr(*, "where")=List of 5
[16:18:41.190]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.190]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.190]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.190]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.190]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.190]  - attr(*, "resolved")= logi FALSE
[16:18:41.190]  - attr(*, "total_size")= num 280
[16:18:41.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.190]  - attr(*, "already-done")= logi TRUE
[16:18:41.205] - copied ‘...future.FUN’ to environment
[16:18:41.206] - copied ‘MoreArgs’ to environment
[16:18:41.206] - copied ‘...future.elements_ii’ to environment
[16:18:41.206] - copied ‘...future.seeds_ii’ to environment
[16:18:41.206] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.206] assign_globals() ... done
[16:18:41.206] requestCore(): workers = 2
[16:18:41.209] MulticoreFuture started
[16:18:41.209] - Launch lazy future ... done
[16:18:41.209] run() for ‘MulticoreFuture’ ... done
[16:18:41.210] Created future:
[16:18:41.210] plan(): Setting new future strategy stack:
[16:18:41.210] List of future strategies:
[16:18:41.210] 1. sequential:
[16:18:41.210]    - args: function (..., envir = parent.frame())
[16:18:41.210]    - tweaked: FALSE
[16:18:41.210]    - call: NULL
[16:18:41.211] plan(): nbrOfWorkers() = 1
[16:18:41.214] plan(): Setting new future strategy stack:
[16:18:41.214] List of future strategies:
[16:18:41.214] 1. multicore:
[16:18:41.214]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.214]    - tweaked: FALSE
[16:18:41.214]    - call: plan(strategy)
[16:18:41.219] plan(): nbrOfWorkers() = 2
[16:18:41.210] MulticoreFuture:
[16:18:41.210] Label: ‘future_mapply-2’
[16:18:41.210] Expression:
[16:18:41.210] {
[16:18:41.210]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.210]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.210]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.210]         on.exit(options(oopts), add = TRUE)
[16:18:41.210]     }
[16:18:41.210]     {
[16:18:41.210]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.210]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.210]         do.call(mapply, args = args)
[16:18:41.210]     }
[16:18:41.210] }
[16:18:41.210] Lazy evaluation: FALSE
[16:18:41.210] Asynchronous evaluation: TRUE
[16:18:41.210] Local evaluation: TRUE
[16:18:41.210] Environment: R_GlobalEnv
[16:18:41.210] Capture standard output: TRUE
[16:18:41.210] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.210] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.210] Packages: <none>
[16:18:41.210] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.210] Resolved: TRUE
[16:18:41.210] Value: <not collected>
[16:18:41.210] Conditions captured: <none>
[16:18:41.210] Early signaling: FALSE
[16:18:41.210] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.210] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.221] Chunk #2 of 2 ... DONE
[16:18:41.221] Launching 2 futures (chunks) ... DONE
[16:18:41.221] Resolving 2 futures (chunks) ...
[16:18:41.221] resolve() on list ...
[16:18:41.221]  recursive: 0
[16:18:41.221]  length: 2
[16:18:41.222] 
[16:18:41.222] Future #1
[16:18:41.222] result() for MulticoreFuture ...
[16:18:41.223] result() for MulticoreFuture ...
[16:18:41.223] result() for MulticoreFuture ... done
[16:18:41.223] result() for MulticoreFuture ... done
[16:18:41.223] result() for MulticoreFuture ...
[16:18:41.224] result() for MulticoreFuture ... done
[16:18:41.224] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:41.224] - nx: 2
[16:18:41.224] - relay: TRUE
[16:18:41.224] - stdout: TRUE
[16:18:41.224] - signal: TRUE
[16:18:41.225] - resignal: FALSE
[16:18:41.225] - force: TRUE
[16:18:41.225] - relayed: [n=2] FALSE, FALSE
[16:18:41.225] - queued futures: [n=2] FALSE, FALSE
[16:18:41.225]  - until=1
[16:18:41.225]  - relaying element #1
[16:18:41.225] result() for MulticoreFuture ...
[16:18:41.226] result() for MulticoreFuture ... done
[16:18:41.226] result() for MulticoreFuture ...
[16:18:41.226] result() for MulticoreFuture ... done
[16:18:41.226] result() for MulticoreFuture ...
[16:18:41.226] result() for MulticoreFuture ... done
[16:18:41.226] result() for MulticoreFuture ...
[16:18:41.226] result() for MulticoreFuture ... done
[16:18:41.227] - relayed: [n=2] TRUE, FALSE
[16:18:41.227] - queued futures: [n=2] TRUE, FALSE
[16:18:41.227] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:41.227]  length: 1 (resolved future 1)
[16:18:41.227] Future #2
[16:18:41.228] result() for MulticoreFuture ...
[16:18:41.228] result() for MulticoreFuture ...
[16:18:41.228] result() for MulticoreFuture ... done
[16:18:41.229] result() for MulticoreFuture ... done
[16:18:41.229] result() for MulticoreFuture ...
[16:18:41.229] result() for MulticoreFuture ... done
[16:18:41.229] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:41.229] - nx: 2
[16:18:41.229] - relay: TRUE
[16:18:41.230] - stdout: TRUE
[16:18:41.230] - signal: TRUE
[16:18:41.230] - resignal: FALSE
[16:18:41.230] - force: TRUE
[16:18:41.230] - relayed: [n=2] TRUE, FALSE
[16:18:41.230] - queued futures: [n=2] TRUE, FALSE
[16:18:41.230]  - until=2
[16:18:41.230]  - relaying element #2
[16:18:41.230] result() for MulticoreFuture ...
[16:18:41.231] result() for MulticoreFuture ... done
[16:18:41.231] result() for MulticoreFuture ...
[16:18:41.231] result() for MulticoreFuture ... done
[16:18:41.231] result() for MulticoreFuture ...
[16:18:41.231] result() for MulticoreFuture ... done
[16:18:41.231] result() for MulticoreFuture ...
[16:18:41.231] result() for MulticoreFuture ... done
[16:18:41.231] - relayed: [n=2] TRUE, TRUE
[16:18:41.232] - queued futures: [n=2] TRUE, TRUE
[16:18:41.232] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:41.232]  length: 0 (resolved future 2)
[16:18:41.232] Relaying remaining futures
[16:18:41.232] signalConditionsASAP(NULL, pos=0) ...
[16:18:41.232] - nx: 2
[16:18:41.232] - relay: TRUE
[16:18:41.232] - stdout: TRUE
[16:18:41.233] - signal: TRUE
[16:18:41.233] - resignal: FALSE
[16:18:41.233] - force: TRUE
[16:18:41.233] - relayed: [n=2] TRUE, TRUE
[16:18:41.233] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:41.233] - relayed: [n=2] TRUE, TRUE
[16:18:41.233] - queued futures: [n=2] TRUE, TRUE
[16:18:41.233] signalConditionsASAP(NULL, pos=0) ... done
[16:18:41.234] resolve() on list ... DONE
[16:18:41.234] result() for MulticoreFuture ...
[16:18:41.234] result() for MulticoreFuture ... done
[16:18:41.234] result() for MulticoreFuture ...
[16:18:41.234] result() for MulticoreFuture ... done
[16:18:41.234] result() for MulticoreFuture ...
[16:18:41.234] result() for MulticoreFuture ... done
[16:18:41.234] result() for MulticoreFuture ...
[16:18:41.234] result() for MulticoreFuture ... done
[16:18:41.235]  - Number of value chunks collected: 2
[16:18:41.235] Resolving 2 futures (chunks) ... DONE
[16:18:41.235] Reducing values from 2 chunks ...
[16:18:41.235]  - Number of values collected after concatenation: 4
[16:18:41.235]  - Number of values expected: 4
[16:18:41.235] Reducing values from 2 chunks ... DONE
[16:18:41.235] future_mapply() ... DONE
[16:18:41.236] future_mapply() ...
[16:18:41.240] Number of chunks: 2
[16:18:41.240] getGlobalsAndPackagesXApply() ...
[16:18:41.240]  - future.globals: TRUE
[16:18:41.240] getGlobalsAndPackages() ...
[16:18:41.240] Searching for globals...
[16:18:41.244] - globals found: [1] ‘FUN’
[16:18:41.244] Searching for globals ... DONE
[16:18:41.244] Resolving globals: FALSE
[16:18:41.245] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:41.245] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:41.245] - globals: [1] ‘FUN’
[16:18:41.246] 
[16:18:41.246] getGlobalsAndPackages() ... DONE
[16:18:41.246]  - globals found/used: [n=1] ‘FUN’
[16:18:41.246]  - needed namespaces: [n=0] 
[16:18:41.246] Finding globals ... DONE
[16:18:41.247] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:41.247] List of 2
[16:18:41.247]  $ ...future.FUN:function (x, ...)  
[16:18:41.247]  $ MoreArgs     :List of 1
[16:18:41.247]   ..$ x: num 42
[16:18:41.247]  - attr(*, "where")=List of 2
[16:18:41.247]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:41.247]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:41.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.247]  - attr(*, "resolved")= logi FALSE
[16:18:41.247]  - attr(*, "total_size")= num NA
[16:18:41.250] Packages to be attached in all futures: [n=0] 
[16:18:41.251] getGlobalsAndPackagesXApply() ... DONE
[16:18:41.251] Number of futures (= number of chunks): 2
[16:18:41.251] Launching 2 futures (chunks) ...
[16:18:41.251] Chunk #1 of 2 ...
[16:18:41.251]  - Finding globals in '...' for chunk #1 ...
[16:18:41.251] getGlobalsAndPackages() ...
[16:18:41.251] Searching for globals...
[16:18:41.252] 
[16:18:41.252] Searching for globals ... DONE
[16:18:41.252] - globals: [0] <none>
[16:18:41.252] getGlobalsAndPackages() ... DONE
[16:18:41.252]    + additional globals found: [n=0] 
[16:18:41.252]    + additional namespaces needed: [n=0] 
[16:18:41.252]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:41.252]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.252]  - seeds: <none>
[16:18:41.253]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.253] getGlobalsAndPackages() ...
[16:18:41.253] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.253] Resolving globals: FALSE
[16:18:41.253] The total size of the 5 globals is 224 bytes (224 bytes)
[16:18:41.254] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[16:18:41.254] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.254] 
[16:18:41.254] getGlobalsAndPackages() ... DONE
[16:18:41.255] run() for ‘Future’ ...
[16:18:41.255] - state: ‘created’
[16:18:41.255] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.258] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.258] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.259]   - Field: ‘label’
[16:18:41.259]   - Field: ‘local’
[16:18:41.259]   - Field: ‘owner’
[16:18:41.259]   - Field: ‘envir’
[16:18:41.259]   - Field: ‘workers’
[16:18:41.259]   - Field: ‘packages’
[16:18:41.259]   - Field: ‘gc’
[16:18:41.259]   - Field: ‘job’
[16:18:41.259]   - Field: ‘conditions’
[16:18:41.259]   - Field: ‘expr’
[16:18:41.260]   - Field: ‘uuid’
[16:18:41.260]   - Field: ‘seed’
[16:18:41.260]   - Field: ‘version’
[16:18:41.260]   - Field: ‘result’
[16:18:41.260]   - Field: ‘asynchronous’
[16:18:41.260]   - Field: ‘calls’
[16:18:41.260]   - Field: ‘globals’
[16:18:41.260]   - Field: ‘stdout’
[16:18:41.260]   - Field: ‘earlySignal’
[16:18:41.260]   - Field: ‘lazy’
[16:18:41.261]   - Field: ‘state’
[16:18:41.261] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.261] - Launch lazy future ...
[16:18:41.261] Packages needed by the future expression (n = 0): <none>
[16:18:41.261] Packages needed by future strategies (n = 0): <none>
[16:18:41.262] {
[16:18:41.262]     {
[16:18:41.262]         {
[16:18:41.262]             ...future.startTime <- base::Sys.time()
[16:18:41.262]             {
[16:18:41.262]                 {
[16:18:41.262]                   {
[16:18:41.262]                     {
[16:18:41.262]                       base::local({
[16:18:41.262]                         has_future <- base::requireNamespace("future", 
[16:18:41.262]                           quietly = TRUE)
[16:18:41.262]                         if (has_future) {
[16:18:41.262]                           ns <- base::getNamespace("future")
[16:18:41.262]                           version <- ns[[".package"]][["version"]]
[16:18:41.262]                           if (is.null(version)) 
[16:18:41.262]                             version <- utils::packageVersion("future")
[16:18:41.262]                         }
[16:18:41.262]                         else {
[16:18:41.262]                           version <- NULL
[16:18:41.262]                         }
[16:18:41.262]                         if (!has_future || version < "1.8.0") {
[16:18:41.262]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.262]                             "", base::R.version$version.string), 
[16:18:41.262]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.262]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.262]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.262]                               "release", "version")], collapse = " "), 
[16:18:41.262]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.262]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.262]                             info)
[16:18:41.262]                           info <- base::paste(info, collapse = "; ")
[16:18:41.262]                           if (!has_future) {
[16:18:41.262]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.262]                               info)
[16:18:41.262]                           }
[16:18:41.262]                           else {
[16:18:41.262]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.262]                               info, version)
[16:18:41.262]                           }
[16:18:41.262]                           base::stop(msg)
[16:18:41.262]                         }
[16:18:41.262]                       })
[16:18:41.262]                     }
[16:18:41.262]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.262]                     base::options(mc.cores = 1L)
[16:18:41.262]                   }
[16:18:41.262]                   ...future.strategy.old <- future::plan("list")
[16:18:41.262]                   options(future.plan = NULL)
[16:18:41.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.262]                 }
[16:18:41.262]                 ...future.workdir <- getwd()
[16:18:41.262]             }
[16:18:41.262]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.262]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.262]         }
[16:18:41.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.262]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.262]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.262]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.262]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.262]             base::names(...future.oldOptions))
[16:18:41.262]     }
[16:18:41.262]     if (FALSE) {
[16:18:41.262]     }
[16:18:41.262]     else {
[16:18:41.262]         if (TRUE) {
[16:18:41.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.262]                 open = "w")
[16:18:41.262]         }
[16:18:41.262]         else {
[16:18:41.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.262]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.262]         }
[16:18:41.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.262]             base::sink(type = "output", split = FALSE)
[16:18:41.262]             base::close(...future.stdout)
[16:18:41.262]         }, add = TRUE)
[16:18:41.262]     }
[16:18:41.262]     ...future.frame <- base::sys.nframe()
[16:18:41.262]     ...future.conditions <- base::list()
[16:18:41.262]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.262]     if (FALSE) {
[16:18:41.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.262]     }
[16:18:41.262]     ...future.result <- base::tryCatch({
[16:18:41.262]         base::withCallingHandlers({
[16:18:41.262]             ...future.value <- base::withVisible(base::local({
[16:18:41.262]                 withCallingHandlers({
[16:18:41.262]                   {
[16:18:41.262]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.262]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.262]                       ...future.globals.maxSize)) {
[16:18:41.262]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.262]                       on.exit(options(oopts), add = TRUE)
[16:18:41.262]                     }
[16:18:41.262]                     {
[16:18:41.262]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.262]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.262]                         USE.NAMES = FALSE)
[16:18:41.262]                       do.call(mapply, args = args)
[16:18:41.262]                     }
[16:18:41.262]                   }
[16:18:41.262]                 }, immediateCondition = function(cond) {
[16:18:41.262]                   save_rds <- function (object, pathname, ...) 
[16:18:41.262]                   {
[16:18:41.262]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.262]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.262]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.262]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.262]                         fi_tmp[["mtime"]])
[16:18:41.262]                     }
[16:18:41.262]                     tryCatch({
[16:18:41.262]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.262]                     }, error = function(ex) {
[16:18:41.262]                       msg <- conditionMessage(ex)
[16:18:41.262]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.262]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.262]                         fi_tmp[["mtime"]], msg)
[16:18:41.262]                       ex$message <- msg
[16:18:41.262]                       stop(ex)
[16:18:41.262]                     })
[16:18:41.262]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.262]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.262]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.262]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.262]                       fi <- file.info(pathname)
[16:18:41.262]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.262]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.262]                         fi[["size"]], fi[["mtime"]])
[16:18:41.262]                       stop(msg)
[16:18:41.262]                     }
[16:18:41.262]                     invisible(pathname)
[16:18:41.262]                   }
[16:18:41.262]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.262]                     rootPath = tempdir()) 
[16:18:41.262]                   {
[16:18:41.262]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.262]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.262]                       tmpdir = path, fileext = ".rds")
[16:18:41.262]                     save_rds(obj, file)
[16:18:41.262]                   }
[16:18:41.262]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.262]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.262]                   {
[16:18:41.262]                     inherits <- base::inherits
[16:18:41.262]                     invokeRestart <- base::invokeRestart
[16:18:41.262]                     is.null <- base::is.null
[16:18:41.262]                     muffled <- FALSE
[16:18:41.262]                     if (inherits(cond, "message")) {
[16:18:41.262]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.262]                       if (muffled) 
[16:18:41.262]                         invokeRestart("muffleMessage")
[16:18:41.262]                     }
[16:18:41.262]                     else if (inherits(cond, "warning")) {
[16:18:41.262]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.262]                       if (muffled) 
[16:18:41.262]                         invokeRestart("muffleWarning")
[16:18:41.262]                     }
[16:18:41.262]                     else if (inherits(cond, "condition")) {
[16:18:41.262]                       if (!is.null(pattern)) {
[16:18:41.262]                         computeRestarts <- base::computeRestarts
[16:18:41.262]                         grepl <- base::grepl
[16:18:41.262]                         restarts <- computeRestarts(cond)
[16:18:41.262]                         for (restart in restarts) {
[16:18:41.262]                           name <- restart$name
[16:18:41.262]                           if (is.null(name)) 
[16:18:41.262]                             next
[16:18:41.262]                           if (!grepl(pattern, name)) 
[16:18:41.262]                             next
[16:18:41.262]                           invokeRestart(restart)
[16:18:41.262]                           muffled <- TRUE
[16:18:41.262]                           break
[16:18:41.262]                         }
[16:18:41.262]                       }
[16:18:41.262]                     }
[16:18:41.262]                     invisible(muffled)
[16:18:41.262]                   }
[16:18:41.262]                   muffleCondition(cond)
[16:18:41.262]                 })
[16:18:41.262]             }))
[16:18:41.262]             future::FutureResult(value = ...future.value$value, 
[16:18:41.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.262]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.262]                     ...future.globalenv.names))
[16:18:41.262]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.262]         }, condition = base::local({
[16:18:41.262]             c <- base::c
[16:18:41.262]             inherits <- base::inherits
[16:18:41.262]             invokeRestart <- base::invokeRestart
[16:18:41.262]             length <- base::length
[16:18:41.262]             list <- base::list
[16:18:41.262]             seq.int <- base::seq.int
[16:18:41.262]             signalCondition <- base::signalCondition
[16:18:41.262]             sys.calls <- base::sys.calls
[16:18:41.262]             `[[` <- base::`[[`
[16:18:41.262]             `+` <- base::`+`
[16:18:41.262]             `<<-` <- base::`<<-`
[16:18:41.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.262]                   3L)]
[16:18:41.262]             }
[16:18:41.262]             function(cond) {
[16:18:41.262]                 is_error <- inherits(cond, "error")
[16:18:41.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.262]                   NULL)
[16:18:41.262]                 if (is_error) {
[16:18:41.262]                   sessionInformation <- function() {
[16:18:41.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.262]                       search = base::search(), system = base::Sys.info())
[16:18:41.262]                   }
[16:18:41.262]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.262]                     cond$call), session = sessionInformation(), 
[16:18:41.262]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.262]                   signalCondition(cond)
[16:18:41.262]                 }
[16:18:41.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.262]                 "immediateCondition"))) {
[16:18:41.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.262]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.262]                   if (TRUE && !signal) {
[16:18:41.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.262]                     {
[16:18:41.262]                       inherits <- base::inherits
[16:18:41.262]                       invokeRestart <- base::invokeRestart
[16:18:41.262]                       is.null <- base::is.null
[16:18:41.262]                       muffled <- FALSE
[16:18:41.262]                       if (inherits(cond, "message")) {
[16:18:41.262]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.262]                         if (muffled) 
[16:18:41.262]                           invokeRestart("muffleMessage")
[16:18:41.262]                       }
[16:18:41.262]                       else if (inherits(cond, "warning")) {
[16:18:41.262]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.262]                         if (muffled) 
[16:18:41.262]                           invokeRestart("muffleWarning")
[16:18:41.262]                       }
[16:18:41.262]                       else if (inherits(cond, "condition")) {
[16:18:41.262]                         if (!is.null(pattern)) {
[16:18:41.262]                           computeRestarts <- base::computeRestarts
[16:18:41.262]                           grepl <- base::grepl
[16:18:41.262]                           restarts <- computeRestarts(cond)
[16:18:41.262]                           for (restart in restarts) {
[16:18:41.262]                             name <- restart$name
[16:18:41.262]                             if (is.null(name)) 
[16:18:41.262]                               next
[16:18:41.262]                             if (!grepl(pattern, name)) 
[16:18:41.262]                               next
[16:18:41.262]                             invokeRestart(restart)
[16:18:41.262]                             muffled <- TRUE
[16:18:41.262]                             break
[16:18:41.262]                           }
[16:18:41.262]                         }
[16:18:41.262]                       }
[16:18:41.262]                       invisible(muffled)
[16:18:41.262]                     }
[16:18:41.262]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.262]                   }
[16:18:41.262]                 }
[16:18:41.262]                 else {
[16:18:41.262]                   if (TRUE) {
[16:18:41.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.262]                     {
[16:18:41.262]                       inherits <- base::inherits
[16:18:41.262]                       invokeRestart <- base::invokeRestart
[16:18:41.262]                       is.null <- base::is.null
[16:18:41.262]                       muffled <- FALSE
[16:18:41.262]                       if (inherits(cond, "message")) {
[16:18:41.262]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.262]                         if (muffled) 
[16:18:41.262]                           invokeRestart("muffleMessage")
[16:18:41.262]                       }
[16:18:41.262]                       else if (inherits(cond, "warning")) {
[16:18:41.262]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.262]                         if (muffled) 
[16:18:41.262]                           invokeRestart("muffleWarning")
[16:18:41.262]                       }
[16:18:41.262]                       else if (inherits(cond, "condition")) {
[16:18:41.262]                         if (!is.null(pattern)) {
[16:18:41.262]                           computeRestarts <- base::computeRestarts
[16:18:41.262]                           grepl <- base::grepl
[16:18:41.262]                           restarts <- computeRestarts(cond)
[16:18:41.262]                           for (restart in restarts) {
[16:18:41.262]                             name <- restart$name
[16:18:41.262]                             if (is.null(name)) 
[16:18:41.262]                               next
[16:18:41.262]                             if (!grepl(pattern, name)) 
[16:18:41.262]                               next
[16:18:41.262]                             invokeRestart(restart)
[16:18:41.262]                             muffled <- TRUE
[16:18:41.262]                             break
[16:18:41.262]                           }
[16:18:41.262]                         }
[16:18:41.262]                       }
[16:18:41.262]                       invisible(muffled)
[16:18:41.262]                     }
[16:18:41.262]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.262]                   }
[16:18:41.262]                 }
[16:18:41.262]             }
[16:18:41.262]         }))
[16:18:41.262]     }, error = function(ex) {
[16:18:41.262]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.262]                 ...future.rng), started = ...future.startTime, 
[16:18:41.262]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.262]             version = "1.8"), class = "FutureResult")
[16:18:41.262]     }, finally = {
[16:18:41.262]         if (!identical(...future.workdir, getwd())) 
[16:18:41.262]             setwd(...future.workdir)
[16:18:41.262]         {
[16:18:41.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.262]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.262]             }
[16:18:41.262]             base::options(...future.oldOptions)
[16:18:41.262]             if (.Platform$OS.type == "windows") {
[16:18:41.262]                 old_names <- names(...future.oldEnvVars)
[16:18:41.262]                 envs <- base::Sys.getenv()
[16:18:41.262]                 names <- names(envs)
[16:18:41.262]                 common <- intersect(names, old_names)
[16:18:41.262]                 added <- setdiff(names, old_names)
[16:18:41.262]                 removed <- setdiff(old_names, names)
[16:18:41.262]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.262]                   envs[common]]
[16:18:41.262]                 NAMES <- toupper(changed)
[16:18:41.262]                 args <- list()
[16:18:41.262]                 for (kk in seq_along(NAMES)) {
[16:18:41.262]                   name <- changed[[kk]]
[16:18:41.262]                   NAME <- NAMES[[kk]]
[16:18:41.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.262]                     next
[16:18:41.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.262]                 }
[16:18:41.262]                 NAMES <- toupper(added)
[16:18:41.262]                 for (kk in seq_along(NAMES)) {
[16:18:41.262]                   name <- added[[kk]]
[16:18:41.262]                   NAME <- NAMES[[kk]]
[16:18:41.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.262]                     next
[16:18:41.262]                   args[[name]] <- ""
[16:18:41.262]                 }
[16:18:41.262]                 NAMES <- toupper(removed)
[16:18:41.262]                 for (kk in seq_along(NAMES)) {
[16:18:41.262]                   name <- removed[[kk]]
[16:18:41.262]                   NAME <- NAMES[[kk]]
[16:18:41.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.262]                     next
[16:18:41.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.262]                 }
[16:18:41.262]                 if (length(args) > 0) 
[16:18:41.262]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.262]             }
[16:18:41.262]             else {
[16:18:41.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.262]             }
[16:18:41.262]             {
[16:18:41.262]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.262]                   0L) {
[16:18:41.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.262]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.262]                   base::options(opts)
[16:18:41.262]                 }
[16:18:41.262]                 {
[16:18:41.262]                   {
[16:18:41.262]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.262]                     NULL
[16:18:41.262]                   }
[16:18:41.262]                   options(future.plan = NULL)
[16:18:41.262]                   if (is.na(NA_character_)) 
[16:18:41.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.262]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.262]                     .init = FALSE)
[16:18:41.262]                 }
[16:18:41.262]             }
[16:18:41.262]         }
[16:18:41.262]     })
[16:18:41.262]     if (TRUE) {
[16:18:41.262]         base::sink(type = "output", split = FALSE)
[16:18:41.262]         if (TRUE) {
[16:18:41.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.262]         }
[16:18:41.262]         else {
[16:18:41.262]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.262]         }
[16:18:41.262]         base::close(...future.stdout)
[16:18:41.262]         ...future.stdout <- NULL
[16:18:41.262]     }
[16:18:41.262]     ...future.result$conditions <- ...future.conditions
[16:18:41.262]     ...future.result$finished <- base::Sys.time()
[16:18:41.262]     ...future.result
[16:18:41.262] }
[16:18:41.264] assign_globals() ...
[16:18:41.264] List of 5
[16:18:41.264]  $ ...future.FUN            :function (x, ...)  
[16:18:41.264]  $ MoreArgs                 :List of 1
[16:18:41.264]   ..$ x: num 42
[16:18:41.264]  $ ...future.elements_ii    :List of 1
[16:18:41.264]   ..$ times:List of 2
[16:18:41.264]   .. ..$ : int 1
[16:18:41.264]   .. ..$ : int 2
[16:18:41.264]  $ ...future.seeds_ii       : NULL
[16:18:41.264]  $ ...future.globals.maxSize: NULL
[16:18:41.264]  - attr(*, "where")=List of 5
[16:18:41.264]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.264]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.264]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.264]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.264]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.264]  - attr(*, "resolved")= logi FALSE
[16:18:41.264]  - attr(*, "total_size")= num 224
[16:18:41.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.264]  - attr(*, "already-done")= logi TRUE
[16:18:41.272] - copied ‘...future.FUN’ to environment
[16:18:41.272] - copied ‘MoreArgs’ to environment
[16:18:41.272] - copied ‘...future.elements_ii’ to environment
[16:18:41.272] - copied ‘...future.seeds_ii’ to environment
[16:18:41.272] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.272] assign_globals() ... done
[16:18:41.273] requestCore(): workers = 2
[16:18:41.275] MulticoreFuture started
[16:18:41.275] - Launch lazy future ... done
[16:18:41.276] run() for ‘MulticoreFuture’ ... done
[16:18:41.276] plan(): Setting new future strategy stack:
[16:18:41.276] Created future:
[16:18:41.276] List of future strategies:
[16:18:41.276] 1. sequential:
[16:18:41.276]    - args: function (..., envir = parent.frame())
[16:18:41.276]    - tweaked: FALSE
[16:18:41.276]    - call: NULL
[16:18:41.278] plan(): nbrOfWorkers() = 1
[16:18:41.280] plan(): Setting new future strategy stack:
[16:18:41.280] List of future strategies:
[16:18:41.280] 1. multicore:
[16:18:41.280]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.280]    - tweaked: FALSE
[16:18:41.280]    - call: plan(strategy)
[16:18:41.287] plan(): nbrOfWorkers() = 2
[16:18:41.277] MulticoreFuture:
[16:18:41.277] Label: ‘future_mapply-1’
[16:18:41.277] Expression:
[16:18:41.277] {
[16:18:41.277]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.277]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.277]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.277]         on.exit(options(oopts), add = TRUE)
[16:18:41.277]     }
[16:18:41.277]     {
[16:18:41.277]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.277]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.277]         do.call(mapply, args = args)
[16:18:41.277]     }
[16:18:41.277] }
[16:18:41.277] Lazy evaluation: FALSE
[16:18:41.277] Asynchronous evaluation: TRUE
[16:18:41.277] Local evaluation: TRUE
[16:18:41.277] Environment: R_GlobalEnv
[16:18:41.277] Capture standard output: TRUE
[16:18:41.277] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.277] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.277] Packages: <none>
[16:18:41.277] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.277] Resolved: TRUE
[16:18:41.277] Value: <not collected>
[16:18:41.277] Conditions captured: <none>
[16:18:41.277] Early signaling: FALSE
[16:18:41.277] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.277] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.288] Chunk #1 of 2 ... DONE
[16:18:41.288] Chunk #2 of 2 ...
[16:18:41.288]  - Finding globals in '...' for chunk #2 ...
[16:18:41.289] getGlobalsAndPackages() ...
[16:18:41.289] Searching for globals...
[16:18:41.289] 
[16:18:41.290] Searching for globals ... DONE
[16:18:41.290] - globals: [0] <none>
[16:18:41.290] getGlobalsAndPackages() ... DONE
[16:18:41.290]    + additional globals found: [n=0] 
[16:18:41.290]    + additional namespaces needed: [n=0] 
[16:18:41.290]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:41.290]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.290]  - seeds: <none>
[16:18:41.291]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.291] getGlobalsAndPackages() ...
[16:18:41.291] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.291] Resolving globals: FALSE
[16:18:41.293] The total size of the 5 globals is 224 bytes (224 bytes)
[16:18:41.293] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[16:18:41.294] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.294] 
[16:18:41.294] getGlobalsAndPackages() ... DONE
[16:18:41.295] run() for ‘Future’ ...
[16:18:41.295] - state: ‘created’
[16:18:41.295] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.299] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.300] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.300]   - Field: ‘label’
[16:18:41.300]   - Field: ‘local’
[16:18:41.300]   - Field: ‘owner’
[16:18:41.300]   - Field: ‘envir’
[16:18:41.300]   - Field: ‘workers’
[16:18:41.301]   - Field: ‘packages’
[16:18:41.301]   - Field: ‘gc’
[16:18:41.301]   - Field: ‘job’
[16:18:41.301]   - Field: ‘conditions’
[16:18:41.301]   - Field: ‘expr’
[16:18:41.301]   - Field: ‘uuid’
[16:18:41.301]   - Field: ‘seed’
[16:18:41.301]   - Field: ‘version’
[16:18:41.302]   - Field: ‘result’
[16:18:41.302]   - Field: ‘asynchronous’
[16:18:41.302]   - Field: ‘calls’
[16:18:41.302]   - Field: ‘globals’
[16:18:41.302]   - Field: ‘stdout’
[16:18:41.302]   - Field: ‘earlySignal’
[16:18:41.302]   - Field: ‘lazy’
[16:18:41.303]   - Field: ‘state’
[16:18:41.303] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.303] - Launch lazy future ...
[16:18:41.303] Packages needed by the future expression (n = 0): <none>
[16:18:41.303] Packages needed by future strategies (n = 0): <none>
[16:18:41.304] {
[16:18:41.304]     {
[16:18:41.304]         {
[16:18:41.304]             ...future.startTime <- base::Sys.time()
[16:18:41.304]             {
[16:18:41.304]                 {
[16:18:41.304]                   {
[16:18:41.304]                     {
[16:18:41.304]                       base::local({
[16:18:41.304]                         has_future <- base::requireNamespace("future", 
[16:18:41.304]                           quietly = TRUE)
[16:18:41.304]                         if (has_future) {
[16:18:41.304]                           ns <- base::getNamespace("future")
[16:18:41.304]                           version <- ns[[".package"]][["version"]]
[16:18:41.304]                           if (is.null(version)) 
[16:18:41.304]                             version <- utils::packageVersion("future")
[16:18:41.304]                         }
[16:18:41.304]                         else {
[16:18:41.304]                           version <- NULL
[16:18:41.304]                         }
[16:18:41.304]                         if (!has_future || version < "1.8.0") {
[16:18:41.304]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.304]                             "", base::R.version$version.string), 
[16:18:41.304]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.304]                               "release", "version")], collapse = " "), 
[16:18:41.304]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.304]                             info)
[16:18:41.304]                           info <- base::paste(info, collapse = "; ")
[16:18:41.304]                           if (!has_future) {
[16:18:41.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.304]                               info)
[16:18:41.304]                           }
[16:18:41.304]                           else {
[16:18:41.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.304]                               info, version)
[16:18:41.304]                           }
[16:18:41.304]                           base::stop(msg)
[16:18:41.304]                         }
[16:18:41.304]                       })
[16:18:41.304]                     }
[16:18:41.304]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.304]                     base::options(mc.cores = 1L)
[16:18:41.304]                   }
[16:18:41.304]                   ...future.strategy.old <- future::plan("list")
[16:18:41.304]                   options(future.plan = NULL)
[16:18:41.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.304]                 }
[16:18:41.304]                 ...future.workdir <- getwd()
[16:18:41.304]             }
[16:18:41.304]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.304]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.304]         }
[16:18:41.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.304]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.304]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.304]             base::names(...future.oldOptions))
[16:18:41.304]     }
[16:18:41.304]     if (FALSE) {
[16:18:41.304]     }
[16:18:41.304]     else {
[16:18:41.304]         if (TRUE) {
[16:18:41.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.304]                 open = "w")
[16:18:41.304]         }
[16:18:41.304]         else {
[16:18:41.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.304]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.304]         }
[16:18:41.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.304]             base::sink(type = "output", split = FALSE)
[16:18:41.304]             base::close(...future.stdout)
[16:18:41.304]         }, add = TRUE)
[16:18:41.304]     }
[16:18:41.304]     ...future.frame <- base::sys.nframe()
[16:18:41.304]     ...future.conditions <- base::list()
[16:18:41.304]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.304]     if (FALSE) {
[16:18:41.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.304]     }
[16:18:41.304]     ...future.result <- base::tryCatch({
[16:18:41.304]         base::withCallingHandlers({
[16:18:41.304]             ...future.value <- base::withVisible(base::local({
[16:18:41.304]                 withCallingHandlers({
[16:18:41.304]                   {
[16:18:41.304]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.304]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.304]                       ...future.globals.maxSize)) {
[16:18:41.304]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.304]                       on.exit(options(oopts), add = TRUE)
[16:18:41.304]                     }
[16:18:41.304]                     {
[16:18:41.304]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.304]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.304]                         USE.NAMES = FALSE)
[16:18:41.304]                       do.call(mapply, args = args)
[16:18:41.304]                     }
[16:18:41.304]                   }
[16:18:41.304]                 }, immediateCondition = function(cond) {
[16:18:41.304]                   save_rds <- function (object, pathname, ...) 
[16:18:41.304]                   {
[16:18:41.304]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.304]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.304]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.304]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.304]                         fi_tmp[["mtime"]])
[16:18:41.304]                     }
[16:18:41.304]                     tryCatch({
[16:18:41.304]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.304]                     }, error = function(ex) {
[16:18:41.304]                       msg <- conditionMessage(ex)
[16:18:41.304]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.304]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.304]                         fi_tmp[["mtime"]], msg)
[16:18:41.304]                       ex$message <- msg
[16:18:41.304]                       stop(ex)
[16:18:41.304]                     })
[16:18:41.304]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.304]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.304]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.304]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.304]                       fi <- file.info(pathname)
[16:18:41.304]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.304]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.304]                         fi[["size"]], fi[["mtime"]])
[16:18:41.304]                       stop(msg)
[16:18:41.304]                     }
[16:18:41.304]                     invisible(pathname)
[16:18:41.304]                   }
[16:18:41.304]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.304]                     rootPath = tempdir()) 
[16:18:41.304]                   {
[16:18:41.304]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.304]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.304]                       tmpdir = path, fileext = ".rds")
[16:18:41.304]                     save_rds(obj, file)
[16:18:41.304]                   }
[16:18:41.304]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.304]                   {
[16:18:41.304]                     inherits <- base::inherits
[16:18:41.304]                     invokeRestart <- base::invokeRestart
[16:18:41.304]                     is.null <- base::is.null
[16:18:41.304]                     muffled <- FALSE
[16:18:41.304]                     if (inherits(cond, "message")) {
[16:18:41.304]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.304]                       if (muffled) 
[16:18:41.304]                         invokeRestart("muffleMessage")
[16:18:41.304]                     }
[16:18:41.304]                     else if (inherits(cond, "warning")) {
[16:18:41.304]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.304]                       if (muffled) 
[16:18:41.304]                         invokeRestart("muffleWarning")
[16:18:41.304]                     }
[16:18:41.304]                     else if (inherits(cond, "condition")) {
[16:18:41.304]                       if (!is.null(pattern)) {
[16:18:41.304]                         computeRestarts <- base::computeRestarts
[16:18:41.304]                         grepl <- base::grepl
[16:18:41.304]                         restarts <- computeRestarts(cond)
[16:18:41.304]                         for (restart in restarts) {
[16:18:41.304]                           name <- restart$name
[16:18:41.304]                           if (is.null(name)) 
[16:18:41.304]                             next
[16:18:41.304]                           if (!grepl(pattern, name)) 
[16:18:41.304]                             next
[16:18:41.304]                           invokeRestart(restart)
[16:18:41.304]                           muffled <- TRUE
[16:18:41.304]                           break
[16:18:41.304]                         }
[16:18:41.304]                       }
[16:18:41.304]                     }
[16:18:41.304]                     invisible(muffled)
[16:18:41.304]                   }
[16:18:41.304]                   muffleCondition(cond)
[16:18:41.304]                 })
[16:18:41.304]             }))
[16:18:41.304]             future::FutureResult(value = ...future.value$value, 
[16:18:41.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.304]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.304]                     ...future.globalenv.names))
[16:18:41.304]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.304]         }, condition = base::local({
[16:18:41.304]             c <- base::c
[16:18:41.304]             inherits <- base::inherits
[16:18:41.304]             invokeRestart <- base::invokeRestart
[16:18:41.304]             length <- base::length
[16:18:41.304]             list <- base::list
[16:18:41.304]             seq.int <- base::seq.int
[16:18:41.304]             signalCondition <- base::signalCondition
[16:18:41.304]             sys.calls <- base::sys.calls
[16:18:41.304]             `[[` <- base::`[[`
[16:18:41.304]             `+` <- base::`+`
[16:18:41.304]             `<<-` <- base::`<<-`
[16:18:41.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.304]                   3L)]
[16:18:41.304]             }
[16:18:41.304]             function(cond) {
[16:18:41.304]                 is_error <- inherits(cond, "error")
[16:18:41.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.304]                   NULL)
[16:18:41.304]                 if (is_error) {
[16:18:41.304]                   sessionInformation <- function() {
[16:18:41.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.304]                       search = base::search(), system = base::Sys.info())
[16:18:41.304]                   }
[16:18:41.304]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.304]                     cond$call), session = sessionInformation(), 
[16:18:41.304]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.304]                   signalCondition(cond)
[16:18:41.304]                 }
[16:18:41.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.304]                 "immediateCondition"))) {
[16:18:41.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.304]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.304]                   if (TRUE && !signal) {
[16:18:41.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.304]                     {
[16:18:41.304]                       inherits <- base::inherits
[16:18:41.304]                       invokeRestart <- base::invokeRestart
[16:18:41.304]                       is.null <- base::is.null
[16:18:41.304]                       muffled <- FALSE
[16:18:41.304]                       if (inherits(cond, "message")) {
[16:18:41.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.304]                         if (muffled) 
[16:18:41.304]                           invokeRestart("muffleMessage")
[16:18:41.304]                       }
[16:18:41.304]                       else if (inherits(cond, "warning")) {
[16:18:41.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.304]                         if (muffled) 
[16:18:41.304]                           invokeRestart("muffleWarning")
[16:18:41.304]                       }
[16:18:41.304]                       else if (inherits(cond, "condition")) {
[16:18:41.304]                         if (!is.null(pattern)) {
[16:18:41.304]                           computeRestarts <- base::computeRestarts
[16:18:41.304]                           grepl <- base::grepl
[16:18:41.304]                           restarts <- computeRestarts(cond)
[16:18:41.304]                           for (restart in restarts) {
[16:18:41.304]                             name <- restart$name
[16:18:41.304]                             if (is.null(name)) 
[16:18:41.304]                               next
[16:18:41.304]                             if (!grepl(pattern, name)) 
[16:18:41.304]                               next
[16:18:41.304]                             invokeRestart(restart)
[16:18:41.304]                             muffled <- TRUE
[16:18:41.304]                             break
[16:18:41.304]                           }
[16:18:41.304]                         }
[16:18:41.304]                       }
[16:18:41.304]                       invisible(muffled)
[16:18:41.304]                     }
[16:18:41.304]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.304]                   }
[16:18:41.304]                 }
[16:18:41.304]                 else {
[16:18:41.304]                   if (TRUE) {
[16:18:41.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.304]                     {
[16:18:41.304]                       inherits <- base::inherits
[16:18:41.304]                       invokeRestart <- base::invokeRestart
[16:18:41.304]                       is.null <- base::is.null
[16:18:41.304]                       muffled <- FALSE
[16:18:41.304]                       if (inherits(cond, "message")) {
[16:18:41.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.304]                         if (muffled) 
[16:18:41.304]                           invokeRestart("muffleMessage")
[16:18:41.304]                       }
[16:18:41.304]                       else if (inherits(cond, "warning")) {
[16:18:41.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.304]                         if (muffled) 
[16:18:41.304]                           invokeRestart("muffleWarning")
[16:18:41.304]                       }
[16:18:41.304]                       else if (inherits(cond, "condition")) {
[16:18:41.304]                         if (!is.null(pattern)) {
[16:18:41.304]                           computeRestarts <- base::computeRestarts
[16:18:41.304]                           grepl <- base::grepl
[16:18:41.304]                           restarts <- computeRestarts(cond)
[16:18:41.304]                           for (restart in restarts) {
[16:18:41.304]                             name <- restart$name
[16:18:41.304]                             if (is.null(name)) 
[16:18:41.304]                               next
[16:18:41.304]                             if (!grepl(pattern, name)) 
[16:18:41.304]                               next
[16:18:41.304]                             invokeRestart(restart)
[16:18:41.304]                             muffled <- TRUE
[16:18:41.304]                             break
[16:18:41.304]                           }
[16:18:41.304]                         }
[16:18:41.304]                       }
[16:18:41.304]                       invisible(muffled)
[16:18:41.304]                     }
[16:18:41.304]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.304]                   }
[16:18:41.304]                 }
[16:18:41.304]             }
[16:18:41.304]         }))
[16:18:41.304]     }, error = function(ex) {
[16:18:41.304]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.304]                 ...future.rng), started = ...future.startTime, 
[16:18:41.304]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.304]             version = "1.8"), class = "FutureResult")
[16:18:41.304]     }, finally = {
[16:18:41.304]         if (!identical(...future.workdir, getwd())) 
[16:18:41.304]             setwd(...future.workdir)
[16:18:41.304]         {
[16:18:41.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.304]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.304]             }
[16:18:41.304]             base::options(...future.oldOptions)
[16:18:41.304]             if (.Platform$OS.type == "windows") {
[16:18:41.304]                 old_names <- names(...future.oldEnvVars)
[16:18:41.304]                 envs <- base::Sys.getenv()
[16:18:41.304]                 names <- names(envs)
[16:18:41.304]                 common <- intersect(names, old_names)
[16:18:41.304]                 added <- setdiff(names, old_names)
[16:18:41.304]                 removed <- setdiff(old_names, names)
[16:18:41.304]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.304]                   envs[common]]
[16:18:41.304]                 NAMES <- toupper(changed)
[16:18:41.304]                 args <- list()
[16:18:41.304]                 for (kk in seq_along(NAMES)) {
[16:18:41.304]                   name <- changed[[kk]]
[16:18:41.304]                   NAME <- NAMES[[kk]]
[16:18:41.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.304]                     next
[16:18:41.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.304]                 }
[16:18:41.304]                 NAMES <- toupper(added)
[16:18:41.304]                 for (kk in seq_along(NAMES)) {
[16:18:41.304]                   name <- added[[kk]]
[16:18:41.304]                   NAME <- NAMES[[kk]]
[16:18:41.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.304]                     next
[16:18:41.304]                   args[[name]] <- ""
[16:18:41.304]                 }
[16:18:41.304]                 NAMES <- toupper(removed)
[16:18:41.304]                 for (kk in seq_along(NAMES)) {
[16:18:41.304]                   name <- removed[[kk]]
[16:18:41.304]                   NAME <- NAMES[[kk]]
[16:18:41.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.304]                     next
[16:18:41.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.304]                 }
[16:18:41.304]                 if (length(args) > 0) 
[16:18:41.304]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.304]             }
[16:18:41.304]             else {
[16:18:41.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.304]             }
[16:18:41.304]             {
[16:18:41.304]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.304]                   0L) {
[16:18:41.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.304]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.304]                   base::options(opts)
[16:18:41.304]                 }
[16:18:41.304]                 {
[16:18:41.304]                   {
[16:18:41.304]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.304]                     NULL
[16:18:41.304]                   }
[16:18:41.304]                   options(future.plan = NULL)
[16:18:41.304]                   if (is.na(NA_character_)) 
[16:18:41.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.304]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.304]                     .init = FALSE)
[16:18:41.304]                 }
[16:18:41.304]             }
[16:18:41.304]         }
[16:18:41.304]     })
[16:18:41.304]     if (TRUE) {
[16:18:41.304]         base::sink(type = "output", split = FALSE)
[16:18:41.304]         if (TRUE) {
[16:18:41.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.304]         }
[16:18:41.304]         else {
[16:18:41.304]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.304]         }
[16:18:41.304]         base::close(...future.stdout)
[16:18:41.304]         ...future.stdout <- NULL
[16:18:41.304]     }
[16:18:41.304]     ...future.result$conditions <- ...future.conditions
[16:18:41.304]     ...future.result$finished <- base::Sys.time()
[16:18:41.304]     ...future.result
[16:18:41.304] }
[16:18:41.308] assign_globals() ...
[16:18:41.308] List of 5
[16:18:41.308]  $ ...future.FUN            :function (x, ...)  
[16:18:41.308]  $ MoreArgs                 :List of 1
[16:18:41.308]   ..$ x: num 42
[16:18:41.308]  $ ...future.elements_ii    :List of 1
[16:18:41.308]   ..$ times:List of 2
[16:18:41.308]   .. ..$ : int 3
[16:18:41.308]   .. ..$ : int 4
[16:18:41.308]  $ ...future.seeds_ii       : NULL
[16:18:41.308]  $ ...future.globals.maxSize: NULL
[16:18:41.308]  - attr(*, "where")=List of 5
[16:18:41.308]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.308]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.308]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.308]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.308]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.308]  - attr(*, "resolved")= logi FALSE
[16:18:41.308]  - attr(*, "total_size")= num 224
[16:18:41.308]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.308]  - attr(*, "already-done")= logi TRUE
[16:18:41.316] - copied ‘...future.FUN’ to environment
[16:18:41.316] - copied ‘MoreArgs’ to environment
[16:18:41.316] - copied ‘...future.elements_ii’ to environment
[16:18:41.316] - copied ‘...future.seeds_ii’ to environment
[16:18:41.316] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.317] assign_globals() ... done
[16:18:41.317] requestCore(): workers = 2
[16:18:41.319] MulticoreFuture started
[16:18:41.320] - Launch lazy future ... done
[16:18:41.320] run() for ‘MulticoreFuture’ ... done
[16:18:41.320] Created future:
[16:18:41.320] plan(): Setting new future strategy stack:
[16:18:41.321] List of future strategies:
[16:18:41.321] 1. sequential:
[16:18:41.321]    - args: function (..., envir = parent.frame())
[16:18:41.321]    - tweaked: FALSE
[16:18:41.321]    - call: NULL
[16:18:41.325] plan(): nbrOfWorkers() = 1
[16:18:41.328] plan(): Setting new future strategy stack:
[16:18:41.328] List of future strategies:
[16:18:41.328] 1. multicore:
[16:18:41.328]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.328]    - tweaked: FALSE
[16:18:41.328]    - call: plan(strategy)
[16:18:41.335] plan(): nbrOfWorkers() = 2
[16:18:41.320] MulticoreFuture:
[16:18:41.320] Label: ‘future_mapply-2’
[16:18:41.320] Expression:
[16:18:41.320] {
[16:18:41.320]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.320]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.320]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.320]         on.exit(options(oopts), add = TRUE)
[16:18:41.320]     }
[16:18:41.320]     {
[16:18:41.320]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.320]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.320]         do.call(mapply, args = args)
[16:18:41.320]     }
[16:18:41.320] }
[16:18:41.320] Lazy evaluation: FALSE
[16:18:41.320] Asynchronous evaluation: TRUE
[16:18:41.320] Local evaluation: TRUE
[16:18:41.320] Environment: R_GlobalEnv
[16:18:41.320] Capture standard output: TRUE
[16:18:41.320] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.320] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.320] Packages: <none>
[16:18:41.320] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.320] Resolved: TRUE
[16:18:41.320] Value: <not collected>
[16:18:41.320] Conditions captured: <none>
[16:18:41.320] Early signaling: FALSE
[16:18:41.320] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.320] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.337] Chunk #2 of 2 ... DONE
[16:18:41.337] Launching 2 futures (chunks) ... DONE
[16:18:41.337] Resolving 2 futures (chunks) ...
[16:18:41.338] resolve() on list ...
[16:18:41.338]  recursive: 0
[16:18:41.338]  length: 2
[16:18:41.338] 
[16:18:41.339] Future #1
[16:18:41.339] result() for MulticoreFuture ...
[16:18:41.340] result() for MulticoreFuture ...
[16:18:41.340] result() for MulticoreFuture ... done
[16:18:41.340] result() for MulticoreFuture ... done
[16:18:41.341] result() for MulticoreFuture ...
[16:18:41.341] result() for MulticoreFuture ... done
[16:18:41.341] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:41.341] - nx: 2
[16:18:41.342] - relay: TRUE
[16:18:41.342] - stdout: TRUE
[16:18:41.342] - signal: TRUE
[16:18:41.342] - resignal: FALSE
[16:18:41.342] - force: TRUE
[16:18:41.342] - relayed: [n=2] FALSE, FALSE
[16:18:41.343] - queued futures: [n=2] FALSE, FALSE
[16:18:41.343]  - until=1
[16:18:41.343]  - relaying element #1
[16:18:41.343] result() for MulticoreFuture ...
[16:18:41.343] result() for MulticoreFuture ... done
[16:18:41.343] result() for MulticoreFuture ...
[16:18:41.344] result() for MulticoreFuture ... done
[16:18:41.344] result() for MulticoreFuture ...
[16:18:41.344] result() for MulticoreFuture ... done
[16:18:41.344] result() for MulticoreFuture ...
[16:18:41.344] result() for MulticoreFuture ... done
[16:18:41.344] - relayed: [n=2] TRUE, FALSE
[16:18:41.345] - queued futures: [n=2] TRUE, FALSE
[16:18:41.345] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:41.345]  length: 1 (resolved future 1)
[16:18:41.345] Future #2
[16:18:41.346] result() for MulticoreFuture ...
[16:18:41.347] result() for MulticoreFuture ...
[16:18:41.347] result() for MulticoreFuture ... done
[16:18:41.347] result() for MulticoreFuture ... done
[16:18:41.347] result() for MulticoreFuture ...
[16:18:41.347] result() for MulticoreFuture ... done
[16:18:41.347] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:41.347] - nx: 2
[16:18:41.348] - relay: TRUE
[16:18:41.348] - stdout: TRUE
[16:18:41.348] - signal: TRUE
[16:18:41.348] - resignal: FALSE
[16:18:41.348] - force: TRUE
[16:18:41.348] - relayed: [n=2] TRUE, FALSE
[16:18:41.348] - queued futures: [n=2] TRUE, FALSE
[16:18:41.348]  - until=2
[16:18:41.349]  - relaying element #2
[16:18:41.349] result() for MulticoreFuture ...
[16:18:41.349] result() for MulticoreFuture ... done
[16:18:41.349] result() for MulticoreFuture ...
[16:18:41.349] result() for MulticoreFuture ... done
[16:18:41.349] result() for MulticoreFuture ...
[16:18:41.349] result() for MulticoreFuture ... done
[16:18:41.349] result() for MulticoreFuture ...
[16:18:41.349] result() for MulticoreFuture ... done
[16:18:41.350] - relayed: [n=2] TRUE, TRUE
[16:18:41.350] - queued futures: [n=2] TRUE, TRUE
[16:18:41.350] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:41.350]  length: 0 (resolved future 2)
[16:18:41.350] Relaying remaining futures
[16:18:41.350] signalConditionsASAP(NULL, pos=0) ...
[16:18:41.350] - nx: 2
[16:18:41.350] - relay: TRUE
[16:18:41.350] - stdout: TRUE
[16:18:41.351] - signal: TRUE
[16:18:41.351] - resignal: FALSE
[16:18:41.351] - force: TRUE
[16:18:41.351] - relayed: [n=2] TRUE, TRUE
[16:18:41.351] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:41.351] - relayed: [n=2] TRUE, TRUE
[16:18:41.351] - queued futures: [n=2] TRUE, TRUE
[16:18:41.351] signalConditionsASAP(NULL, pos=0) ... done
[16:18:41.351] resolve() on list ... DONE
[16:18:41.351] result() for MulticoreFuture ...
[16:18:41.352] result() for MulticoreFuture ... done
[16:18:41.352] result() for MulticoreFuture ...
[16:18:41.352] result() for MulticoreFuture ... done
[16:18:41.352] result() for MulticoreFuture ...
[16:18:41.352] result() for MulticoreFuture ... done
[16:18:41.352] result() for MulticoreFuture ...
[16:18:41.352] result() for MulticoreFuture ... done
[16:18:41.352]  - Number of value chunks collected: 2
[16:18:41.353] Resolving 2 futures (chunks) ... DONE
[16:18:41.353] Reducing values from 2 chunks ...
[16:18:41.353]  - Number of values collected after concatenation: 4
[16:18:41.353]  - Number of values expected: 4
[16:18:41.353] Reducing values from 2 chunks ... DONE
[16:18:41.353] future_mapply() ... DONE
[16:18:41.353] future_mapply() ...
[16:18:41.357] Number of chunks: 2
[16:18:41.358] getGlobalsAndPackagesXApply() ...
[16:18:41.358]  - future.globals: TRUE
[16:18:41.358] getGlobalsAndPackages() ...
[16:18:41.358] Searching for globals...
[16:18:41.359] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[16:18:41.360] Searching for globals ... DONE
[16:18:41.360] Resolving globals: FALSE
[16:18:41.360] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[16:18:41.361] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[16:18:41.361] - globals: [1] ‘FUN’
[16:18:41.361] 
[16:18:41.361] getGlobalsAndPackages() ... DONE
[16:18:41.361]  - globals found/used: [n=1] ‘FUN’
[16:18:41.361]  - needed namespaces: [n=0] 
[16:18:41.361] Finding globals ... DONE
[16:18:41.361] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:41.362] List of 2
[16:18:41.362]  $ ...future.FUN:function (x, y)  
[16:18:41.362]  $ MoreArgs     : NULL
[16:18:41.362]  - attr(*, "where")=List of 2
[16:18:41.362]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:41.362]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:41.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.362]  - attr(*, "resolved")= logi FALSE
[16:18:41.362]  - attr(*, "total_size")= num NA
[16:18:41.364] Packages to be attached in all futures: [n=0] 
[16:18:41.365] getGlobalsAndPackagesXApply() ... DONE
[16:18:41.367] Number of futures (= number of chunks): 2
[16:18:41.367] Launching 2 futures (chunks) ...
[16:18:41.367] Chunk #1 of 2 ...
[16:18:41.368]  - Finding globals in '...' for chunk #1 ...
[16:18:41.368] getGlobalsAndPackages() ...
[16:18:41.368] Searching for globals...
[16:18:41.368] 
[16:18:41.368] Searching for globals ... DONE
[16:18:41.369] - globals: [0] <none>
[16:18:41.369] getGlobalsAndPackages() ... DONE
[16:18:41.369]    + additional globals found: [n=0] 
[16:18:41.369]    + additional namespaces needed: [n=0] 
[16:18:41.369]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:41.369]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.369]  - seeds: <none>
[16:18:41.369]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.369] getGlobalsAndPackages() ...
[16:18:41.370] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.370] Resolving globals: FALSE
[16:18:41.370] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[16:18:41.371] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:41.371] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.371] 
[16:18:41.371] getGlobalsAndPackages() ... DONE
[16:18:41.371] run() for ‘Future’ ...
[16:18:41.372] - state: ‘created’
[16:18:41.372] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.375] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.376]   - Field: ‘label’
[16:18:41.376]   - Field: ‘local’
[16:18:41.376]   - Field: ‘owner’
[16:18:41.376]   - Field: ‘envir’
[16:18:41.376]   - Field: ‘workers’
[16:18:41.376]   - Field: ‘packages’
[16:18:41.376]   - Field: ‘gc’
[16:18:41.376]   - Field: ‘job’
[16:18:41.376]   - Field: ‘conditions’
[16:18:41.377]   - Field: ‘expr’
[16:18:41.377]   - Field: ‘uuid’
[16:18:41.377]   - Field: ‘seed’
[16:18:41.377]   - Field: ‘version’
[16:18:41.377]   - Field: ‘result’
[16:18:41.377]   - Field: ‘asynchronous’
[16:18:41.377]   - Field: ‘calls’
[16:18:41.377]   - Field: ‘globals’
[16:18:41.377]   - Field: ‘stdout’
[16:18:41.377]   - Field: ‘earlySignal’
[16:18:41.377]   - Field: ‘lazy’
[16:18:41.378]   - Field: ‘state’
[16:18:41.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.378] - Launch lazy future ...
[16:18:41.378] Packages needed by the future expression (n = 0): <none>
[16:18:41.378] Packages needed by future strategies (n = 0): <none>
[16:18:41.379] {
[16:18:41.379]     {
[16:18:41.379]         {
[16:18:41.379]             ...future.startTime <- base::Sys.time()
[16:18:41.379]             {
[16:18:41.379]                 {
[16:18:41.379]                   {
[16:18:41.379]                     {
[16:18:41.379]                       base::local({
[16:18:41.379]                         has_future <- base::requireNamespace("future", 
[16:18:41.379]                           quietly = TRUE)
[16:18:41.379]                         if (has_future) {
[16:18:41.379]                           ns <- base::getNamespace("future")
[16:18:41.379]                           version <- ns[[".package"]][["version"]]
[16:18:41.379]                           if (is.null(version)) 
[16:18:41.379]                             version <- utils::packageVersion("future")
[16:18:41.379]                         }
[16:18:41.379]                         else {
[16:18:41.379]                           version <- NULL
[16:18:41.379]                         }
[16:18:41.379]                         if (!has_future || version < "1.8.0") {
[16:18:41.379]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.379]                             "", base::R.version$version.string), 
[16:18:41.379]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.379]                               "release", "version")], collapse = " "), 
[16:18:41.379]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.379]                             info)
[16:18:41.379]                           info <- base::paste(info, collapse = "; ")
[16:18:41.379]                           if (!has_future) {
[16:18:41.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.379]                               info)
[16:18:41.379]                           }
[16:18:41.379]                           else {
[16:18:41.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.379]                               info, version)
[16:18:41.379]                           }
[16:18:41.379]                           base::stop(msg)
[16:18:41.379]                         }
[16:18:41.379]                       })
[16:18:41.379]                     }
[16:18:41.379]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.379]                     base::options(mc.cores = 1L)
[16:18:41.379]                   }
[16:18:41.379]                   ...future.strategy.old <- future::plan("list")
[16:18:41.379]                   options(future.plan = NULL)
[16:18:41.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.379]                 }
[16:18:41.379]                 ...future.workdir <- getwd()
[16:18:41.379]             }
[16:18:41.379]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.379]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.379]         }
[16:18:41.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.379]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.379]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.379]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.379]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.379]             base::names(...future.oldOptions))
[16:18:41.379]     }
[16:18:41.379]     if (FALSE) {
[16:18:41.379]     }
[16:18:41.379]     else {
[16:18:41.379]         if (TRUE) {
[16:18:41.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.379]                 open = "w")
[16:18:41.379]         }
[16:18:41.379]         else {
[16:18:41.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.379]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.379]         }
[16:18:41.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.379]             base::sink(type = "output", split = FALSE)
[16:18:41.379]             base::close(...future.stdout)
[16:18:41.379]         }, add = TRUE)
[16:18:41.379]     }
[16:18:41.379]     ...future.frame <- base::sys.nframe()
[16:18:41.379]     ...future.conditions <- base::list()
[16:18:41.379]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.379]     if (FALSE) {
[16:18:41.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.379]     }
[16:18:41.379]     ...future.result <- base::tryCatch({
[16:18:41.379]         base::withCallingHandlers({
[16:18:41.379]             ...future.value <- base::withVisible(base::local({
[16:18:41.379]                 withCallingHandlers({
[16:18:41.379]                   {
[16:18:41.379]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.379]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.379]                       ...future.globals.maxSize)) {
[16:18:41.379]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.379]                       on.exit(options(oopts), add = TRUE)
[16:18:41.379]                     }
[16:18:41.379]                     {
[16:18:41.379]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.379]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.379]                         USE.NAMES = FALSE)
[16:18:41.379]                       do.call(mapply, args = args)
[16:18:41.379]                     }
[16:18:41.379]                   }
[16:18:41.379]                 }, immediateCondition = function(cond) {
[16:18:41.379]                   save_rds <- function (object, pathname, ...) 
[16:18:41.379]                   {
[16:18:41.379]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.379]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.379]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.379]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.379]                         fi_tmp[["mtime"]])
[16:18:41.379]                     }
[16:18:41.379]                     tryCatch({
[16:18:41.379]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.379]                     }, error = function(ex) {
[16:18:41.379]                       msg <- conditionMessage(ex)
[16:18:41.379]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.379]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.379]                         fi_tmp[["mtime"]], msg)
[16:18:41.379]                       ex$message <- msg
[16:18:41.379]                       stop(ex)
[16:18:41.379]                     })
[16:18:41.379]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.379]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.379]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.379]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.379]                       fi <- file.info(pathname)
[16:18:41.379]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.379]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.379]                         fi[["size"]], fi[["mtime"]])
[16:18:41.379]                       stop(msg)
[16:18:41.379]                     }
[16:18:41.379]                     invisible(pathname)
[16:18:41.379]                   }
[16:18:41.379]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.379]                     rootPath = tempdir()) 
[16:18:41.379]                   {
[16:18:41.379]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.379]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.379]                       tmpdir = path, fileext = ".rds")
[16:18:41.379]                     save_rds(obj, file)
[16:18:41.379]                   }
[16:18:41.379]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.379]                   {
[16:18:41.379]                     inherits <- base::inherits
[16:18:41.379]                     invokeRestart <- base::invokeRestart
[16:18:41.379]                     is.null <- base::is.null
[16:18:41.379]                     muffled <- FALSE
[16:18:41.379]                     if (inherits(cond, "message")) {
[16:18:41.379]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.379]                       if (muffled) 
[16:18:41.379]                         invokeRestart("muffleMessage")
[16:18:41.379]                     }
[16:18:41.379]                     else if (inherits(cond, "warning")) {
[16:18:41.379]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.379]                       if (muffled) 
[16:18:41.379]                         invokeRestart("muffleWarning")
[16:18:41.379]                     }
[16:18:41.379]                     else if (inherits(cond, "condition")) {
[16:18:41.379]                       if (!is.null(pattern)) {
[16:18:41.379]                         computeRestarts <- base::computeRestarts
[16:18:41.379]                         grepl <- base::grepl
[16:18:41.379]                         restarts <- computeRestarts(cond)
[16:18:41.379]                         for (restart in restarts) {
[16:18:41.379]                           name <- restart$name
[16:18:41.379]                           if (is.null(name)) 
[16:18:41.379]                             next
[16:18:41.379]                           if (!grepl(pattern, name)) 
[16:18:41.379]                             next
[16:18:41.379]                           invokeRestart(restart)
[16:18:41.379]                           muffled <- TRUE
[16:18:41.379]                           break
[16:18:41.379]                         }
[16:18:41.379]                       }
[16:18:41.379]                     }
[16:18:41.379]                     invisible(muffled)
[16:18:41.379]                   }
[16:18:41.379]                   muffleCondition(cond)
[16:18:41.379]                 })
[16:18:41.379]             }))
[16:18:41.379]             future::FutureResult(value = ...future.value$value, 
[16:18:41.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.379]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.379]                     ...future.globalenv.names))
[16:18:41.379]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.379]         }, condition = base::local({
[16:18:41.379]             c <- base::c
[16:18:41.379]             inherits <- base::inherits
[16:18:41.379]             invokeRestart <- base::invokeRestart
[16:18:41.379]             length <- base::length
[16:18:41.379]             list <- base::list
[16:18:41.379]             seq.int <- base::seq.int
[16:18:41.379]             signalCondition <- base::signalCondition
[16:18:41.379]             sys.calls <- base::sys.calls
[16:18:41.379]             `[[` <- base::`[[`
[16:18:41.379]             `+` <- base::`+`
[16:18:41.379]             `<<-` <- base::`<<-`
[16:18:41.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.379]                   3L)]
[16:18:41.379]             }
[16:18:41.379]             function(cond) {
[16:18:41.379]                 is_error <- inherits(cond, "error")
[16:18:41.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.379]                   NULL)
[16:18:41.379]                 if (is_error) {
[16:18:41.379]                   sessionInformation <- function() {
[16:18:41.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.379]                       search = base::search(), system = base::Sys.info())
[16:18:41.379]                   }
[16:18:41.379]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.379]                     cond$call), session = sessionInformation(), 
[16:18:41.379]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.379]                   signalCondition(cond)
[16:18:41.379]                 }
[16:18:41.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.379]                 "immediateCondition"))) {
[16:18:41.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.379]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.379]                   if (TRUE && !signal) {
[16:18:41.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.379]                     {
[16:18:41.379]                       inherits <- base::inherits
[16:18:41.379]                       invokeRestart <- base::invokeRestart
[16:18:41.379]                       is.null <- base::is.null
[16:18:41.379]                       muffled <- FALSE
[16:18:41.379]                       if (inherits(cond, "message")) {
[16:18:41.379]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.379]                         if (muffled) 
[16:18:41.379]                           invokeRestart("muffleMessage")
[16:18:41.379]                       }
[16:18:41.379]                       else if (inherits(cond, "warning")) {
[16:18:41.379]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.379]                         if (muffled) 
[16:18:41.379]                           invokeRestart("muffleWarning")
[16:18:41.379]                       }
[16:18:41.379]                       else if (inherits(cond, "condition")) {
[16:18:41.379]                         if (!is.null(pattern)) {
[16:18:41.379]                           computeRestarts <- base::computeRestarts
[16:18:41.379]                           grepl <- base::grepl
[16:18:41.379]                           restarts <- computeRestarts(cond)
[16:18:41.379]                           for (restart in restarts) {
[16:18:41.379]                             name <- restart$name
[16:18:41.379]                             if (is.null(name)) 
[16:18:41.379]                               next
[16:18:41.379]                             if (!grepl(pattern, name)) 
[16:18:41.379]                               next
[16:18:41.379]                             invokeRestart(restart)
[16:18:41.379]                             muffled <- TRUE
[16:18:41.379]                             break
[16:18:41.379]                           }
[16:18:41.379]                         }
[16:18:41.379]                       }
[16:18:41.379]                       invisible(muffled)
[16:18:41.379]                     }
[16:18:41.379]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.379]                   }
[16:18:41.379]                 }
[16:18:41.379]                 else {
[16:18:41.379]                   if (TRUE) {
[16:18:41.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.379]                     {
[16:18:41.379]                       inherits <- base::inherits
[16:18:41.379]                       invokeRestart <- base::invokeRestart
[16:18:41.379]                       is.null <- base::is.null
[16:18:41.379]                       muffled <- FALSE
[16:18:41.379]                       if (inherits(cond, "message")) {
[16:18:41.379]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.379]                         if (muffled) 
[16:18:41.379]                           invokeRestart("muffleMessage")
[16:18:41.379]                       }
[16:18:41.379]                       else if (inherits(cond, "warning")) {
[16:18:41.379]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.379]                         if (muffled) 
[16:18:41.379]                           invokeRestart("muffleWarning")
[16:18:41.379]                       }
[16:18:41.379]                       else if (inherits(cond, "condition")) {
[16:18:41.379]                         if (!is.null(pattern)) {
[16:18:41.379]                           computeRestarts <- base::computeRestarts
[16:18:41.379]                           grepl <- base::grepl
[16:18:41.379]                           restarts <- computeRestarts(cond)
[16:18:41.379]                           for (restart in restarts) {
[16:18:41.379]                             name <- restart$name
[16:18:41.379]                             if (is.null(name)) 
[16:18:41.379]                               next
[16:18:41.379]                             if (!grepl(pattern, name)) 
[16:18:41.379]                               next
[16:18:41.379]                             invokeRestart(restart)
[16:18:41.379]                             muffled <- TRUE
[16:18:41.379]                             break
[16:18:41.379]                           }
[16:18:41.379]                         }
[16:18:41.379]                       }
[16:18:41.379]                       invisible(muffled)
[16:18:41.379]                     }
[16:18:41.379]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.379]                   }
[16:18:41.379]                 }
[16:18:41.379]             }
[16:18:41.379]         }))
[16:18:41.379]     }, error = function(ex) {
[16:18:41.379]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.379]                 ...future.rng), started = ...future.startTime, 
[16:18:41.379]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.379]             version = "1.8"), class = "FutureResult")
[16:18:41.379]     }, finally = {
[16:18:41.379]         if (!identical(...future.workdir, getwd())) 
[16:18:41.379]             setwd(...future.workdir)
[16:18:41.379]         {
[16:18:41.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.379]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.379]             }
[16:18:41.379]             base::options(...future.oldOptions)
[16:18:41.379]             if (.Platform$OS.type == "windows") {
[16:18:41.379]                 old_names <- names(...future.oldEnvVars)
[16:18:41.379]                 envs <- base::Sys.getenv()
[16:18:41.379]                 names <- names(envs)
[16:18:41.379]                 common <- intersect(names, old_names)
[16:18:41.379]                 added <- setdiff(names, old_names)
[16:18:41.379]                 removed <- setdiff(old_names, names)
[16:18:41.379]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.379]                   envs[common]]
[16:18:41.379]                 NAMES <- toupper(changed)
[16:18:41.379]                 args <- list()
[16:18:41.379]                 for (kk in seq_along(NAMES)) {
[16:18:41.379]                   name <- changed[[kk]]
[16:18:41.379]                   NAME <- NAMES[[kk]]
[16:18:41.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.379]                     next
[16:18:41.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.379]                 }
[16:18:41.379]                 NAMES <- toupper(added)
[16:18:41.379]                 for (kk in seq_along(NAMES)) {
[16:18:41.379]                   name <- added[[kk]]
[16:18:41.379]                   NAME <- NAMES[[kk]]
[16:18:41.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.379]                     next
[16:18:41.379]                   args[[name]] <- ""
[16:18:41.379]                 }
[16:18:41.379]                 NAMES <- toupper(removed)
[16:18:41.379]                 for (kk in seq_along(NAMES)) {
[16:18:41.379]                   name <- removed[[kk]]
[16:18:41.379]                   NAME <- NAMES[[kk]]
[16:18:41.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.379]                     next
[16:18:41.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.379]                 }
[16:18:41.379]                 if (length(args) > 0) 
[16:18:41.379]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.379]             }
[16:18:41.379]             else {
[16:18:41.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.379]             }
[16:18:41.379]             {
[16:18:41.379]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.379]                   0L) {
[16:18:41.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.379]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.379]                   base::options(opts)
[16:18:41.379]                 }
[16:18:41.379]                 {
[16:18:41.379]                   {
[16:18:41.379]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.379]                     NULL
[16:18:41.379]                   }
[16:18:41.379]                   options(future.plan = NULL)
[16:18:41.379]                   if (is.na(NA_character_)) 
[16:18:41.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.379]                     .init = FALSE)
[16:18:41.379]                 }
[16:18:41.379]             }
[16:18:41.379]         }
[16:18:41.379]     })
[16:18:41.379]     if (TRUE) {
[16:18:41.379]         base::sink(type = "output", split = FALSE)
[16:18:41.379]         if (TRUE) {
[16:18:41.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.379]         }
[16:18:41.379]         else {
[16:18:41.379]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.379]         }
[16:18:41.379]         base::close(...future.stdout)
[16:18:41.379]         ...future.stdout <- NULL
[16:18:41.379]     }
[16:18:41.379]     ...future.result$conditions <- ...future.conditions
[16:18:41.379]     ...future.result$finished <- base::Sys.time()
[16:18:41.379]     ...future.result
[16:18:41.379] }
[16:18:41.381] assign_globals() ...
[16:18:41.381] List of 5
[16:18:41.381]  $ ...future.FUN            :function (x, y)  
[16:18:41.381]  $ MoreArgs                 : NULL
[16:18:41.381]  $ ...future.elements_ii    :List of 2
[16:18:41.381]   ..$ :List of 1
[16:18:41.381]   .. ..$ a: num 1
[16:18:41.381]   ..$ :List of 1
[16:18:41.381]   .. ..$ A: num 10
[16:18:41.381]  $ ...future.seeds_ii       : NULL
[16:18:41.381]  $ ...future.globals.maxSize: NULL
[16:18:41.381]  - attr(*, "where")=List of 5
[16:18:41.381]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.381]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.381]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.381]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.381]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.381]  - attr(*, "resolved")= logi FALSE
[16:18:41.381]  - attr(*, "total_size")= num 2088
[16:18:41.381]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.381]  - attr(*, "already-done")= logi TRUE
[16:18:41.386] - reassign environment for ‘...future.FUN’
[16:18:41.386] - copied ‘...future.FUN’ to environment
[16:18:41.387] - copied ‘MoreArgs’ to environment
[16:18:41.387] - copied ‘...future.elements_ii’ to environment
[16:18:41.387] - copied ‘...future.seeds_ii’ to environment
[16:18:41.387] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.387] assign_globals() ... done
[16:18:41.387] requestCore(): workers = 2
[16:18:41.389] MulticoreFuture started
[16:18:41.390] - Launch lazy future ... done
[16:18:41.390] run() for ‘MulticoreFuture’ ... done
[16:18:41.390] Created future:
[16:18:41.391] plan(): Setting new future strategy stack:
[16:18:41.391] List of future strategies:
[16:18:41.391] 1. sequential:
[16:18:41.391]    - args: function (..., envir = parent.frame())
[16:18:41.391]    - tweaked: FALSE
[16:18:41.391]    - call: NULL
[16:18:41.392] plan(): nbrOfWorkers() = 1
[16:18:41.394] plan(): Setting new future strategy stack:
[16:18:41.394] List of future strategies:
[16:18:41.394] 1. multicore:
[16:18:41.394]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.394]    - tweaked: FALSE
[16:18:41.394]    - call: plan(strategy)
[16:18:41.400] plan(): nbrOfWorkers() = 2
[16:18:41.391] MulticoreFuture:
[16:18:41.391] Label: ‘future_mapply-1’
[16:18:41.391] Expression:
[16:18:41.391] {
[16:18:41.391]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.391]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.391]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.391]         on.exit(options(oopts), add = TRUE)
[16:18:41.391]     }
[16:18:41.391]     {
[16:18:41.391]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.391]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.391]         do.call(mapply, args = args)
[16:18:41.391]     }
[16:18:41.391] }
[16:18:41.391] Lazy evaluation: FALSE
[16:18:41.391] Asynchronous evaluation: TRUE
[16:18:41.391] Local evaluation: TRUE
[16:18:41.391] Environment: R_GlobalEnv
[16:18:41.391] Capture standard output: TRUE
[16:18:41.391] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.391] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.391] Packages: <none>
[16:18:41.391] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.391] Resolved: TRUE
[16:18:41.391] Value: <not collected>
[16:18:41.391] Conditions captured: <none>
[16:18:41.391] Early signaling: FALSE
[16:18:41.391] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.391] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.401] Chunk #1 of 2 ... DONE
[16:18:41.401] Chunk #2 of 2 ...
[16:18:41.401]  - Finding globals in '...' for chunk #2 ...
[16:18:41.401] getGlobalsAndPackages() ...
[16:18:41.402] Searching for globals...
[16:18:41.402] 
[16:18:41.402] Searching for globals ... DONE
[16:18:41.403] - globals: [0] <none>
[16:18:41.403] getGlobalsAndPackages() ... DONE
[16:18:41.403]    + additional globals found: [n=0] 
[16:18:41.403]    + additional namespaces needed: [n=0] 
[16:18:41.403]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:41.403]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.403]  - seeds: <none>
[16:18:41.404]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.404] getGlobalsAndPackages() ...
[16:18:41.408] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.408] Resolving globals: FALSE
[16:18:41.410] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[16:18:41.411] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:41.412] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.412] 
[16:18:41.412] getGlobalsAndPackages() ... DONE
[16:18:41.413] run() for ‘Future’ ...
[16:18:41.414] - state: ‘created’
[16:18:41.414] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.419] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.420]   - Field: ‘label’
[16:18:41.420]   - Field: ‘local’
[16:18:41.420]   - Field: ‘owner’
[16:18:41.420]   - Field: ‘envir’
[16:18:41.421]   - Field: ‘workers’
[16:18:41.421]   - Field: ‘packages’
[16:18:41.421]   - Field: ‘gc’
[16:18:41.421]   - Field: ‘job’
[16:18:41.421]   - Field: ‘conditions’
[16:18:41.421]   - Field: ‘expr’
[16:18:41.421]   - Field: ‘uuid’
[16:18:41.422]   - Field: ‘seed’
[16:18:41.422]   - Field: ‘version’
[16:18:41.422]   - Field: ‘result’
[16:18:41.422]   - Field: ‘asynchronous’
[16:18:41.422]   - Field: ‘calls’
[16:18:41.422]   - Field: ‘globals’
[16:18:41.423]   - Field: ‘stdout’
[16:18:41.423]   - Field: ‘earlySignal’
[16:18:41.423]   - Field: ‘lazy’
[16:18:41.423]   - Field: ‘state’
[16:18:41.423] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.424] - Launch lazy future ...
[16:18:41.424] Packages needed by the future expression (n = 0): <none>
[16:18:41.424] Packages needed by future strategies (n = 0): <none>
[16:18:41.425] {
[16:18:41.425]     {
[16:18:41.425]         {
[16:18:41.425]             ...future.startTime <- base::Sys.time()
[16:18:41.425]             {
[16:18:41.425]                 {
[16:18:41.425]                   {
[16:18:41.425]                     {
[16:18:41.425]                       base::local({
[16:18:41.425]                         has_future <- base::requireNamespace("future", 
[16:18:41.425]                           quietly = TRUE)
[16:18:41.425]                         if (has_future) {
[16:18:41.425]                           ns <- base::getNamespace("future")
[16:18:41.425]                           version <- ns[[".package"]][["version"]]
[16:18:41.425]                           if (is.null(version)) 
[16:18:41.425]                             version <- utils::packageVersion("future")
[16:18:41.425]                         }
[16:18:41.425]                         else {
[16:18:41.425]                           version <- NULL
[16:18:41.425]                         }
[16:18:41.425]                         if (!has_future || version < "1.8.0") {
[16:18:41.425]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.425]                             "", base::R.version$version.string), 
[16:18:41.425]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.425]                               "release", "version")], collapse = " "), 
[16:18:41.425]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.425]                             info)
[16:18:41.425]                           info <- base::paste(info, collapse = "; ")
[16:18:41.425]                           if (!has_future) {
[16:18:41.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.425]                               info)
[16:18:41.425]                           }
[16:18:41.425]                           else {
[16:18:41.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.425]                               info, version)
[16:18:41.425]                           }
[16:18:41.425]                           base::stop(msg)
[16:18:41.425]                         }
[16:18:41.425]                       })
[16:18:41.425]                     }
[16:18:41.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.425]                     base::options(mc.cores = 1L)
[16:18:41.425]                   }
[16:18:41.425]                   ...future.strategy.old <- future::plan("list")
[16:18:41.425]                   options(future.plan = NULL)
[16:18:41.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.425]                 }
[16:18:41.425]                 ...future.workdir <- getwd()
[16:18:41.425]             }
[16:18:41.425]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.425]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.425]         }
[16:18:41.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.425]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.425]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.425]             base::names(...future.oldOptions))
[16:18:41.425]     }
[16:18:41.425]     if (FALSE) {
[16:18:41.425]     }
[16:18:41.425]     else {
[16:18:41.425]         if (TRUE) {
[16:18:41.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.425]                 open = "w")
[16:18:41.425]         }
[16:18:41.425]         else {
[16:18:41.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.425]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.425]         }
[16:18:41.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.425]             base::sink(type = "output", split = FALSE)
[16:18:41.425]             base::close(...future.stdout)
[16:18:41.425]         }, add = TRUE)
[16:18:41.425]     }
[16:18:41.425]     ...future.frame <- base::sys.nframe()
[16:18:41.425]     ...future.conditions <- base::list()
[16:18:41.425]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.425]     if (FALSE) {
[16:18:41.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.425]     }
[16:18:41.425]     ...future.result <- base::tryCatch({
[16:18:41.425]         base::withCallingHandlers({
[16:18:41.425]             ...future.value <- base::withVisible(base::local({
[16:18:41.425]                 withCallingHandlers({
[16:18:41.425]                   {
[16:18:41.425]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.425]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.425]                       ...future.globals.maxSize)) {
[16:18:41.425]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.425]                       on.exit(options(oopts), add = TRUE)
[16:18:41.425]                     }
[16:18:41.425]                     {
[16:18:41.425]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.425]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.425]                         USE.NAMES = FALSE)
[16:18:41.425]                       do.call(mapply, args = args)
[16:18:41.425]                     }
[16:18:41.425]                   }
[16:18:41.425]                 }, immediateCondition = function(cond) {
[16:18:41.425]                   save_rds <- function (object, pathname, ...) 
[16:18:41.425]                   {
[16:18:41.425]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.425]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.425]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.425]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.425]                         fi_tmp[["mtime"]])
[16:18:41.425]                     }
[16:18:41.425]                     tryCatch({
[16:18:41.425]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.425]                     }, error = function(ex) {
[16:18:41.425]                       msg <- conditionMessage(ex)
[16:18:41.425]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.425]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.425]                         fi_tmp[["mtime"]], msg)
[16:18:41.425]                       ex$message <- msg
[16:18:41.425]                       stop(ex)
[16:18:41.425]                     })
[16:18:41.425]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.425]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.425]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.425]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.425]                       fi <- file.info(pathname)
[16:18:41.425]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.425]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.425]                         fi[["size"]], fi[["mtime"]])
[16:18:41.425]                       stop(msg)
[16:18:41.425]                     }
[16:18:41.425]                     invisible(pathname)
[16:18:41.425]                   }
[16:18:41.425]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.425]                     rootPath = tempdir()) 
[16:18:41.425]                   {
[16:18:41.425]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.425]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.425]                       tmpdir = path, fileext = ".rds")
[16:18:41.425]                     save_rds(obj, file)
[16:18:41.425]                   }
[16:18:41.425]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.425]                   {
[16:18:41.425]                     inherits <- base::inherits
[16:18:41.425]                     invokeRestart <- base::invokeRestart
[16:18:41.425]                     is.null <- base::is.null
[16:18:41.425]                     muffled <- FALSE
[16:18:41.425]                     if (inherits(cond, "message")) {
[16:18:41.425]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.425]                       if (muffled) 
[16:18:41.425]                         invokeRestart("muffleMessage")
[16:18:41.425]                     }
[16:18:41.425]                     else if (inherits(cond, "warning")) {
[16:18:41.425]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.425]                       if (muffled) 
[16:18:41.425]                         invokeRestart("muffleWarning")
[16:18:41.425]                     }
[16:18:41.425]                     else if (inherits(cond, "condition")) {
[16:18:41.425]                       if (!is.null(pattern)) {
[16:18:41.425]                         computeRestarts <- base::computeRestarts
[16:18:41.425]                         grepl <- base::grepl
[16:18:41.425]                         restarts <- computeRestarts(cond)
[16:18:41.425]                         for (restart in restarts) {
[16:18:41.425]                           name <- restart$name
[16:18:41.425]                           if (is.null(name)) 
[16:18:41.425]                             next
[16:18:41.425]                           if (!grepl(pattern, name)) 
[16:18:41.425]                             next
[16:18:41.425]                           invokeRestart(restart)
[16:18:41.425]                           muffled <- TRUE
[16:18:41.425]                           break
[16:18:41.425]                         }
[16:18:41.425]                       }
[16:18:41.425]                     }
[16:18:41.425]                     invisible(muffled)
[16:18:41.425]                   }
[16:18:41.425]                   muffleCondition(cond)
[16:18:41.425]                 })
[16:18:41.425]             }))
[16:18:41.425]             future::FutureResult(value = ...future.value$value, 
[16:18:41.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.425]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.425]                     ...future.globalenv.names))
[16:18:41.425]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.425]         }, condition = base::local({
[16:18:41.425]             c <- base::c
[16:18:41.425]             inherits <- base::inherits
[16:18:41.425]             invokeRestart <- base::invokeRestart
[16:18:41.425]             length <- base::length
[16:18:41.425]             list <- base::list
[16:18:41.425]             seq.int <- base::seq.int
[16:18:41.425]             signalCondition <- base::signalCondition
[16:18:41.425]             sys.calls <- base::sys.calls
[16:18:41.425]             `[[` <- base::`[[`
[16:18:41.425]             `+` <- base::`+`
[16:18:41.425]             `<<-` <- base::`<<-`
[16:18:41.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.425]                   3L)]
[16:18:41.425]             }
[16:18:41.425]             function(cond) {
[16:18:41.425]                 is_error <- inherits(cond, "error")
[16:18:41.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.425]                   NULL)
[16:18:41.425]                 if (is_error) {
[16:18:41.425]                   sessionInformation <- function() {
[16:18:41.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.425]                       search = base::search(), system = base::Sys.info())
[16:18:41.425]                   }
[16:18:41.425]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.425]                     cond$call), session = sessionInformation(), 
[16:18:41.425]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.425]                   signalCondition(cond)
[16:18:41.425]                 }
[16:18:41.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.425]                 "immediateCondition"))) {
[16:18:41.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.425]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.425]                   if (TRUE && !signal) {
[16:18:41.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.425]                     {
[16:18:41.425]                       inherits <- base::inherits
[16:18:41.425]                       invokeRestart <- base::invokeRestart
[16:18:41.425]                       is.null <- base::is.null
[16:18:41.425]                       muffled <- FALSE
[16:18:41.425]                       if (inherits(cond, "message")) {
[16:18:41.425]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.425]                         if (muffled) 
[16:18:41.425]                           invokeRestart("muffleMessage")
[16:18:41.425]                       }
[16:18:41.425]                       else if (inherits(cond, "warning")) {
[16:18:41.425]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.425]                         if (muffled) 
[16:18:41.425]                           invokeRestart("muffleWarning")
[16:18:41.425]                       }
[16:18:41.425]                       else if (inherits(cond, "condition")) {
[16:18:41.425]                         if (!is.null(pattern)) {
[16:18:41.425]                           computeRestarts <- base::computeRestarts
[16:18:41.425]                           grepl <- base::grepl
[16:18:41.425]                           restarts <- computeRestarts(cond)
[16:18:41.425]                           for (restart in restarts) {
[16:18:41.425]                             name <- restart$name
[16:18:41.425]                             if (is.null(name)) 
[16:18:41.425]                               next
[16:18:41.425]                             if (!grepl(pattern, name)) 
[16:18:41.425]                               next
[16:18:41.425]                             invokeRestart(restart)
[16:18:41.425]                             muffled <- TRUE
[16:18:41.425]                             break
[16:18:41.425]                           }
[16:18:41.425]                         }
[16:18:41.425]                       }
[16:18:41.425]                       invisible(muffled)
[16:18:41.425]                     }
[16:18:41.425]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.425]                   }
[16:18:41.425]                 }
[16:18:41.425]                 else {
[16:18:41.425]                   if (TRUE) {
[16:18:41.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.425]                     {
[16:18:41.425]                       inherits <- base::inherits
[16:18:41.425]                       invokeRestart <- base::invokeRestart
[16:18:41.425]                       is.null <- base::is.null
[16:18:41.425]                       muffled <- FALSE
[16:18:41.425]                       if (inherits(cond, "message")) {
[16:18:41.425]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.425]                         if (muffled) 
[16:18:41.425]                           invokeRestart("muffleMessage")
[16:18:41.425]                       }
[16:18:41.425]                       else if (inherits(cond, "warning")) {
[16:18:41.425]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.425]                         if (muffled) 
[16:18:41.425]                           invokeRestart("muffleWarning")
[16:18:41.425]                       }
[16:18:41.425]                       else if (inherits(cond, "condition")) {
[16:18:41.425]                         if (!is.null(pattern)) {
[16:18:41.425]                           computeRestarts <- base::computeRestarts
[16:18:41.425]                           grepl <- base::grepl
[16:18:41.425]                           restarts <- computeRestarts(cond)
[16:18:41.425]                           for (restart in restarts) {
[16:18:41.425]                             name <- restart$name
[16:18:41.425]                             if (is.null(name)) 
[16:18:41.425]                               next
[16:18:41.425]                             if (!grepl(pattern, name)) 
[16:18:41.425]                               next
[16:18:41.425]                             invokeRestart(restart)
[16:18:41.425]                             muffled <- TRUE
[16:18:41.425]                             break
[16:18:41.425]                           }
[16:18:41.425]                         }
[16:18:41.425]                       }
[16:18:41.425]                       invisible(muffled)
[16:18:41.425]                     }
[16:18:41.425]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.425]                   }
[16:18:41.425]                 }
[16:18:41.425]             }
[16:18:41.425]         }))
[16:18:41.425]     }, error = function(ex) {
[16:18:41.425]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.425]                 ...future.rng), started = ...future.startTime, 
[16:18:41.425]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.425]             version = "1.8"), class = "FutureResult")
[16:18:41.425]     }, finally = {
[16:18:41.425]         if (!identical(...future.workdir, getwd())) 
[16:18:41.425]             setwd(...future.workdir)
[16:18:41.425]         {
[16:18:41.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.425]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.425]             }
[16:18:41.425]             base::options(...future.oldOptions)
[16:18:41.425]             if (.Platform$OS.type == "windows") {
[16:18:41.425]                 old_names <- names(...future.oldEnvVars)
[16:18:41.425]                 envs <- base::Sys.getenv()
[16:18:41.425]                 names <- names(envs)
[16:18:41.425]                 common <- intersect(names, old_names)
[16:18:41.425]                 added <- setdiff(names, old_names)
[16:18:41.425]                 removed <- setdiff(old_names, names)
[16:18:41.425]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.425]                   envs[common]]
[16:18:41.425]                 NAMES <- toupper(changed)
[16:18:41.425]                 args <- list()
[16:18:41.425]                 for (kk in seq_along(NAMES)) {
[16:18:41.425]                   name <- changed[[kk]]
[16:18:41.425]                   NAME <- NAMES[[kk]]
[16:18:41.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.425]                     next
[16:18:41.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.425]                 }
[16:18:41.425]                 NAMES <- toupper(added)
[16:18:41.425]                 for (kk in seq_along(NAMES)) {
[16:18:41.425]                   name <- added[[kk]]
[16:18:41.425]                   NAME <- NAMES[[kk]]
[16:18:41.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.425]                     next
[16:18:41.425]                   args[[name]] <- ""
[16:18:41.425]                 }
[16:18:41.425]                 NAMES <- toupper(removed)
[16:18:41.425]                 for (kk in seq_along(NAMES)) {
[16:18:41.425]                   name <- removed[[kk]]
[16:18:41.425]                   NAME <- NAMES[[kk]]
[16:18:41.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.425]                     next
[16:18:41.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.425]                 }
[16:18:41.425]                 if (length(args) > 0) 
[16:18:41.425]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.425]             }
[16:18:41.425]             else {
[16:18:41.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.425]             }
[16:18:41.425]             {
[16:18:41.425]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.425]                   0L) {
[16:18:41.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.425]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.425]                   base::options(opts)
[16:18:41.425]                 }
[16:18:41.425]                 {
[16:18:41.425]                   {
[16:18:41.425]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.425]                     NULL
[16:18:41.425]                   }
[16:18:41.425]                   options(future.plan = NULL)
[16:18:41.425]                   if (is.na(NA_character_)) 
[16:18:41.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.425]                     .init = FALSE)
[16:18:41.425]                 }
[16:18:41.425]             }
[16:18:41.425]         }
[16:18:41.425]     })
[16:18:41.425]     if (TRUE) {
[16:18:41.425]         base::sink(type = "output", split = FALSE)
[16:18:41.425]         if (TRUE) {
[16:18:41.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.425]         }
[16:18:41.425]         else {
[16:18:41.425]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.425]         }
[16:18:41.425]         base::close(...future.stdout)
[16:18:41.425]         ...future.stdout <- NULL
[16:18:41.425]     }
[16:18:41.425]     ...future.result$conditions <- ...future.conditions
[16:18:41.425]     ...future.result$finished <- base::Sys.time()
[16:18:41.425]     ...future.result
[16:18:41.425] }
[16:18:41.428] assign_globals() ...
[16:18:41.428] List of 5
[16:18:41.428]  $ ...future.FUN            :function (x, y)  
[16:18:41.428]  $ MoreArgs                 : NULL
[16:18:41.428]  $ ...future.elements_ii    :List of 2
[16:18:41.428]   ..$ :List of 2
[16:18:41.428]   .. ..$ b: num 2
[16:18:41.428]   .. ..$ c: num 3
[16:18:41.428]   ..$ :List of 2
[16:18:41.428]   .. ..$ B: num 0
[16:18:41.428]   .. ..$ C: num -10
[16:18:41.428]  $ ...future.seeds_ii       : NULL
[16:18:41.428]  $ ...future.globals.maxSize: NULL
[16:18:41.428]  - attr(*, "where")=List of 5
[16:18:41.428]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.428]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.428]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.428]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.428]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.428]  - attr(*, "resolved")= logi FALSE
[16:18:41.428]  - attr(*, "total_size")= num 2200
[16:18:41.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.428]  - attr(*, "already-done")= logi TRUE
[16:18:41.436] - reassign environment for ‘...future.FUN’
[16:18:41.436] - copied ‘...future.FUN’ to environment
[16:18:41.436] - copied ‘MoreArgs’ to environment
[16:18:41.436] - copied ‘...future.elements_ii’ to environment
[16:18:41.436] - copied ‘...future.seeds_ii’ to environment
[16:18:41.436] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.437] assign_globals() ... done
[16:18:41.437] requestCore(): workers = 2
[16:18:41.439] MulticoreFuture started
[16:18:41.439] - Launch lazy future ... done
[16:18:41.440] run() for ‘MulticoreFuture’ ... done
[16:18:41.440] Created future:
[16:18:41.440] plan(): Setting new future strategy stack:
[16:18:41.440] List of future strategies:
[16:18:41.440] 1. sequential:
[16:18:41.440]    - args: function (..., envir = parent.frame())
[16:18:41.440]    - tweaked: FALSE
[16:18:41.440]    - call: NULL
[16:18:41.441] plan(): nbrOfWorkers() = 1
[16:18:41.443] plan(): Setting new future strategy stack:
[16:18:41.444] List of future strategies:
[16:18:41.444] 1. multicore:
[16:18:41.444]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.444]    - tweaked: FALSE
[16:18:41.444]    - call: plan(strategy)
[16:18:41.449] plan(): nbrOfWorkers() = 2
[16:18:41.440] MulticoreFuture:
[16:18:41.440] Label: ‘future_mapply-2’
[16:18:41.440] Expression:
[16:18:41.440] {
[16:18:41.440]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.440]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.440]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.440]         on.exit(options(oopts), add = TRUE)
[16:18:41.440]     }
[16:18:41.440]     {
[16:18:41.440]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.440]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.440]         do.call(mapply, args = args)
[16:18:41.440]     }
[16:18:41.440] }
[16:18:41.440] Lazy evaluation: FALSE
[16:18:41.440] Asynchronous evaluation: TRUE
[16:18:41.440] Local evaluation: TRUE
[16:18:41.440] Environment: R_GlobalEnv
[16:18:41.440] Capture standard output: TRUE
[16:18:41.440] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.440] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.440] Packages: <none>
[16:18:41.440] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.440] Resolved: TRUE
[16:18:41.440] Value: <not collected>
[16:18:41.440] Conditions captured: <none>
[16:18:41.440] Early signaling: FALSE
[16:18:41.440] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.440] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.450] Chunk #2 of 2 ... DONE
[16:18:41.450] Launching 2 futures (chunks) ... DONE
[16:18:41.450] Resolving 2 futures (chunks) ...
[16:18:41.451] resolve() on list ...
[16:18:41.451]  recursive: 0
[16:18:41.451]  length: 2
[16:18:41.451] 
[16:18:41.451] Future #1
[16:18:41.451] result() for MulticoreFuture ...
[16:18:41.452] result() for MulticoreFuture ...
[16:18:41.452] result() for MulticoreFuture ... done
[16:18:41.453] result() for MulticoreFuture ... done
[16:18:41.453] result() for MulticoreFuture ...
[16:18:41.453] result() for MulticoreFuture ... done
[16:18:41.453] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:41.453] - nx: 2
[16:18:41.453] - relay: TRUE
[16:18:41.453] - stdout: TRUE
[16:18:41.454] - signal: TRUE
[16:18:41.454] - resignal: FALSE
[16:18:41.454] - force: TRUE
[16:18:41.454] - relayed: [n=2] FALSE, FALSE
[16:18:41.454] - queued futures: [n=2] FALSE, FALSE
[16:18:41.454]  - until=1
[16:18:41.455]  - relaying element #1
[16:18:41.455] result() for MulticoreFuture ...
[16:18:41.455] result() for MulticoreFuture ... done
[16:18:41.455] result() for MulticoreFuture ...
[16:18:41.459] result() for MulticoreFuture ... done
[16:18:41.459] result() for MulticoreFuture ...
[16:18:41.460] result() for MulticoreFuture ... done
[16:18:41.460] result() for MulticoreFuture ...
[16:18:41.460] result() for MulticoreFuture ... done
[16:18:41.461] - relayed: [n=2] TRUE, FALSE
[16:18:41.461] - queued futures: [n=2] TRUE, FALSE
[16:18:41.461] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:41.462]  length: 1 (resolved future 1)
[16:18:41.462] Future #2
[16:18:41.463] result() for MulticoreFuture ...
[16:18:41.464] result() for MulticoreFuture ...
[16:18:41.464] result() for MulticoreFuture ... done
[16:18:41.464] result() for MulticoreFuture ... done
[16:18:41.465] result() for MulticoreFuture ...
[16:18:41.465] result() for MulticoreFuture ... done
[16:18:41.465] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:41.465] - nx: 2
[16:18:41.465] - relay: TRUE
[16:18:41.465] - stdout: TRUE
[16:18:41.466] - signal: TRUE
[16:18:41.466] - resignal: FALSE
[16:18:41.466] - force: TRUE
[16:18:41.466] - relayed: [n=2] TRUE, FALSE
[16:18:41.466] - queued futures: [n=2] TRUE, FALSE
[16:18:41.466]  - until=2
[16:18:41.466]  - relaying element #2
[16:18:41.467] result() for MulticoreFuture ...
[16:18:41.467] result() for MulticoreFuture ... done
[16:18:41.467] result() for MulticoreFuture ...
[16:18:41.467] result() for MulticoreFuture ... done
[16:18:41.467] result() for MulticoreFuture ...
[16:18:41.467] result() for MulticoreFuture ... done
[16:18:41.467] result() for MulticoreFuture ...
[16:18:41.467] result() for MulticoreFuture ... done
[16:18:41.468] - relayed: [n=2] TRUE, TRUE
[16:18:41.468] - queued futures: [n=2] TRUE, TRUE
[16:18:41.468] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:41.468]  length: 0 (resolved future 2)
[16:18:41.468] Relaying remaining futures
[16:18:41.468] signalConditionsASAP(NULL, pos=0) ...
[16:18:41.468] - nx: 2
[16:18:41.468] - relay: TRUE
[16:18:41.468] - stdout: TRUE
[16:18:41.469] - signal: TRUE
[16:18:41.469] - resignal: FALSE
[16:18:41.469] - force: TRUE
[16:18:41.469] - relayed: [n=2] TRUE, TRUE
[16:18:41.469] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:41.469] - relayed: [n=2] TRUE, TRUE
[16:18:41.469] - queued futures: [n=2] TRUE, TRUE
[16:18:41.470] signalConditionsASAP(NULL, pos=0) ... done
[16:18:41.470] resolve() on list ... DONE
[16:18:41.470] result() for MulticoreFuture ...
[16:18:41.470] result() for MulticoreFuture ... done
[16:18:41.470] result() for MulticoreFuture ...
[16:18:41.470] result() for MulticoreFuture ... done
[16:18:41.470] result() for MulticoreFuture ...
[16:18:41.470] result() for MulticoreFuture ... done
[16:18:41.471] result() for MulticoreFuture ...
[16:18:41.471] result() for MulticoreFuture ... done
[16:18:41.471]  - Number of value chunks collected: 2
[16:18:41.471] Resolving 2 futures (chunks) ... DONE
[16:18:41.471] Reducing values from 2 chunks ...
[16:18:41.471]  - Number of values collected after concatenation: 3
[16:18:41.471]  - Number of values expected: 3
[16:18:41.471] Reducing values from 2 chunks ... DONE
[16:18:41.471] future_mapply() ... DONE
- future_.mapply()
[16:18:41.472] future_mapply() ...
[16:18:41.476] Number of chunks: 2
[16:18:41.476] getGlobalsAndPackagesXApply() ...
[16:18:41.477]  - future.globals: TRUE
[16:18:41.477] getGlobalsAndPackages() ...
[16:18:41.477] Searching for globals...
[16:18:41.478] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[16:18:41.478] Searching for globals ... DONE
[16:18:41.479] Resolving globals: FALSE
[16:18:41.479] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[16:18:41.479] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[16:18:41.479] - globals: [1] ‘FUN’
[16:18:41.480] 
[16:18:41.480] getGlobalsAndPackages() ... DONE
[16:18:41.480]  - globals found/used: [n=1] ‘FUN’
[16:18:41.480]  - needed namespaces: [n=0] 
[16:18:41.480] Finding globals ... DONE
[16:18:41.480] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:41.480] List of 2
[16:18:41.480]  $ ...future.FUN:function (x, y)  
[16:18:41.480]  $ MoreArgs     : list()
[16:18:41.480]  - attr(*, "where")=List of 2
[16:18:41.480]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:41.480]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:41.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.480]  - attr(*, "resolved")= logi FALSE
[16:18:41.480]  - attr(*, "total_size")= num NA
[16:18:41.483] Packages to be attached in all futures: [n=0] 
[16:18:41.483] getGlobalsAndPackagesXApply() ... DONE
[16:18:41.483] Number of futures (= number of chunks): 2
[16:18:41.484] Launching 2 futures (chunks) ...
[16:18:41.484] Chunk #1 of 2 ...
[16:18:41.484]  - Finding globals in '...' for chunk #1 ...
[16:18:41.484] getGlobalsAndPackages() ...
[16:18:41.484] Searching for globals...
[16:18:41.484] 
[16:18:41.485] Searching for globals ... DONE
[16:18:41.485] - globals: [0] <none>
[16:18:41.485] getGlobalsAndPackages() ... DONE
[16:18:41.485]    + additional globals found: [n=0] 
[16:18:41.485]    + additional namespaces needed: [n=0] 
[16:18:41.485]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:41.485]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.485]  - seeds: <none>
[16:18:41.485]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.485] getGlobalsAndPackages() ...
[16:18:41.485] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.486] Resolving globals: FALSE
[16:18:41.486] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[16:18:41.487] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:41.487] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.487] 
[16:18:41.487] getGlobalsAndPackages() ... DONE
[16:18:41.489] run() for ‘Future’ ...
[16:18:41.489] - state: ‘created’
[16:18:41.490] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.493] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.494] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.494]   - Field: ‘label’
[16:18:41.494]   - Field: ‘local’
[16:18:41.494]   - Field: ‘owner’
[16:18:41.494]   - Field: ‘envir’
[16:18:41.494]   - Field: ‘workers’
[16:18:41.494]   - Field: ‘packages’
[16:18:41.494]   - Field: ‘gc’
[16:18:41.494]   - Field: ‘job’
[16:18:41.495]   - Field: ‘conditions’
[16:18:41.495]   - Field: ‘expr’
[16:18:41.495]   - Field: ‘uuid’
[16:18:41.495]   - Field: ‘seed’
[16:18:41.495]   - Field: ‘version’
[16:18:41.495]   - Field: ‘result’
[16:18:41.495]   - Field: ‘asynchronous’
[16:18:41.495]   - Field: ‘calls’
[16:18:41.495]   - Field: ‘globals’
[16:18:41.495]   - Field: ‘stdout’
[16:18:41.496]   - Field: ‘earlySignal’
[16:18:41.496]   - Field: ‘lazy’
[16:18:41.496]   - Field: ‘state’
[16:18:41.496] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.496] - Launch lazy future ...
[16:18:41.496] Packages needed by the future expression (n = 0): <none>
[16:18:41.496] Packages needed by future strategies (n = 0): <none>
[16:18:41.497] {
[16:18:41.497]     {
[16:18:41.497]         {
[16:18:41.497]             ...future.startTime <- base::Sys.time()
[16:18:41.497]             {
[16:18:41.497]                 {
[16:18:41.497]                   {
[16:18:41.497]                     {
[16:18:41.497]                       base::local({
[16:18:41.497]                         has_future <- base::requireNamespace("future", 
[16:18:41.497]                           quietly = TRUE)
[16:18:41.497]                         if (has_future) {
[16:18:41.497]                           ns <- base::getNamespace("future")
[16:18:41.497]                           version <- ns[[".package"]][["version"]]
[16:18:41.497]                           if (is.null(version)) 
[16:18:41.497]                             version <- utils::packageVersion("future")
[16:18:41.497]                         }
[16:18:41.497]                         else {
[16:18:41.497]                           version <- NULL
[16:18:41.497]                         }
[16:18:41.497]                         if (!has_future || version < "1.8.0") {
[16:18:41.497]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.497]                             "", base::R.version$version.string), 
[16:18:41.497]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.497]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.497]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.497]                               "release", "version")], collapse = " "), 
[16:18:41.497]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.497]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.497]                             info)
[16:18:41.497]                           info <- base::paste(info, collapse = "; ")
[16:18:41.497]                           if (!has_future) {
[16:18:41.497]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.497]                               info)
[16:18:41.497]                           }
[16:18:41.497]                           else {
[16:18:41.497]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.497]                               info, version)
[16:18:41.497]                           }
[16:18:41.497]                           base::stop(msg)
[16:18:41.497]                         }
[16:18:41.497]                       })
[16:18:41.497]                     }
[16:18:41.497]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.497]                     base::options(mc.cores = 1L)
[16:18:41.497]                   }
[16:18:41.497]                   ...future.strategy.old <- future::plan("list")
[16:18:41.497]                   options(future.plan = NULL)
[16:18:41.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.497]                 }
[16:18:41.497]                 ...future.workdir <- getwd()
[16:18:41.497]             }
[16:18:41.497]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.497]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.497]         }
[16:18:41.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.497]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.497]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.497]             base::names(...future.oldOptions))
[16:18:41.497]     }
[16:18:41.497]     if (FALSE) {
[16:18:41.497]     }
[16:18:41.497]     else {
[16:18:41.497]         if (TRUE) {
[16:18:41.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.497]                 open = "w")
[16:18:41.497]         }
[16:18:41.497]         else {
[16:18:41.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.497]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.497]         }
[16:18:41.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.497]             base::sink(type = "output", split = FALSE)
[16:18:41.497]             base::close(...future.stdout)
[16:18:41.497]         }, add = TRUE)
[16:18:41.497]     }
[16:18:41.497]     ...future.frame <- base::sys.nframe()
[16:18:41.497]     ...future.conditions <- base::list()
[16:18:41.497]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.497]     if (FALSE) {
[16:18:41.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.497]     }
[16:18:41.497]     ...future.result <- base::tryCatch({
[16:18:41.497]         base::withCallingHandlers({
[16:18:41.497]             ...future.value <- base::withVisible(base::local({
[16:18:41.497]                 withCallingHandlers({
[16:18:41.497]                   {
[16:18:41.497]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.497]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.497]                       ...future.globals.maxSize)) {
[16:18:41.497]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.497]                       on.exit(options(oopts), add = TRUE)
[16:18:41.497]                     }
[16:18:41.497]                     {
[16:18:41.497]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.497]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.497]                         USE.NAMES = FALSE)
[16:18:41.497]                       do.call(mapply, args = args)
[16:18:41.497]                     }
[16:18:41.497]                   }
[16:18:41.497]                 }, immediateCondition = function(cond) {
[16:18:41.497]                   save_rds <- function (object, pathname, ...) 
[16:18:41.497]                   {
[16:18:41.497]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.497]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.497]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.497]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.497]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.497]                         fi_tmp[["mtime"]])
[16:18:41.497]                     }
[16:18:41.497]                     tryCatch({
[16:18:41.497]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.497]                     }, error = function(ex) {
[16:18:41.497]                       msg <- conditionMessage(ex)
[16:18:41.497]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.497]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.497]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.497]                         fi_tmp[["mtime"]], msg)
[16:18:41.497]                       ex$message <- msg
[16:18:41.497]                       stop(ex)
[16:18:41.497]                     })
[16:18:41.497]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.497]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.497]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.497]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.497]                       fi <- file.info(pathname)
[16:18:41.497]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.497]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.497]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.497]                         fi[["size"]], fi[["mtime"]])
[16:18:41.497]                       stop(msg)
[16:18:41.497]                     }
[16:18:41.497]                     invisible(pathname)
[16:18:41.497]                   }
[16:18:41.497]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.497]                     rootPath = tempdir()) 
[16:18:41.497]                   {
[16:18:41.497]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.497]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.497]                       tmpdir = path, fileext = ".rds")
[16:18:41.497]                     save_rds(obj, file)
[16:18:41.497]                   }
[16:18:41.497]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.497]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.497]                   {
[16:18:41.497]                     inherits <- base::inherits
[16:18:41.497]                     invokeRestart <- base::invokeRestart
[16:18:41.497]                     is.null <- base::is.null
[16:18:41.497]                     muffled <- FALSE
[16:18:41.497]                     if (inherits(cond, "message")) {
[16:18:41.497]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.497]                       if (muffled) 
[16:18:41.497]                         invokeRestart("muffleMessage")
[16:18:41.497]                     }
[16:18:41.497]                     else if (inherits(cond, "warning")) {
[16:18:41.497]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.497]                       if (muffled) 
[16:18:41.497]                         invokeRestart("muffleWarning")
[16:18:41.497]                     }
[16:18:41.497]                     else if (inherits(cond, "condition")) {
[16:18:41.497]                       if (!is.null(pattern)) {
[16:18:41.497]                         computeRestarts <- base::computeRestarts
[16:18:41.497]                         grepl <- base::grepl
[16:18:41.497]                         restarts <- computeRestarts(cond)
[16:18:41.497]                         for (restart in restarts) {
[16:18:41.497]                           name <- restart$name
[16:18:41.497]                           if (is.null(name)) 
[16:18:41.497]                             next
[16:18:41.497]                           if (!grepl(pattern, name)) 
[16:18:41.497]                             next
[16:18:41.497]                           invokeRestart(restart)
[16:18:41.497]                           muffled <- TRUE
[16:18:41.497]                           break
[16:18:41.497]                         }
[16:18:41.497]                       }
[16:18:41.497]                     }
[16:18:41.497]                     invisible(muffled)
[16:18:41.497]                   }
[16:18:41.497]                   muffleCondition(cond)
[16:18:41.497]                 })
[16:18:41.497]             }))
[16:18:41.497]             future::FutureResult(value = ...future.value$value, 
[16:18:41.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.497]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.497]                     ...future.globalenv.names))
[16:18:41.497]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.497]         }, condition = base::local({
[16:18:41.497]             c <- base::c
[16:18:41.497]             inherits <- base::inherits
[16:18:41.497]             invokeRestart <- base::invokeRestart
[16:18:41.497]             length <- base::length
[16:18:41.497]             list <- base::list
[16:18:41.497]             seq.int <- base::seq.int
[16:18:41.497]             signalCondition <- base::signalCondition
[16:18:41.497]             sys.calls <- base::sys.calls
[16:18:41.497]             `[[` <- base::`[[`
[16:18:41.497]             `+` <- base::`+`
[16:18:41.497]             `<<-` <- base::`<<-`
[16:18:41.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.497]                   3L)]
[16:18:41.497]             }
[16:18:41.497]             function(cond) {
[16:18:41.497]                 is_error <- inherits(cond, "error")
[16:18:41.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.497]                   NULL)
[16:18:41.497]                 if (is_error) {
[16:18:41.497]                   sessionInformation <- function() {
[16:18:41.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.497]                       search = base::search(), system = base::Sys.info())
[16:18:41.497]                   }
[16:18:41.497]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.497]                     cond$call), session = sessionInformation(), 
[16:18:41.497]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.497]                   signalCondition(cond)
[16:18:41.497]                 }
[16:18:41.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.497]                 "immediateCondition"))) {
[16:18:41.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.497]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.497]                   if (TRUE && !signal) {
[16:18:41.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.497]                     {
[16:18:41.497]                       inherits <- base::inherits
[16:18:41.497]                       invokeRestart <- base::invokeRestart
[16:18:41.497]                       is.null <- base::is.null
[16:18:41.497]                       muffled <- FALSE
[16:18:41.497]                       if (inherits(cond, "message")) {
[16:18:41.497]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.497]                         if (muffled) 
[16:18:41.497]                           invokeRestart("muffleMessage")
[16:18:41.497]                       }
[16:18:41.497]                       else if (inherits(cond, "warning")) {
[16:18:41.497]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.497]                         if (muffled) 
[16:18:41.497]                           invokeRestart("muffleWarning")
[16:18:41.497]                       }
[16:18:41.497]                       else if (inherits(cond, "condition")) {
[16:18:41.497]                         if (!is.null(pattern)) {
[16:18:41.497]                           computeRestarts <- base::computeRestarts
[16:18:41.497]                           grepl <- base::grepl
[16:18:41.497]                           restarts <- computeRestarts(cond)
[16:18:41.497]                           for (restart in restarts) {
[16:18:41.497]                             name <- restart$name
[16:18:41.497]                             if (is.null(name)) 
[16:18:41.497]                               next
[16:18:41.497]                             if (!grepl(pattern, name)) 
[16:18:41.497]                               next
[16:18:41.497]                             invokeRestart(restart)
[16:18:41.497]                             muffled <- TRUE
[16:18:41.497]                             break
[16:18:41.497]                           }
[16:18:41.497]                         }
[16:18:41.497]                       }
[16:18:41.497]                       invisible(muffled)
[16:18:41.497]                     }
[16:18:41.497]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.497]                   }
[16:18:41.497]                 }
[16:18:41.497]                 else {
[16:18:41.497]                   if (TRUE) {
[16:18:41.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.497]                     {
[16:18:41.497]                       inherits <- base::inherits
[16:18:41.497]                       invokeRestart <- base::invokeRestart
[16:18:41.497]                       is.null <- base::is.null
[16:18:41.497]                       muffled <- FALSE
[16:18:41.497]                       if (inherits(cond, "message")) {
[16:18:41.497]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.497]                         if (muffled) 
[16:18:41.497]                           invokeRestart("muffleMessage")
[16:18:41.497]                       }
[16:18:41.497]                       else if (inherits(cond, "warning")) {
[16:18:41.497]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.497]                         if (muffled) 
[16:18:41.497]                           invokeRestart("muffleWarning")
[16:18:41.497]                       }
[16:18:41.497]                       else if (inherits(cond, "condition")) {
[16:18:41.497]                         if (!is.null(pattern)) {
[16:18:41.497]                           computeRestarts <- base::computeRestarts
[16:18:41.497]                           grepl <- base::grepl
[16:18:41.497]                           restarts <- computeRestarts(cond)
[16:18:41.497]                           for (restart in restarts) {
[16:18:41.497]                             name <- restart$name
[16:18:41.497]                             if (is.null(name)) 
[16:18:41.497]                               next
[16:18:41.497]                             if (!grepl(pattern, name)) 
[16:18:41.497]                               next
[16:18:41.497]                             invokeRestart(restart)
[16:18:41.497]                             muffled <- TRUE
[16:18:41.497]                             break
[16:18:41.497]                           }
[16:18:41.497]                         }
[16:18:41.497]                       }
[16:18:41.497]                       invisible(muffled)
[16:18:41.497]                     }
[16:18:41.497]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.497]                   }
[16:18:41.497]                 }
[16:18:41.497]             }
[16:18:41.497]         }))
[16:18:41.497]     }, error = function(ex) {
[16:18:41.497]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.497]                 ...future.rng), started = ...future.startTime, 
[16:18:41.497]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.497]             version = "1.8"), class = "FutureResult")
[16:18:41.497]     }, finally = {
[16:18:41.497]         if (!identical(...future.workdir, getwd())) 
[16:18:41.497]             setwd(...future.workdir)
[16:18:41.497]         {
[16:18:41.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.497]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.497]             }
[16:18:41.497]             base::options(...future.oldOptions)
[16:18:41.497]             if (.Platform$OS.type == "windows") {
[16:18:41.497]                 old_names <- names(...future.oldEnvVars)
[16:18:41.497]                 envs <- base::Sys.getenv()
[16:18:41.497]                 names <- names(envs)
[16:18:41.497]                 common <- intersect(names, old_names)
[16:18:41.497]                 added <- setdiff(names, old_names)
[16:18:41.497]                 removed <- setdiff(old_names, names)
[16:18:41.497]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.497]                   envs[common]]
[16:18:41.497]                 NAMES <- toupper(changed)
[16:18:41.497]                 args <- list()
[16:18:41.497]                 for (kk in seq_along(NAMES)) {
[16:18:41.497]                   name <- changed[[kk]]
[16:18:41.497]                   NAME <- NAMES[[kk]]
[16:18:41.497]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.497]                     next
[16:18:41.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.497]                 }
[16:18:41.497]                 NAMES <- toupper(added)
[16:18:41.497]                 for (kk in seq_along(NAMES)) {
[16:18:41.497]                   name <- added[[kk]]
[16:18:41.497]                   NAME <- NAMES[[kk]]
[16:18:41.497]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.497]                     next
[16:18:41.497]                   args[[name]] <- ""
[16:18:41.497]                 }
[16:18:41.497]                 NAMES <- toupper(removed)
[16:18:41.497]                 for (kk in seq_along(NAMES)) {
[16:18:41.497]                   name <- removed[[kk]]
[16:18:41.497]                   NAME <- NAMES[[kk]]
[16:18:41.497]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.497]                     next
[16:18:41.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.497]                 }
[16:18:41.497]                 if (length(args) > 0) 
[16:18:41.497]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.497]             }
[16:18:41.497]             else {
[16:18:41.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.497]             }
[16:18:41.497]             {
[16:18:41.497]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.497]                   0L) {
[16:18:41.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.497]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.497]                   base::options(opts)
[16:18:41.497]                 }
[16:18:41.497]                 {
[16:18:41.497]                   {
[16:18:41.497]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.497]                     NULL
[16:18:41.497]                   }
[16:18:41.497]                   options(future.plan = NULL)
[16:18:41.497]                   if (is.na(NA_character_)) 
[16:18:41.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.497]                     .init = FALSE)
[16:18:41.497]                 }
[16:18:41.497]             }
[16:18:41.497]         }
[16:18:41.497]     })
[16:18:41.497]     if (TRUE) {
[16:18:41.497]         base::sink(type = "output", split = FALSE)
[16:18:41.497]         if (TRUE) {
[16:18:41.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.497]         }
[16:18:41.497]         else {
[16:18:41.497]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.497]         }
[16:18:41.497]         base::close(...future.stdout)
[16:18:41.497]         ...future.stdout <- NULL
[16:18:41.497]     }
[16:18:41.497]     ...future.result$conditions <- ...future.conditions
[16:18:41.497]     ...future.result$finished <- base::Sys.time()
[16:18:41.497]     ...future.result
[16:18:41.497] }
[16:18:41.499] assign_globals() ...
[16:18:41.499] List of 5
[16:18:41.499]  $ ...future.FUN            :function (x, y)  
[16:18:41.499]  $ MoreArgs                 : list()
[16:18:41.499]  $ ...future.elements_ii    :List of 2
[16:18:41.499]   ..$ :List of 1
[16:18:41.499]   .. ..$ a: num 1
[16:18:41.499]   ..$ :List of 1
[16:18:41.499]   .. ..$ A: num 10
[16:18:41.499]  $ ...future.seeds_ii       : NULL
[16:18:41.499]  $ ...future.globals.maxSize: NULL
[16:18:41.499]  - attr(*, "where")=List of 5
[16:18:41.499]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.499]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.499]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.499]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.499]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.499]  - attr(*, "resolved")= logi FALSE
[16:18:41.499]  - attr(*, "total_size")= num 2088
[16:18:41.499]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.499]  - attr(*, "already-done")= logi TRUE
[16:18:41.504] - reassign environment for ‘...future.FUN’
[16:18:41.504] - copied ‘...future.FUN’ to environment
[16:18:41.504] - copied ‘MoreArgs’ to environment
[16:18:41.505] - copied ‘...future.elements_ii’ to environment
[16:18:41.505] - copied ‘...future.seeds_ii’ to environment
[16:18:41.505] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.505] assign_globals() ... done
[16:18:41.505] requestCore(): workers = 2
[16:18:41.507] MulticoreFuture started
[16:18:41.507] - Launch lazy future ... done
[16:18:41.508] run() for ‘MulticoreFuture’ ... done
[16:18:41.508] Created future:
[16:18:41.508] plan(): Setting new future strategy stack:
[16:18:41.509] List of future strategies:
[16:18:41.509] 1. sequential:
[16:18:41.509]    - args: function (..., envir = parent.frame())
[16:18:41.509]    - tweaked: FALSE
[16:18:41.509]    - call: NULL
[16:18:41.509] plan(): nbrOfWorkers() = 1
[16:18:41.511] plan(): Setting new future strategy stack:
[16:18:41.512] List of future strategies:
[16:18:41.512] 1. multicore:
[16:18:41.512]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.512]    - tweaked: FALSE
[16:18:41.512]    - call: plan(strategy)
[16:18:41.517] plan(): nbrOfWorkers() = 2
[16:18:41.508] MulticoreFuture:
[16:18:41.508] Label: ‘future_.mapply-1’
[16:18:41.508] Expression:
[16:18:41.508] {
[16:18:41.508]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.508]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.508]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.508]         on.exit(options(oopts), add = TRUE)
[16:18:41.508]     }
[16:18:41.508]     {
[16:18:41.508]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.508]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.508]         do.call(mapply, args = args)
[16:18:41.508]     }
[16:18:41.508] }
[16:18:41.508] Lazy evaluation: FALSE
[16:18:41.508] Asynchronous evaluation: TRUE
[16:18:41.508] Local evaluation: TRUE
[16:18:41.508] Environment: R_GlobalEnv
[16:18:41.508] Capture standard output: TRUE
[16:18:41.508] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.508] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.508] Packages: <none>
[16:18:41.508] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.508] Resolved: TRUE
[16:18:41.508] Value: <not collected>
[16:18:41.508] Conditions captured: <none>
[16:18:41.508] Early signaling: FALSE
[16:18:41.508] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.508] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.518] Chunk #1 of 2 ... DONE
[16:18:41.518] Chunk #2 of 2 ...
[16:18:41.518]  - Finding globals in '...' for chunk #2 ...
[16:18:41.518] getGlobalsAndPackages() ...
[16:18:41.518] Searching for globals...
[16:18:41.519] 
[16:18:41.519] Searching for globals ... DONE
[16:18:41.519] - globals: [0] <none>
[16:18:41.519] getGlobalsAndPackages() ... DONE
[16:18:41.519]    + additional globals found: [n=0] 
[16:18:41.520]    + additional namespaces needed: [n=0] 
[16:18:41.520]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:41.520]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.520]  - seeds: <none>
[16:18:41.520]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.520] getGlobalsAndPackages() ...
[16:18:41.521] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.521] Resolving globals: FALSE
[16:18:41.522] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[16:18:41.522] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:41.523] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.523] 
[16:18:41.523] getGlobalsAndPackages() ... DONE
[16:18:41.523] run() for ‘Future’ ...
[16:18:41.524] - state: ‘created’
[16:18:41.524] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.531] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.532]   - Field: ‘label’
[16:18:41.533]   - Field: ‘local’
[16:18:41.533]   - Field: ‘owner’
[16:18:41.533]   - Field: ‘envir’
[16:18:41.534]   - Field: ‘workers’
[16:18:41.534]   - Field: ‘packages’
[16:18:41.534]   - Field: ‘gc’
[16:18:41.535]   - Field: ‘job’
[16:18:41.535]   - Field: ‘conditions’
[16:18:41.535]   - Field: ‘expr’
[16:18:41.535]   - Field: ‘uuid’
[16:18:41.536]   - Field: ‘seed’
[16:18:41.536]   - Field: ‘version’
[16:18:41.536]   - Field: ‘result’
[16:18:41.536]   - Field: ‘asynchronous’
[16:18:41.537]   - Field: ‘calls’
[16:18:41.537]   - Field: ‘globals’
[16:18:41.537]   - Field: ‘stdout’
[16:18:41.537]   - Field: ‘earlySignal’
[16:18:41.538]   - Field: ‘lazy’
[16:18:41.538]   - Field: ‘state’
[16:18:41.538] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.538] - Launch lazy future ...
[16:18:41.539] Packages needed by the future expression (n = 0): <none>
[16:18:41.539] Packages needed by future strategies (n = 0): <none>
[16:18:41.540] {
[16:18:41.540]     {
[16:18:41.540]         {
[16:18:41.540]             ...future.startTime <- base::Sys.time()
[16:18:41.540]             {
[16:18:41.540]                 {
[16:18:41.540]                   {
[16:18:41.540]                     {
[16:18:41.540]                       base::local({
[16:18:41.540]                         has_future <- base::requireNamespace("future", 
[16:18:41.540]                           quietly = TRUE)
[16:18:41.540]                         if (has_future) {
[16:18:41.540]                           ns <- base::getNamespace("future")
[16:18:41.540]                           version <- ns[[".package"]][["version"]]
[16:18:41.540]                           if (is.null(version)) 
[16:18:41.540]                             version <- utils::packageVersion("future")
[16:18:41.540]                         }
[16:18:41.540]                         else {
[16:18:41.540]                           version <- NULL
[16:18:41.540]                         }
[16:18:41.540]                         if (!has_future || version < "1.8.0") {
[16:18:41.540]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.540]                             "", base::R.version$version.string), 
[16:18:41.540]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.540]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.540]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.540]                               "release", "version")], collapse = " "), 
[16:18:41.540]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.540]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.540]                             info)
[16:18:41.540]                           info <- base::paste(info, collapse = "; ")
[16:18:41.540]                           if (!has_future) {
[16:18:41.540]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.540]                               info)
[16:18:41.540]                           }
[16:18:41.540]                           else {
[16:18:41.540]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.540]                               info, version)
[16:18:41.540]                           }
[16:18:41.540]                           base::stop(msg)
[16:18:41.540]                         }
[16:18:41.540]                       })
[16:18:41.540]                     }
[16:18:41.540]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.540]                     base::options(mc.cores = 1L)
[16:18:41.540]                   }
[16:18:41.540]                   ...future.strategy.old <- future::plan("list")
[16:18:41.540]                   options(future.plan = NULL)
[16:18:41.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.540]                 }
[16:18:41.540]                 ...future.workdir <- getwd()
[16:18:41.540]             }
[16:18:41.540]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.540]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.540]         }
[16:18:41.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.540]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.540]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.540]             base::names(...future.oldOptions))
[16:18:41.540]     }
[16:18:41.540]     if (FALSE) {
[16:18:41.540]     }
[16:18:41.540]     else {
[16:18:41.540]         if (TRUE) {
[16:18:41.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.540]                 open = "w")
[16:18:41.540]         }
[16:18:41.540]         else {
[16:18:41.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.540]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.540]         }
[16:18:41.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.540]             base::sink(type = "output", split = FALSE)
[16:18:41.540]             base::close(...future.stdout)
[16:18:41.540]         }, add = TRUE)
[16:18:41.540]     }
[16:18:41.540]     ...future.frame <- base::sys.nframe()
[16:18:41.540]     ...future.conditions <- base::list()
[16:18:41.540]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.540]     if (FALSE) {
[16:18:41.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.540]     }
[16:18:41.540]     ...future.result <- base::tryCatch({
[16:18:41.540]         base::withCallingHandlers({
[16:18:41.540]             ...future.value <- base::withVisible(base::local({
[16:18:41.540]                 withCallingHandlers({
[16:18:41.540]                   {
[16:18:41.540]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.540]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.540]                       ...future.globals.maxSize)) {
[16:18:41.540]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.540]                       on.exit(options(oopts), add = TRUE)
[16:18:41.540]                     }
[16:18:41.540]                     {
[16:18:41.540]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.540]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.540]                         USE.NAMES = FALSE)
[16:18:41.540]                       do.call(mapply, args = args)
[16:18:41.540]                     }
[16:18:41.540]                   }
[16:18:41.540]                 }, immediateCondition = function(cond) {
[16:18:41.540]                   save_rds <- function (object, pathname, ...) 
[16:18:41.540]                   {
[16:18:41.540]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.540]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.540]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.540]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.540]                         fi_tmp[["mtime"]])
[16:18:41.540]                     }
[16:18:41.540]                     tryCatch({
[16:18:41.540]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.540]                     }, error = function(ex) {
[16:18:41.540]                       msg <- conditionMessage(ex)
[16:18:41.540]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.540]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.540]                         fi_tmp[["mtime"]], msg)
[16:18:41.540]                       ex$message <- msg
[16:18:41.540]                       stop(ex)
[16:18:41.540]                     })
[16:18:41.540]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.540]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.540]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.540]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.540]                       fi <- file.info(pathname)
[16:18:41.540]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.540]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.540]                         fi[["size"]], fi[["mtime"]])
[16:18:41.540]                       stop(msg)
[16:18:41.540]                     }
[16:18:41.540]                     invisible(pathname)
[16:18:41.540]                   }
[16:18:41.540]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.540]                     rootPath = tempdir()) 
[16:18:41.540]                   {
[16:18:41.540]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.540]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.540]                       tmpdir = path, fileext = ".rds")
[16:18:41.540]                     save_rds(obj, file)
[16:18:41.540]                   }
[16:18:41.540]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.540]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.540]                   {
[16:18:41.540]                     inherits <- base::inherits
[16:18:41.540]                     invokeRestart <- base::invokeRestart
[16:18:41.540]                     is.null <- base::is.null
[16:18:41.540]                     muffled <- FALSE
[16:18:41.540]                     if (inherits(cond, "message")) {
[16:18:41.540]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.540]                       if (muffled) 
[16:18:41.540]                         invokeRestart("muffleMessage")
[16:18:41.540]                     }
[16:18:41.540]                     else if (inherits(cond, "warning")) {
[16:18:41.540]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.540]                       if (muffled) 
[16:18:41.540]                         invokeRestart("muffleWarning")
[16:18:41.540]                     }
[16:18:41.540]                     else if (inherits(cond, "condition")) {
[16:18:41.540]                       if (!is.null(pattern)) {
[16:18:41.540]                         computeRestarts <- base::computeRestarts
[16:18:41.540]                         grepl <- base::grepl
[16:18:41.540]                         restarts <- computeRestarts(cond)
[16:18:41.540]                         for (restart in restarts) {
[16:18:41.540]                           name <- restart$name
[16:18:41.540]                           if (is.null(name)) 
[16:18:41.540]                             next
[16:18:41.540]                           if (!grepl(pattern, name)) 
[16:18:41.540]                             next
[16:18:41.540]                           invokeRestart(restart)
[16:18:41.540]                           muffled <- TRUE
[16:18:41.540]                           break
[16:18:41.540]                         }
[16:18:41.540]                       }
[16:18:41.540]                     }
[16:18:41.540]                     invisible(muffled)
[16:18:41.540]                   }
[16:18:41.540]                   muffleCondition(cond)
[16:18:41.540]                 })
[16:18:41.540]             }))
[16:18:41.540]             future::FutureResult(value = ...future.value$value, 
[16:18:41.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.540]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.540]                     ...future.globalenv.names))
[16:18:41.540]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.540]         }, condition = base::local({
[16:18:41.540]             c <- base::c
[16:18:41.540]             inherits <- base::inherits
[16:18:41.540]             invokeRestart <- base::invokeRestart
[16:18:41.540]             length <- base::length
[16:18:41.540]             list <- base::list
[16:18:41.540]             seq.int <- base::seq.int
[16:18:41.540]             signalCondition <- base::signalCondition
[16:18:41.540]             sys.calls <- base::sys.calls
[16:18:41.540]             `[[` <- base::`[[`
[16:18:41.540]             `+` <- base::`+`
[16:18:41.540]             `<<-` <- base::`<<-`
[16:18:41.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.540]                   3L)]
[16:18:41.540]             }
[16:18:41.540]             function(cond) {
[16:18:41.540]                 is_error <- inherits(cond, "error")
[16:18:41.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.540]                   NULL)
[16:18:41.540]                 if (is_error) {
[16:18:41.540]                   sessionInformation <- function() {
[16:18:41.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.540]                       search = base::search(), system = base::Sys.info())
[16:18:41.540]                   }
[16:18:41.540]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.540]                     cond$call), session = sessionInformation(), 
[16:18:41.540]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.540]                   signalCondition(cond)
[16:18:41.540]                 }
[16:18:41.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.540]                 "immediateCondition"))) {
[16:18:41.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.540]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.540]                   if (TRUE && !signal) {
[16:18:41.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.540]                     {
[16:18:41.540]                       inherits <- base::inherits
[16:18:41.540]                       invokeRestart <- base::invokeRestart
[16:18:41.540]                       is.null <- base::is.null
[16:18:41.540]                       muffled <- FALSE
[16:18:41.540]                       if (inherits(cond, "message")) {
[16:18:41.540]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.540]                         if (muffled) 
[16:18:41.540]                           invokeRestart("muffleMessage")
[16:18:41.540]                       }
[16:18:41.540]                       else if (inherits(cond, "warning")) {
[16:18:41.540]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.540]                         if (muffled) 
[16:18:41.540]                           invokeRestart("muffleWarning")
[16:18:41.540]                       }
[16:18:41.540]                       else if (inherits(cond, "condition")) {
[16:18:41.540]                         if (!is.null(pattern)) {
[16:18:41.540]                           computeRestarts <- base::computeRestarts
[16:18:41.540]                           grepl <- base::grepl
[16:18:41.540]                           restarts <- computeRestarts(cond)
[16:18:41.540]                           for (restart in restarts) {
[16:18:41.540]                             name <- restart$name
[16:18:41.540]                             if (is.null(name)) 
[16:18:41.540]                               next
[16:18:41.540]                             if (!grepl(pattern, name)) 
[16:18:41.540]                               next
[16:18:41.540]                             invokeRestart(restart)
[16:18:41.540]                             muffled <- TRUE
[16:18:41.540]                             break
[16:18:41.540]                           }
[16:18:41.540]                         }
[16:18:41.540]                       }
[16:18:41.540]                       invisible(muffled)
[16:18:41.540]                     }
[16:18:41.540]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.540]                   }
[16:18:41.540]                 }
[16:18:41.540]                 else {
[16:18:41.540]                   if (TRUE) {
[16:18:41.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.540]                     {
[16:18:41.540]                       inherits <- base::inherits
[16:18:41.540]                       invokeRestart <- base::invokeRestart
[16:18:41.540]                       is.null <- base::is.null
[16:18:41.540]                       muffled <- FALSE
[16:18:41.540]                       if (inherits(cond, "message")) {
[16:18:41.540]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.540]                         if (muffled) 
[16:18:41.540]                           invokeRestart("muffleMessage")
[16:18:41.540]                       }
[16:18:41.540]                       else if (inherits(cond, "warning")) {
[16:18:41.540]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.540]                         if (muffled) 
[16:18:41.540]                           invokeRestart("muffleWarning")
[16:18:41.540]                       }
[16:18:41.540]                       else if (inherits(cond, "condition")) {
[16:18:41.540]                         if (!is.null(pattern)) {
[16:18:41.540]                           computeRestarts <- base::computeRestarts
[16:18:41.540]                           grepl <- base::grepl
[16:18:41.540]                           restarts <- computeRestarts(cond)
[16:18:41.540]                           for (restart in restarts) {
[16:18:41.540]                             name <- restart$name
[16:18:41.540]                             if (is.null(name)) 
[16:18:41.540]                               next
[16:18:41.540]                             if (!grepl(pattern, name)) 
[16:18:41.540]                               next
[16:18:41.540]                             invokeRestart(restart)
[16:18:41.540]                             muffled <- TRUE
[16:18:41.540]                             break
[16:18:41.540]                           }
[16:18:41.540]                         }
[16:18:41.540]                       }
[16:18:41.540]                       invisible(muffled)
[16:18:41.540]                     }
[16:18:41.540]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.540]                   }
[16:18:41.540]                 }
[16:18:41.540]             }
[16:18:41.540]         }))
[16:18:41.540]     }, error = function(ex) {
[16:18:41.540]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.540]                 ...future.rng), started = ...future.startTime, 
[16:18:41.540]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.540]             version = "1.8"), class = "FutureResult")
[16:18:41.540]     }, finally = {
[16:18:41.540]         if (!identical(...future.workdir, getwd())) 
[16:18:41.540]             setwd(...future.workdir)
[16:18:41.540]         {
[16:18:41.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.540]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.540]             }
[16:18:41.540]             base::options(...future.oldOptions)
[16:18:41.540]             if (.Platform$OS.type == "windows") {
[16:18:41.540]                 old_names <- names(...future.oldEnvVars)
[16:18:41.540]                 envs <- base::Sys.getenv()
[16:18:41.540]                 names <- names(envs)
[16:18:41.540]                 common <- intersect(names, old_names)
[16:18:41.540]                 added <- setdiff(names, old_names)
[16:18:41.540]                 removed <- setdiff(old_names, names)
[16:18:41.540]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.540]                   envs[common]]
[16:18:41.540]                 NAMES <- toupper(changed)
[16:18:41.540]                 args <- list()
[16:18:41.540]                 for (kk in seq_along(NAMES)) {
[16:18:41.540]                   name <- changed[[kk]]
[16:18:41.540]                   NAME <- NAMES[[kk]]
[16:18:41.540]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.540]                     next
[16:18:41.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.540]                 }
[16:18:41.540]                 NAMES <- toupper(added)
[16:18:41.540]                 for (kk in seq_along(NAMES)) {
[16:18:41.540]                   name <- added[[kk]]
[16:18:41.540]                   NAME <- NAMES[[kk]]
[16:18:41.540]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.540]                     next
[16:18:41.540]                   args[[name]] <- ""
[16:18:41.540]                 }
[16:18:41.540]                 NAMES <- toupper(removed)
[16:18:41.540]                 for (kk in seq_along(NAMES)) {
[16:18:41.540]                   name <- removed[[kk]]
[16:18:41.540]                   NAME <- NAMES[[kk]]
[16:18:41.540]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.540]                     next
[16:18:41.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.540]                 }
[16:18:41.540]                 if (length(args) > 0) 
[16:18:41.540]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.540]             }
[16:18:41.540]             else {
[16:18:41.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.540]             }
[16:18:41.540]             {
[16:18:41.540]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.540]                   0L) {
[16:18:41.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.540]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.540]                   base::options(opts)
[16:18:41.540]                 }
[16:18:41.540]                 {
[16:18:41.540]                   {
[16:18:41.540]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.540]                     NULL
[16:18:41.540]                   }
[16:18:41.540]                   options(future.plan = NULL)
[16:18:41.540]                   if (is.na(NA_character_)) 
[16:18:41.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.540]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.540]                     .init = FALSE)
[16:18:41.540]                 }
[16:18:41.540]             }
[16:18:41.540]         }
[16:18:41.540]     })
[16:18:41.540]     if (TRUE) {
[16:18:41.540]         base::sink(type = "output", split = FALSE)
[16:18:41.540]         if (TRUE) {
[16:18:41.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.540]         }
[16:18:41.540]         else {
[16:18:41.540]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.540]         }
[16:18:41.540]         base::close(...future.stdout)
[16:18:41.540]         ...future.stdout <- NULL
[16:18:41.540]     }
[16:18:41.540]     ...future.result$conditions <- ...future.conditions
[16:18:41.540]     ...future.result$finished <- base::Sys.time()
[16:18:41.540]     ...future.result
[16:18:41.540] }
[16:18:41.543] assign_globals() ...
[16:18:41.543] List of 5
[16:18:41.543]  $ ...future.FUN            :function (x, y)  
[16:18:41.543]  $ MoreArgs                 : list()
[16:18:41.543]  $ ...future.elements_ii    :List of 2
[16:18:41.543]   ..$ :List of 2
[16:18:41.543]   .. ..$ b: num 2
[16:18:41.543]   .. ..$ c: num 3
[16:18:41.543]   ..$ :List of 2
[16:18:41.543]   .. ..$ B: num 0
[16:18:41.543]   .. ..$ C: num -10
[16:18:41.543]  $ ...future.seeds_ii       : NULL
[16:18:41.543]  $ ...future.globals.maxSize: NULL
[16:18:41.543]  - attr(*, "where")=List of 5
[16:18:41.543]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.543]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.543]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.543]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.543]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.543]  - attr(*, "resolved")= logi FALSE
[16:18:41.543]  - attr(*, "total_size")= num 2200
[16:18:41.543]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.543]  - attr(*, "already-done")= logi TRUE
[16:18:41.551] - reassign environment for ‘...future.FUN’
[16:18:41.552] - copied ‘...future.FUN’ to environment
[16:18:41.552] - copied ‘MoreArgs’ to environment
[16:18:41.552] - copied ‘...future.elements_ii’ to environment
[16:18:41.552] - copied ‘...future.seeds_ii’ to environment
[16:18:41.552] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.552] assign_globals() ... done
[16:18:41.552] requestCore(): workers = 2
[16:18:41.555] MulticoreFuture started
[16:18:41.555] - Launch lazy future ... done
[16:18:41.555] run() for ‘MulticoreFuture’ ... done
[16:18:41.556] Created future:
[16:18:41.556] plan(): Setting new future strategy stack:
[16:18:41.556] List of future strategies:
[16:18:41.556] 1. sequential:
[16:18:41.556]    - args: function (..., envir = parent.frame())
[16:18:41.556]    - tweaked: FALSE
[16:18:41.556]    - call: NULL
[16:18:41.557] plan(): nbrOfWorkers() = 1
[16:18:41.559] plan(): Setting new future strategy stack:
[16:18:41.559] List of future strategies:
[16:18:41.559] 1. multicore:
[16:18:41.559]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.559]    - tweaked: FALSE
[16:18:41.559]    - call: plan(strategy)
[16:18:41.565] plan(): nbrOfWorkers() = 2
[16:18:41.556] MulticoreFuture:
[16:18:41.556] Label: ‘future_.mapply-2’
[16:18:41.556] Expression:
[16:18:41.556] {
[16:18:41.556]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.556]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.556]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.556]         on.exit(options(oopts), add = TRUE)
[16:18:41.556]     }
[16:18:41.556]     {
[16:18:41.556]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.556]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.556]         do.call(mapply, args = args)
[16:18:41.556]     }
[16:18:41.556] }
[16:18:41.556] Lazy evaluation: FALSE
[16:18:41.556] Asynchronous evaluation: TRUE
[16:18:41.556] Local evaluation: TRUE
[16:18:41.556] Environment: R_GlobalEnv
[16:18:41.556] Capture standard output: TRUE
[16:18:41.556] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.556] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.556] Packages: <none>
[16:18:41.556] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.556] Resolved: TRUE
[16:18:41.556] Value: <not collected>
[16:18:41.556] Conditions captured: <none>
[16:18:41.556] Early signaling: FALSE
[16:18:41.556] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.556] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.566] Chunk #2 of 2 ... DONE
[16:18:41.566] Launching 2 futures (chunks) ... DONE
[16:18:41.566] Resolving 2 futures (chunks) ...
[16:18:41.567] resolve() on list ...
[16:18:41.567]  recursive: 0
[16:18:41.567]  length: 2
[16:18:41.567] 
[16:18:41.567] Future #1
[16:18:41.567] result() for MulticoreFuture ...
[16:18:41.568] result() for MulticoreFuture ...
[16:18:41.568] result() for MulticoreFuture ... done
[16:18:41.569] result() for MulticoreFuture ... done
[16:18:41.569] result() for MulticoreFuture ...
[16:18:41.569] result() for MulticoreFuture ... done
[16:18:41.569] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:41.569] - nx: 2
[16:18:41.569] - relay: TRUE
[16:18:41.570] - stdout: TRUE
[16:18:41.570] - signal: TRUE
[16:18:41.570] - resignal: FALSE
[16:18:41.570] - force: TRUE
[16:18:41.570] - relayed: [n=2] FALSE, FALSE
[16:18:41.570] - queued futures: [n=2] FALSE, FALSE
[16:18:41.571]  - until=1
[16:18:41.571]  - relaying element #1
[16:18:41.571] result() for MulticoreFuture ...
[16:18:41.571] result() for MulticoreFuture ... done
[16:18:41.571] result() for MulticoreFuture ...
[16:18:41.571] result() for MulticoreFuture ... done
[16:18:41.572] result() for MulticoreFuture ...
[16:18:41.572] result() for MulticoreFuture ... done
[16:18:41.572] result() for MulticoreFuture ...
[16:18:41.572] result() for MulticoreFuture ... done
[16:18:41.572] - relayed: [n=2] TRUE, FALSE
[16:18:41.572] - queued futures: [n=2] TRUE, FALSE
[16:18:41.572] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:41.573]  length: 1 (resolved future 1)
[16:18:41.573] Future #2
[16:18:41.573] result() for MulticoreFuture ...
[16:18:41.574] result() for MulticoreFuture ...
[16:18:41.574] result() for MulticoreFuture ... done
[16:18:41.574] result() for MulticoreFuture ... done
[16:18:41.574] result() for MulticoreFuture ...
[16:18:41.574] result() for MulticoreFuture ... done
[16:18:41.575] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:41.575] - nx: 2
[16:18:41.575] - relay: TRUE
[16:18:41.575] - stdout: TRUE
[16:18:41.575] - signal: TRUE
[16:18:41.575] - resignal: FALSE
[16:18:41.575] - force: TRUE
[16:18:41.582] - relayed: [n=2] TRUE, FALSE
[16:18:41.582] - queued futures: [n=2] TRUE, FALSE
[16:18:41.582]  - until=2
[16:18:41.582]  - relaying element #2
[16:18:41.582] result() for MulticoreFuture ...
[16:18:41.583] result() for MulticoreFuture ... done
[16:18:41.583] result() for MulticoreFuture ...
[16:18:41.583] result() for MulticoreFuture ... done
[16:18:41.583] result() for MulticoreFuture ...
[16:18:41.583] result() for MulticoreFuture ... done
[16:18:41.583] result() for MulticoreFuture ...
[16:18:41.583] result() for MulticoreFuture ... done
[16:18:41.583] - relayed: [n=2] TRUE, TRUE
[16:18:41.583] - queued futures: [n=2] TRUE, TRUE
[16:18:41.583] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:41.584]  length: 0 (resolved future 2)
[16:18:41.584] Relaying remaining futures
[16:18:41.584] signalConditionsASAP(NULL, pos=0) ...
[16:18:41.584] - nx: 2
[16:18:41.584] - relay: TRUE
[16:18:41.584] - stdout: TRUE
[16:18:41.584] - signal: TRUE
[16:18:41.584] - resignal: FALSE
[16:18:41.585] - force: TRUE
[16:18:41.585] - relayed: [n=2] TRUE, TRUE
[16:18:41.585] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:41.585] - relayed: [n=2] TRUE, TRUE
[16:18:41.585] - queued futures: [n=2] TRUE, TRUE
[16:18:41.585] signalConditionsASAP(NULL, pos=0) ... done
[16:18:41.585] resolve() on list ... DONE
[16:18:41.586] result() for MulticoreFuture ...
[16:18:41.586] result() for MulticoreFuture ... done
[16:18:41.586] result() for MulticoreFuture ...
[16:18:41.586] result() for MulticoreFuture ... done
[16:18:41.586] result() for MulticoreFuture ...
[16:18:41.586] result() for MulticoreFuture ... done
[16:18:41.586] result() for MulticoreFuture ...
[16:18:41.587] result() for MulticoreFuture ... done
[16:18:41.587]  - Number of value chunks collected: 2
[16:18:41.587] Resolving 2 futures (chunks) ... DONE
[16:18:41.587] Reducing values from 2 chunks ...
[16:18:41.587]  - Number of values collected after concatenation: 3
[16:18:41.587]  - Number of values expected: 3
[16:18:41.587] Reducing values from 2 chunks ... DONE
[16:18:41.588] future_mapply() ... DONE
[16:18:41.588] future_mapply() ...
[16:18:41.592] Number of chunks: 5
[16:18:41.592] getGlobalsAndPackagesXApply() ...
[16:18:41.592]  - future.globals: TRUE
[16:18:41.592] getGlobalsAndPackages() ...
[16:18:41.593] Searching for globals...
[16:18:41.594] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:41.594] Searching for globals ... DONE
[16:18:41.594] Resolving globals: FALSE
[16:18:41.595] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:41.595] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:41.595] - globals: [1] ‘FUN’
[16:18:41.595] 
[16:18:41.596] getGlobalsAndPackages() ... DONE
[16:18:41.596]  - globals found/used: [n=1] ‘FUN’
[16:18:41.596]  - needed namespaces: [n=0] 
[16:18:41.596] Finding globals ... DONE
[16:18:41.596] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:41.596] List of 2
[16:18:41.596]  $ ...future.FUN:function (C, k)  
[16:18:41.596]  $ MoreArgs     : NULL
[16:18:41.596]  - attr(*, "where")=List of 2
[16:18:41.596]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:41.596]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:41.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.596]  - attr(*, "resolved")= logi FALSE
[16:18:41.596]  - attr(*, "total_size")= num NA
[16:18:41.599] Packages to be attached in all futures: [n=0] 
[16:18:41.599] getGlobalsAndPackagesXApply() ... DONE
[16:18:41.599] Number of futures (= number of chunks): 5
[16:18:41.599] Launching 5 futures (chunks) ...
[16:18:41.600] Chunk #1 of 5 ...
[16:18:41.600]  - Finding globals in '...' for chunk #1 ...
[16:18:41.600] getGlobalsAndPackages() ...
[16:18:41.600] Searching for globals...
[16:18:41.600] 
[16:18:41.600] Searching for globals ... DONE
[16:18:41.600] - globals: [0] <none>
[16:18:41.601] getGlobalsAndPackages() ... DONE
[16:18:41.601]    + additional globals found: [n=0] 
[16:18:41.601]    + additional namespaces needed: [n=0] 
[16:18:41.601]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:41.601]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:41.601]  - seeds: <none>
[16:18:41.601]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.601] getGlobalsAndPackages() ...
[16:18:41.601] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.601] Resolving globals: FALSE
[16:18:41.602] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:41.602] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:41.602] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.603] 
[16:18:41.603] getGlobalsAndPackages() ... DONE
[16:18:41.603] run() for ‘Future’ ...
[16:18:41.603] - state: ‘created’
[16:18:41.603] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.607] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.607]   - Field: ‘label’
[16:18:41.607]   - Field: ‘local’
[16:18:41.607]   - Field: ‘owner’
[16:18:41.607]   - Field: ‘envir’
[16:18:41.607]   - Field: ‘workers’
[16:18:41.608]   - Field: ‘packages’
[16:18:41.608]   - Field: ‘gc’
[16:18:41.608]   - Field: ‘job’
[16:18:41.608]   - Field: ‘conditions’
[16:18:41.608]   - Field: ‘expr’
[16:18:41.608]   - Field: ‘uuid’
[16:18:41.608]   - Field: ‘seed’
[16:18:41.608]   - Field: ‘version’
[16:18:41.608]   - Field: ‘result’
[16:18:41.608]   - Field: ‘asynchronous’
[16:18:41.609]   - Field: ‘calls’
[16:18:41.609]   - Field: ‘globals’
[16:18:41.609]   - Field: ‘stdout’
[16:18:41.609]   - Field: ‘earlySignal’
[16:18:41.609]   - Field: ‘lazy’
[16:18:41.609]   - Field: ‘state’
[16:18:41.609] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.609] - Launch lazy future ...
[16:18:41.611] Packages needed by the future expression (n = 0): <none>
[16:18:41.611] Packages needed by future strategies (n = 0): <none>
[16:18:41.612] {
[16:18:41.612]     {
[16:18:41.612]         {
[16:18:41.612]             ...future.startTime <- base::Sys.time()
[16:18:41.612]             {
[16:18:41.612]                 {
[16:18:41.612]                   {
[16:18:41.612]                     {
[16:18:41.612]                       base::local({
[16:18:41.612]                         has_future <- base::requireNamespace("future", 
[16:18:41.612]                           quietly = TRUE)
[16:18:41.612]                         if (has_future) {
[16:18:41.612]                           ns <- base::getNamespace("future")
[16:18:41.612]                           version <- ns[[".package"]][["version"]]
[16:18:41.612]                           if (is.null(version)) 
[16:18:41.612]                             version <- utils::packageVersion("future")
[16:18:41.612]                         }
[16:18:41.612]                         else {
[16:18:41.612]                           version <- NULL
[16:18:41.612]                         }
[16:18:41.612]                         if (!has_future || version < "1.8.0") {
[16:18:41.612]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.612]                             "", base::R.version$version.string), 
[16:18:41.612]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.612]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.612]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.612]                               "release", "version")], collapse = " "), 
[16:18:41.612]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.612]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.612]                             info)
[16:18:41.612]                           info <- base::paste(info, collapse = "; ")
[16:18:41.612]                           if (!has_future) {
[16:18:41.612]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.612]                               info)
[16:18:41.612]                           }
[16:18:41.612]                           else {
[16:18:41.612]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.612]                               info, version)
[16:18:41.612]                           }
[16:18:41.612]                           base::stop(msg)
[16:18:41.612]                         }
[16:18:41.612]                       })
[16:18:41.612]                     }
[16:18:41.612]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.612]                     base::options(mc.cores = 1L)
[16:18:41.612]                   }
[16:18:41.612]                   ...future.strategy.old <- future::plan("list")
[16:18:41.612]                   options(future.plan = NULL)
[16:18:41.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.612]                 }
[16:18:41.612]                 ...future.workdir <- getwd()
[16:18:41.612]             }
[16:18:41.612]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.612]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.612]         }
[16:18:41.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.612]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:41.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.612]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.612]             base::names(...future.oldOptions))
[16:18:41.612]     }
[16:18:41.612]     if (FALSE) {
[16:18:41.612]     }
[16:18:41.612]     else {
[16:18:41.612]         if (TRUE) {
[16:18:41.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.612]                 open = "w")
[16:18:41.612]         }
[16:18:41.612]         else {
[16:18:41.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.612]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.612]         }
[16:18:41.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.612]             base::sink(type = "output", split = FALSE)
[16:18:41.612]             base::close(...future.stdout)
[16:18:41.612]         }, add = TRUE)
[16:18:41.612]     }
[16:18:41.612]     ...future.frame <- base::sys.nframe()
[16:18:41.612]     ...future.conditions <- base::list()
[16:18:41.612]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.612]     if (FALSE) {
[16:18:41.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.612]     }
[16:18:41.612]     ...future.result <- base::tryCatch({
[16:18:41.612]         base::withCallingHandlers({
[16:18:41.612]             ...future.value <- base::withVisible(base::local({
[16:18:41.612]                 withCallingHandlers({
[16:18:41.612]                   {
[16:18:41.612]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.612]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.612]                       ...future.globals.maxSize)) {
[16:18:41.612]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.612]                       on.exit(options(oopts), add = TRUE)
[16:18:41.612]                     }
[16:18:41.612]                     {
[16:18:41.612]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.612]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.612]                         USE.NAMES = FALSE)
[16:18:41.612]                       do.call(mapply, args = args)
[16:18:41.612]                     }
[16:18:41.612]                   }
[16:18:41.612]                 }, immediateCondition = function(cond) {
[16:18:41.612]                   save_rds <- function (object, pathname, ...) 
[16:18:41.612]                   {
[16:18:41.612]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.612]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.612]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.612]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.612]                         fi_tmp[["mtime"]])
[16:18:41.612]                     }
[16:18:41.612]                     tryCatch({
[16:18:41.612]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.612]                     }, error = function(ex) {
[16:18:41.612]                       msg <- conditionMessage(ex)
[16:18:41.612]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.612]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.612]                         fi_tmp[["mtime"]], msg)
[16:18:41.612]                       ex$message <- msg
[16:18:41.612]                       stop(ex)
[16:18:41.612]                     })
[16:18:41.612]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.612]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.612]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.612]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.612]                       fi <- file.info(pathname)
[16:18:41.612]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.612]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.612]                         fi[["size"]], fi[["mtime"]])
[16:18:41.612]                       stop(msg)
[16:18:41.612]                     }
[16:18:41.612]                     invisible(pathname)
[16:18:41.612]                   }
[16:18:41.612]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.612]                     rootPath = tempdir()) 
[16:18:41.612]                   {
[16:18:41.612]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.612]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.612]                       tmpdir = path, fileext = ".rds")
[16:18:41.612]                     save_rds(obj, file)
[16:18:41.612]                   }
[16:18:41.612]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.612]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.612]                   {
[16:18:41.612]                     inherits <- base::inherits
[16:18:41.612]                     invokeRestart <- base::invokeRestart
[16:18:41.612]                     is.null <- base::is.null
[16:18:41.612]                     muffled <- FALSE
[16:18:41.612]                     if (inherits(cond, "message")) {
[16:18:41.612]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.612]                       if (muffled) 
[16:18:41.612]                         invokeRestart("muffleMessage")
[16:18:41.612]                     }
[16:18:41.612]                     else if (inherits(cond, "warning")) {
[16:18:41.612]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.612]                       if (muffled) 
[16:18:41.612]                         invokeRestart("muffleWarning")
[16:18:41.612]                     }
[16:18:41.612]                     else if (inherits(cond, "condition")) {
[16:18:41.612]                       if (!is.null(pattern)) {
[16:18:41.612]                         computeRestarts <- base::computeRestarts
[16:18:41.612]                         grepl <- base::grepl
[16:18:41.612]                         restarts <- computeRestarts(cond)
[16:18:41.612]                         for (restart in restarts) {
[16:18:41.612]                           name <- restart$name
[16:18:41.612]                           if (is.null(name)) 
[16:18:41.612]                             next
[16:18:41.612]                           if (!grepl(pattern, name)) 
[16:18:41.612]                             next
[16:18:41.612]                           invokeRestart(restart)
[16:18:41.612]                           muffled <- TRUE
[16:18:41.612]                           break
[16:18:41.612]                         }
[16:18:41.612]                       }
[16:18:41.612]                     }
[16:18:41.612]                     invisible(muffled)
[16:18:41.612]                   }
[16:18:41.612]                   muffleCondition(cond)
[16:18:41.612]                 })
[16:18:41.612]             }))
[16:18:41.612]             future::FutureResult(value = ...future.value$value, 
[16:18:41.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.612]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.612]                     ...future.globalenv.names))
[16:18:41.612]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.612]         }, condition = base::local({
[16:18:41.612]             c <- base::c
[16:18:41.612]             inherits <- base::inherits
[16:18:41.612]             invokeRestart <- base::invokeRestart
[16:18:41.612]             length <- base::length
[16:18:41.612]             list <- base::list
[16:18:41.612]             seq.int <- base::seq.int
[16:18:41.612]             signalCondition <- base::signalCondition
[16:18:41.612]             sys.calls <- base::sys.calls
[16:18:41.612]             `[[` <- base::`[[`
[16:18:41.612]             `+` <- base::`+`
[16:18:41.612]             `<<-` <- base::`<<-`
[16:18:41.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.612]                   3L)]
[16:18:41.612]             }
[16:18:41.612]             function(cond) {
[16:18:41.612]                 is_error <- inherits(cond, "error")
[16:18:41.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.612]                   NULL)
[16:18:41.612]                 if (is_error) {
[16:18:41.612]                   sessionInformation <- function() {
[16:18:41.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.612]                       search = base::search(), system = base::Sys.info())
[16:18:41.612]                   }
[16:18:41.612]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.612]                     cond$call), session = sessionInformation(), 
[16:18:41.612]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.612]                   signalCondition(cond)
[16:18:41.612]                 }
[16:18:41.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.612]                 "immediateCondition"))) {
[16:18:41.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.612]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.612]                   if (TRUE && !signal) {
[16:18:41.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.612]                     {
[16:18:41.612]                       inherits <- base::inherits
[16:18:41.612]                       invokeRestart <- base::invokeRestart
[16:18:41.612]                       is.null <- base::is.null
[16:18:41.612]                       muffled <- FALSE
[16:18:41.612]                       if (inherits(cond, "message")) {
[16:18:41.612]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.612]                         if (muffled) 
[16:18:41.612]                           invokeRestart("muffleMessage")
[16:18:41.612]                       }
[16:18:41.612]                       else if (inherits(cond, "warning")) {
[16:18:41.612]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.612]                         if (muffled) 
[16:18:41.612]                           invokeRestart("muffleWarning")
[16:18:41.612]                       }
[16:18:41.612]                       else if (inherits(cond, "condition")) {
[16:18:41.612]                         if (!is.null(pattern)) {
[16:18:41.612]                           computeRestarts <- base::computeRestarts
[16:18:41.612]                           grepl <- base::grepl
[16:18:41.612]                           restarts <- computeRestarts(cond)
[16:18:41.612]                           for (restart in restarts) {
[16:18:41.612]                             name <- restart$name
[16:18:41.612]                             if (is.null(name)) 
[16:18:41.612]                               next
[16:18:41.612]                             if (!grepl(pattern, name)) 
[16:18:41.612]                               next
[16:18:41.612]                             invokeRestart(restart)
[16:18:41.612]                             muffled <- TRUE
[16:18:41.612]                             break
[16:18:41.612]                           }
[16:18:41.612]                         }
[16:18:41.612]                       }
[16:18:41.612]                       invisible(muffled)
[16:18:41.612]                     }
[16:18:41.612]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.612]                   }
[16:18:41.612]                 }
[16:18:41.612]                 else {
[16:18:41.612]                   if (TRUE) {
[16:18:41.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.612]                     {
[16:18:41.612]                       inherits <- base::inherits
[16:18:41.612]                       invokeRestart <- base::invokeRestart
[16:18:41.612]                       is.null <- base::is.null
[16:18:41.612]                       muffled <- FALSE
[16:18:41.612]                       if (inherits(cond, "message")) {
[16:18:41.612]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.612]                         if (muffled) 
[16:18:41.612]                           invokeRestart("muffleMessage")
[16:18:41.612]                       }
[16:18:41.612]                       else if (inherits(cond, "warning")) {
[16:18:41.612]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.612]                         if (muffled) 
[16:18:41.612]                           invokeRestart("muffleWarning")
[16:18:41.612]                       }
[16:18:41.612]                       else if (inherits(cond, "condition")) {
[16:18:41.612]                         if (!is.null(pattern)) {
[16:18:41.612]                           computeRestarts <- base::computeRestarts
[16:18:41.612]                           grepl <- base::grepl
[16:18:41.612]                           restarts <- computeRestarts(cond)
[16:18:41.612]                           for (restart in restarts) {
[16:18:41.612]                             name <- restart$name
[16:18:41.612]                             if (is.null(name)) 
[16:18:41.612]                               next
[16:18:41.612]                             if (!grepl(pattern, name)) 
[16:18:41.612]                               next
[16:18:41.612]                             invokeRestart(restart)
[16:18:41.612]                             muffled <- TRUE
[16:18:41.612]                             break
[16:18:41.612]                           }
[16:18:41.612]                         }
[16:18:41.612]                       }
[16:18:41.612]                       invisible(muffled)
[16:18:41.612]                     }
[16:18:41.612]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.612]                   }
[16:18:41.612]                 }
[16:18:41.612]             }
[16:18:41.612]         }))
[16:18:41.612]     }, error = function(ex) {
[16:18:41.612]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.612]                 ...future.rng), started = ...future.startTime, 
[16:18:41.612]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.612]             version = "1.8"), class = "FutureResult")
[16:18:41.612]     }, finally = {
[16:18:41.612]         if (!identical(...future.workdir, getwd())) 
[16:18:41.612]             setwd(...future.workdir)
[16:18:41.612]         {
[16:18:41.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.612]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.612]             }
[16:18:41.612]             base::options(...future.oldOptions)
[16:18:41.612]             if (.Platform$OS.type == "windows") {
[16:18:41.612]                 old_names <- names(...future.oldEnvVars)
[16:18:41.612]                 envs <- base::Sys.getenv()
[16:18:41.612]                 names <- names(envs)
[16:18:41.612]                 common <- intersect(names, old_names)
[16:18:41.612]                 added <- setdiff(names, old_names)
[16:18:41.612]                 removed <- setdiff(old_names, names)
[16:18:41.612]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.612]                   envs[common]]
[16:18:41.612]                 NAMES <- toupper(changed)
[16:18:41.612]                 args <- list()
[16:18:41.612]                 for (kk in seq_along(NAMES)) {
[16:18:41.612]                   name <- changed[[kk]]
[16:18:41.612]                   NAME <- NAMES[[kk]]
[16:18:41.612]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.612]                     next
[16:18:41.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.612]                 }
[16:18:41.612]                 NAMES <- toupper(added)
[16:18:41.612]                 for (kk in seq_along(NAMES)) {
[16:18:41.612]                   name <- added[[kk]]
[16:18:41.612]                   NAME <- NAMES[[kk]]
[16:18:41.612]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.612]                     next
[16:18:41.612]                   args[[name]] <- ""
[16:18:41.612]                 }
[16:18:41.612]                 NAMES <- toupper(removed)
[16:18:41.612]                 for (kk in seq_along(NAMES)) {
[16:18:41.612]                   name <- removed[[kk]]
[16:18:41.612]                   NAME <- NAMES[[kk]]
[16:18:41.612]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.612]                     next
[16:18:41.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.612]                 }
[16:18:41.612]                 if (length(args) > 0) 
[16:18:41.612]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.612]             }
[16:18:41.612]             else {
[16:18:41.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.612]             }
[16:18:41.612]             {
[16:18:41.612]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.612]                   0L) {
[16:18:41.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.612]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.612]                   base::options(opts)
[16:18:41.612]                 }
[16:18:41.612]                 {
[16:18:41.612]                   {
[16:18:41.612]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.612]                     NULL
[16:18:41.612]                   }
[16:18:41.612]                   options(future.plan = NULL)
[16:18:41.612]                   if (is.na(NA_character_)) 
[16:18:41.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.612]                     .init = FALSE)
[16:18:41.612]                 }
[16:18:41.612]             }
[16:18:41.612]         }
[16:18:41.612]     })
[16:18:41.612]     if (TRUE) {
[16:18:41.612]         base::sink(type = "output", split = FALSE)
[16:18:41.612]         if (TRUE) {
[16:18:41.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.612]         }
[16:18:41.612]         else {
[16:18:41.612]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.612]         }
[16:18:41.612]         base::close(...future.stdout)
[16:18:41.612]         ...future.stdout <- NULL
[16:18:41.612]     }
[16:18:41.612]     ...future.result$conditions <- ...future.conditions
[16:18:41.612]     ...future.result$finished <- base::Sys.time()
[16:18:41.612]     ...future.result
[16:18:41.612] }
[16:18:41.614] assign_globals() ...
[16:18:41.614] List of 5
[16:18:41.614]  $ ...future.FUN            :function (C, k)  
[16:18:41.614]  $ MoreArgs                 : NULL
[16:18:41.614]  $ ...future.elements_ii    :List of 2
[16:18:41.614]   ..$ :List of 1
[16:18:41.614]   .. ..$ : chr "A"
[16:18:41.614]   ..$ :List of 1
[16:18:41.614]   .. ..$ : int 5
[16:18:41.614]  $ ...future.seeds_ii       : NULL
[16:18:41.614]  $ ...future.globals.maxSize: NULL
[16:18:41.614]  - attr(*, "where")=List of 5
[16:18:41.614]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.614]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.614]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.614]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.614]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.614]  - attr(*, "resolved")= logi FALSE
[16:18:41.614]  - attr(*, "total_size")= num 3488
[16:18:41.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.614]  - attr(*, "already-done")= logi TRUE
[16:18:41.620] - reassign environment for ‘...future.FUN’
[16:18:41.620] - copied ‘...future.FUN’ to environment
[16:18:41.620] - copied ‘MoreArgs’ to environment
[16:18:41.620] - copied ‘...future.elements_ii’ to environment
[16:18:41.620] - copied ‘...future.seeds_ii’ to environment
[16:18:41.620] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.620] assign_globals() ... done
[16:18:41.621] requestCore(): workers = 2
[16:18:41.623] MulticoreFuture started
[16:18:41.623] - Launch lazy future ... done
[16:18:41.624] run() for ‘MulticoreFuture’ ... done
[16:18:41.624] Created future:
[16:18:41.624] plan(): Setting new future strategy stack:
[16:18:41.624] List of future strategies:
[16:18:41.624] 1. sequential:
[16:18:41.624]    - args: function (..., envir = parent.frame())
[16:18:41.624]    - tweaked: FALSE
[16:18:41.624]    - call: NULL
[16:18:41.625] plan(): nbrOfWorkers() = 1
[16:18:41.628] plan(): Setting new future strategy stack:
[16:18:41.628] List of future strategies:
[16:18:41.628] 1. multicore:
[16:18:41.628]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.628]    - tweaked: FALSE
[16:18:41.628]    - call: plan(strategy)
[16:18:41.633] plan(): nbrOfWorkers() = 2
[16:18:41.624] MulticoreFuture:
[16:18:41.624] Label: ‘future_mapply-1’
[16:18:41.624] Expression:
[16:18:41.624] {
[16:18:41.624]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.624]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.624]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.624]         on.exit(options(oopts), add = TRUE)
[16:18:41.624]     }
[16:18:41.624]     {
[16:18:41.624]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.624]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.624]         do.call(mapply, args = args)
[16:18:41.624]     }
[16:18:41.624] }
[16:18:41.624] Lazy evaluation: FALSE
[16:18:41.624] Asynchronous evaluation: TRUE
[16:18:41.624] Local evaluation: TRUE
[16:18:41.624] Environment: R_GlobalEnv
[16:18:41.624] Capture standard output: TRUE
[16:18:41.624] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.624] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.624] Packages: <none>
[16:18:41.624] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.624] Resolved: TRUE
[16:18:41.624] Value: <not collected>
[16:18:41.624] Conditions captured: <none>
[16:18:41.624] Early signaling: FALSE
[16:18:41.624] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.624] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.634] Chunk #1 of 5 ... DONE
[16:18:41.634] Chunk #2 of 5 ...
[16:18:41.635]  - Finding globals in '...' for chunk #2 ...
[16:18:41.635] getGlobalsAndPackages() ...
[16:18:41.635] Searching for globals...
[16:18:41.636] 
[16:18:41.636] Searching for globals ... DONE
[16:18:41.636] - globals: [0] <none>
[16:18:41.636] getGlobalsAndPackages() ... DONE
[16:18:41.636]    + additional globals found: [n=0] 
[16:18:41.636]    + additional namespaces needed: [n=0] 
[16:18:41.636]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:41.637]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:41.637]  - seeds: <none>
[16:18:41.637]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.637] getGlobalsAndPackages() ...
[16:18:41.637] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.637] Resolving globals: FALSE
[16:18:41.638] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:41.639] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:41.639] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.639] 
[16:18:41.639] getGlobalsAndPackages() ... DONE
[16:18:41.640] run() for ‘Future’ ...
[16:18:41.640] - state: ‘created’
[16:18:41.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.645] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.645] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.645]   - Field: ‘label’
[16:18:41.645]   - Field: ‘local’
[16:18:41.646]   - Field: ‘owner’
[16:18:41.646]   - Field: ‘envir’
[16:18:41.646]   - Field: ‘workers’
[16:18:41.646]   - Field: ‘packages’
[16:18:41.646]   - Field: ‘gc’
[16:18:41.646]   - Field: ‘job’
[16:18:41.647]   - Field: ‘conditions’
[16:18:41.647]   - Field: ‘expr’
[16:18:41.647]   - Field: ‘uuid’
[16:18:41.647]   - Field: ‘seed’
[16:18:41.647]   - Field: ‘version’
[16:18:41.647]   - Field: ‘result’
[16:18:41.647]   - Field: ‘asynchronous’
[16:18:41.648]   - Field: ‘calls’
[16:18:41.648]   - Field: ‘globals’
[16:18:41.648]   - Field: ‘stdout’
[16:18:41.648]   - Field: ‘earlySignal’
[16:18:41.648]   - Field: ‘lazy’
[16:18:41.648]   - Field: ‘state’
[16:18:41.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.649] - Launch lazy future ...
[16:18:41.649] Packages needed by the future expression (n = 0): <none>
[16:18:41.649] Packages needed by future strategies (n = 0): <none>
[16:18:41.650] {
[16:18:41.650]     {
[16:18:41.650]         {
[16:18:41.650]             ...future.startTime <- base::Sys.time()
[16:18:41.650]             {
[16:18:41.650]                 {
[16:18:41.650]                   {
[16:18:41.650]                     {
[16:18:41.650]                       base::local({
[16:18:41.650]                         has_future <- base::requireNamespace("future", 
[16:18:41.650]                           quietly = TRUE)
[16:18:41.650]                         if (has_future) {
[16:18:41.650]                           ns <- base::getNamespace("future")
[16:18:41.650]                           version <- ns[[".package"]][["version"]]
[16:18:41.650]                           if (is.null(version)) 
[16:18:41.650]                             version <- utils::packageVersion("future")
[16:18:41.650]                         }
[16:18:41.650]                         else {
[16:18:41.650]                           version <- NULL
[16:18:41.650]                         }
[16:18:41.650]                         if (!has_future || version < "1.8.0") {
[16:18:41.650]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.650]                             "", base::R.version$version.string), 
[16:18:41.650]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.650]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.650]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.650]                               "release", "version")], collapse = " "), 
[16:18:41.650]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.650]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.650]                             info)
[16:18:41.650]                           info <- base::paste(info, collapse = "; ")
[16:18:41.650]                           if (!has_future) {
[16:18:41.650]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.650]                               info)
[16:18:41.650]                           }
[16:18:41.650]                           else {
[16:18:41.650]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.650]                               info, version)
[16:18:41.650]                           }
[16:18:41.650]                           base::stop(msg)
[16:18:41.650]                         }
[16:18:41.650]                       })
[16:18:41.650]                     }
[16:18:41.650]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.650]                     base::options(mc.cores = 1L)
[16:18:41.650]                   }
[16:18:41.650]                   ...future.strategy.old <- future::plan("list")
[16:18:41.650]                   options(future.plan = NULL)
[16:18:41.650]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.650]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.650]                 }
[16:18:41.650]                 ...future.workdir <- getwd()
[16:18:41.650]             }
[16:18:41.650]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.650]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.650]         }
[16:18:41.650]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.650]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:41.650]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.650]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.650]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.650]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.650]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.650]             base::names(...future.oldOptions))
[16:18:41.650]     }
[16:18:41.650]     if (FALSE) {
[16:18:41.650]     }
[16:18:41.650]     else {
[16:18:41.650]         if (TRUE) {
[16:18:41.650]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.650]                 open = "w")
[16:18:41.650]         }
[16:18:41.650]         else {
[16:18:41.650]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.650]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.650]         }
[16:18:41.650]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.650]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.650]             base::sink(type = "output", split = FALSE)
[16:18:41.650]             base::close(...future.stdout)
[16:18:41.650]         }, add = TRUE)
[16:18:41.650]     }
[16:18:41.650]     ...future.frame <- base::sys.nframe()
[16:18:41.650]     ...future.conditions <- base::list()
[16:18:41.650]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.650]     if (FALSE) {
[16:18:41.650]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.650]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.650]     }
[16:18:41.650]     ...future.result <- base::tryCatch({
[16:18:41.650]         base::withCallingHandlers({
[16:18:41.650]             ...future.value <- base::withVisible(base::local({
[16:18:41.650]                 withCallingHandlers({
[16:18:41.650]                   {
[16:18:41.650]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.650]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.650]                       ...future.globals.maxSize)) {
[16:18:41.650]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.650]                       on.exit(options(oopts), add = TRUE)
[16:18:41.650]                     }
[16:18:41.650]                     {
[16:18:41.650]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.650]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.650]                         USE.NAMES = FALSE)
[16:18:41.650]                       do.call(mapply, args = args)
[16:18:41.650]                     }
[16:18:41.650]                   }
[16:18:41.650]                 }, immediateCondition = function(cond) {
[16:18:41.650]                   save_rds <- function (object, pathname, ...) 
[16:18:41.650]                   {
[16:18:41.650]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.650]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.650]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.650]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.650]                         fi_tmp[["mtime"]])
[16:18:41.650]                     }
[16:18:41.650]                     tryCatch({
[16:18:41.650]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.650]                     }, error = function(ex) {
[16:18:41.650]                       msg <- conditionMessage(ex)
[16:18:41.650]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.650]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.650]                         fi_tmp[["mtime"]], msg)
[16:18:41.650]                       ex$message <- msg
[16:18:41.650]                       stop(ex)
[16:18:41.650]                     })
[16:18:41.650]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.650]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.650]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.650]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.650]                       fi <- file.info(pathname)
[16:18:41.650]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.650]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.650]                         fi[["size"]], fi[["mtime"]])
[16:18:41.650]                       stop(msg)
[16:18:41.650]                     }
[16:18:41.650]                     invisible(pathname)
[16:18:41.650]                   }
[16:18:41.650]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.650]                     rootPath = tempdir()) 
[16:18:41.650]                   {
[16:18:41.650]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.650]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.650]                       tmpdir = path, fileext = ".rds")
[16:18:41.650]                     save_rds(obj, file)
[16:18:41.650]                   }
[16:18:41.650]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.650]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.650]                   {
[16:18:41.650]                     inherits <- base::inherits
[16:18:41.650]                     invokeRestart <- base::invokeRestart
[16:18:41.650]                     is.null <- base::is.null
[16:18:41.650]                     muffled <- FALSE
[16:18:41.650]                     if (inherits(cond, "message")) {
[16:18:41.650]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.650]                       if (muffled) 
[16:18:41.650]                         invokeRestart("muffleMessage")
[16:18:41.650]                     }
[16:18:41.650]                     else if (inherits(cond, "warning")) {
[16:18:41.650]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.650]                       if (muffled) 
[16:18:41.650]                         invokeRestart("muffleWarning")
[16:18:41.650]                     }
[16:18:41.650]                     else if (inherits(cond, "condition")) {
[16:18:41.650]                       if (!is.null(pattern)) {
[16:18:41.650]                         computeRestarts <- base::computeRestarts
[16:18:41.650]                         grepl <- base::grepl
[16:18:41.650]                         restarts <- computeRestarts(cond)
[16:18:41.650]                         for (restart in restarts) {
[16:18:41.650]                           name <- restart$name
[16:18:41.650]                           if (is.null(name)) 
[16:18:41.650]                             next
[16:18:41.650]                           if (!grepl(pattern, name)) 
[16:18:41.650]                             next
[16:18:41.650]                           invokeRestart(restart)
[16:18:41.650]                           muffled <- TRUE
[16:18:41.650]                           break
[16:18:41.650]                         }
[16:18:41.650]                       }
[16:18:41.650]                     }
[16:18:41.650]                     invisible(muffled)
[16:18:41.650]                   }
[16:18:41.650]                   muffleCondition(cond)
[16:18:41.650]                 })
[16:18:41.650]             }))
[16:18:41.650]             future::FutureResult(value = ...future.value$value, 
[16:18:41.650]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.650]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.650]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.650]                     ...future.globalenv.names))
[16:18:41.650]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.650]         }, condition = base::local({
[16:18:41.650]             c <- base::c
[16:18:41.650]             inherits <- base::inherits
[16:18:41.650]             invokeRestart <- base::invokeRestart
[16:18:41.650]             length <- base::length
[16:18:41.650]             list <- base::list
[16:18:41.650]             seq.int <- base::seq.int
[16:18:41.650]             signalCondition <- base::signalCondition
[16:18:41.650]             sys.calls <- base::sys.calls
[16:18:41.650]             `[[` <- base::`[[`
[16:18:41.650]             `+` <- base::`+`
[16:18:41.650]             `<<-` <- base::`<<-`
[16:18:41.650]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.650]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.650]                   3L)]
[16:18:41.650]             }
[16:18:41.650]             function(cond) {
[16:18:41.650]                 is_error <- inherits(cond, "error")
[16:18:41.650]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.650]                   NULL)
[16:18:41.650]                 if (is_error) {
[16:18:41.650]                   sessionInformation <- function() {
[16:18:41.650]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.650]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.650]                       search = base::search(), system = base::Sys.info())
[16:18:41.650]                   }
[16:18:41.650]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.650]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.650]                     cond$call), session = sessionInformation(), 
[16:18:41.650]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.650]                   signalCondition(cond)
[16:18:41.650]                 }
[16:18:41.650]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.650]                 "immediateCondition"))) {
[16:18:41.650]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.650]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.650]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.650]                   if (TRUE && !signal) {
[16:18:41.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.650]                     {
[16:18:41.650]                       inherits <- base::inherits
[16:18:41.650]                       invokeRestart <- base::invokeRestart
[16:18:41.650]                       is.null <- base::is.null
[16:18:41.650]                       muffled <- FALSE
[16:18:41.650]                       if (inherits(cond, "message")) {
[16:18:41.650]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.650]                         if (muffled) 
[16:18:41.650]                           invokeRestart("muffleMessage")
[16:18:41.650]                       }
[16:18:41.650]                       else if (inherits(cond, "warning")) {
[16:18:41.650]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.650]                         if (muffled) 
[16:18:41.650]                           invokeRestart("muffleWarning")
[16:18:41.650]                       }
[16:18:41.650]                       else if (inherits(cond, "condition")) {
[16:18:41.650]                         if (!is.null(pattern)) {
[16:18:41.650]                           computeRestarts <- base::computeRestarts
[16:18:41.650]                           grepl <- base::grepl
[16:18:41.650]                           restarts <- computeRestarts(cond)
[16:18:41.650]                           for (restart in restarts) {
[16:18:41.650]                             name <- restart$name
[16:18:41.650]                             if (is.null(name)) 
[16:18:41.650]                               next
[16:18:41.650]                             if (!grepl(pattern, name)) 
[16:18:41.650]                               next
[16:18:41.650]                             invokeRestart(restart)
[16:18:41.650]                             muffled <- TRUE
[16:18:41.650]                             break
[16:18:41.650]                           }
[16:18:41.650]                         }
[16:18:41.650]                       }
[16:18:41.650]                       invisible(muffled)
[16:18:41.650]                     }
[16:18:41.650]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.650]                   }
[16:18:41.650]                 }
[16:18:41.650]                 else {
[16:18:41.650]                   if (TRUE) {
[16:18:41.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.650]                     {
[16:18:41.650]                       inherits <- base::inherits
[16:18:41.650]                       invokeRestart <- base::invokeRestart
[16:18:41.650]                       is.null <- base::is.null
[16:18:41.650]                       muffled <- FALSE
[16:18:41.650]                       if (inherits(cond, "message")) {
[16:18:41.650]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.650]                         if (muffled) 
[16:18:41.650]                           invokeRestart("muffleMessage")
[16:18:41.650]                       }
[16:18:41.650]                       else if (inherits(cond, "warning")) {
[16:18:41.650]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.650]                         if (muffled) 
[16:18:41.650]                           invokeRestart("muffleWarning")
[16:18:41.650]                       }
[16:18:41.650]                       else if (inherits(cond, "condition")) {
[16:18:41.650]                         if (!is.null(pattern)) {
[16:18:41.650]                           computeRestarts <- base::computeRestarts
[16:18:41.650]                           grepl <- base::grepl
[16:18:41.650]                           restarts <- computeRestarts(cond)
[16:18:41.650]                           for (restart in restarts) {
[16:18:41.650]                             name <- restart$name
[16:18:41.650]                             if (is.null(name)) 
[16:18:41.650]                               next
[16:18:41.650]                             if (!grepl(pattern, name)) 
[16:18:41.650]                               next
[16:18:41.650]                             invokeRestart(restart)
[16:18:41.650]                             muffled <- TRUE
[16:18:41.650]                             break
[16:18:41.650]                           }
[16:18:41.650]                         }
[16:18:41.650]                       }
[16:18:41.650]                       invisible(muffled)
[16:18:41.650]                     }
[16:18:41.650]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.650]                   }
[16:18:41.650]                 }
[16:18:41.650]             }
[16:18:41.650]         }))
[16:18:41.650]     }, error = function(ex) {
[16:18:41.650]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.650]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.650]                 ...future.rng), started = ...future.startTime, 
[16:18:41.650]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.650]             version = "1.8"), class = "FutureResult")
[16:18:41.650]     }, finally = {
[16:18:41.650]         if (!identical(...future.workdir, getwd())) 
[16:18:41.650]             setwd(...future.workdir)
[16:18:41.650]         {
[16:18:41.650]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.650]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.650]             }
[16:18:41.650]             base::options(...future.oldOptions)
[16:18:41.650]             if (.Platform$OS.type == "windows") {
[16:18:41.650]                 old_names <- names(...future.oldEnvVars)
[16:18:41.650]                 envs <- base::Sys.getenv()
[16:18:41.650]                 names <- names(envs)
[16:18:41.650]                 common <- intersect(names, old_names)
[16:18:41.650]                 added <- setdiff(names, old_names)
[16:18:41.650]                 removed <- setdiff(old_names, names)
[16:18:41.650]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.650]                   envs[common]]
[16:18:41.650]                 NAMES <- toupper(changed)
[16:18:41.650]                 args <- list()
[16:18:41.650]                 for (kk in seq_along(NAMES)) {
[16:18:41.650]                   name <- changed[[kk]]
[16:18:41.650]                   NAME <- NAMES[[kk]]
[16:18:41.650]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.650]                     next
[16:18:41.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.650]                 }
[16:18:41.650]                 NAMES <- toupper(added)
[16:18:41.650]                 for (kk in seq_along(NAMES)) {
[16:18:41.650]                   name <- added[[kk]]
[16:18:41.650]                   NAME <- NAMES[[kk]]
[16:18:41.650]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.650]                     next
[16:18:41.650]                   args[[name]] <- ""
[16:18:41.650]                 }
[16:18:41.650]                 NAMES <- toupper(removed)
[16:18:41.650]                 for (kk in seq_along(NAMES)) {
[16:18:41.650]                   name <- removed[[kk]]
[16:18:41.650]                   NAME <- NAMES[[kk]]
[16:18:41.650]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.650]                     next
[16:18:41.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.650]                 }
[16:18:41.650]                 if (length(args) > 0) 
[16:18:41.650]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.650]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.650]             }
[16:18:41.650]             else {
[16:18:41.650]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.650]             }
[16:18:41.650]             {
[16:18:41.650]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.650]                   0L) {
[16:18:41.650]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.650]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.650]                   base::options(opts)
[16:18:41.650]                 }
[16:18:41.650]                 {
[16:18:41.650]                   {
[16:18:41.650]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.650]                     NULL
[16:18:41.650]                   }
[16:18:41.650]                   options(future.plan = NULL)
[16:18:41.650]                   if (is.na(NA_character_)) 
[16:18:41.650]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.650]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.650]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.650]                     .init = FALSE)
[16:18:41.650]                 }
[16:18:41.650]             }
[16:18:41.650]         }
[16:18:41.650]     })
[16:18:41.650]     if (TRUE) {
[16:18:41.650]         base::sink(type = "output", split = FALSE)
[16:18:41.650]         if (TRUE) {
[16:18:41.650]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.650]         }
[16:18:41.650]         else {
[16:18:41.650]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.650]         }
[16:18:41.650]         base::close(...future.stdout)
[16:18:41.650]         ...future.stdout <- NULL
[16:18:41.650]     }
[16:18:41.650]     ...future.result$conditions <- ...future.conditions
[16:18:41.650]     ...future.result$finished <- base::Sys.time()
[16:18:41.650]     ...future.result
[16:18:41.650] }
[16:18:41.653] assign_globals() ...
[16:18:41.653] List of 5
[16:18:41.653]  $ ...future.FUN            :function (C, k)  
[16:18:41.653]  $ MoreArgs                 : NULL
[16:18:41.653]  $ ...future.elements_ii    :List of 2
[16:18:41.653]   ..$ :List of 1
[16:18:41.653]   .. ..$ : chr "B"
[16:18:41.653]   ..$ :List of 1
[16:18:41.653]   .. ..$ : int 4
[16:18:41.653]  $ ...future.seeds_ii       : NULL
[16:18:41.653]  $ ...future.globals.maxSize: NULL
[16:18:41.653]  - attr(*, "where")=List of 5
[16:18:41.653]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.653]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.653]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.653]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.653]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.653]  - attr(*, "resolved")= logi FALSE
[16:18:41.653]  - attr(*, "total_size")= num 3488
[16:18:41.653]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.653]  - attr(*, "already-done")= logi TRUE
[16:18:41.667] - reassign environment for ‘...future.FUN’
[16:18:41.667] - copied ‘...future.FUN’ to environment
[16:18:41.667] - copied ‘MoreArgs’ to environment
[16:18:41.667] - copied ‘...future.elements_ii’ to environment
[16:18:41.667] - copied ‘...future.seeds_ii’ to environment
[16:18:41.668] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.668] assign_globals() ... done
[16:18:41.668] requestCore(): workers = 2
[16:18:41.671] MulticoreFuture started
[16:18:41.671] - Launch lazy future ... done
[16:18:41.671] run() for ‘MulticoreFuture’ ... done
[16:18:41.672] Created future:
[16:18:41.672] plan(): Setting new future strategy stack:
[16:18:41.672] List of future strategies:
[16:18:41.672] 1. sequential:
[16:18:41.672]    - args: function (..., envir = parent.frame())
[16:18:41.672]    - tweaked: FALSE
[16:18:41.672]    - call: NULL
[16:18:41.673] plan(): nbrOfWorkers() = 1
[16:18:41.676] plan(): Setting new future strategy stack:
[16:18:41.676] List of future strategies:
[16:18:41.676] 1. multicore:
[16:18:41.676]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.676]    - tweaked: FALSE
[16:18:41.676]    - call: plan(strategy)
[16:18:41.682] plan(): nbrOfWorkers() = 2
[16:18:41.672] MulticoreFuture:
[16:18:41.672] Label: ‘future_mapply-2’
[16:18:41.672] Expression:
[16:18:41.672] {
[16:18:41.672]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.672]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.672]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.672]         on.exit(options(oopts), add = TRUE)
[16:18:41.672]     }
[16:18:41.672]     {
[16:18:41.672]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.672]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.672]         do.call(mapply, args = args)
[16:18:41.672]     }
[16:18:41.672] }
[16:18:41.672] Lazy evaluation: FALSE
[16:18:41.672] Asynchronous evaluation: TRUE
[16:18:41.672] Local evaluation: TRUE
[16:18:41.672] Environment: R_GlobalEnv
[16:18:41.672] Capture standard output: TRUE
[16:18:41.672] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.672] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.672] Packages: <none>
[16:18:41.672] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.672] Resolved: TRUE
[16:18:41.672] Value: <not collected>
[16:18:41.672] Conditions captured: <none>
[16:18:41.672] Early signaling: FALSE
[16:18:41.672] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.672] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.684] Chunk #2 of 5 ... DONE
[16:18:41.684] Chunk #3 of 5 ...
[16:18:41.684]  - Finding globals in '...' for chunk #3 ...
[16:18:41.684] getGlobalsAndPackages() ...
[16:18:41.685] Searching for globals...
[16:18:41.685] 
[16:18:41.685] Searching for globals ... DONE
[16:18:41.686] - globals: [0] <none>
[16:18:41.686] getGlobalsAndPackages() ... DONE
[16:18:41.686]    + additional globals found: [n=0] 
[16:18:41.686]    + additional namespaces needed: [n=0] 
[16:18:41.686]  - Finding globals in '...' for chunk #3 ... DONE
[16:18:41.686]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:41.686]  - seeds: <none>
[16:18:41.687]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.687] getGlobalsAndPackages() ...
[16:18:41.687] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.688] Resolving globals: FALSE
[16:18:41.689] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:41.690] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:41.690] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.690] 
[16:18:41.690] getGlobalsAndPackages() ... DONE
[16:18:41.691] run() for ‘Future’ ...
[16:18:41.691] - state: ‘created’
[16:18:41.691] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.695] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.696] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.696]   - Field: ‘label’
[16:18:41.696]   - Field: ‘local’
[16:18:41.696]   - Field: ‘owner’
[16:18:41.696]   - Field: ‘envir’
[16:18:41.696]   - Field: ‘workers’
[16:18:41.696]   - Field: ‘packages’
[16:18:41.697]   - Field: ‘gc’
[16:18:41.697]   - Field: ‘job’
[16:18:41.697]   - Field: ‘conditions’
[16:18:41.697]   - Field: ‘expr’
[16:18:41.697]   - Field: ‘uuid’
[16:18:41.697]   - Field: ‘seed’
[16:18:41.697]   - Field: ‘version’
[16:18:41.698]   - Field: ‘result’
[16:18:41.698]   - Field: ‘asynchronous’
[16:18:41.698]   - Field: ‘calls’
[16:18:41.698]   - Field: ‘globals’
[16:18:41.698]   - Field: ‘stdout’
[16:18:41.698]   - Field: ‘earlySignal’
[16:18:41.698]   - Field: ‘lazy’
[16:18:41.698]   - Field: ‘state’
[16:18:41.699] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.699] - Launch lazy future ...
[16:18:41.699] Packages needed by the future expression (n = 0): <none>
[16:18:41.699] Packages needed by future strategies (n = 0): <none>
[16:18:41.700] {
[16:18:41.700]     {
[16:18:41.700]         {
[16:18:41.700]             ...future.startTime <- base::Sys.time()
[16:18:41.700]             {
[16:18:41.700]                 {
[16:18:41.700]                   {
[16:18:41.700]                     {
[16:18:41.700]                       base::local({
[16:18:41.700]                         has_future <- base::requireNamespace("future", 
[16:18:41.700]                           quietly = TRUE)
[16:18:41.700]                         if (has_future) {
[16:18:41.700]                           ns <- base::getNamespace("future")
[16:18:41.700]                           version <- ns[[".package"]][["version"]]
[16:18:41.700]                           if (is.null(version)) 
[16:18:41.700]                             version <- utils::packageVersion("future")
[16:18:41.700]                         }
[16:18:41.700]                         else {
[16:18:41.700]                           version <- NULL
[16:18:41.700]                         }
[16:18:41.700]                         if (!has_future || version < "1.8.0") {
[16:18:41.700]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.700]                             "", base::R.version$version.string), 
[16:18:41.700]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.700]                               "release", "version")], collapse = " "), 
[16:18:41.700]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.700]                             info)
[16:18:41.700]                           info <- base::paste(info, collapse = "; ")
[16:18:41.700]                           if (!has_future) {
[16:18:41.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.700]                               info)
[16:18:41.700]                           }
[16:18:41.700]                           else {
[16:18:41.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.700]                               info, version)
[16:18:41.700]                           }
[16:18:41.700]                           base::stop(msg)
[16:18:41.700]                         }
[16:18:41.700]                       })
[16:18:41.700]                     }
[16:18:41.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.700]                     base::options(mc.cores = 1L)
[16:18:41.700]                   }
[16:18:41.700]                   ...future.strategy.old <- future::plan("list")
[16:18:41.700]                   options(future.plan = NULL)
[16:18:41.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.700]                 }
[16:18:41.700]                 ...future.workdir <- getwd()
[16:18:41.700]             }
[16:18:41.700]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.700]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.700]         }
[16:18:41.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.700]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:41.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.700]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.700]             base::names(...future.oldOptions))
[16:18:41.700]     }
[16:18:41.700]     if (FALSE) {
[16:18:41.700]     }
[16:18:41.700]     else {
[16:18:41.700]         if (TRUE) {
[16:18:41.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.700]                 open = "w")
[16:18:41.700]         }
[16:18:41.700]         else {
[16:18:41.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.700]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.700]         }
[16:18:41.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.700]             base::sink(type = "output", split = FALSE)
[16:18:41.700]             base::close(...future.stdout)
[16:18:41.700]         }, add = TRUE)
[16:18:41.700]     }
[16:18:41.700]     ...future.frame <- base::sys.nframe()
[16:18:41.700]     ...future.conditions <- base::list()
[16:18:41.700]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.700]     if (FALSE) {
[16:18:41.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.700]     }
[16:18:41.700]     ...future.result <- base::tryCatch({
[16:18:41.700]         base::withCallingHandlers({
[16:18:41.700]             ...future.value <- base::withVisible(base::local({
[16:18:41.700]                 withCallingHandlers({
[16:18:41.700]                   {
[16:18:41.700]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.700]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.700]                       ...future.globals.maxSize)) {
[16:18:41.700]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.700]                       on.exit(options(oopts), add = TRUE)
[16:18:41.700]                     }
[16:18:41.700]                     {
[16:18:41.700]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.700]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.700]                         USE.NAMES = FALSE)
[16:18:41.700]                       do.call(mapply, args = args)
[16:18:41.700]                     }
[16:18:41.700]                   }
[16:18:41.700]                 }, immediateCondition = function(cond) {
[16:18:41.700]                   save_rds <- function (object, pathname, ...) 
[16:18:41.700]                   {
[16:18:41.700]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.700]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.700]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.700]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.700]                         fi_tmp[["mtime"]])
[16:18:41.700]                     }
[16:18:41.700]                     tryCatch({
[16:18:41.700]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.700]                     }, error = function(ex) {
[16:18:41.700]                       msg <- conditionMessage(ex)
[16:18:41.700]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.700]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.700]                         fi_tmp[["mtime"]], msg)
[16:18:41.700]                       ex$message <- msg
[16:18:41.700]                       stop(ex)
[16:18:41.700]                     })
[16:18:41.700]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.700]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.700]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.700]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.700]                       fi <- file.info(pathname)
[16:18:41.700]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.700]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.700]                         fi[["size"]], fi[["mtime"]])
[16:18:41.700]                       stop(msg)
[16:18:41.700]                     }
[16:18:41.700]                     invisible(pathname)
[16:18:41.700]                   }
[16:18:41.700]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.700]                     rootPath = tempdir()) 
[16:18:41.700]                   {
[16:18:41.700]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.700]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.700]                       tmpdir = path, fileext = ".rds")
[16:18:41.700]                     save_rds(obj, file)
[16:18:41.700]                   }
[16:18:41.700]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.700]                   {
[16:18:41.700]                     inherits <- base::inherits
[16:18:41.700]                     invokeRestart <- base::invokeRestart
[16:18:41.700]                     is.null <- base::is.null
[16:18:41.700]                     muffled <- FALSE
[16:18:41.700]                     if (inherits(cond, "message")) {
[16:18:41.700]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.700]                       if (muffled) 
[16:18:41.700]                         invokeRestart("muffleMessage")
[16:18:41.700]                     }
[16:18:41.700]                     else if (inherits(cond, "warning")) {
[16:18:41.700]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.700]                       if (muffled) 
[16:18:41.700]                         invokeRestart("muffleWarning")
[16:18:41.700]                     }
[16:18:41.700]                     else if (inherits(cond, "condition")) {
[16:18:41.700]                       if (!is.null(pattern)) {
[16:18:41.700]                         computeRestarts <- base::computeRestarts
[16:18:41.700]                         grepl <- base::grepl
[16:18:41.700]                         restarts <- computeRestarts(cond)
[16:18:41.700]                         for (restart in restarts) {
[16:18:41.700]                           name <- restart$name
[16:18:41.700]                           if (is.null(name)) 
[16:18:41.700]                             next
[16:18:41.700]                           if (!grepl(pattern, name)) 
[16:18:41.700]                             next
[16:18:41.700]                           invokeRestart(restart)
[16:18:41.700]                           muffled <- TRUE
[16:18:41.700]                           break
[16:18:41.700]                         }
[16:18:41.700]                       }
[16:18:41.700]                     }
[16:18:41.700]                     invisible(muffled)
[16:18:41.700]                   }
[16:18:41.700]                   muffleCondition(cond)
[16:18:41.700]                 })
[16:18:41.700]             }))
[16:18:41.700]             future::FutureResult(value = ...future.value$value, 
[16:18:41.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.700]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.700]                     ...future.globalenv.names))
[16:18:41.700]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.700]         }, condition = base::local({
[16:18:41.700]             c <- base::c
[16:18:41.700]             inherits <- base::inherits
[16:18:41.700]             invokeRestart <- base::invokeRestart
[16:18:41.700]             length <- base::length
[16:18:41.700]             list <- base::list
[16:18:41.700]             seq.int <- base::seq.int
[16:18:41.700]             signalCondition <- base::signalCondition
[16:18:41.700]             sys.calls <- base::sys.calls
[16:18:41.700]             `[[` <- base::`[[`
[16:18:41.700]             `+` <- base::`+`
[16:18:41.700]             `<<-` <- base::`<<-`
[16:18:41.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.700]                   3L)]
[16:18:41.700]             }
[16:18:41.700]             function(cond) {
[16:18:41.700]                 is_error <- inherits(cond, "error")
[16:18:41.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.700]                   NULL)
[16:18:41.700]                 if (is_error) {
[16:18:41.700]                   sessionInformation <- function() {
[16:18:41.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.700]                       search = base::search(), system = base::Sys.info())
[16:18:41.700]                   }
[16:18:41.700]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.700]                     cond$call), session = sessionInformation(), 
[16:18:41.700]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.700]                   signalCondition(cond)
[16:18:41.700]                 }
[16:18:41.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.700]                 "immediateCondition"))) {
[16:18:41.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.700]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.700]                   if (TRUE && !signal) {
[16:18:41.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.700]                     {
[16:18:41.700]                       inherits <- base::inherits
[16:18:41.700]                       invokeRestart <- base::invokeRestart
[16:18:41.700]                       is.null <- base::is.null
[16:18:41.700]                       muffled <- FALSE
[16:18:41.700]                       if (inherits(cond, "message")) {
[16:18:41.700]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.700]                         if (muffled) 
[16:18:41.700]                           invokeRestart("muffleMessage")
[16:18:41.700]                       }
[16:18:41.700]                       else if (inherits(cond, "warning")) {
[16:18:41.700]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.700]                         if (muffled) 
[16:18:41.700]                           invokeRestart("muffleWarning")
[16:18:41.700]                       }
[16:18:41.700]                       else if (inherits(cond, "condition")) {
[16:18:41.700]                         if (!is.null(pattern)) {
[16:18:41.700]                           computeRestarts <- base::computeRestarts
[16:18:41.700]                           grepl <- base::grepl
[16:18:41.700]                           restarts <- computeRestarts(cond)
[16:18:41.700]                           for (restart in restarts) {
[16:18:41.700]                             name <- restart$name
[16:18:41.700]                             if (is.null(name)) 
[16:18:41.700]                               next
[16:18:41.700]                             if (!grepl(pattern, name)) 
[16:18:41.700]                               next
[16:18:41.700]                             invokeRestart(restart)
[16:18:41.700]                             muffled <- TRUE
[16:18:41.700]                             break
[16:18:41.700]                           }
[16:18:41.700]                         }
[16:18:41.700]                       }
[16:18:41.700]                       invisible(muffled)
[16:18:41.700]                     }
[16:18:41.700]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.700]                   }
[16:18:41.700]                 }
[16:18:41.700]                 else {
[16:18:41.700]                   if (TRUE) {
[16:18:41.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.700]                     {
[16:18:41.700]                       inherits <- base::inherits
[16:18:41.700]                       invokeRestart <- base::invokeRestart
[16:18:41.700]                       is.null <- base::is.null
[16:18:41.700]                       muffled <- FALSE
[16:18:41.700]                       if (inherits(cond, "message")) {
[16:18:41.700]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.700]                         if (muffled) 
[16:18:41.700]                           invokeRestart("muffleMessage")
[16:18:41.700]                       }
[16:18:41.700]                       else if (inherits(cond, "warning")) {
[16:18:41.700]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.700]                         if (muffled) 
[16:18:41.700]                           invokeRestart("muffleWarning")
[16:18:41.700]                       }
[16:18:41.700]                       else if (inherits(cond, "condition")) {
[16:18:41.700]                         if (!is.null(pattern)) {
[16:18:41.700]                           computeRestarts <- base::computeRestarts
[16:18:41.700]                           grepl <- base::grepl
[16:18:41.700]                           restarts <- computeRestarts(cond)
[16:18:41.700]                           for (restart in restarts) {
[16:18:41.700]                             name <- restart$name
[16:18:41.700]                             if (is.null(name)) 
[16:18:41.700]                               next
[16:18:41.700]                             if (!grepl(pattern, name)) 
[16:18:41.700]                               next
[16:18:41.700]                             invokeRestart(restart)
[16:18:41.700]                             muffled <- TRUE
[16:18:41.700]                             break
[16:18:41.700]                           }
[16:18:41.700]                         }
[16:18:41.700]                       }
[16:18:41.700]                       invisible(muffled)
[16:18:41.700]                     }
[16:18:41.700]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.700]                   }
[16:18:41.700]                 }
[16:18:41.700]             }
[16:18:41.700]         }))
[16:18:41.700]     }, error = function(ex) {
[16:18:41.700]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.700]                 ...future.rng), started = ...future.startTime, 
[16:18:41.700]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.700]             version = "1.8"), class = "FutureResult")
[16:18:41.700]     }, finally = {
[16:18:41.700]         if (!identical(...future.workdir, getwd())) 
[16:18:41.700]             setwd(...future.workdir)
[16:18:41.700]         {
[16:18:41.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.700]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.700]             }
[16:18:41.700]             base::options(...future.oldOptions)
[16:18:41.700]             if (.Platform$OS.type == "windows") {
[16:18:41.700]                 old_names <- names(...future.oldEnvVars)
[16:18:41.700]                 envs <- base::Sys.getenv()
[16:18:41.700]                 names <- names(envs)
[16:18:41.700]                 common <- intersect(names, old_names)
[16:18:41.700]                 added <- setdiff(names, old_names)
[16:18:41.700]                 removed <- setdiff(old_names, names)
[16:18:41.700]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.700]                   envs[common]]
[16:18:41.700]                 NAMES <- toupper(changed)
[16:18:41.700]                 args <- list()
[16:18:41.700]                 for (kk in seq_along(NAMES)) {
[16:18:41.700]                   name <- changed[[kk]]
[16:18:41.700]                   NAME <- NAMES[[kk]]
[16:18:41.700]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.700]                     next
[16:18:41.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.700]                 }
[16:18:41.700]                 NAMES <- toupper(added)
[16:18:41.700]                 for (kk in seq_along(NAMES)) {
[16:18:41.700]                   name <- added[[kk]]
[16:18:41.700]                   NAME <- NAMES[[kk]]
[16:18:41.700]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.700]                     next
[16:18:41.700]                   args[[name]] <- ""
[16:18:41.700]                 }
[16:18:41.700]                 NAMES <- toupper(removed)
[16:18:41.700]                 for (kk in seq_along(NAMES)) {
[16:18:41.700]                   name <- removed[[kk]]
[16:18:41.700]                   NAME <- NAMES[[kk]]
[16:18:41.700]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.700]                     next
[16:18:41.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.700]                 }
[16:18:41.700]                 if (length(args) > 0) 
[16:18:41.700]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.700]             }
[16:18:41.700]             else {
[16:18:41.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.700]             }
[16:18:41.700]             {
[16:18:41.700]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.700]                   0L) {
[16:18:41.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.700]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.700]                   base::options(opts)
[16:18:41.700]                 }
[16:18:41.700]                 {
[16:18:41.700]                   {
[16:18:41.700]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.700]                     NULL
[16:18:41.700]                   }
[16:18:41.700]                   options(future.plan = NULL)
[16:18:41.700]                   if (is.na(NA_character_)) 
[16:18:41.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.700]                     .init = FALSE)
[16:18:41.700]                 }
[16:18:41.700]             }
[16:18:41.700]         }
[16:18:41.700]     })
[16:18:41.700]     if (TRUE) {
[16:18:41.700]         base::sink(type = "output", split = FALSE)
[16:18:41.700]         if (TRUE) {
[16:18:41.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.700]         }
[16:18:41.700]         else {
[16:18:41.700]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.700]         }
[16:18:41.700]         base::close(...future.stdout)
[16:18:41.700]         ...future.stdout <- NULL
[16:18:41.700]     }
[16:18:41.700]     ...future.result$conditions <- ...future.conditions
[16:18:41.700]     ...future.result$finished <- base::Sys.time()
[16:18:41.700]     ...future.result
[16:18:41.700] }
[16:18:41.703] assign_globals() ...
[16:18:41.704] List of 5
[16:18:41.704]  $ ...future.FUN            :function (C, k)  
[16:18:41.704]  $ MoreArgs                 : NULL
[16:18:41.704]  $ ...future.elements_ii    :List of 2
[16:18:41.704]   ..$ :List of 1
[16:18:41.704]   .. ..$ : chr "C"
[16:18:41.704]   ..$ :List of 1
[16:18:41.704]   .. ..$ : int 3
[16:18:41.704]  $ ...future.seeds_ii       : NULL
[16:18:41.704]  $ ...future.globals.maxSize: NULL
[16:18:41.704]  - attr(*, "where")=List of 5
[16:18:41.704]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.704]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.704]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.704]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.704]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.704]  - attr(*, "resolved")= logi FALSE
[16:18:41.704]  - attr(*, "total_size")= num 3488
[16:18:41.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.704]  - attr(*, "already-done")= logi TRUE
[16:18:41.714] - reassign environment for ‘...future.FUN’
[16:18:41.714] - copied ‘...future.FUN’ to environment
[16:18:41.714] - copied ‘MoreArgs’ to environment
[16:18:41.714] - copied ‘...future.elements_ii’ to environment
[16:18:41.715] - copied ‘...future.seeds_ii’ to environment
[16:18:41.715] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.715] assign_globals() ... done
[16:18:41.715] requestCore(): workers = 2
[16:18:41.716] Poll #1 (0): usedCores() = 2, workers = 2
[16:18:41.726] result() for MulticoreFuture ...
[16:18:41.727] result() for MulticoreFuture ...
[16:18:41.727] result() for MulticoreFuture ... done
[16:18:41.728] result() for MulticoreFuture ... done
[16:18:41.728] result() for MulticoreFuture ...
[16:18:41.728] result() for MulticoreFuture ... done
[16:18:41.732] MulticoreFuture started
[16:18:41.732] - Launch lazy future ... done
[16:18:41.733] plan(): Setting new future strategy stack:
[16:18:41.733] run() for ‘MulticoreFuture’ ... done
[16:18:41.734] Created future:
[16:18:41.733] List of future strategies:
[16:18:41.733] 1. sequential:
[16:18:41.733]    - args: function (..., envir = parent.frame())
[16:18:41.733]    - tweaked: FALSE
[16:18:41.733]    - call: NULL
[16:18:41.735] plan(): nbrOfWorkers() = 1
[16:18:41.738] plan(): Setting new future strategy stack:
[16:18:41.739] List of future strategies:
[16:18:41.739] 1. multicore:
[16:18:41.739]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.739]    - tweaked: FALSE
[16:18:41.739]    - call: plan(strategy)
[16:18:41.745] plan(): nbrOfWorkers() = 2
[16:18:41.734] MulticoreFuture:
[16:18:41.734] Label: ‘future_mapply-3’
[16:18:41.734] Expression:
[16:18:41.734] {
[16:18:41.734]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.734]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.734]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.734]         on.exit(options(oopts), add = TRUE)
[16:18:41.734]     }
[16:18:41.734]     {
[16:18:41.734]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.734]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.734]         do.call(mapply, args = args)
[16:18:41.734]     }
[16:18:41.734] }
[16:18:41.734] Lazy evaluation: FALSE
[16:18:41.734] Asynchronous evaluation: TRUE
[16:18:41.734] Local evaluation: TRUE
[16:18:41.734] Environment: R_GlobalEnv
[16:18:41.734] Capture standard output: TRUE
[16:18:41.734] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.734] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.734] Packages: <none>
[16:18:41.734] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.734] Resolved: TRUE
[16:18:41.734] Value: <not collected>
[16:18:41.734] Conditions captured: <none>
[16:18:41.734] Early signaling: FALSE
[16:18:41.734] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.734] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.747] Chunk #3 of 5 ... DONE
[16:18:41.747] Chunk #4 of 5 ...
[16:18:41.747]  - Finding globals in '...' for chunk #4 ...
[16:18:41.748] getGlobalsAndPackages() ...
[16:18:41.748] Searching for globals...
[16:18:41.749] 
[16:18:41.749] Searching for globals ... DONE
[16:18:41.749] - globals: [0] <none>
[16:18:41.749] getGlobalsAndPackages() ... DONE
[16:18:41.749]    + additional globals found: [n=0] 
[16:18:41.749]    + additional namespaces needed: [n=0] 
[16:18:41.750]  - Finding globals in '...' for chunk #4 ... DONE
[16:18:41.750]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:41.750]  - seeds: <none>
[16:18:41.750]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.750] getGlobalsAndPackages() ...
[16:18:41.751] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.751] Resolving globals: FALSE
[16:18:41.751] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:41.753] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:41.753] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.753] 
[16:18:41.753] getGlobalsAndPackages() ... DONE
[16:18:41.754] run() for ‘Future’ ...
[16:18:41.754] - state: ‘created’
[16:18:41.754] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.759] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.759] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.759]   - Field: ‘label’
[16:18:41.759]   - Field: ‘local’
[16:18:41.759]   - Field: ‘owner’
[16:18:41.760]   - Field: ‘envir’
[16:18:41.760]   - Field: ‘workers’
[16:18:41.760]   - Field: ‘packages’
[16:18:41.760]   - Field: ‘gc’
[16:18:41.760]   - Field: ‘job’
[16:18:41.760]   - Field: ‘conditions’
[16:18:41.760]   - Field: ‘expr’
[16:18:41.761]   - Field: ‘uuid’
[16:18:41.761]   - Field: ‘seed’
[16:18:41.761]   - Field: ‘version’
[16:18:41.761]   - Field: ‘result’
[16:18:41.761]   - Field: ‘asynchronous’
[16:18:41.761]   - Field: ‘calls’
[16:18:41.761]   - Field: ‘globals’
[16:18:41.762]   - Field: ‘stdout’
[16:18:41.762]   - Field: ‘earlySignal’
[16:18:41.762]   - Field: ‘lazy’
[16:18:41.762]   - Field: ‘state’
[16:18:41.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.762] - Launch lazy future ...
[16:18:41.763] Packages needed by the future expression (n = 0): <none>
[16:18:41.763] Packages needed by future strategies (n = 0): <none>
[16:18:41.763] {
[16:18:41.763]     {
[16:18:41.763]         {
[16:18:41.763]             ...future.startTime <- base::Sys.time()
[16:18:41.763]             {
[16:18:41.763]                 {
[16:18:41.763]                   {
[16:18:41.763]                     {
[16:18:41.763]                       base::local({
[16:18:41.763]                         has_future <- base::requireNamespace("future", 
[16:18:41.763]                           quietly = TRUE)
[16:18:41.763]                         if (has_future) {
[16:18:41.763]                           ns <- base::getNamespace("future")
[16:18:41.763]                           version <- ns[[".package"]][["version"]]
[16:18:41.763]                           if (is.null(version)) 
[16:18:41.763]                             version <- utils::packageVersion("future")
[16:18:41.763]                         }
[16:18:41.763]                         else {
[16:18:41.763]                           version <- NULL
[16:18:41.763]                         }
[16:18:41.763]                         if (!has_future || version < "1.8.0") {
[16:18:41.763]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.763]                             "", base::R.version$version.string), 
[16:18:41.763]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.763]                               "release", "version")], collapse = " "), 
[16:18:41.763]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.763]                             info)
[16:18:41.763]                           info <- base::paste(info, collapse = "; ")
[16:18:41.763]                           if (!has_future) {
[16:18:41.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.763]                               info)
[16:18:41.763]                           }
[16:18:41.763]                           else {
[16:18:41.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.763]                               info, version)
[16:18:41.763]                           }
[16:18:41.763]                           base::stop(msg)
[16:18:41.763]                         }
[16:18:41.763]                       })
[16:18:41.763]                     }
[16:18:41.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.763]                     base::options(mc.cores = 1L)
[16:18:41.763]                   }
[16:18:41.763]                   ...future.strategy.old <- future::plan("list")
[16:18:41.763]                   options(future.plan = NULL)
[16:18:41.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.763]                 }
[16:18:41.763]                 ...future.workdir <- getwd()
[16:18:41.763]             }
[16:18:41.763]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.763]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.763]         }
[16:18:41.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.763]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:41.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.763]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.763]             base::names(...future.oldOptions))
[16:18:41.763]     }
[16:18:41.763]     if (FALSE) {
[16:18:41.763]     }
[16:18:41.763]     else {
[16:18:41.763]         if (TRUE) {
[16:18:41.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.763]                 open = "w")
[16:18:41.763]         }
[16:18:41.763]         else {
[16:18:41.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.763]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.763]         }
[16:18:41.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.763]             base::sink(type = "output", split = FALSE)
[16:18:41.763]             base::close(...future.stdout)
[16:18:41.763]         }, add = TRUE)
[16:18:41.763]     }
[16:18:41.763]     ...future.frame <- base::sys.nframe()
[16:18:41.763]     ...future.conditions <- base::list()
[16:18:41.763]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.763]     if (FALSE) {
[16:18:41.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.763]     }
[16:18:41.763]     ...future.result <- base::tryCatch({
[16:18:41.763]         base::withCallingHandlers({
[16:18:41.763]             ...future.value <- base::withVisible(base::local({
[16:18:41.763]                 withCallingHandlers({
[16:18:41.763]                   {
[16:18:41.763]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.763]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.763]                       ...future.globals.maxSize)) {
[16:18:41.763]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.763]                       on.exit(options(oopts), add = TRUE)
[16:18:41.763]                     }
[16:18:41.763]                     {
[16:18:41.763]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.763]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.763]                         USE.NAMES = FALSE)
[16:18:41.763]                       do.call(mapply, args = args)
[16:18:41.763]                     }
[16:18:41.763]                   }
[16:18:41.763]                 }, immediateCondition = function(cond) {
[16:18:41.763]                   save_rds <- function (object, pathname, ...) 
[16:18:41.763]                   {
[16:18:41.763]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.763]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.763]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.763]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.763]                         fi_tmp[["mtime"]])
[16:18:41.763]                     }
[16:18:41.763]                     tryCatch({
[16:18:41.763]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.763]                     }, error = function(ex) {
[16:18:41.763]                       msg <- conditionMessage(ex)
[16:18:41.763]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.763]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.763]                         fi_tmp[["mtime"]], msg)
[16:18:41.763]                       ex$message <- msg
[16:18:41.763]                       stop(ex)
[16:18:41.763]                     })
[16:18:41.763]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.763]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.763]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.763]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.763]                       fi <- file.info(pathname)
[16:18:41.763]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.763]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.763]                         fi[["size"]], fi[["mtime"]])
[16:18:41.763]                       stop(msg)
[16:18:41.763]                     }
[16:18:41.763]                     invisible(pathname)
[16:18:41.763]                   }
[16:18:41.763]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.763]                     rootPath = tempdir()) 
[16:18:41.763]                   {
[16:18:41.763]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.763]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.763]                       tmpdir = path, fileext = ".rds")
[16:18:41.763]                     save_rds(obj, file)
[16:18:41.763]                   }
[16:18:41.763]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.763]                   {
[16:18:41.763]                     inherits <- base::inherits
[16:18:41.763]                     invokeRestart <- base::invokeRestart
[16:18:41.763]                     is.null <- base::is.null
[16:18:41.763]                     muffled <- FALSE
[16:18:41.763]                     if (inherits(cond, "message")) {
[16:18:41.763]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.763]                       if (muffled) 
[16:18:41.763]                         invokeRestart("muffleMessage")
[16:18:41.763]                     }
[16:18:41.763]                     else if (inherits(cond, "warning")) {
[16:18:41.763]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.763]                       if (muffled) 
[16:18:41.763]                         invokeRestart("muffleWarning")
[16:18:41.763]                     }
[16:18:41.763]                     else if (inherits(cond, "condition")) {
[16:18:41.763]                       if (!is.null(pattern)) {
[16:18:41.763]                         computeRestarts <- base::computeRestarts
[16:18:41.763]                         grepl <- base::grepl
[16:18:41.763]                         restarts <- computeRestarts(cond)
[16:18:41.763]                         for (restart in restarts) {
[16:18:41.763]                           name <- restart$name
[16:18:41.763]                           if (is.null(name)) 
[16:18:41.763]                             next
[16:18:41.763]                           if (!grepl(pattern, name)) 
[16:18:41.763]                             next
[16:18:41.763]                           invokeRestart(restart)
[16:18:41.763]                           muffled <- TRUE
[16:18:41.763]                           break
[16:18:41.763]                         }
[16:18:41.763]                       }
[16:18:41.763]                     }
[16:18:41.763]                     invisible(muffled)
[16:18:41.763]                   }
[16:18:41.763]                   muffleCondition(cond)
[16:18:41.763]                 })
[16:18:41.763]             }))
[16:18:41.763]             future::FutureResult(value = ...future.value$value, 
[16:18:41.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.763]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.763]                     ...future.globalenv.names))
[16:18:41.763]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.763]         }, condition = base::local({
[16:18:41.763]             c <- base::c
[16:18:41.763]             inherits <- base::inherits
[16:18:41.763]             invokeRestart <- base::invokeRestart
[16:18:41.763]             length <- base::length
[16:18:41.763]             list <- base::list
[16:18:41.763]             seq.int <- base::seq.int
[16:18:41.763]             signalCondition <- base::signalCondition
[16:18:41.763]             sys.calls <- base::sys.calls
[16:18:41.763]             `[[` <- base::`[[`
[16:18:41.763]             `+` <- base::`+`
[16:18:41.763]             `<<-` <- base::`<<-`
[16:18:41.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.763]                   3L)]
[16:18:41.763]             }
[16:18:41.763]             function(cond) {
[16:18:41.763]                 is_error <- inherits(cond, "error")
[16:18:41.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.763]                   NULL)
[16:18:41.763]                 if (is_error) {
[16:18:41.763]                   sessionInformation <- function() {
[16:18:41.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.763]                       search = base::search(), system = base::Sys.info())
[16:18:41.763]                   }
[16:18:41.763]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.763]                     cond$call), session = sessionInformation(), 
[16:18:41.763]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.763]                   signalCondition(cond)
[16:18:41.763]                 }
[16:18:41.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.763]                 "immediateCondition"))) {
[16:18:41.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.763]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.763]                   if (TRUE && !signal) {
[16:18:41.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.763]                     {
[16:18:41.763]                       inherits <- base::inherits
[16:18:41.763]                       invokeRestart <- base::invokeRestart
[16:18:41.763]                       is.null <- base::is.null
[16:18:41.763]                       muffled <- FALSE
[16:18:41.763]                       if (inherits(cond, "message")) {
[16:18:41.763]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.763]                         if (muffled) 
[16:18:41.763]                           invokeRestart("muffleMessage")
[16:18:41.763]                       }
[16:18:41.763]                       else if (inherits(cond, "warning")) {
[16:18:41.763]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.763]                         if (muffled) 
[16:18:41.763]                           invokeRestart("muffleWarning")
[16:18:41.763]                       }
[16:18:41.763]                       else if (inherits(cond, "condition")) {
[16:18:41.763]                         if (!is.null(pattern)) {
[16:18:41.763]                           computeRestarts <- base::computeRestarts
[16:18:41.763]                           grepl <- base::grepl
[16:18:41.763]                           restarts <- computeRestarts(cond)
[16:18:41.763]                           for (restart in restarts) {
[16:18:41.763]                             name <- restart$name
[16:18:41.763]                             if (is.null(name)) 
[16:18:41.763]                               next
[16:18:41.763]                             if (!grepl(pattern, name)) 
[16:18:41.763]                               next
[16:18:41.763]                             invokeRestart(restart)
[16:18:41.763]                             muffled <- TRUE
[16:18:41.763]                             break
[16:18:41.763]                           }
[16:18:41.763]                         }
[16:18:41.763]                       }
[16:18:41.763]                       invisible(muffled)
[16:18:41.763]                     }
[16:18:41.763]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.763]                   }
[16:18:41.763]                 }
[16:18:41.763]                 else {
[16:18:41.763]                   if (TRUE) {
[16:18:41.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.763]                     {
[16:18:41.763]                       inherits <- base::inherits
[16:18:41.763]                       invokeRestart <- base::invokeRestart
[16:18:41.763]                       is.null <- base::is.null
[16:18:41.763]                       muffled <- FALSE
[16:18:41.763]                       if (inherits(cond, "message")) {
[16:18:41.763]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.763]                         if (muffled) 
[16:18:41.763]                           invokeRestart("muffleMessage")
[16:18:41.763]                       }
[16:18:41.763]                       else if (inherits(cond, "warning")) {
[16:18:41.763]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.763]                         if (muffled) 
[16:18:41.763]                           invokeRestart("muffleWarning")
[16:18:41.763]                       }
[16:18:41.763]                       else if (inherits(cond, "condition")) {
[16:18:41.763]                         if (!is.null(pattern)) {
[16:18:41.763]                           computeRestarts <- base::computeRestarts
[16:18:41.763]                           grepl <- base::grepl
[16:18:41.763]                           restarts <- computeRestarts(cond)
[16:18:41.763]                           for (restart in restarts) {
[16:18:41.763]                             name <- restart$name
[16:18:41.763]                             if (is.null(name)) 
[16:18:41.763]                               next
[16:18:41.763]                             if (!grepl(pattern, name)) 
[16:18:41.763]                               next
[16:18:41.763]                             invokeRestart(restart)
[16:18:41.763]                             muffled <- TRUE
[16:18:41.763]                             break
[16:18:41.763]                           }
[16:18:41.763]                         }
[16:18:41.763]                       }
[16:18:41.763]                       invisible(muffled)
[16:18:41.763]                     }
[16:18:41.763]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.763]                   }
[16:18:41.763]                 }
[16:18:41.763]             }
[16:18:41.763]         }))
[16:18:41.763]     }, error = function(ex) {
[16:18:41.763]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.763]                 ...future.rng), started = ...future.startTime, 
[16:18:41.763]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.763]             version = "1.8"), class = "FutureResult")
[16:18:41.763]     }, finally = {
[16:18:41.763]         if (!identical(...future.workdir, getwd())) 
[16:18:41.763]             setwd(...future.workdir)
[16:18:41.763]         {
[16:18:41.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.763]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.763]             }
[16:18:41.763]             base::options(...future.oldOptions)
[16:18:41.763]             if (.Platform$OS.type == "windows") {
[16:18:41.763]                 old_names <- names(...future.oldEnvVars)
[16:18:41.763]                 envs <- base::Sys.getenv()
[16:18:41.763]                 names <- names(envs)
[16:18:41.763]                 common <- intersect(names, old_names)
[16:18:41.763]                 added <- setdiff(names, old_names)
[16:18:41.763]                 removed <- setdiff(old_names, names)
[16:18:41.763]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.763]                   envs[common]]
[16:18:41.763]                 NAMES <- toupper(changed)
[16:18:41.763]                 args <- list()
[16:18:41.763]                 for (kk in seq_along(NAMES)) {
[16:18:41.763]                   name <- changed[[kk]]
[16:18:41.763]                   NAME <- NAMES[[kk]]
[16:18:41.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.763]                     next
[16:18:41.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.763]                 }
[16:18:41.763]                 NAMES <- toupper(added)
[16:18:41.763]                 for (kk in seq_along(NAMES)) {
[16:18:41.763]                   name <- added[[kk]]
[16:18:41.763]                   NAME <- NAMES[[kk]]
[16:18:41.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.763]                     next
[16:18:41.763]                   args[[name]] <- ""
[16:18:41.763]                 }
[16:18:41.763]                 NAMES <- toupper(removed)
[16:18:41.763]                 for (kk in seq_along(NAMES)) {
[16:18:41.763]                   name <- removed[[kk]]
[16:18:41.763]                   NAME <- NAMES[[kk]]
[16:18:41.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.763]                     next
[16:18:41.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.763]                 }
[16:18:41.763]                 if (length(args) > 0) 
[16:18:41.763]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.763]             }
[16:18:41.763]             else {
[16:18:41.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.763]             }
[16:18:41.763]             {
[16:18:41.763]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.763]                   0L) {
[16:18:41.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.763]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.763]                   base::options(opts)
[16:18:41.763]                 }
[16:18:41.763]                 {
[16:18:41.763]                   {
[16:18:41.763]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.763]                     NULL
[16:18:41.763]                   }
[16:18:41.763]                   options(future.plan = NULL)
[16:18:41.763]                   if (is.na(NA_character_)) 
[16:18:41.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.763]                     .init = FALSE)
[16:18:41.763]                 }
[16:18:41.763]             }
[16:18:41.763]         }
[16:18:41.763]     })
[16:18:41.763]     if (TRUE) {
[16:18:41.763]         base::sink(type = "output", split = FALSE)
[16:18:41.763]         if (TRUE) {
[16:18:41.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.763]         }
[16:18:41.763]         else {
[16:18:41.763]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.763]         }
[16:18:41.763]         base::close(...future.stdout)
[16:18:41.763]         ...future.stdout <- NULL
[16:18:41.763]     }
[16:18:41.763]     ...future.result$conditions <- ...future.conditions
[16:18:41.763]     ...future.result$finished <- base::Sys.time()
[16:18:41.763]     ...future.result
[16:18:41.763] }
[16:18:41.767] assign_globals() ...
[16:18:41.767] List of 5
[16:18:41.767]  $ ...future.FUN            :function (C, k)  
[16:18:41.767]  $ MoreArgs                 : NULL
[16:18:41.767]  $ ...future.elements_ii    :List of 2
[16:18:41.767]   ..$ :List of 1
[16:18:41.767]   .. ..$ : chr "D"
[16:18:41.767]   ..$ :List of 1
[16:18:41.767]   .. ..$ : int 2
[16:18:41.767]  $ ...future.seeds_ii       : NULL
[16:18:41.767]  $ ...future.globals.maxSize: NULL
[16:18:41.767]  - attr(*, "where")=List of 5
[16:18:41.767]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.767]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.767]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.767]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.767]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.767]  - attr(*, "resolved")= logi FALSE
[16:18:41.767]  - attr(*, "total_size")= num 3488
[16:18:41.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.767]  - attr(*, "already-done")= logi TRUE
[16:18:41.774] - reassign environment for ‘...future.FUN’
[16:18:41.774] - copied ‘...future.FUN’ to environment
[16:18:41.774] - copied ‘MoreArgs’ to environment
[16:18:41.774] - copied ‘...future.elements_ii’ to environment
[16:18:41.774] - copied ‘...future.seeds_ii’ to environment
[16:18:41.774] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.774] assign_globals() ... done
[16:18:41.775] requestCore(): workers = 2
[16:18:41.775] Poll #1 (0): usedCores() = 2, workers = 2
[16:18:41.800] result() for MulticoreFuture ...
[16:18:41.800] result() for MulticoreFuture ...
[16:18:41.801] result() for MulticoreFuture ... done
[16:18:41.801] result() for MulticoreFuture ... done
[16:18:41.801] result() for MulticoreFuture ...
[16:18:41.801] result() for MulticoreFuture ... done
[16:18:41.804] MulticoreFuture started
[16:18:41.805] - Launch lazy future ... done
[16:18:41.805] run() for ‘MulticoreFuture’ ... done
[16:18:41.806] Created future:
[16:18:41.806] plan(): Setting new future strategy stack:
[16:18:41.806] List of future strategies:
[16:18:41.806] 1. sequential:
[16:18:41.806]    - args: function (..., envir = parent.frame())
[16:18:41.806]    - tweaked: FALSE
[16:18:41.806]    - call: NULL
[16:18:41.807] plan(): nbrOfWorkers() = 1
[16:18:41.810] plan(): Setting new future strategy stack:
[16:18:41.810] List of future strategies:
[16:18:41.810] 1. multicore:
[16:18:41.810]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.810]    - tweaked: FALSE
[16:18:41.810]    - call: plan(strategy)
[16:18:41.815] plan(): nbrOfWorkers() = 2
[16:18:41.806] MulticoreFuture:
[16:18:41.806] Label: ‘future_mapply-4’
[16:18:41.806] Expression:
[16:18:41.806] {
[16:18:41.806]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.806]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.806]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.806]         on.exit(options(oopts), add = TRUE)
[16:18:41.806]     }
[16:18:41.806]     {
[16:18:41.806]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.806]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.806]         do.call(mapply, args = args)
[16:18:41.806]     }
[16:18:41.806] }
[16:18:41.806] Lazy evaluation: FALSE
[16:18:41.806] Asynchronous evaluation: TRUE
[16:18:41.806] Local evaluation: TRUE
[16:18:41.806] Environment: R_GlobalEnv
[16:18:41.806] Capture standard output: TRUE
[16:18:41.806] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.806] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.806] Packages: <none>
[16:18:41.806] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.806] Resolved: TRUE
[16:18:41.806] Value: <not collected>
[16:18:41.806] Conditions captured: <none>
[16:18:41.806] Early signaling: FALSE
[16:18:41.806] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.806] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.816] Chunk #4 of 5 ... DONE
[16:18:41.816] Chunk #5 of 5 ...
[16:18:41.817]  - Finding globals in '...' for chunk #5 ...
[16:18:41.817] getGlobalsAndPackages() ...
[16:18:41.817] Searching for globals...
[16:18:41.817] 
[16:18:41.818] Searching for globals ... DONE
[16:18:41.818] - globals: [0] <none>
[16:18:41.818] getGlobalsAndPackages() ... DONE
[16:18:41.818]    + additional globals found: [n=0] 
[16:18:41.818]    + additional namespaces needed: [n=0] 
[16:18:41.818]  - Finding globals in '...' for chunk #5 ... DONE
[16:18:41.819]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:41.819]  - seeds: <none>
[16:18:41.819]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.819] getGlobalsAndPackages() ...
[16:18:41.819] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.820] Resolving globals: FALSE
[16:18:41.821] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:41.822] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:41.822] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.822] 
[16:18:41.823] getGlobalsAndPackages() ... DONE
[16:18:41.823] run() for ‘Future’ ...
[16:18:41.824] - state: ‘created’
[16:18:41.824] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.829] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.829] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.829]   - Field: ‘label’
[16:18:41.830]   - Field: ‘local’
[16:18:41.830]   - Field: ‘owner’
[16:18:41.830]   - Field: ‘envir’
[16:18:41.830]   - Field: ‘workers’
[16:18:41.830]   - Field: ‘packages’
[16:18:41.831]   - Field: ‘gc’
[16:18:41.831]   - Field: ‘job’
[16:18:41.831]   - Field: ‘conditions’
[16:18:41.831]   - Field: ‘expr’
[16:18:41.831]   - Field: ‘uuid’
[16:18:41.831]   - Field: ‘seed’
[16:18:41.832]   - Field: ‘version’
[16:18:41.832]   - Field: ‘result’
[16:18:41.832]   - Field: ‘asynchronous’
[16:18:41.832]   - Field: ‘calls’
[16:18:41.836]   - Field: ‘globals’
[16:18:41.836]   - Field: ‘stdout’
[16:18:41.836]   - Field: ‘earlySignal’
[16:18:41.837]   - Field: ‘lazy’
[16:18:41.837]   - Field: ‘state’
[16:18:41.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.838] - Launch lazy future ...
[16:18:41.839] Packages needed by the future expression (n = 0): <none>
[16:18:41.839] Packages needed by future strategies (n = 0): <none>
[16:18:41.841] {
[16:18:41.841]     {
[16:18:41.841]         {
[16:18:41.841]             ...future.startTime <- base::Sys.time()
[16:18:41.841]             {
[16:18:41.841]                 {
[16:18:41.841]                   {
[16:18:41.841]                     {
[16:18:41.841]                       base::local({
[16:18:41.841]                         has_future <- base::requireNamespace("future", 
[16:18:41.841]                           quietly = TRUE)
[16:18:41.841]                         if (has_future) {
[16:18:41.841]                           ns <- base::getNamespace("future")
[16:18:41.841]                           version <- ns[[".package"]][["version"]]
[16:18:41.841]                           if (is.null(version)) 
[16:18:41.841]                             version <- utils::packageVersion("future")
[16:18:41.841]                         }
[16:18:41.841]                         else {
[16:18:41.841]                           version <- NULL
[16:18:41.841]                         }
[16:18:41.841]                         if (!has_future || version < "1.8.0") {
[16:18:41.841]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.841]                             "", base::R.version$version.string), 
[16:18:41.841]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.841]                               "release", "version")], collapse = " "), 
[16:18:41.841]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.841]                             info)
[16:18:41.841]                           info <- base::paste(info, collapse = "; ")
[16:18:41.841]                           if (!has_future) {
[16:18:41.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.841]                               info)
[16:18:41.841]                           }
[16:18:41.841]                           else {
[16:18:41.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.841]                               info, version)
[16:18:41.841]                           }
[16:18:41.841]                           base::stop(msg)
[16:18:41.841]                         }
[16:18:41.841]                       })
[16:18:41.841]                     }
[16:18:41.841]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.841]                     base::options(mc.cores = 1L)
[16:18:41.841]                   }
[16:18:41.841]                   ...future.strategy.old <- future::plan("list")
[16:18:41.841]                   options(future.plan = NULL)
[16:18:41.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.841]                 }
[16:18:41.841]                 ...future.workdir <- getwd()
[16:18:41.841]             }
[16:18:41.841]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.841]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.841]         }
[16:18:41.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.841]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:41.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.841]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.841]             base::names(...future.oldOptions))
[16:18:41.841]     }
[16:18:41.841]     if (FALSE) {
[16:18:41.841]     }
[16:18:41.841]     else {
[16:18:41.841]         if (TRUE) {
[16:18:41.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.841]                 open = "w")
[16:18:41.841]         }
[16:18:41.841]         else {
[16:18:41.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.841]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.841]         }
[16:18:41.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.841]             base::sink(type = "output", split = FALSE)
[16:18:41.841]             base::close(...future.stdout)
[16:18:41.841]         }, add = TRUE)
[16:18:41.841]     }
[16:18:41.841]     ...future.frame <- base::sys.nframe()
[16:18:41.841]     ...future.conditions <- base::list()
[16:18:41.841]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.841]     if (FALSE) {
[16:18:41.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.841]     }
[16:18:41.841]     ...future.result <- base::tryCatch({
[16:18:41.841]         base::withCallingHandlers({
[16:18:41.841]             ...future.value <- base::withVisible(base::local({
[16:18:41.841]                 withCallingHandlers({
[16:18:41.841]                   {
[16:18:41.841]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.841]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.841]                       ...future.globals.maxSize)) {
[16:18:41.841]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.841]                       on.exit(options(oopts), add = TRUE)
[16:18:41.841]                     }
[16:18:41.841]                     {
[16:18:41.841]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.841]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.841]                         USE.NAMES = FALSE)
[16:18:41.841]                       do.call(mapply, args = args)
[16:18:41.841]                     }
[16:18:41.841]                   }
[16:18:41.841]                 }, immediateCondition = function(cond) {
[16:18:41.841]                   save_rds <- function (object, pathname, ...) 
[16:18:41.841]                   {
[16:18:41.841]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.841]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.841]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.841]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.841]                         fi_tmp[["mtime"]])
[16:18:41.841]                     }
[16:18:41.841]                     tryCatch({
[16:18:41.841]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.841]                     }, error = function(ex) {
[16:18:41.841]                       msg <- conditionMessage(ex)
[16:18:41.841]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.841]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.841]                         fi_tmp[["mtime"]], msg)
[16:18:41.841]                       ex$message <- msg
[16:18:41.841]                       stop(ex)
[16:18:41.841]                     })
[16:18:41.841]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.841]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.841]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.841]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.841]                       fi <- file.info(pathname)
[16:18:41.841]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.841]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.841]                         fi[["size"]], fi[["mtime"]])
[16:18:41.841]                       stop(msg)
[16:18:41.841]                     }
[16:18:41.841]                     invisible(pathname)
[16:18:41.841]                   }
[16:18:41.841]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.841]                     rootPath = tempdir()) 
[16:18:41.841]                   {
[16:18:41.841]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.841]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.841]                       tmpdir = path, fileext = ".rds")
[16:18:41.841]                     save_rds(obj, file)
[16:18:41.841]                   }
[16:18:41.841]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.841]                   {
[16:18:41.841]                     inherits <- base::inherits
[16:18:41.841]                     invokeRestart <- base::invokeRestart
[16:18:41.841]                     is.null <- base::is.null
[16:18:41.841]                     muffled <- FALSE
[16:18:41.841]                     if (inherits(cond, "message")) {
[16:18:41.841]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.841]                       if (muffled) 
[16:18:41.841]                         invokeRestart("muffleMessage")
[16:18:41.841]                     }
[16:18:41.841]                     else if (inherits(cond, "warning")) {
[16:18:41.841]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.841]                       if (muffled) 
[16:18:41.841]                         invokeRestart("muffleWarning")
[16:18:41.841]                     }
[16:18:41.841]                     else if (inherits(cond, "condition")) {
[16:18:41.841]                       if (!is.null(pattern)) {
[16:18:41.841]                         computeRestarts <- base::computeRestarts
[16:18:41.841]                         grepl <- base::grepl
[16:18:41.841]                         restarts <- computeRestarts(cond)
[16:18:41.841]                         for (restart in restarts) {
[16:18:41.841]                           name <- restart$name
[16:18:41.841]                           if (is.null(name)) 
[16:18:41.841]                             next
[16:18:41.841]                           if (!grepl(pattern, name)) 
[16:18:41.841]                             next
[16:18:41.841]                           invokeRestart(restart)
[16:18:41.841]                           muffled <- TRUE
[16:18:41.841]                           break
[16:18:41.841]                         }
[16:18:41.841]                       }
[16:18:41.841]                     }
[16:18:41.841]                     invisible(muffled)
[16:18:41.841]                   }
[16:18:41.841]                   muffleCondition(cond)
[16:18:41.841]                 })
[16:18:41.841]             }))
[16:18:41.841]             future::FutureResult(value = ...future.value$value, 
[16:18:41.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.841]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.841]                     ...future.globalenv.names))
[16:18:41.841]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.841]         }, condition = base::local({
[16:18:41.841]             c <- base::c
[16:18:41.841]             inherits <- base::inherits
[16:18:41.841]             invokeRestart <- base::invokeRestart
[16:18:41.841]             length <- base::length
[16:18:41.841]             list <- base::list
[16:18:41.841]             seq.int <- base::seq.int
[16:18:41.841]             signalCondition <- base::signalCondition
[16:18:41.841]             sys.calls <- base::sys.calls
[16:18:41.841]             `[[` <- base::`[[`
[16:18:41.841]             `+` <- base::`+`
[16:18:41.841]             `<<-` <- base::`<<-`
[16:18:41.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.841]                   3L)]
[16:18:41.841]             }
[16:18:41.841]             function(cond) {
[16:18:41.841]                 is_error <- inherits(cond, "error")
[16:18:41.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.841]                   NULL)
[16:18:41.841]                 if (is_error) {
[16:18:41.841]                   sessionInformation <- function() {
[16:18:41.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.841]                       search = base::search(), system = base::Sys.info())
[16:18:41.841]                   }
[16:18:41.841]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.841]                     cond$call), session = sessionInformation(), 
[16:18:41.841]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.841]                   signalCondition(cond)
[16:18:41.841]                 }
[16:18:41.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.841]                 "immediateCondition"))) {
[16:18:41.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.841]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.841]                   if (TRUE && !signal) {
[16:18:41.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.841]                     {
[16:18:41.841]                       inherits <- base::inherits
[16:18:41.841]                       invokeRestart <- base::invokeRestart
[16:18:41.841]                       is.null <- base::is.null
[16:18:41.841]                       muffled <- FALSE
[16:18:41.841]                       if (inherits(cond, "message")) {
[16:18:41.841]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.841]                         if (muffled) 
[16:18:41.841]                           invokeRestart("muffleMessage")
[16:18:41.841]                       }
[16:18:41.841]                       else if (inherits(cond, "warning")) {
[16:18:41.841]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.841]                         if (muffled) 
[16:18:41.841]                           invokeRestart("muffleWarning")
[16:18:41.841]                       }
[16:18:41.841]                       else if (inherits(cond, "condition")) {
[16:18:41.841]                         if (!is.null(pattern)) {
[16:18:41.841]                           computeRestarts <- base::computeRestarts
[16:18:41.841]                           grepl <- base::grepl
[16:18:41.841]                           restarts <- computeRestarts(cond)
[16:18:41.841]                           for (restart in restarts) {
[16:18:41.841]                             name <- restart$name
[16:18:41.841]                             if (is.null(name)) 
[16:18:41.841]                               next
[16:18:41.841]                             if (!grepl(pattern, name)) 
[16:18:41.841]                               next
[16:18:41.841]                             invokeRestart(restart)
[16:18:41.841]                             muffled <- TRUE
[16:18:41.841]                             break
[16:18:41.841]                           }
[16:18:41.841]                         }
[16:18:41.841]                       }
[16:18:41.841]                       invisible(muffled)
[16:18:41.841]                     }
[16:18:41.841]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.841]                   }
[16:18:41.841]                 }
[16:18:41.841]                 else {
[16:18:41.841]                   if (TRUE) {
[16:18:41.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.841]                     {
[16:18:41.841]                       inherits <- base::inherits
[16:18:41.841]                       invokeRestart <- base::invokeRestart
[16:18:41.841]                       is.null <- base::is.null
[16:18:41.841]                       muffled <- FALSE
[16:18:41.841]                       if (inherits(cond, "message")) {
[16:18:41.841]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.841]                         if (muffled) 
[16:18:41.841]                           invokeRestart("muffleMessage")
[16:18:41.841]                       }
[16:18:41.841]                       else if (inherits(cond, "warning")) {
[16:18:41.841]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.841]                         if (muffled) 
[16:18:41.841]                           invokeRestart("muffleWarning")
[16:18:41.841]                       }
[16:18:41.841]                       else if (inherits(cond, "condition")) {
[16:18:41.841]                         if (!is.null(pattern)) {
[16:18:41.841]                           computeRestarts <- base::computeRestarts
[16:18:41.841]                           grepl <- base::grepl
[16:18:41.841]                           restarts <- computeRestarts(cond)
[16:18:41.841]                           for (restart in restarts) {
[16:18:41.841]                             name <- restart$name
[16:18:41.841]                             if (is.null(name)) 
[16:18:41.841]                               next
[16:18:41.841]                             if (!grepl(pattern, name)) 
[16:18:41.841]                               next
[16:18:41.841]                             invokeRestart(restart)
[16:18:41.841]                             muffled <- TRUE
[16:18:41.841]                             break
[16:18:41.841]                           }
[16:18:41.841]                         }
[16:18:41.841]                       }
[16:18:41.841]                       invisible(muffled)
[16:18:41.841]                     }
[16:18:41.841]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.841]                   }
[16:18:41.841]                 }
[16:18:41.841]             }
[16:18:41.841]         }))
[16:18:41.841]     }, error = function(ex) {
[16:18:41.841]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.841]                 ...future.rng), started = ...future.startTime, 
[16:18:41.841]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.841]             version = "1.8"), class = "FutureResult")
[16:18:41.841]     }, finally = {
[16:18:41.841]         if (!identical(...future.workdir, getwd())) 
[16:18:41.841]             setwd(...future.workdir)
[16:18:41.841]         {
[16:18:41.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.841]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.841]             }
[16:18:41.841]             base::options(...future.oldOptions)
[16:18:41.841]             if (.Platform$OS.type == "windows") {
[16:18:41.841]                 old_names <- names(...future.oldEnvVars)
[16:18:41.841]                 envs <- base::Sys.getenv()
[16:18:41.841]                 names <- names(envs)
[16:18:41.841]                 common <- intersect(names, old_names)
[16:18:41.841]                 added <- setdiff(names, old_names)
[16:18:41.841]                 removed <- setdiff(old_names, names)
[16:18:41.841]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.841]                   envs[common]]
[16:18:41.841]                 NAMES <- toupper(changed)
[16:18:41.841]                 args <- list()
[16:18:41.841]                 for (kk in seq_along(NAMES)) {
[16:18:41.841]                   name <- changed[[kk]]
[16:18:41.841]                   NAME <- NAMES[[kk]]
[16:18:41.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.841]                     next
[16:18:41.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.841]                 }
[16:18:41.841]                 NAMES <- toupper(added)
[16:18:41.841]                 for (kk in seq_along(NAMES)) {
[16:18:41.841]                   name <- added[[kk]]
[16:18:41.841]                   NAME <- NAMES[[kk]]
[16:18:41.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.841]                     next
[16:18:41.841]                   args[[name]] <- ""
[16:18:41.841]                 }
[16:18:41.841]                 NAMES <- toupper(removed)
[16:18:41.841]                 for (kk in seq_along(NAMES)) {
[16:18:41.841]                   name <- removed[[kk]]
[16:18:41.841]                   NAME <- NAMES[[kk]]
[16:18:41.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.841]                     next
[16:18:41.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.841]                 }
[16:18:41.841]                 if (length(args) > 0) 
[16:18:41.841]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.841]             }
[16:18:41.841]             else {
[16:18:41.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.841]             }
[16:18:41.841]             {
[16:18:41.841]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.841]                   0L) {
[16:18:41.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.841]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.841]                   base::options(opts)
[16:18:41.841]                 }
[16:18:41.841]                 {
[16:18:41.841]                   {
[16:18:41.841]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.841]                     NULL
[16:18:41.841]                   }
[16:18:41.841]                   options(future.plan = NULL)
[16:18:41.841]                   if (is.na(NA_character_)) 
[16:18:41.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.841]                     .init = FALSE)
[16:18:41.841]                 }
[16:18:41.841]             }
[16:18:41.841]         }
[16:18:41.841]     })
[16:18:41.841]     if (TRUE) {
[16:18:41.841]         base::sink(type = "output", split = FALSE)
[16:18:41.841]         if (TRUE) {
[16:18:41.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.841]         }
[16:18:41.841]         else {
[16:18:41.841]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.841]         }
[16:18:41.841]         base::close(...future.stdout)
[16:18:41.841]         ...future.stdout <- NULL
[16:18:41.841]     }
[16:18:41.841]     ...future.result$conditions <- ...future.conditions
[16:18:41.841]     ...future.result$finished <- base::Sys.time()
[16:18:41.841]     ...future.result
[16:18:41.841] }
[16:18:41.846] assign_globals() ...
[16:18:41.846] List of 5
[16:18:41.846]  $ ...future.FUN            :function (C, k)  
[16:18:41.846]  $ MoreArgs                 : NULL
[16:18:41.846]  $ ...future.elements_ii    :List of 2
[16:18:41.846]   ..$ :List of 1
[16:18:41.846]   .. ..$ : chr "E"
[16:18:41.846]   ..$ :List of 1
[16:18:41.846]   .. ..$ : int 1
[16:18:41.846]  $ ...future.seeds_ii       : NULL
[16:18:41.846]  $ ...future.globals.maxSize: NULL
[16:18:41.846]  - attr(*, "where")=List of 5
[16:18:41.846]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.846]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.846]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.846]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.846]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.846]  - attr(*, "resolved")= logi FALSE
[16:18:41.846]  - attr(*, "total_size")= num 3488
[16:18:41.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.846]  - attr(*, "already-done")= logi TRUE
[16:18:41.856] - reassign environment for ‘...future.FUN’
[16:18:41.856] - copied ‘...future.FUN’ to environment
[16:18:41.856] - copied ‘MoreArgs’ to environment
[16:18:41.856] - copied ‘...future.elements_ii’ to environment
[16:18:41.857] - copied ‘...future.seeds_ii’ to environment
[16:18:41.857] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.857] assign_globals() ... done
[16:18:41.857] requestCore(): workers = 2
[16:18:41.858] Poll #1 (0): usedCores() = 2, workers = 2
[16:18:41.868] result() for MulticoreFuture ...
[16:18:41.869] result() for MulticoreFuture ...
[16:18:41.869] result() for MulticoreFuture ... done
[16:18:41.869] result() for MulticoreFuture ... done
[16:18:41.870] result() for MulticoreFuture ...
[16:18:41.870] result() for MulticoreFuture ... done
[16:18:41.872] MulticoreFuture started
[16:18:41.873] - Launch lazy future ... done
[16:18:41.873] run() for ‘MulticoreFuture’ ... done
[16:18:41.873] Created future:
[16:18:41.874] plan(): Setting new future strategy stack:
[16:18:41.874] List of future strategies:
[16:18:41.874] 1. sequential:
[16:18:41.874]    - args: function (..., envir = parent.frame())
[16:18:41.874]    - tweaked: FALSE
[16:18:41.874]    - call: NULL
[16:18:41.875] plan(): nbrOfWorkers() = 1
[16:18:41.877] plan(): Setting new future strategy stack:
[16:18:41.877] List of future strategies:
[16:18:41.877] 1. multicore:
[16:18:41.877]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.877]    - tweaked: FALSE
[16:18:41.877]    - call: plan(strategy)
[16:18:41.883] plan(): nbrOfWorkers() = 2
[16:18:41.874] MulticoreFuture:
[16:18:41.874] Label: ‘future_mapply-5’
[16:18:41.874] Expression:
[16:18:41.874] {
[16:18:41.874]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.874]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.874]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.874]         on.exit(options(oopts), add = TRUE)
[16:18:41.874]     }
[16:18:41.874]     {
[16:18:41.874]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.874]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.874]         do.call(mapply, args = args)
[16:18:41.874]     }
[16:18:41.874] }
[16:18:41.874] Lazy evaluation: FALSE
[16:18:41.874] Asynchronous evaluation: TRUE
[16:18:41.874] Local evaluation: TRUE
[16:18:41.874] Environment: R_GlobalEnv
[16:18:41.874] Capture standard output: TRUE
[16:18:41.874] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.874] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.874] Packages: <none>
[16:18:41.874] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.874] Resolved: TRUE
[16:18:41.874] Value: <not collected>
[16:18:41.874] Conditions captured: <none>
[16:18:41.874] Early signaling: FALSE
[16:18:41.874] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.874] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.884] Chunk #5 of 5 ... DONE
[16:18:41.884] Launching 5 futures (chunks) ... DONE
[16:18:41.885] Resolving 5 futures (chunks) ...
[16:18:41.885] resolve() on list ...
[16:18:41.885]  recursive: 0
[16:18:41.885]  length: 5
[16:18:41.885] 
[16:18:41.885] Future #1
[16:18:41.885] result() for MulticoreFuture ...
[16:18:41.886] result() for MulticoreFuture ... done
[16:18:41.886] result() for MulticoreFuture ...
[16:18:41.886] result() for MulticoreFuture ... done
[16:18:41.886] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:41.886] - nx: 5
[16:18:41.886] - relay: TRUE
[16:18:41.886] - stdout: TRUE
[16:18:41.886] - signal: TRUE
[16:18:41.887] - resignal: FALSE
[16:18:41.887] - force: TRUE
[16:18:41.887] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[16:18:41.887] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[16:18:41.887]  - until=1
[16:18:41.887]  - relaying element #1
[16:18:41.888] result() for MulticoreFuture ...
[16:18:41.888] result() for MulticoreFuture ... done
[16:18:41.888] result() for MulticoreFuture ...
[16:18:41.888] result() for MulticoreFuture ... done
[16:18:41.888] result() for MulticoreFuture ...
[16:18:41.888] result() for MulticoreFuture ... done
[16:18:41.889] result() for MulticoreFuture ...
[16:18:41.889] result() for MulticoreFuture ... done
[16:18:41.889] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:41.889] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:41.889] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:41.889]  length: 4 (resolved future 1)
[16:18:41.890] Future #2
[16:18:41.890] result() for MulticoreFuture ...
[16:18:41.890] result() for MulticoreFuture ... done
[16:18:41.890] result() for MulticoreFuture ...
[16:18:41.890] result() for MulticoreFuture ... done
[16:18:41.890] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:41.890] - nx: 5
[16:18:41.891] - relay: TRUE
[16:18:41.891] - stdout: TRUE
[16:18:41.891] - signal: TRUE
[16:18:41.891] - resignal: FALSE
[16:18:41.891] - force: TRUE
[16:18:41.891] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:41.891] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:41.892]  - until=2
[16:18:41.892]  - relaying element #2
[16:18:41.892] result() for MulticoreFuture ...
[16:18:41.892] result() for MulticoreFuture ... done
[16:18:41.892] result() for MulticoreFuture ...
[16:18:41.892] result() for MulticoreFuture ... done
[16:18:41.893] result() for MulticoreFuture ...
[16:18:41.893] result() for MulticoreFuture ... done
[16:18:41.893] result() for MulticoreFuture ...
[16:18:41.893] result() for MulticoreFuture ... done
[16:18:41.893] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:41.893] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:41.894] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:41.894]  length: 3 (resolved future 2)
[16:18:41.894] Future #3
[16:18:41.894] result() for MulticoreFuture ...
[16:18:41.894] result() for MulticoreFuture ... done
[16:18:41.894] result() for MulticoreFuture ...
[16:18:41.894] result() for MulticoreFuture ... done
[16:18:41.895] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:18:41.895] - nx: 5
[16:18:41.895] - relay: TRUE
[16:18:41.895] - stdout: TRUE
[16:18:41.895] - signal: TRUE
[16:18:41.895] - resignal: FALSE
[16:18:41.895] - force: TRUE
[16:18:41.896] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:41.896] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:41.896]  - until=3
[16:18:41.896]  - relaying element #3
[16:18:41.896] result() for MulticoreFuture ...
[16:18:41.900] result() for MulticoreFuture ... done
[16:18:41.900] result() for MulticoreFuture ...
[16:18:41.900] result() for MulticoreFuture ... done
[16:18:41.901] result() for MulticoreFuture ...
[16:18:41.901] result() for MulticoreFuture ... done
[16:18:41.901] result() for MulticoreFuture ...
[16:18:41.902] result() for MulticoreFuture ... done
[16:18:41.902] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:41.902] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:41.902] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:18:41.903]  length: 2 (resolved future 3)
[16:18:41.903] Future #4
[16:18:41.903] result() for MulticoreFuture ...
[16:18:41.905] result() for MulticoreFuture ...
[16:18:41.905] result() for MulticoreFuture ... done
[16:18:41.905] result() for MulticoreFuture ... done
[16:18:41.905] result() for MulticoreFuture ...
[16:18:41.906] result() for MulticoreFuture ... done
[16:18:41.906] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:18:41.906] - nx: 5
[16:18:41.906] - relay: TRUE
[16:18:41.907] - stdout: TRUE
[16:18:41.907] - signal: TRUE
[16:18:41.907] - resignal: FALSE
[16:18:41.907] - force: TRUE
[16:18:41.907] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:41.908] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:41.908]  - until=4
[16:18:41.908]  - relaying element #4
[16:18:41.909] result() for MulticoreFuture ...
[16:18:41.909] result() for MulticoreFuture ... done
[16:18:41.909] result() for MulticoreFuture ...
[16:18:41.909] result() for MulticoreFuture ... done
[16:18:41.910] result() for MulticoreFuture ...
[16:18:41.910] result() for MulticoreFuture ... done
[16:18:41.910] result() for MulticoreFuture ...
[16:18:41.910] result() for MulticoreFuture ... done
[16:18:41.910] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:41.911] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:41.911] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:18:41.911]  length: 1 (resolved future 4)
[16:18:41.911] Future #5
[16:18:41.911] result() for MulticoreFuture ...
[16:18:41.912] result() for MulticoreFuture ...
[16:18:41.912] result() for MulticoreFuture ... done
[16:18:41.912] result() for MulticoreFuture ... done
[16:18:41.913] result() for MulticoreFuture ...
[16:18:41.913] result() for MulticoreFuture ... done
[16:18:41.913] signalConditionsASAP(MulticoreFuture, pos=5) ...
[16:18:41.913] - nx: 5
[16:18:41.913] - relay: TRUE
[16:18:41.914] - stdout: TRUE
[16:18:41.914] - signal: TRUE
[16:18:41.914] - resignal: FALSE
[16:18:41.914] - force: TRUE
[16:18:41.914] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:41.914] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:41.915]  - until=5
[16:18:41.915]  - relaying element #5
[16:18:41.915] result() for MulticoreFuture ...
[16:18:41.915] result() for MulticoreFuture ... done
[16:18:41.915] result() for MulticoreFuture ...
[16:18:41.915] result() for MulticoreFuture ... done
[16:18:41.916] result() for MulticoreFuture ...
[16:18:41.916] result() for MulticoreFuture ... done
[16:18:41.916] result() for MulticoreFuture ...
[16:18:41.916] result() for MulticoreFuture ... done
[16:18:41.916] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:41.916] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:41.916] signalConditionsASAP(MulticoreFuture, pos=5) ... done
[16:18:41.917]  length: 0 (resolved future 5)
[16:18:41.917] Relaying remaining futures
[16:18:41.917] signalConditionsASAP(NULL, pos=0) ...
[16:18:41.917] - nx: 5
[16:18:41.917] - relay: TRUE
[16:18:41.917] - stdout: TRUE
[16:18:41.917] - signal: TRUE
[16:18:41.917] - resignal: FALSE
[16:18:41.917] - force: TRUE
[16:18:41.917] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:41.918] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[16:18:41.918] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:41.918] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:41.918] signalConditionsASAP(NULL, pos=0) ... done
[16:18:41.918] resolve() on list ... DONE
[16:18:41.918] result() for MulticoreFuture ...
[16:18:41.918] result() for MulticoreFuture ... done
[16:18:41.918] result() for MulticoreFuture ...
[16:18:41.918] result() for MulticoreFuture ... done
[16:18:41.919] result() for MulticoreFuture ...
[16:18:41.919] result() for MulticoreFuture ... done
[16:18:41.919] result() for MulticoreFuture ...
[16:18:41.919] result() for MulticoreFuture ... done
[16:18:41.919] result() for MulticoreFuture ...
[16:18:41.919] result() for MulticoreFuture ... done
[16:18:41.919] result() for MulticoreFuture ...
[16:18:41.919] result() for MulticoreFuture ... done
[16:18:41.919] result() for MulticoreFuture ...
[16:18:41.919] result() for MulticoreFuture ... done
[16:18:41.920] result() for MulticoreFuture ...
[16:18:41.920] result() for MulticoreFuture ... done
[16:18:41.920] result() for MulticoreFuture ...
[16:18:41.920] result() for MulticoreFuture ... done
[16:18:41.920] result() for MulticoreFuture ...
[16:18:41.920] result() for MulticoreFuture ... done
[16:18:41.920]  - Number of value chunks collected: 5
[16:18:41.920] Resolving 5 futures (chunks) ... DONE
[16:18:41.920] Reducing values from 5 chunks ...
[16:18:41.921]  - Number of values collected after concatenation: 5
[16:18:41.921]  - Number of values expected: 5
[16:18:41.921] Reducing values from 5 chunks ... DONE
[16:18:41.921] future_mapply() ... DONE
[16:18:41.921] future_mapply() ...
[16:18:41.925] Number of chunks: 2
[16:18:41.926] getGlobalsAndPackagesXApply() ...
[16:18:41.926]  - future.globals: TRUE
[16:18:41.926] getGlobalsAndPackages() ...
[16:18:41.926] Searching for globals...
[16:18:41.927] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:41.927] Searching for globals ... DONE
[16:18:41.928] Resolving globals: FALSE
[16:18:41.928] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:41.928] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:41.929] - globals: [1] ‘FUN’
[16:18:41.929] 
[16:18:41.929] getGlobalsAndPackages() ... DONE
[16:18:41.929]  - globals found/used: [n=1] ‘FUN’
[16:18:41.929]  - needed namespaces: [n=0] 
[16:18:41.929] Finding globals ... DONE
[16:18:41.929] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:41.929] List of 2
[16:18:41.929]  $ ...future.FUN:function (C, k)  
[16:18:41.929]  $ MoreArgs     : list()
[16:18:41.929]  - attr(*, "where")=List of 2
[16:18:41.929]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:41.929]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:41.929]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.929]  - attr(*, "resolved")= logi FALSE
[16:18:41.929]  - attr(*, "total_size")= num NA
[16:18:41.934] Packages to be attached in all futures: [n=0] 
[16:18:41.934] getGlobalsAndPackagesXApply() ... DONE
[16:18:41.935] Number of futures (= number of chunks): 2
[16:18:41.935] Launching 2 futures (chunks) ...
[16:18:41.935] Chunk #1 of 2 ...
[16:18:41.935]  - Finding globals in '...' for chunk #1 ...
[16:18:41.935] getGlobalsAndPackages() ...
[16:18:41.935] Searching for globals...
[16:18:41.936] 
[16:18:41.936] Searching for globals ... DONE
[16:18:41.936] - globals: [0] <none>
[16:18:41.936] getGlobalsAndPackages() ... DONE
[16:18:41.936]    + additional globals found: [n=0] 
[16:18:41.936]    + additional namespaces needed: [n=0] 
[16:18:41.936]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:41.936]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.936]  - seeds: <none>
[16:18:41.937]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.937] getGlobalsAndPackages() ...
[16:18:41.937] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.937] Resolving globals: FALSE
[16:18:41.937] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:41.938] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:41.938] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.938] 
[16:18:41.938] getGlobalsAndPackages() ... DONE
[16:18:41.939] run() for ‘Future’ ...
[16:18:41.939] - state: ‘created’
[16:18:41.939] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.942] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.942] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.943]   - Field: ‘label’
[16:18:41.943]   - Field: ‘local’
[16:18:41.943]   - Field: ‘owner’
[16:18:41.943]   - Field: ‘envir’
[16:18:41.943]   - Field: ‘workers’
[16:18:41.943]   - Field: ‘packages’
[16:18:41.943]   - Field: ‘gc’
[16:18:41.943]   - Field: ‘job’
[16:18:41.943]   - Field: ‘conditions’
[16:18:41.943]   - Field: ‘expr’
[16:18:41.944]   - Field: ‘uuid’
[16:18:41.944]   - Field: ‘seed’
[16:18:41.944]   - Field: ‘version’
[16:18:41.944]   - Field: ‘result’
[16:18:41.944]   - Field: ‘asynchronous’
[16:18:41.944]   - Field: ‘calls’
[16:18:41.944]   - Field: ‘globals’
[16:18:41.944]   - Field: ‘stdout’
[16:18:41.944]   - Field: ‘earlySignal’
[16:18:41.944]   - Field: ‘lazy’
[16:18:41.945]   - Field: ‘state’
[16:18:41.945] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.945] - Launch lazy future ...
[16:18:41.945] Packages needed by the future expression (n = 0): <none>
[16:18:41.945] Packages needed by future strategies (n = 0): <none>
[16:18:41.946] {
[16:18:41.946]     {
[16:18:41.946]         {
[16:18:41.946]             ...future.startTime <- base::Sys.time()
[16:18:41.946]             {
[16:18:41.946]                 {
[16:18:41.946]                   {
[16:18:41.946]                     {
[16:18:41.946]                       base::local({
[16:18:41.946]                         has_future <- base::requireNamespace("future", 
[16:18:41.946]                           quietly = TRUE)
[16:18:41.946]                         if (has_future) {
[16:18:41.946]                           ns <- base::getNamespace("future")
[16:18:41.946]                           version <- ns[[".package"]][["version"]]
[16:18:41.946]                           if (is.null(version)) 
[16:18:41.946]                             version <- utils::packageVersion("future")
[16:18:41.946]                         }
[16:18:41.946]                         else {
[16:18:41.946]                           version <- NULL
[16:18:41.946]                         }
[16:18:41.946]                         if (!has_future || version < "1.8.0") {
[16:18:41.946]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.946]                             "", base::R.version$version.string), 
[16:18:41.946]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.946]                               "release", "version")], collapse = " "), 
[16:18:41.946]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.946]                             info)
[16:18:41.946]                           info <- base::paste(info, collapse = "; ")
[16:18:41.946]                           if (!has_future) {
[16:18:41.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.946]                               info)
[16:18:41.946]                           }
[16:18:41.946]                           else {
[16:18:41.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.946]                               info, version)
[16:18:41.946]                           }
[16:18:41.946]                           base::stop(msg)
[16:18:41.946]                         }
[16:18:41.946]                       })
[16:18:41.946]                     }
[16:18:41.946]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.946]                     base::options(mc.cores = 1L)
[16:18:41.946]                   }
[16:18:41.946]                   ...future.strategy.old <- future::plan("list")
[16:18:41.946]                   options(future.plan = NULL)
[16:18:41.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.946]                 }
[16:18:41.946]                 ...future.workdir <- getwd()
[16:18:41.946]             }
[16:18:41.946]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.946]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.946]         }
[16:18:41.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.946]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.946]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.946]             base::names(...future.oldOptions))
[16:18:41.946]     }
[16:18:41.946]     if (FALSE) {
[16:18:41.946]     }
[16:18:41.946]     else {
[16:18:41.946]         if (TRUE) {
[16:18:41.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.946]                 open = "w")
[16:18:41.946]         }
[16:18:41.946]         else {
[16:18:41.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.946]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.946]         }
[16:18:41.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.946]             base::sink(type = "output", split = FALSE)
[16:18:41.946]             base::close(...future.stdout)
[16:18:41.946]         }, add = TRUE)
[16:18:41.946]     }
[16:18:41.946]     ...future.frame <- base::sys.nframe()
[16:18:41.946]     ...future.conditions <- base::list()
[16:18:41.946]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.946]     if (FALSE) {
[16:18:41.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.946]     }
[16:18:41.946]     ...future.result <- base::tryCatch({
[16:18:41.946]         base::withCallingHandlers({
[16:18:41.946]             ...future.value <- base::withVisible(base::local({
[16:18:41.946]                 withCallingHandlers({
[16:18:41.946]                   {
[16:18:41.946]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.946]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.946]                       ...future.globals.maxSize)) {
[16:18:41.946]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.946]                       on.exit(options(oopts), add = TRUE)
[16:18:41.946]                     }
[16:18:41.946]                     {
[16:18:41.946]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.946]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.946]                         USE.NAMES = FALSE)
[16:18:41.946]                       do.call(mapply, args = args)
[16:18:41.946]                     }
[16:18:41.946]                   }
[16:18:41.946]                 }, immediateCondition = function(cond) {
[16:18:41.946]                   save_rds <- function (object, pathname, ...) 
[16:18:41.946]                   {
[16:18:41.946]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.946]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.946]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.946]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.946]                         fi_tmp[["mtime"]])
[16:18:41.946]                     }
[16:18:41.946]                     tryCatch({
[16:18:41.946]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.946]                     }, error = function(ex) {
[16:18:41.946]                       msg <- conditionMessage(ex)
[16:18:41.946]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.946]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.946]                         fi_tmp[["mtime"]], msg)
[16:18:41.946]                       ex$message <- msg
[16:18:41.946]                       stop(ex)
[16:18:41.946]                     })
[16:18:41.946]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.946]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.946]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.946]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.946]                       fi <- file.info(pathname)
[16:18:41.946]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.946]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.946]                         fi[["size"]], fi[["mtime"]])
[16:18:41.946]                       stop(msg)
[16:18:41.946]                     }
[16:18:41.946]                     invisible(pathname)
[16:18:41.946]                   }
[16:18:41.946]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.946]                     rootPath = tempdir()) 
[16:18:41.946]                   {
[16:18:41.946]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.946]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.946]                       tmpdir = path, fileext = ".rds")
[16:18:41.946]                     save_rds(obj, file)
[16:18:41.946]                   }
[16:18:41.946]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.946]                   {
[16:18:41.946]                     inherits <- base::inherits
[16:18:41.946]                     invokeRestart <- base::invokeRestart
[16:18:41.946]                     is.null <- base::is.null
[16:18:41.946]                     muffled <- FALSE
[16:18:41.946]                     if (inherits(cond, "message")) {
[16:18:41.946]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.946]                       if (muffled) 
[16:18:41.946]                         invokeRestart("muffleMessage")
[16:18:41.946]                     }
[16:18:41.946]                     else if (inherits(cond, "warning")) {
[16:18:41.946]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.946]                       if (muffled) 
[16:18:41.946]                         invokeRestart("muffleWarning")
[16:18:41.946]                     }
[16:18:41.946]                     else if (inherits(cond, "condition")) {
[16:18:41.946]                       if (!is.null(pattern)) {
[16:18:41.946]                         computeRestarts <- base::computeRestarts
[16:18:41.946]                         grepl <- base::grepl
[16:18:41.946]                         restarts <- computeRestarts(cond)
[16:18:41.946]                         for (restart in restarts) {
[16:18:41.946]                           name <- restart$name
[16:18:41.946]                           if (is.null(name)) 
[16:18:41.946]                             next
[16:18:41.946]                           if (!grepl(pattern, name)) 
[16:18:41.946]                             next
[16:18:41.946]                           invokeRestart(restart)
[16:18:41.946]                           muffled <- TRUE
[16:18:41.946]                           break
[16:18:41.946]                         }
[16:18:41.946]                       }
[16:18:41.946]                     }
[16:18:41.946]                     invisible(muffled)
[16:18:41.946]                   }
[16:18:41.946]                   muffleCondition(cond)
[16:18:41.946]                 })
[16:18:41.946]             }))
[16:18:41.946]             future::FutureResult(value = ...future.value$value, 
[16:18:41.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.946]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.946]                     ...future.globalenv.names))
[16:18:41.946]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.946]         }, condition = base::local({
[16:18:41.946]             c <- base::c
[16:18:41.946]             inherits <- base::inherits
[16:18:41.946]             invokeRestart <- base::invokeRestart
[16:18:41.946]             length <- base::length
[16:18:41.946]             list <- base::list
[16:18:41.946]             seq.int <- base::seq.int
[16:18:41.946]             signalCondition <- base::signalCondition
[16:18:41.946]             sys.calls <- base::sys.calls
[16:18:41.946]             `[[` <- base::`[[`
[16:18:41.946]             `+` <- base::`+`
[16:18:41.946]             `<<-` <- base::`<<-`
[16:18:41.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.946]                   3L)]
[16:18:41.946]             }
[16:18:41.946]             function(cond) {
[16:18:41.946]                 is_error <- inherits(cond, "error")
[16:18:41.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.946]                   NULL)
[16:18:41.946]                 if (is_error) {
[16:18:41.946]                   sessionInformation <- function() {
[16:18:41.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.946]                       search = base::search(), system = base::Sys.info())
[16:18:41.946]                   }
[16:18:41.946]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.946]                     cond$call), session = sessionInformation(), 
[16:18:41.946]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.946]                   signalCondition(cond)
[16:18:41.946]                 }
[16:18:41.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.946]                 "immediateCondition"))) {
[16:18:41.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.946]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.946]                   if (TRUE && !signal) {
[16:18:41.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.946]                     {
[16:18:41.946]                       inherits <- base::inherits
[16:18:41.946]                       invokeRestart <- base::invokeRestart
[16:18:41.946]                       is.null <- base::is.null
[16:18:41.946]                       muffled <- FALSE
[16:18:41.946]                       if (inherits(cond, "message")) {
[16:18:41.946]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.946]                         if (muffled) 
[16:18:41.946]                           invokeRestart("muffleMessage")
[16:18:41.946]                       }
[16:18:41.946]                       else if (inherits(cond, "warning")) {
[16:18:41.946]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.946]                         if (muffled) 
[16:18:41.946]                           invokeRestart("muffleWarning")
[16:18:41.946]                       }
[16:18:41.946]                       else if (inherits(cond, "condition")) {
[16:18:41.946]                         if (!is.null(pattern)) {
[16:18:41.946]                           computeRestarts <- base::computeRestarts
[16:18:41.946]                           grepl <- base::grepl
[16:18:41.946]                           restarts <- computeRestarts(cond)
[16:18:41.946]                           for (restart in restarts) {
[16:18:41.946]                             name <- restart$name
[16:18:41.946]                             if (is.null(name)) 
[16:18:41.946]                               next
[16:18:41.946]                             if (!grepl(pattern, name)) 
[16:18:41.946]                               next
[16:18:41.946]                             invokeRestart(restart)
[16:18:41.946]                             muffled <- TRUE
[16:18:41.946]                             break
[16:18:41.946]                           }
[16:18:41.946]                         }
[16:18:41.946]                       }
[16:18:41.946]                       invisible(muffled)
[16:18:41.946]                     }
[16:18:41.946]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.946]                   }
[16:18:41.946]                 }
[16:18:41.946]                 else {
[16:18:41.946]                   if (TRUE) {
[16:18:41.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.946]                     {
[16:18:41.946]                       inherits <- base::inherits
[16:18:41.946]                       invokeRestart <- base::invokeRestart
[16:18:41.946]                       is.null <- base::is.null
[16:18:41.946]                       muffled <- FALSE
[16:18:41.946]                       if (inherits(cond, "message")) {
[16:18:41.946]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.946]                         if (muffled) 
[16:18:41.946]                           invokeRestart("muffleMessage")
[16:18:41.946]                       }
[16:18:41.946]                       else if (inherits(cond, "warning")) {
[16:18:41.946]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.946]                         if (muffled) 
[16:18:41.946]                           invokeRestart("muffleWarning")
[16:18:41.946]                       }
[16:18:41.946]                       else if (inherits(cond, "condition")) {
[16:18:41.946]                         if (!is.null(pattern)) {
[16:18:41.946]                           computeRestarts <- base::computeRestarts
[16:18:41.946]                           grepl <- base::grepl
[16:18:41.946]                           restarts <- computeRestarts(cond)
[16:18:41.946]                           for (restart in restarts) {
[16:18:41.946]                             name <- restart$name
[16:18:41.946]                             if (is.null(name)) 
[16:18:41.946]                               next
[16:18:41.946]                             if (!grepl(pattern, name)) 
[16:18:41.946]                               next
[16:18:41.946]                             invokeRestart(restart)
[16:18:41.946]                             muffled <- TRUE
[16:18:41.946]                             break
[16:18:41.946]                           }
[16:18:41.946]                         }
[16:18:41.946]                       }
[16:18:41.946]                       invisible(muffled)
[16:18:41.946]                     }
[16:18:41.946]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.946]                   }
[16:18:41.946]                 }
[16:18:41.946]             }
[16:18:41.946]         }))
[16:18:41.946]     }, error = function(ex) {
[16:18:41.946]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.946]                 ...future.rng), started = ...future.startTime, 
[16:18:41.946]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.946]             version = "1.8"), class = "FutureResult")
[16:18:41.946]     }, finally = {
[16:18:41.946]         if (!identical(...future.workdir, getwd())) 
[16:18:41.946]             setwd(...future.workdir)
[16:18:41.946]         {
[16:18:41.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.946]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.946]             }
[16:18:41.946]             base::options(...future.oldOptions)
[16:18:41.946]             if (.Platform$OS.type == "windows") {
[16:18:41.946]                 old_names <- names(...future.oldEnvVars)
[16:18:41.946]                 envs <- base::Sys.getenv()
[16:18:41.946]                 names <- names(envs)
[16:18:41.946]                 common <- intersect(names, old_names)
[16:18:41.946]                 added <- setdiff(names, old_names)
[16:18:41.946]                 removed <- setdiff(old_names, names)
[16:18:41.946]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.946]                   envs[common]]
[16:18:41.946]                 NAMES <- toupper(changed)
[16:18:41.946]                 args <- list()
[16:18:41.946]                 for (kk in seq_along(NAMES)) {
[16:18:41.946]                   name <- changed[[kk]]
[16:18:41.946]                   NAME <- NAMES[[kk]]
[16:18:41.946]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.946]                     next
[16:18:41.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.946]                 }
[16:18:41.946]                 NAMES <- toupper(added)
[16:18:41.946]                 for (kk in seq_along(NAMES)) {
[16:18:41.946]                   name <- added[[kk]]
[16:18:41.946]                   NAME <- NAMES[[kk]]
[16:18:41.946]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.946]                     next
[16:18:41.946]                   args[[name]] <- ""
[16:18:41.946]                 }
[16:18:41.946]                 NAMES <- toupper(removed)
[16:18:41.946]                 for (kk in seq_along(NAMES)) {
[16:18:41.946]                   name <- removed[[kk]]
[16:18:41.946]                   NAME <- NAMES[[kk]]
[16:18:41.946]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.946]                     next
[16:18:41.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.946]                 }
[16:18:41.946]                 if (length(args) > 0) 
[16:18:41.946]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.946]             }
[16:18:41.946]             else {
[16:18:41.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.946]             }
[16:18:41.946]             {
[16:18:41.946]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.946]                   0L) {
[16:18:41.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.946]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.946]                   base::options(opts)
[16:18:41.946]                 }
[16:18:41.946]                 {
[16:18:41.946]                   {
[16:18:41.946]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.946]                     NULL
[16:18:41.946]                   }
[16:18:41.946]                   options(future.plan = NULL)
[16:18:41.946]                   if (is.na(NA_character_)) 
[16:18:41.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.946]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.946]                     .init = FALSE)
[16:18:41.946]                 }
[16:18:41.946]             }
[16:18:41.946]         }
[16:18:41.946]     })
[16:18:41.946]     if (TRUE) {
[16:18:41.946]         base::sink(type = "output", split = FALSE)
[16:18:41.946]         if (TRUE) {
[16:18:41.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.946]         }
[16:18:41.946]         else {
[16:18:41.946]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.946]         }
[16:18:41.946]         base::close(...future.stdout)
[16:18:41.946]         ...future.stdout <- NULL
[16:18:41.946]     }
[16:18:41.946]     ...future.result$conditions <- ...future.conditions
[16:18:41.946]     ...future.result$finished <- base::Sys.time()
[16:18:41.946]     ...future.result
[16:18:41.946] }
[16:18:41.948] assign_globals() ...
[16:18:41.948] List of 5
[16:18:41.948]  $ ...future.FUN            :function (C, k)  
[16:18:41.948]  $ MoreArgs                 : list()
[16:18:41.948]  $ ...future.elements_ii    :List of 2
[16:18:41.948]   ..$ :List of 2
[16:18:41.948]   .. ..$ : chr "A"
[16:18:41.948]   .. ..$ : chr "B"
[16:18:41.948]   ..$ :List of 2
[16:18:41.948]   .. ..$ : int 5
[16:18:41.948]   .. ..$ : int 4
[16:18:41.948]  $ ...future.seeds_ii       : NULL
[16:18:41.948]  $ ...future.globals.maxSize: NULL
[16:18:41.948]  - attr(*, "where")=List of 5
[16:18:41.948]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.948]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.948]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.948]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.948]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.948]  - attr(*, "resolved")= logi FALSE
[16:18:41.948]  - attr(*, "total_size")= num 3656
[16:18:41.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.948]  - attr(*, "already-done")= logi TRUE
[16:18:41.954] - reassign environment for ‘...future.FUN’
[16:18:41.954] - copied ‘...future.FUN’ to environment
[16:18:41.954] - copied ‘MoreArgs’ to environment
[16:18:41.954] - copied ‘...future.elements_ii’ to environment
[16:18:41.954] - copied ‘...future.seeds_ii’ to environment
[16:18:41.954] - copied ‘...future.globals.maxSize’ to environment
[16:18:41.954] assign_globals() ... done
[16:18:41.954] requestCore(): workers = 2
[16:18:41.956] MulticoreFuture started
[16:18:41.957] - Launch lazy future ... done
[16:18:41.957] run() for ‘MulticoreFuture’ ... done
[16:18:41.957] Created future:
[16:18:41.958] plan(): Setting new future strategy stack:
[16:18:41.958] List of future strategies:
[16:18:41.958] 1. sequential:
[16:18:41.958]    - args: function (..., envir = parent.frame())
[16:18:41.958]    - tweaked: FALSE
[16:18:41.958]    - call: NULL
[16:18:41.959] plan(): nbrOfWorkers() = 1
[16:18:41.961] plan(): Setting new future strategy stack:
[16:18:41.961] List of future strategies:
[16:18:41.961] 1. multicore:
[16:18:41.961]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:41.961]    - tweaked: FALSE
[16:18:41.961]    - call: plan(strategy)
[16:18:41.957] MulticoreFuture:
[16:18:41.957] Label: ‘future_.mapply-1’
[16:18:41.957] Expression:
[16:18:41.957] {
[16:18:41.957]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.957]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:41.957]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.957]         on.exit(options(oopts), add = TRUE)
[16:18:41.957]     }
[16:18:41.957]     {
[16:18:41.957]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.957]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:41.957]         do.call(mapply, args = args)
[16:18:41.957]     }
[16:18:41.957] }
[16:18:41.957] Lazy evaluation: FALSE
[16:18:41.957] Asynchronous evaluation: TRUE
[16:18:41.957] Local evaluation: TRUE
[16:18:41.957] Environment: R_GlobalEnv
[16:18:41.957] Capture standard output: TRUE
[16:18:41.957] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:41.957] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:41.957] Packages: <none>
[16:18:41.957] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:41.957] Resolved: FALSE
[16:18:41.957] Value: <not collected>
[16:18:41.957] Conditions captured: <none>
[16:18:41.957] Early signaling: FALSE
[16:18:41.957] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:41.957] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.970] Chunk #1 of 2 ... DONE
[16:18:41.970] Chunk #2 of 2 ...
[16:18:41.970]  - Finding globals in '...' for chunk #2 ...
[16:18:41.973] plan(): nbrOfWorkers() = 2
[16:18:41.971] getGlobalsAndPackages() ...
[16:18:41.973] Searching for globals...
[16:18:41.974] 
[16:18:41.975] Searching for globals ... DONE
[16:18:41.975] - globals: [0] <none>
[16:18:41.975] getGlobalsAndPackages() ... DONE
[16:18:41.975]    + additional globals found: [n=0] 
[16:18:41.975]    + additional namespaces needed: [n=0] 
[16:18:41.976]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:41.976]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:41.976]  - seeds: <none>
[16:18:41.976]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.977] getGlobalsAndPackages() ...
[16:18:41.977] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.977] Resolving globals: FALSE
[16:18:41.979] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[16:18:41.980] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:41.980] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:41.980] 
[16:18:41.981] getGlobalsAndPackages() ... DONE
[16:18:41.981] run() for ‘Future’ ...
[16:18:41.981] - state: ‘created’
[16:18:41.982] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:41.987] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:41.987] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:41.987]   - Field: ‘label’
[16:18:41.988]   - Field: ‘local’
[16:18:41.988]   - Field: ‘owner’
[16:18:41.988]   - Field: ‘envir’
[16:18:41.988]   - Field: ‘workers’
[16:18:41.988]   - Field: ‘packages’
[16:18:41.988]   - Field: ‘gc’
[16:18:41.989]   - Field: ‘job’
[16:18:41.989]   - Field: ‘conditions’
[16:18:41.989]   - Field: ‘expr’
[16:18:41.989]   - Field: ‘uuid’
[16:18:41.989]   - Field: ‘seed’
[16:18:41.989]   - Field: ‘version’
[16:18:41.989]   - Field: ‘result’
[16:18:41.990]   - Field: ‘asynchronous’
[16:18:41.990]   - Field: ‘calls’
[16:18:41.990]   - Field: ‘globals’
[16:18:41.990]   - Field: ‘stdout’
[16:18:41.990]   - Field: ‘earlySignal’
[16:18:41.990]   - Field: ‘lazy’
[16:18:41.991]   - Field: ‘state’
[16:18:41.991] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:41.991] - Launch lazy future ...
[16:18:41.991] Packages needed by the future expression (n = 0): <none>
[16:18:41.991] Packages needed by future strategies (n = 0): <none>
[16:18:41.992] {
[16:18:41.992]     {
[16:18:41.992]         {
[16:18:41.992]             ...future.startTime <- base::Sys.time()
[16:18:41.992]             {
[16:18:41.992]                 {
[16:18:41.992]                   {
[16:18:41.992]                     {
[16:18:41.992]                       base::local({
[16:18:41.992]                         has_future <- base::requireNamespace("future", 
[16:18:41.992]                           quietly = TRUE)
[16:18:41.992]                         if (has_future) {
[16:18:41.992]                           ns <- base::getNamespace("future")
[16:18:41.992]                           version <- ns[[".package"]][["version"]]
[16:18:41.992]                           if (is.null(version)) 
[16:18:41.992]                             version <- utils::packageVersion("future")
[16:18:41.992]                         }
[16:18:41.992]                         else {
[16:18:41.992]                           version <- NULL
[16:18:41.992]                         }
[16:18:41.992]                         if (!has_future || version < "1.8.0") {
[16:18:41.992]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:41.992]                             "", base::R.version$version.string), 
[16:18:41.992]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:41.992]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:41.992]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:41.992]                               "release", "version")], collapse = " "), 
[16:18:41.992]                             hostname = base::Sys.info()[["nodename"]])
[16:18:41.992]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:41.992]                             info)
[16:18:41.992]                           info <- base::paste(info, collapse = "; ")
[16:18:41.992]                           if (!has_future) {
[16:18:41.992]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:41.992]                               info)
[16:18:41.992]                           }
[16:18:41.992]                           else {
[16:18:41.992]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:41.992]                               info, version)
[16:18:41.992]                           }
[16:18:41.992]                           base::stop(msg)
[16:18:41.992]                         }
[16:18:41.992]                       })
[16:18:41.992]                     }
[16:18:41.992]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:41.992]                     base::options(mc.cores = 1L)
[16:18:41.992]                   }
[16:18:41.992]                   ...future.strategy.old <- future::plan("list")
[16:18:41.992]                   options(future.plan = NULL)
[16:18:41.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:41.992]                 }
[16:18:41.992]                 ...future.workdir <- getwd()
[16:18:41.992]             }
[16:18:41.992]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:41.992]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:41.992]         }
[16:18:41.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:41.992]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:41.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:41.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:41.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:41.992]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:41.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:41.992]             base::names(...future.oldOptions))
[16:18:41.992]     }
[16:18:41.992]     if (FALSE) {
[16:18:41.992]     }
[16:18:41.992]     else {
[16:18:41.992]         if (TRUE) {
[16:18:41.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:41.992]                 open = "w")
[16:18:41.992]         }
[16:18:41.992]         else {
[16:18:41.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:41.992]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:41.992]         }
[16:18:41.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:41.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:41.992]             base::sink(type = "output", split = FALSE)
[16:18:41.992]             base::close(...future.stdout)
[16:18:41.992]         }, add = TRUE)
[16:18:41.992]     }
[16:18:41.992]     ...future.frame <- base::sys.nframe()
[16:18:41.992]     ...future.conditions <- base::list()
[16:18:41.992]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:41.992]     if (FALSE) {
[16:18:41.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:41.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:41.992]     }
[16:18:41.992]     ...future.result <- base::tryCatch({
[16:18:41.992]         base::withCallingHandlers({
[16:18:41.992]             ...future.value <- base::withVisible(base::local({
[16:18:41.992]                 withCallingHandlers({
[16:18:41.992]                   {
[16:18:41.992]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:41.992]                     if (!identical(...future.globals.maxSize.org, 
[16:18:41.992]                       ...future.globals.maxSize)) {
[16:18:41.992]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:41.992]                       on.exit(options(oopts), add = TRUE)
[16:18:41.992]                     }
[16:18:41.992]                     {
[16:18:41.992]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:41.992]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:41.992]                         USE.NAMES = FALSE)
[16:18:41.992]                       do.call(mapply, args = args)
[16:18:41.992]                     }
[16:18:41.992]                   }
[16:18:41.992]                 }, immediateCondition = function(cond) {
[16:18:41.992]                   save_rds <- function (object, pathname, ...) 
[16:18:41.992]                   {
[16:18:41.992]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:41.992]                     if (file_test("-f", pathname_tmp)) {
[16:18:41.992]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.992]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:41.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.992]                         fi_tmp[["mtime"]])
[16:18:41.992]                     }
[16:18:41.992]                     tryCatch({
[16:18:41.992]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:41.992]                     }, error = function(ex) {
[16:18:41.992]                       msg <- conditionMessage(ex)
[16:18:41.992]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.992]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:41.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.992]                         fi_tmp[["mtime"]], msg)
[16:18:41.992]                       ex$message <- msg
[16:18:41.992]                       stop(ex)
[16:18:41.992]                     })
[16:18:41.992]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:41.992]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:41.992]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:41.992]                       fi_tmp <- file.info(pathname_tmp)
[16:18:41.992]                       fi <- file.info(pathname)
[16:18:41.992]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:41.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:41.992]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:41.992]                         fi[["size"]], fi[["mtime"]])
[16:18:41.992]                       stop(msg)
[16:18:41.992]                     }
[16:18:41.992]                     invisible(pathname)
[16:18:41.992]                   }
[16:18:41.992]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:41.992]                     rootPath = tempdir()) 
[16:18:41.992]                   {
[16:18:41.992]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:41.992]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:41.992]                       tmpdir = path, fileext = ".rds")
[16:18:41.992]                     save_rds(obj, file)
[16:18:41.992]                   }
[16:18:41.992]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:41.992]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.992]                   {
[16:18:41.992]                     inherits <- base::inherits
[16:18:41.992]                     invokeRestart <- base::invokeRestart
[16:18:41.992]                     is.null <- base::is.null
[16:18:41.992]                     muffled <- FALSE
[16:18:41.992]                     if (inherits(cond, "message")) {
[16:18:41.992]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:41.992]                       if (muffled) 
[16:18:41.992]                         invokeRestart("muffleMessage")
[16:18:41.992]                     }
[16:18:41.992]                     else if (inherits(cond, "warning")) {
[16:18:41.992]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:41.992]                       if (muffled) 
[16:18:41.992]                         invokeRestart("muffleWarning")
[16:18:41.992]                     }
[16:18:41.992]                     else if (inherits(cond, "condition")) {
[16:18:41.992]                       if (!is.null(pattern)) {
[16:18:41.992]                         computeRestarts <- base::computeRestarts
[16:18:41.992]                         grepl <- base::grepl
[16:18:41.992]                         restarts <- computeRestarts(cond)
[16:18:41.992]                         for (restart in restarts) {
[16:18:41.992]                           name <- restart$name
[16:18:41.992]                           if (is.null(name)) 
[16:18:41.992]                             next
[16:18:41.992]                           if (!grepl(pattern, name)) 
[16:18:41.992]                             next
[16:18:41.992]                           invokeRestart(restart)
[16:18:41.992]                           muffled <- TRUE
[16:18:41.992]                           break
[16:18:41.992]                         }
[16:18:41.992]                       }
[16:18:41.992]                     }
[16:18:41.992]                     invisible(muffled)
[16:18:41.992]                   }
[16:18:41.992]                   muffleCondition(cond)
[16:18:41.992]                 })
[16:18:41.992]             }))
[16:18:41.992]             future::FutureResult(value = ...future.value$value, 
[16:18:41.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.992]                   ...future.rng), globalenv = if (FALSE) 
[16:18:41.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:41.992]                     ...future.globalenv.names))
[16:18:41.992]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:41.992]         }, condition = base::local({
[16:18:41.992]             c <- base::c
[16:18:41.992]             inherits <- base::inherits
[16:18:41.992]             invokeRestart <- base::invokeRestart
[16:18:41.992]             length <- base::length
[16:18:41.992]             list <- base::list
[16:18:41.992]             seq.int <- base::seq.int
[16:18:41.992]             signalCondition <- base::signalCondition
[16:18:41.992]             sys.calls <- base::sys.calls
[16:18:41.992]             `[[` <- base::`[[`
[16:18:41.992]             `+` <- base::`+`
[16:18:41.992]             `<<-` <- base::`<<-`
[16:18:41.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:41.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:41.992]                   3L)]
[16:18:41.992]             }
[16:18:41.992]             function(cond) {
[16:18:41.992]                 is_error <- inherits(cond, "error")
[16:18:41.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:41.992]                   NULL)
[16:18:41.992]                 if (is_error) {
[16:18:41.992]                   sessionInformation <- function() {
[16:18:41.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:41.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:41.992]                       search = base::search(), system = base::Sys.info())
[16:18:41.992]                   }
[16:18:41.992]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:41.992]                     cond$call), session = sessionInformation(), 
[16:18:41.992]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:41.992]                   signalCondition(cond)
[16:18:41.992]                 }
[16:18:41.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:41.992]                 "immediateCondition"))) {
[16:18:41.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:41.992]                   ...future.conditions[[length(...future.conditions) + 
[16:18:41.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:41.992]                   if (TRUE && !signal) {
[16:18:41.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.992]                     {
[16:18:41.992]                       inherits <- base::inherits
[16:18:41.992]                       invokeRestart <- base::invokeRestart
[16:18:41.992]                       is.null <- base::is.null
[16:18:41.992]                       muffled <- FALSE
[16:18:41.992]                       if (inherits(cond, "message")) {
[16:18:41.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.992]                         if (muffled) 
[16:18:41.992]                           invokeRestart("muffleMessage")
[16:18:41.992]                       }
[16:18:41.992]                       else if (inherits(cond, "warning")) {
[16:18:41.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.992]                         if (muffled) 
[16:18:41.992]                           invokeRestart("muffleWarning")
[16:18:41.992]                       }
[16:18:41.992]                       else if (inherits(cond, "condition")) {
[16:18:41.992]                         if (!is.null(pattern)) {
[16:18:41.992]                           computeRestarts <- base::computeRestarts
[16:18:41.992]                           grepl <- base::grepl
[16:18:41.992]                           restarts <- computeRestarts(cond)
[16:18:41.992]                           for (restart in restarts) {
[16:18:41.992]                             name <- restart$name
[16:18:41.992]                             if (is.null(name)) 
[16:18:41.992]                               next
[16:18:41.992]                             if (!grepl(pattern, name)) 
[16:18:41.992]                               next
[16:18:41.992]                             invokeRestart(restart)
[16:18:41.992]                             muffled <- TRUE
[16:18:41.992]                             break
[16:18:41.992]                           }
[16:18:41.992]                         }
[16:18:41.992]                       }
[16:18:41.992]                       invisible(muffled)
[16:18:41.992]                     }
[16:18:41.992]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.992]                   }
[16:18:41.992]                 }
[16:18:41.992]                 else {
[16:18:41.992]                   if (TRUE) {
[16:18:41.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:41.992]                     {
[16:18:41.992]                       inherits <- base::inherits
[16:18:41.992]                       invokeRestart <- base::invokeRestart
[16:18:41.992]                       is.null <- base::is.null
[16:18:41.992]                       muffled <- FALSE
[16:18:41.992]                       if (inherits(cond, "message")) {
[16:18:41.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:41.992]                         if (muffled) 
[16:18:41.992]                           invokeRestart("muffleMessage")
[16:18:41.992]                       }
[16:18:41.992]                       else if (inherits(cond, "warning")) {
[16:18:41.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:41.992]                         if (muffled) 
[16:18:41.992]                           invokeRestart("muffleWarning")
[16:18:41.992]                       }
[16:18:41.992]                       else if (inherits(cond, "condition")) {
[16:18:41.992]                         if (!is.null(pattern)) {
[16:18:41.992]                           computeRestarts <- base::computeRestarts
[16:18:41.992]                           grepl <- base::grepl
[16:18:41.992]                           restarts <- computeRestarts(cond)
[16:18:41.992]                           for (restart in restarts) {
[16:18:41.992]                             name <- restart$name
[16:18:41.992]                             if (is.null(name)) 
[16:18:41.992]                               next
[16:18:41.992]                             if (!grepl(pattern, name)) 
[16:18:41.992]                               next
[16:18:41.992]                             invokeRestart(restart)
[16:18:41.992]                             muffled <- TRUE
[16:18:41.992]                             break
[16:18:41.992]                           }
[16:18:41.992]                         }
[16:18:41.992]                       }
[16:18:41.992]                       invisible(muffled)
[16:18:41.992]                     }
[16:18:41.992]                     muffleCondition(cond, pattern = "^muffle")
[16:18:41.992]                   }
[16:18:41.992]                 }
[16:18:41.992]             }
[16:18:41.992]         }))
[16:18:41.992]     }, error = function(ex) {
[16:18:41.992]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:41.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:41.992]                 ...future.rng), started = ...future.startTime, 
[16:18:41.992]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:41.992]             version = "1.8"), class = "FutureResult")
[16:18:41.992]     }, finally = {
[16:18:41.992]         if (!identical(...future.workdir, getwd())) 
[16:18:41.992]             setwd(...future.workdir)
[16:18:41.992]         {
[16:18:41.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:41.992]                 ...future.oldOptions$nwarnings <- NULL
[16:18:41.992]             }
[16:18:41.992]             base::options(...future.oldOptions)
[16:18:41.992]             if (.Platform$OS.type == "windows") {
[16:18:41.992]                 old_names <- names(...future.oldEnvVars)
[16:18:41.992]                 envs <- base::Sys.getenv()
[16:18:41.992]                 names <- names(envs)
[16:18:41.992]                 common <- intersect(names, old_names)
[16:18:41.992]                 added <- setdiff(names, old_names)
[16:18:41.992]                 removed <- setdiff(old_names, names)
[16:18:41.992]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:41.992]                   envs[common]]
[16:18:41.992]                 NAMES <- toupper(changed)
[16:18:41.992]                 args <- list()
[16:18:41.992]                 for (kk in seq_along(NAMES)) {
[16:18:41.992]                   name <- changed[[kk]]
[16:18:41.992]                   NAME <- NAMES[[kk]]
[16:18:41.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.992]                     next
[16:18:41.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.992]                 }
[16:18:41.992]                 NAMES <- toupper(added)
[16:18:41.992]                 for (kk in seq_along(NAMES)) {
[16:18:41.992]                   name <- added[[kk]]
[16:18:41.992]                   NAME <- NAMES[[kk]]
[16:18:41.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.992]                     next
[16:18:41.992]                   args[[name]] <- ""
[16:18:41.992]                 }
[16:18:41.992]                 NAMES <- toupper(removed)
[16:18:41.992]                 for (kk in seq_along(NAMES)) {
[16:18:41.992]                   name <- removed[[kk]]
[16:18:41.992]                   NAME <- NAMES[[kk]]
[16:18:41.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:41.992]                     next
[16:18:41.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:41.992]                 }
[16:18:41.992]                 if (length(args) > 0) 
[16:18:41.992]                   base::do.call(base::Sys.setenv, args = args)
[16:18:41.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:41.992]             }
[16:18:41.992]             else {
[16:18:41.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:41.992]             }
[16:18:41.992]             {
[16:18:41.992]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:41.992]                   0L) {
[16:18:41.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:41.992]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:41.992]                   base::options(opts)
[16:18:41.992]                 }
[16:18:41.992]                 {
[16:18:41.992]                   {
[16:18:41.992]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:41.992]                     NULL
[16:18:41.992]                   }
[16:18:41.992]                   options(future.plan = NULL)
[16:18:41.992]                   if (is.na(NA_character_)) 
[16:18:41.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:41.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:41.992]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:41.992]                     .init = FALSE)
[16:18:41.992]                 }
[16:18:41.992]             }
[16:18:41.992]         }
[16:18:41.992]     })
[16:18:41.992]     if (TRUE) {
[16:18:41.992]         base::sink(type = "output", split = FALSE)
[16:18:41.992]         if (TRUE) {
[16:18:41.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:41.992]         }
[16:18:41.992]         else {
[16:18:41.992]             ...future.result["stdout"] <- base::list(NULL)
[16:18:41.992]         }
[16:18:41.992]         base::close(...future.stdout)
[16:18:41.992]         ...future.stdout <- NULL
[16:18:41.992]     }
[16:18:41.992]     ...future.result$conditions <- ...future.conditions
[16:18:41.992]     ...future.result$finished <- base::Sys.time()
[16:18:41.992]     ...future.result
[16:18:41.992] }
[16:18:41.995] assign_globals() ...
[16:18:41.995] List of 5
[16:18:41.995]  $ ...future.FUN            :function (C, k)  
[16:18:41.995]  $ MoreArgs                 : list()
[16:18:41.995]  $ ...future.elements_ii    :List of 2
[16:18:41.995]   ..$ :List of 3
[16:18:41.995]   .. ..$ : chr "C"
[16:18:41.995]   .. ..$ : chr "D"
[16:18:41.995]   .. ..$ : chr "E"
[16:18:41.995]   ..$ :List of 3
[16:18:41.995]   .. ..$ : int 3
[16:18:41.995]   .. ..$ : int 2
[16:18:41.995]   .. ..$ : int 1
[16:18:41.995]  $ ...future.seeds_ii       : NULL
[16:18:41.995]  $ ...future.globals.maxSize: NULL
[16:18:41.995]  - attr(*, "where")=List of 5
[16:18:41.995]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:41.995]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:41.995]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:41.995]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:41.995]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:41.995]  - attr(*, "resolved")= logi FALSE
[16:18:41.995]  - attr(*, "total_size")= num 3824
[16:18:41.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:41.995]  - attr(*, "already-done")= logi TRUE
[16:18:42.003] - reassign environment for ‘...future.FUN’
[16:18:42.003] - copied ‘...future.FUN’ to environment
[16:18:42.003] - copied ‘MoreArgs’ to environment
[16:18:42.003] - copied ‘...future.elements_ii’ to environment
[16:18:42.003] - copied ‘...future.seeds_ii’ to environment
[16:18:42.003] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.003] assign_globals() ... done
[16:18:42.004] requestCore(): workers = 2
[16:18:42.006] MulticoreFuture started
[16:18:42.006] - Launch lazy future ... done
[16:18:42.007] run() for ‘MulticoreFuture’ ... done
[16:18:42.007] Created future:
[16:18:42.007] plan(): Setting new future strategy stack:
[16:18:42.007] List of future strategies:
[16:18:42.007] 1. sequential:
[16:18:42.007]    - args: function (..., envir = parent.frame())
[16:18:42.007]    - tweaked: FALSE
[16:18:42.007]    - call: NULL
[16:18:42.008] plan(): nbrOfWorkers() = 1
[16:18:42.010] plan(): Setting new future strategy stack:
[16:18:42.010] List of future strategies:
[16:18:42.010] 1. multicore:
[16:18:42.010]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.010]    - tweaked: FALSE
[16:18:42.010]    - call: plan(strategy)
[16:18:42.007] MulticoreFuture:
[16:18:42.007] Label: ‘future_.mapply-2’
[16:18:42.007] Expression:
[16:18:42.007] {
[16:18:42.007]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.007]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.007]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.007]         on.exit(options(oopts), add = TRUE)
[16:18:42.007]     }
[16:18:42.007]     {
[16:18:42.007]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.007]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.007]         do.call(mapply, args = args)
[16:18:42.007]     }
[16:18:42.007] }
[16:18:42.007] Lazy evaluation: FALSE
[16:18:42.007] Asynchronous evaluation: TRUE
[16:18:42.007] Local evaluation: TRUE
[16:18:42.007] Environment: R_GlobalEnv
[16:18:42.007] Capture standard output: TRUE
[16:18:42.007] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.007] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.007] Packages: <none>
[16:18:42.007] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.007] Resolved: FALSE
[16:18:42.007] Value: <not collected>
[16:18:42.007] Conditions captured: <none>
[16:18:42.007] Early signaling: FALSE
[16:18:42.007] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.007] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.020] Chunk #2 of 2 ... DONE
[16:18:42.020] Launching 2 futures (chunks) ... DONE
[16:18:42.020] Resolving 2 futures (chunks) ...
[16:18:42.020] resolve() on list ...
[16:18:42.020] plan(): nbrOfWorkers() = 2
[16:18:42.020]  recursive: 0
[16:18:42.021]  length: 2
[16:18:42.021] 
[16:18:42.021] Future #1
[16:18:42.021] result() for MulticoreFuture ...
[16:18:42.022] result() for MulticoreFuture ...
[16:18:42.025] result() for MulticoreFuture ... done
[16:18:42.025] result() for MulticoreFuture ... done
[16:18:42.026] result() for MulticoreFuture ...
[16:18:42.026] result() for MulticoreFuture ... done
[16:18:42.026] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:42.027] - nx: 2
[16:18:42.027] - relay: TRUE
[16:18:42.027] - stdout: TRUE
[16:18:42.028] - signal: TRUE
[16:18:42.028] - resignal: FALSE
[16:18:42.028] - force: TRUE
[16:18:42.028] - relayed: [n=2] FALSE, FALSE
[16:18:42.029] - queued futures: [n=2] FALSE, FALSE
[16:18:42.029]  - until=1
[16:18:42.029]  - relaying element #1
[16:18:42.030] result() for MulticoreFuture ...
[16:18:42.030] result() for MulticoreFuture ... done
[16:18:42.030] result() for MulticoreFuture ...
[16:18:42.030] result() for MulticoreFuture ... done
[16:18:42.031] result() for MulticoreFuture ...
[16:18:42.031] result() for MulticoreFuture ... done
[16:18:42.031] result() for MulticoreFuture ...
[16:18:42.031] result() for MulticoreFuture ... done
[16:18:42.032] - relayed: [n=2] TRUE, FALSE
[16:18:42.032] - queued futures: [n=2] TRUE, FALSE
[16:18:42.032] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:42.032]  length: 1 (resolved future 1)
[16:18:42.033] Future #2
[16:18:42.033] result() for MulticoreFuture ...
[16:18:42.034] result() for MulticoreFuture ...
[16:18:42.034] result() for MulticoreFuture ... done
[16:18:42.035] result() for MulticoreFuture ... done
[16:18:42.035] result() for MulticoreFuture ...
[16:18:42.035] result() for MulticoreFuture ... done
[16:18:42.035] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:42.035] - nx: 2
[16:18:42.035] - relay: TRUE
[16:18:42.036] - stdout: TRUE
[16:18:42.036] - signal: TRUE
[16:18:42.036] - resignal: FALSE
[16:18:42.036] - force: TRUE
[16:18:42.036] - relayed: [n=2] TRUE, FALSE
[16:18:42.036] - queued futures: [n=2] TRUE, FALSE
[16:18:42.036]  - until=2
[16:18:42.037]  - relaying element #2
[16:18:42.037] result() for MulticoreFuture ...
[16:18:42.037] result() for MulticoreFuture ... done
[16:18:42.037] result() for MulticoreFuture ...
[16:18:42.037] result() for MulticoreFuture ... done
[16:18:42.037] result() for MulticoreFuture ...
[16:18:42.037] result() for MulticoreFuture ... done
[16:18:42.037] result() for MulticoreFuture ...
[16:18:42.038] result() for MulticoreFuture ... done
[16:18:42.038] - relayed: [n=2] TRUE, TRUE
[16:18:42.038] - queued futures: [n=2] TRUE, TRUE
[16:18:42.038] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:42.038]  length: 0 (resolved future 2)
[16:18:42.038] Relaying remaining futures
[16:18:42.038] signalConditionsASAP(NULL, pos=0) ...
[16:18:42.038] - nx: 2
[16:18:42.039] - relay: TRUE
[16:18:42.039] - stdout: TRUE
[16:18:42.039] - signal: TRUE
[16:18:42.039] - resignal: FALSE
[16:18:42.039] - force: TRUE
[16:18:42.039] - relayed: [n=2] TRUE, TRUE
[16:18:42.039] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:42.039] - relayed: [n=2] TRUE, TRUE
[16:18:42.039] - queued futures: [n=2] TRUE, TRUE
[16:18:42.040] signalConditionsASAP(NULL, pos=0) ... done
[16:18:42.040] resolve() on list ... DONE
[16:18:42.040] result() for MulticoreFuture ...
[16:18:42.040] result() for MulticoreFuture ... done
[16:18:42.040] result() for MulticoreFuture ...
[16:18:42.040] result() for MulticoreFuture ... done
[16:18:42.040] result() for MulticoreFuture ...
[16:18:42.040] result() for MulticoreFuture ... done
[16:18:42.041] result() for MulticoreFuture ...
[16:18:42.041] result() for MulticoreFuture ... done
[16:18:42.041]  - Number of value chunks collected: 2
[16:18:42.041] Resolving 2 futures (chunks) ... DONE
[16:18:42.041] Reducing values from 2 chunks ...
[16:18:42.041]  - Number of values collected after concatenation: 5
[16:18:42.041]  - Number of values expected: 5
[16:18:42.041] Reducing values from 2 chunks ... DONE
[16:18:42.041] future_mapply() ... DONE
[16:18:42.042] future_mapply() ...
[16:18:42.046] Number of chunks: 3
[16:18:42.047] Index remapping (attribute 'ordering'): [n = 5] 4, 5, 3, 2, 1
[16:18:42.047] getGlobalsAndPackagesXApply() ...
[16:18:42.047]  - future.globals: TRUE
[16:18:42.047] getGlobalsAndPackages() ...
[16:18:42.047] Searching for globals...
[16:18:42.049] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:42.049] Searching for globals ... DONE
[16:18:42.049] Resolving globals: FALSE
[16:18:42.049] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:42.050] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:42.050] - globals: [1] ‘FUN’
[16:18:42.050] 
[16:18:42.050] getGlobalsAndPackages() ... DONE
[16:18:42.050]  - globals found/used: [n=1] ‘FUN’
[16:18:42.050]  - needed namespaces: [n=0] 
[16:18:42.051] Finding globals ... DONE
[16:18:42.051] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:42.051] List of 2
[16:18:42.051]  $ ...future.FUN:function (C, k)  
[16:18:42.051]  $ MoreArgs     : NULL
[16:18:42.051]  - attr(*, "where")=List of 2
[16:18:42.051]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:42.051]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:42.051]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.051]  - attr(*, "resolved")= logi FALSE
[16:18:42.051]  - attr(*, "total_size")= num NA
[16:18:42.054] Packages to be attached in all futures: [n=0] 
[16:18:42.054] getGlobalsAndPackagesXApply() ... DONE
[16:18:42.054] Number of futures (= number of chunks): 3
[16:18:42.054] Launching 3 futures (chunks) ...
[16:18:42.054] Chunk #1 of 3 ...
[16:18:42.054]  - Finding globals in '...' for chunk #1 ...
[16:18:42.054] getGlobalsAndPackages() ...
[16:18:42.055] Searching for globals...
[16:18:42.055] 
[16:18:42.055] Searching for globals ... DONE
[16:18:42.055] - globals: [0] <none>
[16:18:42.055] getGlobalsAndPackages() ... DONE
[16:18:42.055]    + additional globals found: [n=0] 
[16:18:42.055]    + additional namespaces needed: [n=0] 
[16:18:42.058]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:42.058]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:18:42.058]  - seeds: <none>
[16:18:42.058]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.058] getGlobalsAndPackages() ...
[16:18:42.058] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.058] Resolving globals: FALSE
[16:18:42.059] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:42.059] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:42.059] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.060] 
[16:18:42.060] getGlobalsAndPackages() ... DONE
[16:18:42.060] run() for ‘Future’ ...
[16:18:42.060] - state: ‘created’
[16:18:42.060] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.064] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.064]   - Field: ‘label’
[16:18:42.064]   - Field: ‘local’
[16:18:42.064]   - Field: ‘owner’
[16:18:42.065]   - Field: ‘envir’
[16:18:42.065]   - Field: ‘workers’
[16:18:42.065]   - Field: ‘packages’
[16:18:42.065]   - Field: ‘gc’
[16:18:42.065]   - Field: ‘job’
[16:18:42.065]   - Field: ‘conditions’
[16:18:42.065]   - Field: ‘expr’
[16:18:42.065]   - Field: ‘uuid’
[16:18:42.065]   - Field: ‘seed’
[16:18:42.065]   - Field: ‘version’
[16:18:42.066]   - Field: ‘result’
[16:18:42.066]   - Field: ‘asynchronous’
[16:18:42.066]   - Field: ‘calls’
[16:18:42.066]   - Field: ‘globals’
[16:18:42.066]   - Field: ‘stdout’
[16:18:42.066]   - Field: ‘earlySignal’
[16:18:42.066]   - Field: ‘lazy’
[16:18:42.066]   - Field: ‘state’
[16:18:42.066] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.066] - Launch lazy future ...
[16:18:42.067] Packages needed by the future expression (n = 0): <none>
[16:18:42.067] Packages needed by future strategies (n = 0): <none>
[16:18:42.067] {
[16:18:42.067]     {
[16:18:42.067]         {
[16:18:42.067]             ...future.startTime <- base::Sys.time()
[16:18:42.067]             {
[16:18:42.067]                 {
[16:18:42.067]                   {
[16:18:42.067]                     {
[16:18:42.067]                       base::local({
[16:18:42.067]                         has_future <- base::requireNamespace("future", 
[16:18:42.067]                           quietly = TRUE)
[16:18:42.067]                         if (has_future) {
[16:18:42.067]                           ns <- base::getNamespace("future")
[16:18:42.067]                           version <- ns[[".package"]][["version"]]
[16:18:42.067]                           if (is.null(version)) 
[16:18:42.067]                             version <- utils::packageVersion("future")
[16:18:42.067]                         }
[16:18:42.067]                         else {
[16:18:42.067]                           version <- NULL
[16:18:42.067]                         }
[16:18:42.067]                         if (!has_future || version < "1.8.0") {
[16:18:42.067]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.067]                             "", base::R.version$version.string), 
[16:18:42.067]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.067]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.067]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.067]                               "release", "version")], collapse = " "), 
[16:18:42.067]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.067]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.067]                             info)
[16:18:42.067]                           info <- base::paste(info, collapse = "; ")
[16:18:42.067]                           if (!has_future) {
[16:18:42.067]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.067]                               info)
[16:18:42.067]                           }
[16:18:42.067]                           else {
[16:18:42.067]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.067]                               info, version)
[16:18:42.067]                           }
[16:18:42.067]                           base::stop(msg)
[16:18:42.067]                         }
[16:18:42.067]                       })
[16:18:42.067]                     }
[16:18:42.067]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.067]                     base::options(mc.cores = 1L)
[16:18:42.067]                   }
[16:18:42.067]                   ...future.strategy.old <- future::plan("list")
[16:18:42.067]                   options(future.plan = NULL)
[16:18:42.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.067]                 }
[16:18:42.067]                 ...future.workdir <- getwd()
[16:18:42.067]             }
[16:18:42.067]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.067]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.067]         }
[16:18:42.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.067]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:18:42.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.067]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.067]             base::names(...future.oldOptions))
[16:18:42.067]     }
[16:18:42.067]     if (FALSE) {
[16:18:42.067]     }
[16:18:42.067]     else {
[16:18:42.067]         if (TRUE) {
[16:18:42.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.067]                 open = "w")
[16:18:42.067]         }
[16:18:42.067]         else {
[16:18:42.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.067]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.067]         }
[16:18:42.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.067]             base::sink(type = "output", split = FALSE)
[16:18:42.067]             base::close(...future.stdout)
[16:18:42.067]         }, add = TRUE)
[16:18:42.067]     }
[16:18:42.067]     ...future.frame <- base::sys.nframe()
[16:18:42.067]     ...future.conditions <- base::list()
[16:18:42.067]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.067]     if (FALSE) {
[16:18:42.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.067]     }
[16:18:42.067]     ...future.result <- base::tryCatch({
[16:18:42.067]         base::withCallingHandlers({
[16:18:42.067]             ...future.value <- base::withVisible(base::local({
[16:18:42.067]                 withCallingHandlers({
[16:18:42.067]                   {
[16:18:42.067]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.067]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.067]                       ...future.globals.maxSize)) {
[16:18:42.067]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.067]                       on.exit(options(oopts), add = TRUE)
[16:18:42.067]                     }
[16:18:42.067]                     {
[16:18:42.067]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.067]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.067]                         USE.NAMES = FALSE)
[16:18:42.067]                       do.call(mapply, args = args)
[16:18:42.067]                     }
[16:18:42.067]                   }
[16:18:42.067]                 }, immediateCondition = function(cond) {
[16:18:42.067]                   save_rds <- function (object, pathname, ...) 
[16:18:42.067]                   {
[16:18:42.067]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.067]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.067]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.067]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.067]                         fi_tmp[["mtime"]])
[16:18:42.067]                     }
[16:18:42.067]                     tryCatch({
[16:18:42.067]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.067]                     }, error = function(ex) {
[16:18:42.067]                       msg <- conditionMessage(ex)
[16:18:42.067]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.067]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.067]                         fi_tmp[["mtime"]], msg)
[16:18:42.067]                       ex$message <- msg
[16:18:42.067]                       stop(ex)
[16:18:42.067]                     })
[16:18:42.067]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.067]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.067]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.067]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.067]                       fi <- file.info(pathname)
[16:18:42.067]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.067]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.067]                         fi[["size"]], fi[["mtime"]])
[16:18:42.067]                       stop(msg)
[16:18:42.067]                     }
[16:18:42.067]                     invisible(pathname)
[16:18:42.067]                   }
[16:18:42.067]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.067]                     rootPath = tempdir()) 
[16:18:42.067]                   {
[16:18:42.067]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.067]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.067]                       tmpdir = path, fileext = ".rds")
[16:18:42.067]                     save_rds(obj, file)
[16:18:42.067]                   }
[16:18:42.067]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.067]                   {
[16:18:42.067]                     inherits <- base::inherits
[16:18:42.067]                     invokeRestart <- base::invokeRestart
[16:18:42.067]                     is.null <- base::is.null
[16:18:42.067]                     muffled <- FALSE
[16:18:42.067]                     if (inherits(cond, "message")) {
[16:18:42.067]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.067]                       if (muffled) 
[16:18:42.067]                         invokeRestart("muffleMessage")
[16:18:42.067]                     }
[16:18:42.067]                     else if (inherits(cond, "warning")) {
[16:18:42.067]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.067]                       if (muffled) 
[16:18:42.067]                         invokeRestart("muffleWarning")
[16:18:42.067]                     }
[16:18:42.067]                     else if (inherits(cond, "condition")) {
[16:18:42.067]                       if (!is.null(pattern)) {
[16:18:42.067]                         computeRestarts <- base::computeRestarts
[16:18:42.067]                         grepl <- base::grepl
[16:18:42.067]                         restarts <- computeRestarts(cond)
[16:18:42.067]                         for (restart in restarts) {
[16:18:42.067]                           name <- restart$name
[16:18:42.067]                           if (is.null(name)) 
[16:18:42.067]                             next
[16:18:42.067]                           if (!grepl(pattern, name)) 
[16:18:42.067]                             next
[16:18:42.067]                           invokeRestart(restart)
[16:18:42.067]                           muffled <- TRUE
[16:18:42.067]                           break
[16:18:42.067]                         }
[16:18:42.067]                       }
[16:18:42.067]                     }
[16:18:42.067]                     invisible(muffled)
[16:18:42.067]                   }
[16:18:42.067]                   muffleCondition(cond)
[16:18:42.067]                 })
[16:18:42.067]             }))
[16:18:42.067]             future::FutureResult(value = ...future.value$value, 
[16:18:42.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.067]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.067]                     ...future.globalenv.names))
[16:18:42.067]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.067]         }, condition = base::local({
[16:18:42.067]             c <- base::c
[16:18:42.067]             inherits <- base::inherits
[16:18:42.067]             invokeRestart <- base::invokeRestart
[16:18:42.067]             length <- base::length
[16:18:42.067]             list <- base::list
[16:18:42.067]             seq.int <- base::seq.int
[16:18:42.067]             signalCondition <- base::signalCondition
[16:18:42.067]             sys.calls <- base::sys.calls
[16:18:42.067]             `[[` <- base::`[[`
[16:18:42.067]             `+` <- base::`+`
[16:18:42.067]             `<<-` <- base::`<<-`
[16:18:42.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.067]                   3L)]
[16:18:42.067]             }
[16:18:42.067]             function(cond) {
[16:18:42.067]                 is_error <- inherits(cond, "error")
[16:18:42.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.067]                   NULL)
[16:18:42.067]                 if (is_error) {
[16:18:42.067]                   sessionInformation <- function() {
[16:18:42.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.067]                       search = base::search(), system = base::Sys.info())
[16:18:42.067]                   }
[16:18:42.067]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.067]                     cond$call), session = sessionInformation(), 
[16:18:42.067]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.067]                   signalCondition(cond)
[16:18:42.067]                 }
[16:18:42.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.067]                 "immediateCondition"))) {
[16:18:42.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.067]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.067]                   if (TRUE && !signal) {
[16:18:42.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.067]                     {
[16:18:42.067]                       inherits <- base::inherits
[16:18:42.067]                       invokeRestart <- base::invokeRestart
[16:18:42.067]                       is.null <- base::is.null
[16:18:42.067]                       muffled <- FALSE
[16:18:42.067]                       if (inherits(cond, "message")) {
[16:18:42.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.067]                         if (muffled) 
[16:18:42.067]                           invokeRestart("muffleMessage")
[16:18:42.067]                       }
[16:18:42.067]                       else if (inherits(cond, "warning")) {
[16:18:42.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.067]                         if (muffled) 
[16:18:42.067]                           invokeRestart("muffleWarning")
[16:18:42.067]                       }
[16:18:42.067]                       else if (inherits(cond, "condition")) {
[16:18:42.067]                         if (!is.null(pattern)) {
[16:18:42.067]                           computeRestarts <- base::computeRestarts
[16:18:42.067]                           grepl <- base::grepl
[16:18:42.067]                           restarts <- computeRestarts(cond)
[16:18:42.067]                           for (restart in restarts) {
[16:18:42.067]                             name <- restart$name
[16:18:42.067]                             if (is.null(name)) 
[16:18:42.067]                               next
[16:18:42.067]                             if (!grepl(pattern, name)) 
[16:18:42.067]                               next
[16:18:42.067]                             invokeRestart(restart)
[16:18:42.067]                             muffled <- TRUE
[16:18:42.067]                             break
[16:18:42.067]                           }
[16:18:42.067]                         }
[16:18:42.067]                       }
[16:18:42.067]                       invisible(muffled)
[16:18:42.067]                     }
[16:18:42.067]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.067]                   }
[16:18:42.067]                 }
[16:18:42.067]                 else {
[16:18:42.067]                   if (TRUE) {
[16:18:42.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.067]                     {
[16:18:42.067]                       inherits <- base::inherits
[16:18:42.067]                       invokeRestart <- base::invokeRestart
[16:18:42.067]                       is.null <- base::is.null
[16:18:42.067]                       muffled <- FALSE
[16:18:42.067]                       if (inherits(cond, "message")) {
[16:18:42.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.067]                         if (muffled) 
[16:18:42.067]                           invokeRestart("muffleMessage")
[16:18:42.067]                       }
[16:18:42.067]                       else if (inherits(cond, "warning")) {
[16:18:42.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.067]                         if (muffled) 
[16:18:42.067]                           invokeRestart("muffleWarning")
[16:18:42.067]                       }
[16:18:42.067]                       else if (inherits(cond, "condition")) {
[16:18:42.067]                         if (!is.null(pattern)) {
[16:18:42.067]                           computeRestarts <- base::computeRestarts
[16:18:42.067]                           grepl <- base::grepl
[16:18:42.067]                           restarts <- computeRestarts(cond)
[16:18:42.067]                           for (restart in restarts) {
[16:18:42.067]                             name <- restart$name
[16:18:42.067]                             if (is.null(name)) 
[16:18:42.067]                               next
[16:18:42.067]                             if (!grepl(pattern, name)) 
[16:18:42.067]                               next
[16:18:42.067]                             invokeRestart(restart)
[16:18:42.067]                             muffled <- TRUE
[16:18:42.067]                             break
[16:18:42.067]                           }
[16:18:42.067]                         }
[16:18:42.067]                       }
[16:18:42.067]                       invisible(muffled)
[16:18:42.067]                     }
[16:18:42.067]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.067]                   }
[16:18:42.067]                 }
[16:18:42.067]             }
[16:18:42.067]         }))
[16:18:42.067]     }, error = function(ex) {
[16:18:42.067]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.067]                 ...future.rng), started = ...future.startTime, 
[16:18:42.067]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.067]             version = "1.8"), class = "FutureResult")
[16:18:42.067]     }, finally = {
[16:18:42.067]         if (!identical(...future.workdir, getwd())) 
[16:18:42.067]             setwd(...future.workdir)
[16:18:42.067]         {
[16:18:42.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.067]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.067]             }
[16:18:42.067]             base::options(...future.oldOptions)
[16:18:42.067]             if (.Platform$OS.type == "windows") {
[16:18:42.067]                 old_names <- names(...future.oldEnvVars)
[16:18:42.067]                 envs <- base::Sys.getenv()
[16:18:42.067]                 names <- names(envs)
[16:18:42.067]                 common <- intersect(names, old_names)
[16:18:42.067]                 added <- setdiff(names, old_names)
[16:18:42.067]                 removed <- setdiff(old_names, names)
[16:18:42.067]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.067]                   envs[common]]
[16:18:42.067]                 NAMES <- toupper(changed)
[16:18:42.067]                 args <- list()
[16:18:42.067]                 for (kk in seq_along(NAMES)) {
[16:18:42.067]                   name <- changed[[kk]]
[16:18:42.067]                   NAME <- NAMES[[kk]]
[16:18:42.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.067]                     next
[16:18:42.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.067]                 }
[16:18:42.067]                 NAMES <- toupper(added)
[16:18:42.067]                 for (kk in seq_along(NAMES)) {
[16:18:42.067]                   name <- added[[kk]]
[16:18:42.067]                   NAME <- NAMES[[kk]]
[16:18:42.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.067]                     next
[16:18:42.067]                   args[[name]] <- ""
[16:18:42.067]                 }
[16:18:42.067]                 NAMES <- toupper(removed)
[16:18:42.067]                 for (kk in seq_along(NAMES)) {
[16:18:42.067]                   name <- removed[[kk]]
[16:18:42.067]                   NAME <- NAMES[[kk]]
[16:18:42.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.067]                     next
[16:18:42.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.067]                 }
[16:18:42.067]                 if (length(args) > 0) 
[16:18:42.067]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.067]             }
[16:18:42.067]             else {
[16:18:42.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.067]             }
[16:18:42.067]             {
[16:18:42.067]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.067]                   0L) {
[16:18:42.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.067]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.067]                   base::options(opts)
[16:18:42.067]                 }
[16:18:42.067]                 {
[16:18:42.067]                   {
[16:18:42.067]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.067]                     NULL
[16:18:42.067]                   }
[16:18:42.067]                   options(future.plan = NULL)
[16:18:42.067]                   if (is.na(NA_character_)) 
[16:18:42.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.067]                     .init = FALSE)
[16:18:42.067]                 }
[16:18:42.067]             }
[16:18:42.067]         }
[16:18:42.067]     })
[16:18:42.067]     if (TRUE) {
[16:18:42.067]         base::sink(type = "output", split = FALSE)
[16:18:42.067]         if (TRUE) {
[16:18:42.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.067]         }
[16:18:42.067]         else {
[16:18:42.067]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.067]         }
[16:18:42.067]         base::close(...future.stdout)
[16:18:42.067]         ...future.stdout <- NULL
[16:18:42.067]     }
[16:18:42.067]     ...future.result$conditions <- ...future.conditions
[16:18:42.067]     ...future.result$finished <- base::Sys.time()
[16:18:42.067]     ...future.result
[16:18:42.067] }
[16:18:42.070] assign_globals() ...
[16:18:42.070] List of 5
[16:18:42.070]  $ ...future.FUN            :function (C, k)  
[16:18:42.070]  $ MoreArgs                 : NULL
[16:18:42.070]  $ ...future.elements_ii    :List of 2
[16:18:42.070]   ..$ :List of 2
[16:18:42.070]   .. ..$ : chr "D"
[16:18:42.070]   .. ..$ : chr "E"
[16:18:42.070]   ..$ :List of 2
[16:18:42.070]   .. ..$ : int 2
[16:18:42.070]   .. ..$ : int 1
[16:18:42.070]  $ ...future.seeds_ii       : NULL
[16:18:42.070]  $ ...future.globals.maxSize: NULL
[16:18:42.070]  - attr(*, "where")=List of 5
[16:18:42.070]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.070]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.070]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.070]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.070]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.070]  - attr(*, "resolved")= logi FALSE
[16:18:42.070]  - attr(*, "total_size")= num 3656
[16:18:42.070]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.070]  - attr(*, "already-done")= logi TRUE
[16:18:42.075] - reassign environment for ‘...future.FUN’
[16:18:42.075] - copied ‘...future.FUN’ to environment
[16:18:42.076] - copied ‘MoreArgs’ to environment
[16:18:42.076] - copied ‘...future.elements_ii’ to environment
[16:18:42.076] - copied ‘...future.seeds_ii’ to environment
[16:18:42.076] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.076] assign_globals() ... done
[16:18:42.076] requestCore(): workers = 2
[16:18:42.078] MulticoreFuture started
[16:18:42.079] - Launch lazy future ... done
[16:18:42.079] run() for ‘MulticoreFuture’ ... done
[16:18:42.079] Created future:
[16:18:42.079] plan(): Setting new future strategy stack:
[16:18:42.080] List of future strategies:
[16:18:42.080] 1. sequential:
[16:18:42.080]    - args: function (..., envir = parent.frame())
[16:18:42.080]    - tweaked: FALSE
[16:18:42.080]    - call: NULL
[16:18:42.080] plan(): nbrOfWorkers() = 1
[16:18:42.083] plan(): Setting new future strategy stack:
[16:18:42.083] List of future strategies:
[16:18:42.083] 1. multicore:
[16:18:42.083]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.083]    - tweaked: FALSE
[16:18:42.083]    - call: plan(strategy)
[16:18:42.088] plan(): nbrOfWorkers() = 2
[16:18:42.079] MulticoreFuture:
[16:18:42.079] Label: ‘future_mapply-1’
[16:18:42.079] Expression:
[16:18:42.079] {
[16:18:42.079]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.079]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.079]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.079]         on.exit(options(oopts), add = TRUE)
[16:18:42.079]     }
[16:18:42.079]     {
[16:18:42.079]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.079]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.079]         do.call(mapply, args = args)
[16:18:42.079]     }
[16:18:42.079] }
[16:18:42.079] Lazy evaluation: FALSE
[16:18:42.079] Asynchronous evaluation: TRUE
[16:18:42.079] Local evaluation: TRUE
[16:18:42.079] Environment: R_GlobalEnv
[16:18:42.079] Capture standard output: TRUE
[16:18:42.079] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.079] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.079] Packages: <none>
[16:18:42.079] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.079] Resolved: TRUE
[16:18:42.079] Value: <not collected>
[16:18:42.079] Conditions captured: <none>
[16:18:42.079] Early signaling: FALSE
[16:18:42.079] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.079] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.089] Chunk #1 of 3 ... DONE
[16:18:42.089] Chunk #2 of 3 ...
[16:18:42.090]  - Finding globals in '...' for chunk #2 ...
[16:18:42.090] getGlobalsAndPackages() ...
[16:18:42.090] Searching for globals...
[16:18:42.090] 
[16:18:42.091] Searching for globals ... DONE
[16:18:42.091] - globals: [0] <none>
[16:18:42.091] getGlobalsAndPackages() ... DONE
[16:18:42.091]    + additional globals found: [n=0] 
[16:18:42.091]    + additional namespaces needed: [n=0] 
[16:18:42.091]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:42.091]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:18:42.092]  - seeds: <none>
[16:18:42.092]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.092] getGlobalsAndPackages() ...
[16:18:42.092] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.092] Resolving globals: FALSE
[16:18:42.093] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:42.098] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:42.098] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.099] 
[16:18:42.099] getGlobalsAndPackages() ... DONE
[16:18:42.100] run() for ‘Future’ ...
[16:18:42.100] - state: ‘created’
[16:18:42.101] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.107] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.107] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.108]   - Field: ‘label’
[16:18:42.108]   - Field: ‘local’
[16:18:42.108]   - Field: ‘owner’
[16:18:42.108]   - Field: ‘envir’
[16:18:42.109]   - Field: ‘workers’
[16:18:42.109]   - Field: ‘packages’
[16:18:42.109]   - Field: ‘gc’
[16:18:42.109]   - Field: ‘job’
[16:18:42.110]   - Field: ‘conditions’
[16:18:42.110]   - Field: ‘expr’
[16:18:42.110]   - Field: ‘uuid’
[16:18:42.110]   - Field: ‘seed’
[16:18:42.111]   - Field: ‘version’
[16:18:42.111]   - Field: ‘result’
[16:18:42.111]   - Field: ‘asynchronous’
[16:18:42.111]   - Field: ‘calls’
[16:18:42.111]   - Field: ‘globals’
[16:18:42.112]   - Field: ‘stdout’
[16:18:42.112]   - Field: ‘earlySignal’
[16:18:42.112]   - Field: ‘lazy’
[16:18:42.112]   - Field: ‘state’
[16:18:42.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.112] - Launch lazy future ...
[16:18:42.113] Packages needed by the future expression (n = 0): <none>
[16:18:42.113] Packages needed by future strategies (n = 0): <none>
[16:18:42.114] {
[16:18:42.114]     {
[16:18:42.114]         {
[16:18:42.114]             ...future.startTime <- base::Sys.time()
[16:18:42.114]             {
[16:18:42.114]                 {
[16:18:42.114]                   {
[16:18:42.114]                     {
[16:18:42.114]                       base::local({
[16:18:42.114]                         has_future <- base::requireNamespace("future", 
[16:18:42.114]                           quietly = TRUE)
[16:18:42.114]                         if (has_future) {
[16:18:42.114]                           ns <- base::getNamespace("future")
[16:18:42.114]                           version <- ns[[".package"]][["version"]]
[16:18:42.114]                           if (is.null(version)) 
[16:18:42.114]                             version <- utils::packageVersion("future")
[16:18:42.114]                         }
[16:18:42.114]                         else {
[16:18:42.114]                           version <- NULL
[16:18:42.114]                         }
[16:18:42.114]                         if (!has_future || version < "1.8.0") {
[16:18:42.114]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.114]                             "", base::R.version$version.string), 
[16:18:42.114]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.114]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.114]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.114]                               "release", "version")], collapse = " "), 
[16:18:42.114]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.114]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.114]                             info)
[16:18:42.114]                           info <- base::paste(info, collapse = "; ")
[16:18:42.114]                           if (!has_future) {
[16:18:42.114]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.114]                               info)
[16:18:42.114]                           }
[16:18:42.114]                           else {
[16:18:42.114]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.114]                               info, version)
[16:18:42.114]                           }
[16:18:42.114]                           base::stop(msg)
[16:18:42.114]                         }
[16:18:42.114]                       })
[16:18:42.114]                     }
[16:18:42.114]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.114]                     base::options(mc.cores = 1L)
[16:18:42.114]                   }
[16:18:42.114]                   ...future.strategy.old <- future::plan("list")
[16:18:42.114]                   options(future.plan = NULL)
[16:18:42.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.114]                 }
[16:18:42.114]                 ...future.workdir <- getwd()
[16:18:42.114]             }
[16:18:42.114]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.114]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.114]         }
[16:18:42.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.114]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:18:42.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.114]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.114]             base::names(...future.oldOptions))
[16:18:42.114]     }
[16:18:42.114]     if (FALSE) {
[16:18:42.114]     }
[16:18:42.114]     else {
[16:18:42.114]         if (TRUE) {
[16:18:42.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.114]                 open = "w")
[16:18:42.114]         }
[16:18:42.114]         else {
[16:18:42.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.114]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.114]         }
[16:18:42.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.114]             base::sink(type = "output", split = FALSE)
[16:18:42.114]             base::close(...future.stdout)
[16:18:42.114]         }, add = TRUE)
[16:18:42.114]     }
[16:18:42.114]     ...future.frame <- base::sys.nframe()
[16:18:42.114]     ...future.conditions <- base::list()
[16:18:42.114]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.114]     if (FALSE) {
[16:18:42.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.114]     }
[16:18:42.114]     ...future.result <- base::tryCatch({
[16:18:42.114]         base::withCallingHandlers({
[16:18:42.114]             ...future.value <- base::withVisible(base::local({
[16:18:42.114]                 withCallingHandlers({
[16:18:42.114]                   {
[16:18:42.114]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.114]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.114]                       ...future.globals.maxSize)) {
[16:18:42.114]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.114]                       on.exit(options(oopts), add = TRUE)
[16:18:42.114]                     }
[16:18:42.114]                     {
[16:18:42.114]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.114]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.114]                         USE.NAMES = FALSE)
[16:18:42.114]                       do.call(mapply, args = args)
[16:18:42.114]                     }
[16:18:42.114]                   }
[16:18:42.114]                 }, immediateCondition = function(cond) {
[16:18:42.114]                   save_rds <- function (object, pathname, ...) 
[16:18:42.114]                   {
[16:18:42.114]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.114]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.114]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.114]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.114]                         fi_tmp[["mtime"]])
[16:18:42.114]                     }
[16:18:42.114]                     tryCatch({
[16:18:42.114]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.114]                     }, error = function(ex) {
[16:18:42.114]                       msg <- conditionMessage(ex)
[16:18:42.114]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.114]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.114]                         fi_tmp[["mtime"]], msg)
[16:18:42.114]                       ex$message <- msg
[16:18:42.114]                       stop(ex)
[16:18:42.114]                     })
[16:18:42.114]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.114]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.114]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.114]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.114]                       fi <- file.info(pathname)
[16:18:42.114]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.114]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.114]                         fi[["size"]], fi[["mtime"]])
[16:18:42.114]                       stop(msg)
[16:18:42.114]                     }
[16:18:42.114]                     invisible(pathname)
[16:18:42.114]                   }
[16:18:42.114]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.114]                     rootPath = tempdir()) 
[16:18:42.114]                   {
[16:18:42.114]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.114]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.114]                       tmpdir = path, fileext = ".rds")
[16:18:42.114]                     save_rds(obj, file)
[16:18:42.114]                   }
[16:18:42.114]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.114]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.114]                   {
[16:18:42.114]                     inherits <- base::inherits
[16:18:42.114]                     invokeRestart <- base::invokeRestart
[16:18:42.114]                     is.null <- base::is.null
[16:18:42.114]                     muffled <- FALSE
[16:18:42.114]                     if (inherits(cond, "message")) {
[16:18:42.114]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.114]                       if (muffled) 
[16:18:42.114]                         invokeRestart("muffleMessage")
[16:18:42.114]                     }
[16:18:42.114]                     else if (inherits(cond, "warning")) {
[16:18:42.114]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.114]                       if (muffled) 
[16:18:42.114]                         invokeRestart("muffleWarning")
[16:18:42.114]                     }
[16:18:42.114]                     else if (inherits(cond, "condition")) {
[16:18:42.114]                       if (!is.null(pattern)) {
[16:18:42.114]                         computeRestarts <- base::computeRestarts
[16:18:42.114]                         grepl <- base::grepl
[16:18:42.114]                         restarts <- computeRestarts(cond)
[16:18:42.114]                         for (restart in restarts) {
[16:18:42.114]                           name <- restart$name
[16:18:42.114]                           if (is.null(name)) 
[16:18:42.114]                             next
[16:18:42.114]                           if (!grepl(pattern, name)) 
[16:18:42.114]                             next
[16:18:42.114]                           invokeRestart(restart)
[16:18:42.114]                           muffled <- TRUE
[16:18:42.114]                           break
[16:18:42.114]                         }
[16:18:42.114]                       }
[16:18:42.114]                     }
[16:18:42.114]                     invisible(muffled)
[16:18:42.114]                   }
[16:18:42.114]                   muffleCondition(cond)
[16:18:42.114]                 })
[16:18:42.114]             }))
[16:18:42.114]             future::FutureResult(value = ...future.value$value, 
[16:18:42.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.114]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.114]                     ...future.globalenv.names))
[16:18:42.114]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.114]         }, condition = base::local({
[16:18:42.114]             c <- base::c
[16:18:42.114]             inherits <- base::inherits
[16:18:42.114]             invokeRestart <- base::invokeRestart
[16:18:42.114]             length <- base::length
[16:18:42.114]             list <- base::list
[16:18:42.114]             seq.int <- base::seq.int
[16:18:42.114]             signalCondition <- base::signalCondition
[16:18:42.114]             sys.calls <- base::sys.calls
[16:18:42.114]             `[[` <- base::`[[`
[16:18:42.114]             `+` <- base::`+`
[16:18:42.114]             `<<-` <- base::`<<-`
[16:18:42.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.114]                   3L)]
[16:18:42.114]             }
[16:18:42.114]             function(cond) {
[16:18:42.114]                 is_error <- inherits(cond, "error")
[16:18:42.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.114]                   NULL)
[16:18:42.114]                 if (is_error) {
[16:18:42.114]                   sessionInformation <- function() {
[16:18:42.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.114]                       search = base::search(), system = base::Sys.info())
[16:18:42.114]                   }
[16:18:42.114]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.114]                     cond$call), session = sessionInformation(), 
[16:18:42.114]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.114]                   signalCondition(cond)
[16:18:42.114]                 }
[16:18:42.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.114]                 "immediateCondition"))) {
[16:18:42.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.114]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.114]                   if (TRUE && !signal) {
[16:18:42.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.114]                     {
[16:18:42.114]                       inherits <- base::inherits
[16:18:42.114]                       invokeRestart <- base::invokeRestart
[16:18:42.114]                       is.null <- base::is.null
[16:18:42.114]                       muffled <- FALSE
[16:18:42.114]                       if (inherits(cond, "message")) {
[16:18:42.114]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.114]                         if (muffled) 
[16:18:42.114]                           invokeRestart("muffleMessage")
[16:18:42.114]                       }
[16:18:42.114]                       else if (inherits(cond, "warning")) {
[16:18:42.114]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.114]                         if (muffled) 
[16:18:42.114]                           invokeRestart("muffleWarning")
[16:18:42.114]                       }
[16:18:42.114]                       else if (inherits(cond, "condition")) {
[16:18:42.114]                         if (!is.null(pattern)) {
[16:18:42.114]                           computeRestarts <- base::computeRestarts
[16:18:42.114]                           grepl <- base::grepl
[16:18:42.114]                           restarts <- computeRestarts(cond)
[16:18:42.114]                           for (restart in restarts) {
[16:18:42.114]                             name <- restart$name
[16:18:42.114]                             if (is.null(name)) 
[16:18:42.114]                               next
[16:18:42.114]                             if (!grepl(pattern, name)) 
[16:18:42.114]                               next
[16:18:42.114]                             invokeRestart(restart)
[16:18:42.114]                             muffled <- TRUE
[16:18:42.114]                             break
[16:18:42.114]                           }
[16:18:42.114]                         }
[16:18:42.114]                       }
[16:18:42.114]                       invisible(muffled)
[16:18:42.114]                     }
[16:18:42.114]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.114]                   }
[16:18:42.114]                 }
[16:18:42.114]                 else {
[16:18:42.114]                   if (TRUE) {
[16:18:42.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.114]                     {
[16:18:42.114]                       inherits <- base::inherits
[16:18:42.114]                       invokeRestart <- base::invokeRestart
[16:18:42.114]                       is.null <- base::is.null
[16:18:42.114]                       muffled <- FALSE
[16:18:42.114]                       if (inherits(cond, "message")) {
[16:18:42.114]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.114]                         if (muffled) 
[16:18:42.114]                           invokeRestart("muffleMessage")
[16:18:42.114]                       }
[16:18:42.114]                       else if (inherits(cond, "warning")) {
[16:18:42.114]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.114]                         if (muffled) 
[16:18:42.114]                           invokeRestart("muffleWarning")
[16:18:42.114]                       }
[16:18:42.114]                       else if (inherits(cond, "condition")) {
[16:18:42.114]                         if (!is.null(pattern)) {
[16:18:42.114]                           computeRestarts <- base::computeRestarts
[16:18:42.114]                           grepl <- base::grepl
[16:18:42.114]                           restarts <- computeRestarts(cond)
[16:18:42.114]                           for (restart in restarts) {
[16:18:42.114]                             name <- restart$name
[16:18:42.114]                             if (is.null(name)) 
[16:18:42.114]                               next
[16:18:42.114]                             if (!grepl(pattern, name)) 
[16:18:42.114]                               next
[16:18:42.114]                             invokeRestart(restart)
[16:18:42.114]                             muffled <- TRUE
[16:18:42.114]                             break
[16:18:42.114]                           }
[16:18:42.114]                         }
[16:18:42.114]                       }
[16:18:42.114]                       invisible(muffled)
[16:18:42.114]                     }
[16:18:42.114]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.114]                   }
[16:18:42.114]                 }
[16:18:42.114]             }
[16:18:42.114]         }))
[16:18:42.114]     }, error = function(ex) {
[16:18:42.114]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.114]                 ...future.rng), started = ...future.startTime, 
[16:18:42.114]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.114]             version = "1.8"), class = "FutureResult")
[16:18:42.114]     }, finally = {
[16:18:42.114]         if (!identical(...future.workdir, getwd())) 
[16:18:42.114]             setwd(...future.workdir)
[16:18:42.114]         {
[16:18:42.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.114]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.114]             }
[16:18:42.114]             base::options(...future.oldOptions)
[16:18:42.114]             if (.Platform$OS.type == "windows") {
[16:18:42.114]                 old_names <- names(...future.oldEnvVars)
[16:18:42.114]                 envs <- base::Sys.getenv()
[16:18:42.114]                 names <- names(envs)
[16:18:42.114]                 common <- intersect(names, old_names)
[16:18:42.114]                 added <- setdiff(names, old_names)
[16:18:42.114]                 removed <- setdiff(old_names, names)
[16:18:42.114]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.114]                   envs[common]]
[16:18:42.114]                 NAMES <- toupper(changed)
[16:18:42.114]                 args <- list()
[16:18:42.114]                 for (kk in seq_along(NAMES)) {
[16:18:42.114]                   name <- changed[[kk]]
[16:18:42.114]                   NAME <- NAMES[[kk]]
[16:18:42.114]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.114]                     next
[16:18:42.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.114]                 }
[16:18:42.114]                 NAMES <- toupper(added)
[16:18:42.114]                 for (kk in seq_along(NAMES)) {
[16:18:42.114]                   name <- added[[kk]]
[16:18:42.114]                   NAME <- NAMES[[kk]]
[16:18:42.114]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.114]                     next
[16:18:42.114]                   args[[name]] <- ""
[16:18:42.114]                 }
[16:18:42.114]                 NAMES <- toupper(removed)
[16:18:42.114]                 for (kk in seq_along(NAMES)) {
[16:18:42.114]                   name <- removed[[kk]]
[16:18:42.114]                   NAME <- NAMES[[kk]]
[16:18:42.114]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.114]                     next
[16:18:42.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.114]                 }
[16:18:42.114]                 if (length(args) > 0) 
[16:18:42.114]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.114]             }
[16:18:42.114]             else {
[16:18:42.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.114]             }
[16:18:42.114]             {
[16:18:42.114]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.114]                   0L) {
[16:18:42.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.114]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.114]                   base::options(opts)
[16:18:42.114]                 }
[16:18:42.114]                 {
[16:18:42.114]                   {
[16:18:42.114]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.114]                     NULL
[16:18:42.114]                   }
[16:18:42.114]                   options(future.plan = NULL)
[16:18:42.114]                   if (is.na(NA_character_)) 
[16:18:42.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.114]                     .init = FALSE)
[16:18:42.114]                 }
[16:18:42.114]             }
[16:18:42.114]         }
[16:18:42.114]     })
[16:18:42.114]     if (TRUE) {
[16:18:42.114]         base::sink(type = "output", split = FALSE)
[16:18:42.114]         if (TRUE) {
[16:18:42.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.114]         }
[16:18:42.114]         else {
[16:18:42.114]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.114]         }
[16:18:42.114]         base::close(...future.stdout)
[16:18:42.114]         ...future.stdout <- NULL
[16:18:42.114]     }
[16:18:42.114]     ...future.result$conditions <- ...future.conditions
[16:18:42.114]     ...future.result$finished <- base::Sys.time()
[16:18:42.114]     ...future.result
[16:18:42.114] }
[16:18:42.117] assign_globals() ...
[16:18:42.117] List of 5
[16:18:42.117]  $ ...future.FUN            :function (C, k)  
[16:18:42.117]  $ MoreArgs                 : NULL
[16:18:42.117]  $ ...future.elements_ii    :List of 2
[16:18:42.117]   ..$ :List of 1
[16:18:42.117]   .. ..$ : chr "C"
[16:18:42.117]   ..$ :List of 1
[16:18:42.117]   .. ..$ : int 3
[16:18:42.117]  $ ...future.seeds_ii       : NULL
[16:18:42.117]  $ ...future.globals.maxSize: NULL
[16:18:42.117]  - attr(*, "where")=List of 5
[16:18:42.117]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.117]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.117]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.117]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.117]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.117]  - attr(*, "resolved")= logi FALSE
[16:18:42.117]  - attr(*, "total_size")= num 3488
[16:18:42.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.117]  - attr(*, "already-done")= logi TRUE
[16:18:42.124] - reassign environment for ‘...future.FUN’
[16:18:42.124] - copied ‘...future.FUN’ to environment
[16:18:42.124] - copied ‘MoreArgs’ to environment
[16:18:42.125] - copied ‘...future.elements_ii’ to environment
[16:18:42.125] - copied ‘...future.seeds_ii’ to environment
[16:18:42.125] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.125] assign_globals() ... done
[16:18:42.125] requestCore(): workers = 2
[16:18:42.128] MulticoreFuture started
[16:18:42.128] - Launch lazy future ... done
[16:18:42.128] run() for ‘MulticoreFuture’ ... done
[16:18:42.128] Created future:
[16:18:42.129] plan(): Setting new future strategy stack:
[16:18:42.129] List of future strategies:
[16:18:42.129] 1. sequential:
[16:18:42.129]    - args: function (..., envir = parent.frame())
[16:18:42.129]    - tweaked: FALSE
[16:18:42.129]    - call: NULL
[16:18:42.130] plan(): nbrOfWorkers() = 1
[16:18:42.132] plan(): Setting new future strategy stack:
[16:18:42.132] List of future strategies:
[16:18:42.132] 1. multicore:
[16:18:42.132]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.132]    - tweaked: FALSE
[16:18:42.132]    - call: plan(strategy)
[16:18:42.137] plan(): nbrOfWorkers() = 2
[16:18:42.129] MulticoreFuture:
[16:18:42.129] Label: ‘future_mapply-2’
[16:18:42.129] Expression:
[16:18:42.129] {
[16:18:42.129]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.129]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.129]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.129]         on.exit(options(oopts), add = TRUE)
[16:18:42.129]     }
[16:18:42.129]     {
[16:18:42.129]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.129]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.129]         do.call(mapply, args = args)
[16:18:42.129]     }
[16:18:42.129] }
[16:18:42.129] Lazy evaluation: FALSE
[16:18:42.129] Asynchronous evaluation: TRUE
[16:18:42.129] Local evaluation: TRUE
[16:18:42.129] Environment: R_GlobalEnv
[16:18:42.129] Capture standard output: TRUE
[16:18:42.129] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.129] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.129] Packages: <none>
[16:18:42.129] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.129] Resolved: TRUE
[16:18:42.129] Value: <not collected>
[16:18:42.129] Conditions captured: <none>
[16:18:42.129] Early signaling: FALSE
[16:18:42.129] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.129] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.138] Chunk #2 of 3 ... DONE
[16:18:42.139] Chunk #3 of 3 ...
[16:18:42.139]  - Finding globals in '...' for chunk #3 ...
[16:18:42.139] getGlobalsAndPackages() ...
[16:18:42.139] Searching for globals...
[16:18:42.140] 
[16:18:42.140] Searching for globals ... DONE
[16:18:42.140] - globals: [0] <none>
[16:18:42.140] getGlobalsAndPackages() ... DONE
[16:18:42.140]    + additional globals found: [n=0] 
[16:18:42.141]    + additional namespaces needed: [n=0] 
[16:18:42.141]  - Finding globals in '...' for chunk #3 ... DONE
[16:18:42.141]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:18:42.141]  - seeds: <none>
[16:18:42.141]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.141] getGlobalsAndPackages() ...
[16:18:42.141] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.142] Resolving globals: FALSE
[16:18:42.143] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:42.143] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:42.144] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.144] 
[16:18:42.144] getGlobalsAndPackages() ... DONE
[16:18:42.144] run() for ‘Future’ ...
[16:18:42.145] - state: ‘created’
[16:18:42.145] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.154] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.154] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.154]   - Field: ‘label’
[16:18:42.155]   - Field: ‘local’
[16:18:42.155]   - Field: ‘owner’
[16:18:42.155]   - Field: ‘envir’
[16:18:42.156]   - Field: ‘workers’
[16:18:42.156]   - Field: ‘packages’
[16:18:42.156]   - Field: ‘gc’
[16:18:42.156]   - Field: ‘job’
[16:18:42.157]   - Field: ‘conditions’
[16:18:42.157]   - Field: ‘expr’
[16:18:42.157]   - Field: ‘uuid’
[16:18:42.158]   - Field: ‘seed’
[16:18:42.158]   - Field: ‘version’
[16:18:42.158]   - Field: ‘result’
[16:18:42.158]   - Field: ‘asynchronous’
[16:18:42.159]   - Field: ‘calls’
[16:18:42.159]   - Field: ‘globals’
[16:18:42.159]   - Field: ‘stdout’
[16:18:42.159]   - Field: ‘earlySignal’
[16:18:42.159]   - Field: ‘lazy’
[16:18:42.160]   - Field: ‘state’
[16:18:42.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.160] - Launch lazy future ...
[16:18:42.161] Packages needed by the future expression (n = 0): <none>
[16:18:42.161] Packages needed by future strategies (n = 0): <none>
[16:18:42.162] {
[16:18:42.162]     {
[16:18:42.162]         {
[16:18:42.162]             ...future.startTime <- base::Sys.time()
[16:18:42.162]             {
[16:18:42.162]                 {
[16:18:42.162]                   {
[16:18:42.162]                     {
[16:18:42.162]                       base::local({
[16:18:42.162]                         has_future <- base::requireNamespace("future", 
[16:18:42.162]                           quietly = TRUE)
[16:18:42.162]                         if (has_future) {
[16:18:42.162]                           ns <- base::getNamespace("future")
[16:18:42.162]                           version <- ns[[".package"]][["version"]]
[16:18:42.162]                           if (is.null(version)) 
[16:18:42.162]                             version <- utils::packageVersion("future")
[16:18:42.162]                         }
[16:18:42.162]                         else {
[16:18:42.162]                           version <- NULL
[16:18:42.162]                         }
[16:18:42.162]                         if (!has_future || version < "1.8.0") {
[16:18:42.162]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.162]                             "", base::R.version$version.string), 
[16:18:42.162]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.162]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.162]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.162]                               "release", "version")], collapse = " "), 
[16:18:42.162]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.162]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.162]                             info)
[16:18:42.162]                           info <- base::paste(info, collapse = "; ")
[16:18:42.162]                           if (!has_future) {
[16:18:42.162]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.162]                               info)
[16:18:42.162]                           }
[16:18:42.162]                           else {
[16:18:42.162]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.162]                               info, version)
[16:18:42.162]                           }
[16:18:42.162]                           base::stop(msg)
[16:18:42.162]                         }
[16:18:42.162]                       })
[16:18:42.162]                     }
[16:18:42.162]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.162]                     base::options(mc.cores = 1L)
[16:18:42.162]                   }
[16:18:42.162]                   ...future.strategy.old <- future::plan("list")
[16:18:42.162]                   options(future.plan = NULL)
[16:18:42.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.162]                 }
[16:18:42.162]                 ...future.workdir <- getwd()
[16:18:42.162]             }
[16:18:42.162]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.162]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.162]         }
[16:18:42.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.162]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:18:42.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.162]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.162]             base::names(...future.oldOptions))
[16:18:42.162]     }
[16:18:42.162]     if (FALSE) {
[16:18:42.162]     }
[16:18:42.162]     else {
[16:18:42.162]         if (TRUE) {
[16:18:42.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.162]                 open = "w")
[16:18:42.162]         }
[16:18:42.162]         else {
[16:18:42.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.162]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.162]         }
[16:18:42.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.162]             base::sink(type = "output", split = FALSE)
[16:18:42.162]             base::close(...future.stdout)
[16:18:42.162]         }, add = TRUE)
[16:18:42.162]     }
[16:18:42.162]     ...future.frame <- base::sys.nframe()
[16:18:42.162]     ...future.conditions <- base::list()
[16:18:42.162]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.162]     if (FALSE) {
[16:18:42.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.162]     }
[16:18:42.162]     ...future.result <- base::tryCatch({
[16:18:42.162]         base::withCallingHandlers({
[16:18:42.162]             ...future.value <- base::withVisible(base::local({
[16:18:42.162]                 withCallingHandlers({
[16:18:42.162]                   {
[16:18:42.162]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.162]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.162]                       ...future.globals.maxSize)) {
[16:18:42.162]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.162]                       on.exit(options(oopts), add = TRUE)
[16:18:42.162]                     }
[16:18:42.162]                     {
[16:18:42.162]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.162]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.162]                         USE.NAMES = FALSE)
[16:18:42.162]                       do.call(mapply, args = args)
[16:18:42.162]                     }
[16:18:42.162]                   }
[16:18:42.162]                 }, immediateCondition = function(cond) {
[16:18:42.162]                   save_rds <- function (object, pathname, ...) 
[16:18:42.162]                   {
[16:18:42.162]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.162]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.162]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.162]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.162]                         fi_tmp[["mtime"]])
[16:18:42.162]                     }
[16:18:42.162]                     tryCatch({
[16:18:42.162]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.162]                     }, error = function(ex) {
[16:18:42.162]                       msg <- conditionMessage(ex)
[16:18:42.162]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.162]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.162]                         fi_tmp[["mtime"]], msg)
[16:18:42.162]                       ex$message <- msg
[16:18:42.162]                       stop(ex)
[16:18:42.162]                     })
[16:18:42.162]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.162]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.162]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.162]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.162]                       fi <- file.info(pathname)
[16:18:42.162]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.162]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.162]                         fi[["size"]], fi[["mtime"]])
[16:18:42.162]                       stop(msg)
[16:18:42.162]                     }
[16:18:42.162]                     invisible(pathname)
[16:18:42.162]                   }
[16:18:42.162]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.162]                     rootPath = tempdir()) 
[16:18:42.162]                   {
[16:18:42.162]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.162]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.162]                       tmpdir = path, fileext = ".rds")
[16:18:42.162]                     save_rds(obj, file)
[16:18:42.162]                   }
[16:18:42.162]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.162]                   {
[16:18:42.162]                     inherits <- base::inherits
[16:18:42.162]                     invokeRestart <- base::invokeRestart
[16:18:42.162]                     is.null <- base::is.null
[16:18:42.162]                     muffled <- FALSE
[16:18:42.162]                     if (inherits(cond, "message")) {
[16:18:42.162]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.162]                       if (muffled) 
[16:18:42.162]                         invokeRestart("muffleMessage")
[16:18:42.162]                     }
[16:18:42.162]                     else if (inherits(cond, "warning")) {
[16:18:42.162]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.162]                       if (muffled) 
[16:18:42.162]                         invokeRestart("muffleWarning")
[16:18:42.162]                     }
[16:18:42.162]                     else if (inherits(cond, "condition")) {
[16:18:42.162]                       if (!is.null(pattern)) {
[16:18:42.162]                         computeRestarts <- base::computeRestarts
[16:18:42.162]                         grepl <- base::grepl
[16:18:42.162]                         restarts <- computeRestarts(cond)
[16:18:42.162]                         for (restart in restarts) {
[16:18:42.162]                           name <- restart$name
[16:18:42.162]                           if (is.null(name)) 
[16:18:42.162]                             next
[16:18:42.162]                           if (!grepl(pattern, name)) 
[16:18:42.162]                             next
[16:18:42.162]                           invokeRestart(restart)
[16:18:42.162]                           muffled <- TRUE
[16:18:42.162]                           break
[16:18:42.162]                         }
[16:18:42.162]                       }
[16:18:42.162]                     }
[16:18:42.162]                     invisible(muffled)
[16:18:42.162]                   }
[16:18:42.162]                   muffleCondition(cond)
[16:18:42.162]                 })
[16:18:42.162]             }))
[16:18:42.162]             future::FutureResult(value = ...future.value$value, 
[16:18:42.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.162]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.162]                     ...future.globalenv.names))
[16:18:42.162]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.162]         }, condition = base::local({
[16:18:42.162]             c <- base::c
[16:18:42.162]             inherits <- base::inherits
[16:18:42.162]             invokeRestart <- base::invokeRestart
[16:18:42.162]             length <- base::length
[16:18:42.162]             list <- base::list
[16:18:42.162]             seq.int <- base::seq.int
[16:18:42.162]             signalCondition <- base::signalCondition
[16:18:42.162]             sys.calls <- base::sys.calls
[16:18:42.162]             `[[` <- base::`[[`
[16:18:42.162]             `+` <- base::`+`
[16:18:42.162]             `<<-` <- base::`<<-`
[16:18:42.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.162]                   3L)]
[16:18:42.162]             }
[16:18:42.162]             function(cond) {
[16:18:42.162]                 is_error <- inherits(cond, "error")
[16:18:42.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.162]                   NULL)
[16:18:42.162]                 if (is_error) {
[16:18:42.162]                   sessionInformation <- function() {
[16:18:42.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.162]                       search = base::search(), system = base::Sys.info())
[16:18:42.162]                   }
[16:18:42.162]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.162]                     cond$call), session = sessionInformation(), 
[16:18:42.162]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.162]                   signalCondition(cond)
[16:18:42.162]                 }
[16:18:42.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.162]                 "immediateCondition"))) {
[16:18:42.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.162]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.162]                   if (TRUE && !signal) {
[16:18:42.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.162]                     {
[16:18:42.162]                       inherits <- base::inherits
[16:18:42.162]                       invokeRestart <- base::invokeRestart
[16:18:42.162]                       is.null <- base::is.null
[16:18:42.162]                       muffled <- FALSE
[16:18:42.162]                       if (inherits(cond, "message")) {
[16:18:42.162]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.162]                         if (muffled) 
[16:18:42.162]                           invokeRestart("muffleMessage")
[16:18:42.162]                       }
[16:18:42.162]                       else if (inherits(cond, "warning")) {
[16:18:42.162]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.162]                         if (muffled) 
[16:18:42.162]                           invokeRestart("muffleWarning")
[16:18:42.162]                       }
[16:18:42.162]                       else if (inherits(cond, "condition")) {
[16:18:42.162]                         if (!is.null(pattern)) {
[16:18:42.162]                           computeRestarts <- base::computeRestarts
[16:18:42.162]                           grepl <- base::grepl
[16:18:42.162]                           restarts <- computeRestarts(cond)
[16:18:42.162]                           for (restart in restarts) {
[16:18:42.162]                             name <- restart$name
[16:18:42.162]                             if (is.null(name)) 
[16:18:42.162]                               next
[16:18:42.162]                             if (!grepl(pattern, name)) 
[16:18:42.162]                               next
[16:18:42.162]                             invokeRestart(restart)
[16:18:42.162]                             muffled <- TRUE
[16:18:42.162]                             break
[16:18:42.162]                           }
[16:18:42.162]                         }
[16:18:42.162]                       }
[16:18:42.162]                       invisible(muffled)
[16:18:42.162]                     }
[16:18:42.162]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.162]                   }
[16:18:42.162]                 }
[16:18:42.162]                 else {
[16:18:42.162]                   if (TRUE) {
[16:18:42.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.162]                     {
[16:18:42.162]                       inherits <- base::inherits
[16:18:42.162]                       invokeRestart <- base::invokeRestart
[16:18:42.162]                       is.null <- base::is.null
[16:18:42.162]                       muffled <- FALSE
[16:18:42.162]                       if (inherits(cond, "message")) {
[16:18:42.162]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.162]                         if (muffled) 
[16:18:42.162]                           invokeRestart("muffleMessage")
[16:18:42.162]                       }
[16:18:42.162]                       else if (inherits(cond, "warning")) {
[16:18:42.162]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.162]                         if (muffled) 
[16:18:42.162]                           invokeRestart("muffleWarning")
[16:18:42.162]                       }
[16:18:42.162]                       else if (inherits(cond, "condition")) {
[16:18:42.162]                         if (!is.null(pattern)) {
[16:18:42.162]                           computeRestarts <- base::computeRestarts
[16:18:42.162]                           grepl <- base::grepl
[16:18:42.162]                           restarts <- computeRestarts(cond)
[16:18:42.162]                           for (restart in restarts) {
[16:18:42.162]                             name <- restart$name
[16:18:42.162]                             if (is.null(name)) 
[16:18:42.162]                               next
[16:18:42.162]                             if (!grepl(pattern, name)) 
[16:18:42.162]                               next
[16:18:42.162]                             invokeRestart(restart)
[16:18:42.162]                             muffled <- TRUE
[16:18:42.162]                             break
[16:18:42.162]                           }
[16:18:42.162]                         }
[16:18:42.162]                       }
[16:18:42.162]                       invisible(muffled)
[16:18:42.162]                     }
[16:18:42.162]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.162]                   }
[16:18:42.162]                 }
[16:18:42.162]             }
[16:18:42.162]         }))
[16:18:42.162]     }, error = function(ex) {
[16:18:42.162]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.162]                 ...future.rng), started = ...future.startTime, 
[16:18:42.162]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.162]             version = "1.8"), class = "FutureResult")
[16:18:42.162]     }, finally = {
[16:18:42.162]         if (!identical(...future.workdir, getwd())) 
[16:18:42.162]             setwd(...future.workdir)
[16:18:42.162]         {
[16:18:42.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.162]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.162]             }
[16:18:42.162]             base::options(...future.oldOptions)
[16:18:42.162]             if (.Platform$OS.type == "windows") {
[16:18:42.162]                 old_names <- names(...future.oldEnvVars)
[16:18:42.162]                 envs <- base::Sys.getenv()
[16:18:42.162]                 names <- names(envs)
[16:18:42.162]                 common <- intersect(names, old_names)
[16:18:42.162]                 added <- setdiff(names, old_names)
[16:18:42.162]                 removed <- setdiff(old_names, names)
[16:18:42.162]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.162]                   envs[common]]
[16:18:42.162]                 NAMES <- toupper(changed)
[16:18:42.162]                 args <- list()
[16:18:42.162]                 for (kk in seq_along(NAMES)) {
[16:18:42.162]                   name <- changed[[kk]]
[16:18:42.162]                   NAME <- NAMES[[kk]]
[16:18:42.162]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.162]                     next
[16:18:42.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.162]                 }
[16:18:42.162]                 NAMES <- toupper(added)
[16:18:42.162]                 for (kk in seq_along(NAMES)) {
[16:18:42.162]                   name <- added[[kk]]
[16:18:42.162]                   NAME <- NAMES[[kk]]
[16:18:42.162]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.162]                     next
[16:18:42.162]                   args[[name]] <- ""
[16:18:42.162]                 }
[16:18:42.162]                 NAMES <- toupper(removed)
[16:18:42.162]                 for (kk in seq_along(NAMES)) {
[16:18:42.162]                   name <- removed[[kk]]
[16:18:42.162]                   NAME <- NAMES[[kk]]
[16:18:42.162]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.162]                     next
[16:18:42.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.162]                 }
[16:18:42.162]                 if (length(args) > 0) 
[16:18:42.162]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.162]             }
[16:18:42.162]             else {
[16:18:42.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.162]             }
[16:18:42.162]             {
[16:18:42.162]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.162]                   0L) {
[16:18:42.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.162]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.162]                   base::options(opts)
[16:18:42.162]                 }
[16:18:42.162]                 {
[16:18:42.162]                   {
[16:18:42.162]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.162]                     NULL
[16:18:42.162]                   }
[16:18:42.162]                   options(future.plan = NULL)
[16:18:42.162]                   if (is.na(NA_character_)) 
[16:18:42.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.162]                     .init = FALSE)
[16:18:42.162]                 }
[16:18:42.162]             }
[16:18:42.162]         }
[16:18:42.162]     })
[16:18:42.162]     if (TRUE) {
[16:18:42.162]         base::sink(type = "output", split = FALSE)
[16:18:42.162]         if (TRUE) {
[16:18:42.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.162]         }
[16:18:42.162]         else {
[16:18:42.162]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.162]         }
[16:18:42.162]         base::close(...future.stdout)
[16:18:42.162]         ...future.stdout <- NULL
[16:18:42.162]     }
[16:18:42.162]     ...future.result$conditions <- ...future.conditions
[16:18:42.162]     ...future.result$finished <- base::Sys.time()
[16:18:42.162]     ...future.result
[16:18:42.162] }
[16:18:42.165] assign_globals() ...
[16:18:42.165] List of 5
[16:18:42.165]  $ ...future.FUN            :function (C, k)  
[16:18:42.165]  $ MoreArgs                 : NULL
[16:18:42.165]  $ ...future.elements_ii    :List of 2
[16:18:42.165]   ..$ :List of 2
[16:18:42.165]   .. ..$ : chr "B"
[16:18:42.165]   .. ..$ : chr "A"
[16:18:42.165]   ..$ :List of 2
[16:18:42.165]   .. ..$ : int 4
[16:18:42.165]   .. ..$ : int 5
[16:18:42.165]  $ ...future.seeds_ii       : NULL
[16:18:42.165]  $ ...future.globals.maxSize: NULL
[16:18:42.165]  - attr(*, "where")=List of 5
[16:18:42.165]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.165]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.165]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.165]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.165]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.165]  - attr(*, "resolved")= logi FALSE
[16:18:42.165]  - attr(*, "total_size")= num 3656
[16:18:42.165]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.165]  - attr(*, "already-done")= logi TRUE
[16:18:42.174] - reassign environment for ‘...future.FUN’
[16:18:42.174] - copied ‘...future.FUN’ to environment
[16:18:42.174] - copied ‘MoreArgs’ to environment
[16:18:42.174] - copied ‘...future.elements_ii’ to environment
[16:18:42.174] - copied ‘...future.seeds_ii’ to environment
[16:18:42.174] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.174] assign_globals() ... done
[16:18:42.175] requestCore(): workers = 2
[16:18:42.175] Poll #1 (0): usedCores() = 2, workers = 2
[16:18:42.185] result() for MulticoreFuture ...
[16:18:42.186] result() for MulticoreFuture ...
[16:18:42.186] result() for MulticoreFuture ... done
[16:18:42.186] result() for MulticoreFuture ... done
[16:18:42.187] result() for MulticoreFuture ...
[16:18:42.187] result() for MulticoreFuture ... done
[16:18:42.189] MulticoreFuture started
[16:18:42.190] - Launch lazy future ... done
[16:18:42.190] run() for ‘MulticoreFuture’ ... done
[16:18:42.191] Created future:
[16:18:42.191] plan(): Setting new future strategy stack:
[16:18:42.191] List of future strategies:
[16:18:42.191] 1. sequential:
[16:18:42.191]    - args: function (..., envir = parent.frame())
[16:18:42.191]    - tweaked: FALSE
[16:18:42.191]    - call: NULL
[16:18:42.192] plan(): nbrOfWorkers() = 1
[16:18:42.194] plan(): Setting new future strategy stack:
[16:18:42.195] List of future strategies:
[16:18:42.195] 1. multicore:
[16:18:42.195]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.195]    - tweaked: FALSE
[16:18:42.195]    - call: plan(strategy)
[16:18:42.200] plan(): nbrOfWorkers() = 2
[16:18:42.191] MulticoreFuture:
[16:18:42.191] Label: ‘future_mapply-3’
[16:18:42.191] Expression:
[16:18:42.191] {
[16:18:42.191]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.191]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.191]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.191]         on.exit(options(oopts), add = TRUE)
[16:18:42.191]     }
[16:18:42.191]     {
[16:18:42.191]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.191]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.191]         do.call(mapply, args = args)
[16:18:42.191]     }
[16:18:42.191] }
[16:18:42.191] Lazy evaluation: FALSE
[16:18:42.191] Asynchronous evaluation: TRUE
[16:18:42.191] Local evaluation: TRUE
[16:18:42.191] Environment: R_GlobalEnv
[16:18:42.191] Capture standard output: TRUE
[16:18:42.191] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.191] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.191] Packages: <none>
[16:18:42.191] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.191] Resolved: TRUE
[16:18:42.191] Value: <not collected>
[16:18:42.191] Conditions captured: <none>
[16:18:42.191] Early signaling: FALSE
[16:18:42.191] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.191] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.201] Chunk #3 of 3 ... DONE
[16:18:42.202] Launching 3 futures (chunks) ... DONE
[16:18:42.202] Resolving 3 futures (chunks) ...
[16:18:42.202] resolve() on list ...
[16:18:42.202]  recursive: 0
[16:18:42.202]  length: 3
[16:18:42.202] 
[16:18:42.202] Future #1
[16:18:42.203] result() for MulticoreFuture ...
[16:18:42.203] result() for MulticoreFuture ... done
[16:18:42.203] result() for MulticoreFuture ...
[16:18:42.203] result() for MulticoreFuture ... done
[16:18:42.203] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:42.203] - nx: 3
[16:18:42.203] - relay: TRUE
[16:18:42.204] - stdout: TRUE
[16:18:42.204] - signal: TRUE
[16:18:42.204] - resignal: FALSE
[16:18:42.204] - force: TRUE
[16:18:42.204] - relayed: [n=3] FALSE, FALSE, FALSE
[16:18:42.204] - queued futures: [n=3] FALSE, FALSE, FALSE
[16:18:42.204]  - until=1
[16:18:42.205]  - relaying element #1
[16:18:42.205] result() for MulticoreFuture ...
[16:18:42.205] result() for MulticoreFuture ... done
[16:18:42.205] result() for MulticoreFuture ...
[16:18:42.205] result() for MulticoreFuture ... done
[16:18:42.205] result() for MulticoreFuture ...
[16:18:42.206] result() for MulticoreFuture ... done
[16:18:42.206] result() for MulticoreFuture ...
[16:18:42.206] result() for MulticoreFuture ... done
[16:18:42.206] - relayed: [n=3] TRUE, FALSE, FALSE
[16:18:42.206] - queued futures: [n=3] TRUE, FALSE, FALSE
[16:18:42.206] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:42.206]  length: 2 (resolved future 1)
[16:18:42.207] Future #2
[16:18:42.207] result() for MulticoreFuture ...
[16:18:42.208] result() for MulticoreFuture ...
[16:18:42.208] result() for MulticoreFuture ... done
[16:18:42.208] result() for MulticoreFuture ... done
[16:18:42.213] result() for MulticoreFuture ...
[16:18:42.214] result() for MulticoreFuture ... done
[16:18:42.214] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:42.214] - nx: 3
[16:18:42.215] - relay: TRUE
[16:18:42.215] - stdout: TRUE
[16:18:42.215] - signal: TRUE
[16:18:42.216] - resignal: FALSE
[16:18:42.216] - force: TRUE
[16:18:42.216] - relayed: [n=3] TRUE, FALSE, FALSE
[16:18:42.216] - queued futures: [n=3] TRUE, FALSE, FALSE
[16:18:42.217]  - until=2
[16:18:42.217]  - relaying element #2
[16:18:42.217] result() for MulticoreFuture ...
[16:18:42.217] result() for MulticoreFuture ... done
[16:18:42.218] result() for MulticoreFuture ...
[16:18:42.218] result() for MulticoreFuture ... done
[16:18:42.218] result() for MulticoreFuture ...
[16:18:42.219] result() for MulticoreFuture ... done
[16:18:42.219] result() for MulticoreFuture ...
[16:18:42.219] result() for MulticoreFuture ... done
[16:18:42.219] - relayed: [n=3] TRUE, TRUE, FALSE
[16:18:42.219] - queued futures: [n=3] TRUE, TRUE, FALSE
[16:18:42.220] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:42.220]  length: 1 (resolved future 2)
[16:18:42.220] Future #3
[16:18:42.221] result() for MulticoreFuture ...
[16:18:42.222] result() for MulticoreFuture ...
[16:18:42.222] result() for MulticoreFuture ... done
[16:18:42.222] result() for MulticoreFuture ... done
[16:18:42.223] result() for MulticoreFuture ...
[16:18:42.223] result() for MulticoreFuture ... done
[16:18:42.223] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:18:42.223] - nx: 3
[16:18:42.224] - relay: TRUE
[16:18:42.224] - stdout: TRUE
[16:18:42.224] - signal: TRUE
[16:18:42.224] - resignal: FALSE
[16:18:42.224] - force: TRUE
[16:18:42.225] - relayed: [n=3] TRUE, TRUE, FALSE
[16:18:42.225] - queued futures: [n=3] TRUE, TRUE, FALSE
[16:18:42.225]  - until=3
[16:18:42.225]  - relaying element #3
[16:18:42.225] result() for MulticoreFuture ...
[16:18:42.226] result() for MulticoreFuture ... done
[16:18:42.226] result() for MulticoreFuture ...
[16:18:42.226] result() for MulticoreFuture ... done
[16:18:42.226] result() for MulticoreFuture ...
[16:18:42.226] result() for MulticoreFuture ... done
[16:18:42.226] result() for MulticoreFuture ...
[16:18:42.226] result() for MulticoreFuture ... done
[16:18:42.226] - relayed: [n=3] TRUE, TRUE, TRUE
[16:18:42.227] - queued futures: [n=3] TRUE, TRUE, TRUE
[16:18:42.227] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:18:42.227]  length: 0 (resolved future 3)
[16:18:42.227] Relaying remaining futures
[16:18:42.227] signalConditionsASAP(NULL, pos=0) ...
[16:18:42.227] - nx: 3
[16:18:42.227] - relay: TRUE
[16:18:42.227] - stdout: TRUE
[16:18:42.228] - signal: TRUE
[16:18:42.228] - resignal: FALSE
[16:18:42.228] - force: TRUE
[16:18:42.228] - relayed: [n=3] TRUE, TRUE, TRUE
[16:18:42.228] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[16:18:42.228] - relayed: [n=3] TRUE, TRUE, TRUE
[16:18:42.228] - queued futures: [n=3] TRUE, TRUE, TRUE
[16:18:42.228] signalConditionsASAP(NULL, pos=0) ... done
[16:18:42.228] resolve() on list ... DONE
[16:18:42.229] result() for MulticoreFuture ...
[16:18:42.229] result() for MulticoreFuture ... done
[16:18:42.229] result() for MulticoreFuture ...
[16:18:42.229] result() for MulticoreFuture ... done
[16:18:42.229] result() for MulticoreFuture ...
[16:18:42.229] result() for MulticoreFuture ... done
[16:18:42.229] result() for MulticoreFuture ...
[16:18:42.229] result() for MulticoreFuture ... done
[16:18:42.230] result() for MulticoreFuture ...
[16:18:42.230] result() for MulticoreFuture ... done
[16:18:42.230] result() for MulticoreFuture ...
[16:18:42.230] result() for MulticoreFuture ... done
[16:18:42.230]  - Number of value chunks collected: 3
[16:18:42.230] Resolving 3 futures (chunks) ... DONE
[16:18:42.230] Reducing values from 3 chunks ...
[16:18:42.230]  - Number of values collected after concatenation: 5
[16:18:42.230]  - Number of values expected: 5
[16:18:42.231] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 1, 2
[16:18:42.231] Reducing values from 3 chunks ... DONE
[16:18:42.231] future_mapply() ... DONE
[16:18:42.231] future_mapply() ...
[16:18:42.235] Number of chunks: 2
[16:18:42.235] getGlobalsAndPackagesXApply() ...
[16:18:42.236]  - future.globals: TRUE
[16:18:42.236] getGlobalsAndPackages() ...
[16:18:42.236] Searching for globals...
[16:18:42.237] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:42.238] Searching for globals ... DONE
[16:18:42.238] Resolving globals: FALSE
[16:18:42.238] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:42.238] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:42.239] - globals: [1] ‘FUN’
[16:18:42.239] 
[16:18:42.239] getGlobalsAndPackages() ... DONE
[16:18:42.239]  - globals found/used: [n=1] ‘FUN’
[16:18:42.239]  - needed namespaces: [n=0] 
[16:18:42.239] Finding globals ... DONE
[16:18:42.239] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:42.239] List of 2
[16:18:42.239]  $ ...future.FUN:function (C, k)  
[16:18:42.239]  $ MoreArgs     : list()
[16:18:42.239]  - attr(*, "where")=List of 2
[16:18:42.239]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:42.239]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:42.239]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.239]  - attr(*, "resolved")= logi FALSE
[16:18:42.239]  - attr(*, "total_size")= num NA
[16:18:42.242] Packages to be attached in all futures: [n=0] 
[16:18:42.242] getGlobalsAndPackagesXApply() ... DONE
[16:18:42.242] Number of futures (= number of chunks): 2
[16:18:42.243] Launching 2 futures (chunks) ...
[16:18:42.243] Chunk #1 of 2 ...
[16:18:42.243]  - Finding globals in '...' for chunk #1 ...
[16:18:42.243] getGlobalsAndPackages() ...
[16:18:42.243] Searching for globals...
[16:18:42.246] 
[16:18:42.246] Searching for globals ... DONE
[16:18:42.246] - globals: [0] <none>
[16:18:42.246] getGlobalsAndPackages() ... DONE
[16:18:42.246]    + additional globals found: [n=0] 
[16:18:42.246]    + additional namespaces needed: [n=0] 
[16:18:42.247]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:42.247]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:42.247]  - seeds: <none>
[16:18:42.247]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.247] getGlobalsAndPackages() ...
[16:18:42.247] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.247] Resolving globals: FALSE
[16:18:42.248] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:42.248] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:42.249] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.249] 
[16:18:42.249] getGlobalsAndPackages() ... DONE
[16:18:42.249] run() for ‘Future’ ...
[16:18:42.249] - state: ‘created’
[16:18:42.250] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.254] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.254] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.254]   - Field: ‘label’
[16:18:42.254]   - Field: ‘local’
[16:18:42.254]   - Field: ‘owner’
[16:18:42.254]   - Field: ‘envir’
[16:18:42.254]   - Field: ‘workers’
[16:18:42.255]   - Field: ‘packages’
[16:18:42.255]   - Field: ‘gc’
[16:18:42.255]   - Field: ‘job’
[16:18:42.255]   - Field: ‘conditions’
[16:18:42.255]   - Field: ‘expr’
[16:18:42.255]   - Field: ‘uuid’
[16:18:42.255]   - Field: ‘seed’
[16:18:42.255]   - Field: ‘version’
[16:18:42.255]   - Field: ‘result’
[16:18:42.255]   - Field: ‘asynchronous’
[16:18:42.256]   - Field: ‘calls’
[16:18:42.256]   - Field: ‘globals’
[16:18:42.256]   - Field: ‘stdout’
[16:18:42.256]   - Field: ‘earlySignal’
[16:18:42.256]   - Field: ‘lazy’
[16:18:42.256]   - Field: ‘state’
[16:18:42.256] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.256] - Launch lazy future ...
[16:18:42.257] Packages needed by the future expression (n = 0): <none>
[16:18:42.257] Packages needed by future strategies (n = 0): <none>
[16:18:42.257] {
[16:18:42.257]     {
[16:18:42.257]         {
[16:18:42.257]             ...future.startTime <- base::Sys.time()
[16:18:42.257]             {
[16:18:42.257]                 {
[16:18:42.257]                   {
[16:18:42.257]                     {
[16:18:42.257]                       base::local({
[16:18:42.257]                         has_future <- base::requireNamespace("future", 
[16:18:42.257]                           quietly = TRUE)
[16:18:42.257]                         if (has_future) {
[16:18:42.257]                           ns <- base::getNamespace("future")
[16:18:42.257]                           version <- ns[[".package"]][["version"]]
[16:18:42.257]                           if (is.null(version)) 
[16:18:42.257]                             version <- utils::packageVersion("future")
[16:18:42.257]                         }
[16:18:42.257]                         else {
[16:18:42.257]                           version <- NULL
[16:18:42.257]                         }
[16:18:42.257]                         if (!has_future || version < "1.8.0") {
[16:18:42.257]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.257]                             "", base::R.version$version.string), 
[16:18:42.257]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.257]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.257]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.257]                               "release", "version")], collapse = " "), 
[16:18:42.257]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.257]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.257]                             info)
[16:18:42.257]                           info <- base::paste(info, collapse = "; ")
[16:18:42.257]                           if (!has_future) {
[16:18:42.257]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.257]                               info)
[16:18:42.257]                           }
[16:18:42.257]                           else {
[16:18:42.257]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.257]                               info, version)
[16:18:42.257]                           }
[16:18:42.257]                           base::stop(msg)
[16:18:42.257]                         }
[16:18:42.257]                       })
[16:18:42.257]                     }
[16:18:42.257]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.257]                     base::options(mc.cores = 1L)
[16:18:42.257]                   }
[16:18:42.257]                   ...future.strategy.old <- future::plan("list")
[16:18:42.257]                   options(future.plan = NULL)
[16:18:42.257]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.257]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.257]                 }
[16:18:42.257]                 ...future.workdir <- getwd()
[16:18:42.257]             }
[16:18:42.257]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.257]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.257]         }
[16:18:42.257]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.257]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:42.257]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.257]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.257]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.257]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.257]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.257]             base::names(...future.oldOptions))
[16:18:42.257]     }
[16:18:42.257]     if (FALSE) {
[16:18:42.257]     }
[16:18:42.257]     else {
[16:18:42.257]         if (TRUE) {
[16:18:42.257]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.257]                 open = "w")
[16:18:42.257]         }
[16:18:42.257]         else {
[16:18:42.257]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.257]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.257]         }
[16:18:42.257]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.257]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.257]             base::sink(type = "output", split = FALSE)
[16:18:42.257]             base::close(...future.stdout)
[16:18:42.257]         }, add = TRUE)
[16:18:42.257]     }
[16:18:42.257]     ...future.frame <- base::sys.nframe()
[16:18:42.257]     ...future.conditions <- base::list()
[16:18:42.257]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.257]     if (FALSE) {
[16:18:42.257]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.257]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.257]     }
[16:18:42.257]     ...future.result <- base::tryCatch({
[16:18:42.257]         base::withCallingHandlers({
[16:18:42.257]             ...future.value <- base::withVisible(base::local({
[16:18:42.257]                 withCallingHandlers({
[16:18:42.257]                   {
[16:18:42.257]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.257]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.257]                       ...future.globals.maxSize)) {
[16:18:42.257]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.257]                       on.exit(options(oopts), add = TRUE)
[16:18:42.257]                     }
[16:18:42.257]                     {
[16:18:42.257]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.257]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.257]                         USE.NAMES = FALSE)
[16:18:42.257]                       do.call(mapply, args = args)
[16:18:42.257]                     }
[16:18:42.257]                   }
[16:18:42.257]                 }, immediateCondition = function(cond) {
[16:18:42.257]                   save_rds <- function (object, pathname, ...) 
[16:18:42.257]                   {
[16:18:42.257]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.257]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.257]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.257]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.257]                         fi_tmp[["mtime"]])
[16:18:42.257]                     }
[16:18:42.257]                     tryCatch({
[16:18:42.257]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.257]                     }, error = function(ex) {
[16:18:42.257]                       msg <- conditionMessage(ex)
[16:18:42.257]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.257]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.257]                         fi_tmp[["mtime"]], msg)
[16:18:42.257]                       ex$message <- msg
[16:18:42.257]                       stop(ex)
[16:18:42.257]                     })
[16:18:42.257]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.257]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.257]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.257]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.257]                       fi <- file.info(pathname)
[16:18:42.257]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.257]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.257]                         fi[["size"]], fi[["mtime"]])
[16:18:42.257]                       stop(msg)
[16:18:42.257]                     }
[16:18:42.257]                     invisible(pathname)
[16:18:42.257]                   }
[16:18:42.257]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.257]                     rootPath = tempdir()) 
[16:18:42.257]                   {
[16:18:42.257]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.257]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.257]                       tmpdir = path, fileext = ".rds")
[16:18:42.257]                     save_rds(obj, file)
[16:18:42.257]                   }
[16:18:42.257]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.257]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.257]                   {
[16:18:42.257]                     inherits <- base::inherits
[16:18:42.257]                     invokeRestart <- base::invokeRestart
[16:18:42.257]                     is.null <- base::is.null
[16:18:42.257]                     muffled <- FALSE
[16:18:42.257]                     if (inherits(cond, "message")) {
[16:18:42.257]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.257]                       if (muffled) 
[16:18:42.257]                         invokeRestart("muffleMessage")
[16:18:42.257]                     }
[16:18:42.257]                     else if (inherits(cond, "warning")) {
[16:18:42.257]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.257]                       if (muffled) 
[16:18:42.257]                         invokeRestart("muffleWarning")
[16:18:42.257]                     }
[16:18:42.257]                     else if (inherits(cond, "condition")) {
[16:18:42.257]                       if (!is.null(pattern)) {
[16:18:42.257]                         computeRestarts <- base::computeRestarts
[16:18:42.257]                         grepl <- base::grepl
[16:18:42.257]                         restarts <- computeRestarts(cond)
[16:18:42.257]                         for (restart in restarts) {
[16:18:42.257]                           name <- restart$name
[16:18:42.257]                           if (is.null(name)) 
[16:18:42.257]                             next
[16:18:42.257]                           if (!grepl(pattern, name)) 
[16:18:42.257]                             next
[16:18:42.257]                           invokeRestart(restart)
[16:18:42.257]                           muffled <- TRUE
[16:18:42.257]                           break
[16:18:42.257]                         }
[16:18:42.257]                       }
[16:18:42.257]                     }
[16:18:42.257]                     invisible(muffled)
[16:18:42.257]                   }
[16:18:42.257]                   muffleCondition(cond)
[16:18:42.257]                 })
[16:18:42.257]             }))
[16:18:42.257]             future::FutureResult(value = ...future.value$value, 
[16:18:42.257]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.257]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.257]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.257]                     ...future.globalenv.names))
[16:18:42.257]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.257]         }, condition = base::local({
[16:18:42.257]             c <- base::c
[16:18:42.257]             inherits <- base::inherits
[16:18:42.257]             invokeRestart <- base::invokeRestart
[16:18:42.257]             length <- base::length
[16:18:42.257]             list <- base::list
[16:18:42.257]             seq.int <- base::seq.int
[16:18:42.257]             signalCondition <- base::signalCondition
[16:18:42.257]             sys.calls <- base::sys.calls
[16:18:42.257]             `[[` <- base::`[[`
[16:18:42.257]             `+` <- base::`+`
[16:18:42.257]             `<<-` <- base::`<<-`
[16:18:42.257]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.257]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.257]                   3L)]
[16:18:42.257]             }
[16:18:42.257]             function(cond) {
[16:18:42.257]                 is_error <- inherits(cond, "error")
[16:18:42.257]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.257]                   NULL)
[16:18:42.257]                 if (is_error) {
[16:18:42.257]                   sessionInformation <- function() {
[16:18:42.257]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.257]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.257]                       search = base::search(), system = base::Sys.info())
[16:18:42.257]                   }
[16:18:42.257]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.257]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.257]                     cond$call), session = sessionInformation(), 
[16:18:42.257]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.257]                   signalCondition(cond)
[16:18:42.257]                 }
[16:18:42.257]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.257]                 "immediateCondition"))) {
[16:18:42.257]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.257]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.257]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.257]                   if (TRUE && !signal) {
[16:18:42.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.257]                     {
[16:18:42.257]                       inherits <- base::inherits
[16:18:42.257]                       invokeRestart <- base::invokeRestart
[16:18:42.257]                       is.null <- base::is.null
[16:18:42.257]                       muffled <- FALSE
[16:18:42.257]                       if (inherits(cond, "message")) {
[16:18:42.257]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.257]                         if (muffled) 
[16:18:42.257]                           invokeRestart("muffleMessage")
[16:18:42.257]                       }
[16:18:42.257]                       else if (inherits(cond, "warning")) {
[16:18:42.257]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.257]                         if (muffled) 
[16:18:42.257]                           invokeRestart("muffleWarning")
[16:18:42.257]                       }
[16:18:42.257]                       else if (inherits(cond, "condition")) {
[16:18:42.257]                         if (!is.null(pattern)) {
[16:18:42.257]                           computeRestarts <- base::computeRestarts
[16:18:42.257]                           grepl <- base::grepl
[16:18:42.257]                           restarts <- computeRestarts(cond)
[16:18:42.257]                           for (restart in restarts) {
[16:18:42.257]                             name <- restart$name
[16:18:42.257]                             if (is.null(name)) 
[16:18:42.257]                               next
[16:18:42.257]                             if (!grepl(pattern, name)) 
[16:18:42.257]                               next
[16:18:42.257]                             invokeRestart(restart)
[16:18:42.257]                             muffled <- TRUE
[16:18:42.257]                             break
[16:18:42.257]                           }
[16:18:42.257]                         }
[16:18:42.257]                       }
[16:18:42.257]                       invisible(muffled)
[16:18:42.257]                     }
[16:18:42.257]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.257]                   }
[16:18:42.257]                 }
[16:18:42.257]                 else {
[16:18:42.257]                   if (TRUE) {
[16:18:42.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.257]                     {
[16:18:42.257]                       inherits <- base::inherits
[16:18:42.257]                       invokeRestart <- base::invokeRestart
[16:18:42.257]                       is.null <- base::is.null
[16:18:42.257]                       muffled <- FALSE
[16:18:42.257]                       if (inherits(cond, "message")) {
[16:18:42.257]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.257]                         if (muffled) 
[16:18:42.257]                           invokeRestart("muffleMessage")
[16:18:42.257]                       }
[16:18:42.257]                       else if (inherits(cond, "warning")) {
[16:18:42.257]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.257]                         if (muffled) 
[16:18:42.257]                           invokeRestart("muffleWarning")
[16:18:42.257]                       }
[16:18:42.257]                       else if (inherits(cond, "condition")) {
[16:18:42.257]                         if (!is.null(pattern)) {
[16:18:42.257]                           computeRestarts <- base::computeRestarts
[16:18:42.257]                           grepl <- base::grepl
[16:18:42.257]                           restarts <- computeRestarts(cond)
[16:18:42.257]                           for (restart in restarts) {
[16:18:42.257]                             name <- restart$name
[16:18:42.257]                             if (is.null(name)) 
[16:18:42.257]                               next
[16:18:42.257]                             if (!grepl(pattern, name)) 
[16:18:42.257]                               next
[16:18:42.257]                             invokeRestart(restart)
[16:18:42.257]                             muffled <- TRUE
[16:18:42.257]                             break
[16:18:42.257]                           }
[16:18:42.257]                         }
[16:18:42.257]                       }
[16:18:42.257]                       invisible(muffled)
[16:18:42.257]                     }
[16:18:42.257]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.257]                   }
[16:18:42.257]                 }
[16:18:42.257]             }
[16:18:42.257]         }))
[16:18:42.257]     }, error = function(ex) {
[16:18:42.257]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.257]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.257]                 ...future.rng), started = ...future.startTime, 
[16:18:42.257]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.257]             version = "1.8"), class = "FutureResult")
[16:18:42.257]     }, finally = {
[16:18:42.257]         if (!identical(...future.workdir, getwd())) 
[16:18:42.257]             setwd(...future.workdir)
[16:18:42.257]         {
[16:18:42.257]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.257]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.257]             }
[16:18:42.257]             base::options(...future.oldOptions)
[16:18:42.257]             if (.Platform$OS.type == "windows") {
[16:18:42.257]                 old_names <- names(...future.oldEnvVars)
[16:18:42.257]                 envs <- base::Sys.getenv()
[16:18:42.257]                 names <- names(envs)
[16:18:42.257]                 common <- intersect(names, old_names)
[16:18:42.257]                 added <- setdiff(names, old_names)
[16:18:42.257]                 removed <- setdiff(old_names, names)
[16:18:42.257]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.257]                   envs[common]]
[16:18:42.257]                 NAMES <- toupper(changed)
[16:18:42.257]                 args <- list()
[16:18:42.257]                 for (kk in seq_along(NAMES)) {
[16:18:42.257]                   name <- changed[[kk]]
[16:18:42.257]                   NAME <- NAMES[[kk]]
[16:18:42.257]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.257]                     next
[16:18:42.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.257]                 }
[16:18:42.257]                 NAMES <- toupper(added)
[16:18:42.257]                 for (kk in seq_along(NAMES)) {
[16:18:42.257]                   name <- added[[kk]]
[16:18:42.257]                   NAME <- NAMES[[kk]]
[16:18:42.257]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.257]                     next
[16:18:42.257]                   args[[name]] <- ""
[16:18:42.257]                 }
[16:18:42.257]                 NAMES <- toupper(removed)
[16:18:42.257]                 for (kk in seq_along(NAMES)) {
[16:18:42.257]                   name <- removed[[kk]]
[16:18:42.257]                   NAME <- NAMES[[kk]]
[16:18:42.257]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.257]                     next
[16:18:42.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.257]                 }
[16:18:42.257]                 if (length(args) > 0) 
[16:18:42.257]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.257]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.257]             }
[16:18:42.257]             else {
[16:18:42.257]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.257]             }
[16:18:42.257]             {
[16:18:42.257]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.257]                   0L) {
[16:18:42.257]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.257]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.257]                   base::options(opts)
[16:18:42.257]                 }
[16:18:42.257]                 {
[16:18:42.257]                   {
[16:18:42.257]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.257]                     NULL
[16:18:42.257]                   }
[16:18:42.257]                   options(future.plan = NULL)
[16:18:42.257]                   if (is.na(NA_character_)) 
[16:18:42.257]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.257]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.257]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.257]                     .init = FALSE)
[16:18:42.257]                 }
[16:18:42.257]             }
[16:18:42.257]         }
[16:18:42.257]     })
[16:18:42.257]     if (TRUE) {
[16:18:42.257]         base::sink(type = "output", split = FALSE)
[16:18:42.257]         if (TRUE) {
[16:18:42.257]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.257]         }
[16:18:42.257]         else {
[16:18:42.257]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.257]         }
[16:18:42.257]         base::close(...future.stdout)
[16:18:42.257]         ...future.stdout <- NULL
[16:18:42.257]     }
[16:18:42.257]     ...future.result$conditions <- ...future.conditions
[16:18:42.257]     ...future.result$finished <- base::Sys.time()
[16:18:42.257]     ...future.result
[16:18:42.257] }
[16:18:42.260] assign_globals() ...
[16:18:42.260] List of 5
[16:18:42.260]  $ ...future.FUN            :function (C, k)  
[16:18:42.260]  $ MoreArgs                 : list()
[16:18:42.260]  $ ...future.elements_ii    :List of 2
[16:18:42.260]   ..$ :List of 2
[16:18:42.260]   .. ..$ : chr "A"
[16:18:42.260]   .. ..$ : chr "B"
[16:18:42.260]   ..$ :List of 2
[16:18:42.260]   .. ..$ : int 5
[16:18:42.260]   .. ..$ : int 4
[16:18:42.260]  $ ...future.seeds_ii       : NULL
[16:18:42.260]  $ ...future.globals.maxSize: NULL
[16:18:42.260]  - attr(*, "where")=List of 5
[16:18:42.260]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.260]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.260]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.260]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.260]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.260]  - attr(*, "resolved")= logi FALSE
[16:18:42.260]  - attr(*, "total_size")= num 3656
[16:18:42.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.260]  - attr(*, "already-done")= logi TRUE
[16:18:42.266] - reassign environment for ‘...future.FUN’
[16:18:42.266] - copied ‘...future.FUN’ to environment
[16:18:42.266] - copied ‘MoreArgs’ to environment
[16:18:42.266] - copied ‘...future.elements_ii’ to environment
[16:18:42.266] - copied ‘...future.seeds_ii’ to environment
[16:18:42.266] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.266] assign_globals() ... done
[16:18:42.266] requestCore(): workers = 2
[16:18:42.269] MulticoreFuture started
[16:18:42.269] - Launch lazy future ... done
[16:18:42.270] run() for ‘MulticoreFuture’ ... done
[16:18:42.270] Created future:
[16:18:42.270] plan(): Setting new future strategy stack:
[16:18:42.270] List of future strategies:
[16:18:42.270] 1. sequential:
[16:18:42.270]    - args: function (..., envir = parent.frame())
[16:18:42.270]    - tweaked: FALSE
[16:18:42.270]    - call: NULL
[16:18:42.271] plan(): nbrOfWorkers() = 1
[16:18:42.273] plan(): Setting new future strategy stack:
[16:18:42.273] List of future strategies:
[16:18:42.273] 1. multicore:
[16:18:42.273]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.273]    - tweaked: FALSE
[16:18:42.273]    - call: plan(strategy)
[16:18:42.279] plan(): nbrOfWorkers() = 2
[16:18:42.270] MulticoreFuture:
[16:18:42.270] Label: ‘future_.mapply-1’
[16:18:42.270] Expression:
[16:18:42.270] {
[16:18:42.270]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.270]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.270]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.270]         on.exit(options(oopts), add = TRUE)
[16:18:42.270]     }
[16:18:42.270]     {
[16:18:42.270]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.270]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.270]         do.call(mapply, args = args)
[16:18:42.270]     }
[16:18:42.270] }
[16:18:42.270] Lazy evaluation: FALSE
[16:18:42.270] Asynchronous evaluation: TRUE
[16:18:42.270] Local evaluation: TRUE
[16:18:42.270] Environment: R_GlobalEnv
[16:18:42.270] Capture standard output: TRUE
[16:18:42.270] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.270] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.270] Packages: <none>
[16:18:42.270] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.270] Resolved: TRUE
[16:18:42.270] Value: <not collected>
[16:18:42.270] Conditions captured: <none>
[16:18:42.270] Early signaling: FALSE
[16:18:42.270] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.270] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.280] Chunk #1 of 2 ... DONE
[16:18:42.280] Chunk #2 of 2 ...
[16:18:42.281]  - Finding globals in '...' for chunk #2 ...
[16:18:42.281] getGlobalsAndPackages() ...
[16:18:42.281] Searching for globals...
[16:18:42.281] 
[16:18:42.282] Searching for globals ... DONE
[16:18:42.282] - globals: [0] <none>
[16:18:42.282] getGlobalsAndPackages() ... DONE
[16:18:42.282]    + additional globals found: [n=0] 
[16:18:42.282]    + additional namespaces needed: [n=0] 
[16:18:42.282]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:42.282]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:42.287]  - seeds: <none>
[16:18:42.287]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.287] getGlobalsAndPackages() ...
[16:18:42.288] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.288] Resolving globals: FALSE
[16:18:42.290] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[16:18:42.291] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:42.292] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.292] 
[16:18:42.293] getGlobalsAndPackages() ... DONE
[16:18:42.293] run() for ‘Future’ ...
[16:18:42.294] - state: ‘created’
[16:18:42.294] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.300] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.300] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.301]   - Field: ‘label’
[16:18:42.301]   - Field: ‘local’
[16:18:42.301]   - Field: ‘owner’
[16:18:42.301]   - Field: ‘envir’
[16:18:42.301]   - Field: ‘workers’
[16:18:42.302]   - Field: ‘packages’
[16:18:42.302]   - Field: ‘gc’
[16:18:42.302]   - Field: ‘job’
[16:18:42.302]   - Field: ‘conditions’
[16:18:42.302]   - Field: ‘expr’
[16:18:42.302]   - Field: ‘uuid’
[16:18:42.303]   - Field: ‘seed’
[16:18:42.303]   - Field: ‘version’
[16:18:42.303]   - Field: ‘result’
[16:18:42.303]   - Field: ‘asynchronous’
[16:18:42.303]   - Field: ‘calls’
[16:18:42.303]   - Field: ‘globals’
[16:18:42.303]   - Field: ‘stdout’
[16:18:42.304]   - Field: ‘earlySignal’
[16:18:42.304]   - Field: ‘lazy’
[16:18:42.304]   - Field: ‘state’
[16:18:42.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.304] - Launch lazy future ...
[16:18:42.305] Packages needed by the future expression (n = 0): <none>
[16:18:42.305] Packages needed by future strategies (n = 0): <none>
[16:18:42.306] {
[16:18:42.306]     {
[16:18:42.306]         {
[16:18:42.306]             ...future.startTime <- base::Sys.time()
[16:18:42.306]             {
[16:18:42.306]                 {
[16:18:42.306]                   {
[16:18:42.306]                     {
[16:18:42.306]                       base::local({
[16:18:42.306]                         has_future <- base::requireNamespace("future", 
[16:18:42.306]                           quietly = TRUE)
[16:18:42.306]                         if (has_future) {
[16:18:42.306]                           ns <- base::getNamespace("future")
[16:18:42.306]                           version <- ns[[".package"]][["version"]]
[16:18:42.306]                           if (is.null(version)) 
[16:18:42.306]                             version <- utils::packageVersion("future")
[16:18:42.306]                         }
[16:18:42.306]                         else {
[16:18:42.306]                           version <- NULL
[16:18:42.306]                         }
[16:18:42.306]                         if (!has_future || version < "1.8.0") {
[16:18:42.306]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.306]                             "", base::R.version$version.string), 
[16:18:42.306]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.306]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.306]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.306]                               "release", "version")], collapse = " "), 
[16:18:42.306]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.306]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.306]                             info)
[16:18:42.306]                           info <- base::paste(info, collapse = "; ")
[16:18:42.306]                           if (!has_future) {
[16:18:42.306]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.306]                               info)
[16:18:42.306]                           }
[16:18:42.306]                           else {
[16:18:42.306]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.306]                               info, version)
[16:18:42.306]                           }
[16:18:42.306]                           base::stop(msg)
[16:18:42.306]                         }
[16:18:42.306]                       })
[16:18:42.306]                     }
[16:18:42.306]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.306]                     base::options(mc.cores = 1L)
[16:18:42.306]                   }
[16:18:42.306]                   ...future.strategy.old <- future::plan("list")
[16:18:42.306]                   options(future.plan = NULL)
[16:18:42.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.306]                 }
[16:18:42.306]                 ...future.workdir <- getwd()
[16:18:42.306]             }
[16:18:42.306]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.306]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.306]         }
[16:18:42.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.306]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:42.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.306]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.306]             base::names(...future.oldOptions))
[16:18:42.306]     }
[16:18:42.306]     if (FALSE) {
[16:18:42.306]     }
[16:18:42.306]     else {
[16:18:42.306]         if (TRUE) {
[16:18:42.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.306]                 open = "w")
[16:18:42.306]         }
[16:18:42.306]         else {
[16:18:42.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.306]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.306]         }
[16:18:42.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.306]             base::sink(type = "output", split = FALSE)
[16:18:42.306]             base::close(...future.stdout)
[16:18:42.306]         }, add = TRUE)
[16:18:42.306]     }
[16:18:42.306]     ...future.frame <- base::sys.nframe()
[16:18:42.306]     ...future.conditions <- base::list()
[16:18:42.306]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.306]     if (FALSE) {
[16:18:42.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.306]     }
[16:18:42.306]     ...future.result <- base::tryCatch({
[16:18:42.306]         base::withCallingHandlers({
[16:18:42.306]             ...future.value <- base::withVisible(base::local({
[16:18:42.306]                 withCallingHandlers({
[16:18:42.306]                   {
[16:18:42.306]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.306]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.306]                       ...future.globals.maxSize)) {
[16:18:42.306]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.306]                       on.exit(options(oopts), add = TRUE)
[16:18:42.306]                     }
[16:18:42.306]                     {
[16:18:42.306]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.306]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.306]                         USE.NAMES = FALSE)
[16:18:42.306]                       do.call(mapply, args = args)
[16:18:42.306]                     }
[16:18:42.306]                   }
[16:18:42.306]                 }, immediateCondition = function(cond) {
[16:18:42.306]                   save_rds <- function (object, pathname, ...) 
[16:18:42.306]                   {
[16:18:42.306]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.306]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.306]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.306]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.306]                         fi_tmp[["mtime"]])
[16:18:42.306]                     }
[16:18:42.306]                     tryCatch({
[16:18:42.306]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.306]                     }, error = function(ex) {
[16:18:42.306]                       msg <- conditionMessage(ex)
[16:18:42.306]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.306]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.306]                         fi_tmp[["mtime"]], msg)
[16:18:42.306]                       ex$message <- msg
[16:18:42.306]                       stop(ex)
[16:18:42.306]                     })
[16:18:42.306]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.306]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.306]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.306]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.306]                       fi <- file.info(pathname)
[16:18:42.306]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.306]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.306]                         fi[["size"]], fi[["mtime"]])
[16:18:42.306]                       stop(msg)
[16:18:42.306]                     }
[16:18:42.306]                     invisible(pathname)
[16:18:42.306]                   }
[16:18:42.306]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.306]                     rootPath = tempdir()) 
[16:18:42.306]                   {
[16:18:42.306]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.306]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.306]                       tmpdir = path, fileext = ".rds")
[16:18:42.306]                     save_rds(obj, file)
[16:18:42.306]                   }
[16:18:42.306]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.306]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.306]                   {
[16:18:42.306]                     inherits <- base::inherits
[16:18:42.306]                     invokeRestart <- base::invokeRestart
[16:18:42.306]                     is.null <- base::is.null
[16:18:42.306]                     muffled <- FALSE
[16:18:42.306]                     if (inherits(cond, "message")) {
[16:18:42.306]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.306]                       if (muffled) 
[16:18:42.306]                         invokeRestart("muffleMessage")
[16:18:42.306]                     }
[16:18:42.306]                     else if (inherits(cond, "warning")) {
[16:18:42.306]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.306]                       if (muffled) 
[16:18:42.306]                         invokeRestart("muffleWarning")
[16:18:42.306]                     }
[16:18:42.306]                     else if (inherits(cond, "condition")) {
[16:18:42.306]                       if (!is.null(pattern)) {
[16:18:42.306]                         computeRestarts <- base::computeRestarts
[16:18:42.306]                         grepl <- base::grepl
[16:18:42.306]                         restarts <- computeRestarts(cond)
[16:18:42.306]                         for (restart in restarts) {
[16:18:42.306]                           name <- restart$name
[16:18:42.306]                           if (is.null(name)) 
[16:18:42.306]                             next
[16:18:42.306]                           if (!grepl(pattern, name)) 
[16:18:42.306]                             next
[16:18:42.306]                           invokeRestart(restart)
[16:18:42.306]                           muffled <- TRUE
[16:18:42.306]                           break
[16:18:42.306]                         }
[16:18:42.306]                       }
[16:18:42.306]                     }
[16:18:42.306]                     invisible(muffled)
[16:18:42.306]                   }
[16:18:42.306]                   muffleCondition(cond)
[16:18:42.306]                 })
[16:18:42.306]             }))
[16:18:42.306]             future::FutureResult(value = ...future.value$value, 
[16:18:42.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.306]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.306]                     ...future.globalenv.names))
[16:18:42.306]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.306]         }, condition = base::local({
[16:18:42.306]             c <- base::c
[16:18:42.306]             inherits <- base::inherits
[16:18:42.306]             invokeRestart <- base::invokeRestart
[16:18:42.306]             length <- base::length
[16:18:42.306]             list <- base::list
[16:18:42.306]             seq.int <- base::seq.int
[16:18:42.306]             signalCondition <- base::signalCondition
[16:18:42.306]             sys.calls <- base::sys.calls
[16:18:42.306]             `[[` <- base::`[[`
[16:18:42.306]             `+` <- base::`+`
[16:18:42.306]             `<<-` <- base::`<<-`
[16:18:42.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.306]                   3L)]
[16:18:42.306]             }
[16:18:42.306]             function(cond) {
[16:18:42.306]                 is_error <- inherits(cond, "error")
[16:18:42.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.306]                   NULL)
[16:18:42.306]                 if (is_error) {
[16:18:42.306]                   sessionInformation <- function() {
[16:18:42.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.306]                       search = base::search(), system = base::Sys.info())
[16:18:42.306]                   }
[16:18:42.306]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.306]                     cond$call), session = sessionInformation(), 
[16:18:42.306]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.306]                   signalCondition(cond)
[16:18:42.306]                 }
[16:18:42.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.306]                 "immediateCondition"))) {
[16:18:42.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.306]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.306]                   if (TRUE && !signal) {
[16:18:42.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.306]                     {
[16:18:42.306]                       inherits <- base::inherits
[16:18:42.306]                       invokeRestart <- base::invokeRestart
[16:18:42.306]                       is.null <- base::is.null
[16:18:42.306]                       muffled <- FALSE
[16:18:42.306]                       if (inherits(cond, "message")) {
[16:18:42.306]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.306]                         if (muffled) 
[16:18:42.306]                           invokeRestart("muffleMessage")
[16:18:42.306]                       }
[16:18:42.306]                       else if (inherits(cond, "warning")) {
[16:18:42.306]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.306]                         if (muffled) 
[16:18:42.306]                           invokeRestart("muffleWarning")
[16:18:42.306]                       }
[16:18:42.306]                       else if (inherits(cond, "condition")) {
[16:18:42.306]                         if (!is.null(pattern)) {
[16:18:42.306]                           computeRestarts <- base::computeRestarts
[16:18:42.306]                           grepl <- base::grepl
[16:18:42.306]                           restarts <- computeRestarts(cond)
[16:18:42.306]                           for (restart in restarts) {
[16:18:42.306]                             name <- restart$name
[16:18:42.306]                             if (is.null(name)) 
[16:18:42.306]                               next
[16:18:42.306]                             if (!grepl(pattern, name)) 
[16:18:42.306]                               next
[16:18:42.306]                             invokeRestart(restart)
[16:18:42.306]                             muffled <- TRUE
[16:18:42.306]                             break
[16:18:42.306]                           }
[16:18:42.306]                         }
[16:18:42.306]                       }
[16:18:42.306]                       invisible(muffled)
[16:18:42.306]                     }
[16:18:42.306]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.306]                   }
[16:18:42.306]                 }
[16:18:42.306]                 else {
[16:18:42.306]                   if (TRUE) {
[16:18:42.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.306]                     {
[16:18:42.306]                       inherits <- base::inherits
[16:18:42.306]                       invokeRestart <- base::invokeRestart
[16:18:42.306]                       is.null <- base::is.null
[16:18:42.306]                       muffled <- FALSE
[16:18:42.306]                       if (inherits(cond, "message")) {
[16:18:42.306]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.306]                         if (muffled) 
[16:18:42.306]                           invokeRestart("muffleMessage")
[16:18:42.306]                       }
[16:18:42.306]                       else if (inherits(cond, "warning")) {
[16:18:42.306]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.306]                         if (muffled) 
[16:18:42.306]                           invokeRestart("muffleWarning")
[16:18:42.306]                       }
[16:18:42.306]                       else if (inherits(cond, "condition")) {
[16:18:42.306]                         if (!is.null(pattern)) {
[16:18:42.306]                           computeRestarts <- base::computeRestarts
[16:18:42.306]                           grepl <- base::grepl
[16:18:42.306]                           restarts <- computeRestarts(cond)
[16:18:42.306]                           for (restart in restarts) {
[16:18:42.306]                             name <- restart$name
[16:18:42.306]                             if (is.null(name)) 
[16:18:42.306]                               next
[16:18:42.306]                             if (!grepl(pattern, name)) 
[16:18:42.306]                               next
[16:18:42.306]                             invokeRestart(restart)
[16:18:42.306]                             muffled <- TRUE
[16:18:42.306]                             break
[16:18:42.306]                           }
[16:18:42.306]                         }
[16:18:42.306]                       }
[16:18:42.306]                       invisible(muffled)
[16:18:42.306]                     }
[16:18:42.306]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.306]                   }
[16:18:42.306]                 }
[16:18:42.306]             }
[16:18:42.306]         }))
[16:18:42.306]     }, error = function(ex) {
[16:18:42.306]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.306]                 ...future.rng), started = ...future.startTime, 
[16:18:42.306]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.306]             version = "1.8"), class = "FutureResult")
[16:18:42.306]     }, finally = {
[16:18:42.306]         if (!identical(...future.workdir, getwd())) 
[16:18:42.306]             setwd(...future.workdir)
[16:18:42.306]         {
[16:18:42.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.306]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.306]             }
[16:18:42.306]             base::options(...future.oldOptions)
[16:18:42.306]             if (.Platform$OS.type == "windows") {
[16:18:42.306]                 old_names <- names(...future.oldEnvVars)
[16:18:42.306]                 envs <- base::Sys.getenv()
[16:18:42.306]                 names <- names(envs)
[16:18:42.306]                 common <- intersect(names, old_names)
[16:18:42.306]                 added <- setdiff(names, old_names)
[16:18:42.306]                 removed <- setdiff(old_names, names)
[16:18:42.306]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.306]                   envs[common]]
[16:18:42.306]                 NAMES <- toupper(changed)
[16:18:42.306]                 args <- list()
[16:18:42.306]                 for (kk in seq_along(NAMES)) {
[16:18:42.306]                   name <- changed[[kk]]
[16:18:42.306]                   NAME <- NAMES[[kk]]
[16:18:42.306]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.306]                     next
[16:18:42.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.306]                 }
[16:18:42.306]                 NAMES <- toupper(added)
[16:18:42.306]                 for (kk in seq_along(NAMES)) {
[16:18:42.306]                   name <- added[[kk]]
[16:18:42.306]                   NAME <- NAMES[[kk]]
[16:18:42.306]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.306]                     next
[16:18:42.306]                   args[[name]] <- ""
[16:18:42.306]                 }
[16:18:42.306]                 NAMES <- toupper(removed)
[16:18:42.306]                 for (kk in seq_along(NAMES)) {
[16:18:42.306]                   name <- removed[[kk]]
[16:18:42.306]                   NAME <- NAMES[[kk]]
[16:18:42.306]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.306]                     next
[16:18:42.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.306]                 }
[16:18:42.306]                 if (length(args) > 0) 
[16:18:42.306]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.306]             }
[16:18:42.306]             else {
[16:18:42.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.306]             }
[16:18:42.306]             {
[16:18:42.306]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.306]                   0L) {
[16:18:42.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.306]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.306]                   base::options(opts)
[16:18:42.306]                 }
[16:18:42.306]                 {
[16:18:42.306]                   {
[16:18:42.306]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.306]                     NULL
[16:18:42.306]                   }
[16:18:42.306]                   options(future.plan = NULL)
[16:18:42.306]                   if (is.na(NA_character_)) 
[16:18:42.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.306]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.306]                     .init = FALSE)
[16:18:42.306]                 }
[16:18:42.306]             }
[16:18:42.306]         }
[16:18:42.306]     })
[16:18:42.306]     if (TRUE) {
[16:18:42.306]         base::sink(type = "output", split = FALSE)
[16:18:42.306]         if (TRUE) {
[16:18:42.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.306]         }
[16:18:42.306]         else {
[16:18:42.306]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.306]         }
[16:18:42.306]         base::close(...future.stdout)
[16:18:42.306]         ...future.stdout <- NULL
[16:18:42.306]     }
[16:18:42.306]     ...future.result$conditions <- ...future.conditions
[16:18:42.306]     ...future.result$finished <- base::Sys.time()
[16:18:42.306]     ...future.result
[16:18:42.306] }
[16:18:42.309] assign_globals() ...
[16:18:42.309] List of 5
[16:18:42.309]  $ ...future.FUN            :function (C, k)  
[16:18:42.309]  $ MoreArgs                 : list()
[16:18:42.309]  $ ...future.elements_ii    :List of 2
[16:18:42.309]   ..$ :List of 3
[16:18:42.309]   .. ..$ : chr "C"
[16:18:42.309]   .. ..$ : chr "D"
[16:18:42.309]   .. ..$ : chr "E"
[16:18:42.309]   ..$ :List of 3
[16:18:42.309]   .. ..$ : int 3
[16:18:42.309]   .. ..$ : int 2
[16:18:42.309]   .. ..$ : int 1
[16:18:42.309]  $ ...future.seeds_ii       : NULL
[16:18:42.309]  $ ...future.globals.maxSize: NULL
[16:18:42.309]  - attr(*, "where")=List of 5
[16:18:42.309]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.309]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.309]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.309]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.309]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.309]  - attr(*, "resolved")= logi FALSE
[16:18:42.309]  - attr(*, "total_size")= num 3824
[16:18:42.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.309]  - attr(*, "already-done")= logi TRUE
[16:18:42.317] - reassign environment for ‘...future.FUN’
[16:18:42.317] - copied ‘...future.FUN’ to environment
[16:18:42.317] - copied ‘MoreArgs’ to environment
[16:18:42.317] - copied ‘...future.elements_ii’ to environment
[16:18:42.317] - copied ‘...future.seeds_ii’ to environment
[16:18:42.317] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.318] assign_globals() ... done
[16:18:42.318] requestCore(): workers = 2
[16:18:42.320] MulticoreFuture started
[16:18:42.321] - Launch lazy future ... done
[16:18:42.321] run() for ‘MulticoreFuture’ ... done
[16:18:42.321] Created future:
[16:18:42.322] plan(): Setting new future strategy stack:
[16:18:42.322] List of future strategies:
[16:18:42.322] 1. sequential:
[16:18:42.322]    - args: function (..., envir = parent.frame())
[16:18:42.322]    - tweaked: FALSE
[16:18:42.322]    - call: NULL
[16:18:42.323] plan(): nbrOfWorkers() = 1
[16:18:42.325] plan(): Setting new future strategy stack:
[16:18:42.325] List of future strategies:
[16:18:42.325] 1. multicore:
[16:18:42.325]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.325]    - tweaked: FALSE
[16:18:42.325]    - call: plan(strategy)
[16:18:42.330] plan(): nbrOfWorkers() = 2
[16:18:42.322] MulticoreFuture:
[16:18:42.322] Label: ‘future_.mapply-2’
[16:18:42.322] Expression:
[16:18:42.322] {
[16:18:42.322]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.322]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.322]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.322]         on.exit(options(oopts), add = TRUE)
[16:18:42.322]     }
[16:18:42.322]     {
[16:18:42.322]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.322]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.322]         do.call(mapply, args = args)
[16:18:42.322]     }
[16:18:42.322] }
[16:18:42.322] Lazy evaluation: FALSE
[16:18:42.322] Asynchronous evaluation: TRUE
[16:18:42.322] Local evaluation: TRUE
[16:18:42.322] Environment: R_GlobalEnv
[16:18:42.322] Capture standard output: TRUE
[16:18:42.322] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.322] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.322] Packages: <none>
[16:18:42.322] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.322] Resolved: TRUE
[16:18:42.322] Value: <not collected>
[16:18:42.322] Conditions captured: <none>
[16:18:42.322] Early signaling: FALSE
[16:18:42.322] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.322] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.332] Chunk #2 of 2 ... DONE
[16:18:42.332] Launching 2 futures (chunks) ... DONE
[16:18:42.332] Resolving 2 futures (chunks) ...
[16:18:42.332] resolve() on list ...
[16:18:42.332]  recursive: 0
[16:18:42.332]  length: 2
[16:18:42.333] 
[16:18:42.333] Future #1
[16:18:42.333] result() for MulticoreFuture ...
[16:18:42.334] result() for MulticoreFuture ...
[16:18:42.334] result() for MulticoreFuture ... done
[16:18:42.334] result() for MulticoreFuture ... done
[16:18:42.334] result() for MulticoreFuture ...
[16:18:42.338] result() for MulticoreFuture ... done
[16:18:42.339] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:42.339] - nx: 2
[16:18:42.340] - relay: TRUE
[16:18:42.340] - stdout: TRUE
[16:18:42.340] - signal: TRUE
[16:18:42.341] - resignal: FALSE
[16:18:42.341] - force: TRUE
[16:18:42.342] - relayed: [n=2] FALSE, FALSE
[16:18:42.342] - queued futures: [n=2] FALSE, FALSE
[16:18:42.342]  - until=1
[16:18:42.342]  - relaying element #1
[16:18:42.343] result() for MulticoreFuture ...
[16:18:42.343] result() for MulticoreFuture ... done
[16:18:42.343] result() for MulticoreFuture ...
[16:18:42.344] result() for MulticoreFuture ... done
[16:18:42.344] result() for MulticoreFuture ...
[16:18:42.345] result() for MulticoreFuture ... done
[16:18:42.345] result() for MulticoreFuture ...
[16:18:42.345] result() for MulticoreFuture ... done
[16:18:42.345] - relayed: [n=2] TRUE, FALSE
[16:18:42.345] - queued futures: [n=2] TRUE, FALSE
[16:18:42.346] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:42.346]  length: 1 (resolved future 1)
[16:18:42.346] Future #2
[16:18:42.347] result() for MulticoreFuture ...
[16:18:42.348] result() for MulticoreFuture ...
[16:18:42.348] result() for MulticoreFuture ... done
[16:18:42.348] result() for MulticoreFuture ... done
[16:18:42.348] result() for MulticoreFuture ...
[16:18:42.349] result() for MulticoreFuture ... done
[16:18:42.349] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:42.349] - nx: 2
[16:18:42.349] - relay: TRUE
[16:18:42.349] - stdout: TRUE
[16:18:42.350] - signal: TRUE
[16:18:42.350] - resignal: FALSE
[16:18:42.350] - force: TRUE
[16:18:42.350] - relayed: [n=2] TRUE, FALSE
[16:18:42.350] - queued futures: [n=2] TRUE, FALSE
[16:18:42.350]  - until=2
[16:18:42.351]  - relaying element #2
[16:18:42.351] result() for MulticoreFuture ...
[16:18:42.351] result() for MulticoreFuture ... done
[16:18:42.351] result() for MulticoreFuture ...
[16:18:42.351] result() for MulticoreFuture ... done
[16:18:42.351] result() for MulticoreFuture ...
[16:18:42.351] result() for MulticoreFuture ... done
[16:18:42.351] result() for MulticoreFuture ...
[16:18:42.352] result() for MulticoreFuture ... done
[16:18:42.352] - relayed: [n=2] TRUE, TRUE
[16:18:42.352] - queued futures: [n=2] TRUE, TRUE
[16:18:42.352] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:42.352]  length: 0 (resolved future 2)
[16:18:42.352] Relaying remaining futures
[16:18:42.352] signalConditionsASAP(NULL, pos=0) ...
[16:18:42.352] - nx: 2
[16:18:42.353] - relay: TRUE
[16:18:42.353] - stdout: TRUE
[16:18:42.353] - signal: TRUE
[16:18:42.353] - resignal: FALSE
[16:18:42.353] - force: TRUE
[16:18:42.353] - relayed: [n=2] TRUE, TRUE
[16:18:42.353] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:42.353] - relayed: [n=2] TRUE, TRUE
[16:18:42.353] - queued futures: [n=2] TRUE, TRUE
[16:18:42.354] signalConditionsASAP(NULL, pos=0) ... done
[16:18:42.354] resolve() on list ... DONE
[16:18:42.354] result() for MulticoreFuture ...
[16:18:42.354] result() for MulticoreFuture ... done
[16:18:42.354] result() for MulticoreFuture ...
[16:18:42.354] result() for MulticoreFuture ... done
[16:18:42.354] result() for MulticoreFuture ...
[16:18:42.354] result() for MulticoreFuture ... done
[16:18:42.355] result() for MulticoreFuture ...
[16:18:42.355] result() for MulticoreFuture ... done
[16:18:42.355]  - Number of value chunks collected: 2
[16:18:42.355] Resolving 2 futures (chunks) ... DONE
[16:18:42.355] Reducing values from 2 chunks ...
[16:18:42.355]  - Number of values collected after concatenation: 5
[16:18:42.355]  - Number of values expected: 5
[16:18:42.355] Reducing values from 2 chunks ... DONE
[16:18:42.355] future_mapply() ... DONE
[16:18:42.356] future_mapply() ...
[16:18:42.360] Number of chunks: 2
[16:18:42.361] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[16:18:42.361] getGlobalsAndPackagesXApply() ...
[16:18:42.361]  - future.globals: TRUE
[16:18:42.361] getGlobalsAndPackages() ...
[16:18:42.361] Searching for globals...
[16:18:42.363] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:42.363] Searching for globals ... DONE
[16:18:42.363] Resolving globals: FALSE
[16:18:42.363] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:42.364] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:42.364] - globals: [1] ‘FUN’
[16:18:42.364] 
[16:18:42.364] getGlobalsAndPackages() ... DONE
[16:18:42.364]  - globals found/used: [n=1] ‘FUN’
[16:18:42.364]  - needed namespaces: [n=0] 
[16:18:42.364] Finding globals ... DONE
[16:18:42.365] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:42.365] List of 2
[16:18:42.365]  $ ...future.FUN:function (C, k)  
[16:18:42.365]  $ MoreArgs     : NULL
[16:18:42.365]  - attr(*, "where")=List of 2
[16:18:42.365]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:42.365]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:42.365]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.365]  - attr(*, "resolved")= logi FALSE
[16:18:42.365]  - attr(*, "total_size")= num NA
[16:18:42.368] Packages to be attached in all futures: [n=0] 
[16:18:42.368] getGlobalsAndPackagesXApply() ... DONE
[16:18:42.368] Number of futures (= number of chunks): 2
[16:18:42.368] Launching 2 futures (chunks) ...
[16:18:42.368] Chunk #1 of 2 ...
[16:18:42.368]  - Finding globals in '...' for chunk #1 ...
[16:18:42.368] getGlobalsAndPackages() ...
[16:18:42.368] Searching for globals...
[16:18:42.369] 
[16:18:42.369] Searching for globals ... DONE
[16:18:42.371] - globals: [0] <none>
[16:18:42.372] getGlobalsAndPackages() ... DONE
[16:18:42.372]    + additional globals found: [n=0] 
[16:18:42.372]    + additional namespaces needed: [n=0] 
[16:18:42.372]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:42.372]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:42.372]  - seeds: <none>
[16:18:42.372]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.373] getGlobalsAndPackages() ...
[16:18:42.373] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.373] Resolving globals: FALSE
[16:18:42.374] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:42.374] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:42.374] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.374] 
[16:18:42.375] getGlobalsAndPackages() ... DONE
[16:18:42.375] run() for ‘Future’ ...
[16:18:42.375] - state: ‘created’
[16:18:42.375] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.379] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.380]   - Field: ‘label’
[16:18:42.380]   - Field: ‘local’
[16:18:42.380]   - Field: ‘owner’
[16:18:42.380]   - Field: ‘envir’
[16:18:42.380]   - Field: ‘workers’
[16:18:42.380]   - Field: ‘packages’
[16:18:42.380]   - Field: ‘gc’
[16:18:42.381]   - Field: ‘job’
[16:18:42.381]   - Field: ‘conditions’
[16:18:42.381]   - Field: ‘expr’
[16:18:42.381]   - Field: ‘uuid’
[16:18:42.381]   - Field: ‘seed’
[16:18:42.381]   - Field: ‘version’
[16:18:42.381]   - Field: ‘result’
[16:18:42.381]   - Field: ‘asynchronous’
[16:18:42.381]   - Field: ‘calls’
[16:18:42.381]   - Field: ‘globals’
[16:18:42.382]   - Field: ‘stdout’
[16:18:42.382]   - Field: ‘earlySignal’
[16:18:42.382]   - Field: ‘lazy’
[16:18:42.382]   - Field: ‘state’
[16:18:42.382] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.382] - Launch lazy future ...
[16:18:42.382] Packages needed by the future expression (n = 0): <none>
[16:18:42.382] Packages needed by future strategies (n = 0): <none>
[16:18:42.383] {
[16:18:42.383]     {
[16:18:42.383]         {
[16:18:42.383]             ...future.startTime <- base::Sys.time()
[16:18:42.383]             {
[16:18:42.383]                 {
[16:18:42.383]                   {
[16:18:42.383]                     {
[16:18:42.383]                       base::local({
[16:18:42.383]                         has_future <- base::requireNamespace("future", 
[16:18:42.383]                           quietly = TRUE)
[16:18:42.383]                         if (has_future) {
[16:18:42.383]                           ns <- base::getNamespace("future")
[16:18:42.383]                           version <- ns[[".package"]][["version"]]
[16:18:42.383]                           if (is.null(version)) 
[16:18:42.383]                             version <- utils::packageVersion("future")
[16:18:42.383]                         }
[16:18:42.383]                         else {
[16:18:42.383]                           version <- NULL
[16:18:42.383]                         }
[16:18:42.383]                         if (!has_future || version < "1.8.0") {
[16:18:42.383]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.383]                             "", base::R.version$version.string), 
[16:18:42.383]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.383]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.383]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.383]                               "release", "version")], collapse = " "), 
[16:18:42.383]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.383]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.383]                             info)
[16:18:42.383]                           info <- base::paste(info, collapse = "; ")
[16:18:42.383]                           if (!has_future) {
[16:18:42.383]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.383]                               info)
[16:18:42.383]                           }
[16:18:42.383]                           else {
[16:18:42.383]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.383]                               info, version)
[16:18:42.383]                           }
[16:18:42.383]                           base::stop(msg)
[16:18:42.383]                         }
[16:18:42.383]                       })
[16:18:42.383]                     }
[16:18:42.383]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.383]                     base::options(mc.cores = 1L)
[16:18:42.383]                   }
[16:18:42.383]                   ...future.strategy.old <- future::plan("list")
[16:18:42.383]                   options(future.plan = NULL)
[16:18:42.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.383]                 }
[16:18:42.383]                 ...future.workdir <- getwd()
[16:18:42.383]             }
[16:18:42.383]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.383]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.383]         }
[16:18:42.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.383]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:42.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.383]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.383]             base::names(...future.oldOptions))
[16:18:42.383]     }
[16:18:42.383]     if (FALSE) {
[16:18:42.383]     }
[16:18:42.383]     else {
[16:18:42.383]         if (TRUE) {
[16:18:42.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.383]                 open = "w")
[16:18:42.383]         }
[16:18:42.383]         else {
[16:18:42.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.383]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.383]         }
[16:18:42.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.383]             base::sink(type = "output", split = FALSE)
[16:18:42.383]             base::close(...future.stdout)
[16:18:42.383]         }, add = TRUE)
[16:18:42.383]     }
[16:18:42.383]     ...future.frame <- base::sys.nframe()
[16:18:42.383]     ...future.conditions <- base::list()
[16:18:42.383]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.383]     if (FALSE) {
[16:18:42.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.383]     }
[16:18:42.383]     ...future.result <- base::tryCatch({
[16:18:42.383]         base::withCallingHandlers({
[16:18:42.383]             ...future.value <- base::withVisible(base::local({
[16:18:42.383]                 withCallingHandlers({
[16:18:42.383]                   {
[16:18:42.383]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.383]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.383]                       ...future.globals.maxSize)) {
[16:18:42.383]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.383]                       on.exit(options(oopts), add = TRUE)
[16:18:42.383]                     }
[16:18:42.383]                     {
[16:18:42.383]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.383]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.383]                         USE.NAMES = FALSE)
[16:18:42.383]                       do.call(mapply, args = args)
[16:18:42.383]                     }
[16:18:42.383]                   }
[16:18:42.383]                 }, immediateCondition = function(cond) {
[16:18:42.383]                   save_rds <- function (object, pathname, ...) 
[16:18:42.383]                   {
[16:18:42.383]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.383]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.383]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.383]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.383]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.383]                         fi_tmp[["mtime"]])
[16:18:42.383]                     }
[16:18:42.383]                     tryCatch({
[16:18:42.383]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.383]                     }, error = function(ex) {
[16:18:42.383]                       msg <- conditionMessage(ex)
[16:18:42.383]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.383]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.383]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.383]                         fi_tmp[["mtime"]], msg)
[16:18:42.383]                       ex$message <- msg
[16:18:42.383]                       stop(ex)
[16:18:42.383]                     })
[16:18:42.383]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.383]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.383]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.383]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.383]                       fi <- file.info(pathname)
[16:18:42.383]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.383]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.383]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.383]                         fi[["size"]], fi[["mtime"]])
[16:18:42.383]                       stop(msg)
[16:18:42.383]                     }
[16:18:42.383]                     invisible(pathname)
[16:18:42.383]                   }
[16:18:42.383]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.383]                     rootPath = tempdir()) 
[16:18:42.383]                   {
[16:18:42.383]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.383]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.383]                       tmpdir = path, fileext = ".rds")
[16:18:42.383]                     save_rds(obj, file)
[16:18:42.383]                   }
[16:18:42.383]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.383]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.383]                   {
[16:18:42.383]                     inherits <- base::inherits
[16:18:42.383]                     invokeRestart <- base::invokeRestart
[16:18:42.383]                     is.null <- base::is.null
[16:18:42.383]                     muffled <- FALSE
[16:18:42.383]                     if (inherits(cond, "message")) {
[16:18:42.383]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.383]                       if (muffled) 
[16:18:42.383]                         invokeRestart("muffleMessage")
[16:18:42.383]                     }
[16:18:42.383]                     else if (inherits(cond, "warning")) {
[16:18:42.383]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.383]                       if (muffled) 
[16:18:42.383]                         invokeRestart("muffleWarning")
[16:18:42.383]                     }
[16:18:42.383]                     else if (inherits(cond, "condition")) {
[16:18:42.383]                       if (!is.null(pattern)) {
[16:18:42.383]                         computeRestarts <- base::computeRestarts
[16:18:42.383]                         grepl <- base::grepl
[16:18:42.383]                         restarts <- computeRestarts(cond)
[16:18:42.383]                         for (restart in restarts) {
[16:18:42.383]                           name <- restart$name
[16:18:42.383]                           if (is.null(name)) 
[16:18:42.383]                             next
[16:18:42.383]                           if (!grepl(pattern, name)) 
[16:18:42.383]                             next
[16:18:42.383]                           invokeRestart(restart)
[16:18:42.383]                           muffled <- TRUE
[16:18:42.383]                           break
[16:18:42.383]                         }
[16:18:42.383]                       }
[16:18:42.383]                     }
[16:18:42.383]                     invisible(muffled)
[16:18:42.383]                   }
[16:18:42.383]                   muffleCondition(cond)
[16:18:42.383]                 })
[16:18:42.383]             }))
[16:18:42.383]             future::FutureResult(value = ...future.value$value, 
[16:18:42.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.383]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.383]                     ...future.globalenv.names))
[16:18:42.383]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.383]         }, condition = base::local({
[16:18:42.383]             c <- base::c
[16:18:42.383]             inherits <- base::inherits
[16:18:42.383]             invokeRestart <- base::invokeRestart
[16:18:42.383]             length <- base::length
[16:18:42.383]             list <- base::list
[16:18:42.383]             seq.int <- base::seq.int
[16:18:42.383]             signalCondition <- base::signalCondition
[16:18:42.383]             sys.calls <- base::sys.calls
[16:18:42.383]             `[[` <- base::`[[`
[16:18:42.383]             `+` <- base::`+`
[16:18:42.383]             `<<-` <- base::`<<-`
[16:18:42.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.383]                   3L)]
[16:18:42.383]             }
[16:18:42.383]             function(cond) {
[16:18:42.383]                 is_error <- inherits(cond, "error")
[16:18:42.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.383]                   NULL)
[16:18:42.383]                 if (is_error) {
[16:18:42.383]                   sessionInformation <- function() {
[16:18:42.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.383]                       search = base::search(), system = base::Sys.info())
[16:18:42.383]                   }
[16:18:42.383]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.383]                     cond$call), session = sessionInformation(), 
[16:18:42.383]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.383]                   signalCondition(cond)
[16:18:42.383]                 }
[16:18:42.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.383]                 "immediateCondition"))) {
[16:18:42.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.383]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.383]                   if (TRUE && !signal) {
[16:18:42.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.383]                     {
[16:18:42.383]                       inherits <- base::inherits
[16:18:42.383]                       invokeRestart <- base::invokeRestart
[16:18:42.383]                       is.null <- base::is.null
[16:18:42.383]                       muffled <- FALSE
[16:18:42.383]                       if (inherits(cond, "message")) {
[16:18:42.383]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.383]                         if (muffled) 
[16:18:42.383]                           invokeRestart("muffleMessage")
[16:18:42.383]                       }
[16:18:42.383]                       else if (inherits(cond, "warning")) {
[16:18:42.383]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.383]                         if (muffled) 
[16:18:42.383]                           invokeRestart("muffleWarning")
[16:18:42.383]                       }
[16:18:42.383]                       else if (inherits(cond, "condition")) {
[16:18:42.383]                         if (!is.null(pattern)) {
[16:18:42.383]                           computeRestarts <- base::computeRestarts
[16:18:42.383]                           grepl <- base::grepl
[16:18:42.383]                           restarts <- computeRestarts(cond)
[16:18:42.383]                           for (restart in restarts) {
[16:18:42.383]                             name <- restart$name
[16:18:42.383]                             if (is.null(name)) 
[16:18:42.383]                               next
[16:18:42.383]                             if (!grepl(pattern, name)) 
[16:18:42.383]                               next
[16:18:42.383]                             invokeRestart(restart)
[16:18:42.383]                             muffled <- TRUE
[16:18:42.383]                             break
[16:18:42.383]                           }
[16:18:42.383]                         }
[16:18:42.383]                       }
[16:18:42.383]                       invisible(muffled)
[16:18:42.383]                     }
[16:18:42.383]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.383]                   }
[16:18:42.383]                 }
[16:18:42.383]                 else {
[16:18:42.383]                   if (TRUE) {
[16:18:42.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.383]                     {
[16:18:42.383]                       inherits <- base::inherits
[16:18:42.383]                       invokeRestart <- base::invokeRestart
[16:18:42.383]                       is.null <- base::is.null
[16:18:42.383]                       muffled <- FALSE
[16:18:42.383]                       if (inherits(cond, "message")) {
[16:18:42.383]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.383]                         if (muffled) 
[16:18:42.383]                           invokeRestart("muffleMessage")
[16:18:42.383]                       }
[16:18:42.383]                       else if (inherits(cond, "warning")) {
[16:18:42.383]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.383]                         if (muffled) 
[16:18:42.383]                           invokeRestart("muffleWarning")
[16:18:42.383]                       }
[16:18:42.383]                       else if (inherits(cond, "condition")) {
[16:18:42.383]                         if (!is.null(pattern)) {
[16:18:42.383]                           computeRestarts <- base::computeRestarts
[16:18:42.383]                           grepl <- base::grepl
[16:18:42.383]                           restarts <- computeRestarts(cond)
[16:18:42.383]                           for (restart in restarts) {
[16:18:42.383]                             name <- restart$name
[16:18:42.383]                             if (is.null(name)) 
[16:18:42.383]                               next
[16:18:42.383]                             if (!grepl(pattern, name)) 
[16:18:42.383]                               next
[16:18:42.383]                             invokeRestart(restart)
[16:18:42.383]                             muffled <- TRUE
[16:18:42.383]                             break
[16:18:42.383]                           }
[16:18:42.383]                         }
[16:18:42.383]                       }
[16:18:42.383]                       invisible(muffled)
[16:18:42.383]                     }
[16:18:42.383]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.383]                   }
[16:18:42.383]                 }
[16:18:42.383]             }
[16:18:42.383]         }))
[16:18:42.383]     }, error = function(ex) {
[16:18:42.383]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.383]                 ...future.rng), started = ...future.startTime, 
[16:18:42.383]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.383]             version = "1.8"), class = "FutureResult")
[16:18:42.383]     }, finally = {
[16:18:42.383]         if (!identical(...future.workdir, getwd())) 
[16:18:42.383]             setwd(...future.workdir)
[16:18:42.383]         {
[16:18:42.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.383]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.383]             }
[16:18:42.383]             base::options(...future.oldOptions)
[16:18:42.383]             if (.Platform$OS.type == "windows") {
[16:18:42.383]                 old_names <- names(...future.oldEnvVars)
[16:18:42.383]                 envs <- base::Sys.getenv()
[16:18:42.383]                 names <- names(envs)
[16:18:42.383]                 common <- intersect(names, old_names)
[16:18:42.383]                 added <- setdiff(names, old_names)
[16:18:42.383]                 removed <- setdiff(old_names, names)
[16:18:42.383]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.383]                   envs[common]]
[16:18:42.383]                 NAMES <- toupper(changed)
[16:18:42.383]                 args <- list()
[16:18:42.383]                 for (kk in seq_along(NAMES)) {
[16:18:42.383]                   name <- changed[[kk]]
[16:18:42.383]                   NAME <- NAMES[[kk]]
[16:18:42.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.383]                     next
[16:18:42.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.383]                 }
[16:18:42.383]                 NAMES <- toupper(added)
[16:18:42.383]                 for (kk in seq_along(NAMES)) {
[16:18:42.383]                   name <- added[[kk]]
[16:18:42.383]                   NAME <- NAMES[[kk]]
[16:18:42.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.383]                     next
[16:18:42.383]                   args[[name]] <- ""
[16:18:42.383]                 }
[16:18:42.383]                 NAMES <- toupper(removed)
[16:18:42.383]                 for (kk in seq_along(NAMES)) {
[16:18:42.383]                   name <- removed[[kk]]
[16:18:42.383]                   NAME <- NAMES[[kk]]
[16:18:42.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.383]                     next
[16:18:42.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.383]                 }
[16:18:42.383]                 if (length(args) > 0) 
[16:18:42.383]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.383]             }
[16:18:42.383]             else {
[16:18:42.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.383]             }
[16:18:42.383]             {
[16:18:42.383]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.383]                   0L) {
[16:18:42.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.383]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.383]                   base::options(opts)
[16:18:42.383]                 }
[16:18:42.383]                 {
[16:18:42.383]                   {
[16:18:42.383]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.383]                     NULL
[16:18:42.383]                   }
[16:18:42.383]                   options(future.plan = NULL)
[16:18:42.383]                   if (is.na(NA_character_)) 
[16:18:42.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.383]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.383]                     .init = FALSE)
[16:18:42.383]                 }
[16:18:42.383]             }
[16:18:42.383]         }
[16:18:42.383]     })
[16:18:42.383]     if (TRUE) {
[16:18:42.383]         base::sink(type = "output", split = FALSE)
[16:18:42.383]         if (TRUE) {
[16:18:42.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.383]         }
[16:18:42.383]         else {
[16:18:42.383]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.383]         }
[16:18:42.383]         base::close(...future.stdout)
[16:18:42.383]         ...future.stdout <- NULL
[16:18:42.383]     }
[16:18:42.383]     ...future.result$conditions <- ...future.conditions
[16:18:42.383]     ...future.result$finished <- base::Sys.time()
[16:18:42.383]     ...future.result
[16:18:42.383] }
[16:18:42.385] assign_globals() ...
[16:18:42.386] List of 5
[16:18:42.386]  $ ...future.FUN            :function (C, k)  
[16:18:42.386]  $ MoreArgs                 : NULL
[16:18:42.386]  $ ...future.elements_ii    :List of 2
[16:18:42.386]   ..$ :List of 2
[16:18:42.386]   .. ..$ : chr "E"
[16:18:42.386]   .. ..$ : chr "D"
[16:18:42.386]   ..$ :List of 2
[16:18:42.386]   .. ..$ : int 1
[16:18:42.386]   .. ..$ : int 2
[16:18:42.386]  $ ...future.seeds_ii       : NULL
[16:18:42.386]  $ ...future.globals.maxSize: NULL
[16:18:42.386]  - attr(*, "where")=List of 5
[16:18:42.386]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.386]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.386]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.386]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.386]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.386]  - attr(*, "resolved")= logi FALSE
[16:18:42.386]  - attr(*, "total_size")= num 3656
[16:18:42.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.386]  - attr(*, "already-done")= logi TRUE
[16:18:42.391] - reassign environment for ‘...future.FUN’
[16:18:42.391] - copied ‘...future.FUN’ to environment
[16:18:42.392] - copied ‘MoreArgs’ to environment
[16:18:42.392] - copied ‘...future.elements_ii’ to environment
[16:18:42.392] - copied ‘...future.seeds_ii’ to environment
[16:18:42.392] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.392] assign_globals() ... done
[16:18:42.392] requestCore(): workers = 2
[16:18:42.395] MulticoreFuture started
[16:18:42.395] - Launch lazy future ... done
[16:18:42.395] run() for ‘MulticoreFuture’ ... done
[16:18:42.396] Created future:
[16:18:42.396] plan(): Setting new future strategy stack:
[16:18:42.396] List of future strategies:
[16:18:42.396] 1. sequential:
[16:18:42.396]    - args: function (..., envir = parent.frame())
[16:18:42.396]    - tweaked: FALSE
[16:18:42.396]    - call: NULL
[16:18:42.397] plan(): nbrOfWorkers() = 1
[16:18:42.399] plan(): Setting new future strategy stack:
[16:18:42.399] List of future strategies:
[16:18:42.399] 1. multicore:
[16:18:42.399]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.399]    - tweaked: FALSE
[16:18:42.399]    - call: plan(strategy)
[16:18:42.405] plan(): nbrOfWorkers() = 2
[16:18:42.396] MulticoreFuture:
[16:18:42.396] Label: ‘future_mapply-1’
[16:18:42.396] Expression:
[16:18:42.396] {
[16:18:42.396]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.396]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.396]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.396]         on.exit(options(oopts), add = TRUE)
[16:18:42.396]     }
[16:18:42.396]     {
[16:18:42.396]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.396]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.396]         do.call(mapply, args = args)
[16:18:42.396]     }
[16:18:42.396] }
[16:18:42.396] Lazy evaluation: FALSE
[16:18:42.396] Asynchronous evaluation: TRUE
[16:18:42.396] Local evaluation: TRUE
[16:18:42.396] Environment: R_GlobalEnv
[16:18:42.396] Capture standard output: TRUE
[16:18:42.396] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.396] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.396] Packages: <none>
[16:18:42.396] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.396] Resolved: TRUE
[16:18:42.396] Value: <not collected>
[16:18:42.396] Conditions captured: <none>
[16:18:42.396] Early signaling: FALSE
[16:18:42.396] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.396] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.406] Chunk #1 of 2 ... DONE
[16:18:42.406] Chunk #2 of 2 ...
[16:18:42.406]  - Finding globals in '...' for chunk #2 ...
[16:18:42.407] getGlobalsAndPackages() ...
[16:18:42.407] Searching for globals...
[16:18:42.407] 
[16:18:42.408] Searching for globals ... DONE
[16:18:42.408] - globals: [0] <none>
[16:18:42.408] getGlobalsAndPackages() ... DONE
[16:18:42.408]    + additional globals found: [n=0] 
[16:18:42.408]    + additional namespaces needed: [n=0] 
[16:18:42.408]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:42.408]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:42.413]  - seeds: <none>
[16:18:42.413]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.414] getGlobalsAndPackages() ...
[16:18:42.414] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.414] Resolving globals: FALSE
[16:18:42.416] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[16:18:42.418] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:42.418] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.418] 
[16:18:42.419] getGlobalsAndPackages() ... DONE
[16:18:42.419] run() for ‘Future’ ...
[16:18:42.420] - state: ‘created’
[16:18:42.420] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.426] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.426] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.427]   - Field: ‘label’
[16:18:42.427]   - Field: ‘local’
[16:18:42.427]   - Field: ‘owner’
[16:18:42.427]   - Field: ‘envir’
[16:18:42.428]   - Field: ‘workers’
[16:18:42.428]   - Field: ‘packages’
[16:18:42.428]   - Field: ‘gc’
[16:18:42.428]   - Field: ‘job’
[16:18:42.428]   - Field: ‘conditions’
[16:18:42.428]   - Field: ‘expr’
[16:18:42.429]   - Field: ‘uuid’
[16:18:42.429]   - Field: ‘seed’
[16:18:42.429]   - Field: ‘version’
[16:18:42.429]   - Field: ‘result’
[16:18:42.429]   - Field: ‘asynchronous’
[16:18:42.429]   - Field: ‘calls’
[16:18:42.429]   - Field: ‘globals’
[16:18:42.430]   - Field: ‘stdout’
[16:18:42.430]   - Field: ‘earlySignal’
[16:18:42.430]   - Field: ‘lazy’
[16:18:42.430]   - Field: ‘state’
[16:18:42.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.430] - Launch lazy future ...
[16:18:42.431] Packages needed by the future expression (n = 0): <none>
[16:18:42.431] Packages needed by future strategies (n = 0): <none>
[16:18:42.432] {
[16:18:42.432]     {
[16:18:42.432]         {
[16:18:42.432]             ...future.startTime <- base::Sys.time()
[16:18:42.432]             {
[16:18:42.432]                 {
[16:18:42.432]                   {
[16:18:42.432]                     {
[16:18:42.432]                       base::local({
[16:18:42.432]                         has_future <- base::requireNamespace("future", 
[16:18:42.432]                           quietly = TRUE)
[16:18:42.432]                         if (has_future) {
[16:18:42.432]                           ns <- base::getNamespace("future")
[16:18:42.432]                           version <- ns[[".package"]][["version"]]
[16:18:42.432]                           if (is.null(version)) 
[16:18:42.432]                             version <- utils::packageVersion("future")
[16:18:42.432]                         }
[16:18:42.432]                         else {
[16:18:42.432]                           version <- NULL
[16:18:42.432]                         }
[16:18:42.432]                         if (!has_future || version < "1.8.0") {
[16:18:42.432]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.432]                             "", base::R.version$version.string), 
[16:18:42.432]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.432]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.432]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.432]                               "release", "version")], collapse = " "), 
[16:18:42.432]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.432]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.432]                             info)
[16:18:42.432]                           info <- base::paste(info, collapse = "; ")
[16:18:42.432]                           if (!has_future) {
[16:18:42.432]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.432]                               info)
[16:18:42.432]                           }
[16:18:42.432]                           else {
[16:18:42.432]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.432]                               info, version)
[16:18:42.432]                           }
[16:18:42.432]                           base::stop(msg)
[16:18:42.432]                         }
[16:18:42.432]                       })
[16:18:42.432]                     }
[16:18:42.432]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.432]                     base::options(mc.cores = 1L)
[16:18:42.432]                   }
[16:18:42.432]                   ...future.strategy.old <- future::plan("list")
[16:18:42.432]                   options(future.plan = NULL)
[16:18:42.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.432]                 }
[16:18:42.432]                 ...future.workdir <- getwd()
[16:18:42.432]             }
[16:18:42.432]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.432]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.432]         }
[16:18:42.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.432]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:42.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.432]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.432]             base::names(...future.oldOptions))
[16:18:42.432]     }
[16:18:42.432]     if (FALSE) {
[16:18:42.432]     }
[16:18:42.432]     else {
[16:18:42.432]         if (TRUE) {
[16:18:42.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.432]                 open = "w")
[16:18:42.432]         }
[16:18:42.432]         else {
[16:18:42.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.432]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.432]         }
[16:18:42.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.432]             base::sink(type = "output", split = FALSE)
[16:18:42.432]             base::close(...future.stdout)
[16:18:42.432]         }, add = TRUE)
[16:18:42.432]     }
[16:18:42.432]     ...future.frame <- base::sys.nframe()
[16:18:42.432]     ...future.conditions <- base::list()
[16:18:42.432]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.432]     if (FALSE) {
[16:18:42.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.432]     }
[16:18:42.432]     ...future.result <- base::tryCatch({
[16:18:42.432]         base::withCallingHandlers({
[16:18:42.432]             ...future.value <- base::withVisible(base::local({
[16:18:42.432]                 withCallingHandlers({
[16:18:42.432]                   {
[16:18:42.432]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.432]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.432]                       ...future.globals.maxSize)) {
[16:18:42.432]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.432]                       on.exit(options(oopts), add = TRUE)
[16:18:42.432]                     }
[16:18:42.432]                     {
[16:18:42.432]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.432]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.432]                         USE.NAMES = FALSE)
[16:18:42.432]                       do.call(mapply, args = args)
[16:18:42.432]                     }
[16:18:42.432]                   }
[16:18:42.432]                 }, immediateCondition = function(cond) {
[16:18:42.432]                   save_rds <- function (object, pathname, ...) 
[16:18:42.432]                   {
[16:18:42.432]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.432]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.432]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.432]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.432]                         fi_tmp[["mtime"]])
[16:18:42.432]                     }
[16:18:42.432]                     tryCatch({
[16:18:42.432]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.432]                     }, error = function(ex) {
[16:18:42.432]                       msg <- conditionMessage(ex)
[16:18:42.432]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.432]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.432]                         fi_tmp[["mtime"]], msg)
[16:18:42.432]                       ex$message <- msg
[16:18:42.432]                       stop(ex)
[16:18:42.432]                     })
[16:18:42.432]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.432]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.432]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.432]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.432]                       fi <- file.info(pathname)
[16:18:42.432]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.432]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.432]                         fi[["size"]], fi[["mtime"]])
[16:18:42.432]                       stop(msg)
[16:18:42.432]                     }
[16:18:42.432]                     invisible(pathname)
[16:18:42.432]                   }
[16:18:42.432]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.432]                     rootPath = tempdir()) 
[16:18:42.432]                   {
[16:18:42.432]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.432]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.432]                       tmpdir = path, fileext = ".rds")
[16:18:42.432]                     save_rds(obj, file)
[16:18:42.432]                   }
[16:18:42.432]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.432]                   {
[16:18:42.432]                     inherits <- base::inherits
[16:18:42.432]                     invokeRestart <- base::invokeRestart
[16:18:42.432]                     is.null <- base::is.null
[16:18:42.432]                     muffled <- FALSE
[16:18:42.432]                     if (inherits(cond, "message")) {
[16:18:42.432]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.432]                       if (muffled) 
[16:18:42.432]                         invokeRestart("muffleMessage")
[16:18:42.432]                     }
[16:18:42.432]                     else if (inherits(cond, "warning")) {
[16:18:42.432]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.432]                       if (muffled) 
[16:18:42.432]                         invokeRestart("muffleWarning")
[16:18:42.432]                     }
[16:18:42.432]                     else if (inherits(cond, "condition")) {
[16:18:42.432]                       if (!is.null(pattern)) {
[16:18:42.432]                         computeRestarts <- base::computeRestarts
[16:18:42.432]                         grepl <- base::grepl
[16:18:42.432]                         restarts <- computeRestarts(cond)
[16:18:42.432]                         for (restart in restarts) {
[16:18:42.432]                           name <- restart$name
[16:18:42.432]                           if (is.null(name)) 
[16:18:42.432]                             next
[16:18:42.432]                           if (!grepl(pattern, name)) 
[16:18:42.432]                             next
[16:18:42.432]                           invokeRestart(restart)
[16:18:42.432]                           muffled <- TRUE
[16:18:42.432]                           break
[16:18:42.432]                         }
[16:18:42.432]                       }
[16:18:42.432]                     }
[16:18:42.432]                     invisible(muffled)
[16:18:42.432]                   }
[16:18:42.432]                   muffleCondition(cond)
[16:18:42.432]                 })
[16:18:42.432]             }))
[16:18:42.432]             future::FutureResult(value = ...future.value$value, 
[16:18:42.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.432]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.432]                     ...future.globalenv.names))
[16:18:42.432]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.432]         }, condition = base::local({
[16:18:42.432]             c <- base::c
[16:18:42.432]             inherits <- base::inherits
[16:18:42.432]             invokeRestart <- base::invokeRestart
[16:18:42.432]             length <- base::length
[16:18:42.432]             list <- base::list
[16:18:42.432]             seq.int <- base::seq.int
[16:18:42.432]             signalCondition <- base::signalCondition
[16:18:42.432]             sys.calls <- base::sys.calls
[16:18:42.432]             `[[` <- base::`[[`
[16:18:42.432]             `+` <- base::`+`
[16:18:42.432]             `<<-` <- base::`<<-`
[16:18:42.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.432]                   3L)]
[16:18:42.432]             }
[16:18:42.432]             function(cond) {
[16:18:42.432]                 is_error <- inherits(cond, "error")
[16:18:42.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.432]                   NULL)
[16:18:42.432]                 if (is_error) {
[16:18:42.432]                   sessionInformation <- function() {
[16:18:42.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.432]                       search = base::search(), system = base::Sys.info())
[16:18:42.432]                   }
[16:18:42.432]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.432]                     cond$call), session = sessionInformation(), 
[16:18:42.432]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.432]                   signalCondition(cond)
[16:18:42.432]                 }
[16:18:42.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.432]                 "immediateCondition"))) {
[16:18:42.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.432]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.432]                   if (TRUE && !signal) {
[16:18:42.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.432]                     {
[16:18:42.432]                       inherits <- base::inherits
[16:18:42.432]                       invokeRestart <- base::invokeRestart
[16:18:42.432]                       is.null <- base::is.null
[16:18:42.432]                       muffled <- FALSE
[16:18:42.432]                       if (inherits(cond, "message")) {
[16:18:42.432]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.432]                         if (muffled) 
[16:18:42.432]                           invokeRestart("muffleMessage")
[16:18:42.432]                       }
[16:18:42.432]                       else if (inherits(cond, "warning")) {
[16:18:42.432]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.432]                         if (muffled) 
[16:18:42.432]                           invokeRestart("muffleWarning")
[16:18:42.432]                       }
[16:18:42.432]                       else if (inherits(cond, "condition")) {
[16:18:42.432]                         if (!is.null(pattern)) {
[16:18:42.432]                           computeRestarts <- base::computeRestarts
[16:18:42.432]                           grepl <- base::grepl
[16:18:42.432]                           restarts <- computeRestarts(cond)
[16:18:42.432]                           for (restart in restarts) {
[16:18:42.432]                             name <- restart$name
[16:18:42.432]                             if (is.null(name)) 
[16:18:42.432]                               next
[16:18:42.432]                             if (!grepl(pattern, name)) 
[16:18:42.432]                               next
[16:18:42.432]                             invokeRestart(restart)
[16:18:42.432]                             muffled <- TRUE
[16:18:42.432]                             break
[16:18:42.432]                           }
[16:18:42.432]                         }
[16:18:42.432]                       }
[16:18:42.432]                       invisible(muffled)
[16:18:42.432]                     }
[16:18:42.432]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.432]                   }
[16:18:42.432]                 }
[16:18:42.432]                 else {
[16:18:42.432]                   if (TRUE) {
[16:18:42.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.432]                     {
[16:18:42.432]                       inherits <- base::inherits
[16:18:42.432]                       invokeRestart <- base::invokeRestart
[16:18:42.432]                       is.null <- base::is.null
[16:18:42.432]                       muffled <- FALSE
[16:18:42.432]                       if (inherits(cond, "message")) {
[16:18:42.432]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.432]                         if (muffled) 
[16:18:42.432]                           invokeRestart("muffleMessage")
[16:18:42.432]                       }
[16:18:42.432]                       else if (inherits(cond, "warning")) {
[16:18:42.432]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.432]                         if (muffled) 
[16:18:42.432]                           invokeRestart("muffleWarning")
[16:18:42.432]                       }
[16:18:42.432]                       else if (inherits(cond, "condition")) {
[16:18:42.432]                         if (!is.null(pattern)) {
[16:18:42.432]                           computeRestarts <- base::computeRestarts
[16:18:42.432]                           grepl <- base::grepl
[16:18:42.432]                           restarts <- computeRestarts(cond)
[16:18:42.432]                           for (restart in restarts) {
[16:18:42.432]                             name <- restart$name
[16:18:42.432]                             if (is.null(name)) 
[16:18:42.432]                               next
[16:18:42.432]                             if (!grepl(pattern, name)) 
[16:18:42.432]                               next
[16:18:42.432]                             invokeRestart(restart)
[16:18:42.432]                             muffled <- TRUE
[16:18:42.432]                             break
[16:18:42.432]                           }
[16:18:42.432]                         }
[16:18:42.432]                       }
[16:18:42.432]                       invisible(muffled)
[16:18:42.432]                     }
[16:18:42.432]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.432]                   }
[16:18:42.432]                 }
[16:18:42.432]             }
[16:18:42.432]         }))
[16:18:42.432]     }, error = function(ex) {
[16:18:42.432]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.432]                 ...future.rng), started = ...future.startTime, 
[16:18:42.432]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.432]             version = "1.8"), class = "FutureResult")
[16:18:42.432]     }, finally = {
[16:18:42.432]         if (!identical(...future.workdir, getwd())) 
[16:18:42.432]             setwd(...future.workdir)
[16:18:42.432]         {
[16:18:42.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.432]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.432]             }
[16:18:42.432]             base::options(...future.oldOptions)
[16:18:42.432]             if (.Platform$OS.type == "windows") {
[16:18:42.432]                 old_names <- names(...future.oldEnvVars)
[16:18:42.432]                 envs <- base::Sys.getenv()
[16:18:42.432]                 names <- names(envs)
[16:18:42.432]                 common <- intersect(names, old_names)
[16:18:42.432]                 added <- setdiff(names, old_names)
[16:18:42.432]                 removed <- setdiff(old_names, names)
[16:18:42.432]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.432]                   envs[common]]
[16:18:42.432]                 NAMES <- toupper(changed)
[16:18:42.432]                 args <- list()
[16:18:42.432]                 for (kk in seq_along(NAMES)) {
[16:18:42.432]                   name <- changed[[kk]]
[16:18:42.432]                   NAME <- NAMES[[kk]]
[16:18:42.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.432]                     next
[16:18:42.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.432]                 }
[16:18:42.432]                 NAMES <- toupper(added)
[16:18:42.432]                 for (kk in seq_along(NAMES)) {
[16:18:42.432]                   name <- added[[kk]]
[16:18:42.432]                   NAME <- NAMES[[kk]]
[16:18:42.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.432]                     next
[16:18:42.432]                   args[[name]] <- ""
[16:18:42.432]                 }
[16:18:42.432]                 NAMES <- toupper(removed)
[16:18:42.432]                 for (kk in seq_along(NAMES)) {
[16:18:42.432]                   name <- removed[[kk]]
[16:18:42.432]                   NAME <- NAMES[[kk]]
[16:18:42.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.432]                     next
[16:18:42.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.432]                 }
[16:18:42.432]                 if (length(args) > 0) 
[16:18:42.432]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.432]             }
[16:18:42.432]             else {
[16:18:42.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.432]             }
[16:18:42.432]             {
[16:18:42.432]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.432]                   0L) {
[16:18:42.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.432]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.432]                   base::options(opts)
[16:18:42.432]                 }
[16:18:42.432]                 {
[16:18:42.432]                   {
[16:18:42.432]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.432]                     NULL
[16:18:42.432]                   }
[16:18:42.432]                   options(future.plan = NULL)
[16:18:42.432]                   if (is.na(NA_character_)) 
[16:18:42.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.432]                     .init = FALSE)
[16:18:42.432]                 }
[16:18:42.432]             }
[16:18:42.432]         }
[16:18:42.432]     })
[16:18:42.432]     if (TRUE) {
[16:18:42.432]         base::sink(type = "output", split = FALSE)
[16:18:42.432]         if (TRUE) {
[16:18:42.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.432]         }
[16:18:42.432]         else {
[16:18:42.432]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.432]         }
[16:18:42.432]         base::close(...future.stdout)
[16:18:42.432]         ...future.stdout <- NULL
[16:18:42.432]     }
[16:18:42.432]     ...future.result$conditions <- ...future.conditions
[16:18:42.432]     ...future.result$finished <- base::Sys.time()
[16:18:42.432]     ...future.result
[16:18:42.432] }
[16:18:42.435] assign_globals() ...
[16:18:42.435] List of 5
[16:18:42.435]  $ ...future.FUN            :function (C, k)  
[16:18:42.435]  $ MoreArgs                 : NULL
[16:18:42.435]  $ ...future.elements_ii    :List of 2
[16:18:42.435]   ..$ :List of 3
[16:18:42.435]   .. ..$ : chr "C"
[16:18:42.435]   .. ..$ : chr "B"
[16:18:42.435]   .. ..$ : chr "A"
[16:18:42.435]   ..$ :List of 3
[16:18:42.435]   .. ..$ : int 3
[16:18:42.435]   .. ..$ : int 4
[16:18:42.435]   .. ..$ : int 5
[16:18:42.435]  $ ...future.seeds_ii       : NULL
[16:18:42.435]  $ ...future.globals.maxSize: NULL
[16:18:42.435]  - attr(*, "where")=List of 5
[16:18:42.435]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.435]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.435]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.435]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.435]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.435]  - attr(*, "resolved")= logi FALSE
[16:18:42.435]  - attr(*, "total_size")= num 3824
[16:18:42.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.435]  - attr(*, "already-done")= logi TRUE
[16:18:42.443] - reassign environment for ‘...future.FUN’
[16:18:42.443] - copied ‘...future.FUN’ to environment
[16:18:42.443] - copied ‘MoreArgs’ to environment
[16:18:42.443] - copied ‘...future.elements_ii’ to environment
[16:18:42.444] - copied ‘...future.seeds_ii’ to environment
[16:18:42.444] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.444] assign_globals() ... done
[16:18:42.444] requestCore(): workers = 2
[16:18:42.446] MulticoreFuture started
[16:18:42.447] - Launch lazy future ... done
[16:18:42.447] run() for ‘MulticoreFuture’ ... done
[16:18:42.447] Created future:
[16:18:42.448] plan(): Setting new future strategy stack:
[16:18:42.448] List of future strategies:
[16:18:42.448] 1. sequential:
[16:18:42.448]    - args: function (..., envir = parent.frame())
[16:18:42.448]    - tweaked: FALSE
[16:18:42.448]    - call: NULL
[16:18:42.449] plan(): nbrOfWorkers() = 1
[16:18:42.451] plan(): Setting new future strategy stack:
[16:18:42.451] List of future strategies:
[16:18:42.451] 1. multicore:
[16:18:42.451]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.451]    - tweaked: FALSE
[16:18:42.451]    - call: plan(strategy)
[16:18:42.448] MulticoreFuture:
[16:18:42.448] Label: ‘future_mapply-2’
[16:18:42.448] Expression:
[16:18:42.448] {
[16:18:42.448]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.448]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.448]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.448]         on.exit(options(oopts), add = TRUE)
[16:18:42.448]     }
[16:18:42.448]     {
[16:18:42.448]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.448]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.448]         do.call(mapply, args = args)
[16:18:42.448]     }
[16:18:42.448] }
[16:18:42.448] Lazy evaluation: FALSE
[16:18:42.448] Asynchronous evaluation: TRUE
[16:18:42.448] Local evaluation: TRUE
[16:18:42.448] Environment: R_GlobalEnv
[16:18:42.448] Capture standard output: TRUE
[16:18:42.448] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.448] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.448] Packages: <none>
[16:18:42.448] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.448] Resolved: FALSE
[16:18:42.448] Value: <not collected>
[16:18:42.448] Conditions captured: <none>
[16:18:42.448] Early signaling: FALSE
[16:18:42.448] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.448] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.460] Chunk #2 of 2 ... DONE
[16:18:42.460] Launching 2 futures (chunks) ... DONE
[16:18:42.461] Resolving 2 futures (chunks) ...
[16:18:42.461] resolve() on list ...
[16:18:42.461]  recursive: 0
[16:18:42.461]  length: 2
[16:18:42.461] 
[16:18:42.461] plan(): nbrOfWorkers() = 2
[16:18:42.462] Future #1
[16:18:42.462] result() for MulticoreFuture ...
[16:18:42.463] result() for MulticoreFuture ...
[16:18:42.463] result() for MulticoreFuture ... done
[16:18:42.466] result() for MulticoreFuture ... done
[16:18:42.466] result() for MulticoreFuture ...
[16:18:42.467] result() for MulticoreFuture ... done
[16:18:42.467] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:42.467] - nx: 2
[16:18:42.468] - relay: TRUE
[16:18:42.468] - stdout: TRUE
[16:18:42.469] - signal: TRUE
[16:18:42.469] - resignal: FALSE
[16:18:42.469] - force: TRUE
[16:18:42.469] - relayed: [n=2] FALSE, FALSE
[16:18:42.470] - queued futures: [n=2] FALSE, FALSE
[16:18:42.470]  - until=1
[16:18:42.470]  - relaying element #1
[16:18:42.471] result() for MulticoreFuture ...
[16:18:42.471] result() for MulticoreFuture ... done
[16:18:42.471] result() for MulticoreFuture ...
[16:18:42.471] result() for MulticoreFuture ... done
[16:18:42.472] result() for MulticoreFuture ...
[16:18:42.472] result() for MulticoreFuture ... done
[16:18:42.472] result() for MulticoreFuture ...
[16:18:42.473] result() for MulticoreFuture ... done
[16:18:42.473] - relayed: [n=2] TRUE, FALSE
[16:18:42.473] - queued futures: [n=2] TRUE, FALSE
[16:18:42.473] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:42.473]  length: 1 (resolved future 1)
[16:18:42.474] Future #2
[16:18:42.474] result() for MulticoreFuture ...
[16:18:42.475] result() for MulticoreFuture ...
[16:18:42.476] result() for MulticoreFuture ... done
[16:18:42.476] result() for MulticoreFuture ... done
[16:18:42.476] result() for MulticoreFuture ...
[16:18:42.476] result() for MulticoreFuture ... done
[16:18:42.477] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:42.477] - nx: 2
[16:18:42.477] - relay: TRUE
[16:18:42.477] - stdout: TRUE
[16:18:42.477] - signal: TRUE
[16:18:42.477] - resignal: FALSE
[16:18:42.478] - force: TRUE
[16:18:42.478] - relayed: [n=2] TRUE, FALSE
[16:18:42.478] - queued futures: [n=2] TRUE, FALSE
[16:18:42.478]  - until=2
[16:18:42.478]  - relaying element #2
[16:18:42.478] result() for MulticoreFuture ...
[16:18:42.478] result() for MulticoreFuture ... done
[16:18:42.478] result() for MulticoreFuture ...
[16:18:42.479] result() for MulticoreFuture ... done
[16:18:42.479] result() for MulticoreFuture ...
[16:18:42.479] result() for MulticoreFuture ... done
[16:18:42.479] result() for MulticoreFuture ...
[16:18:42.479] result() for MulticoreFuture ... done
[16:18:42.479] - relayed: [n=2] TRUE, TRUE
[16:18:42.479] - queued futures: [n=2] TRUE, TRUE
[16:18:42.479] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:42.480]  length: 0 (resolved future 2)
[16:18:42.480] Relaying remaining futures
[16:18:42.480] signalConditionsASAP(NULL, pos=0) ...
[16:18:42.480] - nx: 2
[16:18:42.480] - relay: TRUE
[16:18:42.480] - stdout: TRUE
[16:18:42.480] - signal: TRUE
[16:18:42.480] - resignal: FALSE
[16:18:42.480] - force: TRUE
[16:18:42.481] - relayed: [n=2] TRUE, TRUE
[16:18:42.481] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:42.481] - relayed: [n=2] TRUE, TRUE
[16:18:42.481] - queued futures: [n=2] TRUE, TRUE
[16:18:42.481] signalConditionsASAP(NULL, pos=0) ... done
[16:18:42.481] resolve() on list ... DONE
[16:18:42.481] result() for MulticoreFuture ...
[16:18:42.481] result() for MulticoreFuture ... done
[16:18:42.482] result() for MulticoreFuture ...
[16:18:42.482] result() for MulticoreFuture ... done
[16:18:42.482] result() for MulticoreFuture ...
[16:18:42.482] result() for MulticoreFuture ... done
[16:18:42.482] result() for MulticoreFuture ...
[16:18:42.482] result() for MulticoreFuture ... done
[16:18:42.482]  - Number of value chunks collected: 2
[16:18:42.482] Resolving 2 futures (chunks) ... DONE
[16:18:42.483] Reducing values from 2 chunks ...
[16:18:42.483]  - Number of values collected after concatenation: 5
[16:18:42.483]  - Number of values expected: 5
[16:18:42.483] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[16:18:42.483] Reducing values from 2 chunks ... DONE
[16:18:42.483] future_mapply() ... DONE
[16:18:42.483] future_mapply() ...
[16:18:42.488] Number of chunks: 2
[16:18:42.488] getGlobalsAndPackagesXApply() ...
[16:18:42.488]  - future.globals: TRUE
[16:18:42.488] getGlobalsAndPackages() ...
[16:18:42.488] Searching for globals...
[16:18:42.490] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:42.490] Searching for globals ... DONE
[16:18:42.490] Resolving globals: FALSE
[16:18:42.491] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:42.491] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:42.491] - globals: [1] ‘FUN’
[16:18:42.491] 
[16:18:42.491] getGlobalsAndPackages() ... DONE
[16:18:42.491]  - globals found/used: [n=1] ‘FUN’
[16:18:42.492]  - needed namespaces: [n=0] 
[16:18:42.492] Finding globals ... DONE
[16:18:42.492] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:42.492] List of 2
[16:18:42.492]  $ ...future.FUN:function (C, k)  
[16:18:42.492]  $ MoreArgs     : list()
[16:18:42.492]  - attr(*, "where")=List of 2
[16:18:42.492]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:42.492]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:42.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.492]  - attr(*, "resolved")= logi FALSE
[16:18:42.492]  - attr(*, "total_size")= num NA
[16:18:42.495] Packages to be attached in all futures: [n=0] 
[16:18:42.495] getGlobalsAndPackagesXApply() ... DONE
[16:18:42.495] Number of futures (= number of chunks): 2
[16:18:42.495] Launching 2 futures (chunks) ...
[16:18:42.495] Chunk #1 of 2 ...
[16:18:42.495]  - Finding globals in '...' for chunk #1 ...
[16:18:42.496] getGlobalsAndPackages() ...
[16:18:42.498] Searching for globals...
[16:18:42.499] 
[16:18:42.499] Searching for globals ... DONE
[16:18:42.499] - globals: [0] <none>
[16:18:42.499] getGlobalsAndPackages() ... DONE
[16:18:42.499]    + additional globals found: [n=0] 
[16:18:42.499]    + additional namespaces needed: [n=0] 
[16:18:42.499]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:42.499]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:42.500]  - seeds: <none>
[16:18:42.500]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.500] getGlobalsAndPackages() ...
[16:18:42.500] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.500] Resolving globals: FALSE
[16:18:42.501] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:42.501] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:42.501] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.502] 
[16:18:42.502] getGlobalsAndPackages() ... DONE
[16:18:42.502] run() for ‘Future’ ...
[16:18:42.502] - state: ‘created’
[16:18:42.502] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.506] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.506] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.507]   - Field: ‘label’
[16:18:42.507]   - Field: ‘local’
[16:18:42.507]   - Field: ‘owner’
[16:18:42.507]   - Field: ‘envir’
[16:18:42.507]   - Field: ‘workers’
[16:18:42.507]   - Field: ‘packages’
[16:18:42.507]   - Field: ‘gc’
[16:18:42.507]   - Field: ‘job’
[16:18:42.507]   - Field: ‘conditions’
[16:18:42.507]   - Field: ‘expr’
[16:18:42.508]   - Field: ‘uuid’
[16:18:42.508]   - Field: ‘seed’
[16:18:42.508]   - Field: ‘version’
[16:18:42.508]   - Field: ‘result’
[16:18:42.508]   - Field: ‘asynchronous’
[16:18:42.508]   - Field: ‘calls’
[16:18:42.508]   - Field: ‘globals’
[16:18:42.508]   - Field: ‘stdout’
[16:18:42.508]   - Field: ‘earlySignal’
[16:18:42.508]   - Field: ‘lazy’
[16:18:42.509]   - Field: ‘state’
[16:18:42.509] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.509] - Launch lazy future ...
[16:18:42.509] Packages needed by the future expression (n = 0): <none>
[16:18:42.509] Packages needed by future strategies (n = 0): <none>
[16:18:42.510] {
[16:18:42.510]     {
[16:18:42.510]         {
[16:18:42.510]             ...future.startTime <- base::Sys.time()
[16:18:42.510]             {
[16:18:42.510]                 {
[16:18:42.510]                   {
[16:18:42.510]                     {
[16:18:42.510]                       base::local({
[16:18:42.510]                         has_future <- base::requireNamespace("future", 
[16:18:42.510]                           quietly = TRUE)
[16:18:42.510]                         if (has_future) {
[16:18:42.510]                           ns <- base::getNamespace("future")
[16:18:42.510]                           version <- ns[[".package"]][["version"]]
[16:18:42.510]                           if (is.null(version)) 
[16:18:42.510]                             version <- utils::packageVersion("future")
[16:18:42.510]                         }
[16:18:42.510]                         else {
[16:18:42.510]                           version <- NULL
[16:18:42.510]                         }
[16:18:42.510]                         if (!has_future || version < "1.8.0") {
[16:18:42.510]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.510]                             "", base::R.version$version.string), 
[16:18:42.510]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.510]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.510]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.510]                               "release", "version")], collapse = " "), 
[16:18:42.510]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.510]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.510]                             info)
[16:18:42.510]                           info <- base::paste(info, collapse = "; ")
[16:18:42.510]                           if (!has_future) {
[16:18:42.510]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.510]                               info)
[16:18:42.510]                           }
[16:18:42.510]                           else {
[16:18:42.510]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.510]                               info, version)
[16:18:42.510]                           }
[16:18:42.510]                           base::stop(msg)
[16:18:42.510]                         }
[16:18:42.510]                       })
[16:18:42.510]                     }
[16:18:42.510]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.510]                     base::options(mc.cores = 1L)
[16:18:42.510]                   }
[16:18:42.510]                   ...future.strategy.old <- future::plan("list")
[16:18:42.510]                   options(future.plan = NULL)
[16:18:42.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.510]                 }
[16:18:42.510]                 ...future.workdir <- getwd()
[16:18:42.510]             }
[16:18:42.510]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.510]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.510]         }
[16:18:42.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.510]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:42.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.510]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.510]             base::names(...future.oldOptions))
[16:18:42.510]     }
[16:18:42.510]     if (FALSE) {
[16:18:42.510]     }
[16:18:42.510]     else {
[16:18:42.510]         if (TRUE) {
[16:18:42.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.510]                 open = "w")
[16:18:42.510]         }
[16:18:42.510]         else {
[16:18:42.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.510]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.510]         }
[16:18:42.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.510]             base::sink(type = "output", split = FALSE)
[16:18:42.510]             base::close(...future.stdout)
[16:18:42.510]         }, add = TRUE)
[16:18:42.510]     }
[16:18:42.510]     ...future.frame <- base::sys.nframe()
[16:18:42.510]     ...future.conditions <- base::list()
[16:18:42.510]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.510]     if (FALSE) {
[16:18:42.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.510]     }
[16:18:42.510]     ...future.result <- base::tryCatch({
[16:18:42.510]         base::withCallingHandlers({
[16:18:42.510]             ...future.value <- base::withVisible(base::local({
[16:18:42.510]                 withCallingHandlers({
[16:18:42.510]                   {
[16:18:42.510]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.510]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.510]                       ...future.globals.maxSize)) {
[16:18:42.510]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.510]                       on.exit(options(oopts), add = TRUE)
[16:18:42.510]                     }
[16:18:42.510]                     {
[16:18:42.510]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.510]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.510]                         USE.NAMES = FALSE)
[16:18:42.510]                       do.call(mapply, args = args)
[16:18:42.510]                     }
[16:18:42.510]                   }
[16:18:42.510]                 }, immediateCondition = function(cond) {
[16:18:42.510]                   save_rds <- function (object, pathname, ...) 
[16:18:42.510]                   {
[16:18:42.510]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.510]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.510]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.510]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.510]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.510]                         fi_tmp[["mtime"]])
[16:18:42.510]                     }
[16:18:42.510]                     tryCatch({
[16:18:42.510]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.510]                     }, error = function(ex) {
[16:18:42.510]                       msg <- conditionMessage(ex)
[16:18:42.510]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.510]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.510]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.510]                         fi_tmp[["mtime"]], msg)
[16:18:42.510]                       ex$message <- msg
[16:18:42.510]                       stop(ex)
[16:18:42.510]                     })
[16:18:42.510]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.510]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.510]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.510]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.510]                       fi <- file.info(pathname)
[16:18:42.510]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.510]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.510]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.510]                         fi[["size"]], fi[["mtime"]])
[16:18:42.510]                       stop(msg)
[16:18:42.510]                     }
[16:18:42.510]                     invisible(pathname)
[16:18:42.510]                   }
[16:18:42.510]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.510]                     rootPath = tempdir()) 
[16:18:42.510]                   {
[16:18:42.510]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.510]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.510]                       tmpdir = path, fileext = ".rds")
[16:18:42.510]                     save_rds(obj, file)
[16:18:42.510]                   }
[16:18:42.510]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.510]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.510]                   {
[16:18:42.510]                     inherits <- base::inherits
[16:18:42.510]                     invokeRestart <- base::invokeRestart
[16:18:42.510]                     is.null <- base::is.null
[16:18:42.510]                     muffled <- FALSE
[16:18:42.510]                     if (inherits(cond, "message")) {
[16:18:42.510]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.510]                       if (muffled) 
[16:18:42.510]                         invokeRestart("muffleMessage")
[16:18:42.510]                     }
[16:18:42.510]                     else if (inherits(cond, "warning")) {
[16:18:42.510]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.510]                       if (muffled) 
[16:18:42.510]                         invokeRestart("muffleWarning")
[16:18:42.510]                     }
[16:18:42.510]                     else if (inherits(cond, "condition")) {
[16:18:42.510]                       if (!is.null(pattern)) {
[16:18:42.510]                         computeRestarts <- base::computeRestarts
[16:18:42.510]                         grepl <- base::grepl
[16:18:42.510]                         restarts <- computeRestarts(cond)
[16:18:42.510]                         for (restart in restarts) {
[16:18:42.510]                           name <- restart$name
[16:18:42.510]                           if (is.null(name)) 
[16:18:42.510]                             next
[16:18:42.510]                           if (!grepl(pattern, name)) 
[16:18:42.510]                             next
[16:18:42.510]                           invokeRestart(restart)
[16:18:42.510]                           muffled <- TRUE
[16:18:42.510]                           break
[16:18:42.510]                         }
[16:18:42.510]                       }
[16:18:42.510]                     }
[16:18:42.510]                     invisible(muffled)
[16:18:42.510]                   }
[16:18:42.510]                   muffleCondition(cond)
[16:18:42.510]                 })
[16:18:42.510]             }))
[16:18:42.510]             future::FutureResult(value = ...future.value$value, 
[16:18:42.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.510]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.510]                     ...future.globalenv.names))
[16:18:42.510]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.510]         }, condition = base::local({
[16:18:42.510]             c <- base::c
[16:18:42.510]             inherits <- base::inherits
[16:18:42.510]             invokeRestart <- base::invokeRestart
[16:18:42.510]             length <- base::length
[16:18:42.510]             list <- base::list
[16:18:42.510]             seq.int <- base::seq.int
[16:18:42.510]             signalCondition <- base::signalCondition
[16:18:42.510]             sys.calls <- base::sys.calls
[16:18:42.510]             `[[` <- base::`[[`
[16:18:42.510]             `+` <- base::`+`
[16:18:42.510]             `<<-` <- base::`<<-`
[16:18:42.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.510]                   3L)]
[16:18:42.510]             }
[16:18:42.510]             function(cond) {
[16:18:42.510]                 is_error <- inherits(cond, "error")
[16:18:42.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.510]                   NULL)
[16:18:42.510]                 if (is_error) {
[16:18:42.510]                   sessionInformation <- function() {
[16:18:42.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.510]                       search = base::search(), system = base::Sys.info())
[16:18:42.510]                   }
[16:18:42.510]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.510]                     cond$call), session = sessionInformation(), 
[16:18:42.510]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.510]                   signalCondition(cond)
[16:18:42.510]                 }
[16:18:42.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.510]                 "immediateCondition"))) {
[16:18:42.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.510]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.510]                   if (TRUE && !signal) {
[16:18:42.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.510]                     {
[16:18:42.510]                       inherits <- base::inherits
[16:18:42.510]                       invokeRestart <- base::invokeRestart
[16:18:42.510]                       is.null <- base::is.null
[16:18:42.510]                       muffled <- FALSE
[16:18:42.510]                       if (inherits(cond, "message")) {
[16:18:42.510]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.510]                         if (muffled) 
[16:18:42.510]                           invokeRestart("muffleMessage")
[16:18:42.510]                       }
[16:18:42.510]                       else if (inherits(cond, "warning")) {
[16:18:42.510]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.510]                         if (muffled) 
[16:18:42.510]                           invokeRestart("muffleWarning")
[16:18:42.510]                       }
[16:18:42.510]                       else if (inherits(cond, "condition")) {
[16:18:42.510]                         if (!is.null(pattern)) {
[16:18:42.510]                           computeRestarts <- base::computeRestarts
[16:18:42.510]                           grepl <- base::grepl
[16:18:42.510]                           restarts <- computeRestarts(cond)
[16:18:42.510]                           for (restart in restarts) {
[16:18:42.510]                             name <- restart$name
[16:18:42.510]                             if (is.null(name)) 
[16:18:42.510]                               next
[16:18:42.510]                             if (!grepl(pattern, name)) 
[16:18:42.510]                               next
[16:18:42.510]                             invokeRestart(restart)
[16:18:42.510]                             muffled <- TRUE
[16:18:42.510]                             break
[16:18:42.510]                           }
[16:18:42.510]                         }
[16:18:42.510]                       }
[16:18:42.510]                       invisible(muffled)
[16:18:42.510]                     }
[16:18:42.510]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.510]                   }
[16:18:42.510]                 }
[16:18:42.510]                 else {
[16:18:42.510]                   if (TRUE) {
[16:18:42.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.510]                     {
[16:18:42.510]                       inherits <- base::inherits
[16:18:42.510]                       invokeRestart <- base::invokeRestart
[16:18:42.510]                       is.null <- base::is.null
[16:18:42.510]                       muffled <- FALSE
[16:18:42.510]                       if (inherits(cond, "message")) {
[16:18:42.510]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.510]                         if (muffled) 
[16:18:42.510]                           invokeRestart("muffleMessage")
[16:18:42.510]                       }
[16:18:42.510]                       else if (inherits(cond, "warning")) {
[16:18:42.510]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.510]                         if (muffled) 
[16:18:42.510]                           invokeRestart("muffleWarning")
[16:18:42.510]                       }
[16:18:42.510]                       else if (inherits(cond, "condition")) {
[16:18:42.510]                         if (!is.null(pattern)) {
[16:18:42.510]                           computeRestarts <- base::computeRestarts
[16:18:42.510]                           grepl <- base::grepl
[16:18:42.510]                           restarts <- computeRestarts(cond)
[16:18:42.510]                           for (restart in restarts) {
[16:18:42.510]                             name <- restart$name
[16:18:42.510]                             if (is.null(name)) 
[16:18:42.510]                               next
[16:18:42.510]                             if (!grepl(pattern, name)) 
[16:18:42.510]                               next
[16:18:42.510]                             invokeRestart(restart)
[16:18:42.510]                             muffled <- TRUE
[16:18:42.510]                             break
[16:18:42.510]                           }
[16:18:42.510]                         }
[16:18:42.510]                       }
[16:18:42.510]                       invisible(muffled)
[16:18:42.510]                     }
[16:18:42.510]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.510]                   }
[16:18:42.510]                 }
[16:18:42.510]             }
[16:18:42.510]         }))
[16:18:42.510]     }, error = function(ex) {
[16:18:42.510]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.510]                 ...future.rng), started = ...future.startTime, 
[16:18:42.510]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.510]             version = "1.8"), class = "FutureResult")
[16:18:42.510]     }, finally = {
[16:18:42.510]         if (!identical(...future.workdir, getwd())) 
[16:18:42.510]             setwd(...future.workdir)
[16:18:42.510]         {
[16:18:42.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.510]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.510]             }
[16:18:42.510]             base::options(...future.oldOptions)
[16:18:42.510]             if (.Platform$OS.type == "windows") {
[16:18:42.510]                 old_names <- names(...future.oldEnvVars)
[16:18:42.510]                 envs <- base::Sys.getenv()
[16:18:42.510]                 names <- names(envs)
[16:18:42.510]                 common <- intersect(names, old_names)
[16:18:42.510]                 added <- setdiff(names, old_names)
[16:18:42.510]                 removed <- setdiff(old_names, names)
[16:18:42.510]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.510]                   envs[common]]
[16:18:42.510]                 NAMES <- toupper(changed)
[16:18:42.510]                 args <- list()
[16:18:42.510]                 for (kk in seq_along(NAMES)) {
[16:18:42.510]                   name <- changed[[kk]]
[16:18:42.510]                   NAME <- NAMES[[kk]]
[16:18:42.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.510]                     next
[16:18:42.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.510]                 }
[16:18:42.510]                 NAMES <- toupper(added)
[16:18:42.510]                 for (kk in seq_along(NAMES)) {
[16:18:42.510]                   name <- added[[kk]]
[16:18:42.510]                   NAME <- NAMES[[kk]]
[16:18:42.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.510]                     next
[16:18:42.510]                   args[[name]] <- ""
[16:18:42.510]                 }
[16:18:42.510]                 NAMES <- toupper(removed)
[16:18:42.510]                 for (kk in seq_along(NAMES)) {
[16:18:42.510]                   name <- removed[[kk]]
[16:18:42.510]                   NAME <- NAMES[[kk]]
[16:18:42.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.510]                     next
[16:18:42.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.510]                 }
[16:18:42.510]                 if (length(args) > 0) 
[16:18:42.510]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.510]             }
[16:18:42.510]             else {
[16:18:42.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.510]             }
[16:18:42.510]             {
[16:18:42.510]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.510]                   0L) {
[16:18:42.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.510]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.510]                   base::options(opts)
[16:18:42.510]                 }
[16:18:42.510]                 {
[16:18:42.510]                   {
[16:18:42.510]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.510]                     NULL
[16:18:42.510]                   }
[16:18:42.510]                   options(future.plan = NULL)
[16:18:42.510]                   if (is.na(NA_character_)) 
[16:18:42.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.510]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.510]                     .init = FALSE)
[16:18:42.510]                 }
[16:18:42.510]             }
[16:18:42.510]         }
[16:18:42.510]     })
[16:18:42.510]     if (TRUE) {
[16:18:42.510]         base::sink(type = "output", split = FALSE)
[16:18:42.510]         if (TRUE) {
[16:18:42.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.510]         }
[16:18:42.510]         else {
[16:18:42.510]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.510]         }
[16:18:42.510]         base::close(...future.stdout)
[16:18:42.510]         ...future.stdout <- NULL
[16:18:42.510]     }
[16:18:42.510]     ...future.result$conditions <- ...future.conditions
[16:18:42.510]     ...future.result$finished <- base::Sys.time()
[16:18:42.510]     ...future.result
[16:18:42.510] }
[16:18:42.512] assign_globals() ...
[16:18:42.512] List of 5
[16:18:42.512]  $ ...future.FUN            :function (C, k)  
[16:18:42.512]  $ MoreArgs                 : list()
[16:18:42.512]  $ ...future.elements_ii    :List of 2
[16:18:42.512]   ..$ :List of 2
[16:18:42.512]   .. ..$ : chr "A"
[16:18:42.512]   .. ..$ : chr "B"
[16:18:42.512]   ..$ :List of 2
[16:18:42.512]   .. ..$ : int 5
[16:18:42.512]   .. ..$ : int 4
[16:18:42.512]  $ ...future.seeds_ii       : NULL
[16:18:42.512]  $ ...future.globals.maxSize: NULL
[16:18:42.512]  - attr(*, "where")=List of 5
[16:18:42.512]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.512]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.512]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.512]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.512]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.512]  - attr(*, "resolved")= logi FALSE
[16:18:42.512]  - attr(*, "total_size")= num 3656
[16:18:42.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.512]  - attr(*, "already-done")= logi TRUE
[16:18:42.518] - reassign environment for ‘...future.FUN’
[16:18:42.518] - copied ‘...future.FUN’ to environment
[16:18:42.518] - copied ‘MoreArgs’ to environment
[16:18:42.518] - copied ‘...future.elements_ii’ to environment
[16:18:42.518] - copied ‘...future.seeds_ii’ to environment
[16:18:42.518] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.519] assign_globals() ... done
[16:18:42.519] requestCore(): workers = 2
[16:18:42.521] MulticoreFuture started
[16:18:42.521] - Launch lazy future ... done
[16:18:42.522] run() for ‘MulticoreFuture’ ... done
[16:18:42.522] Created future:
[16:18:42.522] plan(): Setting new future strategy stack:
[16:18:42.522] List of future strategies:
[16:18:42.522] 1. sequential:
[16:18:42.522]    - args: function (..., envir = parent.frame())
[16:18:42.522]    - tweaked: FALSE
[16:18:42.522]    - call: NULL
[16:18:42.523] plan(): nbrOfWorkers() = 1
[16:18:42.525] plan(): Setting new future strategy stack:
[16:18:42.525] List of future strategies:
[16:18:42.525] 1. multicore:
[16:18:42.525]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.525]    - tweaked: FALSE
[16:18:42.525]    - call: plan(strategy)
[16:18:42.522] MulticoreFuture:
[16:18:42.522] Label: ‘future_.mapply-1’
[16:18:42.522] Expression:
[16:18:42.522] {
[16:18:42.522]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.522]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.522]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.522]         on.exit(options(oopts), add = TRUE)
[16:18:42.522]     }
[16:18:42.522]     {
[16:18:42.522]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.522]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.522]         do.call(mapply, args = args)
[16:18:42.522]     }
[16:18:42.522] }
[16:18:42.522] Lazy evaluation: FALSE
[16:18:42.522] Asynchronous evaluation: TRUE
[16:18:42.522] Local evaluation: TRUE
[16:18:42.522] Environment: R_GlobalEnv
[16:18:42.522] Capture standard output: TRUE
[16:18:42.522] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.522] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.522] Packages: <none>
[16:18:42.522] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.522] Resolved: FALSE
[16:18:42.522] Value: <not collected>
[16:18:42.522] Conditions captured: <none>
[16:18:42.522] Early signaling: FALSE
[16:18:42.522] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.522] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.535] Chunk #1 of 2 ... DONE
[16:18:42.535] Chunk #2 of 2 ...
[16:18:42.535]  - Finding globals in '...' for chunk #2 ...
[16:18:42.535] getGlobalsAndPackages() ...
[16:18:42.536] Searching for globals...
[16:18:42.542] plan(): nbrOfWorkers() = 2
[16:18:42.543] 
[16:18:42.543] Searching for globals ... DONE
[16:18:42.543] - globals: [0] <none>
[16:18:42.543] getGlobalsAndPackages() ... DONE
[16:18:42.543]    + additional globals found: [n=0] 
[16:18:42.544]    + additional namespaces needed: [n=0] 
[16:18:42.544]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:42.544]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:42.544]  - seeds: <none>
[16:18:42.544]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.544] getGlobalsAndPackages() ...
[16:18:42.544] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.545] Resolving globals: FALSE
[16:18:42.546] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[16:18:42.547] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:42.547] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.547] 
[16:18:42.547] getGlobalsAndPackages() ... DONE
[16:18:42.548] run() for ‘Future’ ...
[16:18:42.548] - state: ‘created’
[16:18:42.549] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.554] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.554] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.554]   - Field: ‘label’
[16:18:42.555]   - Field: ‘local’
[16:18:42.555]   - Field: ‘owner’
[16:18:42.555]   - Field: ‘envir’
[16:18:42.555]   - Field: ‘workers’
[16:18:42.555]   - Field: ‘packages’
[16:18:42.556]   - Field: ‘gc’
[16:18:42.556]   - Field: ‘job’
[16:18:42.556]   - Field: ‘conditions’
[16:18:42.556]   - Field: ‘expr’
[16:18:42.556]   - Field: ‘uuid’
[16:18:42.557]   - Field: ‘seed’
[16:18:42.557]   - Field: ‘version’
[16:18:42.557]   - Field: ‘result’
[16:18:42.557]   - Field: ‘asynchronous’
[16:18:42.557]   - Field: ‘calls’
[16:18:42.557]   - Field: ‘globals’
[16:18:42.557]   - Field: ‘stdout’
[16:18:42.557]   - Field: ‘earlySignal’
[16:18:42.558]   - Field: ‘lazy’
[16:18:42.558]   - Field: ‘state’
[16:18:42.558] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.558] - Launch lazy future ...
[16:18:42.558] Packages needed by the future expression (n = 0): <none>
[16:18:42.559] Packages needed by future strategies (n = 0): <none>
[16:18:42.560] {
[16:18:42.560]     {
[16:18:42.560]         {
[16:18:42.560]             ...future.startTime <- base::Sys.time()
[16:18:42.560]             {
[16:18:42.560]                 {
[16:18:42.560]                   {
[16:18:42.560]                     {
[16:18:42.560]                       base::local({
[16:18:42.560]                         has_future <- base::requireNamespace("future", 
[16:18:42.560]                           quietly = TRUE)
[16:18:42.560]                         if (has_future) {
[16:18:42.560]                           ns <- base::getNamespace("future")
[16:18:42.560]                           version <- ns[[".package"]][["version"]]
[16:18:42.560]                           if (is.null(version)) 
[16:18:42.560]                             version <- utils::packageVersion("future")
[16:18:42.560]                         }
[16:18:42.560]                         else {
[16:18:42.560]                           version <- NULL
[16:18:42.560]                         }
[16:18:42.560]                         if (!has_future || version < "1.8.0") {
[16:18:42.560]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.560]                             "", base::R.version$version.string), 
[16:18:42.560]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.560]                               "release", "version")], collapse = " "), 
[16:18:42.560]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.560]                             info)
[16:18:42.560]                           info <- base::paste(info, collapse = "; ")
[16:18:42.560]                           if (!has_future) {
[16:18:42.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.560]                               info)
[16:18:42.560]                           }
[16:18:42.560]                           else {
[16:18:42.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.560]                               info, version)
[16:18:42.560]                           }
[16:18:42.560]                           base::stop(msg)
[16:18:42.560]                         }
[16:18:42.560]                       })
[16:18:42.560]                     }
[16:18:42.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.560]                     base::options(mc.cores = 1L)
[16:18:42.560]                   }
[16:18:42.560]                   ...future.strategy.old <- future::plan("list")
[16:18:42.560]                   options(future.plan = NULL)
[16:18:42.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.560]                 }
[16:18:42.560]                 ...future.workdir <- getwd()
[16:18:42.560]             }
[16:18:42.560]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.560]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.560]         }
[16:18:42.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.560]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:42.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.560]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.560]             base::names(...future.oldOptions))
[16:18:42.560]     }
[16:18:42.560]     if (FALSE) {
[16:18:42.560]     }
[16:18:42.560]     else {
[16:18:42.560]         if (TRUE) {
[16:18:42.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.560]                 open = "w")
[16:18:42.560]         }
[16:18:42.560]         else {
[16:18:42.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.560]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.560]         }
[16:18:42.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.560]             base::sink(type = "output", split = FALSE)
[16:18:42.560]             base::close(...future.stdout)
[16:18:42.560]         }, add = TRUE)
[16:18:42.560]     }
[16:18:42.560]     ...future.frame <- base::sys.nframe()
[16:18:42.560]     ...future.conditions <- base::list()
[16:18:42.560]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.560]     if (FALSE) {
[16:18:42.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.560]     }
[16:18:42.560]     ...future.result <- base::tryCatch({
[16:18:42.560]         base::withCallingHandlers({
[16:18:42.560]             ...future.value <- base::withVisible(base::local({
[16:18:42.560]                 withCallingHandlers({
[16:18:42.560]                   {
[16:18:42.560]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.560]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.560]                       ...future.globals.maxSize)) {
[16:18:42.560]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.560]                       on.exit(options(oopts), add = TRUE)
[16:18:42.560]                     }
[16:18:42.560]                     {
[16:18:42.560]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.560]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.560]                         USE.NAMES = FALSE)
[16:18:42.560]                       do.call(mapply, args = args)
[16:18:42.560]                     }
[16:18:42.560]                   }
[16:18:42.560]                 }, immediateCondition = function(cond) {
[16:18:42.560]                   save_rds <- function (object, pathname, ...) 
[16:18:42.560]                   {
[16:18:42.560]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.560]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.560]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.560]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.560]                         fi_tmp[["mtime"]])
[16:18:42.560]                     }
[16:18:42.560]                     tryCatch({
[16:18:42.560]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.560]                     }, error = function(ex) {
[16:18:42.560]                       msg <- conditionMessage(ex)
[16:18:42.560]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.560]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.560]                         fi_tmp[["mtime"]], msg)
[16:18:42.560]                       ex$message <- msg
[16:18:42.560]                       stop(ex)
[16:18:42.560]                     })
[16:18:42.560]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.560]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.560]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.560]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.560]                       fi <- file.info(pathname)
[16:18:42.560]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.560]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.560]                         fi[["size"]], fi[["mtime"]])
[16:18:42.560]                       stop(msg)
[16:18:42.560]                     }
[16:18:42.560]                     invisible(pathname)
[16:18:42.560]                   }
[16:18:42.560]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.560]                     rootPath = tempdir()) 
[16:18:42.560]                   {
[16:18:42.560]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.560]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.560]                       tmpdir = path, fileext = ".rds")
[16:18:42.560]                     save_rds(obj, file)
[16:18:42.560]                   }
[16:18:42.560]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.560]                   {
[16:18:42.560]                     inherits <- base::inherits
[16:18:42.560]                     invokeRestart <- base::invokeRestart
[16:18:42.560]                     is.null <- base::is.null
[16:18:42.560]                     muffled <- FALSE
[16:18:42.560]                     if (inherits(cond, "message")) {
[16:18:42.560]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.560]                       if (muffled) 
[16:18:42.560]                         invokeRestart("muffleMessage")
[16:18:42.560]                     }
[16:18:42.560]                     else if (inherits(cond, "warning")) {
[16:18:42.560]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.560]                       if (muffled) 
[16:18:42.560]                         invokeRestart("muffleWarning")
[16:18:42.560]                     }
[16:18:42.560]                     else if (inherits(cond, "condition")) {
[16:18:42.560]                       if (!is.null(pattern)) {
[16:18:42.560]                         computeRestarts <- base::computeRestarts
[16:18:42.560]                         grepl <- base::grepl
[16:18:42.560]                         restarts <- computeRestarts(cond)
[16:18:42.560]                         for (restart in restarts) {
[16:18:42.560]                           name <- restart$name
[16:18:42.560]                           if (is.null(name)) 
[16:18:42.560]                             next
[16:18:42.560]                           if (!grepl(pattern, name)) 
[16:18:42.560]                             next
[16:18:42.560]                           invokeRestart(restart)
[16:18:42.560]                           muffled <- TRUE
[16:18:42.560]                           break
[16:18:42.560]                         }
[16:18:42.560]                       }
[16:18:42.560]                     }
[16:18:42.560]                     invisible(muffled)
[16:18:42.560]                   }
[16:18:42.560]                   muffleCondition(cond)
[16:18:42.560]                 })
[16:18:42.560]             }))
[16:18:42.560]             future::FutureResult(value = ...future.value$value, 
[16:18:42.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.560]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.560]                     ...future.globalenv.names))
[16:18:42.560]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.560]         }, condition = base::local({
[16:18:42.560]             c <- base::c
[16:18:42.560]             inherits <- base::inherits
[16:18:42.560]             invokeRestart <- base::invokeRestart
[16:18:42.560]             length <- base::length
[16:18:42.560]             list <- base::list
[16:18:42.560]             seq.int <- base::seq.int
[16:18:42.560]             signalCondition <- base::signalCondition
[16:18:42.560]             sys.calls <- base::sys.calls
[16:18:42.560]             `[[` <- base::`[[`
[16:18:42.560]             `+` <- base::`+`
[16:18:42.560]             `<<-` <- base::`<<-`
[16:18:42.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.560]                   3L)]
[16:18:42.560]             }
[16:18:42.560]             function(cond) {
[16:18:42.560]                 is_error <- inherits(cond, "error")
[16:18:42.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.560]                   NULL)
[16:18:42.560]                 if (is_error) {
[16:18:42.560]                   sessionInformation <- function() {
[16:18:42.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.560]                       search = base::search(), system = base::Sys.info())
[16:18:42.560]                   }
[16:18:42.560]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.560]                     cond$call), session = sessionInformation(), 
[16:18:42.560]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.560]                   signalCondition(cond)
[16:18:42.560]                 }
[16:18:42.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.560]                 "immediateCondition"))) {
[16:18:42.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.560]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.560]                   if (TRUE && !signal) {
[16:18:42.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.560]                     {
[16:18:42.560]                       inherits <- base::inherits
[16:18:42.560]                       invokeRestart <- base::invokeRestart
[16:18:42.560]                       is.null <- base::is.null
[16:18:42.560]                       muffled <- FALSE
[16:18:42.560]                       if (inherits(cond, "message")) {
[16:18:42.560]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.560]                         if (muffled) 
[16:18:42.560]                           invokeRestart("muffleMessage")
[16:18:42.560]                       }
[16:18:42.560]                       else if (inherits(cond, "warning")) {
[16:18:42.560]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.560]                         if (muffled) 
[16:18:42.560]                           invokeRestart("muffleWarning")
[16:18:42.560]                       }
[16:18:42.560]                       else if (inherits(cond, "condition")) {
[16:18:42.560]                         if (!is.null(pattern)) {
[16:18:42.560]                           computeRestarts <- base::computeRestarts
[16:18:42.560]                           grepl <- base::grepl
[16:18:42.560]                           restarts <- computeRestarts(cond)
[16:18:42.560]                           for (restart in restarts) {
[16:18:42.560]                             name <- restart$name
[16:18:42.560]                             if (is.null(name)) 
[16:18:42.560]                               next
[16:18:42.560]                             if (!grepl(pattern, name)) 
[16:18:42.560]                               next
[16:18:42.560]                             invokeRestart(restart)
[16:18:42.560]                             muffled <- TRUE
[16:18:42.560]                             break
[16:18:42.560]                           }
[16:18:42.560]                         }
[16:18:42.560]                       }
[16:18:42.560]                       invisible(muffled)
[16:18:42.560]                     }
[16:18:42.560]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.560]                   }
[16:18:42.560]                 }
[16:18:42.560]                 else {
[16:18:42.560]                   if (TRUE) {
[16:18:42.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.560]                     {
[16:18:42.560]                       inherits <- base::inherits
[16:18:42.560]                       invokeRestart <- base::invokeRestart
[16:18:42.560]                       is.null <- base::is.null
[16:18:42.560]                       muffled <- FALSE
[16:18:42.560]                       if (inherits(cond, "message")) {
[16:18:42.560]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.560]                         if (muffled) 
[16:18:42.560]                           invokeRestart("muffleMessage")
[16:18:42.560]                       }
[16:18:42.560]                       else if (inherits(cond, "warning")) {
[16:18:42.560]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.560]                         if (muffled) 
[16:18:42.560]                           invokeRestart("muffleWarning")
[16:18:42.560]                       }
[16:18:42.560]                       else if (inherits(cond, "condition")) {
[16:18:42.560]                         if (!is.null(pattern)) {
[16:18:42.560]                           computeRestarts <- base::computeRestarts
[16:18:42.560]                           grepl <- base::grepl
[16:18:42.560]                           restarts <- computeRestarts(cond)
[16:18:42.560]                           for (restart in restarts) {
[16:18:42.560]                             name <- restart$name
[16:18:42.560]                             if (is.null(name)) 
[16:18:42.560]                               next
[16:18:42.560]                             if (!grepl(pattern, name)) 
[16:18:42.560]                               next
[16:18:42.560]                             invokeRestart(restart)
[16:18:42.560]                             muffled <- TRUE
[16:18:42.560]                             break
[16:18:42.560]                           }
[16:18:42.560]                         }
[16:18:42.560]                       }
[16:18:42.560]                       invisible(muffled)
[16:18:42.560]                     }
[16:18:42.560]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.560]                   }
[16:18:42.560]                 }
[16:18:42.560]             }
[16:18:42.560]         }))
[16:18:42.560]     }, error = function(ex) {
[16:18:42.560]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.560]                 ...future.rng), started = ...future.startTime, 
[16:18:42.560]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.560]             version = "1.8"), class = "FutureResult")
[16:18:42.560]     }, finally = {
[16:18:42.560]         if (!identical(...future.workdir, getwd())) 
[16:18:42.560]             setwd(...future.workdir)
[16:18:42.560]         {
[16:18:42.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.560]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.560]             }
[16:18:42.560]             base::options(...future.oldOptions)
[16:18:42.560]             if (.Platform$OS.type == "windows") {
[16:18:42.560]                 old_names <- names(...future.oldEnvVars)
[16:18:42.560]                 envs <- base::Sys.getenv()
[16:18:42.560]                 names <- names(envs)
[16:18:42.560]                 common <- intersect(names, old_names)
[16:18:42.560]                 added <- setdiff(names, old_names)
[16:18:42.560]                 removed <- setdiff(old_names, names)
[16:18:42.560]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.560]                   envs[common]]
[16:18:42.560]                 NAMES <- toupper(changed)
[16:18:42.560]                 args <- list()
[16:18:42.560]                 for (kk in seq_along(NAMES)) {
[16:18:42.560]                   name <- changed[[kk]]
[16:18:42.560]                   NAME <- NAMES[[kk]]
[16:18:42.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.560]                     next
[16:18:42.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.560]                 }
[16:18:42.560]                 NAMES <- toupper(added)
[16:18:42.560]                 for (kk in seq_along(NAMES)) {
[16:18:42.560]                   name <- added[[kk]]
[16:18:42.560]                   NAME <- NAMES[[kk]]
[16:18:42.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.560]                     next
[16:18:42.560]                   args[[name]] <- ""
[16:18:42.560]                 }
[16:18:42.560]                 NAMES <- toupper(removed)
[16:18:42.560]                 for (kk in seq_along(NAMES)) {
[16:18:42.560]                   name <- removed[[kk]]
[16:18:42.560]                   NAME <- NAMES[[kk]]
[16:18:42.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.560]                     next
[16:18:42.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.560]                 }
[16:18:42.560]                 if (length(args) > 0) 
[16:18:42.560]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.560]             }
[16:18:42.560]             else {
[16:18:42.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.560]             }
[16:18:42.560]             {
[16:18:42.560]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.560]                   0L) {
[16:18:42.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.560]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.560]                   base::options(opts)
[16:18:42.560]                 }
[16:18:42.560]                 {
[16:18:42.560]                   {
[16:18:42.560]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.560]                     NULL
[16:18:42.560]                   }
[16:18:42.560]                   options(future.plan = NULL)
[16:18:42.560]                   if (is.na(NA_character_)) 
[16:18:42.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.560]                     .init = FALSE)
[16:18:42.560]                 }
[16:18:42.560]             }
[16:18:42.560]         }
[16:18:42.560]     })
[16:18:42.560]     if (TRUE) {
[16:18:42.560]         base::sink(type = "output", split = FALSE)
[16:18:42.560]         if (TRUE) {
[16:18:42.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.560]         }
[16:18:42.560]         else {
[16:18:42.560]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.560]         }
[16:18:42.560]         base::close(...future.stdout)
[16:18:42.560]         ...future.stdout <- NULL
[16:18:42.560]     }
[16:18:42.560]     ...future.result$conditions <- ...future.conditions
[16:18:42.560]     ...future.result$finished <- base::Sys.time()
[16:18:42.560]     ...future.result
[16:18:42.560] }
[16:18:42.562] assign_globals() ...
[16:18:42.562] List of 5
[16:18:42.562]  $ ...future.FUN            :function (C, k)  
[16:18:42.562]  $ MoreArgs                 : list()
[16:18:42.562]  $ ...future.elements_ii    :List of 2
[16:18:42.562]   ..$ :List of 3
[16:18:42.562]   .. ..$ : chr "C"
[16:18:42.562]   .. ..$ : chr "D"
[16:18:42.562]   .. ..$ : chr "E"
[16:18:42.562]   ..$ :List of 3
[16:18:42.562]   .. ..$ : int 3
[16:18:42.562]   .. ..$ : int 2
[16:18:42.562]   .. ..$ : int 1
[16:18:42.562]  $ ...future.seeds_ii       : NULL
[16:18:42.562]  $ ...future.globals.maxSize: NULL
[16:18:42.562]  - attr(*, "where")=List of 5
[16:18:42.562]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.562]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.562]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.562]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.562]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.562]  - attr(*, "resolved")= logi FALSE
[16:18:42.562]  - attr(*, "total_size")= num 3824
[16:18:42.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.562]  - attr(*, "already-done")= logi TRUE
[16:18:42.570] - reassign environment for ‘...future.FUN’
[16:18:42.570] - copied ‘...future.FUN’ to environment
[16:18:42.570] - copied ‘MoreArgs’ to environment
[16:18:42.570] - copied ‘...future.elements_ii’ to environment
[16:18:42.571] - copied ‘...future.seeds_ii’ to environment
[16:18:42.571] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.571] assign_globals() ... done
[16:18:42.571] requestCore(): workers = 2
[16:18:42.573] MulticoreFuture started
[16:18:42.574] - Launch lazy future ... done
[16:18:42.574] run() for ‘MulticoreFuture’ ... done
[16:18:42.574] Created future:
[16:18:42.574] plan(): Setting new future strategy stack:
[16:18:42.575] List of future strategies:
[16:18:42.575] 1. sequential:
[16:18:42.575]    - args: function (..., envir = parent.frame())
[16:18:42.575]    - tweaked: FALSE
[16:18:42.575]    - call: NULL
[16:18:42.576] plan(): nbrOfWorkers() = 1
[16:18:42.578] plan(): Setting new future strategy stack:
[16:18:42.578] List of future strategies:
[16:18:42.578] 1. multicore:
[16:18:42.578]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.578]    - tweaked: FALSE
[16:18:42.578]    - call: plan(strategy)
[16:18:42.583] plan(): nbrOfWorkers() = 2
[16:18:42.575] MulticoreFuture:
[16:18:42.575] Label: ‘future_.mapply-2’
[16:18:42.575] Expression:
[16:18:42.575] {
[16:18:42.575]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.575]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.575]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.575]         on.exit(options(oopts), add = TRUE)
[16:18:42.575]     }
[16:18:42.575]     {
[16:18:42.575]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.575]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.575]         do.call(mapply, args = args)
[16:18:42.575]     }
[16:18:42.575] }
[16:18:42.575] Lazy evaluation: FALSE
[16:18:42.575] Asynchronous evaluation: TRUE
[16:18:42.575] Local evaluation: TRUE
[16:18:42.575] Environment: R_GlobalEnv
[16:18:42.575] Capture standard output: TRUE
[16:18:42.575] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.575] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.575] Packages: <none>
[16:18:42.575] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.575] Resolved: TRUE
[16:18:42.575] Value: <not collected>
[16:18:42.575] Conditions captured: <none>
[16:18:42.575] Early signaling: FALSE
[16:18:42.575] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.575] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.584] Chunk #2 of 2 ... DONE
[16:18:42.584] Launching 2 futures (chunks) ... DONE
[16:18:42.584] Resolving 2 futures (chunks) ...
[16:18:42.585] resolve() on list ...
[16:18:42.585]  recursive: 0
[16:18:42.585]  length: 2
[16:18:42.585] 
[16:18:42.585] Future #1
[16:18:42.586] result() for MulticoreFuture ...
[16:18:42.587] result() for MulticoreFuture ...
[16:18:42.587] result() for MulticoreFuture ... done
[16:18:42.587] result() for MulticoreFuture ... done
[16:18:42.587] result() for MulticoreFuture ...
[16:18:42.591] result() for MulticoreFuture ... done
[16:18:42.592] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:42.592] - nx: 2
[16:18:42.593] - relay: TRUE
[16:18:42.593] - stdout: TRUE
[16:18:42.593] - signal: TRUE
[16:18:42.594] - resignal: FALSE
[16:18:42.594] - force: TRUE
[16:18:42.594] - relayed: [n=2] FALSE, FALSE
[16:18:42.594] - queued futures: [n=2] FALSE, FALSE
[16:18:42.595]  - until=1
[16:18:42.595]  - relaying element #1
[16:18:42.595] result() for MulticoreFuture ...
[16:18:42.596] result() for MulticoreFuture ... done
[16:18:42.596] result() for MulticoreFuture ...
[16:18:42.596] result() for MulticoreFuture ... done
[16:18:42.597] result() for MulticoreFuture ...
[16:18:42.597] result() for MulticoreFuture ... done
[16:18:42.597] result() for MulticoreFuture ...
[16:18:42.597] result() for MulticoreFuture ... done
[16:18:42.597] - relayed: [n=2] TRUE, FALSE
[16:18:42.598] - queued futures: [n=2] TRUE, FALSE
[16:18:42.598] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:42.598]  length: 1 (resolved future 1)
[16:18:42.599] Future #2
[16:18:42.599] result() for MulticoreFuture ...
[16:18:42.600] result() for MulticoreFuture ...
[16:18:42.600] result() for MulticoreFuture ... done
[16:18:42.600] result() for MulticoreFuture ... done
[16:18:42.601] result() for MulticoreFuture ...
[16:18:42.601] result() for MulticoreFuture ... done
[16:18:42.601] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:42.601] - nx: 2
[16:18:42.601] - relay: TRUE
[16:18:42.601] - stdout: TRUE
[16:18:42.602] - signal: TRUE
[16:18:42.602] - resignal: FALSE
[16:18:42.602] - force: TRUE
[16:18:42.602] - relayed: [n=2] TRUE, FALSE
[16:18:42.602] - queued futures: [n=2] TRUE, FALSE
[16:18:42.602]  - until=2
[16:18:42.603]  - relaying element #2
[16:18:42.603] result() for MulticoreFuture ...
[16:18:42.603] result() for MulticoreFuture ... done
[16:18:42.603] result() for MulticoreFuture ...
[16:18:42.603] result() for MulticoreFuture ... done
[16:18:42.603] result() for MulticoreFuture ...
[16:18:42.603] result() for MulticoreFuture ... done
[16:18:42.604] result() for MulticoreFuture ...
[16:18:42.604] result() for MulticoreFuture ... done
[16:18:42.604] - relayed: [n=2] TRUE, TRUE
[16:18:42.604] - queued futures: [n=2] TRUE, TRUE
[16:18:42.604] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:42.604]  length: 0 (resolved future 2)
[16:18:42.604] Relaying remaining futures
[16:18:42.605] signalConditionsASAP(NULL, pos=0) ...
[16:18:42.605] - nx: 2
[16:18:42.605] - relay: TRUE
[16:18:42.605] - stdout: TRUE
[16:18:42.605] - signal: TRUE
[16:18:42.605] - resignal: FALSE
[16:18:42.605] - force: TRUE
[16:18:42.605] - relayed: [n=2] TRUE, TRUE
[16:18:42.605] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:42.606] - relayed: [n=2] TRUE, TRUE
[16:18:42.606] - queued futures: [n=2] TRUE, TRUE
[16:18:42.606] signalConditionsASAP(NULL, pos=0) ... done
[16:18:42.606] resolve() on list ... DONE
[16:18:42.606] result() for MulticoreFuture ...
[16:18:42.606] result() for MulticoreFuture ... done
[16:18:42.606] result() for MulticoreFuture ...
[16:18:42.606] result() for MulticoreFuture ... done
[16:18:42.607] result() for MulticoreFuture ...
[16:18:42.607] result() for MulticoreFuture ... done
[16:18:42.607] result() for MulticoreFuture ...
[16:18:42.607] result() for MulticoreFuture ... done
[16:18:42.607]  - Number of value chunks collected: 2
[16:18:42.607] Resolving 2 futures (chunks) ... DONE
[16:18:42.607] Reducing values from 2 chunks ...
[16:18:42.607]  - Number of values collected after concatenation: 5
[16:18:42.607]  - Number of values expected: 5
[16:18:42.608] Reducing values from 2 chunks ... DONE
[16:18:42.608] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[16:18:42.608] future_mapply() ...
[16:18:42.613] Number of chunks: 1
[16:18:42.613] getGlobalsAndPackagesXApply() ...
[16:18:42.613]  - future.globals: TRUE
[16:18:42.613] getGlobalsAndPackages() ...
[16:18:42.613] Searching for globals...
[16:18:42.615] - globals found: [1] ‘FUN’
[16:18:42.615] Searching for globals ... DONE
[16:18:42.615] Resolving globals: FALSE
[16:18:42.615] The total size of the 1 globals is 848 bytes (848 bytes)
[16:18:42.616] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:18:42.616] - globals: [1] ‘FUN’
[16:18:42.616] 
[16:18:42.616] getGlobalsAndPackages() ... DONE
[16:18:42.616]  - globals found/used: [n=1] ‘FUN’
[16:18:42.616]  - needed namespaces: [n=0] 
[16:18:42.616] Finding globals ... DONE
[16:18:42.617] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:42.617] List of 2
[16:18:42.617]  $ ...future.FUN:function (x)  
[16:18:42.617]  $ MoreArgs     : NULL
[16:18:42.617]  - attr(*, "where")=List of 2
[16:18:42.617]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:42.617]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:42.617]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.617]  - attr(*, "resolved")= logi FALSE
[16:18:42.617]  - attr(*, "total_size")= num NA
[16:18:42.620] Packages to be attached in all futures: [n=0] 
[16:18:42.620] getGlobalsAndPackagesXApply() ... DONE
[16:18:42.620] Number of futures (= number of chunks): 1
[16:18:42.620] Launching 1 futures (chunks) ...
[16:18:42.620] Chunk #1 of 1 ...
[16:18:42.620]  - Finding globals in '...' for chunk #1 ...
[16:18:42.620] getGlobalsAndPackages() ...
[16:18:42.621] Searching for globals...
[16:18:42.621] 
[16:18:42.621] Searching for globals ... DONE
[16:18:42.621] - globals: [0] <none>
[16:18:42.621] getGlobalsAndPackages() ... DONE
[16:18:42.621]    + additional globals found: [n=0] 
[16:18:42.621]    + additional namespaces needed: [n=0] 
[16:18:42.621]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:42.622]  - seeds: <none>
[16:18:42.622]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.622] getGlobalsAndPackages() ...
[16:18:42.622] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.622] Resolving globals: FALSE
[16:18:42.623] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[16:18:42.626] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:42.626] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.626] 
[16:18:42.626] getGlobalsAndPackages() ... DONE
[16:18:42.627] run() for ‘Future’ ...
[16:18:42.627] - state: ‘created’
[16:18:42.627] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.631] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.632] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.632]   - Field: ‘label’
[16:18:42.632]   - Field: ‘local’
[16:18:42.632]   - Field: ‘owner’
[16:18:42.632]   - Field: ‘envir’
[16:18:42.632]   - Field: ‘workers’
[16:18:42.633]   - Field: ‘packages’
[16:18:42.633]   - Field: ‘gc’
[16:18:42.633]   - Field: ‘job’
[16:18:42.633]   - Field: ‘conditions’
[16:18:42.633]   - Field: ‘expr’
[16:18:42.633]   - Field: ‘uuid’
[16:18:42.633]   - Field: ‘seed’
[16:18:42.633]   - Field: ‘version’
[16:18:42.634]   - Field: ‘result’
[16:18:42.634]   - Field: ‘asynchronous’
[16:18:42.634]   - Field: ‘calls’
[16:18:42.634]   - Field: ‘globals’
[16:18:42.634]   - Field: ‘stdout’
[16:18:42.634]   - Field: ‘earlySignal’
[16:18:42.634]   - Field: ‘lazy’
[16:18:42.634]   - Field: ‘state’
[16:18:42.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.635] - Launch lazy future ...
[16:18:42.635] Packages needed by the future expression (n = 0): <none>
[16:18:42.635] Packages needed by future strategies (n = 0): <none>
[16:18:42.636] {
[16:18:42.636]     {
[16:18:42.636]         {
[16:18:42.636]             ...future.startTime <- base::Sys.time()
[16:18:42.636]             {
[16:18:42.636]                 {
[16:18:42.636]                   {
[16:18:42.636]                     {
[16:18:42.636]                       base::local({
[16:18:42.636]                         has_future <- base::requireNamespace("future", 
[16:18:42.636]                           quietly = TRUE)
[16:18:42.636]                         if (has_future) {
[16:18:42.636]                           ns <- base::getNamespace("future")
[16:18:42.636]                           version <- ns[[".package"]][["version"]]
[16:18:42.636]                           if (is.null(version)) 
[16:18:42.636]                             version <- utils::packageVersion("future")
[16:18:42.636]                         }
[16:18:42.636]                         else {
[16:18:42.636]                           version <- NULL
[16:18:42.636]                         }
[16:18:42.636]                         if (!has_future || version < "1.8.0") {
[16:18:42.636]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.636]                             "", base::R.version$version.string), 
[16:18:42.636]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.636]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.636]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.636]                               "release", "version")], collapse = " "), 
[16:18:42.636]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.636]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.636]                             info)
[16:18:42.636]                           info <- base::paste(info, collapse = "; ")
[16:18:42.636]                           if (!has_future) {
[16:18:42.636]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.636]                               info)
[16:18:42.636]                           }
[16:18:42.636]                           else {
[16:18:42.636]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.636]                               info, version)
[16:18:42.636]                           }
[16:18:42.636]                           base::stop(msg)
[16:18:42.636]                         }
[16:18:42.636]                       })
[16:18:42.636]                     }
[16:18:42.636]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.636]                     base::options(mc.cores = 1L)
[16:18:42.636]                   }
[16:18:42.636]                   ...future.strategy.old <- future::plan("list")
[16:18:42.636]                   options(future.plan = NULL)
[16:18:42.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.636]                 }
[16:18:42.636]                 ...future.workdir <- getwd()
[16:18:42.636]             }
[16:18:42.636]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.636]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.636]         }
[16:18:42.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.636]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:42.636]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.636]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.636]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.636]             base::names(...future.oldOptions))
[16:18:42.636]     }
[16:18:42.636]     if (FALSE) {
[16:18:42.636]     }
[16:18:42.636]     else {
[16:18:42.636]         if (TRUE) {
[16:18:42.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.636]                 open = "w")
[16:18:42.636]         }
[16:18:42.636]         else {
[16:18:42.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.636]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.636]         }
[16:18:42.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.636]             base::sink(type = "output", split = FALSE)
[16:18:42.636]             base::close(...future.stdout)
[16:18:42.636]         }, add = TRUE)
[16:18:42.636]     }
[16:18:42.636]     ...future.frame <- base::sys.nframe()
[16:18:42.636]     ...future.conditions <- base::list()
[16:18:42.636]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.636]     if (FALSE) {
[16:18:42.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.636]     }
[16:18:42.636]     ...future.result <- base::tryCatch({
[16:18:42.636]         base::withCallingHandlers({
[16:18:42.636]             ...future.value <- base::withVisible(base::local({
[16:18:42.636]                 withCallingHandlers({
[16:18:42.636]                   {
[16:18:42.636]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.636]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.636]                       ...future.globals.maxSize)) {
[16:18:42.636]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.636]                       on.exit(options(oopts), add = TRUE)
[16:18:42.636]                     }
[16:18:42.636]                     {
[16:18:42.636]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.636]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.636]                         USE.NAMES = FALSE)
[16:18:42.636]                       do.call(mapply, args = args)
[16:18:42.636]                     }
[16:18:42.636]                   }
[16:18:42.636]                 }, immediateCondition = function(cond) {
[16:18:42.636]                   save_rds <- function (object, pathname, ...) 
[16:18:42.636]                   {
[16:18:42.636]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.636]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.636]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.636]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.636]                         fi_tmp[["mtime"]])
[16:18:42.636]                     }
[16:18:42.636]                     tryCatch({
[16:18:42.636]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.636]                     }, error = function(ex) {
[16:18:42.636]                       msg <- conditionMessage(ex)
[16:18:42.636]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.636]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.636]                         fi_tmp[["mtime"]], msg)
[16:18:42.636]                       ex$message <- msg
[16:18:42.636]                       stop(ex)
[16:18:42.636]                     })
[16:18:42.636]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.636]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.636]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.636]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.636]                       fi <- file.info(pathname)
[16:18:42.636]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.636]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.636]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.636]                         fi[["size"]], fi[["mtime"]])
[16:18:42.636]                       stop(msg)
[16:18:42.636]                     }
[16:18:42.636]                     invisible(pathname)
[16:18:42.636]                   }
[16:18:42.636]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.636]                     rootPath = tempdir()) 
[16:18:42.636]                   {
[16:18:42.636]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.636]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.636]                       tmpdir = path, fileext = ".rds")
[16:18:42.636]                     save_rds(obj, file)
[16:18:42.636]                   }
[16:18:42.636]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.636]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.636]                   {
[16:18:42.636]                     inherits <- base::inherits
[16:18:42.636]                     invokeRestart <- base::invokeRestart
[16:18:42.636]                     is.null <- base::is.null
[16:18:42.636]                     muffled <- FALSE
[16:18:42.636]                     if (inherits(cond, "message")) {
[16:18:42.636]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.636]                       if (muffled) 
[16:18:42.636]                         invokeRestart("muffleMessage")
[16:18:42.636]                     }
[16:18:42.636]                     else if (inherits(cond, "warning")) {
[16:18:42.636]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.636]                       if (muffled) 
[16:18:42.636]                         invokeRestart("muffleWarning")
[16:18:42.636]                     }
[16:18:42.636]                     else if (inherits(cond, "condition")) {
[16:18:42.636]                       if (!is.null(pattern)) {
[16:18:42.636]                         computeRestarts <- base::computeRestarts
[16:18:42.636]                         grepl <- base::grepl
[16:18:42.636]                         restarts <- computeRestarts(cond)
[16:18:42.636]                         for (restart in restarts) {
[16:18:42.636]                           name <- restart$name
[16:18:42.636]                           if (is.null(name)) 
[16:18:42.636]                             next
[16:18:42.636]                           if (!grepl(pattern, name)) 
[16:18:42.636]                             next
[16:18:42.636]                           invokeRestart(restart)
[16:18:42.636]                           muffled <- TRUE
[16:18:42.636]                           break
[16:18:42.636]                         }
[16:18:42.636]                       }
[16:18:42.636]                     }
[16:18:42.636]                     invisible(muffled)
[16:18:42.636]                   }
[16:18:42.636]                   muffleCondition(cond)
[16:18:42.636]                 })
[16:18:42.636]             }))
[16:18:42.636]             future::FutureResult(value = ...future.value$value, 
[16:18:42.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.636]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.636]                     ...future.globalenv.names))
[16:18:42.636]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.636]         }, condition = base::local({
[16:18:42.636]             c <- base::c
[16:18:42.636]             inherits <- base::inherits
[16:18:42.636]             invokeRestart <- base::invokeRestart
[16:18:42.636]             length <- base::length
[16:18:42.636]             list <- base::list
[16:18:42.636]             seq.int <- base::seq.int
[16:18:42.636]             signalCondition <- base::signalCondition
[16:18:42.636]             sys.calls <- base::sys.calls
[16:18:42.636]             `[[` <- base::`[[`
[16:18:42.636]             `+` <- base::`+`
[16:18:42.636]             `<<-` <- base::`<<-`
[16:18:42.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.636]                   3L)]
[16:18:42.636]             }
[16:18:42.636]             function(cond) {
[16:18:42.636]                 is_error <- inherits(cond, "error")
[16:18:42.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.636]                   NULL)
[16:18:42.636]                 if (is_error) {
[16:18:42.636]                   sessionInformation <- function() {
[16:18:42.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.636]                       search = base::search(), system = base::Sys.info())
[16:18:42.636]                   }
[16:18:42.636]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.636]                     cond$call), session = sessionInformation(), 
[16:18:42.636]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.636]                   signalCondition(cond)
[16:18:42.636]                 }
[16:18:42.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.636]                 "immediateCondition"))) {
[16:18:42.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.636]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.636]                   if (TRUE && !signal) {
[16:18:42.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.636]                     {
[16:18:42.636]                       inherits <- base::inherits
[16:18:42.636]                       invokeRestart <- base::invokeRestart
[16:18:42.636]                       is.null <- base::is.null
[16:18:42.636]                       muffled <- FALSE
[16:18:42.636]                       if (inherits(cond, "message")) {
[16:18:42.636]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.636]                         if (muffled) 
[16:18:42.636]                           invokeRestart("muffleMessage")
[16:18:42.636]                       }
[16:18:42.636]                       else if (inherits(cond, "warning")) {
[16:18:42.636]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.636]                         if (muffled) 
[16:18:42.636]                           invokeRestart("muffleWarning")
[16:18:42.636]                       }
[16:18:42.636]                       else if (inherits(cond, "condition")) {
[16:18:42.636]                         if (!is.null(pattern)) {
[16:18:42.636]                           computeRestarts <- base::computeRestarts
[16:18:42.636]                           grepl <- base::grepl
[16:18:42.636]                           restarts <- computeRestarts(cond)
[16:18:42.636]                           for (restart in restarts) {
[16:18:42.636]                             name <- restart$name
[16:18:42.636]                             if (is.null(name)) 
[16:18:42.636]                               next
[16:18:42.636]                             if (!grepl(pattern, name)) 
[16:18:42.636]                               next
[16:18:42.636]                             invokeRestart(restart)
[16:18:42.636]                             muffled <- TRUE
[16:18:42.636]                             break
[16:18:42.636]                           }
[16:18:42.636]                         }
[16:18:42.636]                       }
[16:18:42.636]                       invisible(muffled)
[16:18:42.636]                     }
[16:18:42.636]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.636]                   }
[16:18:42.636]                 }
[16:18:42.636]                 else {
[16:18:42.636]                   if (TRUE) {
[16:18:42.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.636]                     {
[16:18:42.636]                       inherits <- base::inherits
[16:18:42.636]                       invokeRestart <- base::invokeRestart
[16:18:42.636]                       is.null <- base::is.null
[16:18:42.636]                       muffled <- FALSE
[16:18:42.636]                       if (inherits(cond, "message")) {
[16:18:42.636]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.636]                         if (muffled) 
[16:18:42.636]                           invokeRestart("muffleMessage")
[16:18:42.636]                       }
[16:18:42.636]                       else if (inherits(cond, "warning")) {
[16:18:42.636]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.636]                         if (muffled) 
[16:18:42.636]                           invokeRestart("muffleWarning")
[16:18:42.636]                       }
[16:18:42.636]                       else if (inherits(cond, "condition")) {
[16:18:42.636]                         if (!is.null(pattern)) {
[16:18:42.636]                           computeRestarts <- base::computeRestarts
[16:18:42.636]                           grepl <- base::grepl
[16:18:42.636]                           restarts <- computeRestarts(cond)
[16:18:42.636]                           for (restart in restarts) {
[16:18:42.636]                             name <- restart$name
[16:18:42.636]                             if (is.null(name)) 
[16:18:42.636]                               next
[16:18:42.636]                             if (!grepl(pattern, name)) 
[16:18:42.636]                               next
[16:18:42.636]                             invokeRestart(restart)
[16:18:42.636]                             muffled <- TRUE
[16:18:42.636]                             break
[16:18:42.636]                           }
[16:18:42.636]                         }
[16:18:42.636]                       }
[16:18:42.636]                       invisible(muffled)
[16:18:42.636]                     }
[16:18:42.636]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.636]                   }
[16:18:42.636]                 }
[16:18:42.636]             }
[16:18:42.636]         }))
[16:18:42.636]     }, error = function(ex) {
[16:18:42.636]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.636]                 ...future.rng), started = ...future.startTime, 
[16:18:42.636]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.636]             version = "1.8"), class = "FutureResult")
[16:18:42.636]     }, finally = {
[16:18:42.636]         if (!identical(...future.workdir, getwd())) 
[16:18:42.636]             setwd(...future.workdir)
[16:18:42.636]         {
[16:18:42.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.636]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.636]             }
[16:18:42.636]             base::options(...future.oldOptions)
[16:18:42.636]             if (.Platform$OS.type == "windows") {
[16:18:42.636]                 old_names <- names(...future.oldEnvVars)
[16:18:42.636]                 envs <- base::Sys.getenv()
[16:18:42.636]                 names <- names(envs)
[16:18:42.636]                 common <- intersect(names, old_names)
[16:18:42.636]                 added <- setdiff(names, old_names)
[16:18:42.636]                 removed <- setdiff(old_names, names)
[16:18:42.636]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.636]                   envs[common]]
[16:18:42.636]                 NAMES <- toupper(changed)
[16:18:42.636]                 args <- list()
[16:18:42.636]                 for (kk in seq_along(NAMES)) {
[16:18:42.636]                   name <- changed[[kk]]
[16:18:42.636]                   NAME <- NAMES[[kk]]
[16:18:42.636]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.636]                     next
[16:18:42.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.636]                 }
[16:18:42.636]                 NAMES <- toupper(added)
[16:18:42.636]                 for (kk in seq_along(NAMES)) {
[16:18:42.636]                   name <- added[[kk]]
[16:18:42.636]                   NAME <- NAMES[[kk]]
[16:18:42.636]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.636]                     next
[16:18:42.636]                   args[[name]] <- ""
[16:18:42.636]                 }
[16:18:42.636]                 NAMES <- toupper(removed)
[16:18:42.636]                 for (kk in seq_along(NAMES)) {
[16:18:42.636]                   name <- removed[[kk]]
[16:18:42.636]                   NAME <- NAMES[[kk]]
[16:18:42.636]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.636]                     next
[16:18:42.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.636]                 }
[16:18:42.636]                 if (length(args) > 0) 
[16:18:42.636]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.636]             }
[16:18:42.636]             else {
[16:18:42.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.636]             }
[16:18:42.636]             {
[16:18:42.636]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.636]                   0L) {
[16:18:42.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.636]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.636]                   base::options(opts)
[16:18:42.636]                 }
[16:18:42.636]                 {
[16:18:42.636]                   {
[16:18:42.636]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.636]                     NULL
[16:18:42.636]                   }
[16:18:42.636]                   options(future.plan = NULL)
[16:18:42.636]                   if (is.na(NA_character_)) 
[16:18:42.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.636]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.636]                     .init = FALSE)
[16:18:42.636]                 }
[16:18:42.636]             }
[16:18:42.636]         }
[16:18:42.636]     })
[16:18:42.636]     if (TRUE) {
[16:18:42.636]         base::sink(type = "output", split = FALSE)
[16:18:42.636]         if (TRUE) {
[16:18:42.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.636]         }
[16:18:42.636]         else {
[16:18:42.636]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.636]         }
[16:18:42.636]         base::close(...future.stdout)
[16:18:42.636]         ...future.stdout <- NULL
[16:18:42.636]     }
[16:18:42.636]     ...future.result$conditions <- ...future.conditions
[16:18:42.636]     ...future.result$finished <- base::Sys.time()
[16:18:42.636]     ...future.result
[16:18:42.636] }
[16:18:42.638] assign_globals() ...
[16:18:42.638] List of 5
[16:18:42.638]  $ ...future.FUN            :function (x)  
[16:18:42.638]  $ MoreArgs                 : NULL
[16:18:42.638]  $ ...future.elements_ii    :List of 1
[16:18:42.638]   ..$ :List of 1
[16:18:42.638]   .. ..$ : Date[1:1], format: "2018-06-01"
[16:18:42.638]  $ ...future.seeds_ii       : NULL
[16:18:42.638]  $ ...future.globals.maxSize: NULL
[16:18:42.638]  - attr(*, "where")=List of 5
[16:18:42.638]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.638]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.638]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.638]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.638]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.638]  - attr(*, "resolved")= logi FALSE
[16:18:42.638]  - attr(*, "total_size")= num 1128
[16:18:42.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.638]  - attr(*, "already-done")= logi TRUE
[16:18:42.643] - copied ‘...future.FUN’ to environment
[16:18:42.643] - copied ‘MoreArgs’ to environment
[16:18:42.644] - copied ‘...future.elements_ii’ to environment
[16:18:42.644] - copied ‘...future.seeds_ii’ to environment
[16:18:42.644] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.644] assign_globals() ... done
[16:18:42.644] requestCore(): workers = 2
[16:18:42.646] MulticoreFuture started
[16:18:42.647] - Launch lazy future ... done
[16:18:42.647] run() for ‘MulticoreFuture’ ... done
[16:18:42.647] Created future:
[16:18:42.648] plan(): Setting new future strategy stack:
[16:18:42.648] List of future strategies:
[16:18:42.648] 1. sequential:
[16:18:42.648]    - args: function (..., envir = parent.frame())
[16:18:42.648]    - tweaked: FALSE
[16:18:42.648]    - call: NULL
[16:18:42.649] plan(): nbrOfWorkers() = 1
[16:18:42.651] plan(): Setting new future strategy stack:
[16:18:42.651] List of future strategies:
[16:18:42.651] 1. multicore:
[16:18:42.651]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.651]    - tweaked: FALSE
[16:18:42.651]    - call: plan(strategy)
[16:18:42.657] plan(): nbrOfWorkers() = 2
[16:18:42.648] MulticoreFuture:
[16:18:42.648] Label: ‘future_mapply-1’
[16:18:42.648] Expression:
[16:18:42.648] {
[16:18:42.648]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.648]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.648]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.648]         on.exit(options(oopts), add = TRUE)
[16:18:42.648]     }
[16:18:42.648]     {
[16:18:42.648]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.648]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.648]         do.call(mapply, args = args)
[16:18:42.648]     }
[16:18:42.648] }
[16:18:42.648] Lazy evaluation: FALSE
[16:18:42.648] Asynchronous evaluation: TRUE
[16:18:42.648] Local evaluation: TRUE
[16:18:42.648] Environment: R_GlobalEnv
[16:18:42.648] Capture standard output: TRUE
[16:18:42.648] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.648] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.648] Packages: <none>
[16:18:42.648] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.648] Resolved: TRUE
[16:18:42.648] Value: <not collected>
[16:18:42.648] Conditions captured: <none>
[16:18:42.648] Early signaling: FALSE
[16:18:42.648] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.648] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.658] Chunk #1 of 1 ... DONE
[16:18:42.658] Launching 1 futures (chunks) ... DONE
[16:18:42.658] Resolving 1 futures (chunks) ...
[16:18:42.659] resolve() on list ...
[16:18:42.659]  recursive: 0
[16:18:42.659]  length: 1
[16:18:42.659] 
[16:18:42.659] Future #1
[16:18:42.659] result() for MulticoreFuture ...
[16:18:42.661] result() for MulticoreFuture ...
[16:18:42.661] result() for MulticoreFuture ... done
[16:18:42.661] result() for MulticoreFuture ... done
[16:18:42.661] result() for MulticoreFuture ...
[16:18:42.661] result() for MulticoreFuture ... done
[16:18:42.661] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:42.662] - nx: 1
[16:18:42.662] - relay: TRUE
[16:18:42.662] - stdout: TRUE
[16:18:42.662] - signal: TRUE
[16:18:42.662] - resignal: FALSE
[16:18:42.662] - force: TRUE
[16:18:42.662] - relayed: [n=1] FALSE
[16:18:42.662] - queued futures: [n=1] FALSE
[16:18:42.663]  - until=1
[16:18:42.663]  - relaying element #1
[16:18:42.663] result() for MulticoreFuture ...
[16:18:42.663] result() for MulticoreFuture ... done
[16:18:42.663] result() for MulticoreFuture ...
[16:18:42.663] result() for MulticoreFuture ... done
[16:18:42.663] result() for MulticoreFuture ...
[16:18:42.664] result() for MulticoreFuture ... done
[16:18:42.664] result() for MulticoreFuture ...
[16:18:42.664] result() for MulticoreFuture ... done
[16:18:42.664] - relayed: [n=1] TRUE
[16:18:42.664] - queued futures: [n=1] TRUE
[16:18:42.664] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:42.664]  length: 0 (resolved future 1)
[16:18:42.664] Relaying remaining futures
[16:18:42.665] signalConditionsASAP(NULL, pos=0) ...
[16:18:42.665] - nx: 1
[16:18:42.665] - relay: TRUE
[16:18:42.665] - stdout: TRUE
[16:18:42.665] - signal: TRUE
[16:18:42.665] - resignal: FALSE
[16:18:42.665] - force: TRUE
[16:18:42.665] - relayed: [n=1] TRUE
[16:18:42.665] - queued futures: [n=1] TRUE
 - flush all
[16:18:42.666] - relayed: [n=1] TRUE
[16:18:42.666] - queued futures: [n=1] TRUE
[16:18:42.666] signalConditionsASAP(NULL, pos=0) ... done
[16:18:42.669] resolve() on list ... DONE
[16:18:42.670] result() for MulticoreFuture ...
[16:18:42.670] result() for MulticoreFuture ... done
[16:18:42.670] result() for MulticoreFuture ...
[16:18:42.670] result() for MulticoreFuture ... done
[16:18:42.670]  - Number of value chunks collected: 1
[16:18:42.671] Resolving 1 futures (chunks) ... DONE
[16:18:42.671] Reducing values from 1 chunks ...
[16:18:42.671]  - Number of values collected after concatenation: 1
[16:18:42.671]  - Number of values expected: 1
[16:18:42.671] Reducing values from 1 chunks ... DONE
[16:18:42.672] future_mapply() ... DONE
[16:18:42.672] future_mapply() ...
[16:18:42.676] Number of chunks: 1
[16:18:42.677] getGlobalsAndPackagesXApply() ...
[16:18:42.677]  - future.globals: TRUE
[16:18:42.677] getGlobalsAndPackages() ...
[16:18:42.677] Searching for globals...
[16:18:42.679] - globals found: [1] ‘FUN’
[16:18:42.679] Searching for globals ... DONE
[16:18:42.679] Resolving globals: FALSE
[16:18:42.680] The total size of the 1 globals is 848 bytes (848 bytes)
[16:18:42.680] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:18:42.681] - globals: [1] ‘FUN’
[16:18:42.681] 
[16:18:42.681] getGlobalsAndPackages() ... DONE
[16:18:42.681]  - globals found/used: [n=1] ‘FUN’
[16:18:42.681]  - needed namespaces: [n=0] 
[16:18:42.681] Finding globals ... DONE
[16:18:42.682] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:42.682] List of 2
[16:18:42.682]  $ ...future.FUN:function (x)  
[16:18:42.682]  $ MoreArgs     : list()
[16:18:42.682]  - attr(*, "where")=List of 2
[16:18:42.682]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:42.682]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:42.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.682]  - attr(*, "resolved")= logi FALSE
[16:18:42.682]  - attr(*, "total_size")= num NA
[16:18:42.685] Packages to be attached in all futures: [n=0] 
[16:18:42.685] getGlobalsAndPackagesXApply() ... DONE
[16:18:42.686] Number of futures (= number of chunks): 1
[16:18:42.686] Launching 1 futures (chunks) ...
[16:18:42.686] Chunk #1 of 1 ...
[16:18:42.686]  - Finding globals in '...' for chunk #1 ...
[16:18:42.686] getGlobalsAndPackages() ...
[16:18:42.686] Searching for globals...
[16:18:42.687] 
[16:18:42.687] Searching for globals ... DONE
[16:18:42.687] - globals: [0] <none>
[16:18:42.687] getGlobalsAndPackages() ... DONE
[16:18:42.687]    + additional globals found: [n=0] 
[16:18:42.687]    + additional namespaces needed: [n=0] 
[16:18:42.687]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:42.687]  - seeds: <none>
[16:18:42.687]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.688] getGlobalsAndPackages() ...
[16:18:42.688] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.688] Resolving globals: FALSE
[16:18:42.688] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[16:18:42.689] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:42.689] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.689] 
[16:18:42.689] getGlobalsAndPackages() ... DONE
[16:18:42.690] run() for ‘Future’ ...
[16:18:42.690] - state: ‘created’
[16:18:42.690] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.694] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.694] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.694]   - Field: ‘label’
[16:18:42.694]   - Field: ‘local’
[16:18:42.694]   - Field: ‘owner’
[16:18:42.695]   - Field: ‘envir’
[16:18:42.695]   - Field: ‘workers’
[16:18:42.695]   - Field: ‘packages’
[16:18:42.695]   - Field: ‘gc’
[16:18:42.695]   - Field: ‘job’
[16:18:42.695]   - Field: ‘conditions’
[16:18:42.695]   - Field: ‘expr’
[16:18:42.695]   - Field: ‘uuid’
[16:18:42.695]   - Field: ‘seed’
[16:18:42.695]   - Field: ‘version’
[16:18:42.696]   - Field: ‘result’
[16:18:42.696]   - Field: ‘asynchronous’
[16:18:42.696]   - Field: ‘calls’
[16:18:42.696]   - Field: ‘globals’
[16:18:42.696]   - Field: ‘stdout’
[16:18:42.696]   - Field: ‘earlySignal’
[16:18:42.696]   - Field: ‘lazy’
[16:18:42.696]   - Field: ‘state’
[16:18:42.696] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.697] - Launch lazy future ...
[16:18:42.697] Packages needed by the future expression (n = 0): <none>
[16:18:42.697] Packages needed by future strategies (n = 0): <none>
[16:18:42.697] {
[16:18:42.697]     {
[16:18:42.697]         {
[16:18:42.697]             ...future.startTime <- base::Sys.time()
[16:18:42.697]             {
[16:18:42.697]                 {
[16:18:42.697]                   {
[16:18:42.697]                     {
[16:18:42.697]                       base::local({
[16:18:42.697]                         has_future <- base::requireNamespace("future", 
[16:18:42.697]                           quietly = TRUE)
[16:18:42.697]                         if (has_future) {
[16:18:42.697]                           ns <- base::getNamespace("future")
[16:18:42.697]                           version <- ns[[".package"]][["version"]]
[16:18:42.697]                           if (is.null(version)) 
[16:18:42.697]                             version <- utils::packageVersion("future")
[16:18:42.697]                         }
[16:18:42.697]                         else {
[16:18:42.697]                           version <- NULL
[16:18:42.697]                         }
[16:18:42.697]                         if (!has_future || version < "1.8.0") {
[16:18:42.697]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.697]                             "", base::R.version$version.string), 
[16:18:42.697]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.697]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.697]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.697]                               "release", "version")], collapse = " "), 
[16:18:42.697]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.697]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.697]                             info)
[16:18:42.697]                           info <- base::paste(info, collapse = "; ")
[16:18:42.697]                           if (!has_future) {
[16:18:42.697]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.697]                               info)
[16:18:42.697]                           }
[16:18:42.697]                           else {
[16:18:42.697]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.697]                               info, version)
[16:18:42.697]                           }
[16:18:42.697]                           base::stop(msg)
[16:18:42.697]                         }
[16:18:42.697]                       })
[16:18:42.697]                     }
[16:18:42.697]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.697]                     base::options(mc.cores = 1L)
[16:18:42.697]                   }
[16:18:42.697]                   ...future.strategy.old <- future::plan("list")
[16:18:42.697]                   options(future.plan = NULL)
[16:18:42.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.697]                 }
[16:18:42.697]                 ...future.workdir <- getwd()
[16:18:42.697]             }
[16:18:42.697]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.697]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.697]         }
[16:18:42.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.697]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:42.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.697]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.697]             base::names(...future.oldOptions))
[16:18:42.697]     }
[16:18:42.697]     if (FALSE) {
[16:18:42.697]     }
[16:18:42.697]     else {
[16:18:42.697]         if (TRUE) {
[16:18:42.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.697]                 open = "w")
[16:18:42.697]         }
[16:18:42.697]         else {
[16:18:42.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.697]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.697]         }
[16:18:42.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.697]             base::sink(type = "output", split = FALSE)
[16:18:42.697]             base::close(...future.stdout)
[16:18:42.697]         }, add = TRUE)
[16:18:42.697]     }
[16:18:42.697]     ...future.frame <- base::sys.nframe()
[16:18:42.697]     ...future.conditions <- base::list()
[16:18:42.697]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.697]     if (FALSE) {
[16:18:42.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.697]     }
[16:18:42.697]     ...future.result <- base::tryCatch({
[16:18:42.697]         base::withCallingHandlers({
[16:18:42.697]             ...future.value <- base::withVisible(base::local({
[16:18:42.697]                 withCallingHandlers({
[16:18:42.697]                   {
[16:18:42.697]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.697]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.697]                       ...future.globals.maxSize)) {
[16:18:42.697]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.697]                       on.exit(options(oopts), add = TRUE)
[16:18:42.697]                     }
[16:18:42.697]                     {
[16:18:42.697]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.697]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.697]                         USE.NAMES = FALSE)
[16:18:42.697]                       do.call(mapply, args = args)
[16:18:42.697]                     }
[16:18:42.697]                   }
[16:18:42.697]                 }, immediateCondition = function(cond) {
[16:18:42.697]                   save_rds <- function (object, pathname, ...) 
[16:18:42.697]                   {
[16:18:42.697]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.697]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.697]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.697]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.697]                         fi_tmp[["mtime"]])
[16:18:42.697]                     }
[16:18:42.697]                     tryCatch({
[16:18:42.697]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.697]                     }, error = function(ex) {
[16:18:42.697]                       msg <- conditionMessage(ex)
[16:18:42.697]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.697]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.697]                         fi_tmp[["mtime"]], msg)
[16:18:42.697]                       ex$message <- msg
[16:18:42.697]                       stop(ex)
[16:18:42.697]                     })
[16:18:42.697]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.697]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.697]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.697]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.697]                       fi <- file.info(pathname)
[16:18:42.697]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.697]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.697]                         fi[["size"]], fi[["mtime"]])
[16:18:42.697]                       stop(msg)
[16:18:42.697]                     }
[16:18:42.697]                     invisible(pathname)
[16:18:42.697]                   }
[16:18:42.697]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.697]                     rootPath = tempdir()) 
[16:18:42.697]                   {
[16:18:42.697]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.697]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.697]                       tmpdir = path, fileext = ".rds")
[16:18:42.697]                     save_rds(obj, file)
[16:18:42.697]                   }
[16:18:42.697]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.697]                   {
[16:18:42.697]                     inherits <- base::inherits
[16:18:42.697]                     invokeRestart <- base::invokeRestart
[16:18:42.697]                     is.null <- base::is.null
[16:18:42.697]                     muffled <- FALSE
[16:18:42.697]                     if (inherits(cond, "message")) {
[16:18:42.697]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.697]                       if (muffled) 
[16:18:42.697]                         invokeRestart("muffleMessage")
[16:18:42.697]                     }
[16:18:42.697]                     else if (inherits(cond, "warning")) {
[16:18:42.697]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.697]                       if (muffled) 
[16:18:42.697]                         invokeRestart("muffleWarning")
[16:18:42.697]                     }
[16:18:42.697]                     else if (inherits(cond, "condition")) {
[16:18:42.697]                       if (!is.null(pattern)) {
[16:18:42.697]                         computeRestarts <- base::computeRestarts
[16:18:42.697]                         grepl <- base::grepl
[16:18:42.697]                         restarts <- computeRestarts(cond)
[16:18:42.697]                         for (restart in restarts) {
[16:18:42.697]                           name <- restart$name
[16:18:42.697]                           if (is.null(name)) 
[16:18:42.697]                             next
[16:18:42.697]                           if (!grepl(pattern, name)) 
[16:18:42.697]                             next
[16:18:42.697]                           invokeRestart(restart)
[16:18:42.697]                           muffled <- TRUE
[16:18:42.697]                           break
[16:18:42.697]                         }
[16:18:42.697]                       }
[16:18:42.697]                     }
[16:18:42.697]                     invisible(muffled)
[16:18:42.697]                   }
[16:18:42.697]                   muffleCondition(cond)
[16:18:42.697]                 })
[16:18:42.697]             }))
[16:18:42.697]             future::FutureResult(value = ...future.value$value, 
[16:18:42.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.697]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.697]                     ...future.globalenv.names))
[16:18:42.697]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.697]         }, condition = base::local({
[16:18:42.697]             c <- base::c
[16:18:42.697]             inherits <- base::inherits
[16:18:42.697]             invokeRestart <- base::invokeRestart
[16:18:42.697]             length <- base::length
[16:18:42.697]             list <- base::list
[16:18:42.697]             seq.int <- base::seq.int
[16:18:42.697]             signalCondition <- base::signalCondition
[16:18:42.697]             sys.calls <- base::sys.calls
[16:18:42.697]             `[[` <- base::`[[`
[16:18:42.697]             `+` <- base::`+`
[16:18:42.697]             `<<-` <- base::`<<-`
[16:18:42.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.697]                   3L)]
[16:18:42.697]             }
[16:18:42.697]             function(cond) {
[16:18:42.697]                 is_error <- inherits(cond, "error")
[16:18:42.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.697]                   NULL)
[16:18:42.697]                 if (is_error) {
[16:18:42.697]                   sessionInformation <- function() {
[16:18:42.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.697]                       search = base::search(), system = base::Sys.info())
[16:18:42.697]                   }
[16:18:42.697]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.697]                     cond$call), session = sessionInformation(), 
[16:18:42.697]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.697]                   signalCondition(cond)
[16:18:42.697]                 }
[16:18:42.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.697]                 "immediateCondition"))) {
[16:18:42.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.697]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.697]                   if (TRUE && !signal) {
[16:18:42.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.697]                     {
[16:18:42.697]                       inherits <- base::inherits
[16:18:42.697]                       invokeRestart <- base::invokeRestart
[16:18:42.697]                       is.null <- base::is.null
[16:18:42.697]                       muffled <- FALSE
[16:18:42.697]                       if (inherits(cond, "message")) {
[16:18:42.697]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.697]                         if (muffled) 
[16:18:42.697]                           invokeRestart("muffleMessage")
[16:18:42.697]                       }
[16:18:42.697]                       else if (inherits(cond, "warning")) {
[16:18:42.697]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.697]                         if (muffled) 
[16:18:42.697]                           invokeRestart("muffleWarning")
[16:18:42.697]                       }
[16:18:42.697]                       else if (inherits(cond, "condition")) {
[16:18:42.697]                         if (!is.null(pattern)) {
[16:18:42.697]                           computeRestarts <- base::computeRestarts
[16:18:42.697]                           grepl <- base::grepl
[16:18:42.697]                           restarts <- computeRestarts(cond)
[16:18:42.697]                           for (restart in restarts) {
[16:18:42.697]                             name <- restart$name
[16:18:42.697]                             if (is.null(name)) 
[16:18:42.697]                               next
[16:18:42.697]                             if (!grepl(pattern, name)) 
[16:18:42.697]                               next
[16:18:42.697]                             invokeRestart(restart)
[16:18:42.697]                             muffled <- TRUE
[16:18:42.697]                             break
[16:18:42.697]                           }
[16:18:42.697]                         }
[16:18:42.697]                       }
[16:18:42.697]                       invisible(muffled)
[16:18:42.697]                     }
[16:18:42.697]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.697]                   }
[16:18:42.697]                 }
[16:18:42.697]                 else {
[16:18:42.697]                   if (TRUE) {
[16:18:42.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.697]                     {
[16:18:42.697]                       inherits <- base::inherits
[16:18:42.697]                       invokeRestart <- base::invokeRestart
[16:18:42.697]                       is.null <- base::is.null
[16:18:42.697]                       muffled <- FALSE
[16:18:42.697]                       if (inherits(cond, "message")) {
[16:18:42.697]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.697]                         if (muffled) 
[16:18:42.697]                           invokeRestart("muffleMessage")
[16:18:42.697]                       }
[16:18:42.697]                       else if (inherits(cond, "warning")) {
[16:18:42.697]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.697]                         if (muffled) 
[16:18:42.697]                           invokeRestart("muffleWarning")
[16:18:42.697]                       }
[16:18:42.697]                       else if (inherits(cond, "condition")) {
[16:18:42.697]                         if (!is.null(pattern)) {
[16:18:42.697]                           computeRestarts <- base::computeRestarts
[16:18:42.697]                           grepl <- base::grepl
[16:18:42.697]                           restarts <- computeRestarts(cond)
[16:18:42.697]                           for (restart in restarts) {
[16:18:42.697]                             name <- restart$name
[16:18:42.697]                             if (is.null(name)) 
[16:18:42.697]                               next
[16:18:42.697]                             if (!grepl(pattern, name)) 
[16:18:42.697]                               next
[16:18:42.697]                             invokeRestart(restart)
[16:18:42.697]                             muffled <- TRUE
[16:18:42.697]                             break
[16:18:42.697]                           }
[16:18:42.697]                         }
[16:18:42.697]                       }
[16:18:42.697]                       invisible(muffled)
[16:18:42.697]                     }
[16:18:42.697]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.697]                   }
[16:18:42.697]                 }
[16:18:42.697]             }
[16:18:42.697]         }))
[16:18:42.697]     }, error = function(ex) {
[16:18:42.697]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.697]                 ...future.rng), started = ...future.startTime, 
[16:18:42.697]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.697]             version = "1.8"), class = "FutureResult")
[16:18:42.697]     }, finally = {
[16:18:42.697]         if (!identical(...future.workdir, getwd())) 
[16:18:42.697]             setwd(...future.workdir)
[16:18:42.697]         {
[16:18:42.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.697]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.697]             }
[16:18:42.697]             base::options(...future.oldOptions)
[16:18:42.697]             if (.Platform$OS.type == "windows") {
[16:18:42.697]                 old_names <- names(...future.oldEnvVars)
[16:18:42.697]                 envs <- base::Sys.getenv()
[16:18:42.697]                 names <- names(envs)
[16:18:42.697]                 common <- intersect(names, old_names)
[16:18:42.697]                 added <- setdiff(names, old_names)
[16:18:42.697]                 removed <- setdiff(old_names, names)
[16:18:42.697]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.697]                   envs[common]]
[16:18:42.697]                 NAMES <- toupper(changed)
[16:18:42.697]                 args <- list()
[16:18:42.697]                 for (kk in seq_along(NAMES)) {
[16:18:42.697]                   name <- changed[[kk]]
[16:18:42.697]                   NAME <- NAMES[[kk]]
[16:18:42.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.697]                     next
[16:18:42.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.697]                 }
[16:18:42.697]                 NAMES <- toupper(added)
[16:18:42.697]                 for (kk in seq_along(NAMES)) {
[16:18:42.697]                   name <- added[[kk]]
[16:18:42.697]                   NAME <- NAMES[[kk]]
[16:18:42.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.697]                     next
[16:18:42.697]                   args[[name]] <- ""
[16:18:42.697]                 }
[16:18:42.697]                 NAMES <- toupper(removed)
[16:18:42.697]                 for (kk in seq_along(NAMES)) {
[16:18:42.697]                   name <- removed[[kk]]
[16:18:42.697]                   NAME <- NAMES[[kk]]
[16:18:42.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.697]                     next
[16:18:42.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.697]                 }
[16:18:42.697]                 if (length(args) > 0) 
[16:18:42.697]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.697]             }
[16:18:42.697]             else {
[16:18:42.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.697]             }
[16:18:42.697]             {
[16:18:42.697]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.697]                   0L) {
[16:18:42.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.697]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.697]                   base::options(opts)
[16:18:42.697]                 }
[16:18:42.697]                 {
[16:18:42.697]                   {
[16:18:42.697]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.697]                     NULL
[16:18:42.697]                   }
[16:18:42.697]                   options(future.plan = NULL)
[16:18:42.697]                   if (is.na(NA_character_)) 
[16:18:42.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.697]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.697]                     .init = FALSE)
[16:18:42.697]                 }
[16:18:42.697]             }
[16:18:42.697]         }
[16:18:42.697]     })
[16:18:42.697]     if (TRUE) {
[16:18:42.697]         base::sink(type = "output", split = FALSE)
[16:18:42.697]         if (TRUE) {
[16:18:42.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.697]         }
[16:18:42.697]         else {
[16:18:42.697]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.697]         }
[16:18:42.697]         base::close(...future.stdout)
[16:18:42.697]         ...future.stdout <- NULL
[16:18:42.697]     }
[16:18:42.697]     ...future.result$conditions <- ...future.conditions
[16:18:42.697]     ...future.result$finished <- base::Sys.time()
[16:18:42.697]     ...future.result
[16:18:42.697] }
[16:18:42.700] assign_globals() ...
[16:18:42.700] List of 5
[16:18:42.700]  $ ...future.FUN            :function (x)  
[16:18:42.700]  $ MoreArgs                 : list()
[16:18:42.700]  $ ...future.elements_ii    :List of 1
[16:18:42.700]   ..$ :List of 1
[16:18:42.700]   .. ..$ : Date[1:1], format: "2018-06-01"
[16:18:42.700]  $ ...future.seeds_ii       : NULL
[16:18:42.700]  $ ...future.globals.maxSize: NULL
[16:18:42.700]  - attr(*, "where")=List of 5
[16:18:42.700]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.700]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.700]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.700]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.700]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.700]  - attr(*, "resolved")= logi FALSE
[16:18:42.700]  - attr(*, "total_size")= num 1128
[16:18:42.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.700]  - attr(*, "already-done")= logi TRUE
[16:18:42.709] - copied ‘...future.FUN’ to environment
[16:18:42.709] - copied ‘MoreArgs’ to environment
[16:18:42.709] - copied ‘...future.elements_ii’ to environment
[16:18:42.709] - copied ‘...future.seeds_ii’ to environment
[16:18:42.710] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.710] assign_globals() ... done
[16:18:42.710] requestCore(): workers = 2
[16:18:42.713] MulticoreFuture started
[16:18:42.713] - Launch lazy future ... done
[16:18:42.714] run() for ‘MulticoreFuture’ ... done
[16:18:42.714] plan(): Setting new future strategy stack:
[16:18:42.714] Created future:
[16:18:42.714] List of future strategies:
[16:18:42.714] 1. sequential:
[16:18:42.714]    - args: function (..., envir = parent.frame())
[16:18:42.714]    - tweaked: FALSE
[16:18:42.714]    - call: NULL
[16:18:42.716] plan(): nbrOfWorkers() = 1
[16:18:42.718] plan(): Setting new future strategy stack:
[16:18:42.719] List of future strategies:
[16:18:42.719] 1. multicore:
[16:18:42.719]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.719]    - tweaked: FALSE
[16:18:42.719]    - call: plan(strategy)
[16:18:42.725] plan(): nbrOfWorkers() = 2
[16:18:42.715] MulticoreFuture:
[16:18:42.715] Label: ‘future_.mapply-1’
[16:18:42.715] Expression:
[16:18:42.715] {
[16:18:42.715]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.715]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.715]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.715]         on.exit(options(oopts), add = TRUE)
[16:18:42.715]     }
[16:18:42.715]     {
[16:18:42.715]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.715]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.715]         do.call(mapply, args = args)
[16:18:42.715]     }
[16:18:42.715] }
[16:18:42.715] Lazy evaluation: FALSE
[16:18:42.715] Asynchronous evaluation: TRUE
[16:18:42.715] Local evaluation: TRUE
[16:18:42.715] Environment: R_GlobalEnv
[16:18:42.715] Capture standard output: TRUE
[16:18:42.715] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.715] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.715] Packages: <none>
[16:18:42.715] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.715] Resolved: TRUE
[16:18:42.715] Value: <not collected>
[16:18:42.715] Conditions captured: <none>
[16:18:42.715] Early signaling: FALSE
[16:18:42.715] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.715] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.726] Chunk #1 of 1 ... DONE
[16:18:42.726] Launching 1 futures (chunks) ... DONE
[16:18:42.726] Resolving 1 futures (chunks) ...
[16:18:42.727] resolve() on list ...
[16:18:42.727]  recursive: 0
[16:18:42.727]  length: 1
[16:18:42.727] 
[16:18:42.727] Future #1
[16:18:42.728] result() for MulticoreFuture ...
[16:18:42.729] result() for MulticoreFuture ...
[16:18:42.729] result() for MulticoreFuture ... done
[16:18:42.729] result() for MulticoreFuture ... done
[16:18:42.729] result() for MulticoreFuture ...
[16:18:42.729] result() for MulticoreFuture ... done
[16:18:42.730] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:42.730] - nx: 1
[16:18:42.730] - relay: TRUE
[16:18:42.730] - stdout: TRUE
[16:18:42.730] - signal: TRUE
[16:18:42.730] - resignal: FALSE
[16:18:42.730] - force: TRUE
[16:18:42.730] - relayed: [n=1] FALSE
[16:18:42.731] - queued futures: [n=1] FALSE
[16:18:42.731]  - until=1
[16:18:42.731]  - relaying element #1
[16:18:42.731] result() for MulticoreFuture ...
[16:18:42.731] result() for MulticoreFuture ... done
[16:18:42.732] result() for MulticoreFuture ...
[16:18:42.732] result() for MulticoreFuture ... done
[16:18:42.732] result() for MulticoreFuture ...
[16:18:42.732] result() for MulticoreFuture ... done
[16:18:42.732] result() for MulticoreFuture ...
[16:18:42.732] result() for MulticoreFuture ... done
[16:18:42.732] - relayed: [n=1] TRUE
[16:18:42.733] - queued futures: [n=1] TRUE
[16:18:42.733] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:42.733]  length: 0 (resolved future 1)
[16:18:42.733] Relaying remaining futures
[16:18:42.733] signalConditionsASAP(NULL, pos=0) ...
[16:18:42.733] - nx: 1
[16:18:42.733] - relay: TRUE
[16:18:42.733] - stdout: TRUE
[16:18:42.733] - signal: TRUE
[16:18:42.734] - resignal: FALSE
[16:18:42.734] - force: TRUE
[16:18:42.734] - relayed: [n=1] TRUE
[16:18:42.734] - queued futures: [n=1] TRUE
 - flush all
[16:18:42.734] - relayed: [n=1] TRUE
[16:18:42.734] - queued futures: [n=1] TRUE
[16:18:42.734] signalConditionsASAP(NULL, pos=0) ... done
[16:18:42.734] resolve() on list ... DONE
[16:18:42.735] result() for MulticoreFuture ...
[16:18:42.735] result() for MulticoreFuture ... done
[16:18:42.735] result() for MulticoreFuture ...
[16:18:42.735] result() for MulticoreFuture ... done
[16:18:42.735]  - Number of value chunks collected: 1
[16:18:42.735] Resolving 1 futures (chunks) ... DONE
[16:18:42.735] Reducing values from 1 chunks ...
[16:18:42.735]  - Number of values collected after concatenation: 1
[16:18:42.736]  - Number of values expected: 1
[16:18:42.736] Reducing values from 1 chunks ... DONE
[16:18:42.736] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[16:18:42.736] future_mapply() ...
[16:18:42.740] Number of chunks: 2
[16:18:42.741] getGlobalsAndPackagesXApply() ...
[16:18:42.741]  - future.globals: TRUE
[16:18:42.741] getGlobalsAndPackages() ...
[16:18:42.741] Searching for globals...
[16:18:42.742] - globals found: [1] ‘FUN’
[16:18:42.743] Searching for globals ... DONE
[16:18:42.743] Resolving globals: FALSE
[16:18:42.743] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[16:18:42.743] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[16:18:42.744] - globals: [1] ‘FUN’
[16:18:42.744] 
[16:18:42.744] getGlobalsAndPackages() ... DONE
[16:18:42.744]  - globals found/used: [n=1] ‘FUN’
[16:18:42.744]  - needed namespaces: [n=0] 
[16:18:42.744] Finding globals ... DONE
[16:18:42.744] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:42.745] List of 2
[16:18:42.745]  $ ...future.FUN:function (x, y)  
[16:18:42.745]  $ MoreArgs     :List of 1
[16:18:42.745]   ..$ y: int [1:2] 3 4
[16:18:42.745]  - attr(*, "where")=List of 2
[16:18:42.745]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:42.745]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:42.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.745]  - attr(*, "resolved")= logi FALSE
[16:18:42.745]  - attr(*, "total_size")= num NA
[16:18:42.751] Packages to be attached in all futures: [n=0] 
[16:18:42.751] getGlobalsAndPackagesXApply() ... DONE
[16:18:42.752] Number of futures (= number of chunks): 2
[16:18:42.752] Launching 2 futures (chunks) ...
[16:18:42.752] Chunk #1 of 2 ...
[16:18:42.752]  - Finding globals in '...' for chunk #1 ...
[16:18:42.752] getGlobalsAndPackages() ...
[16:18:42.753] Searching for globals...
[16:18:42.753] 
[16:18:42.753] Searching for globals ... DONE
[16:18:42.753] - globals: [0] <none>
[16:18:42.753] getGlobalsAndPackages() ... DONE
[16:18:42.754]    + additional globals found: [n=0] 
[16:18:42.754]    + additional namespaces needed: [n=0] 
[16:18:42.754]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:42.754]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:42.754]  - seeds: <none>
[16:18:42.754]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.754] getGlobalsAndPackages() ...
[16:18:42.754] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.755] Resolving globals: FALSE
[16:18:42.755] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[16:18:42.756] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[16:18:42.756] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.756] 
[16:18:42.756] getGlobalsAndPackages() ... DONE
[16:18:42.757] run() for ‘Future’ ...
[16:18:42.757] - state: ‘created’
[16:18:42.757] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.761] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.761] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.761]   - Field: ‘label’
[16:18:42.761]   - Field: ‘local’
[16:18:42.761]   - Field: ‘owner’
[16:18:42.761]   - Field: ‘envir’
[16:18:42.761]   - Field: ‘workers’
[16:18:42.762]   - Field: ‘packages’
[16:18:42.762]   - Field: ‘gc’
[16:18:42.762]   - Field: ‘job’
[16:18:42.762]   - Field: ‘conditions’
[16:18:42.762]   - Field: ‘expr’
[16:18:42.762]   - Field: ‘uuid’
[16:18:42.762]   - Field: ‘seed’
[16:18:42.762]   - Field: ‘version’
[16:18:42.762]   - Field: ‘result’
[16:18:42.762]   - Field: ‘asynchronous’
[16:18:42.763]   - Field: ‘calls’
[16:18:42.763]   - Field: ‘globals’
[16:18:42.763]   - Field: ‘stdout’
[16:18:42.763]   - Field: ‘earlySignal’
[16:18:42.763]   - Field: ‘lazy’
[16:18:42.763]   - Field: ‘state’
[16:18:42.763] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.763] - Launch lazy future ...
[16:18:42.764] Packages needed by the future expression (n = 0): <none>
[16:18:42.764] Packages needed by future strategies (n = 0): <none>
[16:18:42.764] {
[16:18:42.764]     {
[16:18:42.764]         {
[16:18:42.764]             ...future.startTime <- base::Sys.time()
[16:18:42.764]             {
[16:18:42.764]                 {
[16:18:42.764]                   {
[16:18:42.764]                     {
[16:18:42.764]                       base::local({
[16:18:42.764]                         has_future <- base::requireNamespace("future", 
[16:18:42.764]                           quietly = TRUE)
[16:18:42.764]                         if (has_future) {
[16:18:42.764]                           ns <- base::getNamespace("future")
[16:18:42.764]                           version <- ns[[".package"]][["version"]]
[16:18:42.764]                           if (is.null(version)) 
[16:18:42.764]                             version <- utils::packageVersion("future")
[16:18:42.764]                         }
[16:18:42.764]                         else {
[16:18:42.764]                           version <- NULL
[16:18:42.764]                         }
[16:18:42.764]                         if (!has_future || version < "1.8.0") {
[16:18:42.764]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.764]                             "", base::R.version$version.string), 
[16:18:42.764]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.764]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.764]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.764]                               "release", "version")], collapse = " "), 
[16:18:42.764]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.764]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.764]                             info)
[16:18:42.764]                           info <- base::paste(info, collapse = "; ")
[16:18:42.764]                           if (!has_future) {
[16:18:42.764]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.764]                               info)
[16:18:42.764]                           }
[16:18:42.764]                           else {
[16:18:42.764]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.764]                               info, version)
[16:18:42.764]                           }
[16:18:42.764]                           base::stop(msg)
[16:18:42.764]                         }
[16:18:42.764]                       })
[16:18:42.764]                     }
[16:18:42.764]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.764]                     base::options(mc.cores = 1L)
[16:18:42.764]                   }
[16:18:42.764]                   ...future.strategy.old <- future::plan("list")
[16:18:42.764]                   options(future.plan = NULL)
[16:18:42.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.764]                 }
[16:18:42.764]                 ...future.workdir <- getwd()
[16:18:42.764]             }
[16:18:42.764]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.764]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.764]         }
[16:18:42.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.764]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:42.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.764]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.764]             base::names(...future.oldOptions))
[16:18:42.764]     }
[16:18:42.764]     if (FALSE) {
[16:18:42.764]     }
[16:18:42.764]     else {
[16:18:42.764]         if (TRUE) {
[16:18:42.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.764]                 open = "w")
[16:18:42.764]         }
[16:18:42.764]         else {
[16:18:42.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.764]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.764]         }
[16:18:42.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.764]             base::sink(type = "output", split = FALSE)
[16:18:42.764]             base::close(...future.stdout)
[16:18:42.764]         }, add = TRUE)
[16:18:42.764]     }
[16:18:42.764]     ...future.frame <- base::sys.nframe()
[16:18:42.764]     ...future.conditions <- base::list()
[16:18:42.764]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.764]     if (FALSE) {
[16:18:42.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.764]     }
[16:18:42.764]     ...future.result <- base::tryCatch({
[16:18:42.764]         base::withCallingHandlers({
[16:18:42.764]             ...future.value <- base::withVisible(base::local({
[16:18:42.764]                 withCallingHandlers({
[16:18:42.764]                   {
[16:18:42.764]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.764]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.764]                       ...future.globals.maxSize)) {
[16:18:42.764]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.764]                       on.exit(options(oopts), add = TRUE)
[16:18:42.764]                     }
[16:18:42.764]                     {
[16:18:42.764]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.764]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.764]                         USE.NAMES = FALSE)
[16:18:42.764]                       do.call(mapply, args = args)
[16:18:42.764]                     }
[16:18:42.764]                   }
[16:18:42.764]                 }, immediateCondition = function(cond) {
[16:18:42.764]                   save_rds <- function (object, pathname, ...) 
[16:18:42.764]                   {
[16:18:42.764]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.764]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.764]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.764]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.764]                         fi_tmp[["mtime"]])
[16:18:42.764]                     }
[16:18:42.764]                     tryCatch({
[16:18:42.764]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.764]                     }, error = function(ex) {
[16:18:42.764]                       msg <- conditionMessage(ex)
[16:18:42.764]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.764]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.764]                         fi_tmp[["mtime"]], msg)
[16:18:42.764]                       ex$message <- msg
[16:18:42.764]                       stop(ex)
[16:18:42.764]                     })
[16:18:42.764]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.764]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.764]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.764]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.764]                       fi <- file.info(pathname)
[16:18:42.764]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.764]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.764]                         fi[["size"]], fi[["mtime"]])
[16:18:42.764]                       stop(msg)
[16:18:42.764]                     }
[16:18:42.764]                     invisible(pathname)
[16:18:42.764]                   }
[16:18:42.764]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.764]                     rootPath = tempdir()) 
[16:18:42.764]                   {
[16:18:42.764]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.764]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.764]                       tmpdir = path, fileext = ".rds")
[16:18:42.764]                     save_rds(obj, file)
[16:18:42.764]                   }
[16:18:42.764]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.764]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.764]                   {
[16:18:42.764]                     inherits <- base::inherits
[16:18:42.764]                     invokeRestart <- base::invokeRestart
[16:18:42.764]                     is.null <- base::is.null
[16:18:42.764]                     muffled <- FALSE
[16:18:42.764]                     if (inherits(cond, "message")) {
[16:18:42.764]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.764]                       if (muffled) 
[16:18:42.764]                         invokeRestart("muffleMessage")
[16:18:42.764]                     }
[16:18:42.764]                     else if (inherits(cond, "warning")) {
[16:18:42.764]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.764]                       if (muffled) 
[16:18:42.764]                         invokeRestart("muffleWarning")
[16:18:42.764]                     }
[16:18:42.764]                     else if (inherits(cond, "condition")) {
[16:18:42.764]                       if (!is.null(pattern)) {
[16:18:42.764]                         computeRestarts <- base::computeRestarts
[16:18:42.764]                         grepl <- base::grepl
[16:18:42.764]                         restarts <- computeRestarts(cond)
[16:18:42.764]                         for (restart in restarts) {
[16:18:42.764]                           name <- restart$name
[16:18:42.764]                           if (is.null(name)) 
[16:18:42.764]                             next
[16:18:42.764]                           if (!grepl(pattern, name)) 
[16:18:42.764]                             next
[16:18:42.764]                           invokeRestart(restart)
[16:18:42.764]                           muffled <- TRUE
[16:18:42.764]                           break
[16:18:42.764]                         }
[16:18:42.764]                       }
[16:18:42.764]                     }
[16:18:42.764]                     invisible(muffled)
[16:18:42.764]                   }
[16:18:42.764]                   muffleCondition(cond)
[16:18:42.764]                 })
[16:18:42.764]             }))
[16:18:42.764]             future::FutureResult(value = ...future.value$value, 
[16:18:42.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.764]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.764]                     ...future.globalenv.names))
[16:18:42.764]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.764]         }, condition = base::local({
[16:18:42.764]             c <- base::c
[16:18:42.764]             inherits <- base::inherits
[16:18:42.764]             invokeRestart <- base::invokeRestart
[16:18:42.764]             length <- base::length
[16:18:42.764]             list <- base::list
[16:18:42.764]             seq.int <- base::seq.int
[16:18:42.764]             signalCondition <- base::signalCondition
[16:18:42.764]             sys.calls <- base::sys.calls
[16:18:42.764]             `[[` <- base::`[[`
[16:18:42.764]             `+` <- base::`+`
[16:18:42.764]             `<<-` <- base::`<<-`
[16:18:42.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.764]                   3L)]
[16:18:42.764]             }
[16:18:42.764]             function(cond) {
[16:18:42.764]                 is_error <- inherits(cond, "error")
[16:18:42.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.764]                   NULL)
[16:18:42.764]                 if (is_error) {
[16:18:42.764]                   sessionInformation <- function() {
[16:18:42.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.764]                       search = base::search(), system = base::Sys.info())
[16:18:42.764]                   }
[16:18:42.764]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.764]                     cond$call), session = sessionInformation(), 
[16:18:42.764]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.764]                   signalCondition(cond)
[16:18:42.764]                 }
[16:18:42.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.764]                 "immediateCondition"))) {
[16:18:42.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.764]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.764]                   if (TRUE && !signal) {
[16:18:42.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.764]                     {
[16:18:42.764]                       inherits <- base::inherits
[16:18:42.764]                       invokeRestart <- base::invokeRestart
[16:18:42.764]                       is.null <- base::is.null
[16:18:42.764]                       muffled <- FALSE
[16:18:42.764]                       if (inherits(cond, "message")) {
[16:18:42.764]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.764]                         if (muffled) 
[16:18:42.764]                           invokeRestart("muffleMessage")
[16:18:42.764]                       }
[16:18:42.764]                       else if (inherits(cond, "warning")) {
[16:18:42.764]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.764]                         if (muffled) 
[16:18:42.764]                           invokeRestart("muffleWarning")
[16:18:42.764]                       }
[16:18:42.764]                       else if (inherits(cond, "condition")) {
[16:18:42.764]                         if (!is.null(pattern)) {
[16:18:42.764]                           computeRestarts <- base::computeRestarts
[16:18:42.764]                           grepl <- base::grepl
[16:18:42.764]                           restarts <- computeRestarts(cond)
[16:18:42.764]                           for (restart in restarts) {
[16:18:42.764]                             name <- restart$name
[16:18:42.764]                             if (is.null(name)) 
[16:18:42.764]                               next
[16:18:42.764]                             if (!grepl(pattern, name)) 
[16:18:42.764]                               next
[16:18:42.764]                             invokeRestart(restart)
[16:18:42.764]                             muffled <- TRUE
[16:18:42.764]                             break
[16:18:42.764]                           }
[16:18:42.764]                         }
[16:18:42.764]                       }
[16:18:42.764]                       invisible(muffled)
[16:18:42.764]                     }
[16:18:42.764]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.764]                   }
[16:18:42.764]                 }
[16:18:42.764]                 else {
[16:18:42.764]                   if (TRUE) {
[16:18:42.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.764]                     {
[16:18:42.764]                       inherits <- base::inherits
[16:18:42.764]                       invokeRestart <- base::invokeRestart
[16:18:42.764]                       is.null <- base::is.null
[16:18:42.764]                       muffled <- FALSE
[16:18:42.764]                       if (inherits(cond, "message")) {
[16:18:42.764]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.764]                         if (muffled) 
[16:18:42.764]                           invokeRestart("muffleMessage")
[16:18:42.764]                       }
[16:18:42.764]                       else if (inherits(cond, "warning")) {
[16:18:42.764]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.764]                         if (muffled) 
[16:18:42.764]                           invokeRestart("muffleWarning")
[16:18:42.764]                       }
[16:18:42.764]                       else if (inherits(cond, "condition")) {
[16:18:42.764]                         if (!is.null(pattern)) {
[16:18:42.764]                           computeRestarts <- base::computeRestarts
[16:18:42.764]                           grepl <- base::grepl
[16:18:42.764]                           restarts <- computeRestarts(cond)
[16:18:42.764]                           for (restart in restarts) {
[16:18:42.764]                             name <- restart$name
[16:18:42.764]                             if (is.null(name)) 
[16:18:42.764]                               next
[16:18:42.764]                             if (!grepl(pattern, name)) 
[16:18:42.764]                               next
[16:18:42.764]                             invokeRestart(restart)
[16:18:42.764]                             muffled <- TRUE
[16:18:42.764]                             break
[16:18:42.764]                           }
[16:18:42.764]                         }
[16:18:42.764]                       }
[16:18:42.764]                       invisible(muffled)
[16:18:42.764]                     }
[16:18:42.764]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.764]                   }
[16:18:42.764]                 }
[16:18:42.764]             }
[16:18:42.764]         }))
[16:18:42.764]     }, error = function(ex) {
[16:18:42.764]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.764]                 ...future.rng), started = ...future.startTime, 
[16:18:42.764]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.764]             version = "1.8"), class = "FutureResult")
[16:18:42.764]     }, finally = {
[16:18:42.764]         if (!identical(...future.workdir, getwd())) 
[16:18:42.764]             setwd(...future.workdir)
[16:18:42.764]         {
[16:18:42.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.764]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.764]             }
[16:18:42.764]             base::options(...future.oldOptions)
[16:18:42.764]             if (.Platform$OS.type == "windows") {
[16:18:42.764]                 old_names <- names(...future.oldEnvVars)
[16:18:42.764]                 envs <- base::Sys.getenv()
[16:18:42.764]                 names <- names(envs)
[16:18:42.764]                 common <- intersect(names, old_names)
[16:18:42.764]                 added <- setdiff(names, old_names)
[16:18:42.764]                 removed <- setdiff(old_names, names)
[16:18:42.764]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.764]                   envs[common]]
[16:18:42.764]                 NAMES <- toupper(changed)
[16:18:42.764]                 args <- list()
[16:18:42.764]                 for (kk in seq_along(NAMES)) {
[16:18:42.764]                   name <- changed[[kk]]
[16:18:42.764]                   NAME <- NAMES[[kk]]
[16:18:42.764]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.764]                     next
[16:18:42.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.764]                 }
[16:18:42.764]                 NAMES <- toupper(added)
[16:18:42.764]                 for (kk in seq_along(NAMES)) {
[16:18:42.764]                   name <- added[[kk]]
[16:18:42.764]                   NAME <- NAMES[[kk]]
[16:18:42.764]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.764]                     next
[16:18:42.764]                   args[[name]] <- ""
[16:18:42.764]                 }
[16:18:42.764]                 NAMES <- toupper(removed)
[16:18:42.764]                 for (kk in seq_along(NAMES)) {
[16:18:42.764]                   name <- removed[[kk]]
[16:18:42.764]                   NAME <- NAMES[[kk]]
[16:18:42.764]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.764]                     next
[16:18:42.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.764]                 }
[16:18:42.764]                 if (length(args) > 0) 
[16:18:42.764]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.764]             }
[16:18:42.764]             else {
[16:18:42.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.764]             }
[16:18:42.764]             {
[16:18:42.764]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.764]                   0L) {
[16:18:42.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.764]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.764]                   base::options(opts)
[16:18:42.764]                 }
[16:18:42.764]                 {
[16:18:42.764]                   {
[16:18:42.764]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.764]                     NULL
[16:18:42.764]                   }
[16:18:42.764]                   options(future.plan = NULL)
[16:18:42.764]                   if (is.na(NA_character_)) 
[16:18:42.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.764]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.764]                     .init = FALSE)
[16:18:42.764]                 }
[16:18:42.764]             }
[16:18:42.764]         }
[16:18:42.764]     })
[16:18:42.764]     if (TRUE) {
[16:18:42.764]         base::sink(type = "output", split = FALSE)
[16:18:42.764]         if (TRUE) {
[16:18:42.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.764]         }
[16:18:42.764]         else {
[16:18:42.764]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.764]         }
[16:18:42.764]         base::close(...future.stdout)
[16:18:42.764]         ...future.stdout <- NULL
[16:18:42.764]     }
[16:18:42.764]     ...future.result$conditions <- ...future.conditions
[16:18:42.764]     ...future.result$finished <- base::Sys.time()
[16:18:42.764]     ...future.result
[16:18:42.764] }
[16:18:42.767] assign_globals() ...
[16:18:42.767] List of 5
[16:18:42.767]  $ ...future.FUN            :function (x, y)  
[16:18:42.767]  $ MoreArgs                 :List of 1
[16:18:42.767]   ..$ y: int [1:2] 3 4
[16:18:42.767]  $ ...future.elements_ii    :List of 1
[16:18:42.767]   ..$ x:List of 1
[16:18:42.767]   .. ..$ : int 1
[16:18:42.767]  $ ...future.seeds_ii       : NULL
[16:18:42.767]  $ ...future.globals.maxSize: NULL
[16:18:42.767]  - attr(*, "where")=List of 5
[16:18:42.767]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.767]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.767]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.767]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.767]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.767]  - attr(*, "resolved")= logi FALSE
[16:18:42.767]  - attr(*, "total_size")= num 1816
[16:18:42.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.767]  - attr(*, "already-done")= logi TRUE
[16:18:42.772] - reassign environment for ‘...future.FUN’
[16:18:42.772] - copied ‘...future.FUN’ to environment
[16:18:42.772] - copied ‘MoreArgs’ to environment
[16:18:42.772] - copied ‘...future.elements_ii’ to environment
[16:18:42.773] - copied ‘...future.seeds_ii’ to environment
[16:18:42.773] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.773] assign_globals() ... done
[16:18:42.773] requestCore(): workers = 2
[16:18:42.775] MulticoreFuture started
[16:18:42.776] - Launch lazy future ... done
[16:18:42.776] run() for ‘MulticoreFuture’ ... done
[16:18:42.776] Created future:
[16:18:42.776] plan(): Setting new future strategy stack:
[16:18:42.777] List of future strategies:
[16:18:42.777] 1. sequential:
[16:18:42.777]    - args: function (..., envir = parent.frame())
[16:18:42.777]    - tweaked: FALSE
[16:18:42.777]    - call: NULL
[16:18:42.777] plan(): nbrOfWorkers() = 1
[16:18:42.784] plan(): Setting new future strategy stack:
[16:18:42.784] List of future strategies:
[16:18:42.784] 1. multicore:
[16:18:42.784]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.784]    - tweaked: FALSE
[16:18:42.784]    - call: plan(strategy)
[16:18:42.791] plan(): nbrOfWorkers() = 2
[16:18:42.776] MulticoreFuture:
[16:18:42.776] Label: ‘future_mapply-1’
[16:18:42.776] Expression:
[16:18:42.776] {
[16:18:42.776]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.776]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.776]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.776]         on.exit(options(oopts), add = TRUE)
[16:18:42.776]     }
[16:18:42.776]     {
[16:18:42.776]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.776]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.776]         do.call(mapply, args = args)
[16:18:42.776]     }
[16:18:42.776] }
[16:18:42.776] Lazy evaluation: FALSE
[16:18:42.776] Asynchronous evaluation: TRUE
[16:18:42.776] Local evaluation: TRUE
[16:18:42.776] Environment: R_GlobalEnv
[16:18:42.776] Capture standard output: TRUE
[16:18:42.776] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.776] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.776] Packages: <none>
[16:18:42.776] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.776] Resolved: TRUE
[16:18:42.776] Value: <not collected>
[16:18:42.776] Conditions captured: <none>
[16:18:42.776] Early signaling: FALSE
[16:18:42.776] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.776] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.793] Chunk #1 of 2 ... DONE
[16:18:42.793] Chunk #2 of 2 ...
[16:18:42.793]  - Finding globals in '...' for chunk #2 ...
[16:18:42.793] getGlobalsAndPackages() ...
[16:18:42.794] Searching for globals...
[16:18:42.795] 
[16:18:42.795] Searching for globals ... DONE
[16:18:42.795] - globals: [0] <none>
[16:18:42.795] getGlobalsAndPackages() ... DONE
[16:18:42.795]    + additional globals found: [n=0] 
[16:18:42.795]    + additional namespaces needed: [n=0] 
[16:18:42.796]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:42.796]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:42.796]  - seeds: <none>
[16:18:42.796]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.797] getGlobalsAndPackages() ...
[16:18:42.797] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.797] Resolving globals: FALSE
[16:18:42.798] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[16:18:42.799] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[16:18:42.800] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.800] 
[16:18:42.800] getGlobalsAndPackages() ... DONE
[16:18:42.801] run() for ‘Future’ ...
[16:18:42.801] - state: ‘created’
[16:18:42.801] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.807] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.807]   - Field: ‘label’
[16:18:42.807]   - Field: ‘local’
[16:18:42.808]   - Field: ‘owner’
[16:18:42.808]   - Field: ‘envir’
[16:18:42.808]   - Field: ‘workers’
[16:18:42.808]   - Field: ‘packages’
[16:18:42.808]   - Field: ‘gc’
[16:18:42.808]   - Field: ‘job’
[16:18:42.808]   - Field: ‘conditions’
[16:18:42.809]   - Field: ‘expr’
[16:18:42.809]   - Field: ‘uuid’
[16:18:42.809]   - Field: ‘seed’
[16:18:42.809]   - Field: ‘version’
[16:18:42.809]   - Field: ‘result’
[16:18:42.809]   - Field: ‘asynchronous’
[16:18:42.809]   - Field: ‘calls’
[16:18:42.810]   - Field: ‘globals’
[16:18:42.810]   - Field: ‘stdout’
[16:18:42.810]   - Field: ‘earlySignal’
[16:18:42.810]   - Field: ‘lazy’
[16:18:42.810]   - Field: ‘state’
[16:18:42.811] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.811] - Launch lazy future ...
[16:18:42.811] Packages needed by the future expression (n = 0): <none>
[16:18:42.811] Packages needed by future strategies (n = 0): <none>
[16:18:42.812] {
[16:18:42.812]     {
[16:18:42.812]         {
[16:18:42.812]             ...future.startTime <- base::Sys.time()
[16:18:42.812]             {
[16:18:42.812]                 {
[16:18:42.812]                   {
[16:18:42.812]                     {
[16:18:42.812]                       base::local({
[16:18:42.812]                         has_future <- base::requireNamespace("future", 
[16:18:42.812]                           quietly = TRUE)
[16:18:42.812]                         if (has_future) {
[16:18:42.812]                           ns <- base::getNamespace("future")
[16:18:42.812]                           version <- ns[[".package"]][["version"]]
[16:18:42.812]                           if (is.null(version)) 
[16:18:42.812]                             version <- utils::packageVersion("future")
[16:18:42.812]                         }
[16:18:42.812]                         else {
[16:18:42.812]                           version <- NULL
[16:18:42.812]                         }
[16:18:42.812]                         if (!has_future || version < "1.8.0") {
[16:18:42.812]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.812]                             "", base::R.version$version.string), 
[16:18:42.812]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.812]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.812]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.812]                               "release", "version")], collapse = " "), 
[16:18:42.812]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.812]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.812]                             info)
[16:18:42.812]                           info <- base::paste(info, collapse = "; ")
[16:18:42.812]                           if (!has_future) {
[16:18:42.812]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.812]                               info)
[16:18:42.812]                           }
[16:18:42.812]                           else {
[16:18:42.812]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.812]                               info, version)
[16:18:42.812]                           }
[16:18:42.812]                           base::stop(msg)
[16:18:42.812]                         }
[16:18:42.812]                       })
[16:18:42.812]                     }
[16:18:42.812]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.812]                     base::options(mc.cores = 1L)
[16:18:42.812]                   }
[16:18:42.812]                   ...future.strategy.old <- future::plan("list")
[16:18:42.812]                   options(future.plan = NULL)
[16:18:42.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.812]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.812]                 }
[16:18:42.812]                 ...future.workdir <- getwd()
[16:18:42.812]             }
[16:18:42.812]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.812]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.812]         }
[16:18:42.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.812]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:42.812]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.812]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.812]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.812]             base::names(...future.oldOptions))
[16:18:42.812]     }
[16:18:42.812]     if (FALSE) {
[16:18:42.812]     }
[16:18:42.812]     else {
[16:18:42.812]         if (TRUE) {
[16:18:42.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.812]                 open = "w")
[16:18:42.812]         }
[16:18:42.812]         else {
[16:18:42.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.812]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.812]         }
[16:18:42.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.812]             base::sink(type = "output", split = FALSE)
[16:18:42.812]             base::close(...future.stdout)
[16:18:42.812]         }, add = TRUE)
[16:18:42.812]     }
[16:18:42.812]     ...future.frame <- base::sys.nframe()
[16:18:42.812]     ...future.conditions <- base::list()
[16:18:42.812]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.812]     if (FALSE) {
[16:18:42.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.812]     }
[16:18:42.812]     ...future.result <- base::tryCatch({
[16:18:42.812]         base::withCallingHandlers({
[16:18:42.812]             ...future.value <- base::withVisible(base::local({
[16:18:42.812]                 withCallingHandlers({
[16:18:42.812]                   {
[16:18:42.812]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.812]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.812]                       ...future.globals.maxSize)) {
[16:18:42.812]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.812]                       on.exit(options(oopts), add = TRUE)
[16:18:42.812]                     }
[16:18:42.812]                     {
[16:18:42.812]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.812]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.812]                         USE.NAMES = FALSE)
[16:18:42.812]                       do.call(mapply, args = args)
[16:18:42.812]                     }
[16:18:42.812]                   }
[16:18:42.812]                 }, immediateCondition = function(cond) {
[16:18:42.812]                   save_rds <- function (object, pathname, ...) 
[16:18:42.812]                   {
[16:18:42.812]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.812]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.812]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.812]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.812]                         fi_tmp[["mtime"]])
[16:18:42.812]                     }
[16:18:42.812]                     tryCatch({
[16:18:42.812]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.812]                     }, error = function(ex) {
[16:18:42.812]                       msg <- conditionMessage(ex)
[16:18:42.812]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.812]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.812]                         fi_tmp[["mtime"]], msg)
[16:18:42.812]                       ex$message <- msg
[16:18:42.812]                       stop(ex)
[16:18:42.812]                     })
[16:18:42.812]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.812]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.812]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.812]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.812]                       fi <- file.info(pathname)
[16:18:42.812]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.812]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.812]                         fi[["size"]], fi[["mtime"]])
[16:18:42.812]                       stop(msg)
[16:18:42.812]                     }
[16:18:42.812]                     invisible(pathname)
[16:18:42.812]                   }
[16:18:42.812]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.812]                     rootPath = tempdir()) 
[16:18:42.812]                   {
[16:18:42.812]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.812]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.812]                       tmpdir = path, fileext = ".rds")
[16:18:42.812]                     save_rds(obj, file)
[16:18:42.812]                   }
[16:18:42.812]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.812]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.812]                   {
[16:18:42.812]                     inherits <- base::inherits
[16:18:42.812]                     invokeRestart <- base::invokeRestart
[16:18:42.812]                     is.null <- base::is.null
[16:18:42.812]                     muffled <- FALSE
[16:18:42.812]                     if (inherits(cond, "message")) {
[16:18:42.812]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.812]                       if (muffled) 
[16:18:42.812]                         invokeRestart("muffleMessage")
[16:18:42.812]                     }
[16:18:42.812]                     else if (inherits(cond, "warning")) {
[16:18:42.812]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.812]                       if (muffled) 
[16:18:42.812]                         invokeRestart("muffleWarning")
[16:18:42.812]                     }
[16:18:42.812]                     else if (inherits(cond, "condition")) {
[16:18:42.812]                       if (!is.null(pattern)) {
[16:18:42.812]                         computeRestarts <- base::computeRestarts
[16:18:42.812]                         grepl <- base::grepl
[16:18:42.812]                         restarts <- computeRestarts(cond)
[16:18:42.812]                         for (restart in restarts) {
[16:18:42.812]                           name <- restart$name
[16:18:42.812]                           if (is.null(name)) 
[16:18:42.812]                             next
[16:18:42.812]                           if (!grepl(pattern, name)) 
[16:18:42.812]                             next
[16:18:42.812]                           invokeRestart(restart)
[16:18:42.812]                           muffled <- TRUE
[16:18:42.812]                           break
[16:18:42.812]                         }
[16:18:42.812]                       }
[16:18:42.812]                     }
[16:18:42.812]                     invisible(muffled)
[16:18:42.812]                   }
[16:18:42.812]                   muffleCondition(cond)
[16:18:42.812]                 })
[16:18:42.812]             }))
[16:18:42.812]             future::FutureResult(value = ...future.value$value, 
[16:18:42.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.812]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.812]                     ...future.globalenv.names))
[16:18:42.812]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.812]         }, condition = base::local({
[16:18:42.812]             c <- base::c
[16:18:42.812]             inherits <- base::inherits
[16:18:42.812]             invokeRestart <- base::invokeRestart
[16:18:42.812]             length <- base::length
[16:18:42.812]             list <- base::list
[16:18:42.812]             seq.int <- base::seq.int
[16:18:42.812]             signalCondition <- base::signalCondition
[16:18:42.812]             sys.calls <- base::sys.calls
[16:18:42.812]             `[[` <- base::`[[`
[16:18:42.812]             `+` <- base::`+`
[16:18:42.812]             `<<-` <- base::`<<-`
[16:18:42.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.812]                   3L)]
[16:18:42.812]             }
[16:18:42.812]             function(cond) {
[16:18:42.812]                 is_error <- inherits(cond, "error")
[16:18:42.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.812]                   NULL)
[16:18:42.812]                 if (is_error) {
[16:18:42.812]                   sessionInformation <- function() {
[16:18:42.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.812]                       search = base::search(), system = base::Sys.info())
[16:18:42.812]                   }
[16:18:42.812]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.812]                     cond$call), session = sessionInformation(), 
[16:18:42.812]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.812]                   signalCondition(cond)
[16:18:42.812]                 }
[16:18:42.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.812]                 "immediateCondition"))) {
[16:18:42.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.812]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.812]                   if (TRUE && !signal) {
[16:18:42.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.812]                     {
[16:18:42.812]                       inherits <- base::inherits
[16:18:42.812]                       invokeRestart <- base::invokeRestart
[16:18:42.812]                       is.null <- base::is.null
[16:18:42.812]                       muffled <- FALSE
[16:18:42.812]                       if (inherits(cond, "message")) {
[16:18:42.812]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.812]                         if (muffled) 
[16:18:42.812]                           invokeRestart("muffleMessage")
[16:18:42.812]                       }
[16:18:42.812]                       else if (inherits(cond, "warning")) {
[16:18:42.812]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.812]                         if (muffled) 
[16:18:42.812]                           invokeRestart("muffleWarning")
[16:18:42.812]                       }
[16:18:42.812]                       else if (inherits(cond, "condition")) {
[16:18:42.812]                         if (!is.null(pattern)) {
[16:18:42.812]                           computeRestarts <- base::computeRestarts
[16:18:42.812]                           grepl <- base::grepl
[16:18:42.812]                           restarts <- computeRestarts(cond)
[16:18:42.812]                           for (restart in restarts) {
[16:18:42.812]                             name <- restart$name
[16:18:42.812]                             if (is.null(name)) 
[16:18:42.812]                               next
[16:18:42.812]                             if (!grepl(pattern, name)) 
[16:18:42.812]                               next
[16:18:42.812]                             invokeRestart(restart)
[16:18:42.812]                             muffled <- TRUE
[16:18:42.812]                             break
[16:18:42.812]                           }
[16:18:42.812]                         }
[16:18:42.812]                       }
[16:18:42.812]                       invisible(muffled)
[16:18:42.812]                     }
[16:18:42.812]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.812]                   }
[16:18:42.812]                 }
[16:18:42.812]                 else {
[16:18:42.812]                   if (TRUE) {
[16:18:42.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.812]                     {
[16:18:42.812]                       inherits <- base::inherits
[16:18:42.812]                       invokeRestart <- base::invokeRestart
[16:18:42.812]                       is.null <- base::is.null
[16:18:42.812]                       muffled <- FALSE
[16:18:42.812]                       if (inherits(cond, "message")) {
[16:18:42.812]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.812]                         if (muffled) 
[16:18:42.812]                           invokeRestart("muffleMessage")
[16:18:42.812]                       }
[16:18:42.812]                       else if (inherits(cond, "warning")) {
[16:18:42.812]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.812]                         if (muffled) 
[16:18:42.812]                           invokeRestart("muffleWarning")
[16:18:42.812]                       }
[16:18:42.812]                       else if (inherits(cond, "condition")) {
[16:18:42.812]                         if (!is.null(pattern)) {
[16:18:42.812]                           computeRestarts <- base::computeRestarts
[16:18:42.812]                           grepl <- base::grepl
[16:18:42.812]                           restarts <- computeRestarts(cond)
[16:18:42.812]                           for (restart in restarts) {
[16:18:42.812]                             name <- restart$name
[16:18:42.812]                             if (is.null(name)) 
[16:18:42.812]                               next
[16:18:42.812]                             if (!grepl(pattern, name)) 
[16:18:42.812]                               next
[16:18:42.812]                             invokeRestart(restart)
[16:18:42.812]                             muffled <- TRUE
[16:18:42.812]                             break
[16:18:42.812]                           }
[16:18:42.812]                         }
[16:18:42.812]                       }
[16:18:42.812]                       invisible(muffled)
[16:18:42.812]                     }
[16:18:42.812]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.812]                   }
[16:18:42.812]                 }
[16:18:42.812]             }
[16:18:42.812]         }))
[16:18:42.812]     }, error = function(ex) {
[16:18:42.812]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.812]                 ...future.rng), started = ...future.startTime, 
[16:18:42.812]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.812]             version = "1.8"), class = "FutureResult")
[16:18:42.812]     }, finally = {
[16:18:42.812]         if (!identical(...future.workdir, getwd())) 
[16:18:42.812]             setwd(...future.workdir)
[16:18:42.812]         {
[16:18:42.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.812]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.812]             }
[16:18:42.812]             base::options(...future.oldOptions)
[16:18:42.812]             if (.Platform$OS.type == "windows") {
[16:18:42.812]                 old_names <- names(...future.oldEnvVars)
[16:18:42.812]                 envs <- base::Sys.getenv()
[16:18:42.812]                 names <- names(envs)
[16:18:42.812]                 common <- intersect(names, old_names)
[16:18:42.812]                 added <- setdiff(names, old_names)
[16:18:42.812]                 removed <- setdiff(old_names, names)
[16:18:42.812]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.812]                   envs[common]]
[16:18:42.812]                 NAMES <- toupper(changed)
[16:18:42.812]                 args <- list()
[16:18:42.812]                 for (kk in seq_along(NAMES)) {
[16:18:42.812]                   name <- changed[[kk]]
[16:18:42.812]                   NAME <- NAMES[[kk]]
[16:18:42.812]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.812]                     next
[16:18:42.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.812]                 }
[16:18:42.812]                 NAMES <- toupper(added)
[16:18:42.812]                 for (kk in seq_along(NAMES)) {
[16:18:42.812]                   name <- added[[kk]]
[16:18:42.812]                   NAME <- NAMES[[kk]]
[16:18:42.812]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.812]                     next
[16:18:42.812]                   args[[name]] <- ""
[16:18:42.812]                 }
[16:18:42.812]                 NAMES <- toupper(removed)
[16:18:42.812]                 for (kk in seq_along(NAMES)) {
[16:18:42.812]                   name <- removed[[kk]]
[16:18:42.812]                   NAME <- NAMES[[kk]]
[16:18:42.812]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.812]                     next
[16:18:42.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.812]                 }
[16:18:42.812]                 if (length(args) > 0) 
[16:18:42.812]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.812]             }
[16:18:42.812]             else {
[16:18:42.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.812]             }
[16:18:42.812]             {
[16:18:42.812]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.812]                   0L) {
[16:18:42.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.812]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.812]                   base::options(opts)
[16:18:42.812]                 }
[16:18:42.812]                 {
[16:18:42.812]                   {
[16:18:42.812]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.812]                     NULL
[16:18:42.812]                   }
[16:18:42.812]                   options(future.plan = NULL)
[16:18:42.812]                   if (is.na(NA_character_)) 
[16:18:42.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.812]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.812]                     .init = FALSE)
[16:18:42.812]                 }
[16:18:42.812]             }
[16:18:42.812]         }
[16:18:42.812]     })
[16:18:42.812]     if (TRUE) {
[16:18:42.812]         base::sink(type = "output", split = FALSE)
[16:18:42.812]         if (TRUE) {
[16:18:42.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.812]         }
[16:18:42.812]         else {
[16:18:42.812]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.812]         }
[16:18:42.812]         base::close(...future.stdout)
[16:18:42.812]         ...future.stdout <- NULL
[16:18:42.812]     }
[16:18:42.812]     ...future.result$conditions <- ...future.conditions
[16:18:42.812]     ...future.result$finished <- base::Sys.time()
[16:18:42.812]     ...future.result
[16:18:42.812] }
[16:18:42.815] assign_globals() ...
[16:18:42.815] List of 5
[16:18:42.815]  $ ...future.FUN            :function (x, y)  
[16:18:42.815]  $ MoreArgs                 :List of 1
[16:18:42.815]   ..$ y: int [1:2] 3 4
[16:18:42.815]  $ ...future.elements_ii    :List of 1
[16:18:42.815]   ..$ x:List of 1
[16:18:42.815]   .. ..$ : int 2
[16:18:42.815]  $ ...future.seeds_ii       : NULL
[16:18:42.815]  $ ...future.globals.maxSize: NULL
[16:18:42.815]  - attr(*, "where")=List of 5
[16:18:42.815]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.815]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.815]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.815]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.815]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.815]  - attr(*, "resolved")= logi FALSE
[16:18:42.815]  - attr(*, "total_size")= num 1816
[16:18:42.815]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.815]  - attr(*, "already-done")= logi TRUE
[16:18:42.821] - reassign environment for ‘...future.FUN’
[16:18:42.821] - copied ‘...future.FUN’ to environment
[16:18:42.821] - copied ‘MoreArgs’ to environment
[16:18:42.822] - copied ‘...future.elements_ii’ to environment
[16:18:42.822] - copied ‘...future.seeds_ii’ to environment
[16:18:42.822] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.822] assign_globals() ... done
[16:18:42.822] requestCore(): workers = 2
[16:18:42.825] MulticoreFuture started
[16:18:42.825] - Launch lazy future ... done
[16:18:42.825] run() for ‘MulticoreFuture’ ... done
[16:18:42.825] Created future:
[16:18:42.826] plan(): Setting new future strategy stack:
[16:18:42.826] List of future strategies:
[16:18:42.826] 1. sequential:
[16:18:42.826]    - args: function (..., envir = parent.frame())
[16:18:42.826]    - tweaked: FALSE
[16:18:42.826]    - call: NULL
[16:18:42.827] plan(): nbrOfWorkers() = 1
[16:18:42.829] plan(): Setting new future strategy stack:
[16:18:42.829] List of future strategies:
[16:18:42.829] 1. multicore:
[16:18:42.829]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.829]    - tweaked: FALSE
[16:18:42.829]    - call: plan(strategy)
[16:18:42.826] MulticoreFuture:
[16:18:42.826] Label: ‘future_mapply-2’
[16:18:42.826] Expression:
[16:18:42.826] {
[16:18:42.826]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.826]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.826]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.826]         on.exit(options(oopts), add = TRUE)
[16:18:42.826]     }
[16:18:42.826]     {
[16:18:42.826]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:42.826]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.826]         do.call(mapply, args = args)
[16:18:42.826]     }
[16:18:42.826] }
[16:18:42.826] Lazy evaluation: FALSE
[16:18:42.826] Asynchronous evaluation: TRUE
[16:18:42.826] Local evaluation: TRUE
[16:18:42.826] Environment: R_GlobalEnv
[16:18:42.826] Capture standard output: TRUE
[16:18:42.826] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.826] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.826] Packages: <none>
[16:18:42.826] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:42.826] Resolved: FALSE
[16:18:42.826] Value: <not collected>
[16:18:42.826] Conditions captured: <none>
[16:18:42.826] Early signaling: FALSE
[16:18:42.826] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.826] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.838] Chunk #2 of 2 ... DONE
[16:18:42.839] Launching 2 futures (chunks) ... DONE
[16:18:42.839] Resolving 2 futures (chunks) ...
[16:18:42.839] resolve() on list ...
[16:18:42.839]  recursive: 0
[16:18:42.840]  length: 2
[16:18:42.840] 
[16:18:42.840] Future #1
[16:18:42.840] result() for MulticoreFuture ...
[16:18:42.841] plan(): nbrOfWorkers() = 2
[16:18:42.845] result() for MulticoreFuture ...
[16:18:42.845] result() for MulticoreFuture ... done
[16:18:42.845] result() for MulticoreFuture ... done
[16:18:42.846] result() for MulticoreFuture ...
[16:18:42.846] result() for MulticoreFuture ... done
[16:18:42.847] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:42.847] - nx: 2
[16:18:42.847] - relay: TRUE
[16:18:42.848] - stdout: TRUE
[16:18:42.848] - signal: TRUE
[16:18:42.848] - resignal: FALSE
[16:18:42.849] - force: TRUE
[16:18:42.849] - relayed: [n=2] FALSE, FALSE
[16:18:42.849] - queued futures: [n=2] FALSE, FALSE
[16:18:42.849]  - until=1
[16:18:42.850]  - relaying element #1
[16:18:42.850] result() for MulticoreFuture ...
[16:18:42.850] result() for MulticoreFuture ... done
[16:18:42.850] result() for MulticoreFuture ...
[16:18:42.851] result() for MulticoreFuture ... done
[16:18:42.851] result() for MulticoreFuture ...
[16:18:42.851] result() for MulticoreFuture ... done
[16:18:42.852] result() for MulticoreFuture ...
[16:18:42.852] result() for MulticoreFuture ... done
[16:18:42.852] - relayed: [n=2] TRUE, FALSE
[16:18:42.852] - queued futures: [n=2] TRUE, FALSE
[16:18:42.852] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:42.853]  length: 1 (resolved future 1)
[16:18:42.853] Future #2
[16:18:42.853] result() for MulticoreFuture ...
[16:18:42.854] result() for MulticoreFuture ...
[16:18:42.855] result() for MulticoreFuture ... done
[16:18:42.855] result() for MulticoreFuture ... done
[16:18:42.855] result() for MulticoreFuture ...
[16:18:42.855] result() for MulticoreFuture ... done
[16:18:42.856] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:42.856] - nx: 2
[16:18:42.856] - relay: TRUE
[16:18:42.856] - stdout: TRUE
[16:18:42.857] - signal: TRUE
[16:18:42.857] - resignal: FALSE
[16:18:42.857] - force: TRUE
[16:18:42.857] - relayed: [n=2] TRUE, FALSE
[16:18:42.857] - queued futures: [n=2] TRUE, FALSE
[16:18:42.858]  - until=2
[16:18:42.858]  - relaying element #2
[16:18:42.858] result() for MulticoreFuture ...
[16:18:42.858] result() for MulticoreFuture ... done
[16:18:42.858] result() for MulticoreFuture ...
[16:18:42.858] result() for MulticoreFuture ... done
[16:18:42.859] result() for MulticoreFuture ...
[16:18:42.859] result() for MulticoreFuture ... done
[16:18:42.859] result() for MulticoreFuture ...
[16:18:42.859] result() for MulticoreFuture ... done
[16:18:42.859] - relayed: [n=2] TRUE, TRUE
[16:18:42.859] - queued futures: [n=2] TRUE, TRUE
[16:18:42.859] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:42.859]  length: 0 (resolved future 2)
[16:18:42.860] Relaying remaining futures
[16:18:42.860] signalConditionsASAP(NULL, pos=0) ...
[16:18:42.860] - nx: 2
[16:18:42.860] - relay: TRUE
[16:18:42.860] - stdout: TRUE
[16:18:42.860] - signal: TRUE
[16:18:42.860] - resignal: FALSE
[16:18:42.860] - force: TRUE
[16:18:42.860] - relayed: [n=2] TRUE, TRUE
[16:18:42.861] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:42.861] - relayed: [n=2] TRUE, TRUE
[16:18:42.861] - queued futures: [n=2] TRUE, TRUE
[16:18:42.861] signalConditionsASAP(NULL, pos=0) ... done
[16:18:42.861] resolve() on list ... DONE
[16:18:42.861] result() for MulticoreFuture ...
[16:18:42.861] result() for MulticoreFuture ... done
[16:18:42.861] result() for MulticoreFuture ...
[16:18:42.862] result() for MulticoreFuture ... done
[16:18:42.862] result() for MulticoreFuture ...
[16:18:42.862] result() for MulticoreFuture ... done
[16:18:42.862] result() for MulticoreFuture ...
[16:18:42.862] result() for MulticoreFuture ... done
[16:18:42.862]  - Number of value chunks collected: 2
[16:18:42.862] Resolving 2 futures (chunks) ... DONE
[16:18:42.862] Reducing values from 2 chunks ...
[16:18:42.863]  - Number of values collected after concatenation: 2
[16:18:42.863]  - Number of values expected: 2
[16:18:42.863] Reducing values from 2 chunks ... DONE
[16:18:42.863] future_mapply() ... DONE
[16:18:42.863] future_mapply() ...
[16:18:42.863] Generating random seeds ...
[16:18:42.863] Generating random seed streams for 2 elements ...
[16:18:42.863] Generating random seed streams for 2 elements ... DONE
[16:18:42.864] Generating random seeds ... DONE
[16:18:42.864] Will set RNG state on exit: 10407, 1706010716, 685712127, 788975707, 227942610, 1997775507, -909439414
[16:18:42.868] Number of chunks: 2
[16:18:42.868] getGlobalsAndPackagesXApply() ...
[16:18:42.868]  - future.globals: TRUE
[16:18:42.868] getGlobalsAndPackages() ...
[16:18:42.868] Searching for globals...
[16:18:42.870] - globals found: [1] ‘FUN’
[16:18:42.870] Searching for globals ... DONE
[16:18:42.870] Resolving globals: FALSE
[16:18:42.870] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[16:18:42.871] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[16:18:42.871] - globals: [1] ‘FUN’
[16:18:42.871] 
[16:18:42.871] getGlobalsAndPackages() ... DONE
[16:18:42.871]  - globals found/used: [n=1] ‘FUN’
[16:18:42.871]  - needed namespaces: [n=0] 
[16:18:42.871] Finding globals ... DONE
[16:18:42.871] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:42.872] List of 2
[16:18:42.872]  $ ...future.FUN:function (x, y)  
[16:18:42.872]  $ MoreArgs     :List of 1
[16:18:42.872]   ..$ y: int [1:2] 3 4
[16:18:42.872]  - attr(*, "where")=List of 2
[16:18:42.872]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:42.872]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:42.872]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.872]  - attr(*, "resolved")= logi FALSE
[16:18:42.872]  - attr(*, "total_size")= num NA
[16:18:42.875] Packages to be attached in all futures: [n=0] 
[16:18:42.875] getGlobalsAndPackagesXApply() ... DONE
[16:18:42.875] Number of futures (= number of chunks): 2
[16:18:42.875] Launching 2 futures (chunks) ...
[16:18:42.875] Chunk #1 of 2 ...
[16:18:42.878]  - Finding globals in '...' for chunk #1 ...
[16:18:42.878] getGlobalsAndPackages() ...
[16:18:42.878] Searching for globals...
[16:18:42.879] 
[16:18:42.879] Searching for globals ... DONE
[16:18:42.879] - globals: [0] <none>
[16:18:42.879] getGlobalsAndPackages() ... DONE
[16:18:42.879]    + additional globals found: [n=0] 
[16:18:42.879]    + additional namespaces needed: [n=0] 
[16:18:42.879]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:42.879]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:42.880]  - seeds: [1] <seeds>
[16:18:42.880]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.880] getGlobalsAndPackages() ...
[16:18:42.880] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.880] Resolving globals: FALSE
[16:18:42.881] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[16:18:42.881] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[16:18:42.881] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.881] 
[16:18:42.882] getGlobalsAndPackages() ... DONE
[16:18:42.882] run() for ‘Future’ ...
[16:18:42.882] - state: ‘created’
[16:18:42.882] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.887] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.887] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.887]   - Field: ‘label’
[16:18:42.887]   - Field: ‘local’
[16:18:42.887]   - Field: ‘owner’
[16:18:42.888]   - Field: ‘envir’
[16:18:42.888]   - Field: ‘workers’
[16:18:42.888]   - Field: ‘packages’
[16:18:42.888]   - Field: ‘gc’
[16:18:42.888]   - Field: ‘job’
[16:18:42.888]   - Field: ‘conditions’
[16:18:42.888]   - Field: ‘expr’
[16:18:42.888]   - Field: ‘uuid’
[16:18:42.889]   - Field: ‘seed’
[16:18:42.889]   - Field: ‘version’
[16:18:42.889]   - Field: ‘result’
[16:18:42.889]   - Field: ‘asynchronous’
[16:18:42.889]   - Field: ‘calls’
[16:18:42.889]   - Field: ‘globals’
[16:18:42.889]   - Field: ‘stdout’
[16:18:42.889]   - Field: ‘earlySignal’
[16:18:42.889]   - Field: ‘lazy’
[16:18:42.889]   - Field: ‘state’
[16:18:42.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.890] - Launch lazy future ...
[16:18:42.890] Packages needed by the future expression (n = 0): <none>
[16:18:42.890] Packages needed by future strategies (n = 0): <none>
[16:18:42.891] {
[16:18:42.891]     {
[16:18:42.891]         {
[16:18:42.891]             ...future.startTime <- base::Sys.time()
[16:18:42.891]             {
[16:18:42.891]                 {
[16:18:42.891]                   {
[16:18:42.891]                     {
[16:18:42.891]                       base::local({
[16:18:42.891]                         has_future <- base::requireNamespace("future", 
[16:18:42.891]                           quietly = TRUE)
[16:18:42.891]                         if (has_future) {
[16:18:42.891]                           ns <- base::getNamespace("future")
[16:18:42.891]                           version <- ns[[".package"]][["version"]]
[16:18:42.891]                           if (is.null(version)) 
[16:18:42.891]                             version <- utils::packageVersion("future")
[16:18:42.891]                         }
[16:18:42.891]                         else {
[16:18:42.891]                           version <- NULL
[16:18:42.891]                         }
[16:18:42.891]                         if (!has_future || version < "1.8.0") {
[16:18:42.891]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.891]                             "", base::R.version$version.string), 
[16:18:42.891]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.891]                               "release", "version")], collapse = " "), 
[16:18:42.891]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.891]                             info)
[16:18:42.891]                           info <- base::paste(info, collapse = "; ")
[16:18:42.891]                           if (!has_future) {
[16:18:42.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.891]                               info)
[16:18:42.891]                           }
[16:18:42.891]                           else {
[16:18:42.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.891]                               info, version)
[16:18:42.891]                           }
[16:18:42.891]                           base::stop(msg)
[16:18:42.891]                         }
[16:18:42.891]                       })
[16:18:42.891]                     }
[16:18:42.891]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.891]                     base::options(mc.cores = 1L)
[16:18:42.891]                   }
[16:18:42.891]                   ...future.strategy.old <- future::plan("list")
[16:18:42.891]                   options(future.plan = NULL)
[16:18:42.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.891]                 }
[16:18:42.891]                 ...future.workdir <- getwd()
[16:18:42.891]             }
[16:18:42.891]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.891]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.891]         }
[16:18:42.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.891]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:42.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.891]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.891]             base::names(...future.oldOptions))
[16:18:42.891]     }
[16:18:42.891]     if (FALSE) {
[16:18:42.891]     }
[16:18:42.891]     else {
[16:18:42.891]         if (TRUE) {
[16:18:42.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.891]                 open = "w")
[16:18:42.891]         }
[16:18:42.891]         else {
[16:18:42.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.891]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.891]         }
[16:18:42.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.891]             base::sink(type = "output", split = FALSE)
[16:18:42.891]             base::close(...future.stdout)
[16:18:42.891]         }, add = TRUE)
[16:18:42.891]     }
[16:18:42.891]     ...future.frame <- base::sys.nframe()
[16:18:42.891]     ...future.conditions <- base::list()
[16:18:42.891]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.891]     if (FALSE) {
[16:18:42.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.891]     }
[16:18:42.891]     ...future.result <- base::tryCatch({
[16:18:42.891]         base::withCallingHandlers({
[16:18:42.891]             ...future.value <- base::withVisible(base::local({
[16:18:42.891]                 withCallingHandlers({
[16:18:42.891]                   {
[16:18:42.891]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.891]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.891]                       ...future.globals.maxSize)) {
[16:18:42.891]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.891]                       on.exit(options(oopts), add = TRUE)
[16:18:42.891]                     }
[16:18:42.891]                     {
[16:18:42.891]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:42.891]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[16:18:42.891]                           envir = globalenv(), inherits = FALSE)
[16:18:42.891]                         ...future.FUN(...)
[16:18:42.891]                       }
[16:18:42.891]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:42.891]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:42.891]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.891]                         USE.NAMES = FALSE)
[16:18:42.891]                       do.call(mapply, args = args)
[16:18:42.891]                     }
[16:18:42.891]                   }
[16:18:42.891]                 }, immediateCondition = function(cond) {
[16:18:42.891]                   save_rds <- function (object, pathname, ...) 
[16:18:42.891]                   {
[16:18:42.891]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.891]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.891]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.891]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.891]                         fi_tmp[["mtime"]])
[16:18:42.891]                     }
[16:18:42.891]                     tryCatch({
[16:18:42.891]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.891]                     }, error = function(ex) {
[16:18:42.891]                       msg <- conditionMessage(ex)
[16:18:42.891]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.891]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.891]                         fi_tmp[["mtime"]], msg)
[16:18:42.891]                       ex$message <- msg
[16:18:42.891]                       stop(ex)
[16:18:42.891]                     })
[16:18:42.891]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.891]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.891]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.891]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.891]                       fi <- file.info(pathname)
[16:18:42.891]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.891]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.891]                         fi[["size"]], fi[["mtime"]])
[16:18:42.891]                       stop(msg)
[16:18:42.891]                     }
[16:18:42.891]                     invisible(pathname)
[16:18:42.891]                   }
[16:18:42.891]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.891]                     rootPath = tempdir()) 
[16:18:42.891]                   {
[16:18:42.891]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.891]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.891]                       tmpdir = path, fileext = ".rds")
[16:18:42.891]                     save_rds(obj, file)
[16:18:42.891]                   }
[16:18:42.891]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.891]                   {
[16:18:42.891]                     inherits <- base::inherits
[16:18:42.891]                     invokeRestart <- base::invokeRestart
[16:18:42.891]                     is.null <- base::is.null
[16:18:42.891]                     muffled <- FALSE
[16:18:42.891]                     if (inherits(cond, "message")) {
[16:18:42.891]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.891]                       if (muffled) 
[16:18:42.891]                         invokeRestart("muffleMessage")
[16:18:42.891]                     }
[16:18:42.891]                     else if (inherits(cond, "warning")) {
[16:18:42.891]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.891]                       if (muffled) 
[16:18:42.891]                         invokeRestart("muffleWarning")
[16:18:42.891]                     }
[16:18:42.891]                     else if (inherits(cond, "condition")) {
[16:18:42.891]                       if (!is.null(pattern)) {
[16:18:42.891]                         computeRestarts <- base::computeRestarts
[16:18:42.891]                         grepl <- base::grepl
[16:18:42.891]                         restarts <- computeRestarts(cond)
[16:18:42.891]                         for (restart in restarts) {
[16:18:42.891]                           name <- restart$name
[16:18:42.891]                           if (is.null(name)) 
[16:18:42.891]                             next
[16:18:42.891]                           if (!grepl(pattern, name)) 
[16:18:42.891]                             next
[16:18:42.891]                           invokeRestart(restart)
[16:18:42.891]                           muffled <- TRUE
[16:18:42.891]                           break
[16:18:42.891]                         }
[16:18:42.891]                       }
[16:18:42.891]                     }
[16:18:42.891]                     invisible(muffled)
[16:18:42.891]                   }
[16:18:42.891]                   muffleCondition(cond)
[16:18:42.891]                 })
[16:18:42.891]             }))
[16:18:42.891]             future::FutureResult(value = ...future.value$value, 
[16:18:42.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.891]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.891]                     ...future.globalenv.names))
[16:18:42.891]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.891]         }, condition = base::local({
[16:18:42.891]             c <- base::c
[16:18:42.891]             inherits <- base::inherits
[16:18:42.891]             invokeRestart <- base::invokeRestart
[16:18:42.891]             length <- base::length
[16:18:42.891]             list <- base::list
[16:18:42.891]             seq.int <- base::seq.int
[16:18:42.891]             signalCondition <- base::signalCondition
[16:18:42.891]             sys.calls <- base::sys.calls
[16:18:42.891]             `[[` <- base::`[[`
[16:18:42.891]             `+` <- base::`+`
[16:18:42.891]             `<<-` <- base::`<<-`
[16:18:42.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.891]                   3L)]
[16:18:42.891]             }
[16:18:42.891]             function(cond) {
[16:18:42.891]                 is_error <- inherits(cond, "error")
[16:18:42.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.891]                   NULL)
[16:18:42.891]                 if (is_error) {
[16:18:42.891]                   sessionInformation <- function() {
[16:18:42.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.891]                       search = base::search(), system = base::Sys.info())
[16:18:42.891]                   }
[16:18:42.891]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.891]                     cond$call), session = sessionInformation(), 
[16:18:42.891]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.891]                   signalCondition(cond)
[16:18:42.891]                 }
[16:18:42.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.891]                 "immediateCondition"))) {
[16:18:42.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.891]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.891]                   if (TRUE && !signal) {
[16:18:42.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.891]                     {
[16:18:42.891]                       inherits <- base::inherits
[16:18:42.891]                       invokeRestart <- base::invokeRestart
[16:18:42.891]                       is.null <- base::is.null
[16:18:42.891]                       muffled <- FALSE
[16:18:42.891]                       if (inherits(cond, "message")) {
[16:18:42.891]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.891]                         if (muffled) 
[16:18:42.891]                           invokeRestart("muffleMessage")
[16:18:42.891]                       }
[16:18:42.891]                       else if (inherits(cond, "warning")) {
[16:18:42.891]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.891]                         if (muffled) 
[16:18:42.891]                           invokeRestart("muffleWarning")
[16:18:42.891]                       }
[16:18:42.891]                       else if (inherits(cond, "condition")) {
[16:18:42.891]                         if (!is.null(pattern)) {
[16:18:42.891]                           computeRestarts <- base::computeRestarts
[16:18:42.891]                           grepl <- base::grepl
[16:18:42.891]                           restarts <- computeRestarts(cond)
[16:18:42.891]                           for (restart in restarts) {
[16:18:42.891]                             name <- restart$name
[16:18:42.891]                             if (is.null(name)) 
[16:18:42.891]                               next
[16:18:42.891]                             if (!grepl(pattern, name)) 
[16:18:42.891]                               next
[16:18:42.891]                             invokeRestart(restart)
[16:18:42.891]                             muffled <- TRUE
[16:18:42.891]                             break
[16:18:42.891]                           }
[16:18:42.891]                         }
[16:18:42.891]                       }
[16:18:42.891]                       invisible(muffled)
[16:18:42.891]                     }
[16:18:42.891]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.891]                   }
[16:18:42.891]                 }
[16:18:42.891]                 else {
[16:18:42.891]                   if (TRUE) {
[16:18:42.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.891]                     {
[16:18:42.891]                       inherits <- base::inherits
[16:18:42.891]                       invokeRestart <- base::invokeRestart
[16:18:42.891]                       is.null <- base::is.null
[16:18:42.891]                       muffled <- FALSE
[16:18:42.891]                       if (inherits(cond, "message")) {
[16:18:42.891]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.891]                         if (muffled) 
[16:18:42.891]                           invokeRestart("muffleMessage")
[16:18:42.891]                       }
[16:18:42.891]                       else if (inherits(cond, "warning")) {
[16:18:42.891]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.891]                         if (muffled) 
[16:18:42.891]                           invokeRestart("muffleWarning")
[16:18:42.891]                       }
[16:18:42.891]                       else if (inherits(cond, "condition")) {
[16:18:42.891]                         if (!is.null(pattern)) {
[16:18:42.891]                           computeRestarts <- base::computeRestarts
[16:18:42.891]                           grepl <- base::grepl
[16:18:42.891]                           restarts <- computeRestarts(cond)
[16:18:42.891]                           for (restart in restarts) {
[16:18:42.891]                             name <- restart$name
[16:18:42.891]                             if (is.null(name)) 
[16:18:42.891]                               next
[16:18:42.891]                             if (!grepl(pattern, name)) 
[16:18:42.891]                               next
[16:18:42.891]                             invokeRestart(restart)
[16:18:42.891]                             muffled <- TRUE
[16:18:42.891]                             break
[16:18:42.891]                           }
[16:18:42.891]                         }
[16:18:42.891]                       }
[16:18:42.891]                       invisible(muffled)
[16:18:42.891]                     }
[16:18:42.891]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.891]                   }
[16:18:42.891]                 }
[16:18:42.891]             }
[16:18:42.891]         }))
[16:18:42.891]     }, error = function(ex) {
[16:18:42.891]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.891]                 ...future.rng), started = ...future.startTime, 
[16:18:42.891]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.891]             version = "1.8"), class = "FutureResult")
[16:18:42.891]     }, finally = {
[16:18:42.891]         if (!identical(...future.workdir, getwd())) 
[16:18:42.891]             setwd(...future.workdir)
[16:18:42.891]         {
[16:18:42.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.891]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.891]             }
[16:18:42.891]             base::options(...future.oldOptions)
[16:18:42.891]             if (.Platform$OS.type == "windows") {
[16:18:42.891]                 old_names <- names(...future.oldEnvVars)
[16:18:42.891]                 envs <- base::Sys.getenv()
[16:18:42.891]                 names <- names(envs)
[16:18:42.891]                 common <- intersect(names, old_names)
[16:18:42.891]                 added <- setdiff(names, old_names)
[16:18:42.891]                 removed <- setdiff(old_names, names)
[16:18:42.891]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.891]                   envs[common]]
[16:18:42.891]                 NAMES <- toupper(changed)
[16:18:42.891]                 args <- list()
[16:18:42.891]                 for (kk in seq_along(NAMES)) {
[16:18:42.891]                   name <- changed[[kk]]
[16:18:42.891]                   NAME <- NAMES[[kk]]
[16:18:42.891]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.891]                     next
[16:18:42.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.891]                 }
[16:18:42.891]                 NAMES <- toupper(added)
[16:18:42.891]                 for (kk in seq_along(NAMES)) {
[16:18:42.891]                   name <- added[[kk]]
[16:18:42.891]                   NAME <- NAMES[[kk]]
[16:18:42.891]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.891]                     next
[16:18:42.891]                   args[[name]] <- ""
[16:18:42.891]                 }
[16:18:42.891]                 NAMES <- toupper(removed)
[16:18:42.891]                 for (kk in seq_along(NAMES)) {
[16:18:42.891]                   name <- removed[[kk]]
[16:18:42.891]                   NAME <- NAMES[[kk]]
[16:18:42.891]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.891]                     next
[16:18:42.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.891]                 }
[16:18:42.891]                 if (length(args) > 0) 
[16:18:42.891]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.891]             }
[16:18:42.891]             else {
[16:18:42.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.891]             }
[16:18:42.891]             {
[16:18:42.891]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.891]                   0L) {
[16:18:42.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.891]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.891]                   base::options(opts)
[16:18:42.891]                 }
[16:18:42.891]                 {
[16:18:42.891]                   {
[16:18:42.891]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.891]                     NULL
[16:18:42.891]                   }
[16:18:42.891]                   options(future.plan = NULL)
[16:18:42.891]                   if (is.na(NA_character_)) 
[16:18:42.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.891]                     .init = FALSE)
[16:18:42.891]                 }
[16:18:42.891]             }
[16:18:42.891]         }
[16:18:42.891]     })
[16:18:42.891]     if (TRUE) {
[16:18:42.891]         base::sink(type = "output", split = FALSE)
[16:18:42.891]         if (TRUE) {
[16:18:42.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.891]         }
[16:18:42.891]         else {
[16:18:42.891]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.891]         }
[16:18:42.891]         base::close(...future.stdout)
[16:18:42.891]         ...future.stdout <- NULL
[16:18:42.891]     }
[16:18:42.891]     ...future.result$conditions <- ...future.conditions
[16:18:42.891]     ...future.result$finished <- base::Sys.time()
[16:18:42.891]     ...future.result
[16:18:42.891] }
[16:18:42.893] assign_globals() ...
[16:18:42.893] List of 5
[16:18:42.893]  $ ...future.FUN            :function (x, y)  
[16:18:42.893]  $ MoreArgs                 :List of 1
[16:18:42.893]   ..$ y: int [1:2] 3 4
[16:18:42.893]  $ ...future.elements_ii    :List of 1
[16:18:42.893]   ..$ x:List of 1
[16:18:42.893]   .. ..$ : int 1
[16:18:42.893]  $ ...future.seeds_ii       :List of 1
[16:18:42.893]   ..$ : int [1:7] 10407 -1291181225 -1274997864 1246859407 1331684716 -1051072268 -134169161
[16:18:42.893]  $ ...future.globals.maxSize: NULL
[16:18:42.893]  - attr(*, "where")=List of 5
[16:18:42.893]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.893]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.893]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.893]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.893]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.893]  - attr(*, "resolved")= logi FALSE
[16:18:42.893]  - attr(*, "total_size")= num 1896
[16:18:42.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.893]  - attr(*, "already-done")= logi TRUE
[16:18:42.899] - reassign environment for ‘...future.FUN’
[16:18:42.899] - copied ‘...future.FUN’ to environment
[16:18:42.899] - copied ‘MoreArgs’ to environment
[16:18:42.899] - copied ‘...future.elements_ii’ to environment
[16:18:42.899] - copied ‘...future.seeds_ii’ to environment
[16:18:42.900] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.900] assign_globals() ... done
[16:18:42.900] requestCore(): workers = 2
[16:18:42.902] MulticoreFuture started
[16:18:42.903] - Launch lazy future ... done
[16:18:42.903] run() for ‘MulticoreFuture’ ... done
[16:18:42.903] Created future:
[16:18:42.903] plan(): Setting new future strategy stack:
[16:18:42.904] List of future strategies:
[16:18:42.904] 1. sequential:
[16:18:42.904]    - args: function (..., envir = parent.frame())
[16:18:42.904]    - tweaked: FALSE
[16:18:42.904]    - call: NULL
[16:18:42.905] plan(): nbrOfWorkers() = 1
[16:18:42.907] plan(): Setting new future strategy stack:
[16:18:42.907] List of future strategies:
[16:18:42.907] 1. multicore:
[16:18:42.907]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.907]    - tweaked: FALSE
[16:18:42.907]    - call: plan(strategy)
[16:18:42.903] MulticoreFuture:
[16:18:42.903] Label: ‘future_mapply-1’
[16:18:42.903] Expression:
[16:18:42.903] {
[16:18:42.903]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.903]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.903]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.903]         on.exit(options(oopts), add = TRUE)
[16:18:42.903]     }
[16:18:42.903]     {
[16:18:42.903]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:42.903]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[16:18:42.903]                 inherits = FALSE)
[16:18:42.903]             ...future.FUN(...)
[16:18:42.903]         }
[16:18:42.903]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:42.903]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:42.903]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.903]         do.call(mapply, args = args)
[16:18:42.903]     }
[16:18:42.903] }
[16:18:42.903] Lazy evaluation: FALSE
[16:18:42.903] Asynchronous evaluation: TRUE
[16:18:42.903] Local evaluation: TRUE
[16:18:42.903] Environment: R_GlobalEnv
[16:18:42.903] Capture standard output: TRUE
[16:18:42.903] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.903] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.903] Packages: <none>
[16:18:42.903] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:18:42.903] Resolved: FALSE
[16:18:42.903] Value: <not collected>
[16:18:42.903] Conditions captured: <none>
[16:18:42.903] Early signaling: FALSE
[16:18:42.903] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.903] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.917] Chunk #1 of 2 ... DONE
[16:18:42.917] Chunk #2 of 2 ...
[16:18:42.917]  - Finding globals in '...' for chunk #2 ...
[16:18:42.917] getGlobalsAndPackages() ...
[16:18:42.917] Searching for globals...
[16:18:42.918] 
[16:18:42.918] Searching for globals ... DONE
[16:18:42.918] - globals: [0] <none>
[16:18:42.918] plan(): nbrOfWorkers() = 2
[16:18:42.918] getGlobalsAndPackages() ... DONE
[16:18:42.922]    + additional globals found: [n=0] 
[16:18:42.922]    + additional namespaces needed: [n=0] 
[16:18:42.922]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:42.922]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:42.923]  - seeds: [1] <seeds>
[16:18:42.923]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.924] getGlobalsAndPackages() ...
[16:18:42.924] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.925] Resolving globals: FALSE
[16:18:42.926] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[16:18:42.927] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[16:18:42.928] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:42.928] 
[16:18:42.928] getGlobalsAndPackages() ... DONE
[16:18:42.929] run() for ‘Future’ ...
[16:18:42.929] - state: ‘created’
[16:18:42.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:42.935] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:42.936]   - Field: ‘label’
[16:18:42.936]   - Field: ‘local’
[16:18:42.936]   - Field: ‘owner’
[16:18:42.937]   - Field: ‘envir’
[16:18:42.937]   - Field: ‘workers’
[16:18:42.937]   - Field: ‘packages’
[16:18:42.937]   - Field: ‘gc’
[16:18:42.938]   - Field: ‘job’
[16:18:42.938]   - Field: ‘conditions’
[16:18:42.938]   - Field: ‘expr’
[16:18:42.938]   - Field: ‘uuid’
[16:18:42.938]   - Field: ‘seed’
[16:18:42.939]   - Field: ‘version’
[16:18:42.939]   - Field: ‘result’
[16:18:42.939]   - Field: ‘asynchronous’
[16:18:42.939]   - Field: ‘calls’
[16:18:42.939]   - Field: ‘globals’
[16:18:42.939]   - Field: ‘stdout’
[16:18:42.939]   - Field: ‘earlySignal’
[16:18:42.940]   - Field: ‘lazy’
[16:18:42.940]   - Field: ‘state’
[16:18:42.940] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:42.940] - Launch lazy future ...
[16:18:42.941] Packages needed by the future expression (n = 0): <none>
[16:18:42.941] Packages needed by future strategies (n = 0): <none>
[16:18:42.941] {
[16:18:42.941]     {
[16:18:42.941]         {
[16:18:42.941]             ...future.startTime <- base::Sys.time()
[16:18:42.941]             {
[16:18:42.941]                 {
[16:18:42.941]                   {
[16:18:42.941]                     {
[16:18:42.941]                       base::local({
[16:18:42.941]                         has_future <- base::requireNamespace("future", 
[16:18:42.941]                           quietly = TRUE)
[16:18:42.941]                         if (has_future) {
[16:18:42.941]                           ns <- base::getNamespace("future")
[16:18:42.941]                           version <- ns[[".package"]][["version"]]
[16:18:42.941]                           if (is.null(version)) 
[16:18:42.941]                             version <- utils::packageVersion("future")
[16:18:42.941]                         }
[16:18:42.941]                         else {
[16:18:42.941]                           version <- NULL
[16:18:42.941]                         }
[16:18:42.941]                         if (!has_future || version < "1.8.0") {
[16:18:42.941]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:42.941]                             "", base::R.version$version.string), 
[16:18:42.941]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:42.941]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:42.941]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:42.941]                               "release", "version")], collapse = " "), 
[16:18:42.941]                             hostname = base::Sys.info()[["nodename"]])
[16:18:42.941]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:42.941]                             info)
[16:18:42.941]                           info <- base::paste(info, collapse = "; ")
[16:18:42.941]                           if (!has_future) {
[16:18:42.941]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:42.941]                               info)
[16:18:42.941]                           }
[16:18:42.941]                           else {
[16:18:42.941]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:42.941]                               info, version)
[16:18:42.941]                           }
[16:18:42.941]                           base::stop(msg)
[16:18:42.941]                         }
[16:18:42.941]                       })
[16:18:42.941]                     }
[16:18:42.941]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:42.941]                     base::options(mc.cores = 1L)
[16:18:42.941]                   }
[16:18:42.941]                   ...future.strategy.old <- future::plan("list")
[16:18:42.941]                   options(future.plan = NULL)
[16:18:42.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:42.941]                 }
[16:18:42.941]                 ...future.workdir <- getwd()
[16:18:42.941]             }
[16:18:42.941]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:42.941]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:42.941]         }
[16:18:42.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:42.941]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:42.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:42.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:42.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:42.941]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:42.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:42.941]             base::names(...future.oldOptions))
[16:18:42.941]     }
[16:18:42.941]     if (FALSE) {
[16:18:42.941]     }
[16:18:42.941]     else {
[16:18:42.941]         if (TRUE) {
[16:18:42.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:42.941]                 open = "w")
[16:18:42.941]         }
[16:18:42.941]         else {
[16:18:42.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:42.941]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:42.941]         }
[16:18:42.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:42.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:42.941]             base::sink(type = "output", split = FALSE)
[16:18:42.941]             base::close(...future.stdout)
[16:18:42.941]         }, add = TRUE)
[16:18:42.941]     }
[16:18:42.941]     ...future.frame <- base::sys.nframe()
[16:18:42.941]     ...future.conditions <- base::list()
[16:18:42.941]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:42.941]     if (FALSE) {
[16:18:42.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:42.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:42.941]     }
[16:18:42.941]     ...future.result <- base::tryCatch({
[16:18:42.941]         base::withCallingHandlers({
[16:18:42.941]             ...future.value <- base::withVisible(base::local({
[16:18:42.941]                 withCallingHandlers({
[16:18:42.941]                   {
[16:18:42.941]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.941]                     if (!identical(...future.globals.maxSize.org, 
[16:18:42.941]                       ...future.globals.maxSize)) {
[16:18:42.941]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.941]                       on.exit(options(oopts), add = TRUE)
[16:18:42.941]                     }
[16:18:42.941]                     {
[16:18:42.941]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:42.941]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[16:18:42.941]                           envir = globalenv(), inherits = FALSE)
[16:18:42.941]                         ...future.FUN(...)
[16:18:42.941]                       }
[16:18:42.941]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:42.941]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:42.941]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:42.941]                         USE.NAMES = FALSE)
[16:18:42.941]                       do.call(mapply, args = args)
[16:18:42.941]                     }
[16:18:42.941]                   }
[16:18:42.941]                 }, immediateCondition = function(cond) {
[16:18:42.941]                   save_rds <- function (object, pathname, ...) 
[16:18:42.941]                   {
[16:18:42.941]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:42.941]                     if (file_test("-f", pathname_tmp)) {
[16:18:42.941]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.941]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:42.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.941]                         fi_tmp[["mtime"]])
[16:18:42.941]                     }
[16:18:42.941]                     tryCatch({
[16:18:42.941]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:42.941]                     }, error = function(ex) {
[16:18:42.941]                       msg <- conditionMessage(ex)
[16:18:42.941]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.941]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:42.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.941]                         fi_tmp[["mtime"]], msg)
[16:18:42.941]                       ex$message <- msg
[16:18:42.941]                       stop(ex)
[16:18:42.941]                     })
[16:18:42.941]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:42.941]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:42.941]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:42.941]                       fi_tmp <- file.info(pathname_tmp)
[16:18:42.941]                       fi <- file.info(pathname)
[16:18:42.941]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:42.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:42.941]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:42.941]                         fi[["size"]], fi[["mtime"]])
[16:18:42.941]                       stop(msg)
[16:18:42.941]                     }
[16:18:42.941]                     invisible(pathname)
[16:18:42.941]                   }
[16:18:42.941]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:42.941]                     rootPath = tempdir()) 
[16:18:42.941]                   {
[16:18:42.941]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:42.941]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:42.941]                       tmpdir = path, fileext = ".rds")
[16:18:42.941]                     save_rds(obj, file)
[16:18:42.941]                   }
[16:18:42.941]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:42.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.941]                   {
[16:18:42.941]                     inherits <- base::inherits
[16:18:42.941]                     invokeRestart <- base::invokeRestart
[16:18:42.941]                     is.null <- base::is.null
[16:18:42.941]                     muffled <- FALSE
[16:18:42.941]                     if (inherits(cond, "message")) {
[16:18:42.941]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:42.941]                       if (muffled) 
[16:18:42.941]                         invokeRestart("muffleMessage")
[16:18:42.941]                     }
[16:18:42.941]                     else if (inherits(cond, "warning")) {
[16:18:42.941]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:42.941]                       if (muffled) 
[16:18:42.941]                         invokeRestart("muffleWarning")
[16:18:42.941]                     }
[16:18:42.941]                     else if (inherits(cond, "condition")) {
[16:18:42.941]                       if (!is.null(pattern)) {
[16:18:42.941]                         computeRestarts <- base::computeRestarts
[16:18:42.941]                         grepl <- base::grepl
[16:18:42.941]                         restarts <- computeRestarts(cond)
[16:18:42.941]                         for (restart in restarts) {
[16:18:42.941]                           name <- restart$name
[16:18:42.941]                           if (is.null(name)) 
[16:18:42.941]                             next
[16:18:42.941]                           if (!grepl(pattern, name)) 
[16:18:42.941]                             next
[16:18:42.941]                           invokeRestart(restart)
[16:18:42.941]                           muffled <- TRUE
[16:18:42.941]                           break
[16:18:42.941]                         }
[16:18:42.941]                       }
[16:18:42.941]                     }
[16:18:42.941]                     invisible(muffled)
[16:18:42.941]                   }
[16:18:42.941]                   muffleCondition(cond)
[16:18:42.941]                 })
[16:18:42.941]             }))
[16:18:42.941]             future::FutureResult(value = ...future.value$value, 
[16:18:42.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.941]                   ...future.rng), globalenv = if (FALSE) 
[16:18:42.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:42.941]                     ...future.globalenv.names))
[16:18:42.941]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:42.941]         }, condition = base::local({
[16:18:42.941]             c <- base::c
[16:18:42.941]             inherits <- base::inherits
[16:18:42.941]             invokeRestart <- base::invokeRestart
[16:18:42.941]             length <- base::length
[16:18:42.941]             list <- base::list
[16:18:42.941]             seq.int <- base::seq.int
[16:18:42.941]             signalCondition <- base::signalCondition
[16:18:42.941]             sys.calls <- base::sys.calls
[16:18:42.941]             `[[` <- base::`[[`
[16:18:42.941]             `+` <- base::`+`
[16:18:42.941]             `<<-` <- base::`<<-`
[16:18:42.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:42.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:42.941]                   3L)]
[16:18:42.941]             }
[16:18:42.941]             function(cond) {
[16:18:42.941]                 is_error <- inherits(cond, "error")
[16:18:42.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:42.941]                   NULL)
[16:18:42.941]                 if (is_error) {
[16:18:42.941]                   sessionInformation <- function() {
[16:18:42.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:42.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:42.941]                       search = base::search(), system = base::Sys.info())
[16:18:42.941]                   }
[16:18:42.941]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:42.941]                     cond$call), session = sessionInformation(), 
[16:18:42.941]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:42.941]                   signalCondition(cond)
[16:18:42.941]                 }
[16:18:42.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:42.941]                 "immediateCondition"))) {
[16:18:42.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:42.941]                   ...future.conditions[[length(...future.conditions) + 
[16:18:42.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:42.941]                   if (TRUE && !signal) {
[16:18:42.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.941]                     {
[16:18:42.941]                       inherits <- base::inherits
[16:18:42.941]                       invokeRestart <- base::invokeRestart
[16:18:42.941]                       is.null <- base::is.null
[16:18:42.941]                       muffled <- FALSE
[16:18:42.941]                       if (inherits(cond, "message")) {
[16:18:42.941]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.941]                         if (muffled) 
[16:18:42.941]                           invokeRestart("muffleMessage")
[16:18:42.941]                       }
[16:18:42.941]                       else if (inherits(cond, "warning")) {
[16:18:42.941]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.941]                         if (muffled) 
[16:18:42.941]                           invokeRestart("muffleWarning")
[16:18:42.941]                       }
[16:18:42.941]                       else if (inherits(cond, "condition")) {
[16:18:42.941]                         if (!is.null(pattern)) {
[16:18:42.941]                           computeRestarts <- base::computeRestarts
[16:18:42.941]                           grepl <- base::grepl
[16:18:42.941]                           restarts <- computeRestarts(cond)
[16:18:42.941]                           for (restart in restarts) {
[16:18:42.941]                             name <- restart$name
[16:18:42.941]                             if (is.null(name)) 
[16:18:42.941]                               next
[16:18:42.941]                             if (!grepl(pattern, name)) 
[16:18:42.941]                               next
[16:18:42.941]                             invokeRestart(restart)
[16:18:42.941]                             muffled <- TRUE
[16:18:42.941]                             break
[16:18:42.941]                           }
[16:18:42.941]                         }
[16:18:42.941]                       }
[16:18:42.941]                       invisible(muffled)
[16:18:42.941]                     }
[16:18:42.941]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.941]                   }
[16:18:42.941]                 }
[16:18:42.941]                 else {
[16:18:42.941]                   if (TRUE) {
[16:18:42.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:42.941]                     {
[16:18:42.941]                       inherits <- base::inherits
[16:18:42.941]                       invokeRestart <- base::invokeRestart
[16:18:42.941]                       is.null <- base::is.null
[16:18:42.941]                       muffled <- FALSE
[16:18:42.941]                       if (inherits(cond, "message")) {
[16:18:42.941]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:42.941]                         if (muffled) 
[16:18:42.941]                           invokeRestart("muffleMessage")
[16:18:42.941]                       }
[16:18:42.941]                       else if (inherits(cond, "warning")) {
[16:18:42.941]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:42.941]                         if (muffled) 
[16:18:42.941]                           invokeRestart("muffleWarning")
[16:18:42.941]                       }
[16:18:42.941]                       else if (inherits(cond, "condition")) {
[16:18:42.941]                         if (!is.null(pattern)) {
[16:18:42.941]                           computeRestarts <- base::computeRestarts
[16:18:42.941]                           grepl <- base::grepl
[16:18:42.941]                           restarts <- computeRestarts(cond)
[16:18:42.941]                           for (restart in restarts) {
[16:18:42.941]                             name <- restart$name
[16:18:42.941]                             if (is.null(name)) 
[16:18:42.941]                               next
[16:18:42.941]                             if (!grepl(pattern, name)) 
[16:18:42.941]                               next
[16:18:42.941]                             invokeRestart(restart)
[16:18:42.941]                             muffled <- TRUE
[16:18:42.941]                             break
[16:18:42.941]                           }
[16:18:42.941]                         }
[16:18:42.941]                       }
[16:18:42.941]                       invisible(muffled)
[16:18:42.941]                     }
[16:18:42.941]                     muffleCondition(cond, pattern = "^muffle")
[16:18:42.941]                   }
[16:18:42.941]                 }
[16:18:42.941]             }
[16:18:42.941]         }))
[16:18:42.941]     }, error = function(ex) {
[16:18:42.941]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:42.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:42.941]                 ...future.rng), started = ...future.startTime, 
[16:18:42.941]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:42.941]             version = "1.8"), class = "FutureResult")
[16:18:42.941]     }, finally = {
[16:18:42.941]         if (!identical(...future.workdir, getwd())) 
[16:18:42.941]             setwd(...future.workdir)
[16:18:42.941]         {
[16:18:42.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:42.941]                 ...future.oldOptions$nwarnings <- NULL
[16:18:42.941]             }
[16:18:42.941]             base::options(...future.oldOptions)
[16:18:42.941]             if (.Platform$OS.type == "windows") {
[16:18:42.941]                 old_names <- names(...future.oldEnvVars)
[16:18:42.941]                 envs <- base::Sys.getenv()
[16:18:42.941]                 names <- names(envs)
[16:18:42.941]                 common <- intersect(names, old_names)
[16:18:42.941]                 added <- setdiff(names, old_names)
[16:18:42.941]                 removed <- setdiff(old_names, names)
[16:18:42.941]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:42.941]                   envs[common]]
[16:18:42.941]                 NAMES <- toupper(changed)
[16:18:42.941]                 args <- list()
[16:18:42.941]                 for (kk in seq_along(NAMES)) {
[16:18:42.941]                   name <- changed[[kk]]
[16:18:42.941]                   NAME <- NAMES[[kk]]
[16:18:42.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.941]                     next
[16:18:42.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.941]                 }
[16:18:42.941]                 NAMES <- toupper(added)
[16:18:42.941]                 for (kk in seq_along(NAMES)) {
[16:18:42.941]                   name <- added[[kk]]
[16:18:42.941]                   NAME <- NAMES[[kk]]
[16:18:42.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.941]                     next
[16:18:42.941]                   args[[name]] <- ""
[16:18:42.941]                 }
[16:18:42.941]                 NAMES <- toupper(removed)
[16:18:42.941]                 for (kk in seq_along(NAMES)) {
[16:18:42.941]                   name <- removed[[kk]]
[16:18:42.941]                   NAME <- NAMES[[kk]]
[16:18:42.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:42.941]                     next
[16:18:42.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:42.941]                 }
[16:18:42.941]                 if (length(args) > 0) 
[16:18:42.941]                   base::do.call(base::Sys.setenv, args = args)
[16:18:42.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:42.941]             }
[16:18:42.941]             else {
[16:18:42.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:42.941]             }
[16:18:42.941]             {
[16:18:42.941]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:42.941]                   0L) {
[16:18:42.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:42.941]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:42.941]                   base::options(opts)
[16:18:42.941]                 }
[16:18:42.941]                 {
[16:18:42.941]                   {
[16:18:42.941]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:42.941]                     NULL
[16:18:42.941]                   }
[16:18:42.941]                   options(future.plan = NULL)
[16:18:42.941]                   if (is.na(NA_character_)) 
[16:18:42.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:42.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:42.941]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:42.941]                     .init = FALSE)
[16:18:42.941]                 }
[16:18:42.941]             }
[16:18:42.941]         }
[16:18:42.941]     })
[16:18:42.941]     if (TRUE) {
[16:18:42.941]         base::sink(type = "output", split = FALSE)
[16:18:42.941]         if (TRUE) {
[16:18:42.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:42.941]         }
[16:18:42.941]         else {
[16:18:42.941]             ...future.result["stdout"] <- base::list(NULL)
[16:18:42.941]         }
[16:18:42.941]         base::close(...future.stdout)
[16:18:42.941]         ...future.stdout <- NULL
[16:18:42.941]     }
[16:18:42.941]     ...future.result$conditions <- ...future.conditions
[16:18:42.941]     ...future.result$finished <- base::Sys.time()
[16:18:42.941]     ...future.result
[16:18:42.941] }
[16:18:42.945] assign_globals() ...
[16:18:42.945] List of 5
[16:18:42.945]  $ ...future.FUN            :function (x, y)  
[16:18:42.945]  $ MoreArgs                 :List of 1
[16:18:42.945]   ..$ y: int [1:2] 3 4
[16:18:42.945]  $ ...future.elements_ii    :List of 1
[16:18:42.945]   ..$ x:List of 1
[16:18:42.945]   .. ..$ : int 2
[16:18:42.945]  $ ...future.seeds_ii       :List of 1
[16:18:42.945]   ..$ : int [1:7] 10407 1937383189 -1199309665 -327078635 1017004800 -2027055308 406916297
[16:18:42.945]  $ ...future.globals.maxSize: NULL
[16:18:42.945]  - attr(*, "where")=List of 5
[16:18:42.945]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:42.945]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:42.945]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:42.945]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:42.945]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:42.945]  - attr(*, "resolved")= logi FALSE
[16:18:42.945]  - attr(*, "total_size")= num 1896
[16:18:42.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:42.945]  - attr(*, "already-done")= logi TRUE
[16:18:42.952] - reassign environment for ‘...future.FUN’
[16:18:42.952] - copied ‘...future.FUN’ to environment
[16:18:42.952] - copied ‘MoreArgs’ to environment
[16:18:42.952] - copied ‘...future.elements_ii’ to environment
[16:18:42.953] - copied ‘...future.seeds_ii’ to environment
[16:18:42.953] - copied ‘...future.globals.maxSize’ to environment
[16:18:42.953] assign_globals() ... done
[16:18:42.953] requestCore(): workers = 2
[16:18:42.955] MulticoreFuture started
[16:18:42.956] - Launch lazy future ... done
[16:18:42.956] run() for ‘MulticoreFuture’ ... done
[16:18:42.956] Created future:
[16:18:42.957] plan(): Setting new future strategy stack:
[16:18:42.957] List of future strategies:
[16:18:42.957] 1. sequential:
[16:18:42.957]    - args: function (..., envir = parent.frame())
[16:18:42.957]    - tweaked: FALSE
[16:18:42.957]    - call: NULL
[16:18:42.958] plan(): nbrOfWorkers() = 1
[16:18:42.960] plan(): Setting new future strategy stack:
[16:18:42.960] List of future strategies:
[16:18:42.960] 1. multicore:
[16:18:42.960]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:42.960]    - tweaked: FALSE
[16:18:42.960]    - call: plan(strategy)
[16:18:42.966] plan(): nbrOfWorkers() = 2
[16:18:42.957] MulticoreFuture:
[16:18:42.957] Label: ‘future_mapply-2’
[16:18:42.957] Expression:
[16:18:42.957] {
[16:18:42.957]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:42.957]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:42.957]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:42.957]         on.exit(options(oopts), add = TRUE)
[16:18:42.957]     }
[16:18:42.957]     {
[16:18:42.957]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:42.957]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[16:18:42.957]                 inherits = FALSE)
[16:18:42.957]             ...future.FUN(...)
[16:18:42.957]         }
[16:18:42.957]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:42.957]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:42.957]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:42.957]         do.call(mapply, args = args)
[16:18:42.957]     }
[16:18:42.957] }
[16:18:42.957] Lazy evaluation: FALSE
[16:18:42.957] Asynchronous evaluation: TRUE
[16:18:42.957] Local evaluation: TRUE
[16:18:42.957] Environment: R_GlobalEnv
[16:18:42.957] Capture standard output: TRUE
[16:18:42.957] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:42.957] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:42.957] Packages: <none>
[16:18:42.957] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:18:42.957] Resolved: TRUE
[16:18:42.957] Value: <not collected>
[16:18:42.957] Conditions captured: <none>
[16:18:42.957] Early signaling: FALSE
[16:18:42.957] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:42.957] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:42.967] Chunk #2 of 2 ... DONE
[16:18:42.967] Launching 2 futures (chunks) ... DONE
[16:18:42.967] Resolving 2 futures (chunks) ...
[16:18:42.968] resolve() on list ...
[16:18:42.968]  recursive: 0
[16:18:42.968]  length: 2
[16:18:42.968] 
[16:18:42.968] Future #1
[16:18:42.969] result() for MulticoreFuture ...
[16:18:42.970] result() for MulticoreFuture ...
[16:18:42.970] result() for MulticoreFuture ... done
[16:18:42.970] result() for MulticoreFuture ... done
[16:18:42.970] result() for MulticoreFuture ...
[16:18:42.970] result() for MulticoreFuture ... done
[16:18:42.970] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:42.970] - nx: 2
[16:18:42.971] - relay: TRUE
[16:18:42.975] - stdout: TRUE
[16:18:42.975] - signal: TRUE
[16:18:42.976] - resignal: FALSE
[16:18:42.976] - force: TRUE
[16:18:42.977] - relayed: [n=2] FALSE, FALSE
[16:18:42.977] - queued futures: [n=2] FALSE, FALSE
[16:18:42.977]  - until=1
[16:18:42.978]  - relaying element #1
[16:18:42.978] result() for MulticoreFuture ...
[16:18:42.978] result() for MulticoreFuture ... done
[16:18:42.979] result() for MulticoreFuture ...
[16:18:42.979] result() for MulticoreFuture ... done
[16:18:42.979] result() for MulticoreFuture ...
[16:18:42.980] result() for MulticoreFuture ... done
[16:18:42.980] result() for MulticoreFuture ...
[16:18:42.980] result() for MulticoreFuture ... done
[16:18:42.980] - relayed: [n=2] TRUE, FALSE
[16:18:42.981] - queued futures: [n=2] TRUE, FALSE
[16:18:42.981] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:42.981]  length: 1 (resolved future 1)
[16:18:42.982] Future #2
[16:18:42.982] result() for MulticoreFuture ...
[16:18:42.983] result() for MulticoreFuture ...
[16:18:42.983] result() for MulticoreFuture ... done
[16:18:42.984] result() for MulticoreFuture ... done
[16:18:42.984] result() for MulticoreFuture ...
[16:18:42.984] result() for MulticoreFuture ... done
[16:18:42.985] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:42.985] - nx: 2
[16:18:42.985] - relay: TRUE
[16:18:42.985] - stdout: TRUE
[16:18:42.985] - signal: TRUE
[16:18:42.986] - resignal: FALSE
[16:18:42.986] - force: TRUE
[16:18:42.986] - relayed: [n=2] TRUE, FALSE
[16:18:42.986] - queued futures: [n=2] TRUE, FALSE
[16:18:42.986]  - until=2
[16:18:42.987]  - relaying element #2
[16:18:42.987] result() for MulticoreFuture ...
[16:18:42.987] result() for MulticoreFuture ... done
[16:18:42.987] result() for MulticoreFuture ...
[16:18:42.987] result() for MulticoreFuture ... done
[16:18:42.987] result() for MulticoreFuture ...
[16:18:42.988] result() for MulticoreFuture ... done
[16:18:42.988] result() for MulticoreFuture ...
[16:18:42.988] result() for MulticoreFuture ... done
[16:18:42.988] - relayed: [n=2] TRUE, TRUE
[16:18:42.988] - queued futures: [n=2] TRUE, TRUE
[16:18:42.988] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:42.988]  length: 0 (resolved future 2)
[16:18:42.989] Relaying remaining futures
[16:18:42.989] signalConditionsASAP(NULL, pos=0) ...
[16:18:42.989] - nx: 2
[16:18:42.989] - relay: TRUE
[16:18:42.989] - stdout: TRUE
[16:18:42.989] - signal: TRUE
[16:18:42.989] - resignal: FALSE
[16:18:42.989] - force: TRUE
[16:18:42.989] - relayed: [n=2] TRUE, TRUE
[16:18:42.989] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:42.990] - relayed: [n=2] TRUE, TRUE
[16:18:42.990] - queued futures: [n=2] TRUE, TRUE
[16:18:42.990] signalConditionsASAP(NULL, pos=0) ... done
[16:18:42.990] resolve() on list ... DONE
[16:18:42.990] result() for MulticoreFuture ...
[16:18:42.990] result() for MulticoreFuture ... done
[16:18:42.990] result() for MulticoreFuture ...
[16:18:42.991] result() for MulticoreFuture ... done
[16:18:42.991] result() for MulticoreFuture ...
[16:18:42.991] result() for MulticoreFuture ... done
[16:18:42.991] result() for MulticoreFuture ...
[16:18:42.991] result() for MulticoreFuture ... done
[16:18:42.991]  - Number of value chunks collected: 2
[16:18:42.991] Resolving 2 futures (chunks) ... DONE
[16:18:42.991] Reducing values from 2 chunks ...
[16:18:42.991]  - Number of values collected after concatenation: 2
[16:18:42.992]  - Number of values expected: 2
[16:18:42.992] Reducing values from 2 chunks ... DONE
[16:18:42.992] future_mapply() ... DONE
[16:18:42.992] future_mapply() ...
[16:18:42.997] Number of chunks: 2
[16:18:42.997] getGlobalsAndPackagesXApply() ...
[16:18:42.997]  - future.globals: TRUE
[16:18:42.997] getGlobalsAndPackages() ...
[16:18:42.997] Searching for globals...
[16:18:42.999] - globals found: [1] ‘FUN’
[16:18:42.999] Searching for globals ... DONE
[16:18:42.999] Resolving globals: FALSE
[16:18:42.999] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[16:18:43.000] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[16:18:43.000] - globals: [1] ‘FUN’
[16:18:43.000] 
[16:18:43.000] getGlobalsAndPackages() ... DONE
[16:18:43.000]  - globals found/used: [n=1] ‘FUN’
[16:18:43.000]  - needed namespaces: [n=0] 
[16:18:43.000] Finding globals ... DONE
[16:18:43.001] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:43.001] List of 2
[16:18:43.001]  $ ...future.FUN:function (x, y)  
[16:18:43.001]  $ MoreArgs     :List of 1
[16:18:43.001]   ..$ y: int [1:2] 3 4
[16:18:43.001]  - attr(*, "where")=List of 2
[16:18:43.001]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:43.001]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:43.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.001]  - attr(*, "resolved")= logi FALSE
[16:18:43.001]  - attr(*, "total_size")= num NA
[16:18:43.004] Packages to be attached in all futures: [n=0] 
[16:18:43.004] getGlobalsAndPackagesXApply() ... DONE
[16:18:43.004] Number of futures (= number of chunks): 2
[16:18:43.004] Launching 2 futures (chunks) ...
[16:18:43.004] Chunk #1 of 2 ...
[16:18:43.005]  - Finding globals in '...' for chunk #1 ...
[16:18:43.005] getGlobalsAndPackages() ...
[16:18:43.005] Searching for globals...
[16:18:43.005] 
[16:18:43.005] Searching for globals ... DONE
[16:18:43.005] - globals: [0] <none>
[16:18:43.005] getGlobalsAndPackages() ... DONE
[16:18:43.006]    + additional globals found: [n=0] 
[16:18:43.008]    + additional namespaces needed: [n=0] 
[16:18:43.008]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:43.008]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.009]  - seeds: <none>
[16:18:43.009]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.009] getGlobalsAndPackages() ...
[16:18:43.009] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.009] Resolving globals: FALSE
[16:18:43.010] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[16:18:43.010] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[16:18:43.010] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.010] 
[16:18:43.011] getGlobalsAndPackages() ... DONE
[16:18:43.011] run() for ‘Future’ ...
[16:18:43.011] - state: ‘created’
[16:18:43.011] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.015] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.015] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.016]   - Field: ‘label’
[16:18:43.016]   - Field: ‘local’
[16:18:43.016]   - Field: ‘owner’
[16:18:43.016]   - Field: ‘envir’
[16:18:43.016]   - Field: ‘workers’
[16:18:43.016]   - Field: ‘packages’
[16:18:43.016]   - Field: ‘gc’
[16:18:43.016]   - Field: ‘job’
[16:18:43.017]   - Field: ‘conditions’
[16:18:43.017]   - Field: ‘expr’
[16:18:43.017]   - Field: ‘uuid’
[16:18:43.017]   - Field: ‘seed’
[16:18:43.017]   - Field: ‘version’
[16:18:43.017]   - Field: ‘result’
[16:18:43.017]   - Field: ‘asynchronous’
[16:18:43.017]   - Field: ‘calls’
[16:18:43.017]   - Field: ‘globals’
[16:18:43.017]   - Field: ‘stdout’
[16:18:43.018]   - Field: ‘earlySignal’
[16:18:43.018]   - Field: ‘lazy’
[16:18:43.018]   - Field: ‘state’
[16:18:43.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.018] - Launch lazy future ...
[16:18:43.018] Packages needed by the future expression (n = 0): <none>
[16:18:43.018] Packages needed by future strategies (n = 0): <none>
[16:18:43.019] {
[16:18:43.019]     {
[16:18:43.019]         {
[16:18:43.019]             ...future.startTime <- base::Sys.time()
[16:18:43.019]             {
[16:18:43.019]                 {
[16:18:43.019]                   {
[16:18:43.019]                     {
[16:18:43.019]                       base::local({
[16:18:43.019]                         has_future <- base::requireNamespace("future", 
[16:18:43.019]                           quietly = TRUE)
[16:18:43.019]                         if (has_future) {
[16:18:43.019]                           ns <- base::getNamespace("future")
[16:18:43.019]                           version <- ns[[".package"]][["version"]]
[16:18:43.019]                           if (is.null(version)) 
[16:18:43.019]                             version <- utils::packageVersion("future")
[16:18:43.019]                         }
[16:18:43.019]                         else {
[16:18:43.019]                           version <- NULL
[16:18:43.019]                         }
[16:18:43.019]                         if (!has_future || version < "1.8.0") {
[16:18:43.019]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.019]                             "", base::R.version$version.string), 
[16:18:43.019]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:43.019]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:43.019]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.019]                               "release", "version")], collapse = " "), 
[16:18:43.019]                             hostname = base::Sys.info()[["nodename"]])
[16:18:43.019]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.019]                             info)
[16:18:43.019]                           info <- base::paste(info, collapse = "; ")
[16:18:43.019]                           if (!has_future) {
[16:18:43.019]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.019]                               info)
[16:18:43.019]                           }
[16:18:43.019]                           else {
[16:18:43.019]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.019]                               info, version)
[16:18:43.019]                           }
[16:18:43.019]                           base::stop(msg)
[16:18:43.019]                         }
[16:18:43.019]                       })
[16:18:43.019]                     }
[16:18:43.019]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.019]                     base::options(mc.cores = 1L)
[16:18:43.019]                   }
[16:18:43.019]                   ...future.strategy.old <- future::plan("list")
[16:18:43.019]                   options(future.plan = NULL)
[16:18:43.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.019]                 }
[16:18:43.019]                 ...future.workdir <- getwd()
[16:18:43.019]             }
[16:18:43.019]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.019]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.019]         }
[16:18:43.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.019]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.019]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.019]             base::names(...future.oldOptions))
[16:18:43.019]     }
[16:18:43.019]     if (FALSE) {
[16:18:43.019]     }
[16:18:43.019]     else {
[16:18:43.019]         if (TRUE) {
[16:18:43.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.019]                 open = "w")
[16:18:43.019]         }
[16:18:43.019]         else {
[16:18:43.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.019]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.019]         }
[16:18:43.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.019]             base::sink(type = "output", split = FALSE)
[16:18:43.019]             base::close(...future.stdout)
[16:18:43.019]         }, add = TRUE)
[16:18:43.019]     }
[16:18:43.019]     ...future.frame <- base::sys.nframe()
[16:18:43.019]     ...future.conditions <- base::list()
[16:18:43.019]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.019]     if (FALSE) {
[16:18:43.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.019]     }
[16:18:43.019]     ...future.result <- base::tryCatch({
[16:18:43.019]         base::withCallingHandlers({
[16:18:43.019]             ...future.value <- base::withVisible(base::local({
[16:18:43.019]                 withCallingHandlers({
[16:18:43.019]                   {
[16:18:43.019]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.019]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.019]                       ...future.globals.maxSize)) {
[16:18:43.019]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.019]                       on.exit(options(oopts), add = TRUE)
[16:18:43.019]                     }
[16:18:43.019]                     {
[16:18:43.019]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.019]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.019]                         USE.NAMES = FALSE)
[16:18:43.019]                       do.call(mapply, args = args)
[16:18:43.019]                     }
[16:18:43.019]                   }
[16:18:43.019]                 }, immediateCondition = function(cond) {
[16:18:43.019]                   save_rds <- function (object, pathname, ...) 
[16:18:43.019]                   {
[16:18:43.019]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.019]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.019]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.019]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.019]                         fi_tmp[["mtime"]])
[16:18:43.019]                     }
[16:18:43.019]                     tryCatch({
[16:18:43.019]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.019]                     }, error = function(ex) {
[16:18:43.019]                       msg <- conditionMessage(ex)
[16:18:43.019]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.019]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.019]                         fi_tmp[["mtime"]], msg)
[16:18:43.019]                       ex$message <- msg
[16:18:43.019]                       stop(ex)
[16:18:43.019]                     })
[16:18:43.019]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.019]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.019]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.019]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.019]                       fi <- file.info(pathname)
[16:18:43.019]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.019]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.019]                         fi[["size"]], fi[["mtime"]])
[16:18:43.019]                       stop(msg)
[16:18:43.019]                     }
[16:18:43.019]                     invisible(pathname)
[16:18:43.019]                   }
[16:18:43.019]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.019]                     rootPath = tempdir()) 
[16:18:43.019]                   {
[16:18:43.019]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.019]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.019]                       tmpdir = path, fileext = ".rds")
[16:18:43.019]                     save_rds(obj, file)
[16:18:43.019]                   }
[16:18:43.019]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.019]                   {
[16:18:43.019]                     inherits <- base::inherits
[16:18:43.019]                     invokeRestart <- base::invokeRestart
[16:18:43.019]                     is.null <- base::is.null
[16:18:43.019]                     muffled <- FALSE
[16:18:43.019]                     if (inherits(cond, "message")) {
[16:18:43.019]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.019]                       if (muffled) 
[16:18:43.019]                         invokeRestart("muffleMessage")
[16:18:43.019]                     }
[16:18:43.019]                     else if (inherits(cond, "warning")) {
[16:18:43.019]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.019]                       if (muffled) 
[16:18:43.019]                         invokeRestart("muffleWarning")
[16:18:43.019]                     }
[16:18:43.019]                     else if (inherits(cond, "condition")) {
[16:18:43.019]                       if (!is.null(pattern)) {
[16:18:43.019]                         computeRestarts <- base::computeRestarts
[16:18:43.019]                         grepl <- base::grepl
[16:18:43.019]                         restarts <- computeRestarts(cond)
[16:18:43.019]                         for (restart in restarts) {
[16:18:43.019]                           name <- restart$name
[16:18:43.019]                           if (is.null(name)) 
[16:18:43.019]                             next
[16:18:43.019]                           if (!grepl(pattern, name)) 
[16:18:43.019]                             next
[16:18:43.019]                           invokeRestart(restart)
[16:18:43.019]                           muffled <- TRUE
[16:18:43.019]                           break
[16:18:43.019]                         }
[16:18:43.019]                       }
[16:18:43.019]                     }
[16:18:43.019]                     invisible(muffled)
[16:18:43.019]                   }
[16:18:43.019]                   muffleCondition(cond)
[16:18:43.019]                 })
[16:18:43.019]             }))
[16:18:43.019]             future::FutureResult(value = ...future.value$value, 
[16:18:43.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.019]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.019]                     ...future.globalenv.names))
[16:18:43.019]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.019]         }, condition = base::local({
[16:18:43.019]             c <- base::c
[16:18:43.019]             inherits <- base::inherits
[16:18:43.019]             invokeRestart <- base::invokeRestart
[16:18:43.019]             length <- base::length
[16:18:43.019]             list <- base::list
[16:18:43.019]             seq.int <- base::seq.int
[16:18:43.019]             signalCondition <- base::signalCondition
[16:18:43.019]             sys.calls <- base::sys.calls
[16:18:43.019]             `[[` <- base::`[[`
[16:18:43.019]             `+` <- base::`+`
[16:18:43.019]             `<<-` <- base::`<<-`
[16:18:43.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.019]                   3L)]
[16:18:43.019]             }
[16:18:43.019]             function(cond) {
[16:18:43.019]                 is_error <- inherits(cond, "error")
[16:18:43.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.019]                   NULL)
[16:18:43.019]                 if (is_error) {
[16:18:43.019]                   sessionInformation <- function() {
[16:18:43.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.019]                       search = base::search(), system = base::Sys.info())
[16:18:43.019]                   }
[16:18:43.019]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.019]                     cond$call), session = sessionInformation(), 
[16:18:43.019]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.019]                   signalCondition(cond)
[16:18:43.019]                 }
[16:18:43.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.019]                 "immediateCondition"))) {
[16:18:43.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.019]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.019]                   if (TRUE && !signal) {
[16:18:43.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.019]                     {
[16:18:43.019]                       inherits <- base::inherits
[16:18:43.019]                       invokeRestart <- base::invokeRestart
[16:18:43.019]                       is.null <- base::is.null
[16:18:43.019]                       muffled <- FALSE
[16:18:43.019]                       if (inherits(cond, "message")) {
[16:18:43.019]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.019]                         if (muffled) 
[16:18:43.019]                           invokeRestart("muffleMessage")
[16:18:43.019]                       }
[16:18:43.019]                       else if (inherits(cond, "warning")) {
[16:18:43.019]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.019]                         if (muffled) 
[16:18:43.019]                           invokeRestart("muffleWarning")
[16:18:43.019]                       }
[16:18:43.019]                       else if (inherits(cond, "condition")) {
[16:18:43.019]                         if (!is.null(pattern)) {
[16:18:43.019]                           computeRestarts <- base::computeRestarts
[16:18:43.019]                           grepl <- base::grepl
[16:18:43.019]                           restarts <- computeRestarts(cond)
[16:18:43.019]                           for (restart in restarts) {
[16:18:43.019]                             name <- restart$name
[16:18:43.019]                             if (is.null(name)) 
[16:18:43.019]                               next
[16:18:43.019]                             if (!grepl(pattern, name)) 
[16:18:43.019]                               next
[16:18:43.019]                             invokeRestart(restart)
[16:18:43.019]                             muffled <- TRUE
[16:18:43.019]                             break
[16:18:43.019]                           }
[16:18:43.019]                         }
[16:18:43.019]                       }
[16:18:43.019]                       invisible(muffled)
[16:18:43.019]                     }
[16:18:43.019]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.019]                   }
[16:18:43.019]                 }
[16:18:43.019]                 else {
[16:18:43.019]                   if (TRUE) {
[16:18:43.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.019]                     {
[16:18:43.019]                       inherits <- base::inherits
[16:18:43.019]                       invokeRestart <- base::invokeRestart
[16:18:43.019]                       is.null <- base::is.null
[16:18:43.019]                       muffled <- FALSE
[16:18:43.019]                       if (inherits(cond, "message")) {
[16:18:43.019]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.019]                         if (muffled) 
[16:18:43.019]                           invokeRestart("muffleMessage")
[16:18:43.019]                       }
[16:18:43.019]                       else if (inherits(cond, "warning")) {
[16:18:43.019]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.019]                         if (muffled) 
[16:18:43.019]                           invokeRestart("muffleWarning")
[16:18:43.019]                       }
[16:18:43.019]                       else if (inherits(cond, "condition")) {
[16:18:43.019]                         if (!is.null(pattern)) {
[16:18:43.019]                           computeRestarts <- base::computeRestarts
[16:18:43.019]                           grepl <- base::grepl
[16:18:43.019]                           restarts <- computeRestarts(cond)
[16:18:43.019]                           for (restart in restarts) {
[16:18:43.019]                             name <- restart$name
[16:18:43.019]                             if (is.null(name)) 
[16:18:43.019]                               next
[16:18:43.019]                             if (!grepl(pattern, name)) 
[16:18:43.019]                               next
[16:18:43.019]                             invokeRestart(restart)
[16:18:43.019]                             muffled <- TRUE
[16:18:43.019]                             break
[16:18:43.019]                           }
[16:18:43.019]                         }
[16:18:43.019]                       }
[16:18:43.019]                       invisible(muffled)
[16:18:43.019]                     }
[16:18:43.019]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.019]                   }
[16:18:43.019]                 }
[16:18:43.019]             }
[16:18:43.019]         }))
[16:18:43.019]     }, error = function(ex) {
[16:18:43.019]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.019]                 ...future.rng), started = ...future.startTime, 
[16:18:43.019]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.019]             version = "1.8"), class = "FutureResult")
[16:18:43.019]     }, finally = {
[16:18:43.019]         if (!identical(...future.workdir, getwd())) 
[16:18:43.019]             setwd(...future.workdir)
[16:18:43.019]         {
[16:18:43.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.019]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.019]             }
[16:18:43.019]             base::options(...future.oldOptions)
[16:18:43.019]             if (.Platform$OS.type == "windows") {
[16:18:43.019]                 old_names <- names(...future.oldEnvVars)
[16:18:43.019]                 envs <- base::Sys.getenv()
[16:18:43.019]                 names <- names(envs)
[16:18:43.019]                 common <- intersect(names, old_names)
[16:18:43.019]                 added <- setdiff(names, old_names)
[16:18:43.019]                 removed <- setdiff(old_names, names)
[16:18:43.019]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.019]                   envs[common]]
[16:18:43.019]                 NAMES <- toupper(changed)
[16:18:43.019]                 args <- list()
[16:18:43.019]                 for (kk in seq_along(NAMES)) {
[16:18:43.019]                   name <- changed[[kk]]
[16:18:43.019]                   NAME <- NAMES[[kk]]
[16:18:43.019]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.019]                     next
[16:18:43.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.019]                 }
[16:18:43.019]                 NAMES <- toupper(added)
[16:18:43.019]                 for (kk in seq_along(NAMES)) {
[16:18:43.019]                   name <- added[[kk]]
[16:18:43.019]                   NAME <- NAMES[[kk]]
[16:18:43.019]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.019]                     next
[16:18:43.019]                   args[[name]] <- ""
[16:18:43.019]                 }
[16:18:43.019]                 NAMES <- toupper(removed)
[16:18:43.019]                 for (kk in seq_along(NAMES)) {
[16:18:43.019]                   name <- removed[[kk]]
[16:18:43.019]                   NAME <- NAMES[[kk]]
[16:18:43.019]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.019]                     next
[16:18:43.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.019]                 }
[16:18:43.019]                 if (length(args) > 0) 
[16:18:43.019]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.019]             }
[16:18:43.019]             else {
[16:18:43.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.019]             }
[16:18:43.019]             {
[16:18:43.019]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.019]                   0L) {
[16:18:43.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.019]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.019]                   base::options(opts)
[16:18:43.019]                 }
[16:18:43.019]                 {
[16:18:43.019]                   {
[16:18:43.019]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.019]                     NULL
[16:18:43.019]                   }
[16:18:43.019]                   options(future.plan = NULL)
[16:18:43.019]                   if (is.na(NA_character_)) 
[16:18:43.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.019]                     .init = FALSE)
[16:18:43.019]                 }
[16:18:43.019]             }
[16:18:43.019]         }
[16:18:43.019]     })
[16:18:43.019]     if (TRUE) {
[16:18:43.019]         base::sink(type = "output", split = FALSE)
[16:18:43.019]         if (TRUE) {
[16:18:43.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.019]         }
[16:18:43.019]         else {
[16:18:43.019]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.019]         }
[16:18:43.019]         base::close(...future.stdout)
[16:18:43.019]         ...future.stdout <- NULL
[16:18:43.019]     }
[16:18:43.019]     ...future.result$conditions <- ...future.conditions
[16:18:43.019]     ...future.result$finished <- base::Sys.time()
[16:18:43.019]     ...future.result
[16:18:43.019] }
[16:18:43.021] assign_globals() ...
[16:18:43.021] List of 5
[16:18:43.021]  $ ...future.FUN            :function (x, y)  
[16:18:43.021]  $ MoreArgs                 :List of 1
[16:18:43.021]   ..$ y: int [1:2] 3 4
[16:18:43.021]  $ ...future.elements_ii    :List of 1
[16:18:43.021]   ..$ x:List of 1
[16:18:43.021]   .. ..$ : int 1
[16:18:43.021]  $ ...future.seeds_ii       : NULL
[16:18:43.021]  $ ...future.globals.maxSize: NULL
[16:18:43.021]  - attr(*, "where")=List of 5
[16:18:43.021]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.021]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.021]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.021]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.021]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.021]  - attr(*, "resolved")= logi FALSE
[16:18:43.021]  - attr(*, "total_size")= num 1816
[16:18:43.021]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.021]  - attr(*, "already-done")= logi TRUE
[16:18:43.026] - reassign environment for ‘...future.FUN’
[16:18:43.026] - copied ‘...future.FUN’ to environment
[16:18:43.027] - copied ‘MoreArgs’ to environment
[16:18:43.027] - copied ‘...future.elements_ii’ to environment
[16:18:43.027] - copied ‘...future.seeds_ii’ to environment
[16:18:43.027] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.027] assign_globals() ... done
[16:18:43.027] requestCore(): workers = 2
[16:18:43.029] MulticoreFuture started
[16:18:43.030] - Launch lazy future ... done
[16:18:43.030] run() for ‘MulticoreFuture’ ... done
[16:18:43.030] Created future:
[16:18:43.030] plan(): Setting new future strategy stack:
[16:18:43.031] List of future strategies:
[16:18:43.031] 1. sequential:
[16:18:43.031]    - args: function (..., envir = parent.frame())
[16:18:43.031]    - tweaked: FALSE
[16:18:43.031]    - call: NULL
[16:18:43.032] plan(): nbrOfWorkers() = 1
[16:18:43.034] plan(): Setting new future strategy stack:
[16:18:43.034] List of future strategies:
[16:18:43.034] 1. multicore:
[16:18:43.034]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.034]    - tweaked: FALSE
[16:18:43.034]    - call: plan(strategy)
[16:18:43.039] plan(): nbrOfWorkers() = 2
[16:18:43.031] MulticoreFuture:
[16:18:43.031] Label: ‘future_.mapply-1’
[16:18:43.031] Expression:
[16:18:43.031] {
[16:18:43.031]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.031]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.031]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.031]         on.exit(options(oopts), add = TRUE)
[16:18:43.031]     }
[16:18:43.031]     {
[16:18:43.031]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.031]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.031]         do.call(mapply, args = args)
[16:18:43.031]     }
[16:18:43.031] }
[16:18:43.031] Lazy evaluation: FALSE
[16:18:43.031] Asynchronous evaluation: TRUE
[16:18:43.031] Local evaluation: TRUE
[16:18:43.031] Environment: R_GlobalEnv
[16:18:43.031] Capture standard output: TRUE
[16:18:43.031] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.031] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.031] Packages: <none>
[16:18:43.031] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:43.031] Resolved: TRUE
[16:18:43.031] Value: <not collected>
[16:18:43.031] Conditions captured: <none>
[16:18:43.031] Early signaling: FALSE
[16:18:43.031] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.031] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.040] Chunk #1 of 2 ... DONE
[16:18:43.041] Chunk #2 of 2 ...
[16:18:43.041]  - Finding globals in '...' for chunk #2 ...
[16:18:43.041] getGlobalsAndPackages() ...
[16:18:43.041] Searching for globals...
[16:18:43.042] 
[16:18:43.042] Searching for globals ... DONE
[16:18:43.042] - globals: [0] <none>
[16:18:43.042] getGlobalsAndPackages() ... DONE
[16:18:43.042]    + additional globals found: [n=0] 
[16:18:43.042]    + additional namespaces needed: [n=0] 
[16:18:43.043]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:43.043]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.043]  - seeds: <none>
[16:18:43.043]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.043] getGlobalsAndPackages() ...
[16:18:43.043] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.044] Resolving globals: FALSE
[16:18:43.049] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[16:18:43.050] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[16:18:43.051] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.051] 
[16:18:43.052] getGlobalsAndPackages() ... DONE
[16:18:43.052] run() for ‘Future’ ...
[16:18:43.053] - state: ‘created’
[16:18:43.053] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.059] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.060] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.060]   - Field: ‘label’
[16:18:43.060]   - Field: ‘local’
[16:18:43.060]   - Field: ‘owner’
[16:18:43.061]   - Field: ‘envir’
[16:18:43.061]   - Field: ‘workers’
[16:18:43.061]   - Field: ‘packages’
[16:18:43.061]   - Field: ‘gc’
[16:18:43.061]   - Field: ‘job’
[16:18:43.062]   - Field: ‘conditions’
[16:18:43.062]   - Field: ‘expr’
[16:18:43.062]   - Field: ‘uuid’
[16:18:43.062]   - Field: ‘seed’
[16:18:43.063]   - Field: ‘version’
[16:18:43.063]   - Field: ‘result’
[16:18:43.063]   - Field: ‘asynchronous’
[16:18:43.063]   - Field: ‘calls’
[16:18:43.064]   - Field: ‘globals’
[16:18:43.064]   - Field: ‘stdout’
[16:18:43.064]   - Field: ‘earlySignal’
[16:18:43.064]   - Field: ‘lazy’
[16:18:43.064]   - Field: ‘state’
[16:18:43.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.065] - Launch lazy future ...
[16:18:43.065] Packages needed by the future expression (n = 0): <none>
[16:18:43.066] Packages needed by future strategies (n = 0): <none>
[16:18:43.066] {
[16:18:43.066]     {
[16:18:43.066]         {
[16:18:43.066]             ...future.startTime <- base::Sys.time()
[16:18:43.066]             {
[16:18:43.066]                 {
[16:18:43.066]                   {
[16:18:43.066]                     {
[16:18:43.066]                       base::local({
[16:18:43.066]                         has_future <- base::requireNamespace("future", 
[16:18:43.066]                           quietly = TRUE)
[16:18:43.066]                         if (has_future) {
[16:18:43.066]                           ns <- base::getNamespace("future")
[16:18:43.066]                           version <- ns[[".package"]][["version"]]
[16:18:43.066]                           if (is.null(version)) 
[16:18:43.066]                             version <- utils::packageVersion("future")
[16:18:43.066]                         }
[16:18:43.066]                         else {
[16:18:43.066]                           version <- NULL
[16:18:43.066]                         }
[16:18:43.066]                         if (!has_future || version < "1.8.0") {
[16:18:43.066]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.066]                             "", base::R.version$version.string), 
[16:18:43.066]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:43.066]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:43.066]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.066]                               "release", "version")], collapse = " "), 
[16:18:43.066]                             hostname = base::Sys.info()[["nodename"]])
[16:18:43.066]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.066]                             info)
[16:18:43.066]                           info <- base::paste(info, collapse = "; ")
[16:18:43.066]                           if (!has_future) {
[16:18:43.066]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.066]                               info)
[16:18:43.066]                           }
[16:18:43.066]                           else {
[16:18:43.066]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.066]                               info, version)
[16:18:43.066]                           }
[16:18:43.066]                           base::stop(msg)
[16:18:43.066]                         }
[16:18:43.066]                       })
[16:18:43.066]                     }
[16:18:43.066]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.066]                     base::options(mc.cores = 1L)
[16:18:43.066]                   }
[16:18:43.066]                   ...future.strategy.old <- future::plan("list")
[16:18:43.066]                   options(future.plan = NULL)
[16:18:43.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.066]                 }
[16:18:43.066]                 ...future.workdir <- getwd()
[16:18:43.066]             }
[16:18:43.066]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.066]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.066]         }
[16:18:43.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.066]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.066]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.066]             base::names(...future.oldOptions))
[16:18:43.066]     }
[16:18:43.066]     if (FALSE) {
[16:18:43.066]     }
[16:18:43.066]     else {
[16:18:43.066]         if (TRUE) {
[16:18:43.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.066]                 open = "w")
[16:18:43.066]         }
[16:18:43.066]         else {
[16:18:43.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.066]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.066]         }
[16:18:43.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.066]             base::sink(type = "output", split = FALSE)
[16:18:43.066]             base::close(...future.stdout)
[16:18:43.066]         }, add = TRUE)
[16:18:43.066]     }
[16:18:43.066]     ...future.frame <- base::sys.nframe()
[16:18:43.066]     ...future.conditions <- base::list()
[16:18:43.066]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.066]     if (FALSE) {
[16:18:43.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.066]     }
[16:18:43.066]     ...future.result <- base::tryCatch({
[16:18:43.066]         base::withCallingHandlers({
[16:18:43.066]             ...future.value <- base::withVisible(base::local({
[16:18:43.066]                 withCallingHandlers({
[16:18:43.066]                   {
[16:18:43.066]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.066]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.066]                       ...future.globals.maxSize)) {
[16:18:43.066]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.066]                       on.exit(options(oopts), add = TRUE)
[16:18:43.066]                     }
[16:18:43.066]                     {
[16:18:43.066]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.066]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.066]                         USE.NAMES = FALSE)
[16:18:43.066]                       do.call(mapply, args = args)
[16:18:43.066]                     }
[16:18:43.066]                   }
[16:18:43.066]                 }, immediateCondition = function(cond) {
[16:18:43.066]                   save_rds <- function (object, pathname, ...) 
[16:18:43.066]                   {
[16:18:43.066]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.066]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.066]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.066]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.066]                         fi_tmp[["mtime"]])
[16:18:43.066]                     }
[16:18:43.066]                     tryCatch({
[16:18:43.066]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.066]                     }, error = function(ex) {
[16:18:43.066]                       msg <- conditionMessage(ex)
[16:18:43.066]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.066]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.066]                         fi_tmp[["mtime"]], msg)
[16:18:43.066]                       ex$message <- msg
[16:18:43.066]                       stop(ex)
[16:18:43.066]                     })
[16:18:43.066]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.066]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.066]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.066]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.066]                       fi <- file.info(pathname)
[16:18:43.066]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.066]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.066]                         fi[["size"]], fi[["mtime"]])
[16:18:43.066]                       stop(msg)
[16:18:43.066]                     }
[16:18:43.066]                     invisible(pathname)
[16:18:43.066]                   }
[16:18:43.066]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.066]                     rootPath = tempdir()) 
[16:18:43.066]                   {
[16:18:43.066]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.066]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.066]                       tmpdir = path, fileext = ".rds")
[16:18:43.066]                     save_rds(obj, file)
[16:18:43.066]                   }
[16:18:43.066]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.066]                   {
[16:18:43.066]                     inherits <- base::inherits
[16:18:43.066]                     invokeRestart <- base::invokeRestart
[16:18:43.066]                     is.null <- base::is.null
[16:18:43.066]                     muffled <- FALSE
[16:18:43.066]                     if (inherits(cond, "message")) {
[16:18:43.066]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.066]                       if (muffled) 
[16:18:43.066]                         invokeRestart("muffleMessage")
[16:18:43.066]                     }
[16:18:43.066]                     else if (inherits(cond, "warning")) {
[16:18:43.066]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.066]                       if (muffled) 
[16:18:43.066]                         invokeRestart("muffleWarning")
[16:18:43.066]                     }
[16:18:43.066]                     else if (inherits(cond, "condition")) {
[16:18:43.066]                       if (!is.null(pattern)) {
[16:18:43.066]                         computeRestarts <- base::computeRestarts
[16:18:43.066]                         grepl <- base::grepl
[16:18:43.066]                         restarts <- computeRestarts(cond)
[16:18:43.066]                         for (restart in restarts) {
[16:18:43.066]                           name <- restart$name
[16:18:43.066]                           if (is.null(name)) 
[16:18:43.066]                             next
[16:18:43.066]                           if (!grepl(pattern, name)) 
[16:18:43.066]                             next
[16:18:43.066]                           invokeRestart(restart)
[16:18:43.066]                           muffled <- TRUE
[16:18:43.066]                           break
[16:18:43.066]                         }
[16:18:43.066]                       }
[16:18:43.066]                     }
[16:18:43.066]                     invisible(muffled)
[16:18:43.066]                   }
[16:18:43.066]                   muffleCondition(cond)
[16:18:43.066]                 })
[16:18:43.066]             }))
[16:18:43.066]             future::FutureResult(value = ...future.value$value, 
[16:18:43.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.066]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.066]                     ...future.globalenv.names))
[16:18:43.066]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.066]         }, condition = base::local({
[16:18:43.066]             c <- base::c
[16:18:43.066]             inherits <- base::inherits
[16:18:43.066]             invokeRestart <- base::invokeRestart
[16:18:43.066]             length <- base::length
[16:18:43.066]             list <- base::list
[16:18:43.066]             seq.int <- base::seq.int
[16:18:43.066]             signalCondition <- base::signalCondition
[16:18:43.066]             sys.calls <- base::sys.calls
[16:18:43.066]             `[[` <- base::`[[`
[16:18:43.066]             `+` <- base::`+`
[16:18:43.066]             `<<-` <- base::`<<-`
[16:18:43.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.066]                   3L)]
[16:18:43.066]             }
[16:18:43.066]             function(cond) {
[16:18:43.066]                 is_error <- inherits(cond, "error")
[16:18:43.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.066]                   NULL)
[16:18:43.066]                 if (is_error) {
[16:18:43.066]                   sessionInformation <- function() {
[16:18:43.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.066]                       search = base::search(), system = base::Sys.info())
[16:18:43.066]                   }
[16:18:43.066]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.066]                     cond$call), session = sessionInformation(), 
[16:18:43.066]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.066]                   signalCondition(cond)
[16:18:43.066]                 }
[16:18:43.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.066]                 "immediateCondition"))) {
[16:18:43.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.066]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.066]                   if (TRUE && !signal) {
[16:18:43.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.066]                     {
[16:18:43.066]                       inherits <- base::inherits
[16:18:43.066]                       invokeRestart <- base::invokeRestart
[16:18:43.066]                       is.null <- base::is.null
[16:18:43.066]                       muffled <- FALSE
[16:18:43.066]                       if (inherits(cond, "message")) {
[16:18:43.066]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.066]                         if (muffled) 
[16:18:43.066]                           invokeRestart("muffleMessage")
[16:18:43.066]                       }
[16:18:43.066]                       else if (inherits(cond, "warning")) {
[16:18:43.066]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.066]                         if (muffled) 
[16:18:43.066]                           invokeRestart("muffleWarning")
[16:18:43.066]                       }
[16:18:43.066]                       else if (inherits(cond, "condition")) {
[16:18:43.066]                         if (!is.null(pattern)) {
[16:18:43.066]                           computeRestarts <- base::computeRestarts
[16:18:43.066]                           grepl <- base::grepl
[16:18:43.066]                           restarts <- computeRestarts(cond)
[16:18:43.066]                           for (restart in restarts) {
[16:18:43.066]                             name <- restart$name
[16:18:43.066]                             if (is.null(name)) 
[16:18:43.066]                               next
[16:18:43.066]                             if (!grepl(pattern, name)) 
[16:18:43.066]                               next
[16:18:43.066]                             invokeRestart(restart)
[16:18:43.066]                             muffled <- TRUE
[16:18:43.066]                             break
[16:18:43.066]                           }
[16:18:43.066]                         }
[16:18:43.066]                       }
[16:18:43.066]                       invisible(muffled)
[16:18:43.066]                     }
[16:18:43.066]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.066]                   }
[16:18:43.066]                 }
[16:18:43.066]                 else {
[16:18:43.066]                   if (TRUE) {
[16:18:43.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.066]                     {
[16:18:43.066]                       inherits <- base::inherits
[16:18:43.066]                       invokeRestart <- base::invokeRestart
[16:18:43.066]                       is.null <- base::is.null
[16:18:43.066]                       muffled <- FALSE
[16:18:43.066]                       if (inherits(cond, "message")) {
[16:18:43.066]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.066]                         if (muffled) 
[16:18:43.066]                           invokeRestart("muffleMessage")
[16:18:43.066]                       }
[16:18:43.066]                       else if (inherits(cond, "warning")) {
[16:18:43.066]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.066]                         if (muffled) 
[16:18:43.066]                           invokeRestart("muffleWarning")
[16:18:43.066]                       }
[16:18:43.066]                       else if (inherits(cond, "condition")) {
[16:18:43.066]                         if (!is.null(pattern)) {
[16:18:43.066]                           computeRestarts <- base::computeRestarts
[16:18:43.066]                           grepl <- base::grepl
[16:18:43.066]                           restarts <- computeRestarts(cond)
[16:18:43.066]                           for (restart in restarts) {
[16:18:43.066]                             name <- restart$name
[16:18:43.066]                             if (is.null(name)) 
[16:18:43.066]                               next
[16:18:43.066]                             if (!grepl(pattern, name)) 
[16:18:43.066]                               next
[16:18:43.066]                             invokeRestart(restart)
[16:18:43.066]                             muffled <- TRUE
[16:18:43.066]                             break
[16:18:43.066]                           }
[16:18:43.066]                         }
[16:18:43.066]                       }
[16:18:43.066]                       invisible(muffled)
[16:18:43.066]                     }
[16:18:43.066]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.066]                   }
[16:18:43.066]                 }
[16:18:43.066]             }
[16:18:43.066]         }))
[16:18:43.066]     }, error = function(ex) {
[16:18:43.066]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.066]                 ...future.rng), started = ...future.startTime, 
[16:18:43.066]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.066]             version = "1.8"), class = "FutureResult")
[16:18:43.066]     }, finally = {
[16:18:43.066]         if (!identical(...future.workdir, getwd())) 
[16:18:43.066]             setwd(...future.workdir)
[16:18:43.066]         {
[16:18:43.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.066]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.066]             }
[16:18:43.066]             base::options(...future.oldOptions)
[16:18:43.066]             if (.Platform$OS.type == "windows") {
[16:18:43.066]                 old_names <- names(...future.oldEnvVars)
[16:18:43.066]                 envs <- base::Sys.getenv()
[16:18:43.066]                 names <- names(envs)
[16:18:43.066]                 common <- intersect(names, old_names)
[16:18:43.066]                 added <- setdiff(names, old_names)
[16:18:43.066]                 removed <- setdiff(old_names, names)
[16:18:43.066]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.066]                   envs[common]]
[16:18:43.066]                 NAMES <- toupper(changed)
[16:18:43.066]                 args <- list()
[16:18:43.066]                 for (kk in seq_along(NAMES)) {
[16:18:43.066]                   name <- changed[[kk]]
[16:18:43.066]                   NAME <- NAMES[[kk]]
[16:18:43.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.066]                     next
[16:18:43.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.066]                 }
[16:18:43.066]                 NAMES <- toupper(added)
[16:18:43.066]                 for (kk in seq_along(NAMES)) {
[16:18:43.066]                   name <- added[[kk]]
[16:18:43.066]                   NAME <- NAMES[[kk]]
[16:18:43.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.066]                     next
[16:18:43.066]                   args[[name]] <- ""
[16:18:43.066]                 }
[16:18:43.066]                 NAMES <- toupper(removed)
[16:18:43.066]                 for (kk in seq_along(NAMES)) {
[16:18:43.066]                   name <- removed[[kk]]
[16:18:43.066]                   NAME <- NAMES[[kk]]
[16:18:43.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.066]                     next
[16:18:43.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.066]                 }
[16:18:43.066]                 if (length(args) > 0) 
[16:18:43.066]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.066]             }
[16:18:43.066]             else {
[16:18:43.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.066]             }
[16:18:43.066]             {
[16:18:43.066]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.066]                   0L) {
[16:18:43.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.066]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.066]                   base::options(opts)
[16:18:43.066]                 }
[16:18:43.066]                 {
[16:18:43.066]                   {
[16:18:43.066]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.066]                     NULL
[16:18:43.066]                   }
[16:18:43.066]                   options(future.plan = NULL)
[16:18:43.066]                   if (is.na(NA_character_)) 
[16:18:43.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.066]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.066]                     .init = FALSE)
[16:18:43.066]                 }
[16:18:43.066]             }
[16:18:43.066]         }
[16:18:43.066]     })
[16:18:43.066]     if (TRUE) {
[16:18:43.066]         base::sink(type = "output", split = FALSE)
[16:18:43.066]         if (TRUE) {
[16:18:43.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.066]         }
[16:18:43.066]         else {
[16:18:43.066]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.066]         }
[16:18:43.066]         base::close(...future.stdout)
[16:18:43.066]         ...future.stdout <- NULL
[16:18:43.066]     }
[16:18:43.066]     ...future.result$conditions <- ...future.conditions
[16:18:43.066]     ...future.result$finished <- base::Sys.time()
[16:18:43.066]     ...future.result
[16:18:43.066] }
[16:18:43.069] assign_globals() ...
[16:18:43.069] List of 5
[16:18:43.069]  $ ...future.FUN            :function (x, y)  
[16:18:43.069]  $ MoreArgs                 :List of 1
[16:18:43.069]   ..$ y: int [1:2] 3 4
[16:18:43.069]  $ ...future.elements_ii    :List of 1
[16:18:43.069]   ..$ x:List of 1
[16:18:43.069]   .. ..$ : int 2
[16:18:43.069]  $ ...future.seeds_ii       : NULL
[16:18:43.069]  $ ...future.globals.maxSize: NULL
[16:18:43.069]  - attr(*, "where")=List of 5
[16:18:43.069]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.069]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.069]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.069]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.069]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.069]  - attr(*, "resolved")= logi FALSE
[16:18:43.069]  - attr(*, "total_size")= num 1816
[16:18:43.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.069]  - attr(*, "already-done")= logi TRUE
[16:18:43.077] - reassign environment for ‘...future.FUN’
[16:18:43.077] - copied ‘...future.FUN’ to environment
[16:18:43.077] - copied ‘MoreArgs’ to environment
[16:18:43.077] - copied ‘...future.elements_ii’ to environment
[16:18:43.077] - copied ‘...future.seeds_ii’ to environment
[16:18:43.077] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.077] assign_globals() ... done
[16:18:43.077] requestCore(): workers = 2
[16:18:43.080] MulticoreFuture started
[16:18:43.080] - Launch lazy future ... done
[16:18:43.081] run() for ‘MulticoreFuture’ ... done
[16:18:43.081] Created future:
[16:18:43.081] plan(): Setting new future strategy stack:
[16:18:43.081] List of future strategies:
[16:18:43.081] 1. sequential:
[16:18:43.081]    - args: function (..., envir = parent.frame())
[16:18:43.081]    - tweaked: FALSE
[16:18:43.081]    - call: NULL
[16:18:43.082] plan(): nbrOfWorkers() = 1
[16:18:43.084] plan(): Setting new future strategy stack:
[16:18:43.084] List of future strategies:
[16:18:43.084] 1. multicore:
[16:18:43.084]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.084]    - tweaked: FALSE
[16:18:43.084]    - call: plan(strategy)
[16:18:43.090] plan(): nbrOfWorkers() = 2
[16:18:43.081] MulticoreFuture:
[16:18:43.081] Label: ‘future_.mapply-2’
[16:18:43.081] Expression:
[16:18:43.081] {
[16:18:43.081]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.081]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.081]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.081]         on.exit(options(oopts), add = TRUE)
[16:18:43.081]     }
[16:18:43.081]     {
[16:18:43.081]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.081]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.081]         do.call(mapply, args = args)
[16:18:43.081]     }
[16:18:43.081] }
[16:18:43.081] Lazy evaluation: FALSE
[16:18:43.081] Asynchronous evaluation: TRUE
[16:18:43.081] Local evaluation: TRUE
[16:18:43.081] Environment: R_GlobalEnv
[16:18:43.081] Capture standard output: TRUE
[16:18:43.081] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.081] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.081] Packages: <none>
[16:18:43.081] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:43.081] Resolved: TRUE
[16:18:43.081] Value: <not collected>
[16:18:43.081] Conditions captured: <none>
[16:18:43.081] Early signaling: FALSE
[16:18:43.081] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.081] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.091] Chunk #2 of 2 ... DONE
[16:18:43.091] Launching 2 futures (chunks) ... DONE
[16:18:43.092] Resolving 2 futures (chunks) ...
[16:18:43.092] resolve() on list ...
[16:18:43.092]  recursive: 0
[16:18:43.092]  length: 2
[16:18:43.092] 
[16:18:43.092] Future #1
[16:18:43.093] result() for MulticoreFuture ...
[16:18:43.094] result() for MulticoreFuture ...
[16:18:43.094] result() for MulticoreFuture ... done
[16:18:43.094] result() for MulticoreFuture ... done
[16:18:43.094] result() for MulticoreFuture ...
[16:18:43.094] result() for MulticoreFuture ... done
[16:18:43.094] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:43.094] - nx: 2
[16:18:43.095] - relay: TRUE
[16:18:43.095] - stdout: TRUE
[16:18:43.095] - signal: TRUE
[16:18:43.095] - resignal: FALSE
[16:18:43.095] - force: TRUE
[16:18:43.095] - relayed: [n=2] FALSE, FALSE
[16:18:43.095] - queued futures: [n=2] FALSE, FALSE
[16:18:43.096]  - until=1
[16:18:43.096]  - relaying element #1
[16:18:43.096] result() for MulticoreFuture ...
[16:18:43.096] result() for MulticoreFuture ... done
[16:18:43.096] result() for MulticoreFuture ...
[16:18:43.096] result() for MulticoreFuture ... done
[16:18:43.101] result() for MulticoreFuture ...
[16:18:43.101] result() for MulticoreFuture ... done
[16:18:43.102] result() for MulticoreFuture ...
[16:18:43.102] result() for MulticoreFuture ... done
[16:18:43.102] - relayed: [n=2] TRUE, FALSE
[16:18:43.103] - queued futures: [n=2] TRUE, FALSE
[16:18:43.103] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:43.103]  length: 1 (resolved future 1)
[16:18:43.104] Future #2
[16:18:43.104] result() for MulticoreFuture ...
[16:18:43.105] result() for MulticoreFuture ...
[16:18:43.105] result() for MulticoreFuture ... done
[16:18:43.106] result() for MulticoreFuture ... done
[16:18:43.106] result() for MulticoreFuture ...
[16:18:43.106] result() for MulticoreFuture ... done
[16:18:43.106] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:43.107] - nx: 2
[16:18:43.107] - relay: TRUE
[16:18:43.107] - stdout: TRUE
[16:18:43.107] - signal: TRUE
[16:18:43.107] - resignal: FALSE
[16:18:43.107] - force: TRUE
[16:18:43.107] - relayed: [n=2] TRUE, FALSE
[16:18:43.108] - queued futures: [n=2] TRUE, FALSE
[16:18:43.108]  - until=2
[16:18:43.108]  - relaying element #2
[16:18:43.108] result() for MulticoreFuture ...
[16:18:43.108] result() for MulticoreFuture ... done
[16:18:43.108] result() for MulticoreFuture ...
[16:18:43.109] result() for MulticoreFuture ... done
[16:18:43.109] result() for MulticoreFuture ...
[16:18:43.109] result() for MulticoreFuture ... done
[16:18:43.109] result() for MulticoreFuture ...
[16:18:43.109] result() for MulticoreFuture ... done
[16:18:43.109] - relayed: [n=2] TRUE, TRUE
[16:18:43.109] - queued futures: [n=2] TRUE, TRUE
[16:18:43.110] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:43.110]  length: 0 (resolved future 2)
[16:18:43.110] Relaying remaining futures
[16:18:43.110] signalConditionsASAP(NULL, pos=0) ...
[16:18:43.110] - nx: 2
[16:18:43.110] - relay: TRUE
[16:18:43.110] - stdout: TRUE
[16:18:43.111] - signal: TRUE
[16:18:43.111] - resignal: FALSE
[16:18:43.111] - force: TRUE
[16:18:43.111] - relayed: [n=2] TRUE, TRUE
[16:18:43.111] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:43.111] - relayed: [n=2] TRUE, TRUE
[16:18:43.111] - queued futures: [n=2] TRUE, TRUE
[16:18:43.112] signalConditionsASAP(NULL, pos=0) ... done
[16:18:43.112] resolve() on list ... DONE
[16:18:43.112] result() for MulticoreFuture ...
[16:18:43.112] result() for MulticoreFuture ... done
[16:18:43.112] result() for MulticoreFuture ...
[16:18:43.112] result() for MulticoreFuture ... done
[16:18:43.112] result() for MulticoreFuture ...
[16:18:43.112] result() for MulticoreFuture ... done
[16:18:43.112] result() for MulticoreFuture ...
[16:18:43.113] result() for MulticoreFuture ... done
[16:18:43.113]  - Number of value chunks collected: 2
[16:18:43.113] Resolving 2 futures (chunks) ... DONE
[16:18:43.113] Reducing values from 2 chunks ...
[16:18:43.113]  - Number of values collected after concatenation: 2
[16:18:43.113]  - Number of values expected: 2
[16:18:43.113] Reducing values from 2 chunks ... DONE
[16:18:43.113] future_mapply() ... DONE
- Recycle arguments to same length ...
[16:18:43.114] future_mapply() ...
[16:18:43.118] Number of chunks: 2
[16:18:43.118] getGlobalsAndPackagesXApply() ...
[16:18:43.118]  - future.globals: TRUE
[16:18:43.118] getGlobalsAndPackages() ...
[16:18:43.118] Searching for globals...
[16:18:43.119] - globals found: [1] ‘FUN’
[16:18:43.119] Searching for globals ... DONE
[16:18:43.119] Resolving globals: FALSE
[16:18:43.120] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:43.120] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:43.120] - globals: [1] ‘FUN’
[16:18:43.120] 
[16:18:43.120] getGlobalsAndPackages() ... DONE
[16:18:43.120]  - globals found/used: [n=1] ‘FUN’
[16:18:43.121]  - needed namespaces: [n=0] 
[16:18:43.121] Finding globals ... DONE
[16:18:43.121] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:43.121] List of 2
[16:18:43.121]  $ ...future.FUN:function (x, ...)  
[16:18:43.121]  $ MoreArgs     : NULL
[16:18:43.121]  - attr(*, "where")=List of 2
[16:18:43.121]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:43.121]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:43.121]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.121]  - attr(*, "resolved")= logi FALSE
[16:18:43.121]  - attr(*, "total_size")= num NA
[16:18:43.124] Packages to be attached in all futures: [n=0] 
[16:18:43.124] getGlobalsAndPackagesXApply() ... DONE
[16:18:43.124] Number of futures (= number of chunks): 2
[16:18:43.124] Launching 2 futures (chunks) ...
[16:18:43.124] Chunk #1 of 2 ...
[16:18:43.124]  - Finding globals in '...' for chunk #1 ...
[16:18:43.124] getGlobalsAndPackages() ...
[16:18:43.125] Searching for globals...
[16:18:43.125] 
[16:18:43.125] Searching for globals ... DONE
[16:18:43.125] - globals: [0] <none>
[16:18:43.125] getGlobalsAndPackages() ... DONE
[16:18:43.125]    + additional globals found: [n=0] 
[16:18:43.125]    + additional namespaces needed: [n=0] 
[16:18:43.125]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:43.126]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.126]  - seeds: <none>
[16:18:43.126]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.126] getGlobalsAndPackages() ...
[16:18:43.126] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.126] Resolving globals: FALSE
[16:18:43.127] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:43.127] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:43.129] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.129] 
[16:18:43.130] getGlobalsAndPackages() ... DONE
[16:18:43.130] run() for ‘Future’ ...
[16:18:43.130] - state: ‘created’
[16:18:43.130] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.134] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.134] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.134]   - Field: ‘label’
[16:18:43.134]   - Field: ‘local’
[16:18:43.134]   - Field: ‘owner’
[16:18:43.134]   - Field: ‘envir’
[16:18:43.134]   - Field: ‘workers’
[16:18:43.134]   - Field: ‘packages’
[16:18:43.135]   - Field: ‘gc’
[16:18:43.135]   - Field: ‘job’
[16:18:43.135]   - Field: ‘conditions’
[16:18:43.135]   - Field: ‘expr’
[16:18:43.135]   - Field: ‘uuid’
[16:18:43.135]   - Field: ‘seed’
[16:18:43.135]   - Field: ‘version’
[16:18:43.135]   - Field: ‘result’
[16:18:43.135]   - Field: ‘asynchronous’
[16:18:43.135]   - Field: ‘calls’
[16:18:43.136]   - Field: ‘globals’
[16:18:43.136]   - Field: ‘stdout’
[16:18:43.136]   - Field: ‘earlySignal’
[16:18:43.136]   - Field: ‘lazy’
[16:18:43.136]   - Field: ‘state’
[16:18:43.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.136] - Launch lazy future ...
[16:18:43.137] Packages needed by the future expression (n = 0): <none>
[16:18:43.137] Packages needed by future strategies (n = 0): <none>
[16:18:43.137] {
[16:18:43.137]     {
[16:18:43.137]         {
[16:18:43.137]             ...future.startTime <- base::Sys.time()
[16:18:43.137]             {
[16:18:43.137]                 {
[16:18:43.137]                   {
[16:18:43.137]                     {
[16:18:43.137]                       base::local({
[16:18:43.137]                         has_future <- base::requireNamespace("future", 
[16:18:43.137]                           quietly = TRUE)
[16:18:43.137]                         if (has_future) {
[16:18:43.137]                           ns <- base::getNamespace("future")
[16:18:43.137]                           version <- ns[[".package"]][["version"]]
[16:18:43.137]                           if (is.null(version)) 
[16:18:43.137]                             version <- utils::packageVersion("future")
[16:18:43.137]                         }
[16:18:43.137]                         else {
[16:18:43.137]                           version <- NULL
[16:18:43.137]                         }
[16:18:43.137]                         if (!has_future || version < "1.8.0") {
[16:18:43.137]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.137]                             "", base::R.version$version.string), 
[16:18:43.137]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:43.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:43.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.137]                               "release", "version")], collapse = " "), 
[16:18:43.137]                             hostname = base::Sys.info()[["nodename"]])
[16:18:43.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.137]                             info)
[16:18:43.137]                           info <- base::paste(info, collapse = "; ")
[16:18:43.137]                           if (!has_future) {
[16:18:43.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.137]                               info)
[16:18:43.137]                           }
[16:18:43.137]                           else {
[16:18:43.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.137]                               info, version)
[16:18:43.137]                           }
[16:18:43.137]                           base::stop(msg)
[16:18:43.137]                         }
[16:18:43.137]                       })
[16:18:43.137]                     }
[16:18:43.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.137]                     base::options(mc.cores = 1L)
[16:18:43.137]                   }
[16:18:43.137]                   ...future.strategy.old <- future::plan("list")
[16:18:43.137]                   options(future.plan = NULL)
[16:18:43.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.137]                 }
[16:18:43.137]                 ...future.workdir <- getwd()
[16:18:43.137]             }
[16:18:43.137]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.137]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.137]         }
[16:18:43.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.137]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.137]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.137]             base::names(...future.oldOptions))
[16:18:43.137]     }
[16:18:43.137]     if (FALSE) {
[16:18:43.137]     }
[16:18:43.137]     else {
[16:18:43.137]         if (TRUE) {
[16:18:43.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.137]                 open = "w")
[16:18:43.137]         }
[16:18:43.137]         else {
[16:18:43.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.137]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.137]         }
[16:18:43.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.137]             base::sink(type = "output", split = FALSE)
[16:18:43.137]             base::close(...future.stdout)
[16:18:43.137]         }, add = TRUE)
[16:18:43.137]     }
[16:18:43.137]     ...future.frame <- base::sys.nframe()
[16:18:43.137]     ...future.conditions <- base::list()
[16:18:43.137]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.137]     if (FALSE) {
[16:18:43.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.137]     }
[16:18:43.137]     ...future.result <- base::tryCatch({
[16:18:43.137]         base::withCallingHandlers({
[16:18:43.137]             ...future.value <- base::withVisible(base::local({
[16:18:43.137]                 withCallingHandlers({
[16:18:43.137]                   {
[16:18:43.137]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.137]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.137]                       ...future.globals.maxSize)) {
[16:18:43.137]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.137]                       on.exit(options(oopts), add = TRUE)
[16:18:43.137]                     }
[16:18:43.137]                     {
[16:18:43.137]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.137]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.137]                         USE.NAMES = FALSE)
[16:18:43.137]                       do.call(mapply, args = args)
[16:18:43.137]                     }
[16:18:43.137]                   }
[16:18:43.137]                 }, immediateCondition = function(cond) {
[16:18:43.137]                   save_rds <- function (object, pathname, ...) 
[16:18:43.137]                   {
[16:18:43.137]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.137]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.137]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.137]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.137]                         fi_tmp[["mtime"]])
[16:18:43.137]                     }
[16:18:43.137]                     tryCatch({
[16:18:43.137]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.137]                     }, error = function(ex) {
[16:18:43.137]                       msg <- conditionMessage(ex)
[16:18:43.137]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.137]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.137]                         fi_tmp[["mtime"]], msg)
[16:18:43.137]                       ex$message <- msg
[16:18:43.137]                       stop(ex)
[16:18:43.137]                     })
[16:18:43.137]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.137]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.137]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.137]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.137]                       fi <- file.info(pathname)
[16:18:43.137]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.137]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.137]                         fi[["size"]], fi[["mtime"]])
[16:18:43.137]                       stop(msg)
[16:18:43.137]                     }
[16:18:43.137]                     invisible(pathname)
[16:18:43.137]                   }
[16:18:43.137]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.137]                     rootPath = tempdir()) 
[16:18:43.137]                   {
[16:18:43.137]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.137]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.137]                       tmpdir = path, fileext = ".rds")
[16:18:43.137]                     save_rds(obj, file)
[16:18:43.137]                   }
[16:18:43.137]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.137]                   {
[16:18:43.137]                     inherits <- base::inherits
[16:18:43.137]                     invokeRestart <- base::invokeRestart
[16:18:43.137]                     is.null <- base::is.null
[16:18:43.137]                     muffled <- FALSE
[16:18:43.137]                     if (inherits(cond, "message")) {
[16:18:43.137]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.137]                       if (muffled) 
[16:18:43.137]                         invokeRestart("muffleMessage")
[16:18:43.137]                     }
[16:18:43.137]                     else if (inherits(cond, "warning")) {
[16:18:43.137]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.137]                       if (muffled) 
[16:18:43.137]                         invokeRestart("muffleWarning")
[16:18:43.137]                     }
[16:18:43.137]                     else if (inherits(cond, "condition")) {
[16:18:43.137]                       if (!is.null(pattern)) {
[16:18:43.137]                         computeRestarts <- base::computeRestarts
[16:18:43.137]                         grepl <- base::grepl
[16:18:43.137]                         restarts <- computeRestarts(cond)
[16:18:43.137]                         for (restart in restarts) {
[16:18:43.137]                           name <- restart$name
[16:18:43.137]                           if (is.null(name)) 
[16:18:43.137]                             next
[16:18:43.137]                           if (!grepl(pattern, name)) 
[16:18:43.137]                             next
[16:18:43.137]                           invokeRestart(restart)
[16:18:43.137]                           muffled <- TRUE
[16:18:43.137]                           break
[16:18:43.137]                         }
[16:18:43.137]                       }
[16:18:43.137]                     }
[16:18:43.137]                     invisible(muffled)
[16:18:43.137]                   }
[16:18:43.137]                   muffleCondition(cond)
[16:18:43.137]                 })
[16:18:43.137]             }))
[16:18:43.137]             future::FutureResult(value = ...future.value$value, 
[16:18:43.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.137]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.137]                     ...future.globalenv.names))
[16:18:43.137]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.137]         }, condition = base::local({
[16:18:43.137]             c <- base::c
[16:18:43.137]             inherits <- base::inherits
[16:18:43.137]             invokeRestart <- base::invokeRestart
[16:18:43.137]             length <- base::length
[16:18:43.137]             list <- base::list
[16:18:43.137]             seq.int <- base::seq.int
[16:18:43.137]             signalCondition <- base::signalCondition
[16:18:43.137]             sys.calls <- base::sys.calls
[16:18:43.137]             `[[` <- base::`[[`
[16:18:43.137]             `+` <- base::`+`
[16:18:43.137]             `<<-` <- base::`<<-`
[16:18:43.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.137]                   3L)]
[16:18:43.137]             }
[16:18:43.137]             function(cond) {
[16:18:43.137]                 is_error <- inherits(cond, "error")
[16:18:43.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.137]                   NULL)
[16:18:43.137]                 if (is_error) {
[16:18:43.137]                   sessionInformation <- function() {
[16:18:43.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.137]                       search = base::search(), system = base::Sys.info())
[16:18:43.137]                   }
[16:18:43.137]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.137]                     cond$call), session = sessionInformation(), 
[16:18:43.137]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.137]                   signalCondition(cond)
[16:18:43.137]                 }
[16:18:43.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.137]                 "immediateCondition"))) {
[16:18:43.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.137]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.137]                   if (TRUE && !signal) {
[16:18:43.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.137]                     {
[16:18:43.137]                       inherits <- base::inherits
[16:18:43.137]                       invokeRestart <- base::invokeRestart
[16:18:43.137]                       is.null <- base::is.null
[16:18:43.137]                       muffled <- FALSE
[16:18:43.137]                       if (inherits(cond, "message")) {
[16:18:43.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.137]                         if (muffled) 
[16:18:43.137]                           invokeRestart("muffleMessage")
[16:18:43.137]                       }
[16:18:43.137]                       else if (inherits(cond, "warning")) {
[16:18:43.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.137]                         if (muffled) 
[16:18:43.137]                           invokeRestart("muffleWarning")
[16:18:43.137]                       }
[16:18:43.137]                       else if (inherits(cond, "condition")) {
[16:18:43.137]                         if (!is.null(pattern)) {
[16:18:43.137]                           computeRestarts <- base::computeRestarts
[16:18:43.137]                           grepl <- base::grepl
[16:18:43.137]                           restarts <- computeRestarts(cond)
[16:18:43.137]                           for (restart in restarts) {
[16:18:43.137]                             name <- restart$name
[16:18:43.137]                             if (is.null(name)) 
[16:18:43.137]                               next
[16:18:43.137]                             if (!grepl(pattern, name)) 
[16:18:43.137]                               next
[16:18:43.137]                             invokeRestart(restart)
[16:18:43.137]                             muffled <- TRUE
[16:18:43.137]                             break
[16:18:43.137]                           }
[16:18:43.137]                         }
[16:18:43.137]                       }
[16:18:43.137]                       invisible(muffled)
[16:18:43.137]                     }
[16:18:43.137]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.137]                   }
[16:18:43.137]                 }
[16:18:43.137]                 else {
[16:18:43.137]                   if (TRUE) {
[16:18:43.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.137]                     {
[16:18:43.137]                       inherits <- base::inherits
[16:18:43.137]                       invokeRestart <- base::invokeRestart
[16:18:43.137]                       is.null <- base::is.null
[16:18:43.137]                       muffled <- FALSE
[16:18:43.137]                       if (inherits(cond, "message")) {
[16:18:43.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.137]                         if (muffled) 
[16:18:43.137]                           invokeRestart("muffleMessage")
[16:18:43.137]                       }
[16:18:43.137]                       else if (inherits(cond, "warning")) {
[16:18:43.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.137]                         if (muffled) 
[16:18:43.137]                           invokeRestart("muffleWarning")
[16:18:43.137]                       }
[16:18:43.137]                       else if (inherits(cond, "condition")) {
[16:18:43.137]                         if (!is.null(pattern)) {
[16:18:43.137]                           computeRestarts <- base::computeRestarts
[16:18:43.137]                           grepl <- base::grepl
[16:18:43.137]                           restarts <- computeRestarts(cond)
[16:18:43.137]                           for (restart in restarts) {
[16:18:43.137]                             name <- restart$name
[16:18:43.137]                             if (is.null(name)) 
[16:18:43.137]                               next
[16:18:43.137]                             if (!grepl(pattern, name)) 
[16:18:43.137]                               next
[16:18:43.137]                             invokeRestart(restart)
[16:18:43.137]                             muffled <- TRUE
[16:18:43.137]                             break
[16:18:43.137]                           }
[16:18:43.137]                         }
[16:18:43.137]                       }
[16:18:43.137]                       invisible(muffled)
[16:18:43.137]                     }
[16:18:43.137]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.137]                   }
[16:18:43.137]                 }
[16:18:43.137]             }
[16:18:43.137]         }))
[16:18:43.137]     }, error = function(ex) {
[16:18:43.137]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.137]                 ...future.rng), started = ...future.startTime, 
[16:18:43.137]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.137]             version = "1.8"), class = "FutureResult")
[16:18:43.137]     }, finally = {
[16:18:43.137]         if (!identical(...future.workdir, getwd())) 
[16:18:43.137]             setwd(...future.workdir)
[16:18:43.137]         {
[16:18:43.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.137]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.137]             }
[16:18:43.137]             base::options(...future.oldOptions)
[16:18:43.137]             if (.Platform$OS.type == "windows") {
[16:18:43.137]                 old_names <- names(...future.oldEnvVars)
[16:18:43.137]                 envs <- base::Sys.getenv()
[16:18:43.137]                 names <- names(envs)
[16:18:43.137]                 common <- intersect(names, old_names)
[16:18:43.137]                 added <- setdiff(names, old_names)
[16:18:43.137]                 removed <- setdiff(old_names, names)
[16:18:43.137]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.137]                   envs[common]]
[16:18:43.137]                 NAMES <- toupper(changed)
[16:18:43.137]                 args <- list()
[16:18:43.137]                 for (kk in seq_along(NAMES)) {
[16:18:43.137]                   name <- changed[[kk]]
[16:18:43.137]                   NAME <- NAMES[[kk]]
[16:18:43.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.137]                     next
[16:18:43.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.137]                 }
[16:18:43.137]                 NAMES <- toupper(added)
[16:18:43.137]                 for (kk in seq_along(NAMES)) {
[16:18:43.137]                   name <- added[[kk]]
[16:18:43.137]                   NAME <- NAMES[[kk]]
[16:18:43.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.137]                     next
[16:18:43.137]                   args[[name]] <- ""
[16:18:43.137]                 }
[16:18:43.137]                 NAMES <- toupper(removed)
[16:18:43.137]                 for (kk in seq_along(NAMES)) {
[16:18:43.137]                   name <- removed[[kk]]
[16:18:43.137]                   NAME <- NAMES[[kk]]
[16:18:43.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.137]                     next
[16:18:43.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.137]                 }
[16:18:43.137]                 if (length(args) > 0) 
[16:18:43.137]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.137]             }
[16:18:43.137]             else {
[16:18:43.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.137]             }
[16:18:43.137]             {
[16:18:43.137]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.137]                   0L) {
[16:18:43.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.137]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.137]                   base::options(opts)
[16:18:43.137]                 }
[16:18:43.137]                 {
[16:18:43.137]                   {
[16:18:43.137]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.137]                     NULL
[16:18:43.137]                   }
[16:18:43.137]                   options(future.plan = NULL)
[16:18:43.137]                   if (is.na(NA_character_)) 
[16:18:43.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.137]                     .init = FALSE)
[16:18:43.137]                 }
[16:18:43.137]             }
[16:18:43.137]         }
[16:18:43.137]     })
[16:18:43.137]     if (TRUE) {
[16:18:43.137]         base::sink(type = "output", split = FALSE)
[16:18:43.137]         if (TRUE) {
[16:18:43.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.137]         }
[16:18:43.137]         else {
[16:18:43.137]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.137]         }
[16:18:43.137]         base::close(...future.stdout)
[16:18:43.137]         ...future.stdout <- NULL
[16:18:43.137]     }
[16:18:43.137]     ...future.result$conditions <- ...future.conditions
[16:18:43.137]     ...future.result$finished <- base::Sys.time()
[16:18:43.137]     ...future.result
[16:18:43.137] }
[16:18:43.140] assign_globals() ...
[16:18:43.140] List of 5
[16:18:43.140]  $ ...future.FUN            :function (x, ...)  
[16:18:43.140]  $ MoreArgs                 : NULL
[16:18:43.140]  $ ...future.elements_ii    :List of 2
[16:18:43.140]   ..$ :List of 2
[16:18:43.140]   .. ..$ : int 1
[16:18:43.140]   .. ..$ : int 2
[16:18:43.140]   ..$ :List of 2
[16:18:43.140]   .. ..$ : int 2
[16:18:43.140]   .. ..$ : int 1
[16:18:43.140]  $ ...future.seeds_ii       : NULL
[16:18:43.140]  $ ...future.globals.maxSize: NULL
[16:18:43.140]  - attr(*, "where")=List of 5
[16:18:43.140]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.140]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.140]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.140]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.140]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.140]  - attr(*, "resolved")= logi FALSE
[16:18:43.140]  - attr(*, "total_size")= num 280
[16:18:43.140]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.140]  - attr(*, "already-done")= logi TRUE
[16:18:43.145] - copied ‘...future.FUN’ to environment
[16:18:43.145] - copied ‘MoreArgs’ to environment
[16:18:43.145] - copied ‘...future.elements_ii’ to environment
[16:18:43.146] - copied ‘...future.seeds_ii’ to environment
[16:18:43.146] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.146] assign_globals() ... done
[16:18:43.146] requestCore(): workers = 2
[16:18:43.148] MulticoreFuture started
[16:18:43.149] - Launch lazy future ... done
[16:18:43.149] run() for ‘MulticoreFuture’ ... done
[16:18:43.149] Created future:
[16:18:43.149] plan(): Setting new future strategy stack:
[16:18:43.150] List of future strategies:
[16:18:43.150] 1. sequential:
[16:18:43.150]    - args: function (..., envir = parent.frame())
[16:18:43.150]    - tweaked: FALSE
[16:18:43.150]    - call: NULL
[16:18:43.150] plan(): nbrOfWorkers() = 1
[16:18:43.153] plan(): Setting new future strategy stack:
[16:18:43.153] List of future strategies:
[16:18:43.153] 1. multicore:
[16:18:43.153]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.153]    - tweaked: FALSE
[16:18:43.153]    - call: plan(strategy)
[16:18:43.158] plan(): nbrOfWorkers() = 2
[16:18:43.149] MulticoreFuture:
[16:18:43.149] Label: ‘future_mapply-1’
[16:18:43.149] Expression:
[16:18:43.149] {
[16:18:43.149]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.149]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.149]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.149]         on.exit(options(oopts), add = TRUE)
[16:18:43.149]     }
[16:18:43.149]     {
[16:18:43.149]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.149]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.149]         do.call(mapply, args = args)
[16:18:43.149]     }
[16:18:43.149] }
[16:18:43.149] Lazy evaluation: FALSE
[16:18:43.149] Asynchronous evaluation: TRUE
[16:18:43.149] Local evaluation: TRUE
[16:18:43.149] Environment: R_GlobalEnv
[16:18:43.149] Capture standard output: TRUE
[16:18:43.149] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.149] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.149] Packages: <none>
[16:18:43.149] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:43.149] Resolved: TRUE
[16:18:43.149] Value: <not collected>
[16:18:43.149] Conditions captured: <none>
[16:18:43.149] Early signaling: FALSE
[16:18:43.149] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.149] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.159] Chunk #1 of 2 ... DONE
[16:18:43.159] Chunk #2 of 2 ...
[16:18:43.160]  - Finding globals in '...' for chunk #2 ...
[16:18:43.160] getGlobalsAndPackages() ...
[16:18:43.160] Searching for globals...
[16:18:43.161] 
[16:18:43.161] Searching for globals ... DONE
[16:18:43.161] - globals: [0] <none>
[16:18:43.161] getGlobalsAndPackages() ... DONE
[16:18:43.161]    + additional globals found: [n=0] 
[16:18:43.161]    + additional namespaces needed: [n=0] 
[16:18:43.162]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:43.162]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.162]  - seeds: <none>
[16:18:43.162]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.162] getGlobalsAndPackages() ...
[16:18:43.162] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.163] Resolving globals: FALSE
[16:18:43.164] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:43.172] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:43.172] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.172] 
[16:18:43.172] getGlobalsAndPackages() ... DONE
[16:18:43.173] run() for ‘Future’ ...
[16:18:43.173] - state: ‘created’
[16:18:43.173] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.179] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.179]   - Field: ‘label’
[16:18:43.179]   - Field: ‘local’
[16:18:43.180]   - Field: ‘owner’
[16:18:43.180]   - Field: ‘envir’
[16:18:43.180]   - Field: ‘workers’
[16:18:43.180]   - Field: ‘packages’
[16:18:43.180]   - Field: ‘gc’
[16:18:43.181]   - Field: ‘job’
[16:18:43.181]   - Field: ‘conditions’
[16:18:43.181]   - Field: ‘expr’
[16:18:43.181]   - Field: ‘uuid’
[16:18:43.181]   - Field: ‘seed’
[16:18:43.182]   - Field: ‘version’
[16:18:43.182]   - Field: ‘result’
[16:18:43.182]   - Field: ‘asynchronous’
[16:18:43.182]   - Field: ‘calls’
[16:18:43.182]   - Field: ‘globals’
[16:18:43.183]   - Field: ‘stdout’
[16:18:43.183]   - Field: ‘earlySignal’
[16:18:43.183]   - Field: ‘lazy’
[16:18:43.183]   - Field: ‘state’
[16:18:43.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.183] - Launch lazy future ...
[16:18:43.184] Packages needed by the future expression (n = 0): <none>
[16:18:43.184] Packages needed by future strategies (n = 0): <none>
[16:18:43.185] {
[16:18:43.185]     {
[16:18:43.185]         {
[16:18:43.185]             ...future.startTime <- base::Sys.time()
[16:18:43.185]             {
[16:18:43.185]                 {
[16:18:43.185]                   {
[16:18:43.185]                     {
[16:18:43.185]                       base::local({
[16:18:43.185]                         has_future <- base::requireNamespace("future", 
[16:18:43.185]                           quietly = TRUE)
[16:18:43.185]                         if (has_future) {
[16:18:43.185]                           ns <- base::getNamespace("future")
[16:18:43.185]                           version <- ns[[".package"]][["version"]]
[16:18:43.185]                           if (is.null(version)) 
[16:18:43.185]                             version <- utils::packageVersion("future")
[16:18:43.185]                         }
[16:18:43.185]                         else {
[16:18:43.185]                           version <- NULL
[16:18:43.185]                         }
[16:18:43.185]                         if (!has_future || version < "1.8.0") {
[16:18:43.185]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.185]                             "", base::R.version$version.string), 
[16:18:43.185]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:43.185]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:43.185]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.185]                               "release", "version")], collapse = " "), 
[16:18:43.185]                             hostname = base::Sys.info()[["nodename"]])
[16:18:43.185]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.185]                             info)
[16:18:43.185]                           info <- base::paste(info, collapse = "; ")
[16:18:43.185]                           if (!has_future) {
[16:18:43.185]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.185]                               info)
[16:18:43.185]                           }
[16:18:43.185]                           else {
[16:18:43.185]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.185]                               info, version)
[16:18:43.185]                           }
[16:18:43.185]                           base::stop(msg)
[16:18:43.185]                         }
[16:18:43.185]                       })
[16:18:43.185]                     }
[16:18:43.185]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.185]                     base::options(mc.cores = 1L)
[16:18:43.185]                   }
[16:18:43.185]                   ...future.strategy.old <- future::plan("list")
[16:18:43.185]                   options(future.plan = NULL)
[16:18:43.185]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.185]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.185]                 }
[16:18:43.185]                 ...future.workdir <- getwd()
[16:18:43.185]             }
[16:18:43.185]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.185]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.185]         }
[16:18:43.185]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.185]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.185]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.185]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.185]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.185]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.185]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.185]             base::names(...future.oldOptions))
[16:18:43.185]     }
[16:18:43.185]     if (FALSE) {
[16:18:43.185]     }
[16:18:43.185]     else {
[16:18:43.185]         if (TRUE) {
[16:18:43.185]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.185]                 open = "w")
[16:18:43.185]         }
[16:18:43.185]         else {
[16:18:43.185]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.185]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.185]         }
[16:18:43.185]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.185]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.185]             base::sink(type = "output", split = FALSE)
[16:18:43.185]             base::close(...future.stdout)
[16:18:43.185]         }, add = TRUE)
[16:18:43.185]     }
[16:18:43.185]     ...future.frame <- base::sys.nframe()
[16:18:43.185]     ...future.conditions <- base::list()
[16:18:43.185]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.185]     if (FALSE) {
[16:18:43.185]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.185]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.185]     }
[16:18:43.185]     ...future.result <- base::tryCatch({
[16:18:43.185]         base::withCallingHandlers({
[16:18:43.185]             ...future.value <- base::withVisible(base::local({
[16:18:43.185]                 withCallingHandlers({
[16:18:43.185]                   {
[16:18:43.185]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.185]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.185]                       ...future.globals.maxSize)) {
[16:18:43.185]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.185]                       on.exit(options(oopts), add = TRUE)
[16:18:43.185]                     }
[16:18:43.185]                     {
[16:18:43.185]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.185]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.185]                         USE.NAMES = FALSE)
[16:18:43.185]                       do.call(mapply, args = args)
[16:18:43.185]                     }
[16:18:43.185]                   }
[16:18:43.185]                 }, immediateCondition = function(cond) {
[16:18:43.185]                   save_rds <- function (object, pathname, ...) 
[16:18:43.185]                   {
[16:18:43.185]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.185]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.185]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.185]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.185]                         fi_tmp[["mtime"]])
[16:18:43.185]                     }
[16:18:43.185]                     tryCatch({
[16:18:43.185]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.185]                     }, error = function(ex) {
[16:18:43.185]                       msg <- conditionMessage(ex)
[16:18:43.185]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.185]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.185]                         fi_tmp[["mtime"]], msg)
[16:18:43.185]                       ex$message <- msg
[16:18:43.185]                       stop(ex)
[16:18:43.185]                     })
[16:18:43.185]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.185]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.185]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.185]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.185]                       fi <- file.info(pathname)
[16:18:43.185]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.185]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.185]                         fi[["size"]], fi[["mtime"]])
[16:18:43.185]                       stop(msg)
[16:18:43.185]                     }
[16:18:43.185]                     invisible(pathname)
[16:18:43.185]                   }
[16:18:43.185]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.185]                     rootPath = tempdir()) 
[16:18:43.185]                   {
[16:18:43.185]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.185]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.185]                       tmpdir = path, fileext = ".rds")
[16:18:43.185]                     save_rds(obj, file)
[16:18:43.185]                   }
[16:18:43.185]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.185]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.185]                   {
[16:18:43.185]                     inherits <- base::inherits
[16:18:43.185]                     invokeRestart <- base::invokeRestart
[16:18:43.185]                     is.null <- base::is.null
[16:18:43.185]                     muffled <- FALSE
[16:18:43.185]                     if (inherits(cond, "message")) {
[16:18:43.185]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.185]                       if (muffled) 
[16:18:43.185]                         invokeRestart("muffleMessage")
[16:18:43.185]                     }
[16:18:43.185]                     else if (inherits(cond, "warning")) {
[16:18:43.185]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.185]                       if (muffled) 
[16:18:43.185]                         invokeRestart("muffleWarning")
[16:18:43.185]                     }
[16:18:43.185]                     else if (inherits(cond, "condition")) {
[16:18:43.185]                       if (!is.null(pattern)) {
[16:18:43.185]                         computeRestarts <- base::computeRestarts
[16:18:43.185]                         grepl <- base::grepl
[16:18:43.185]                         restarts <- computeRestarts(cond)
[16:18:43.185]                         for (restart in restarts) {
[16:18:43.185]                           name <- restart$name
[16:18:43.185]                           if (is.null(name)) 
[16:18:43.185]                             next
[16:18:43.185]                           if (!grepl(pattern, name)) 
[16:18:43.185]                             next
[16:18:43.185]                           invokeRestart(restart)
[16:18:43.185]                           muffled <- TRUE
[16:18:43.185]                           break
[16:18:43.185]                         }
[16:18:43.185]                       }
[16:18:43.185]                     }
[16:18:43.185]                     invisible(muffled)
[16:18:43.185]                   }
[16:18:43.185]                   muffleCondition(cond)
[16:18:43.185]                 })
[16:18:43.185]             }))
[16:18:43.185]             future::FutureResult(value = ...future.value$value, 
[16:18:43.185]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.185]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.185]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.185]                     ...future.globalenv.names))
[16:18:43.185]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.185]         }, condition = base::local({
[16:18:43.185]             c <- base::c
[16:18:43.185]             inherits <- base::inherits
[16:18:43.185]             invokeRestart <- base::invokeRestart
[16:18:43.185]             length <- base::length
[16:18:43.185]             list <- base::list
[16:18:43.185]             seq.int <- base::seq.int
[16:18:43.185]             signalCondition <- base::signalCondition
[16:18:43.185]             sys.calls <- base::sys.calls
[16:18:43.185]             `[[` <- base::`[[`
[16:18:43.185]             `+` <- base::`+`
[16:18:43.185]             `<<-` <- base::`<<-`
[16:18:43.185]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.185]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.185]                   3L)]
[16:18:43.185]             }
[16:18:43.185]             function(cond) {
[16:18:43.185]                 is_error <- inherits(cond, "error")
[16:18:43.185]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.185]                   NULL)
[16:18:43.185]                 if (is_error) {
[16:18:43.185]                   sessionInformation <- function() {
[16:18:43.185]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.185]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.185]                       search = base::search(), system = base::Sys.info())
[16:18:43.185]                   }
[16:18:43.185]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.185]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.185]                     cond$call), session = sessionInformation(), 
[16:18:43.185]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.185]                   signalCondition(cond)
[16:18:43.185]                 }
[16:18:43.185]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.185]                 "immediateCondition"))) {
[16:18:43.185]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.185]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.185]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.185]                   if (TRUE && !signal) {
[16:18:43.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.185]                     {
[16:18:43.185]                       inherits <- base::inherits
[16:18:43.185]                       invokeRestart <- base::invokeRestart
[16:18:43.185]                       is.null <- base::is.null
[16:18:43.185]                       muffled <- FALSE
[16:18:43.185]                       if (inherits(cond, "message")) {
[16:18:43.185]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.185]                         if (muffled) 
[16:18:43.185]                           invokeRestart("muffleMessage")
[16:18:43.185]                       }
[16:18:43.185]                       else if (inherits(cond, "warning")) {
[16:18:43.185]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.185]                         if (muffled) 
[16:18:43.185]                           invokeRestart("muffleWarning")
[16:18:43.185]                       }
[16:18:43.185]                       else if (inherits(cond, "condition")) {
[16:18:43.185]                         if (!is.null(pattern)) {
[16:18:43.185]                           computeRestarts <- base::computeRestarts
[16:18:43.185]                           grepl <- base::grepl
[16:18:43.185]                           restarts <- computeRestarts(cond)
[16:18:43.185]                           for (restart in restarts) {
[16:18:43.185]                             name <- restart$name
[16:18:43.185]                             if (is.null(name)) 
[16:18:43.185]                               next
[16:18:43.185]                             if (!grepl(pattern, name)) 
[16:18:43.185]                               next
[16:18:43.185]                             invokeRestart(restart)
[16:18:43.185]                             muffled <- TRUE
[16:18:43.185]                             break
[16:18:43.185]                           }
[16:18:43.185]                         }
[16:18:43.185]                       }
[16:18:43.185]                       invisible(muffled)
[16:18:43.185]                     }
[16:18:43.185]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.185]                   }
[16:18:43.185]                 }
[16:18:43.185]                 else {
[16:18:43.185]                   if (TRUE) {
[16:18:43.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.185]                     {
[16:18:43.185]                       inherits <- base::inherits
[16:18:43.185]                       invokeRestart <- base::invokeRestart
[16:18:43.185]                       is.null <- base::is.null
[16:18:43.185]                       muffled <- FALSE
[16:18:43.185]                       if (inherits(cond, "message")) {
[16:18:43.185]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.185]                         if (muffled) 
[16:18:43.185]                           invokeRestart("muffleMessage")
[16:18:43.185]                       }
[16:18:43.185]                       else if (inherits(cond, "warning")) {
[16:18:43.185]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.185]                         if (muffled) 
[16:18:43.185]                           invokeRestart("muffleWarning")
[16:18:43.185]                       }
[16:18:43.185]                       else if (inherits(cond, "condition")) {
[16:18:43.185]                         if (!is.null(pattern)) {
[16:18:43.185]                           computeRestarts <- base::computeRestarts
[16:18:43.185]                           grepl <- base::grepl
[16:18:43.185]                           restarts <- computeRestarts(cond)
[16:18:43.185]                           for (restart in restarts) {
[16:18:43.185]                             name <- restart$name
[16:18:43.185]                             if (is.null(name)) 
[16:18:43.185]                               next
[16:18:43.185]                             if (!grepl(pattern, name)) 
[16:18:43.185]                               next
[16:18:43.185]                             invokeRestart(restart)
[16:18:43.185]                             muffled <- TRUE
[16:18:43.185]                             break
[16:18:43.185]                           }
[16:18:43.185]                         }
[16:18:43.185]                       }
[16:18:43.185]                       invisible(muffled)
[16:18:43.185]                     }
[16:18:43.185]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.185]                   }
[16:18:43.185]                 }
[16:18:43.185]             }
[16:18:43.185]         }))
[16:18:43.185]     }, error = function(ex) {
[16:18:43.185]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.185]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.185]                 ...future.rng), started = ...future.startTime, 
[16:18:43.185]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.185]             version = "1.8"), class = "FutureResult")
[16:18:43.185]     }, finally = {
[16:18:43.185]         if (!identical(...future.workdir, getwd())) 
[16:18:43.185]             setwd(...future.workdir)
[16:18:43.185]         {
[16:18:43.185]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.185]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.185]             }
[16:18:43.185]             base::options(...future.oldOptions)
[16:18:43.185]             if (.Platform$OS.type == "windows") {
[16:18:43.185]                 old_names <- names(...future.oldEnvVars)
[16:18:43.185]                 envs <- base::Sys.getenv()
[16:18:43.185]                 names <- names(envs)
[16:18:43.185]                 common <- intersect(names, old_names)
[16:18:43.185]                 added <- setdiff(names, old_names)
[16:18:43.185]                 removed <- setdiff(old_names, names)
[16:18:43.185]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.185]                   envs[common]]
[16:18:43.185]                 NAMES <- toupper(changed)
[16:18:43.185]                 args <- list()
[16:18:43.185]                 for (kk in seq_along(NAMES)) {
[16:18:43.185]                   name <- changed[[kk]]
[16:18:43.185]                   NAME <- NAMES[[kk]]
[16:18:43.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.185]                     next
[16:18:43.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.185]                 }
[16:18:43.185]                 NAMES <- toupper(added)
[16:18:43.185]                 for (kk in seq_along(NAMES)) {
[16:18:43.185]                   name <- added[[kk]]
[16:18:43.185]                   NAME <- NAMES[[kk]]
[16:18:43.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.185]                     next
[16:18:43.185]                   args[[name]] <- ""
[16:18:43.185]                 }
[16:18:43.185]                 NAMES <- toupper(removed)
[16:18:43.185]                 for (kk in seq_along(NAMES)) {
[16:18:43.185]                   name <- removed[[kk]]
[16:18:43.185]                   NAME <- NAMES[[kk]]
[16:18:43.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.185]                     next
[16:18:43.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.185]                 }
[16:18:43.185]                 if (length(args) > 0) 
[16:18:43.185]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.185]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.185]             }
[16:18:43.185]             else {
[16:18:43.185]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.185]             }
[16:18:43.185]             {
[16:18:43.185]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.185]                   0L) {
[16:18:43.185]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.185]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.185]                   base::options(opts)
[16:18:43.185]                 }
[16:18:43.185]                 {
[16:18:43.185]                   {
[16:18:43.185]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.185]                     NULL
[16:18:43.185]                   }
[16:18:43.185]                   options(future.plan = NULL)
[16:18:43.185]                   if (is.na(NA_character_)) 
[16:18:43.185]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.185]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.185]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.185]                     .init = FALSE)
[16:18:43.185]                 }
[16:18:43.185]             }
[16:18:43.185]         }
[16:18:43.185]     })
[16:18:43.185]     if (TRUE) {
[16:18:43.185]         base::sink(type = "output", split = FALSE)
[16:18:43.185]         if (TRUE) {
[16:18:43.185]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.185]         }
[16:18:43.185]         else {
[16:18:43.185]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.185]         }
[16:18:43.185]         base::close(...future.stdout)
[16:18:43.185]         ...future.stdout <- NULL
[16:18:43.185]     }
[16:18:43.185]     ...future.result$conditions <- ...future.conditions
[16:18:43.185]     ...future.result$finished <- base::Sys.time()
[16:18:43.185]     ...future.result
[16:18:43.185] }
[16:18:43.188] assign_globals() ...
[16:18:43.188] List of 5
[16:18:43.188]  $ ...future.FUN            :function (x, ...)  
[16:18:43.188]  $ MoreArgs                 : NULL
[16:18:43.188]  $ ...future.elements_ii    :List of 2
[16:18:43.188]   ..$ :List of 2
[16:18:43.188]   .. ..$ : int 3
[16:18:43.188]   .. ..$ : int 4
[16:18:43.188]   ..$ :List of 2
[16:18:43.188]   .. ..$ : int 2
[16:18:43.188]   .. ..$ : int 1
[16:18:43.188]  $ ...future.seeds_ii       : NULL
[16:18:43.188]  $ ...future.globals.maxSize: NULL
[16:18:43.188]  - attr(*, "where")=List of 5
[16:18:43.188]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.188]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.188]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.188]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.188]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.188]  - attr(*, "resolved")= logi FALSE
[16:18:43.188]  - attr(*, "total_size")= num 280
[16:18:43.188]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.188]  - attr(*, "already-done")= logi TRUE
[16:18:43.198] - copied ‘...future.FUN’ to environment
[16:18:43.198] - copied ‘MoreArgs’ to environment
[16:18:43.198] - copied ‘...future.elements_ii’ to environment
[16:18:43.198] - copied ‘...future.seeds_ii’ to environment
[16:18:43.198] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.198] assign_globals() ... done
[16:18:43.198] requestCore(): workers = 2
[16:18:43.201] MulticoreFuture started
[16:18:43.201] - Launch lazy future ... done
[16:18:43.201] run() for ‘MulticoreFuture’ ... done
[16:18:43.202] Created future:
[16:18:43.202] plan(): Setting new future strategy stack:
[16:18:43.202] List of future strategies:
[16:18:43.202] 1. sequential:
[16:18:43.202]    - args: function (..., envir = parent.frame())
[16:18:43.202]    - tweaked: FALSE
[16:18:43.202]    - call: NULL
[16:18:43.203] plan(): nbrOfWorkers() = 1
[16:18:43.205] plan(): Setting new future strategy stack:
[16:18:43.205] List of future strategies:
[16:18:43.205] 1. multicore:
[16:18:43.205]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.205]    - tweaked: FALSE
[16:18:43.205]    - call: plan(strategy)
[16:18:43.211] plan(): nbrOfWorkers() = 2
[16:18:43.202] MulticoreFuture:
[16:18:43.202] Label: ‘future_mapply-2’
[16:18:43.202] Expression:
[16:18:43.202] {
[16:18:43.202]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.202]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.202]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.202]         on.exit(options(oopts), add = TRUE)
[16:18:43.202]     }
[16:18:43.202]     {
[16:18:43.202]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.202]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.202]         do.call(mapply, args = args)
[16:18:43.202]     }
[16:18:43.202] }
[16:18:43.202] Lazy evaluation: FALSE
[16:18:43.202] Asynchronous evaluation: TRUE
[16:18:43.202] Local evaluation: TRUE
[16:18:43.202] Environment: R_GlobalEnv
[16:18:43.202] Capture standard output: TRUE
[16:18:43.202] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.202] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.202] Packages: <none>
[16:18:43.202] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:43.202] Resolved: TRUE
[16:18:43.202] Value: <not collected>
[16:18:43.202] Conditions captured: <none>
[16:18:43.202] Early signaling: FALSE
[16:18:43.202] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.202] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.213] Chunk #2 of 2 ... DONE
[16:18:43.213] Launching 2 futures (chunks) ... DONE
[16:18:43.213] Resolving 2 futures (chunks) ...
[16:18:43.213] resolve() on list ...
[16:18:43.213]  recursive: 0
[16:18:43.213]  length: 2
[16:18:43.213] 
[16:18:43.214] Future #1
[16:18:43.214] result() for MulticoreFuture ...
[16:18:43.215] result() for MulticoreFuture ...
[16:18:43.215] result() for MulticoreFuture ... done
[16:18:43.215] result() for MulticoreFuture ... done
[16:18:43.215] result() for MulticoreFuture ...
[16:18:43.215] result() for MulticoreFuture ... done
[16:18:43.216] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:43.216] - nx: 2
[16:18:43.216] - relay: TRUE
[16:18:43.216] - stdout: TRUE
[16:18:43.216] - signal: TRUE
[16:18:43.216] - resignal: FALSE
[16:18:43.217] - force: TRUE
[16:18:43.217] - relayed: [n=2] FALSE, FALSE
[16:18:43.217] - queued futures: [n=2] FALSE, FALSE
[16:18:43.217]  - until=1
[16:18:43.217]  - relaying element #1
[16:18:43.217] result() for MulticoreFuture ...
[16:18:43.218] result() for MulticoreFuture ... done
[16:18:43.218] result() for MulticoreFuture ...
[16:18:43.218] result() for MulticoreFuture ... done
[16:18:43.218] result() for MulticoreFuture ...
[16:18:43.218] result() for MulticoreFuture ... done
[16:18:43.218] result() for MulticoreFuture ...
[16:18:43.223] result() for MulticoreFuture ... done
[16:18:43.223] - relayed: [n=2] TRUE, FALSE
[16:18:43.223] - queued futures: [n=2] TRUE, FALSE
[16:18:43.224] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:43.224]  length: 1 (resolved future 1)
[16:18:43.225] Future #2
[16:18:43.225] result() for MulticoreFuture ...
[16:18:43.226] result() for MulticoreFuture ...
[16:18:43.226] result() for MulticoreFuture ... done
[16:18:43.227] result() for MulticoreFuture ... done
[16:18:43.227] result() for MulticoreFuture ...
[16:18:43.227] result() for MulticoreFuture ... done
[16:18:43.227] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:43.227] - nx: 2
[16:18:43.228] - relay: TRUE
[16:18:43.228] - stdout: TRUE
[16:18:43.228] - signal: TRUE
[16:18:43.228] - resignal: FALSE
[16:18:43.228] - force: TRUE
[16:18:43.228] - relayed: [n=2] TRUE, FALSE
[16:18:43.229] - queued futures: [n=2] TRUE, FALSE
[16:18:43.229]  - until=2
[16:18:43.229]  - relaying element #2
[16:18:43.229] result() for MulticoreFuture ...
[16:18:43.229] result() for MulticoreFuture ... done
[16:18:43.229] result() for MulticoreFuture ...
[16:18:43.230] result() for MulticoreFuture ... done
[16:18:43.230] result() for MulticoreFuture ...
[16:18:43.230] result() for MulticoreFuture ... done
[16:18:43.230] result() for MulticoreFuture ...
[16:18:43.230] result() for MulticoreFuture ... done
[16:18:43.230] - relayed: [n=2] TRUE, TRUE
[16:18:43.230] - queued futures: [n=2] TRUE, TRUE
[16:18:43.231] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:43.231]  length: 0 (resolved future 2)
[16:18:43.231] Relaying remaining futures
[16:18:43.231] signalConditionsASAP(NULL, pos=0) ...
[16:18:43.231] - nx: 2
[16:18:43.231] - relay: TRUE
[16:18:43.231] - stdout: TRUE
[16:18:43.232] - signal: TRUE
[16:18:43.232] - resignal: FALSE
[16:18:43.232] - force: TRUE
[16:18:43.232] - relayed: [n=2] TRUE, TRUE
[16:18:43.232] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:43.232] - relayed: [n=2] TRUE, TRUE
[16:18:43.233] - queued futures: [n=2] TRUE, TRUE
[16:18:43.233] signalConditionsASAP(NULL, pos=0) ... done
[16:18:43.233] resolve() on list ... DONE
[16:18:43.233] result() for MulticoreFuture ...
[16:18:43.233] result() for MulticoreFuture ... done
[16:18:43.233] result() for MulticoreFuture ...
[16:18:43.233] result() for MulticoreFuture ... done
[16:18:43.234] result() for MulticoreFuture ...
[16:18:43.234] result() for MulticoreFuture ... done
[16:18:43.234] result() for MulticoreFuture ...
[16:18:43.234] result() for MulticoreFuture ... done
[16:18:43.234]  - Number of value chunks collected: 2
[16:18:43.234] Resolving 2 futures (chunks) ... DONE
[16:18:43.235] Reducing values from 2 chunks ...
[16:18:43.235]  - Number of values collected after concatenation: 4
[16:18:43.235]  - Number of values expected: 4
[16:18:43.235] Reducing values from 2 chunks ... DONE
[16:18:43.235] future_mapply() ... DONE
- Parallel RNG ...
[16:18:43.235] future_mapply() ...
[16:18:43.235] Generating random seeds ...
[16:18:43.236] Generating random seed streams for 4 elements ...
[16:18:43.236] Generating random seed streams for 4 elements ... DONE
[16:18:43.236] Generating random seeds ... DONE
[16:18:43.236] Will set RNG state on exit: 10407, 788975707, -1162111843, -682504231, -909439414, 2137587272, -328729136
[16:18:43.240] Number of chunks: 2
[16:18:43.241] getGlobalsAndPackagesXApply() ...
[16:18:43.241]  - future.globals: TRUE
[16:18:43.241] getGlobalsAndPackages() ...
[16:18:43.241] Searching for globals...
[16:18:43.242] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[16:18:43.243] Searching for globals ... DONE
[16:18:43.243] Resolving globals: FALSE
[16:18:43.243] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[16:18:43.244] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[16:18:43.244] - globals: [1] ‘FUN’
[16:18:43.244] - packages: [1] ‘stats’
[16:18:43.244] getGlobalsAndPackages() ... DONE
[16:18:43.244]  - globals found/used: [n=1] ‘FUN’
[16:18:43.244]  - needed namespaces: [n=1] ‘stats’
[16:18:43.244] Finding globals ... DONE
[16:18:43.245] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:43.245] List of 2
[16:18:43.245]  $ ...future.FUN:function (n, min = 0, max = 1)  
[16:18:43.245]  $ MoreArgs     :List of 1
[16:18:43.245]   ..$ min: num 1
[16:18:43.245]  - attr(*, "where")=List of 2
[16:18:43.245]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:43.245]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:43.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.245]  - attr(*, "resolved")= logi FALSE
[16:18:43.245]  - attr(*, "total_size")= num NA
[16:18:43.248] Packages to be attached in all futures: [n=1] ‘stats’
[16:18:43.248] getGlobalsAndPackagesXApply() ... DONE
[16:18:43.248] Number of futures (= number of chunks): 2
[16:18:43.248] Launching 2 futures (chunks) ...
[16:18:43.248] Chunk #1 of 2 ...
[16:18:43.249]  - Finding globals in '...' for chunk #1 ...
[16:18:43.249] getGlobalsAndPackages() ...
[16:18:43.249] Searching for globals...
[16:18:43.249] 
[16:18:43.249] Searching for globals ... DONE
[16:18:43.249] - globals: [0] <none>
[16:18:43.249] getGlobalsAndPackages() ... DONE
[16:18:43.250]    + additional globals found: [n=0] 
[16:18:43.250]    + additional namespaces needed: [n=0] 
[16:18:43.250]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:43.250]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.250]  - seeds: [2] <seeds>
[16:18:43.250]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.250] getGlobalsAndPackages() ...
[16:18:43.250] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.250] Resolving globals: FALSE
[16:18:43.254] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[16:18:43.254] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[16:18:43.254] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.254] - packages: [1] ‘stats’
[16:18:43.255] getGlobalsAndPackages() ... DONE
[16:18:43.255] run() for ‘Future’ ...
[16:18:43.255] - state: ‘created’
[16:18:43.255] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.259] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.259] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.259]   - Field: ‘label’
[16:18:43.259]   - Field: ‘local’
[16:18:43.260]   - Field: ‘owner’
[16:18:43.260]   - Field: ‘envir’
[16:18:43.260]   - Field: ‘workers’
[16:18:43.260]   - Field: ‘packages’
[16:18:43.260]   - Field: ‘gc’
[16:18:43.260]   - Field: ‘job’
[16:18:43.260]   - Field: ‘conditions’
[16:18:43.260]   - Field: ‘expr’
[16:18:43.261]   - Field: ‘uuid’
[16:18:43.261]   - Field: ‘seed’
[16:18:43.261]   - Field: ‘version’
[16:18:43.261]   - Field: ‘result’
[16:18:43.261]   - Field: ‘asynchronous’
[16:18:43.261]   - Field: ‘calls’
[16:18:43.261]   - Field: ‘globals’
[16:18:43.261]   - Field: ‘stdout’
[16:18:43.262]   - Field: ‘earlySignal’
[16:18:43.262]   - Field: ‘lazy’
[16:18:43.262]   - Field: ‘state’
[16:18:43.262] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.262] - Launch lazy future ...
[16:18:43.262] Packages needed by the future expression (n = 1): ‘stats’
[16:18:43.262] Packages needed by future strategies (n = 0): <none>
[16:18:43.263] {
[16:18:43.263]     {
[16:18:43.263]         {
[16:18:43.263]             ...future.startTime <- base::Sys.time()
[16:18:43.263]             {
[16:18:43.263]                 {
[16:18:43.263]                   {
[16:18:43.263]                     {
[16:18:43.263]                       {
[16:18:43.263]                         base::local({
[16:18:43.263]                           has_future <- base::requireNamespace("future", 
[16:18:43.263]                             quietly = TRUE)
[16:18:43.263]                           if (has_future) {
[16:18:43.263]                             ns <- base::getNamespace("future")
[16:18:43.263]                             version <- ns[[".package"]][["version"]]
[16:18:43.263]                             if (is.null(version)) 
[16:18:43.263]                               version <- utils::packageVersion("future")
[16:18:43.263]                           }
[16:18:43.263]                           else {
[16:18:43.263]                             version <- NULL
[16:18:43.263]                           }
[16:18:43.263]                           if (!has_future || version < "1.8.0") {
[16:18:43.263]                             info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.263]                               "", base::R.version$version.string), 
[16:18:43.263]                               platform = base::sprintf("%s (%s-bit)", 
[16:18:43.263]                                 base::R.version$platform, 8 * 
[16:18:43.263]                                   base::.Machine$sizeof.pointer), 
[16:18:43.263]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.263]                                 "release", "version")], collapse = " "), 
[16:18:43.263]                               hostname = base::Sys.info()[["nodename"]])
[16:18:43.263]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.263]                               info)
[16:18:43.263]                             info <- base::paste(info, collapse = "; ")
[16:18:43.263]                             if (!has_future) {
[16:18:43.263]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.263]                                 info)
[16:18:43.263]                             }
[16:18:43.263]                             else {
[16:18:43.263]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.263]                                 info, version)
[16:18:43.263]                             }
[16:18:43.263]                             base::stop(msg)
[16:18:43.263]                           }
[16:18:43.263]                         })
[16:18:43.263]                       }
[16:18:43.263]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.263]                       base::options(mc.cores = 1L)
[16:18:43.263]                     }
[16:18:43.263]                     base::local({
[16:18:43.263]                       for (pkg in "stats") {
[16:18:43.263]                         base::loadNamespace(pkg)
[16:18:43.263]                         base::library(pkg, character.only = TRUE)
[16:18:43.263]                       }
[16:18:43.263]                     })
[16:18:43.263]                   }
[16:18:43.263]                   ...future.strategy.old <- future::plan("list")
[16:18:43.263]                   options(future.plan = NULL)
[16:18:43.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.263]                 }
[16:18:43.263]                 ...future.workdir <- getwd()
[16:18:43.263]             }
[16:18:43.263]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.263]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.263]         }
[16:18:43.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.263]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.263]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.263]             base::names(...future.oldOptions))
[16:18:43.263]     }
[16:18:43.263]     if (FALSE) {
[16:18:43.263]     }
[16:18:43.263]     else {
[16:18:43.263]         if (TRUE) {
[16:18:43.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.263]                 open = "w")
[16:18:43.263]         }
[16:18:43.263]         else {
[16:18:43.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.263]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.263]         }
[16:18:43.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.263]             base::sink(type = "output", split = FALSE)
[16:18:43.263]             base::close(...future.stdout)
[16:18:43.263]         }, add = TRUE)
[16:18:43.263]     }
[16:18:43.263]     ...future.frame <- base::sys.nframe()
[16:18:43.263]     ...future.conditions <- base::list()
[16:18:43.263]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.263]     if (FALSE) {
[16:18:43.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.263]     }
[16:18:43.263]     ...future.result <- base::tryCatch({
[16:18:43.263]         base::withCallingHandlers({
[16:18:43.263]             ...future.value <- base::withVisible(base::local({
[16:18:43.263]                 withCallingHandlers({
[16:18:43.263]                   {
[16:18:43.263]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.263]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.263]                       ...future.globals.maxSize)) {
[16:18:43.263]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.263]                       on.exit(options(oopts), add = TRUE)
[16:18:43.263]                     }
[16:18:43.263]                     {
[16:18:43.263]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:43.263]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[16:18:43.263]                           envir = globalenv(), inherits = FALSE)
[16:18:43.263]                         ...future.FUN(...)
[16:18:43.263]                       }
[16:18:43.263]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:43.263]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:43.263]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.263]                         USE.NAMES = FALSE)
[16:18:43.263]                       do.call(mapply, args = args)
[16:18:43.263]                     }
[16:18:43.263]                   }
[16:18:43.263]                 }, immediateCondition = function(cond) {
[16:18:43.263]                   save_rds <- function (object, pathname, ...) 
[16:18:43.263]                   {
[16:18:43.263]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.263]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.263]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.263]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.263]                         fi_tmp[["mtime"]])
[16:18:43.263]                     }
[16:18:43.263]                     tryCatch({
[16:18:43.263]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.263]                     }, error = function(ex) {
[16:18:43.263]                       msg <- conditionMessage(ex)
[16:18:43.263]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.263]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.263]                         fi_tmp[["mtime"]], msg)
[16:18:43.263]                       ex$message <- msg
[16:18:43.263]                       stop(ex)
[16:18:43.263]                     })
[16:18:43.263]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.263]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.263]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.263]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.263]                       fi <- file.info(pathname)
[16:18:43.263]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.263]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.263]                         fi[["size"]], fi[["mtime"]])
[16:18:43.263]                       stop(msg)
[16:18:43.263]                     }
[16:18:43.263]                     invisible(pathname)
[16:18:43.263]                   }
[16:18:43.263]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.263]                     rootPath = tempdir()) 
[16:18:43.263]                   {
[16:18:43.263]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.263]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.263]                       tmpdir = path, fileext = ".rds")
[16:18:43.263]                     save_rds(obj, file)
[16:18:43.263]                   }
[16:18:43.263]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.263]                   {
[16:18:43.263]                     inherits <- base::inherits
[16:18:43.263]                     invokeRestart <- base::invokeRestart
[16:18:43.263]                     is.null <- base::is.null
[16:18:43.263]                     muffled <- FALSE
[16:18:43.263]                     if (inherits(cond, "message")) {
[16:18:43.263]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.263]                       if (muffled) 
[16:18:43.263]                         invokeRestart("muffleMessage")
[16:18:43.263]                     }
[16:18:43.263]                     else if (inherits(cond, "warning")) {
[16:18:43.263]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.263]                       if (muffled) 
[16:18:43.263]                         invokeRestart("muffleWarning")
[16:18:43.263]                     }
[16:18:43.263]                     else if (inherits(cond, "condition")) {
[16:18:43.263]                       if (!is.null(pattern)) {
[16:18:43.263]                         computeRestarts <- base::computeRestarts
[16:18:43.263]                         grepl <- base::grepl
[16:18:43.263]                         restarts <- computeRestarts(cond)
[16:18:43.263]                         for (restart in restarts) {
[16:18:43.263]                           name <- restart$name
[16:18:43.263]                           if (is.null(name)) 
[16:18:43.263]                             next
[16:18:43.263]                           if (!grepl(pattern, name)) 
[16:18:43.263]                             next
[16:18:43.263]                           invokeRestart(restart)
[16:18:43.263]                           muffled <- TRUE
[16:18:43.263]                           break
[16:18:43.263]                         }
[16:18:43.263]                       }
[16:18:43.263]                     }
[16:18:43.263]                     invisible(muffled)
[16:18:43.263]                   }
[16:18:43.263]                   muffleCondition(cond)
[16:18:43.263]                 })
[16:18:43.263]             }))
[16:18:43.263]             future::FutureResult(value = ...future.value$value, 
[16:18:43.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.263]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.263]                     ...future.globalenv.names))
[16:18:43.263]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.263]         }, condition = base::local({
[16:18:43.263]             c <- base::c
[16:18:43.263]             inherits <- base::inherits
[16:18:43.263]             invokeRestart <- base::invokeRestart
[16:18:43.263]             length <- base::length
[16:18:43.263]             list <- base::list
[16:18:43.263]             seq.int <- base::seq.int
[16:18:43.263]             signalCondition <- base::signalCondition
[16:18:43.263]             sys.calls <- base::sys.calls
[16:18:43.263]             `[[` <- base::`[[`
[16:18:43.263]             `+` <- base::`+`
[16:18:43.263]             `<<-` <- base::`<<-`
[16:18:43.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.263]                   3L)]
[16:18:43.263]             }
[16:18:43.263]             function(cond) {
[16:18:43.263]                 is_error <- inherits(cond, "error")
[16:18:43.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.263]                   NULL)
[16:18:43.263]                 if (is_error) {
[16:18:43.263]                   sessionInformation <- function() {
[16:18:43.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.263]                       search = base::search(), system = base::Sys.info())
[16:18:43.263]                   }
[16:18:43.263]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.263]                     cond$call), session = sessionInformation(), 
[16:18:43.263]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.263]                   signalCondition(cond)
[16:18:43.263]                 }
[16:18:43.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.263]                 "immediateCondition"))) {
[16:18:43.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.263]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.263]                   if (TRUE && !signal) {
[16:18:43.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.263]                     {
[16:18:43.263]                       inherits <- base::inherits
[16:18:43.263]                       invokeRestart <- base::invokeRestart
[16:18:43.263]                       is.null <- base::is.null
[16:18:43.263]                       muffled <- FALSE
[16:18:43.263]                       if (inherits(cond, "message")) {
[16:18:43.263]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.263]                         if (muffled) 
[16:18:43.263]                           invokeRestart("muffleMessage")
[16:18:43.263]                       }
[16:18:43.263]                       else if (inherits(cond, "warning")) {
[16:18:43.263]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.263]                         if (muffled) 
[16:18:43.263]                           invokeRestart("muffleWarning")
[16:18:43.263]                       }
[16:18:43.263]                       else if (inherits(cond, "condition")) {
[16:18:43.263]                         if (!is.null(pattern)) {
[16:18:43.263]                           computeRestarts <- base::computeRestarts
[16:18:43.263]                           grepl <- base::grepl
[16:18:43.263]                           restarts <- computeRestarts(cond)
[16:18:43.263]                           for (restart in restarts) {
[16:18:43.263]                             name <- restart$name
[16:18:43.263]                             if (is.null(name)) 
[16:18:43.263]                               next
[16:18:43.263]                             if (!grepl(pattern, name)) 
[16:18:43.263]                               next
[16:18:43.263]                             invokeRestart(restart)
[16:18:43.263]                             muffled <- TRUE
[16:18:43.263]                             break
[16:18:43.263]                           }
[16:18:43.263]                         }
[16:18:43.263]                       }
[16:18:43.263]                       invisible(muffled)
[16:18:43.263]                     }
[16:18:43.263]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.263]                   }
[16:18:43.263]                 }
[16:18:43.263]                 else {
[16:18:43.263]                   if (TRUE) {
[16:18:43.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.263]                     {
[16:18:43.263]                       inherits <- base::inherits
[16:18:43.263]                       invokeRestart <- base::invokeRestart
[16:18:43.263]                       is.null <- base::is.null
[16:18:43.263]                       muffled <- FALSE
[16:18:43.263]                       if (inherits(cond, "message")) {
[16:18:43.263]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.263]                         if (muffled) 
[16:18:43.263]                           invokeRestart("muffleMessage")
[16:18:43.263]                       }
[16:18:43.263]                       else if (inherits(cond, "warning")) {
[16:18:43.263]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.263]                         if (muffled) 
[16:18:43.263]                           invokeRestart("muffleWarning")
[16:18:43.263]                       }
[16:18:43.263]                       else if (inherits(cond, "condition")) {
[16:18:43.263]                         if (!is.null(pattern)) {
[16:18:43.263]                           computeRestarts <- base::computeRestarts
[16:18:43.263]                           grepl <- base::grepl
[16:18:43.263]                           restarts <- computeRestarts(cond)
[16:18:43.263]                           for (restart in restarts) {
[16:18:43.263]                             name <- restart$name
[16:18:43.263]                             if (is.null(name)) 
[16:18:43.263]                               next
[16:18:43.263]                             if (!grepl(pattern, name)) 
[16:18:43.263]                               next
[16:18:43.263]                             invokeRestart(restart)
[16:18:43.263]                             muffled <- TRUE
[16:18:43.263]                             break
[16:18:43.263]                           }
[16:18:43.263]                         }
[16:18:43.263]                       }
[16:18:43.263]                       invisible(muffled)
[16:18:43.263]                     }
[16:18:43.263]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.263]                   }
[16:18:43.263]                 }
[16:18:43.263]             }
[16:18:43.263]         }))
[16:18:43.263]     }, error = function(ex) {
[16:18:43.263]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.263]                 ...future.rng), started = ...future.startTime, 
[16:18:43.263]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.263]             version = "1.8"), class = "FutureResult")
[16:18:43.263]     }, finally = {
[16:18:43.263]         if (!identical(...future.workdir, getwd())) 
[16:18:43.263]             setwd(...future.workdir)
[16:18:43.263]         {
[16:18:43.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.263]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.263]             }
[16:18:43.263]             base::options(...future.oldOptions)
[16:18:43.263]             if (.Platform$OS.type == "windows") {
[16:18:43.263]                 old_names <- names(...future.oldEnvVars)
[16:18:43.263]                 envs <- base::Sys.getenv()
[16:18:43.263]                 names <- names(envs)
[16:18:43.263]                 common <- intersect(names, old_names)
[16:18:43.263]                 added <- setdiff(names, old_names)
[16:18:43.263]                 removed <- setdiff(old_names, names)
[16:18:43.263]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.263]                   envs[common]]
[16:18:43.263]                 NAMES <- toupper(changed)
[16:18:43.263]                 args <- list()
[16:18:43.263]                 for (kk in seq_along(NAMES)) {
[16:18:43.263]                   name <- changed[[kk]]
[16:18:43.263]                   NAME <- NAMES[[kk]]
[16:18:43.263]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.263]                     next
[16:18:43.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.263]                 }
[16:18:43.263]                 NAMES <- toupper(added)
[16:18:43.263]                 for (kk in seq_along(NAMES)) {
[16:18:43.263]                   name <- added[[kk]]
[16:18:43.263]                   NAME <- NAMES[[kk]]
[16:18:43.263]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.263]                     next
[16:18:43.263]                   args[[name]] <- ""
[16:18:43.263]                 }
[16:18:43.263]                 NAMES <- toupper(removed)
[16:18:43.263]                 for (kk in seq_along(NAMES)) {
[16:18:43.263]                   name <- removed[[kk]]
[16:18:43.263]                   NAME <- NAMES[[kk]]
[16:18:43.263]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.263]                     next
[16:18:43.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.263]                 }
[16:18:43.263]                 if (length(args) > 0) 
[16:18:43.263]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.263]             }
[16:18:43.263]             else {
[16:18:43.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.263]             }
[16:18:43.263]             {
[16:18:43.263]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.263]                   0L) {
[16:18:43.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.263]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.263]                   base::options(opts)
[16:18:43.263]                 }
[16:18:43.263]                 {
[16:18:43.263]                   {
[16:18:43.263]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.263]                     NULL
[16:18:43.263]                   }
[16:18:43.263]                   options(future.plan = NULL)
[16:18:43.263]                   if (is.na(NA_character_)) 
[16:18:43.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.263]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.263]                     .init = FALSE)
[16:18:43.263]                 }
[16:18:43.263]             }
[16:18:43.263]         }
[16:18:43.263]     })
[16:18:43.263]     if (TRUE) {
[16:18:43.263]         base::sink(type = "output", split = FALSE)
[16:18:43.263]         if (TRUE) {
[16:18:43.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.263]         }
[16:18:43.263]         else {
[16:18:43.263]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.263]         }
[16:18:43.263]         base::close(...future.stdout)
[16:18:43.263]         ...future.stdout <- NULL
[16:18:43.263]     }
[16:18:43.263]     ...future.result$conditions <- ...future.conditions
[16:18:43.263]     ...future.result$finished <- base::Sys.time()
[16:18:43.263]     ...future.result
[16:18:43.263] }
[16:18:43.266] assign_globals() ...
[16:18:43.266] List of 5
[16:18:43.266]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[16:18:43.266]  $ MoreArgs                 :List of 1
[16:18:43.266]   ..$ min: num 1
[16:18:43.266]  $ ...future.elements_ii    :List of 2
[16:18:43.266]   ..$ n  :List of 2
[16:18:43.266]   .. ..$ : int 1
[16:18:43.266]   .. ..$ : int 2
[16:18:43.266]   ..$ max:List of 2
[16:18:43.266]   .. ..$ : int 2
[16:18:43.266]   .. ..$ : int 3
[16:18:43.266]  $ ...future.seeds_ii       :List of 2
[16:18:43.266]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[16:18:43.266]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[16:18:43.266]  $ ...future.globals.maxSize: NULL
[16:18:43.266]  - attr(*, "where")=List of 5
[16:18:43.266]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.266]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.266]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.266]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.266]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.266]  - attr(*, "resolved")= logi FALSE
[16:18:43.266]  - attr(*, "total_size")= num 2528
[16:18:43.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.266]  - attr(*, "already-done")= logi TRUE
[16:18:43.272] - copied ‘...future.FUN’ to environment
[16:18:43.273] - copied ‘MoreArgs’ to environment
[16:18:43.273] - copied ‘...future.elements_ii’ to environment
[16:18:43.273] - copied ‘...future.seeds_ii’ to environment
[16:18:43.273] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.273] assign_globals() ... done
[16:18:43.273] requestCore(): workers = 2
[16:18:43.275] MulticoreFuture started
[16:18:43.276] - Launch lazy future ... done
[16:18:43.276] run() for ‘MulticoreFuture’ ... done
[16:18:43.276] Created future:
[16:18:43.277] plan(): Setting new future strategy stack:
[16:18:43.277] List of future strategies:
[16:18:43.277] 1. sequential:
[16:18:43.277]    - args: function (..., envir = parent.frame())
[16:18:43.277]    - tweaked: FALSE
[16:18:43.277]    - call: NULL
[16:18:43.278] plan(): nbrOfWorkers() = 1
[16:18:43.280] plan(): Setting new future strategy stack:
[16:18:43.280] List of future strategies:
[16:18:43.280] 1. multicore:
[16:18:43.280]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.280]    - tweaked: FALSE
[16:18:43.280]    - call: plan(strategy)
[16:18:43.277] MulticoreFuture:
[16:18:43.277] Label: ‘future_mapply-1’
[16:18:43.277] Expression:
[16:18:43.277] {
[16:18:43.277]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.277]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.277]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.277]         on.exit(options(oopts), add = TRUE)
[16:18:43.277]     }
[16:18:43.277]     {
[16:18:43.277]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:43.277]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[16:18:43.277]                 inherits = FALSE)
[16:18:43.277]             ...future.FUN(...)
[16:18:43.277]         }
[16:18:43.277]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:43.277]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:43.277]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.277]         do.call(mapply, args = args)
[16:18:43.277]     }
[16:18:43.277] }
[16:18:43.277] Lazy evaluation: FALSE
[16:18:43.277] Asynchronous evaluation: TRUE
[16:18:43.277] Local evaluation: TRUE
[16:18:43.277] Environment: R_GlobalEnv
[16:18:43.277] Capture standard output: TRUE
[16:18:43.277] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.277] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.277] Packages: 1 packages (‘stats’)
[16:18:43.277] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:18:43.277] Resolved: FALSE
[16:18:43.277] Value: <not collected>
[16:18:43.277] Conditions captured: <none>
[16:18:43.277] Early signaling: FALSE
[16:18:43.277] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.277] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.289] Chunk #1 of 2 ... DONE
[16:18:43.289] Chunk #2 of 2 ...
[16:18:43.290]  - Finding globals in '...' for chunk #2 ...
[16:18:43.290] getGlobalsAndPackages() ...
[16:18:43.290] Searching for globals...
[16:18:43.291] 
[16:18:43.291] Searching for globals ... DONE
[16:18:43.291] - globals: [0] <none>
[16:18:43.291] getGlobalsAndPackages() ... DONE
[16:18:43.291] plan(): nbrOfWorkers() = 2
[16:18:43.291]    + additional globals found: [n=0] 
[16:18:43.294]    + additional namespaces needed: [n=0] 
[16:18:43.294]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:43.295]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.295]  - seeds: [2] <seeds>
[16:18:43.295]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.296] getGlobalsAndPackages() ...
[16:18:43.296] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.296] Resolving globals: FALSE
[16:18:43.298] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[16:18:43.299] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[16:18:43.300] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.300] - packages: [1] ‘stats’
[16:18:43.300] getGlobalsAndPackages() ... DONE
[16:18:43.301] run() for ‘Future’ ...
[16:18:43.301] - state: ‘created’
[16:18:43.301] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.307] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.307] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.307]   - Field: ‘label’
[16:18:43.308]   - Field: ‘local’
[16:18:43.308]   - Field: ‘owner’
[16:18:43.308]   - Field: ‘envir’
[16:18:43.308]   - Field: ‘workers’
[16:18:43.308]   - Field: ‘packages’
[16:18:43.309]   - Field: ‘gc’
[16:18:43.309]   - Field: ‘job’
[16:18:43.309]   - Field: ‘conditions’
[16:18:43.309]   - Field: ‘expr’
[16:18:43.310]   - Field: ‘uuid’
[16:18:43.310]   - Field: ‘seed’
[16:18:43.310]   - Field: ‘version’
[16:18:43.310]   - Field: ‘result’
[16:18:43.310]   - Field: ‘asynchronous’
[16:18:43.311]   - Field: ‘calls’
[16:18:43.311]   - Field: ‘globals’
[16:18:43.311]   - Field: ‘stdout’
[16:18:43.311]   - Field: ‘earlySignal’
[16:18:43.311]   - Field: ‘lazy’
[16:18:43.312]   - Field: ‘state’
[16:18:43.312] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.312] - Launch lazy future ...
[16:18:43.312] Packages needed by the future expression (n = 1): ‘stats’
[16:18:43.313] Packages needed by future strategies (n = 0): <none>
[16:18:43.313] {
[16:18:43.313]     {
[16:18:43.313]         {
[16:18:43.313]             ...future.startTime <- base::Sys.time()
[16:18:43.313]             {
[16:18:43.313]                 {
[16:18:43.313]                   {
[16:18:43.313]                     {
[16:18:43.313]                       {
[16:18:43.313]                         base::local({
[16:18:43.313]                           has_future <- base::requireNamespace("future", 
[16:18:43.313]                             quietly = TRUE)
[16:18:43.313]                           if (has_future) {
[16:18:43.313]                             ns <- base::getNamespace("future")
[16:18:43.313]                             version <- ns[[".package"]][["version"]]
[16:18:43.313]                             if (is.null(version)) 
[16:18:43.313]                               version <- utils::packageVersion("future")
[16:18:43.313]                           }
[16:18:43.313]                           else {
[16:18:43.313]                             version <- NULL
[16:18:43.313]                           }
[16:18:43.313]                           if (!has_future || version < "1.8.0") {
[16:18:43.313]                             info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.313]                               "", base::R.version$version.string), 
[16:18:43.313]                               platform = base::sprintf("%s (%s-bit)", 
[16:18:43.313]                                 base::R.version$platform, 8 * 
[16:18:43.313]                                   base::.Machine$sizeof.pointer), 
[16:18:43.313]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.313]                                 "release", "version")], collapse = " "), 
[16:18:43.313]                               hostname = base::Sys.info()[["nodename"]])
[16:18:43.313]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.313]                               info)
[16:18:43.313]                             info <- base::paste(info, collapse = "; ")
[16:18:43.313]                             if (!has_future) {
[16:18:43.313]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.313]                                 info)
[16:18:43.313]                             }
[16:18:43.313]                             else {
[16:18:43.313]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.313]                                 info, version)
[16:18:43.313]                             }
[16:18:43.313]                             base::stop(msg)
[16:18:43.313]                           }
[16:18:43.313]                         })
[16:18:43.313]                       }
[16:18:43.313]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.313]                       base::options(mc.cores = 1L)
[16:18:43.313]                     }
[16:18:43.313]                     base::local({
[16:18:43.313]                       for (pkg in "stats") {
[16:18:43.313]                         base::loadNamespace(pkg)
[16:18:43.313]                         base::library(pkg, character.only = TRUE)
[16:18:43.313]                       }
[16:18:43.313]                     })
[16:18:43.313]                   }
[16:18:43.313]                   ...future.strategy.old <- future::plan("list")
[16:18:43.313]                   options(future.plan = NULL)
[16:18:43.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.313]                 }
[16:18:43.313]                 ...future.workdir <- getwd()
[16:18:43.313]             }
[16:18:43.313]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.313]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.313]         }
[16:18:43.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.313]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.313]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.313]             base::names(...future.oldOptions))
[16:18:43.313]     }
[16:18:43.313]     if (FALSE) {
[16:18:43.313]     }
[16:18:43.313]     else {
[16:18:43.313]         if (TRUE) {
[16:18:43.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.313]                 open = "w")
[16:18:43.313]         }
[16:18:43.313]         else {
[16:18:43.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.313]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.313]         }
[16:18:43.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.313]             base::sink(type = "output", split = FALSE)
[16:18:43.313]             base::close(...future.stdout)
[16:18:43.313]         }, add = TRUE)
[16:18:43.313]     }
[16:18:43.313]     ...future.frame <- base::sys.nframe()
[16:18:43.313]     ...future.conditions <- base::list()
[16:18:43.313]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.313]     if (FALSE) {
[16:18:43.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.313]     }
[16:18:43.313]     ...future.result <- base::tryCatch({
[16:18:43.313]         base::withCallingHandlers({
[16:18:43.313]             ...future.value <- base::withVisible(base::local({
[16:18:43.313]                 withCallingHandlers({
[16:18:43.313]                   {
[16:18:43.313]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.313]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.313]                       ...future.globals.maxSize)) {
[16:18:43.313]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.313]                       on.exit(options(oopts), add = TRUE)
[16:18:43.313]                     }
[16:18:43.313]                     {
[16:18:43.313]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:43.313]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[16:18:43.313]                           envir = globalenv(), inherits = FALSE)
[16:18:43.313]                         ...future.FUN(...)
[16:18:43.313]                       }
[16:18:43.313]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:43.313]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:43.313]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.313]                         USE.NAMES = FALSE)
[16:18:43.313]                       do.call(mapply, args = args)
[16:18:43.313]                     }
[16:18:43.313]                   }
[16:18:43.313]                 }, immediateCondition = function(cond) {
[16:18:43.313]                   save_rds <- function (object, pathname, ...) 
[16:18:43.313]                   {
[16:18:43.313]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.313]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.313]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.313]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.313]                         fi_tmp[["mtime"]])
[16:18:43.313]                     }
[16:18:43.313]                     tryCatch({
[16:18:43.313]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.313]                     }, error = function(ex) {
[16:18:43.313]                       msg <- conditionMessage(ex)
[16:18:43.313]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.313]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.313]                         fi_tmp[["mtime"]], msg)
[16:18:43.313]                       ex$message <- msg
[16:18:43.313]                       stop(ex)
[16:18:43.313]                     })
[16:18:43.313]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.313]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.313]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.313]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.313]                       fi <- file.info(pathname)
[16:18:43.313]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.313]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.313]                         fi[["size"]], fi[["mtime"]])
[16:18:43.313]                       stop(msg)
[16:18:43.313]                     }
[16:18:43.313]                     invisible(pathname)
[16:18:43.313]                   }
[16:18:43.313]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.313]                     rootPath = tempdir()) 
[16:18:43.313]                   {
[16:18:43.313]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.313]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.313]                       tmpdir = path, fileext = ".rds")
[16:18:43.313]                     save_rds(obj, file)
[16:18:43.313]                   }
[16:18:43.313]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.313]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.313]                   {
[16:18:43.313]                     inherits <- base::inherits
[16:18:43.313]                     invokeRestart <- base::invokeRestart
[16:18:43.313]                     is.null <- base::is.null
[16:18:43.313]                     muffled <- FALSE
[16:18:43.313]                     if (inherits(cond, "message")) {
[16:18:43.313]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.313]                       if (muffled) 
[16:18:43.313]                         invokeRestart("muffleMessage")
[16:18:43.313]                     }
[16:18:43.313]                     else if (inherits(cond, "warning")) {
[16:18:43.313]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.313]                       if (muffled) 
[16:18:43.313]                         invokeRestart("muffleWarning")
[16:18:43.313]                     }
[16:18:43.313]                     else if (inherits(cond, "condition")) {
[16:18:43.313]                       if (!is.null(pattern)) {
[16:18:43.313]                         computeRestarts <- base::computeRestarts
[16:18:43.313]                         grepl <- base::grepl
[16:18:43.313]                         restarts <- computeRestarts(cond)
[16:18:43.313]                         for (restart in restarts) {
[16:18:43.313]                           name <- restart$name
[16:18:43.313]                           if (is.null(name)) 
[16:18:43.313]                             next
[16:18:43.313]                           if (!grepl(pattern, name)) 
[16:18:43.313]                             next
[16:18:43.313]                           invokeRestart(restart)
[16:18:43.313]                           muffled <- TRUE
[16:18:43.313]                           break
[16:18:43.313]                         }
[16:18:43.313]                       }
[16:18:43.313]                     }
[16:18:43.313]                     invisible(muffled)
[16:18:43.313]                   }
[16:18:43.313]                   muffleCondition(cond)
[16:18:43.313]                 })
[16:18:43.313]             }))
[16:18:43.313]             future::FutureResult(value = ...future.value$value, 
[16:18:43.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.313]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.313]                     ...future.globalenv.names))
[16:18:43.313]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.313]         }, condition = base::local({
[16:18:43.313]             c <- base::c
[16:18:43.313]             inherits <- base::inherits
[16:18:43.313]             invokeRestart <- base::invokeRestart
[16:18:43.313]             length <- base::length
[16:18:43.313]             list <- base::list
[16:18:43.313]             seq.int <- base::seq.int
[16:18:43.313]             signalCondition <- base::signalCondition
[16:18:43.313]             sys.calls <- base::sys.calls
[16:18:43.313]             `[[` <- base::`[[`
[16:18:43.313]             `+` <- base::`+`
[16:18:43.313]             `<<-` <- base::`<<-`
[16:18:43.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.313]                   3L)]
[16:18:43.313]             }
[16:18:43.313]             function(cond) {
[16:18:43.313]                 is_error <- inherits(cond, "error")
[16:18:43.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.313]                   NULL)
[16:18:43.313]                 if (is_error) {
[16:18:43.313]                   sessionInformation <- function() {
[16:18:43.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.313]                       search = base::search(), system = base::Sys.info())
[16:18:43.313]                   }
[16:18:43.313]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.313]                     cond$call), session = sessionInformation(), 
[16:18:43.313]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.313]                   signalCondition(cond)
[16:18:43.313]                 }
[16:18:43.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.313]                 "immediateCondition"))) {
[16:18:43.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.313]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.313]                   if (TRUE && !signal) {
[16:18:43.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.313]                     {
[16:18:43.313]                       inherits <- base::inherits
[16:18:43.313]                       invokeRestart <- base::invokeRestart
[16:18:43.313]                       is.null <- base::is.null
[16:18:43.313]                       muffled <- FALSE
[16:18:43.313]                       if (inherits(cond, "message")) {
[16:18:43.313]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.313]                         if (muffled) 
[16:18:43.313]                           invokeRestart("muffleMessage")
[16:18:43.313]                       }
[16:18:43.313]                       else if (inherits(cond, "warning")) {
[16:18:43.313]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.313]                         if (muffled) 
[16:18:43.313]                           invokeRestart("muffleWarning")
[16:18:43.313]                       }
[16:18:43.313]                       else if (inherits(cond, "condition")) {
[16:18:43.313]                         if (!is.null(pattern)) {
[16:18:43.313]                           computeRestarts <- base::computeRestarts
[16:18:43.313]                           grepl <- base::grepl
[16:18:43.313]                           restarts <- computeRestarts(cond)
[16:18:43.313]                           for (restart in restarts) {
[16:18:43.313]                             name <- restart$name
[16:18:43.313]                             if (is.null(name)) 
[16:18:43.313]                               next
[16:18:43.313]                             if (!grepl(pattern, name)) 
[16:18:43.313]                               next
[16:18:43.313]                             invokeRestart(restart)
[16:18:43.313]                             muffled <- TRUE
[16:18:43.313]                             break
[16:18:43.313]                           }
[16:18:43.313]                         }
[16:18:43.313]                       }
[16:18:43.313]                       invisible(muffled)
[16:18:43.313]                     }
[16:18:43.313]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.313]                   }
[16:18:43.313]                 }
[16:18:43.313]                 else {
[16:18:43.313]                   if (TRUE) {
[16:18:43.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.313]                     {
[16:18:43.313]                       inherits <- base::inherits
[16:18:43.313]                       invokeRestart <- base::invokeRestart
[16:18:43.313]                       is.null <- base::is.null
[16:18:43.313]                       muffled <- FALSE
[16:18:43.313]                       if (inherits(cond, "message")) {
[16:18:43.313]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.313]                         if (muffled) 
[16:18:43.313]                           invokeRestart("muffleMessage")
[16:18:43.313]                       }
[16:18:43.313]                       else if (inherits(cond, "warning")) {
[16:18:43.313]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.313]                         if (muffled) 
[16:18:43.313]                           invokeRestart("muffleWarning")
[16:18:43.313]                       }
[16:18:43.313]                       else if (inherits(cond, "condition")) {
[16:18:43.313]                         if (!is.null(pattern)) {
[16:18:43.313]                           computeRestarts <- base::computeRestarts
[16:18:43.313]                           grepl <- base::grepl
[16:18:43.313]                           restarts <- computeRestarts(cond)
[16:18:43.313]                           for (restart in restarts) {
[16:18:43.313]                             name <- restart$name
[16:18:43.313]                             if (is.null(name)) 
[16:18:43.313]                               next
[16:18:43.313]                             if (!grepl(pattern, name)) 
[16:18:43.313]                               next
[16:18:43.313]                             invokeRestart(restart)
[16:18:43.313]                             muffled <- TRUE
[16:18:43.313]                             break
[16:18:43.313]                           }
[16:18:43.313]                         }
[16:18:43.313]                       }
[16:18:43.313]                       invisible(muffled)
[16:18:43.313]                     }
[16:18:43.313]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.313]                   }
[16:18:43.313]                 }
[16:18:43.313]             }
[16:18:43.313]         }))
[16:18:43.313]     }, error = function(ex) {
[16:18:43.313]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.313]                 ...future.rng), started = ...future.startTime, 
[16:18:43.313]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.313]             version = "1.8"), class = "FutureResult")
[16:18:43.313]     }, finally = {
[16:18:43.313]         if (!identical(...future.workdir, getwd())) 
[16:18:43.313]             setwd(...future.workdir)
[16:18:43.313]         {
[16:18:43.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.313]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.313]             }
[16:18:43.313]             base::options(...future.oldOptions)
[16:18:43.313]             if (.Platform$OS.type == "windows") {
[16:18:43.313]                 old_names <- names(...future.oldEnvVars)
[16:18:43.313]                 envs <- base::Sys.getenv()
[16:18:43.313]                 names <- names(envs)
[16:18:43.313]                 common <- intersect(names, old_names)
[16:18:43.313]                 added <- setdiff(names, old_names)
[16:18:43.313]                 removed <- setdiff(old_names, names)
[16:18:43.313]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.313]                   envs[common]]
[16:18:43.313]                 NAMES <- toupper(changed)
[16:18:43.313]                 args <- list()
[16:18:43.313]                 for (kk in seq_along(NAMES)) {
[16:18:43.313]                   name <- changed[[kk]]
[16:18:43.313]                   NAME <- NAMES[[kk]]
[16:18:43.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.313]                     next
[16:18:43.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.313]                 }
[16:18:43.313]                 NAMES <- toupper(added)
[16:18:43.313]                 for (kk in seq_along(NAMES)) {
[16:18:43.313]                   name <- added[[kk]]
[16:18:43.313]                   NAME <- NAMES[[kk]]
[16:18:43.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.313]                     next
[16:18:43.313]                   args[[name]] <- ""
[16:18:43.313]                 }
[16:18:43.313]                 NAMES <- toupper(removed)
[16:18:43.313]                 for (kk in seq_along(NAMES)) {
[16:18:43.313]                   name <- removed[[kk]]
[16:18:43.313]                   NAME <- NAMES[[kk]]
[16:18:43.313]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.313]                     next
[16:18:43.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.313]                 }
[16:18:43.313]                 if (length(args) > 0) 
[16:18:43.313]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.313]             }
[16:18:43.313]             else {
[16:18:43.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.313]             }
[16:18:43.313]             {
[16:18:43.313]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.313]                   0L) {
[16:18:43.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.313]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.313]                   base::options(opts)
[16:18:43.313]                 }
[16:18:43.313]                 {
[16:18:43.313]                   {
[16:18:43.313]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.313]                     NULL
[16:18:43.313]                   }
[16:18:43.313]                   options(future.plan = NULL)
[16:18:43.313]                   if (is.na(NA_character_)) 
[16:18:43.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.313]                     .init = FALSE)
[16:18:43.313]                 }
[16:18:43.313]             }
[16:18:43.313]         }
[16:18:43.313]     })
[16:18:43.313]     if (TRUE) {
[16:18:43.313]         base::sink(type = "output", split = FALSE)
[16:18:43.313]         if (TRUE) {
[16:18:43.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.313]         }
[16:18:43.313]         else {
[16:18:43.313]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.313]         }
[16:18:43.313]         base::close(...future.stdout)
[16:18:43.313]         ...future.stdout <- NULL
[16:18:43.313]     }
[16:18:43.313]     ...future.result$conditions <- ...future.conditions
[16:18:43.313]     ...future.result$finished <- base::Sys.time()
[16:18:43.313]     ...future.result
[16:18:43.313] }
[16:18:43.316] assign_globals() ...
[16:18:43.317] List of 5
[16:18:43.317]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[16:18:43.317]  $ MoreArgs                 :List of 1
[16:18:43.317]   ..$ min: num 1
[16:18:43.317]  $ ...future.elements_ii    :List of 2
[16:18:43.317]   ..$ n  :List of 2
[16:18:43.317]   .. ..$ : int 3
[16:18:43.317]   .. ..$ : int 4
[16:18:43.317]   ..$ max:List of 2
[16:18:43.317]   .. ..$ : int 4
[16:18:43.317]   .. ..$ : int 5
[16:18:43.317]  $ ...future.seeds_ii       :List of 2
[16:18:43.317]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[16:18:43.317]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[16:18:43.317]  $ ...future.globals.maxSize: NULL
[16:18:43.317]  - attr(*, "where")=List of 5
[16:18:43.317]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.317]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.317]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.317]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.317]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.317]  - attr(*, "resolved")= logi FALSE
[16:18:43.317]  - attr(*, "total_size")= num 2528
[16:18:43.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.317]  - attr(*, "already-done")= logi TRUE
[16:18:43.326] - copied ‘...future.FUN’ to environment
[16:18:43.326] - copied ‘MoreArgs’ to environment
[16:18:43.326] - copied ‘...future.elements_ii’ to environment
[16:18:43.326] - copied ‘...future.seeds_ii’ to environment
[16:18:43.326] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.326] assign_globals() ... done
[16:18:43.326] requestCore(): workers = 2
[16:18:43.329] MulticoreFuture started
[16:18:43.329] - Launch lazy future ... done
[16:18:43.329] run() for ‘MulticoreFuture’ ... done
[16:18:43.330] Created future:
[16:18:43.330] plan(): Setting new future strategy stack:
[16:18:43.331] List of future strategies:
[16:18:43.331] 1. sequential:
[16:18:43.331]    - args: function (..., envir = parent.frame())
[16:18:43.331]    - tweaked: FALSE
[16:18:43.331]    - call: NULL
[16:18:43.331] plan(): nbrOfWorkers() = 1
[16:18:43.333] plan(): Setting new future strategy stack:
[16:18:43.334] List of future strategies:
[16:18:43.334] 1. multicore:
[16:18:43.334]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.334]    - tweaked: FALSE
[16:18:43.334]    - call: plan(strategy)
[16:18:43.330] MulticoreFuture:
[16:18:43.330] Label: ‘future_mapply-2’
[16:18:43.330] Expression:
[16:18:43.330] {
[16:18:43.330]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.330]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.330]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.330]         on.exit(options(oopts), add = TRUE)
[16:18:43.330]     }
[16:18:43.330]     {
[16:18:43.330]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:43.330]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[16:18:43.330]                 inherits = FALSE)
[16:18:43.330]             ...future.FUN(...)
[16:18:43.330]         }
[16:18:43.330]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:43.330]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:43.330]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.330]         do.call(mapply, args = args)
[16:18:43.330]     }
[16:18:43.330] }
[16:18:43.330] Lazy evaluation: FALSE
[16:18:43.330] Asynchronous evaluation: TRUE
[16:18:43.330] Local evaluation: TRUE
[16:18:43.330] Environment: R_GlobalEnv
[16:18:43.330] Capture standard output: TRUE
[16:18:43.330] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.330] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.330] Packages: 1 packages (‘stats’)
[16:18:43.330] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:18:43.330] Resolved: FALSE
[16:18:43.330] Value: <not collected>
[16:18:43.330] Conditions captured: <none>
[16:18:43.330] Early signaling: FALSE
[16:18:43.330] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.330] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.343] Chunk #2 of 2 ... DONE
[16:18:43.343] Launching 2 futures (chunks) ... DONE
[16:18:43.343] Resolving 2 futures (chunks) ...
[16:18:43.346] plan(): nbrOfWorkers() = 2
[16:18:43.344] resolve() on list ...
[16:18:43.347]  recursive: 0
[16:18:43.347]  length: 2
[16:18:43.347] 
[16:18:43.348] Future #1
[16:18:43.348] result() for MulticoreFuture ...
[16:18:43.349] result() for MulticoreFuture ...
[16:18:43.350] result() for MulticoreFuture ... done
[16:18:43.350] result() for MulticoreFuture ... done
[16:18:43.350] result() for MulticoreFuture ...
[16:18:43.350] result() for MulticoreFuture ... done
[16:18:43.351] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:43.351] - nx: 2
[16:18:43.351] - relay: TRUE
[16:18:43.352] - stdout: TRUE
[16:18:43.352] - signal: TRUE
[16:18:43.352] - resignal: FALSE
[16:18:43.352] - force: TRUE
[16:18:43.353] - relayed: [n=2] FALSE, FALSE
[16:18:43.353] - queued futures: [n=2] FALSE, FALSE
[16:18:43.353]  - until=1
[16:18:43.353]  - relaying element #1
[16:18:43.354] result() for MulticoreFuture ...
[16:18:43.354] result() for MulticoreFuture ... done
[16:18:43.354] result() for MulticoreFuture ...
[16:18:43.354] result() for MulticoreFuture ... done
[16:18:43.355] result() for MulticoreFuture ...
[16:18:43.355] result() for MulticoreFuture ... done
[16:18:43.355] result() for MulticoreFuture ...
[16:18:43.355] result() for MulticoreFuture ... done
[16:18:43.356] - relayed: [n=2] TRUE, FALSE
[16:18:43.356] - queued futures: [n=2] TRUE, FALSE
[16:18:43.356] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:43.356]  length: 1 (resolved future 1)
[16:18:43.357] Future #2
[16:18:43.357] result() for MulticoreFuture ...
[16:18:43.358] result() for MulticoreFuture ...
[16:18:43.358] result() for MulticoreFuture ... done
[16:18:43.358] result() for MulticoreFuture ... done
[16:18:43.358] result() for MulticoreFuture ...
[16:18:43.359] result() for MulticoreFuture ... done
[16:18:43.359] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:43.359] - nx: 2
[16:18:43.359] - relay: TRUE
[16:18:43.359] - stdout: TRUE
[16:18:43.360] - signal: TRUE
[16:18:43.360] - resignal: FALSE
[16:18:43.360] - force: TRUE
[16:18:43.360] - relayed: [n=2] TRUE, FALSE
[16:18:43.360] - queued futures: [n=2] TRUE, FALSE
[16:18:43.360]  - until=2
[16:18:43.361]  - relaying element #2
[16:18:43.361] result() for MulticoreFuture ...
[16:18:43.361] result() for MulticoreFuture ... done
[16:18:43.361] result() for MulticoreFuture ...
[16:18:43.361] result() for MulticoreFuture ... done
[16:18:43.361] result() for MulticoreFuture ...
[16:18:43.362] result() for MulticoreFuture ... done
[16:18:43.362] result() for MulticoreFuture ...
[16:18:43.362] result() for MulticoreFuture ... done
[16:18:43.362] - relayed: [n=2] TRUE, TRUE
[16:18:43.362] - queued futures: [n=2] TRUE, TRUE
[16:18:43.362] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:43.362]  length: 0 (resolved future 2)
[16:18:43.362] Relaying remaining futures
[16:18:43.362] signalConditionsASAP(NULL, pos=0) ...
[16:18:43.362] - nx: 2
[16:18:43.363] - relay: TRUE
[16:18:43.363] - stdout: TRUE
[16:18:43.363] - signal: TRUE
[16:18:43.363] - resignal: FALSE
[16:18:43.363] - force: TRUE
[16:18:43.363] - relayed: [n=2] TRUE, TRUE
[16:18:43.363] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:43.364] - relayed: [n=2] TRUE, TRUE
[16:18:43.364] - queued futures: [n=2] TRUE, TRUE
[16:18:43.364] signalConditionsASAP(NULL, pos=0) ... done
[16:18:43.364] resolve() on list ... DONE
[16:18:43.364] result() for MulticoreFuture ...
[16:18:43.364] result() for MulticoreFuture ... done
[16:18:43.364] result() for MulticoreFuture ...
[16:18:43.364] result() for MulticoreFuture ... done
[16:18:43.364] result() for MulticoreFuture ...
[16:18:43.365] result() for MulticoreFuture ... done
[16:18:43.365] result() for MulticoreFuture ...
[16:18:43.365] result() for MulticoreFuture ... done
[16:18:43.365]  - Number of value chunks collected: 2
[16:18:43.365] Resolving 2 futures (chunks) ... DONE
[16:18:43.365] Reducing values from 2 chunks ...
[16:18:43.365]  - Number of values collected after concatenation: 4
[16:18:43.365]  - Number of values expected: 4
[16:18:43.366] Reducing values from 2 chunks ... DONE
[16:18:43.366] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[16:18:43.366] future_mapply() ...
[16:18:43.371] Number of chunks: 2
[16:18:43.371] getGlobalsAndPackagesXApply() ...
[16:18:43.371]  - future.globals: TRUE
[16:18:43.371] getGlobalsAndPackages() ...
[16:18:43.371] Searching for globals...
[16:18:43.372] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:18:43.373] Searching for globals ... DONE
[16:18:43.373] Resolving globals: FALSE
[16:18:43.373] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[16:18:43.373] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[16:18:43.374] - globals: [1] ‘FUN’
[16:18:43.374] - packages: [1] ‘stats’
[16:18:43.374] getGlobalsAndPackages() ... DONE
[16:18:43.374]  - globals found/used: [n=1] ‘FUN’
[16:18:43.374]  - needed namespaces: [n=1] ‘stats’
[16:18:43.374] Finding globals ... DONE
[16:18:43.374] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:43.375] List of 2
[16:18:43.375]  $ ...future.FUN:function (x, w, ...)  
[16:18:43.375]  $ MoreArgs     : NULL
[16:18:43.375]  - attr(*, "where")=List of 2
[16:18:43.375]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:43.375]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:43.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.375]  - attr(*, "resolved")= logi FALSE
[16:18:43.375]  - attr(*, "total_size")= num NA
[16:18:43.380] Packages to be attached in all futures: [n=1] ‘stats’
[16:18:43.380] getGlobalsAndPackagesXApply() ... DONE
[16:18:43.381] Number of futures (= number of chunks): 2
[16:18:43.381] Launching 2 futures (chunks) ...
[16:18:43.381] Chunk #1 of 2 ...
[16:18:43.381]  - Finding globals in '...' for chunk #1 ...
[16:18:43.381] getGlobalsAndPackages() ...
[16:18:43.381] Searching for globals...
[16:18:43.382] 
[16:18:43.382] Searching for globals ... DONE
[16:18:43.382] - globals: [0] <none>
[16:18:43.382] getGlobalsAndPackages() ... DONE
[16:18:43.382]    + additional globals found: [n=0] 
[16:18:43.382]    + additional namespaces needed: [n=0] 
[16:18:43.383]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:43.383]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.383]  - seeds: <none>
[16:18:43.383]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.383] getGlobalsAndPackages() ...
[16:18:43.383] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.383] Resolving globals: FALSE
[16:18:43.384] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[16:18:43.385] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:43.385] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.385] - packages: [1] ‘stats’
[16:18:43.385] getGlobalsAndPackages() ... DONE
[16:18:43.385] run() for ‘Future’ ...
[16:18:43.386] - state: ‘created’
[16:18:43.386] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.390] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.390]   - Field: ‘label’
[16:18:43.391]   - Field: ‘local’
[16:18:43.391]   - Field: ‘owner’
[16:18:43.391]   - Field: ‘envir’
[16:18:43.391]   - Field: ‘workers’
[16:18:43.391]   - Field: ‘packages’
[16:18:43.391]   - Field: ‘gc’
[16:18:43.391]   - Field: ‘job’
[16:18:43.391]   - Field: ‘conditions’
[16:18:43.392]   - Field: ‘expr’
[16:18:43.392]   - Field: ‘uuid’
[16:18:43.392]   - Field: ‘seed’
[16:18:43.392]   - Field: ‘version’
[16:18:43.392]   - Field: ‘result’
[16:18:43.392]   - Field: ‘asynchronous’
[16:18:43.392]   - Field: ‘calls’
[16:18:43.392]   - Field: ‘globals’
[16:18:43.392]   - Field: ‘stdout’
[16:18:43.392]   - Field: ‘earlySignal’
[16:18:43.393]   - Field: ‘lazy’
[16:18:43.393]   - Field: ‘state’
[16:18:43.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.393] - Launch lazy future ...
[16:18:43.393] Packages needed by the future expression (n = 1): ‘stats’
[16:18:43.393] Packages needed by future strategies (n = 0): <none>
[16:18:43.394] {
[16:18:43.394]     {
[16:18:43.394]         {
[16:18:43.394]             ...future.startTime <- base::Sys.time()
[16:18:43.394]             {
[16:18:43.394]                 {
[16:18:43.394]                   {
[16:18:43.394]                     {
[16:18:43.394]                       {
[16:18:43.394]                         base::local({
[16:18:43.394]                           has_future <- base::requireNamespace("future", 
[16:18:43.394]                             quietly = TRUE)
[16:18:43.394]                           if (has_future) {
[16:18:43.394]                             ns <- base::getNamespace("future")
[16:18:43.394]                             version <- ns[[".package"]][["version"]]
[16:18:43.394]                             if (is.null(version)) 
[16:18:43.394]                               version <- utils::packageVersion("future")
[16:18:43.394]                           }
[16:18:43.394]                           else {
[16:18:43.394]                             version <- NULL
[16:18:43.394]                           }
[16:18:43.394]                           if (!has_future || version < "1.8.0") {
[16:18:43.394]                             info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.394]                               "", base::R.version$version.string), 
[16:18:43.394]                               platform = base::sprintf("%s (%s-bit)", 
[16:18:43.394]                                 base::R.version$platform, 8 * 
[16:18:43.394]                                   base::.Machine$sizeof.pointer), 
[16:18:43.394]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.394]                                 "release", "version")], collapse = " "), 
[16:18:43.394]                               hostname = base::Sys.info()[["nodename"]])
[16:18:43.394]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.394]                               info)
[16:18:43.394]                             info <- base::paste(info, collapse = "; ")
[16:18:43.394]                             if (!has_future) {
[16:18:43.394]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.394]                                 info)
[16:18:43.394]                             }
[16:18:43.394]                             else {
[16:18:43.394]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.394]                                 info, version)
[16:18:43.394]                             }
[16:18:43.394]                             base::stop(msg)
[16:18:43.394]                           }
[16:18:43.394]                         })
[16:18:43.394]                       }
[16:18:43.394]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.394]                       base::options(mc.cores = 1L)
[16:18:43.394]                     }
[16:18:43.394]                     base::local({
[16:18:43.394]                       for (pkg in "stats") {
[16:18:43.394]                         base::loadNamespace(pkg)
[16:18:43.394]                         base::library(pkg, character.only = TRUE)
[16:18:43.394]                       }
[16:18:43.394]                     })
[16:18:43.394]                   }
[16:18:43.394]                   ...future.strategy.old <- future::plan("list")
[16:18:43.394]                   options(future.plan = NULL)
[16:18:43.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.394]                 }
[16:18:43.394]                 ...future.workdir <- getwd()
[16:18:43.394]             }
[16:18:43.394]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.394]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.394]         }
[16:18:43.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.394]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.394]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.394]             base::names(...future.oldOptions))
[16:18:43.394]     }
[16:18:43.394]     if (FALSE) {
[16:18:43.394]     }
[16:18:43.394]     else {
[16:18:43.394]         if (TRUE) {
[16:18:43.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.394]                 open = "w")
[16:18:43.394]         }
[16:18:43.394]         else {
[16:18:43.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.394]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.394]         }
[16:18:43.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.394]             base::sink(type = "output", split = FALSE)
[16:18:43.394]             base::close(...future.stdout)
[16:18:43.394]         }, add = TRUE)
[16:18:43.394]     }
[16:18:43.394]     ...future.frame <- base::sys.nframe()
[16:18:43.394]     ...future.conditions <- base::list()
[16:18:43.394]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.394]     if (FALSE) {
[16:18:43.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.394]     }
[16:18:43.394]     ...future.result <- base::tryCatch({
[16:18:43.394]         base::withCallingHandlers({
[16:18:43.394]             ...future.value <- base::withVisible(base::local({
[16:18:43.394]                 withCallingHandlers({
[16:18:43.394]                   {
[16:18:43.394]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.394]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.394]                       ...future.globals.maxSize)) {
[16:18:43.394]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.394]                       on.exit(options(oopts), add = TRUE)
[16:18:43.394]                     }
[16:18:43.394]                     {
[16:18:43.394]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.394]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.394]                         USE.NAMES = FALSE)
[16:18:43.394]                       do.call(mapply, args = args)
[16:18:43.394]                     }
[16:18:43.394]                   }
[16:18:43.394]                 }, immediateCondition = function(cond) {
[16:18:43.394]                   save_rds <- function (object, pathname, ...) 
[16:18:43.394]                   {
[16:18:43.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.394]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.394]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.394]                         fi_tmp[["mtime"]])
[16:18:43.394]                     }
[16:18:43.394]                     tryCatch({
[16:18:43.394]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.394]                     }, error = function(ex) {
[16:18:43.394]                       msg <- conditionMessage(ex)
[16:18:43.394]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.394]                         fi_tmp[["mtime"]], msg)
[16:18:43.394]                       ex$message <- msg
[16:18:43.394]                       stop(ex)
[16:18:43.394]                     })
[16:18:43.394]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.394]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.394]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.394]                       fi <- file.info(pathname)
[16:18:43.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.394]                         fi[["size"]], fi[["mtime"]])
[16:18:43.394]                       stop(msg)
[16:18:43.394]                     }
[16:18:43.394]                     invisible(pathname)
[16:18:43.394]                   }
[16:18:43.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.394]                     rootPath = tempdir()) 
[16:18:43.394]                   {
[16:18:43.394]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.394]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.394]                       tmpdir = path, fileext = ".rds")
[16:18:43.394]                     save_rds(obj, file)
[16:18:43.394]                   }
[16:18:43.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.394]                   {
[16:18:43.394]                     inherits <- base::inherits
[16:18:43.394]                     invokeRestart <- base::invokeRestart
[16:18:43.394]                     is.null <- base::is.null
[16:18:43.394]                     muffled <- FALSE
[16:18:43.394]                     if (inherits(cond, "message")) {
[16:18:43.394]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.394]                       if (muffled) 
[16:18:43.394]                         invokeRestart("muffleMessage")
[16:18:43.394]                     }
[16:18:43.394]                     else if (inherits(cond, "warning")) {
[16:18:43.394]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.394]                       if (muffled) 
[16:18:43.394]                         invokeRestart("muffleWarning")
[16:18:43.394]                     }
[16:18:43.394]                     else if (inherits(cond, "condition")) {
[16:18:43.394]                       if (!is.null(pattern)) {
[16:18:43.394]                         computeRestarts <- base::computeRestarts
[16:18:43.394]                         grepl <- base::grepl
[16:18:43.394]                         restarts <- computeRestarts(cond)
[16:18:43.394]                         for (restart in restarts) {
[16:18:43.394]                           name <- restart$name
[16:18:43.394]                           if (is.null(name)) 
[16:18:43.394]                             next
[16:18:43.394]                           if (!grepl(pattern, name)) 
[16:18:43.394]                             next
[16:18:43.394]                           invokeRestart(restart)
[16:18:43.394]                           muffled <- TRUE
[16:18:43.394]                           break
[16:18:43.394]                         }
[16:18:43.394]                       }
[16:18:43.394]                     }
[16:18:43.394]                     invisible(muffled)
[16:18:43.394]                   }
[16:18:43.394]                   muffleCondition(cond)
[16:18:43.394]                 })
[16:18:43.394]             }))
[16:18:43.394]             future::FutureResult(value = ...future.value$value, 
[16:18:43.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.394]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.394]                     ...future.globalenv.names))
[16:18:43.394]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.394]         }, condition = base::local({
[16:18:43.394]             c <- base::c
[16:18:43.394]             inherits <- base::inherits
[16:18:43.394]             invokeRestart <- base::invokeRestart
[16:18:43.394]             length <- base::length
[16:18:43.394]             list <- base::list
[16:18:43.394]             seq.int <- base::seq.int
[16:18:43.394]             signalCondition <- base::signalCondition
[16:18:43.394]             sys.calls <- base::sys.calls
[16:18:43.394]             `[[` <- base::`[[`
[16:18:43.394]             `+` <- base::`+`
[16:18:43.394]             `<<-` <- base::`<<-`
[16:18:43.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.394]                   3L)]
[16:18:43.394]             }
[16:18:43.394]             function(cond) {
[16:18:43.394]                 is_error <- inherits(cond, "error")
[16:18:43.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.394]                   NULL)
[16:18:43.394]                 if (is_error) {
[16:18:43.394]                   sessionInformation <- function() {
[16:18:43.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.394]                       search = base::search(), system = base::Sys.info())
[16:18:43.394]                   }
[16:18:43.394]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.394]                     cond$call), session = sessionInformation(), 
[16:18:43.394]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.394]                   signalCondition(cond)
[16:18:43.394]                 }
[16:18:43.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.394]                 "immediateCondition"))) {
[16:18:43.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.394]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.394]                   if (TRUE && !signal) {
[16:18:43.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.394]                     {
[16:18:43.394]                       inherits <- base::inherits
[16:18:43.394]                       invokeRestart <- base::invokeRestart
[16:18:43.394]                       is.null <- base::is.null
[16:18:43.394]                       muffled <- FALSE
[16:18:43.394]                       if (inherits(cond, "message")) {
[16:18:43.394]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.394]                         if (muffled) 
[16:18:43.394]                           invokeRestart("muffleMessage")
[16:18:43.394]                       }
[16:18:43.394]                       else if (inherits(cond, "warning")) {
[16:18:43.394]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.394]                         if (muffled) 
[16:18:43.394]                           invokeRestart("muffleWarning")
[16:18:43.394]                       }
[16:18:43.394]                       else if (inherits(cond, "condition")) {
[16:18:43.394]                         if (!is.null(pattern)) {
[16:18:43.394]                           computeRestarts <- base::computeRestarts
[16:18:43.394]                           grepl <- base::grepl
[16:18:43.394]                           restarts <- computeRestarts(cond)
[16:18:43.394]                           for (restart in restarts) {
[16:18:43.394]                             name <- restart$name
[16:18:43.394]                             if (is.null(name)) 
[16:18:43.394]                               next
[16:18:43.394]                             if (!grepl(pattern, name)) 
[16:18:43.394]                               next
[16:18:43.394]                             invokeRestart(restart)
[16:18:43.394]                             muffled <- TRUE
[16:18:43.394]                             break
[16:18:43.394]                           }
[16:18:43.394]                         }
[16:18:43.394]                       }
[16:18:43.394]                       invisible(muffled)
[16:18:43.394]                     }
[16:18:43.394]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.394]                   }
[16:18:43.394]                 }
[16:18:43.394]                 else {
[16:18:43.394]                   if (TRUE) {
[16:18:43.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.394]                     {
[16:18:43.394]                       inherits <- base::inherits
[16:18:43.394]                       invokeRestart <- base::invokeRestart
[16:18:43.394]                       is.null <- base::is.null
[16:18:43.394]                       muffled <- FALSE
[16:18:43.394]                       if (inherits(cond, "message")) {
[16:18:43.394]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.394]                         if (muffled) 
[16:18:43.394]                           invokeRestart("muffleMessage")
[16:18:43.394]                       }
[16:18:43.394]                       else if (inherits(cond, "warning")) {
[16:18:43.394]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.394]                         if (muffled) 
[16:18:43.394]                           invokeRestart("muffleWarning")
[16:18:43.394]                       }
[16:18:43.394]                       else if (inherits(cond, "condition")) {
[16:18:43.394]                         if (!is.null(pattern)) {
[16:18:43.394]                           computeRestarts <- base::computeRestarts
[16:18:43.394]                           grepl <- base::grepl
[16:18:43.394]                           restarts <- computeRestarts(cond)
[16:18:43.394]                           for (restart in restarts) {
[16:18:43.394]                             name <- restart$name
[16:18:43.394]                             if (is.null(name)) 
[16:18:43.394]                               next
[16:18:43.394]                             if (!grepl(pattern, name)) 
[16:18:43.394]                               next
[16:18:43.394]                             invokeRestart(restart)
[16:18:43.394]                             muffled <- TRUE
[16:18:43.394]                             break
[16:18:43.394]                           }
[16:18:43.394]                         }
[16:18:43.394]                       }
[16:18:43.394]                       invisible(muffled)
[16:18:43.394]                     }
[16:18:43.394]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.394]                   }
[16:18:43.394]                 }
[16:18:43.394]             }
[16:18:43.394]         }))
[16:18:43.394]     }, error = function(ex) {
[16:18:43.394]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.394]                 ...future.rng), started = ...future.startTime, 
[16:18:43.394]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.394]             version = "1.8"), class = "FutureResult")
[16:18:43.394]     }, finally = {
[16:18:43.394]         if (!identical(...future.workdir, getwd())) 
[16:18:43.394]             setwd(...future.workdir)
[16:18:43.394]         {
[16:18:43.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.394]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.394]             }
[16:18:43.394]             base::options(...future.oldOptions)
[16:18:43.394]             if (.Platform$OS.type == "windows") {
[16:18:43.394]                 old_names <- names(...future.oldEnvVars)
[16:18:43.394]                 envs <- base::Sys.getenv()
[16:18:43.394]                 names <- names(envs)
[16:18:43.394]                 common <- intersect(names, old_names)
[16:18:43.394]                 added <- setdiff(names, old_names)
[16:18:43.394]                 removed <- setdiff(old_names, names)
[16:18:43.394]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.394]                   envs[common]]
[16:18:43.394]                 NAMES <- toupper(changed)
[16:18:43.394]                 args <- list()
[16:18:43.394]                 for (kk in seq_along(NAMES)) {
[16:18:43.394]                   name <- changed[[kk]]
[16:18:43.394]                   NAME <- NAMES[[kk]]
[16:18:43.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.394]                     next
[16:18:43.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.394]                 }
[16:18:43.394]                 NAMES <- toupper(added)
[16:18:43.394]                 for (kk in seq_along(NAMES)) {
[16:18:43.394]                   name <- added[[kk]]
[16:18:43.394]                   NAME <- NAMES[[kk]]
[16:18:43.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.394]                     next
[16:18:43.394]                   args[[name]] <- ""
[16:18:43.394]                 }
[16:18:43.394]                 NAMES <- toupper(removed)
[16:18:43.394]                 for (kk in seq_along(NAMES)) {
[16:18:43.394]                   name <- removed[[kk]]
[16:18:43.394]                   NAME <- NAMES[[kk]]
[16:18:43.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.394]                     next
[16:18:43.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.394]                 }
[16:18:43.394]                 if (length(args) > 0) 
[16:18:43.394]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.394]             }
[16:18:43.394]             else {
[16:18:43.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.394]             }
[16:18:43.394]             {
[16:18:43.394]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.394]                   0L) {
[16:18:43.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.394]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.394]                   base::options(opts)
[16:18:43.394]                 }
[16:18:43.394]                 {
[16:18:43.394]                   {
[16:18:43.394]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.394]                     NULL
[16:18:43.394]                   }
[16:18:43.394]                   options(future.plan = NULL)
[16:18:43.394]                   if (is.na(NA_character_)) 
[16:18:43.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.394]                     .init = FALSE)
[16:18:43.394]                 }
[16:18:43.394]             }
[16:18:43.394]         }
[16:18:43.394]     })
[16:18:43.394]     if (TRUE) {
[16:18:43.394]         base::sink(type = "output", split = FALSE)
[16:18:43.394]         if (TRUE) {
[16:18:43.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.394]         }
[16:18:43.394]         else {
[16:18:43.394]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.394]         }
[16:18:43.394]         base::close(...future.stdout)
[16:18:43.394]         ...future.stdout <- NULL
[16:18:43.394]     }
[16:18:43.394]     ...future.result$conditions <- ...future.conditions
[16:18:43.394]     ...future.result$finished <- base::Sys.time()
[16:18:43.394]     ...future.result
[16:18:43.394] }
[16:18:43.396] assign_globals() ...
[16:18:43.397] List of 5
[16:18:43.397]  $ ...future.FUN            :function (x, w, ...)  
[16:18:43.397]  $ MoreArgs                 : NULL
[16:18:43.397]  $ ...future.elements_ii    :List of 2
[16:18:43.397]   ..$ :List of 2
[16:18:43.397]   .. ..$ : num [1:10] 0.919 0.631 0.41 0.856 0.906 ...
[16:18:43.397]   .. ..$ : num [1:10] 0.7823 0.4693 0.1329 0.0585 0.6223 ...
[16:18:43.397]   ..$ :List of 2
[16:18:43.397]   .. ..$ : num [1:10] 4 6 4 3 6 4 6 8 7 4
[16:18:43.397]   .. ..$ : num [1:10] 6 6 9 8 2 8 8 1 6 3
[16:18:43.397]  $ ...future.seeds_ii       : NULL
[16:18:43.397]  $ ...future.globals.maxSize: NULL
[16:18:43.397]  - attr(*, "where")=List of 5
[16:18:43.397]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.397]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.397]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.397]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.397]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.397]  - attr(*, "resolved")= logi FALSE
[16:18:43.397]  - attr(*, "total_size")= num 2120
[16:18:43.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.397]  - attr(*, "already-done")= logi TRUE
[16:18:43.403] - copied ‘...future.FUN’ to environment
[16:18:43.403] - copied ‘MoreArgs’ to environment
[16:18:43.403] - copied ‘...future.elements_ii’ to environment
[16:18:43.403] - copied ‘...future.seeds_ii’ to environment
[16:18:43.403] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.403] assign_globals() ... done
[16:18:43.403] requestCore(): workers = 2
[16:18:43.406] MulticoreFuture started
[16:18:43.406] - Launch lazy future ... done
[16:18:43.407] run() for ‘MulticoreFuture’ ... done
[16:18:43.407] Created future:
[16:18:43.407] plan(): Setting new future strategy stack:
[16:18:43.408] List of future strategies:
[16:18:43.408] 1. sequential:
[16:18:43.408]    - args: function (..., envir = parent.frame())
[16:18:43.408]    - tweaked: FALSE
[16:18:43.408]    - call: NULL
[16:18:43.408] plan(): nbrOfWorkers() = 1
[16:18:43.415] plan(): Setting new future strategy stack:
[16:18:43.416] List of future strategies:
[16:18:43.416] 1. multicore:
[16:18:43.416]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.416]    - tweaked: FALSE
[16:18:43.416]    - call: plan(strategy)
[16:18:43.423] plan(): nbrOfWorkers() = 2
[16:18:43.407] MulticoreFuture:
[16:18:43.407] Label: ‘future_Map-1’
[16:18:43.407] Expression:
[16:18:43.407] {
[16:18:43.407]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.407]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.407]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.407]         on.exit(options(oopts), add = TRUE)
[16:18:43.407]     }
[16:18:43.407]     {
[16:18:43.407]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.407]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.407]         do.call(mapply, args = args)
[16:18:43.407]     }
[16:18:43.407] }
[16:18:43.407] Lazy evaluation: FALSE
[16:18:43.407] Asynchronous evaluation: TRUE
[16:18:43.407] Local evaluation: TRUE
[16:18:43.407] Environment: R_GlobalEnv
[16:18:43.407] Capture standard output: TRUE
[16:18:43.407] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.407] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.407] Packages: 1 packages (‘stats’)
[16:18:43.407] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:43.407] Resolved: TRUE
[16:18:43.407] Value: <not collected>
[16:18:43.407] Conditions captured: <none>
[16:18:43.407] Early signaling: FALSE
[16:18:43.407] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.407] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.424] Chunk #1 of 2 ... DONE
[16:18:43.425] Chunk #2 of 2 ...
[16:18:43.425]  - Finding globals in '...' for chunk #2 ...
[16:18:43.425] getGlobalsAndPackages() ...
[16:18:43.425] Searching for globals...
[16:18:43.426] 
[16:18:43.426] Searching for globals ... DONE
[16:18:43.427] - globals: [0] <none>
[16:18:43.427] getGlobalsAndPackages() ... DONE
[16:18:43.427]    + additional globals found: [n=0] 
[16:18:43.427]    + additional namespaces needed: [n=0] 
[16:18:43.427]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:43.428]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.428]  - seeds: <none>
[16:18:43.428]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.428] getGlobalsAndPackages() ...
[16:18:43.429] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.429] Resolving globals: FALSE
[16:18:43.430] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[16:18:43.431] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:43.432] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.432] - packages: [1] ‘stats’
[16:18:43.432] getGlobalsAndPackages() ... DONE
[16:18:43.433] run() for ‘Future’ ...
[16:18:43.433] - state: ‘created’
[16:18:43.433] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.438] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.439]   - Field: ‘label’
[16:18:43.439]   - Field: ‘local’
[16:18:43.439]   - Field: ‘owner’
[16:18:43.440]   - Field: ‘envir’
[16:18:43.440]   - Field: ‘workers’
[16:18:43.440]   - Field: ‘packages’
[16:18:43.440]   - Field: ‘gc’
[16:18:43.440]   - Field: ‘job’
[16:18:43.440]   - Field: ‘conditions’
[16:18:43.441]   - Field: ‘expr’
[16:18:43.441]   - Field: ‘uuid’
[16:18:43.441]   - Field: ‘seed’
[16:18:43.441]   - Field: ‘version’
[16:18:43.441]   - Field: ‘result’
[16:18:43.441]   - Field: ‘asynchronous’
[16:18:43.441]   - Field: ‘calls’
[16:18:43.442]   - Field: ‘globals’
[16:18:43.442]   - Field: ‘stdout’
[16:18:43.442]   - Field: ‘earlySignal’
[16:18:43.442]   - Field: ‘lazy’
[16:18:43.442]   - Field: ‘state’
[16:18:43.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.443] - Launch lazy future ...
[16:18:43.443] Packages needed by the future expression (n = 1): ‘stats’
[16:18:43.443] Packages needed by future strategies (n = 0): <none>
[16:18:43.444] {
[16:18:43.444]     {
[16:18:43.444]         {
[16:18:43.444]             ...future.startTime <- base::Sys.time()
[16:18:43.444]             {
[16:18:43.444]                 {
[16:18:43.444]                   {
[16:18:43.444]                     {
[16:18:43.444]                       {
[16:18:43.444]                         base::local({
[16:18:43.444]                           has_future <- base::requireNamespace("future", 
[16:18:43.444]                             quietly = TRUE)
[16:18:43.444]                           if (has_future) {
[16:18:43.444]                             ns <- base::getNamespace("future")
[16:18:43.444]                             version <- ns[[".package"]][["version"]]
[16:18:43.444]                             if (is.null(version)) 
[16:18:43.444]                               version <- utils::packageVersion("future")
[16:18:43.444]                           }
[16:18:43.444]                           else {
[16:18:43.444]                             version <- NULL
[16:18:43.444]                           }
[16:18:43.444]                           if (!has_future || version < "1.8.0") {
[16:18:43.444]                             info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.444]                               "", base::R.version$version.string), 
[16:18:43.444]                               platform = base::sprintf("%s (%s-bit)", 
[16:18:43.444]                                 base::R.version$platform, 8 * 
[16:18:43.444]                                   base::.Machine$sizeof.pointer), 
[16:18:43.444]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.444]                                 "release", "version")], collapse = " "), 
[16:18:43.444]                               hostname = base::Sys.info()[["nodename"]])
[16:18:43.444]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.444]                               info)
[16:18:43.444]                             info <- base::paste(info, collapse = "; ")
[16:18:43.444]                             if (!has_future) {
[16:18:43.444]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.444]                                 info)
[16:18:43.444]                             }
[16:18:43.444]                             else {
[16:18:43.444]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.444]                                 info, version)
[16:18:43.444]                             }
[16:18:43.444]                             base::stop(msg)
[16:18:43.444]                           }
[16:18:43.444]                         })
[16:18:43.444]                       }
[16:18:43.444]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.444]                       base::options(mc.cores = 1L)
[16:18:43.444]                     }
[16:18:43.444]                     base::local({
[16:18:43.444]                       for (pkg in "stats") {
[16:18:43.444]                         base::loadNamespace(pkg)
[16:18:43.444]                         base::library(pkg, character.only = TRUE)
[16:18:43.444]                       }
[16:18:43.444]                     })
[16:18:43.444]                   }
[16:18:43.444]                   ...future.strategy.old <- future::plan("list")
[16:18:43.444]                   options(future.plan = NULL)
[16:18:43.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.444]                 }
[16:18:43.444]                 ...future.workdir <- getwd()
[16:18:43.444]             }
[16:18:43.444]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.444]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.444]         }
[16:18:43.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.444]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.444]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.444]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.444]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.444]             base::names(...future.oldOptions))
[16:18:43.444]     }
[16:18:43.444]     if (FALSE) {
[16:18:43.444]     }
[16:18:43.444]     else {
[16:18:43.444]         if (TRUE) {
[16:18:43.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.444]                 open = "w")
[16:18:43.444]         }
[16:18:43.444]         else {
[16:18:43.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.444]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.444]         }
[16:18:43.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.444]             base::sink(type = "output", split = FALSE)
[16:18:43.444]             base::close(...future.stdout)
[16:18:43.444]         }, add = TRUE)
[16:18:43.444]     }
[16:18:43.444]     ...future.frame <- base::sys.nframe()
[16:18:43.444]     ...future.conditions <- base::list()
[16:18:43.444]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.444]     if (FALSE) {
[16:18:43.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.444]     }
[16:18:43.444]     ...future.result <- base::tryCatch({
[16:18:43.444]         base::withCallingHandlers({
[16:18:43.444]             ...future.value <- base::withVisible(base::local({
[16:18:43.444]                 withCallingHandlers({
[16:18:43.444]                   {
[16:18:43.444]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.444]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.444]                       ...future.globals.maxSize)) {
[16:18:43.444]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.444]                       on.exit(options(oopts), add = TRUE)
[16:18:43.444]                     }
[16:18:43.444]                     {
[16:18:43.444]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.444]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.444]                         USE.NAMES = FALSE)
[16:18:43.444]                       do.call(mapply, args = args)
[16:18:43.444]                     }
[16:18:43.444]                   }
[16:18:43.444]                 }, immediateCondition = function(cond) {
[16:18:43.444]                   save_rds <- function (object, pathname, ...) 
[16:18:43.444]                   {
[16:18:43.444]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.444]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.444]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.444]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.444]                         fi_tmp[["mtime"]])
[16:18:43.444]                     }
[16:18:43.444]                     tryCatch({
[16:18:43.444]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.444]                     }, error = function(ex) {
[16:18:43.444]                       msg <- conditionMessage(ex)
[16:18:43.444]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.444]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.444]                         fi_tmp[["mtime"]], msg)
[16:18:43.444]                       ex$message <- msg
[16:18:43.444]                       stop(ex)
[16:18:43.444]                     })
[16:18:43.444]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.444]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.444]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.444]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.444]                       fi <- file.info(pathname)
[16:18:43.444]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.444]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.444]                         fi[["size"]], fi[["mtime"]])
[16:18:43.444]                       stop(msg)
[16:18:43.444]                     }
[16:18:43.444]                     invisible(pathname)
[16:18:43.444]                   }
[16:18:43.444]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.444]                     rootPath = tempdir()) 
[16:18:43.444]                   {
[16:18:43.444]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.444]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.444]                       tmpdir = path, fileext = ".rds")
[16:18:43.444]                     save_rds(obj, file)
[16:18:43.444]                   }
[16:18:43.444]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.444]                   {
[16:18:43.444]                     inherits <- base::inherits
[16:18:43.444]                     invokeRestart <- base::invokeRestart
[16:18:43.444]                     is.null <- base::is.null
[16:18:43.444]                     muffled <- FALSE
[16:18:43.444]                     if (inherits(cond, "message")) {
[16:18:43.444]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.444]                       if (muffled) 
[16:18:43.444]                         invokeRestart("muffleMessage")
[16:18:43.444]                     }
[16:18:43.444]                     else if (inherits(cond, "warning")) {
[16:18:43.444]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.444]                       if (muffled) 
[16:18:43.444]                         invokeRestart("muffleWarning")
[16:18:43.444]                     }
[16:18:43.444]                     else if (inherits(cond, "condition")) {
[16:18:43.444]                       if (!is.null(pattern)) {
[16:18:43.444]                         computeRestarts <- base::computeRestarts
[16:18:43.444]                         grepl <- base::grepl
[16:18:43.444]                         restarts <- computeRestarts(cond)
[16:18:43.444]                         for (restart in restarts) {
[16:18:43.444]                           name <- restart$name
[16:18:43.444]                           if (is.null(name)) 
[16:18:43.444]                             next
[16:18:43.444]                           if (!grepl(pattern, name)) 
[16:18:43.444]                             next
[16:18:43.444]                           invokeRestart(restart)
[16:18:43.444]                           muffled <- TRUE
[16:18:43.444]                           break
[16:18:43.444]                         }
[16:18:43.444]                       }
[16:18:43.444]                     }
[16:18:43.444]                     invisible(muffled)
[16:18:43.444]                   }
[16:18:43.444]                   muffleCondition(cond)
[16:18:43.444]                 })
[16:18:43.444]             }))
[16:18:43.444]             future::FutureResult(value = ...future.value$value, 
[16:18:43.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.444]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.444]                     ...future.globalenv.names))
[16:18:43.444]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.444]         }, condition = base::local({
[16:18:43.444]             c <- base::c
[16:18:43.444]             inherits <- base::inherits
[16:18:43.444]             invokeRestart <- base::invokeRestart
[16:18:43.444]             length <- base::length
[16:18:43.444]             list <- base::list
[16:18:43.444]             seq.int <- base::seq.int
[16:18:43.444]             signalCondition <- base::signalCondition
[16:18:43.444]             sys.calls <- base::sys.calls
[16:18:43.444]             `[[` <- base::`[[`
[16:18:43.444]             `+` <- base::`+`
[16:18:43.444]             `<<-` <- base::`<<-`
[16:18:43.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.444]                   3L)]
[16:18:43.444]             }
[16:18:43.444]             function(cond) {
[16:18:43.444]                 is_error <- inherits(cond, "error")
[16:18:43.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.444]                   NULL)
[16:18:43.444]                 if (is_error) {
[16:18:43.444]                   sessionInformation <- function() {
[16:18:43.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.444]                       search = base::search(), system = base::Sys.info())
[16:18:43.444]                   }
[16:18:43.444]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.444]                     cond$call), session = sessionInformation(), 
[16:18:43.444]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.444]                   signalCondition(cond)
[16:18:43.444]                 }
[16:18:43.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.444]                 "immediateCondition"))) {
[16:18:43.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.444]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.444]                   if (TRUE && !signal) {
[16:18:43.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.444]                     {
[16:18:43.444]                       inherits <- base::inherits
[16:18:43.444]                       invokeRestart <- base::invokeRestart
[16:18:43.444]                       is.null <- base::is.null
[16:18:43.444]                       muffled <- FALSE
[16:18:43.444]                       if (inherits(cond, "message")) {
[16:18:43.444]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.444]                         if (muffled) 
[16:18:43.444]                           invokeRestart("muffleMessage")
[16:18:43.444]                       }
[16:18:43.444]                       else if (inherits(cond, "warning")) {
[16:18:43.444]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.444]                         if (muffled) 
[16:18:43.444]                           invokeRestart("muffleWarning")
[16:18:43.444]                       }
[16:18:43.444]                       else if (inherits(cond, "condition")) {
[16:18:43.444]                         if (!is.null(pattern)) {
[16:18:43.444]                           computeRestarts <- base::computeRestarts
[16:18:43.444]                           grepl <- base::grepl
[16:18:43.444]                           restarts <- computeRestarts(cond)
[16:18:43.444]                           for (restart in restarts) {
[16:18:43.444]                             name <- restart$name
[16:18:43.444]                             if (is.null(name)) 
[16:18:43.444]                               next
[16:18:43.444]                             if (!grepl(pattern, name)) 
[16:18:43.444]                               next
[16:18:43.444]                             invokeRestart(restart)
[16:18:43.444]                             muffled <- TRUE
[16:18:43.444]                             break
[16:18:43.444]                           }
[16:18:43.444]                         }
[16:18:43.444]                       }
[16:18:43.444]                       invisible(muffled)
[16:18:43.444]                     }
[16:18:43.444]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.444]                   }
[16:18:43.444]                 }
[16:18:43.444]                 else {
[16:18:43.444]                   if (TRUE) {
[16:18:43.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.444]                     {
[16:18:43.444]                       inherits <- base::inherits
[16:18:43.444]                       invokeRestart <- base::invokeRestart
[16:18:43.444]                       is.null <- base::is.null
[16:18:43.444]                       muffled <- FALSE
[16:18:43.444]                       if (inherits(cond, "message")) {
[16:18:43.444]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.444]                         if (muffled) 
[16:18:43.444]                           invokeRestart("muffleMessage")
[16:18:43.444]                       }
[16:18:43.444]                       else if (inherits(cond, "warning")) {
[16:18:43.444]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.444]                         if (muffled) 
[16:18:43.444]                           invokeRestart("muffleWarning")
[16:18:43.444]                       }
[16:18:43.444]                       else if (inherits(cond, "condition")) {
[16:18:43.444]                         if (!is.null(pattern)) {
[16:18:43.444]                           computeRestarts <- base::computeRestarts
[16:18:43.444]                           grepl <- base::grepl
[16:18:43.444]                           restarts <- computeRestarts(cond)
[16:18:43.444]                           for (restart in restarts) {
[16:18:43.444]                             name <- restart$name
[16:18:43.444]                             if (is.null(name)) 
[16:18:43.444]                               next
[16:18:43.444]                             if (!grepl(pattern, name)) 
[16:18:43.444]                               next
[16:18:43.444]                             invokeRestart(restart)
[16:18:43.444]                             muffled <- TRUE
[16:18:43.444]                             break
[16:18:43.444]                           }
[16:18:43.444]                         }
[16:18:43.444]                       }
[16:18:43.444]                       invisible(muffled)
[16:18:43.444]                     }
[16:18:43.444]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.444]                   }
[16:18:43.444]                 }
[16:18:43.444]             }
[16:18:43.444]         }))
[16:18:43.444]     }, error = function(ex) {
[16:18:43.444]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.444]                 ...future.rng), started = ...future.startTime, 
[16:18:43.444]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.444]             version = "1.8"), class = "FutureResult")
[16:18:43.444]     }, finally = {
[16:18:43.444]         if (!identical(...future.workdir, getwd())) 
[16:18:43.444]             setwd(...future.workdir)
[16:18:43.444]         {
[16:18:43.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.444]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.444]             }
[16:18:43.444]             base::options(...future.oldOptions)
[16:18:43.444]             if (.Platform$OS.type == "windows") {
[16:18:43.444]                 old_names <- names(...future.oldEnvVars)
[16:18:43.444]                 envs <- base::Sys.getenv()
[16:18:43.444]                 names <- names(envs)
[16:18:43.444]                 common <- intersect(names, old_names)
[16:18:43.444]                 added <- setdiff(names, old_names)
[16:18:43.444]                 removed <- setdiff(old_names, names)
[16:18:43.444]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.444]                   envs[common]]
[16:18:43.444]                 NAMES <- toupper(changed)
[16:18:43.444]                 args <- list()
[16:18:43.444]                 for (kk in seq_along(NAMES)) {
[16:18:43.444]                   name <- changed[[kk]]
[16:18:43.444]                   NAME <- NAMES[[kk]]
[16:18:43.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.444]                     next
[16:18:43.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.444]                 }
[16:18:43.444]                 NAMES <- toupper(added)
[16:18:43.444]                 for (kk in seq_along(NAMES)) {
[16:18:43.444]                   name <- added[[kk]]
[16:18:43.444]                   NAME <- NAMES[[kk]]
[16:18:43.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.444]                     next
[16:18:43.444]                   args[[name]] <- ""
[16:18:43.444]                 }
[16:18:43.444]                 NAMES <- toupper(removed)
[16:18:43.444]                 for (kk in seq_along(NAMES)) {
[16:18:43.444]                   name <- removed[[kk]]
[16:18:43.444]                   NAME <- NAMES[[kk]]
[16:18:43.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.444]                     next
[16:18:43.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.444]                 }
[16:18:43.444]                 if (length(args) > 0) 
[16:18:43.444]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.444]             }
[16:18:43.444]             else {
[16:18:43.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.444]             }
[16:18:43.444]             {
[16:18:43.444]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.444]                   0L) {
[16:18:43.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.444]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.444]                   base::options(opts)
[16:18:43.444]                 }
[16:18:43.444]                 {
[16:18:43.444]                   {
[16:18:43.444]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.444]                     NULL
[16:18:43.444]                   }
[16:18:43.444]                   options(future.plan = NULL)
[16:18:43.444]                   if (is.na(NA_character_)) 
[16:18:43.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.444]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.444]                     .init = FALSE)
[16:18:43.444]                 }
[16:18:43.444]             }
[16:18:43.444]         }
[16:18:43.444]     })
[16:18:43.444]     if (TRUE) {
[16:18:43.444]         base::sink(type = "output", split = FALSE)
[16:18:43.444]         if (TRUE) {
[16:18:43.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.444]         }
[16:18:43.444]         else {
[16:18:43.444]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.444]         }
[16:18:43.444]         base::close(...future.stdout)
[16:18:43.444]         ...future.stdout <- NULL
[16:18:43.444]     }
[16:18:43.444]     ...future.result$conditions <- ...future.conditions
[16:18:43.444]     ...future.result$finished <- base::Sys.time()
[16:18:43.444]     ...future.result
[16:18:43.444] }
[16:18:43.447] assign_globals() ...
[16:18:43.447] List of 5
[16:18:43.447]  $ ...future.FUN            :function (x, w, ...)  
[16:18:43.447]  $ MoreArgs                 : NULL
[16:18:43.447]  $ ...future.elements_ii    :List of 2
[16:18:43.447]   ..$ :List of 3
[16:18:43.447]   .. ..$ : num [1:10] 0.0503 0.4963 0.0195 0.9876 0.9512 ...
[16:18:43.447]   .. ..$ : num [1:10] 0.674 0.643 0.849 0.175 0.369 ...
[16:18:43.447]   .. ..$ : num [1:10] 0.9349 0.2822 0.7631 0.3269 0.0536 ...
[16:18:43.447]   ..$ :List of 3
[16:18:43.447]   .. ..$ : num [1:10] 4 8 5 4 11 6 13 7 3 4
[16:18:43.447]   .. ..$ : num [1:10] 7 4 8 6 4 3 4 6 5 4
[16:18:43.447]   .. ..$ : num [1:10] 4 7 5 6 6 4 2 5 5 7
[16:18:43.447]  $ ...future.seeds_ii       : NULL
[16:18:43.447]  $ ...future.globals.maxSize: NULL
[16:18:43.447]  - attr(*, "where")=List of 5
[16:18:43.447]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.447]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.447]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.447]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.447]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.447]  - attr(*, "resolved")= logi FALSE
[16:18:43.447]  - attr(*, "total_size")= num 2472
[16:18:43.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.447]  - attr(*, "already-done")= logi TRUE
[16:18:43.455] - copied ‘...future.FUN’ to environment
[16:18:43.455] - copied ‘MoreArgs’ to environment
[16:18:43.455] - copied ‘...future.elements_ii’ to environment
[16:18:43.456] - copied ‘...future.seeds_ii’ to environment
[16:18:43.456] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.456] assign_globals() ... done
[16:18:43.456] requestCore(): workers = 2
[16:18:43.515] plan(): Setting new future strategy stack:
[16:18:43.515] MulticoreFuture started
[16:18:43.515] - Launch lazy future ... done
[16:18:43.516] run() for ‘MulticoreFuture’ ... done
[16:18:43.515] List of future strategies:
[16:18:43.515] 1. sequential:
[16:18:43.515]    - args: function (..., envir = parent.frame())
[16:18:43.515]    - tweaked: FALSE
[16:18:43.515]    - call: NULL
[16:18:43.516] Created future:
[16:18:43.516] plan(): nbrOfWorkers() = 1
[16:18:43.517] plan(): Setting new future strategy stack:
[16:18:43.517] List of future strategies:
[16:18:43.517] 1. multicore:
[16:18:43.517]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.517]    - tweaked: FALSE
[16:18:43.517]    - call: plan(strategy)
[16:18:43.521] plan(): nbrOfWorkers() = 2
[16:18:43.516] MulticoreFuture:
[16:18:43.516] Label: ‘future_Map-2’
[16:18:43.516] Expression:
[16:18:43.516] {
[16:18:43.516]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.516]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.516]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.516]         on.exit(options(oopts), add = TRUE)
[16:18:43.516]     }
[16:18:43.516]     {
[16:18:43.516]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.516]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.516]         do.call(mapply, args = args)
[16:18:43.516]     }
[16:18:43.516] }
[16:18:43.516] Lazy evaluation: FALSE
[16:18:43.516] Asynchronous evaluation: TRUE
[16:18:43.516] Local evaluation: TRUE
[16:18:43.516] Environment: R_GlobalEnv
[16:18:43.516] Capture standard output: TRUE
[16:18:43.516] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.516] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.516] Packages: 1 packages (‘stats’)
[16:18:43.516] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:43.516] Resolved: TRUE
[16:18:43.516] Value: <not collected>
[16:18:43.516] Conditions captured: <none>
[16:18:43.516] Early signaling: FALSE
[16:18:43.516] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.516] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.522] Chunk #2 of 2 ... DONE
[16:18:43.522] Launching 2 futures (chunks) ... DONE
[16:18:43.522] Resolving 2 futures (chunks) ...
[16:18:43.522] resolve() on list ...
[16:18:43.522]  recursive: 0
[16:18:43.522]  length: 2
[16:18:43.523] 
[16:18:43.523] Future #1
[16:18:43.523] result() for MulticoreFuture ...
[16:18:43.524] result() for MulticoreFuture ...
[16:18:43.524] result() for MulticoreFuture ... done
[16:18:43.524] result() for MulticoreFuture ... done
[16:18:43.524] result() for MulticoreFuture ...
[16:18:43.524] result() for MulticoreFuture ... done
[16:18:43.524] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:43.524] - nx: 2
[16:18:43.524] - relay: TRUE
[16:18:43.525] - stdout: TRUE
[16:18:43.525] - signal: TRUE
[16:18:43.525] - resignal: FALSE
[16:18:43.525] - force: TRUE
[16:18:43.525] - relayed: [n=2] FALSE, FALSE
[16:18:43.525] - queued futures: [n=2] FALSE, FALSE
[16:18:43.525]  - until=1
[16:18:43.525]  - relaying element #1
[16:18:43.525] result() for MulticoreFuture ...
[16:18:43.525] result() for MulticoreFuture ... done
[16:18:43.525] result() for MulticoreFuture ...
[16:18:43.526] result() for MulticoreFuture ... done
[16:18:43.526] result() for MulticoreFuture ...
[16:18:43.526] result() for MulticoreFuture ... done
[16:18:43.526] result() for MulticoreFuture ...
[16:18:43.526] result() for MulticoreFuture ... done
[16:18:43.526] - relayed: [n=2] TRUE, FALSE
[16:18:43.526] - queued futures: [n=2] TRUE, FALSE
[16:18:43.526] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:43.526]  length: 1 (resolved future 1)
[16:18:43.527] Future #2
[16:18:43.527] result() for MulticoreFuture ...
[16:18:43.527] result() for MulticoreFuture ...
[16:18:43.527] result() for MulticoreFuture ... done
[16:18:43.527] result() for MulticoreFuture ... done
[16:18:43.528] result() for MulticoreFuture ...
[16:18:43.528] result() for MulticoreFuture ... done
[16:18:43.528] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:43.528] - nx: 2
[16:18:43.528] - relay: TRUE
[16:18:43.528] - stdout: TRUE
[16:18:43.528] - signal: TRUE
[16:18:43.528] - resignal: FALSE
[16:18:43.528] - force: TRUE
[16:18:43.528] - relayed: [n=2] TRUE, FALSE
[16:18:43.528] - queued futures: [n=2] TRUE, FALSE
[16:18:43.529]  - until=2
[16:18:43.529]  - relaying element #2
[16:18:43.529] result() for MulticoreFuture ...
[16:18:43.529] result() for MulticoreFuture ... done
[16:18:43.529] result() for MulticoreFuture ...
[16:18:43.529] result() for MulticoreFuture ... done
[16:18:43.529] result() for MulticoreFuture ...
[16:18:43.529] result() for MulticoreFuture ... done
[16:18:43.529] result() for MulticoreFuture ...
[16:18:43.529] result() for MulticoreFuture ... done
[16:18:43.530] - relayed: [n=2] TRUE, TRUE
[16:18:43.530] - queued futures: [n=2] TRUE, TRUE
[16:18:43.530] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:43.530]  length: 0 (resolved future 2)
[16:18:43.530] Relaying remaining futures
[16:18:43.530] signalConditionsASAP(NULL, pos=0) ...
[16:18:43.530] - nx: 2
[16:18:43.530] - relay: TRUE
[16:18:43.530] - stdout: TRUE
[16:18:43.530] - signal: TRUE
[16:18:43.530] - resignal: FALSE
[16:18:43.530] - force: TRUE
[16:18:43.531] - relayed: [n=2] TRUE, TRUE
[16:18:43.531] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:43.531] - relayed: [n=2] TRUE, TRUE
[16:18:43.531] - queued futures: [n=2] TRUE, TRUE
[16:18:43.531] signalConditionsASAP(NULL, pos=0) ... done
[16:18:43.531] resolve() on list ... DONE
[16:18:43.531] result() for MulticoreFuture ...
[16:18:43.531] result() for MulticoreFuture ... done
[16:18:43.531] result() for MulticoreFuture ...
[16:18:43.531] result() for MulticoreFuture ... done
[16:18:43.531] result() for MulticoreFuture ...
[16:18:43.532] result() for MulticoreFuture ... done
[16:18:43.532] result() for MulticoreFuture ...
[16:18:43.532] result() for MulticoreFuture ... done
[16:18:43.532]  - Number of value chunks collected: 2
[16:18:43.532] Resolving 2 futures (chunks) ... DONE
[16:18:43.532] Reducing values from 2 chunks ...
[16:18:43.532]  - Number of values collected after concatenation: 5
[16:18:43.532]  - Number of values expected: 5
[16:18:43.532] Reducing values from 2 chunks ... DONE
[16:18:43.532] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[16:18:43.534] future_mapply() ...
[16:18:43.538] Number of chunks: 2
[16:18:43.538] getGlobalsAndPackagesXApply() ...
[16:18:43.538]  - future.globals: TRUE
[16:18:43.538] getGlobalsAndPackages() ...
[16:18:43.539] Searching for globals...
[16:18:43.539] - globals found: [1] ‘FUN’
[16:18:43.539] Searching for globals ... DONE
[16:18:43.539] Resolving globals: FALSE
[16:18:43.540] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:43.540] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:43.540] - globals: [1] ‘FUN’
[16:18:43.540] 
[16:18:43.540] getGlobalsAndPackages() ... DONE
[16:18:43.541]  - globals found/used: [n=1] ‘FUN’
[16:18:43.541]  - needed namespaces: [n=0] 
[16:18:43.541] Finding globals ... DONE
[16:18:43.541] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:43.541] List of 2
[16:18:43.541]  $ ...future.FUN:function (e1, e2)  
[16:18:43.541]  $ MoreArgs     : NULL
[16:18:43.541]  - attr(*, "where")=List of 2
[16:18:43.541]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:43.541]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:43.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.541]  - attr(*, "resolved")= logi FALSE
[16:18:43.541]  - attr(*, "total_size")= num NA
[16:18:43.543] Packages to be attached in all futures: [n=0] 
[16:18:43.544] getGlobalsAndPackagesXApply() ... DONE
[16:18:43.544] Number of futures (= number of chunks): 2
[16:18:43.544] Launching 2 futures (chunks) ...
[16:18:43.544] Chunk #1 of 2 ...
[16:18:43.544]  - Finding globals in '...' for chunk #1 ...
[16:18:43.544] getGlobalsAndPackages() ...
[16:18:43.544] Searching for globals...
[16:18:43.545] 
[16:18:43.545] Searching for globals ... DONE
[16:18:43.545] - globals: [0] <none>
[16:18:43.545] getGlobalsAndPackages() ... DONE
[16:18:43.545]    + additional globals found: [n=0] 
[16:18:43.545]    + additional namespaces needed: [n=0] 
[16:18:43.545]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:43.545]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.545]  - seeds: <none>
[16:18:43.545]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.546] getGlobalsAndPackages() ...
[16:18:43.546] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.546] Resolving globals: FALSE
[16:18:43.546] The total size of the 5 globals is 168 bytes (168 bytes)
[16:18:43.547] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:43.547] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.547] 
[16:18:43.547] getGlobalsAndPackages() ... DONE
[16:18:43.547] run() for ‘Future’ ...
[16:18:43.547] - state: ‘created’
[16:18:43.548] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.552] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.552]   - Field: ‘label’
[16:18:43.552]   - Field: ‘local’
[16:18:43.552]   - Field: ‘owner’
[16:18:43.552]   - Field: ‘envir’
[16:18:43.552]   - Field: ‘workers’
[16:18:43.552]   - Field: ‘packages’
[16:18:43.552]   - Field: ‘gc’
[16:18:43.553]   - Field: ‘job’
[16:18:43.553]   - Field: ‘conditions’
[16:18:43.553]   - Field: ‘expr’
[16:18:43.553]   - Field: ‘uuid’
[16:18:43.553]   - Field: ‘seed’
[16:18:43.553]   - Field: ‘version’
[16:18:43.553]   - Field: ‘result’
[16:18:43.553]   - Field: ‘asynchronous’
[16:18:43.553]   - Field: ‘calls’
[16:18:43.553]   - Field: ‘globals’
[16:18:43.553]   - Field: ‘stdout’
[16:18:43.554]   - Field: ‘earlySignal’
[16:18:43.554]   - Field: ‘lazy’
[16:18:43.554]   - Field: ‘state’
[16:18:43.554] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.554] - Launch lazy future ...
[16:18:43.554] Packages needed by the future expression (n = 0): <none>
[16:18:43.554] Packages needed by future strategies (n = 0): <none>
[16:18:43.555] {
[16:18:43.555]     {
[16:18:43.555]         {
[16:18:43.555]             ...future.startTime <- base::Sys.time()
[16:18:43.555]             {
[16:18:43.555]                 {
[16:18:43.555]                   {
[16:18:43.555]                     {
[16:18:43.555]                       base::local({
[16:18:43.555]                         has_future <- base::requireNamespace("future", 
[16:18:43.555]                           quietly = TRUE)
[16:18:43.555]                         if (has_future) {
[16:18:43.555]                           ns <- base::getNamespace("future")
[16:18:43.555]                           version <- ns[[".package"]][["version"]]
[16:18:43.555]                           if (is.null(version)) 
[16:18:43.555]                             version <- utils::packageVersion("future")
[16:18:43.555]                         }
[16:18:43.555]                         else {
[16:18:43.555]                           version <- NULL
[16:18:43.555]                         }
[16:18:43.555]                         if (!has_future || version < "1.8.0") {
[16:18:43.555]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.555]                             "", base::R.version$version.string), 
[16:18:43.555]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:43.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:43.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.555]                               "release", "version")], collapse = " "), 
[16:18:43.555]                             hostname = base::Sys.info()[["nodename"]])
[16:18:43.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.555]                             info)
[16:18:43.555]                           info <- base::paste(info, collapse = "; ")
[16:18:43.555]                           if (!has_future) {
[16:18:43.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.555]                               info)
[16:18:43.555]                           }
[16:18:43.555]                           else {
[16:18:43.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.555]                               info, version)
[16:18:43.555]                           }
[16:18:43.555]                           base::stop(msg)
[16:18:43.555]                         }
[16:18:43.555]                       })
[16:18:43.555]                     }
[16:18:43.555]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.555]                     base::options(mc.cores = 1L)
[16:18:43.555]                   }
[16:18:43.555]                   ...future.strategy.old <- future::plan("list")
[16:18:43.555]                   options(future.plan = NULL)
[16:18:43.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.555]                 }
[16:18:43.555]                 ...future.workdir <- getwd()
[16:18:43.555]             }
[16:18:43.555]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.555]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.555]         }
[16:18:43.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.555]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.555]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.555]             base::names(...future.oldOptions))
[16:18:43.555]     }
[16:18:43.555]     if (FALSE) {
[16:18:43.555]     }
[16:18:43.555]     else {
[16:18:43.555]         if (TRUE) {
[16:18:43.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.555]                 open = "w")
[16:18:43.555]         }
[16:18:43.555]         else {
[16:18:43.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.555]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.555]         }
[16:18:43.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.555]             base::sink(type = "output", split = FALSE)
[16:18:43.555]             base::close(...future.stdout)
[16:18:43.555]         }, add = TRUE)
[16:18:43.555]     }
[16:18:43.555]     ...future.frame <- base::sys.nframe()
[16:18:43.555]     ...future.conditions <- base::list()
[16:18:43.555]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.555]     if (FALSE) {
[16:18:43.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.555]     }
[16:18:43.555]     ...future.result <- base::tryCatch({
[16:18:43.555]         base::withCallingHandlers({
[16:18:43.555]             ...future.value <- base::withVisible(base::local({
[16:18:43.555]                 withCallingHandlers({
[16:18:43.555]                   {
[16:18:43.555]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.555]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.555]                       ...future.globals.maxSize)) {
[16:18:43.555]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.555]                       on.exit(options(oopts), add = TRUE)
[16:18:43.555]                     }
[16:18:43.555]                     {
[16:18:43.555]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.555]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.555]                         USE.NAMES = FALSE)
[16:18:43.555]                       do.call(mapply, args = args)
[16:18:43.555]                     }
[16:18:43.555]                   }
[16:18:43.555]                 }, immediateCondition = function(cond) {
[16:18:43.555]                   save_rds <- function (object, pathname, ...) 
[16:18:43.555]                   {
[16:18:43.555]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.555]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.555]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.555]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.555]                         fi_tmp[["mtime"]])
[16:18:43.555]                     }
[16:18:43.555]                     tryCatch({
[16:18:43.555]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.555]                     }, error = function(ex) {
[16:18:43.555]                       msg <- conditionMessage(ex)
[16:18:43.555]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.555]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.555]                         fi_tmp[["mtime"]], msg)
[16:18:43.555]                       ex$message <- msg
[16:18:43.555]                       stop(ex)
[16:18:43.555]                     })
[16:18:43.555]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.555]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.555]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.555]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.555]                       fi <- file.info(pathname)
[16:18:43.555]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.555]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.555]                         fi[["size"]], fi[["mtime"]])
[16:18:43.555]                       stop(msg)
[16:18:43.555]                     }
[16:18:43.555]                     invisible(pathname)
[16:18:43.555]                   }
[16:18:43.555]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.555]                     rootPath = tempdir()) 
[16:18:43.555]                   {
[16:18:43.555]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.555]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.555]                       tmpdir = path, fileext = ".rds")
[16:18:43.555]                     save_rds(obj, file)
[16:18:43.555]                   }
[16:18:43.555]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.555]                   {
[16:18:43.555]                     inherits <- base::inherits
[16:18:43.555]                     invokeRestart <- base::invokeRestart
[16:18:43.555]                     is.null <- base::is.null
[16:18:43.555]                     muffled <- FALSE
[16:18:43.555]                     if (inherits(cond, "message")) {
[16:18:43.555]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.555]                       if (muffled) 
[16:18:43.555]                         invokeRestart("muffleMessage")
[16:18:43.555]                     }
[16:18:43.555]                     else if (inherits(cond, "warning")) {
[16:18:43.555]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.555]                       if (muffled) 
[16:18:43.555]                         invokeRestart("muffleWarning")
[16:18:43.555]                     }
[16:18:43.555]                     else if (inherits(cond, "condition")) {
[16:18:43.555]                       if (!is.null(pattern)) {
[16:18:43.555]                         computeRestarts <- base::computeRestarts
[16:18:43.555]                         grepl <- base::grepl
[16:18:43.555]                         restarts <- computeRestarts(cond)
[16:18:43.555]                         for (restart in restarts) {
[16:18:43.555]                           name <- restart$name
[16:18:43.555]                           if (is.null(name)) 
[16:18:43.555]                             next
[16:18:43.555]                           if (!grepl(pattern, name)) 
[16:18:43.555]                             next
[16:18:43.555]                           invokeRestart(restart)
[16:18:43.555]                           muffled <- TRUE
[16:18:43.555]                           break
[16:18:43.555]                         }
[16:18:43.555]                       }
[16:18:43.555]                     }
[16:18:43.555]                     invisible(muffled)
[16:18:43.555]                   }
[16:18:43.555]                   muffleCondition(cond)
[16:18:43.555]                 })
[16:18:43.555]             }))
[16:18:43.555]             future::FutureResult(value = ...future.value$value, 
[16:18:43.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.555]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.555]                     ...future.globalenv.names))
[16:18:43.555]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.555]         }, condition = base::local({
[16:18:43.555]             c <- base::c
[16:18:43.555]             inherits <- base::inherits
[16:18:43.555]             invokeRestart <- base::invokeRestart
[16:18:43.555]             length <- base::length
[16:18:43.555]             list <- base::list
[16:18:43.555]             seq.int <- base::seq.int
[16:18:43.555]             signalCondition <- base::signalCondition
[16:18:43.555]             sys.calls <- base::sys.calls
[16:18:43.555]             `[[` <- base::`[[`
[16:18:43.555]             `+` <- base::`+`
[16:18:43.555]             `<<-` <- base::`<<-`
[16:18:43.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.555]                   3L)]
[16:18:43.555]             }
[16:18:43.555]             function(cond) {
[16:18:43.555]                 is_error <- inherits(cond, "error")
[16:18:43.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.555]                   NULL)
[16:18:43.555]                 if (is_error) {
[16:18:43.555]                   sessionInformation <- function() {
[16:18:43.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.555]                       search = base::search(), system = base::Sys.info())
[16:18:43.555]                   }
[16:18:43.555]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.555]                     cond$call), session = sessionInformation(), 
[16:18:43.555]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.555]                   signalCondition(cond)
[16:18:43.555]                 }
[16:18:43.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.555]                 "immediateCondition"))) {
[16:18:43.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.555]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.555]                   if (TRUE && !signal) {
[16:18:43.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.555]                     {
[16:18:43.555]                       inherits <- base::inherits
[16:18:43.555]                       invokeRestart <- base::invokeRestart
[16:18:43.555]                       is.null <- base::is.null
[16:18:43.555]                       muffled <- FALSE
[16:18:43.555]                       if (inherits(cond, "message")) {
[16:18:43.555]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.555]                         if (muffled) 
[16:18:43.555]                           invokeRestart("muffleMessage")
[16:18:43.555]                       }
[16:18:43.555]                       else if (inherits(cond, "warning")) {
[16:18:43.555]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.555]                         if (muffled) 
[16:18:43.555]                           invokeRestart("muffleWarning")
[16:18:43.555]                       }
[16:18:43.555]                       else if (inherits(cond, "condition")) {
[16:18:43.555]                         if (!is.null(pattern)) {
[16:18:43.555]                           computeRestarts <- base::computeRestarts
[16:18:43.555]                           grepl <- base::grepl
[16:18:43.555]                           restarts <- computeRestarts(cond)
[16:18:43.555]                           for (restart in restarts) {
[16:18:43.555]                             name <- restart$name
[16:18:43.555]                             if (is.null(name)) 
[16:18:43.555]                               next
[16:18:43.555]                             if (!grepl(pattern, name)) 
[16:18:43.555]                               next
[16:18:43.555]                             invokeRestart(restart)
[16:18:43.555]                             muffled <- TRUE
[16:18:43.555]                             break
[16:18:43.555]                           }
[16:18:43.555]                         }
[16:18:43.555]                       }
[16:18:43.555]                       invisible(muffled)
[16:18:43.555]                     }
[16:18:43.555]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.555]                   }
[16:18:43.555]                 }
[16:18:43.555]                 else {
[16:18:43.555]                   if (TRUE) {
[16:18:43.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.555]                     {
[16:18:43.555]                       inherits <- base::inherits
[16:18:43.555]                       invokeRestart <- base::invokeRestart
[16:18:43.555]                       is.null <- base::is.null
[16:18:43.555]                       muffled <- FALSE
[16:18:43.555]                       if (inherits(cond, "message")) {
[16:18:43.555]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.555]                         if (muffled) 
[16:18:43.555]                           invokeRestart("muffleMessage")
[16:18:43.555]                       }
[16:18:43.555]                       else if (inherits(cond, "warning")) {
[16:18:43.555]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.555]                         if (muffled) 
[16:18:43.555]                           invokeRestart("muffleWarning")
[16:18:43.555]                       }
[16:18:43.555]                       else if (inherits(cond, "condition")) {
[16:18:43.555]                         if (!is.null(pattern)) {
[16:18:43.555]                           computeRestarts <- base::computeRestarts
[16:18:43.555]                           grepl <- base::grepl
[16:18:43.555]                           restarts <- computeRestarts(cond)
[16:18:43.555]                           for (restart in restarts) {
[16:18:43.555]                             name <- restart$name
[16:18:43.555]                             if (is.null(name)) 
[16:18:43.555]                               next
[16:18:43.555]                             if (!grepl(pattern, name)) 
[16:18:43.555]                               next
[16:18:43.555]                             invokeRestart(restart)
[16:18:43.555]                             muffled <- TRUE
[16:18:43.555]                             break
[16:18:43.555]                           }
[16:18:43.555]                         }
[16:18:43.555]                       }
[16:18:43.555]                       invisible(muffled)
[16:18:43.555]                     }
[16:18:43.555]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.555]                   }
[16:18:43.555]                 }
[16:18:43.555]             }
[16:18:43.555]         }))
[16:18:43.555]     }, error = function(ex) {
[16:18:43.555]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.555]                 ...future.rng), started = ...future.startTime, 
[16:18:43.555]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.555]             version = "1.8"), class = "FutureResult")
[16:18:43.555]     }, finally = {
[16:18:43.555]         if (!identical(...future.workdir, getwd())) 
[16:18:43.555]             setwd(...future.workdir)
[16:18:43.555]         {
[16:18:43.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.555]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.555]             }
[16:18:43.555]             base::options(...future.oldOptions)
[16:18:43.555]             if (.Platform$OS.type == "windows") {
[16:18:43.555]                 old_names <- names(...future.oldEnvVars)
[16:18:43.555]                 envs <- base::Sys.getenv()
[16:18:43.555]                 names <- names(envs)
[16:18:43.555]                 common <- intersect(names, old_names)
[16:18:43.555]                 added <- setdiff(names, old_names)
[16:18:43.555]                 removed <- setdiff(old_names, names)
[16:18:43.555]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.555]                   envs[common]]
[16:18:43.555]                 NAMES <- toupper(changed)
[16:18:43.555]                 args <- list()
[16:18:43.555]                 for (kk in seq_along(NAMES)) {
[16:18:43.555]                   name <- changed[[kk]]
[16:18:43.555]                   NAME <- NAMES[[kk]]
[16:18:43.555]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.555]                     next
[16:18:43.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.555]                 }
[16:18:43.555]                 NAMES <- toupper(added)
[16:18:43.555]                 for (kk in seq_along(NAMES)) {
[16:18:43.555]                   name <- added[[kk]]
[16:18:43.555]                   NAME <- NAMES[[kk]]
[16:18:43.555]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.555]                     next
[16:18:43.555]                   args[[name]] <- ""
[16:18:43.555]                 }
[16:18:43.555]                 NAMES <- toupper(removed)
[16:18:43.555]                 for (kk in seq_along(NAMES)) {
[16:18:43.555]                   name <- removed[[kk]]
[16:18:43.555]                   NAME <- NAMES[[kk]]
[16:18:43.555]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.555]                     next
[16:18:43.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.555]                 }
[16:18:43.555]                 if (length(args) > 0) 
[16:18:43.555]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.555]             }
[16:18:43.555]             else {
[16:18:43.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.555]             }
[16:18:43.555]             {
[16:18:43.555]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.555]                   0L) {
[16:18:43.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.555]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.555]                   base::options(opts)
[16:18:43.555]                 }
[16:18:43.555]                 {
[16:18:43.555]                   {
[16:18:43.555]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.555]                     NULL
[16:18:43.555]                   }
[16:18:43.555]                   options(future.plan = NULL)
[16:18:43.555]                   if (is.na(NA_character_)) 
[16:18:43.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.555]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.555]                     .init = FALSE)
[16:18:43.555]                 }
[16:18:43.555]             }
[16:18:43.555]         }
[16:18:43.555]     })
[16:18:43.555]     if (TRUE) {
[16:18:43.555]         base::sink(type = "output", split = FALSE)
[16:18:43.555]         if (TRUE) {
[16:18:43.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.555]         }
[16:18:43.555]         else {
[16:18:43.555]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.555]         }
[16:18:43.555]         base::close(...future.stdout)
[16:18:43.555]         ...future.stdout <- NULL
[16:18:43.555]     }
[16:18:43.555]     ...future.result$conditions <- ...future.conditions
[16:18:43.555]     ...future.result$finished <- base::Sys.time()
[16:18:43.555]     ...future.result
[16:18:43.555] }
[16:18:43.557] assign_globals() ...
[16:18:43.557] List of 5
[16:18:43.557]  $ ...future.FUN            :function (e1, e2)  
[16:18:43.557]  $ MoreArgs                 : NULL
[16:18:43.557]  $ ...future.elements_ii    :List of 2
[16:18:43.557]   ..$ :List of 1
[16:18:43.557]   .. ..$ : num 1
[16:18:43.557]   ..$ :List of 1
[16:18:43.557]   .. ..$ : int 1
[16:18:43.557]  $ ...future.seeds_ii       : NULL
[16:18:43.557]  $ ...future.globals.maxSize: NULL
[16:18:43.557]  - attr(*, "where")=List of 5
[16:18:43.557]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.557]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.557]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.557]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.557]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.557]  - attr(*, "resolved")= logi FALSE
[16:18:43.557]  - attr(*, "total_size")= num 168
[16:18:43.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.557]  - attr(*, "already-done")= logi TRUE
[16:18:43.563] - copied ‘...future.FUN’ to environment
[16:18:43.563] - copied ‘MoreArgs’ to environment
[16:18:43.563] - copied ‘...future.elements_ii’ to environment
[16:18:43.563] - copied ‘...future.seeds_ii’ to environment
[16:18:43.563] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.563] assign_globals() ... done
[16:18:43.563] requestCore(): workers = 2
[16:18:43.566] MulticoreFuture started
[16:18:43.566] - Launch lazy future ... done
[16:18:43.566] run() for ‘MulticoreFuture’ ... done
[16:18:43.566] Created future:
[16:18:43.567] plan(): Setting new future strategy stack:
[16:18:43.567] List of future strategies:
[16:18:43.567] 1. sequential:
[16:18:43.567]    - args: function (..., envir = parent.frame())
[16:18:43.567]    - tweaked: FALSE
[16:18:43.567]    - call: NULL
[16:18:43.568] plan(): nbrOfWorkers() = 1
[16:18:43.570] plan(): Setting new future strategy stack:
[16:18:43.570] List of future strategies:
[16:18:43.570] 1. multicore:
[16:18:43.570]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.570]    - tweaked: FALSE
[16:18:43.570]    - call: plan(strategy)
[16:18:43.575] plan(): nbrOfWorkers() = 2
[16:18:43.566] MulticoreFuture:
[16:18:43.566] Label: ‘future_Map-1’
[16:18:43.566] Expression:
[16:18:43.566] {
[16:18:43.566]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.566]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.566]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.566]         on.exit(options(oopts), add = TRUE)
[16:18:43.566]     }
[16:18:43.566]     {
[16:18:43.566]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.566]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.566]         do.call(mapply, args = args)
[16:18:43.566]     }
[16:18:43.566] }
[16:18:43.566] Lazy evaluation: FALSE
[16:18:43.566] Asynchronous evaluation: TRUE
[16:18:43.566] Local evaluation: TRUE
[16:18:43.566] Environment: R_GlobalEnv
[16:18:43.566] Capture standard output: TRUE
[16:18:43.566] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.566] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.566] Packages: <none>
[16:18:43.566] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:43.566] Resolved: TRUE
[16:18:43.566] Value: <not collected>
[16:18:43.566] Conditions captured: <none>
[16:18:43.566] Early signaling: FALSE
[16:18:43.566] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.566] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.576] Chunk #1 of 2 ... DONE
[16:18:43.576] Chunk #2 of 2 ...
[16:18:43.576]  - Finding globals in '...' for chunk #2 ...
[16:18:43.576] getGlobalsAndPackages() ...
[16:18:43.577] Searching for globals...
[16:18:43.577] 
[16:18:43.577] Searching for globals ... DONE
[16:18:43.577] - globals: [0] <none>
[16:18:43.577] getGlobalsAndPackages() ... DONE
[16:18:43.578]    + additional globals found: [n=0] 
[16:18:43.578]    + additional namespaces needed: [n=0] 
[16:18:43.578]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:43.578]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.578]  - seeds: <none>
[16:18:43.578]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.578] getGlobalsAndPackages() ...
[16:18:43.578] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.579] Resolving globals: FALSE
[16:18:43.579] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:43.580] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:43.580] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.581] 
[16:18:43.581] getGlobalsAndPackages() ... DONE
[16:18:43.581] run() for ‘Future’ ...
[16:18:43.581] - state: ‘created’
[16:18:43.581] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.586] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.586] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.586]   - Field: ‘label’
[16:18:43.586]   - Field: ‘local’
[16:18:43.586]   - Field: ‘owner’
[16:18:43.586]   - Field: ‘envir’
[16:18:43.587]   - Field: ‘workers’
[16:18:43.587]   - Field: ‘packages’
[16:18:43.587]   - Field: ‘gc’
[16:18:43.587]   - Field: ‘job’
[16:18:43.587]   - Field: ‘conditions’
[16:18:43.587]   - Field: ‘expr’
[16:18:43.587]   - Field: ‘uuid’
[16:18:43.587]   - Field: ‘seed’
[16:18:43.588]   - Field: ‘version’
[16:18:43.588]   - Field: ‘result’
[16:18:43.588]   - Field: ‘asynchronous’
[16:18:43.588]   - Field: ‘calls’
[16:18:43.588]   - Field: ‘globals’
[16:18:43.588]   - Field: ‘stdout’
[16:18:43.588]   - Field: ‘earlySignal’
[16:18:43.589]   - Field: ‘lazy’
[16:18:43.589]   - Field: ‘state’
[16:18:43.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.589] - Launch lazy future ...
[16:18:43.589] Packages needed by the future expression (n = 0): <none>
[16:18:43.590] Packages needed by future strategies (n = 0): <none>
[16:18:43.590] {
[16:18:43.590]     {
[16:18:43.590]         {
[16:18:43.590]             ...future.startTime <- base::Sys.time()
[16:18:43.590]             {
[16:18:43.590]                 {
[16:18:43.590]                   {
[16:18:43.590]                     {
[16:18:43.590]                       base::local({
[16:18:43.590]                         has_future <- base::requireNamespace("future", 
[16:18:43.590]                           quietly = TRUE)
[16:18:43.590]                         if (has_future) {
[16:18:43.590]                           ns <- base::getNamespace("future")
[16:18:43.590]                           version <- ns[[".package"]][["version"]]
[16:18:43.590]                           if (is.null(version)) 
[16:18:43.590]                             version <- utils::packageVersion("future")
[16:18:43.590]                         }
[16:18:43.590]                         else {
[16:18:43.590]                           version <- NULL
[16:18:43.590]                         }
[16:18:43.590]                         if (!has_future || version < "1.8.0") {
[16:18:43.590]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.590]                             "", base::R.version$version.string), 
[16:18:43.590]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:43.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:43.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.590]                               "release", "version")], collapse = " "), 
[16:18:43.590]                             hostname = base::Sys.info()[["nodename"]])
[16:18:43.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.590]                             info)
[16:18:43.590]                           info <- base::paste(info, collapse = "; ")
[16:18:43.590]                           if (!has_future) {
[16:18:43.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.590]                               info)
[16:18:43.590]                           }
[16:18:43.590]                           else {
[16:18:43.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.590]                               info, version)
[16:18:43.590]                           }
[16:18:43.590]                           base::stop(msg)
[16:18:43.590]                         }
[16:18:43.590]                       })
[16:18:43.590]                     }
[16:18:43.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.590]                     base::options(mc.cores = 1L)
[16:18:43.590]                   }
[16:18:43.590]                   ...future.strategy.old <- future::plan("list")
[16:18:43.590]                   options(future.plan = NULL)
[16:18:43.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.590]                 }
[16:18:43.590]                 ...future.workdir <- getwd()
[16:18:43.590]             }
[16:18:43.590]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.590]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.590]         }
[16:18:43.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.590]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.590]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.590]             base::names(...future.oldOptions))
[16:18:43.590]     }
[16:18:43.590]     if (FALSE) {
[16:18:43.590]     }
[16:18:43.590]     else {
[16:18:43.590]         if (TRUE) {
[16:18:43.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.590]                 open = "w")
[16:18:43.590]         }
[16:18:43.590]         else {
[16:18:43.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.590]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.590]         }
[16:18:43.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.590]             base::sink(type = "output", split = FALSE)
[16:18:43.590]             base::close(...future.stdout)
[16:18:43.590]         }, add = TRUE)
[16:18:43.590]     }
[16:18:43.590]     ...future.frame <- base::sys.nframe()
[16:18:43.590]     ...future.conditions <- base::list()
[16:18:43.590]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.590]     if (FALSE) {
[16:18:43.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.590]     }
[16:18:43.590]     ...future.result <- base::tryCatch({
[16:18:43.590]         base::withCallingHandlers({
[16:18:43.590]             ...future.value <- base::withVisible(base::local({
[16:18:43.590]                 withCallingHandlers({
[16:18:43.590]                   {
[16:18:43.590]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.590]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.590]                       ...future.globals.maxSize)) {
[16:18:43.590]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.590]                       on.exit(options(oopts), add = TRUE)
[16:18:43.590]                     }
[16:18:43.590]                     {
[16:18:43.590]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.590]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.590]                         USE.NAMES = FALSE)
[16:18:43.590]                       do.call(mapply, args = args)
[16:18:43.590]                     }
[16:18:43.590]                   }
[16:18:43.590]                 }, immediateCondition = function(cond) {
[16:18:43.590]                   save_rds <- function (object, pathname, ...) 
[16:18:43.590]                   {
[16:18:43.590]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.590]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.590]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.590]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.590]                         fi_tmp[["mtime"]])
[16:18:43.590]                     }
[16:18:43.590]                     tryCatch({
[16:18:43.590]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.590]                     }, error = function(ex) {
[16:18:43.590]                       msg <- conditionMessage(ex)
[16:18:43.590]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.590]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.590]                         fi_tmp[["mtime"]], msg)
[16:18:43.590]                       ex$message <- msg
[16:18:43.590]                       stop(ex)
[16:18:43.590]                     })
[16:18:43.590]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.590]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.590]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.590]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.590]                       fi <- file.info(pathname)
[16:18:43.590]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.590]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.590]                         fi[["size"]], fi[["mtime"]])
[16:18:43.590]                       stop(msg)
[16:18:43.590]                     }
[16:18:43.590]                     invisible(pathname)
[16:18:43.590]                   }
[16:18:43.590]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.590]                     rootPath = tempdir()) 
[16:18:43.590]                   {
[16:18:43.590]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.590]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.590]                       tmpdir = path, fileext = ".rds")
[16:18:43.590]                     save_rds(obj, file)
[16:18:43.590]                   }
[16:18:43.590]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.590]                   {
[16:18:43.590]                     inherits <- base::inherits
[16:18:43.590]                     invokeRestart <- base::invokeRestart
[16:18:43.590]                     is.null <- base::is.null
[16:18:43.590]                     muffled <- FALSE
[16:18:43.590]                     if (inherits(cond, "message")) {
[16:18:43.590]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.590]                       if (muffled) 
[16:18:43.590]                         invokeRestart("muffleMessage")
[16:18:43.590]                     }
[16:18:43.590]                     else if (inherits(cond, "warning")) {
[16:18:43.590]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.590]                       if (muffled) 
[16:18:43.590]                         invokeRestart("muffleWarning")
[16:18:43.590]                     }
[16:18:43.590]                     else if (inherits(cond, "condition")) {
[16:18:43.590]                       if (!is.null(pattern)) {
[16:18:43.590]                         computeRestarts <- base::computeRestarts
[16:18:43.590]                         grepl <- base::grepl
[16:18:43.590]                         restarts <- computeRestarts(cond)
[16:18:43.590]                         for (restart in restarts) {
[16:18:43.590]                           name <- restart$name
[16:18:43.590]                           if (is.null(name)) 
[16:18:43.590]                             next
[16:18:43.590]                           if (!grepl(pattern, name)) 
[16:18:43.590]                             next
[16:18:43.590]                           invokeRestart(restart)
[16:18:43.590]                           muffled <- TRUE
[16:18:43.590]                           break
[16:18:43.590]                         }
[16:18:43.590]                       }
[16:18:43.590]                     }
[16:18:43.590]                     invisible(muffled)
[16:18:43.590]                   }
[16:18:43.590]                   muffleCondition(cond)
[16:18:43.590]                 })
[16:18:43.590]             }))
[16:18:43.590]             future::FutureResult(value = ...future.value$value, 
[16:18:43.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.590]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.590]                     ...future.globalenv.names))
[16:18:43.590]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.590]         }, condition = base::local({
[16:18:43.590]             c <- base::c
[16:18:43.590]             inherits <- base::inherits
[16:18:43.590]             invokeRestart <- base::invokeRestart
[16:18:43.590]             length <- base::length
[16:18:43.590]             list <- base::list
[16:18:43.590]             seq.int <- base::seq.int
[16:18:43.590]             signalCondition <- base::signalCondition
[16:18:43.590]             sys.calls <- base::sys.calls
[16:18:43.590]             `[[` <- base::`[[`
[16:18:43.590]             `+` <- base::`+`
[16:18:43.590]             `<<-` <- base::`<<-`
[16:18:43.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.590]                   3L)]
[16:18:43.590]             }
[16:18:43.590]             function(cond) {
[16:18:43.590]                 is_error <- inherits(cond, "error")
[16:18:43.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.590]                   NULL)
[16:18:43.590]                 if (is_error) {
[16:18:43.590]                   sessionInformation <- function() {
[16:18:43.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.590]                       search = base::search(), system = base::Sys.info())
[16:18:43.590]                   }
[16:18:43.590]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.590]                     cond$call), session = sessionInformation(), 
[16:18:43.590]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.590]                   signalCondition(cond)
[16:18:43.590]                 }
[16:18:43.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.590]                 "immediateCondition"))) {
[16:18:43.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.590]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.590]                   if (TRUE && !signal) {
[16:18:43.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.590]                     {
[16:18:43.590]                       inherits <- base::inherits
[16:18:43.590]                       invokeRestart <- base::invokeRestart
[16:18:43.590]                       is.null <- base::is.null
[16:18:43.590]                       muffled <- FALSE
[16:18:43.590]                       if (inherits(cond, "message")) {
[16:18:43.590]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.590]                         if (muffled) 
[16:18:43.590]                           invokeRestart("muffleMessage")
[16:18:43.590]                       }
[16:18:43.590]                       else if (inherits(cond, "warning")) {
[16:18:43.590]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.590]                         if (muffled) 
[16:18:43.590]                           invokeRestart("muffleWarning")
[16:18:43.590]                       }
[16:18:43.590]                       else if (inherits(cond, "condition")) {
[16:18:43.590]                         if (!is.null(pattern)) {
[16:18:43.590]                           computeRestarts <- base::computeRestarts
[16:18:43.590]                           grepl <- base::grepl
[16:18:43.590]                           restarts <- computeRestarts(cond)
[16:18:43.590]                           for (restart in restarts) {
[16:18:43.590]                             name <- restart$name
[16:18:43.590]                             if (is.null(name)) 
[16:18:43.590]                               next
[16:18:43.590]                             if (!grepl(pattern, name)) 
[16:18:43.590]                               next
[16:18:43.590]                             invokeRestart(restart)
[16:18:43.590]                             muffled <- TRUE
[16:18:43.590]                             break
[16:18:43.590]                           }
[16:18:43.590]                         }
[16:18:43.590]                       }
[16:18:43.590]                       invisible(muffled)
[16:18:43.590]                     }
[16:18:43.590]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.590]                   }
[16:18:43.590]                 }
[16:18:43.590]                 else {
[16:18:43.590]                   if (TRUE) {
[16:18:43.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.590]                     {
[16:18:43.590]                       inherits <- base::inherits
[16:18:43.590]                       invokeRestart <- base::invokeRestart
[16:18:43.590]                       is.null <- base::is.null
[16:18:43.590]                       muffled <- FALSE
[16:18:43.590]                       if (inherits(cond, "message")) {
[16:18:43.590]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.590]                         if (muffled) 
[16:18:43.590]                           invokeRestart("muffleMessage")
[16:18:43.590]                       }
[16:18:43.590]                       else if (inherits(cond, "warning")) {
[16:18:43.590]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.590]                         if (muffled) 
[16:18:43.590]                           invokeRestart("muffleWarning")
[16:18:43.590]                       }
[16:18:43.590]                       else if (inherits(cond, "condition")) {
[16:18:43.590]                         if (!is.null(pattern)) {
[16:18:43.590]                           computeRestarts <- base::computeRestarts
[16:18:43.590]                           grepl <- base::grepl
[16:18:43.590]                           restarts <- computeRestarts(cond)
[16:18:43.590]                           for (restart in restarts) {
[16:18:43.590]                             name <- restart$name
[16:18:43.590]                             if (is.null(name)) 
[16:18:43.590]                               next
[16:18:43.590]                             if (!grepl(pattern, name)) 
[16:18:43.590]                               next
[16:18:43.590]                             invokeRestart(restart)
[16:18:43.590]                             muffled <- TRUE
[16:18:43.590]                             break
[16:18:43.590]                           }
[16:18:43.590]                         }
[16:18:43.590]                       }
[16:18:43.590]                       invisible(muffled)
[16:18:43.590]                     }
[16:18:43.590]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.590]                   }
[16:18:43.590]                 }
[16:18:43.590]             }
[16:18:43.590]         }))
[16:18:43.590]     }, error = function(ex) {
[16:18:43.590]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.590]                 ...future.rng), started = ...future.startTime, 
[16:18:43.590]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.590]             version = "1.8"), class = "FutureResult")
[16:18:43.590]     }, finally = {
[16:18:43.590]         if (!identical(...future.workdir, getwd())) 
[16:18:43.590]             setwd(...future.workdir)
[16:18:43.590]         {
[16:18:43.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.590]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.590]             }
[16:18:43.590]             base::options(...future.oldOptions)
[16:18:43.590]             if (.Platform$OS.type == "windows") {
[16:18:43.590]                 old_names <- names(...future.oldEnvVars)
[16:18:43.590]                 envs <- base::Sys.getenv()
[16:18:43.590]                 names <- names(envs)
[16:18:43.590]                 common <- intersect(names, old_names)
[16:18:43.590]                 added <- setdiff(names, old_names)
[16:18:43.590]                 removed <- setdiff(old_names, names)
[16:18:43.590]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.590]                   envs[common]]
[16:18:43.590]                 NAMES <- toupper(changed)
[16:18:43.590]                 args <- list()
[16:18:43.590]                 for (kk in seq_along(NAMES)) {
[16:18:43.590]                   name <- changed[[kk]]
[16:18:43.590]                   NAME <- NAMES[[kk]]
[16:18:43.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.590]                     next
[16:18:43.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.590]                 }
[16:18:43.590]                 NAMES <- toupper(added)
[16:18:43.590]                 for (kk in seq_along(NAMES)) {
[16:18:43.590]                   name <- added[[kk]]
[16:18:43.590]                   NAME <- NAMES[[kk]]
[16:18:43.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.590]                     next
[16:18:43.590]                   args[[name]] <- ""
[16:18:43.590]                 }
[16:18:43.590]                 NAMES <- toupper(removed)
[16:18:43.590]                 for (kk in seq_along(NAMES)) {
[16:18:43.590]                   name <- removed[[kk]]
[16:18:43.590]                   NAME <- NAMES[[kk]]
[16:18:43.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.590]                     next
[16:18:43.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.590]                 }
[16:18:43.590]                 if (length(args) > 0) 
[16:18:43.590]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.590]             }
[16:18:43.590]             else {
[16:18:43.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.590]             }
[16:18:43.590]             {
[16:18:43.590]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.590]                   0L) {
[16:18:43.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.590]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.590]                   base::options(opts)
[16:18:43.590]                 }
[16:18:43.590]                 {
[16:18:43.590]                   {
[16:18:43.590]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.590]                     NULL
[16:18:43.590]                   }
[16:18:43.590]                   options(future.plan = NULL)
[16:18:43.590]                   if (is.na(NA_character_)) 
[16:18:43.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.590]                     .init = FALSE)
[16:18:43.590]                 }
[16:18:43.590]             }
[16:18:43.590]         }
[16:18:43.590]     })
[16:18:43.590]     if (TRUE) {
[16:18:43.590]         base::sink(type = "output", split = FALSE)
[16:18:43.590]         if (TRUE) {
[16:18:43.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.590]         }
[16:18:43.590]         else {
[16:18:43.590]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.590]         }
[16:18:43.590]         base::close(...future.stdout)
[16:18:43.590]         ...future.stdout <- NULL
[16:18:43.590]     }
[16:18:43.590]     ...future.result$conditions <- ...future.conditions
[16:18:43.590]     ...future.result$finished <- base::Sys.time()
[16:18:43.590]     ...future.result
[16:18:43.590] }
[16:18:43.593] assign_globals() ...
[16:18:43.593] List of 5
[16:18:43.593]  $ ...future.FUN            :function (e1, e2)  
[16:18:43.593]  $ MoreArgs                 : NULL
[16:18:43.593]  $ ...future.elements_ii    :List of 2
[16:18:43.593]   ..$ :List of 2
[16:18:43.593]   .. ..$ : num 1
[16:18:43.593]   .. ..$ : num 1
[16:18:43.593]   ..$ :List of 2
[16:18:43.593]   .. ..$ : int 2
[16:18:43.593]   .. ..$ : int 3
[16:18:43.593]  $ ...future.seeds_ii       : NULL
[16:18:43.593]  $ ...future.globals.maxSize: NULL
[16:18:43.593]  - attr(*, "where")=List of 5
[16:18:43.593]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.593]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.593]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.593]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.593]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.593]  - attr(*, "resolved")= logi FALSE
[16:18:43.593]  - attr(*, "total_size")= num 280
[16:18:43.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.593]  - attr(*, "already-done")= logi TRUE
[16:18:43.601] - copied ‘...future.FUN’ to environment
[16:18:43.602] - copied ‘MoreArgs’ to environment
[16:18:43.602] - copied ‘...future.elements_ii’ to environment
[16:18:43.602] - copied ‘...future.seeds_ii’ to environment
[16:18:43.602] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.602] assign_globals() ... done
[16:18:43.602] requestCore(): workers = 2
[16:18:43.605] MulticoreFuture started
[16:18:43.605] - Launch lazy future ... done
[16:18:43.605] run() for ‘MulticoreFuture’ ... done
[16:18:43.605] Created future:
[16:18:43.606] plan(): Setting new future strategy stack:
[16:18:43.606] List of future strategies:
[16:18:43.606] 1. sequential:
[16:18:43.606]    - args: function (..., envir = parent.frame())
[16:18:43.606]    - tweaked: FALSE
[16:18:43.606]    - call: NULL
[16:18:43.607] plan(): nbrOfWorkers() = 1
[16:18:43.609] plan(): Setting new future strategy stack:
[16:18:43.609] List of future strategies:
[16:18:43.609] 1. multicore:
[16:18:43.609]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.609]    - tweaked: FALSE
[16:18:43.609]    - call: plan(strategy)
[16:18:43.614] plan(): nbrOfWorkers() = 2
[16:18:43.606] MulticoreFuture:
[16:18:43.606] Label: ‘future_Map-2’
[16:18:43.606] Expression:
[16:18:43.606] {
[16:18:43.606]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.606]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.606]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.606]         on.exit(options(oopts), add = TRUE)
[16:18:43.606]     }
[16:18:43.606]     {
[16:18:43.606]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.606]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.606]         do.call(mapply, args = args)
[16:18:43.606]     }
[16:18:43.606] }
[16:18:43.606] Lazy evaluation: FALSE
[16:18:43.606] Asynchronous evaluation: TRUE
[16:18:43.606] Local evaluation: TRUE
[16:18:43.606] Environment: R_GlobalEnv
[16:18:43.606] Capture standard output: TRUE
[16:18:43.606] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.606] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.606] Packages: <none>
[16:18:43.606] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:43.606] Resolved: TRUE
[16:18:43.606] Value: <not collected>
[16:18:43.606] Conditions captured: <none>
[16:18:43.606] Early signaling: FALSE
[16:18:43.606] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.606] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.615] Chunk #2 of 2 ... DONE
[16:18:43.615] Launching 2 futures (chunks) ... DONE
[16:18:43.615] Resolving 2 futures (chunks) ...
[16:18:43.615] resolve() on list ...
[16:18:43.616]  recursive: 0
[16:18:43.616]  length: 2
[16:18:43.616] 
[16:18:43.616] Future #1
[16:18:43.616] result() for MulticoreFuture ...
[16:18:43.617] result() for MulticoreFuture ...
[16:18:43.617] result() for MulticoreFuture ... done
[16:18:43.618] result() for MulticoreFuture ... done
[16:18:43.618] result() for MulticoreFuture ...
[16:18:43.618] result() for MulticoreFuture ... done
[16:18:43.618] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:43.618] - nx: 2
[16:18:43.618] - relay: TRUE
[16:18:43.618] - stdout: TRUE
[16:18:43.619] - signal: TRUE
[16:18:43.619] - resignal: FALSE
[16:18:43.619] - force: TRUE
[16:18:43.619] - relayed: [n=2] FALSE, FALSE
[16:18:43.619] - queued futures: [n=2] FALSE, FALSE
[16:18:43.619]  - until=1
[16:18:43.619]  - relaying element #1
[16:18:43.619] result() for MulticoreFuture ...
[16:18:43.620] result() for MulticoreFuture ... done
[16:18:43.620] result() for MulticoreFuture ...
[16:18:43.620] result() for MulticoreFuture ... done
[16:18:43.620] result() for MulticoreFuture ...
[16:18:43.620] result() for MulticoreFuture ... done
[16:18:43.620] result() for MulticoreFuture ...
[16:18:43.620] result() for MulticoreFuture ... done
[16:18:43.621] - relayed: [n=2] TRUE, FALSE
[16:18:43.621] - queued futures: [n=2] TRUE, FALSE
[16:18:43.621] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:43.621]  length: 1 (resolved future 1)
[16:18:43.621] Future #2
[16:18:43.621] result() for MulticoreFuture ...
[16:18:43.622] result() for MulticoreFuture ...
[16:18:43.622] result() for MulticoreFuture ... done
[16:18:43.622] result() for MulticoreFuture ... done
[16:18:43.622] result() for MulticoreFuture ...
[16:18:43.622] result() for MulticoreFuture ... done
[16:18:43.623] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:43.623] - nx: 2
[16:18:43.623] - relay: TRUE
[16:18:43.623] - stdout: TRUE
[16:18:43.623] - signal: TRUE
[16:18:43.623] - resignal: FALSE
[16:18:43.623] - force: TRUE
[16:18:43.623] - relayed: [n=2] TRUE, FALSE
[16:18:43.623] - queued futures: [n=2] TRUE, FALSE
[16:18:43.624]  - until=2
[16:18:43.624]  - relaying element #2
[16:18:43.624] result() for MulticoreFuture ...
[16:18:43.624] result() for MulticoreFuture ... done
[16:18:43.624] result() for MulticoreFuture ...
[16:18:43.624] result() for MulticoreFuture ... done
[16:18:43.624] result() for MulticoreFuture ...
[16:18:43.625] result() for MulticoreFuture ... done
[16:18:43.625] result() for MulticoreFuture ...
[16:18:43.625] result() for MulticoreFuture ... done
[16:18:43.625] - relayed: [n=2] TRUE, TRUE
[16:18:43.625] - queued futures: [n=2] TRUE, TRUE
[16:18:43.625] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:43.625]  length: 0 (resolved future 2)
[16:18:43.625] Relaying remaining futures
[16:18:43.625] signalConditionsASAP(NULL, pos=0) ...
[16:18:43.626] - nx: 2
[16:18:43.626] - relay: TRUE
[16:18:43.626] - stdout: TRUE
[16:18:43.626] - signal: TRUE
[16:18:43.626] - resignal: FALSE
[16:18:43.626] - force: TRUE
[16:18:43.626] - relayed: [n=2] TRUE, TRUE
[16:18:43.626] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:43.627] - relayed: [n=2] TRUE, TRUE
[16:18:43.627] - queued futures: [n=2] TRUE, TRUE
[16:18:43.627] signalConditionsASAP(NULL, pos=0) ... done
[16:18:43.627] resolve() on list ... DONE
[16:18:43.627] result() for MulticoreFuture ...
[16:18:43.627] result() for MulticoreFuture ... done
[16:18:43.627] result() for MulticoreFuture ...
[16:18:43.627] result() for MulticoreFuture ... done
[16:18:43.628] result() for MulticoreFuture ...
[16:18:43.628] result() for MulticoreFuture ... done
[16:18:43.628] result() for MulticoreFuture ...
[16:18:43.628] result() for MulticoreFuture ... done
[16:18:43.628]  - Number of value chunks collected: 2
[16:18:43.628] Resolving 2 futures (chunks) ... DONE
[16:18:43.628] Reducing values from 2 chunks ...
[16:18:43.628]  - Number of values collected after concatenation: 3
[16:18:43.629]  - Number of values expected: 3
[16:18:43.629] Reducing values from 2 chunks ... DONE
[16:18:43.629] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[16:18:43.629] future_mapply() ...
[16:18:43.634] Number of chunks: 2
[16:18:43.634] getGlobalsAndPackagesXApply() ...
[16:18:43.634]  - future.globals: TRUE
[16:18:43.634] getGlobalsAndPackages() ...
[16:18:43.634] Searching for globals...
[16:18:43.636] - globals found: [1] ‘FUN’
[16:18:43.636] Searching for globals ... DONE
[16:18:43.636] Resolving globals: FALSE
[16:18:43.636] The total size of the 1 globals is 848 bytes (848 bytes)
[16:18:43.637] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:18:43.637] - globals: [1] ‘FUN’
[16:18:43.637] 
[16:18:43.637] getGlobalsAndPackages() ... DONE
[16:18:43.637]  - globals found/used: [n=1] ‘FUN’
[16:18:43.637]  - needed namespaces: [n=0] 
[16:18:43.637] Finding globals ... DONE
[16:18:43.638] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:43.638] List of 2
[16:18:43.638]  $ ...future.FUN:function (x)  
[16:18:43.638]  $ MoreArgs     : NULL
[16:18:43.638]  - attr(*, "where")=List of 2
[16:18:43.638]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:43.638]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:43.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.638]  - attr(*, "resolved")= logi FALSE
[16:18:43.638]  - attr(*, "total_size")= num NA
[16:18:43.641] Packages to be attached in all futures: [n=0] 
[16:18:43.641] getGlobalsAndPackagesXApply() ... DONE
[16:18:43.642] Number of futures (= number of chunks): 2
[16:18:43.642] Launching 2 futures (chunks) ...
[16:18:43.642] Chunk #1 of 2 ...
[16:18:43.642]  - Finding globals in '...' for chunk #1 ...
[16:18:43.642] getGlobalsAndPackages() ...
[16:18:43.642] Searching for globals...
[16:18:43.643] 
[16:18:43.643] Searching for globals ... DONE
[16:18:43.643] - globals: [0] <none>
[16:18:43.643] getGlobalsAndPackages() ... DONE
[16:18:43.643]    + additional globals found: [n=0] 
[16:18:43.643]    + additional namespaces needed: [n=0] 
[16:18:43.643]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:43.643]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.644]  - seeds: <none>
[16:18:43.644]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.644] getGlobalsAndPackages() ...
[16:18:43.644] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.644] Resolving globals: FALSE
[16:18:43.647] The total size of the 5 globals is 904 bytes (904 bytes)
[16:18:43.648] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:43.648] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.648] 
[16:18:43.648] getGlobalsAndPackages() ... DONE
[16:18:43.648] run() for ‘Future’ ...
[16:18:43.649] - state: ‘created’
[16:18:43.649] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.652] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.652] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.653]   - Field: ‘label’
[16:18:43.653]   - Field: ‘local’
[16:18:43.653]   - Field: ‘owner’
[16:18:43.653]   - Field: ‘envir’
[16:18:43.653]   - Field: ‘workers’
[16:18:43.653]   - Field: ‘packages’
[16:18:43.653]   - Field: ‘gc’
[16:18:43.653]   - Field: ‘job’
[16:18:43.653]   - Field: ‘conditions’
[16:18:43.654]   - Field: ‘expr’
[16:18:43.654]   - Field: ‘uuid’
[16:18:43.654]   - Field: ‘seed’
[16:18:43.654]   - Field: ‘version’
[16:18:43.654]   - Field: ‘result’
[16:18:43.654]   - Field: ‘asynchronous’
[16:18:43.654]   - Field: ‘calls’
[16:18:43.654]   - Field: ‘globals’
[16:18:43.654]   - Field: ‘stdout’
[16:18:43.654]   - Field: ‘earlySignal’
[16:18:43.655]   - Field: ‘lazy’
[16:18:43.655]   - Field: ‘state’
[16:18:43.655] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.655] - Launch lazy future ...
[16:18:43.655] Packages needed by the future expression (n = 0): <none>
[16:18:43.655] Packages needed by future strategies (n = 0): <none>
[16:18:43.656] {
[16:18:43.656]     {
[16:18:43.656]         {
[16:18:43.656]             ...future.startTime <- base::Sys.time()
[16:18:43.656]             {
[16:18:43.656]                 {
[16:18:43.656]                   {
[16:18:43.656]                     {
[16:18:43.656]                       base::local({
[16:18:43.656]                         has_future <- base::requireNamespace("future", 
[16:18:43.656]                           quietly = TRUE)
[16:18:43.656]                         if (has_future) {
[16:18:43.656]                           ns <- base::getNamespace("future")
[16:18:43.656]                           version <- ns[[".package"]][["version"]]
[16:18:43.656]                           if (is.null(version)) 
[16:18:43.656]                             version <- utils::packageVersion("future")
[16:18:43.656]                         }
[16:18:43.656]                         else {
[16:18:43.656]                           version <- NULL
[16:18:43.656]                         }
[16:18:43.656]                         if (!has_future || version < "1.8.0") {
[16:18:43.656]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.656]                             "", base::R.version$version.string), 
[16:18:43.656]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:43.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:43.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.656]                               "release", "version")], collapse = " "), 
[16:18:43.656]                             hostname = base::Sys.info()[["nodename"]])
[16:18:43.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.656]                             info)
[16:18:43.656]                           info <- base::paste(info, collapse = "; ")
[16:18:43.656]                           if (!has_future) {
[16:18:43.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.656]                               info)
[16:18:43.656]                           }
[16:18:43.656]                           else {
[16:18:43.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.656]                               info, version)
[16:18:43.656]                           }
[16:18:43.656]                           base::stop(msg)
[16:18:43.656]                         }
[16:18:43.656]                       })
[16:18:43.656]                     }
[16:18:43.656]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.656]                     base::options(mc.cores = 1L)
[16:18:43.656]                   }
[16:18:43.656]                   ...future.strategy.old <- future::plan("list")
[16:18:43.656]                   options(future.plan = NULL)
[16:18:43.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.656]                 }
[16:18:43.656]                 ...future.workdir <- getwd()
[16:18:43.656]             }
[16:18:43.656]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.656]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.656]         }
[16:18:43.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.656]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.656]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.656]             base::names(...future.oldOptions))
[16:18:43.656]     }
[16:18:43.656]     if (FALSE) {
[16:18:43.656]     }
[16:18:43.656]     else {
[16:18:43.656]         if (TRUE) {
[16:18:43.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.656]                 open = "w")
[16:18:43.656]         }
[16:18:43.656]         else {
[16:18:43.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.656]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.656]         }
[16:18:43.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.656]             base::sink(type = "output", split = FALSE)
[16:18:43.656]             base::close(...future.stdout)
[16:18:43.656]         }, add = TRUE)
[16:18:43.656]     }
[16:18:43.656]     ...future.frame <- base::sys.nframe()
[16:18:43.656]     ...future.conditions <- base::list()
[16:18:43.656]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.656]     if (FALSE) {
[16:18:43.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.656]     }
[16:18:43.656]     ...future.result <- base::tryCatch({
[16:18:43.656]         base::withCallingHandlers({
[16:18:43.656]             ...future.value <- base::withVisible(base::local({
[16:18:43.656]                 withCallingHandlers({
[16:18:43.656]                   {
[16:18:43.656]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.656]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.656]                       ...future.globals.maxSize)) {
[16:18:43.656]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.656]                       on.exit(options(oopts), add = TRUE)
[16:18:43.656]                     }
[16:18:43.656]                     {
[16:18:43.656]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.656]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.656]                         USE.NAMES = FALSE)
[16:18:43.656]                       do.call(mapply, args = args)
[16:18:43.656]                     }
[16:18:43.656]                   }
[16:18:43.656]                 }, immediateCondition = function(cond) {
[16:18:43.656]                   save_rds <- function (object, pathname, ...) 
[16:18:43.656]                   {
[16:18:43.656]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.656]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.656]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.656]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.656]                         fi_tmp[["mtime"]])
[16:18:43.656]                     }
[16:18:43.656]                     tryCatch({
[16:18:43.656]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.656]                     }, error = function(ex) {
[16:18:43.656]                       msg <- conditionMessage(ex)
[16:18:43.656]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.656]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.656]                         fi_tmp[["mtime"]], msg)
[16:18:43.656]                       ex$message <- msg
[16:18:43.656]                       stop(ex)
[16:18:43.656]                     })
[16:18:43.656]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.656]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.656]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.656]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.656]                       fi <- file.info(pathname)
[16:18:43.656]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.656]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.656]                         fi[["size"]], fi[["mtime"]])
[16:18:43.656]                       stop(msg)
[16:18:43.656]                     }
[16:18:43.656]                     invisible(pathname)
[16:18:43.656]                   }
[16:18:43.656]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.656]                     rootPath = tempdir()) 
[16:18:43.656]                   {
[16:18:43.656]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.656]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.656]                       tmpdir = path, fileext = ".rds")
[16:18:43.656]                     save_rds(obj, file)
[16:18:43.656]                   }
[16:18:43.656]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.656]                   {
[16:18:43.656]                     inherits <- base::inherits
[16:18:43.656]                     invokeRestart <- base::invokeRestart
[16:18:43.656]                     is.null <- base::is.null
[16:18:43.656]                     muffled <- FALSE
[16:18:43.656]                     if (inherits(cond, "message")) {
[16:18:43.656]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.656]                       if (muffled) 
[16:18:43.656]                         invokeRestart("muffleMessage")
[16:18:43.656]                     }
[16:18:43.656]                     else if (inherits(cond, "warning")) {
[16:18:43.656]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.656]                       if (muffled) 
[16:18:43.656]                         invokeRestart("muffleWarning")
[16:18:43.656]                     }
[16:18:43.656]                     else if (inherits(cond, "condition")) {
[16:18:43.656]                       if (!is.null(pattern)) {
[16:18:43.656]                         computeRestarts <- base::computeRestarts
[16:18:43.656]                         grepl <- base::grepl
[16:18:43.656]                         restarts <- computeRestarts(cond)
[16:18:43.656]                         for (restart in restarts) {
[16:18:43.656]                           name <- restart$name
[16:18:43.656]                           if (is.null(name)) 
[16:18:43.656]                             next
[16:18:43.656]                           if (!grepl(pattern, name)) 
[16:18:43.656]                             next
[16:18:43.656]                           invokeRestart(restart)
[16:18:43.656]                           muffled <- TRUE
[16:18:43.656]                           break
[16:18:43.656]                         }
[16:18:43.656]                       }
[16:18:43.656]                     }
[16:18:43.656]                     invisible(muffled)
[16:18:43.656]                   }
[16:18:43.656]                   muffleCondition(cond)
[16:18:43.656]                 })
[16:18:43.656]             }))
[16:18:43.656]             future::FutureResult(value = ...future.value$value, 
[16:18:43.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.656]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.656]                     ...future.globalenv.names))
[16:18:43.656]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.656]         }, condition = base::local({
[16:18:43.656]             c <- base::c
[16:18:43.656]             inherits <- base::inherits
[16:18:43.656]             invokeRestart <- base::invokeRestart
[16:18:43.656]             length <- base::length
[16:18:43.656]             list <- base::list
[16:18:43.656]             seq.int <- base::seq.int
[16:18:43.656]             signalCondition <- base::signalCondition
[16:18:43.656]             sys.calls <- base::sys.calls
[16:18:43.656]             `[[` <- base::`[[`
[16:18:43.656]             `+` <- base::`+`
[16:18:43.656]             `<<-` <- base::`<<-`
[16:18:43.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.656]                   3L)]
[16:18:43.656]             }
[16:18:43.656]             function(cond) {
[16:18:43.656]                 is_error <- inherits(cond, "error")
[16:18:43.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.656]                   NULL)
[16:18:43.656]                 if (is_error) {
[16:18:43.656]                   sessionInformation <- function() {
[16:18:43.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.656]                       search = base::search(), system = base::Sys.info())
[16:18:43.656]                   }
[16:18:43.656]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.656]                     cond$call), session = sessionInformation(), 
[16:18:43.656]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.656]                   signalCondition(cond)
[16:18:43.656]                 }
[16:18:43.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.656]                 "immediateCondition"))) {
[16:18:43.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.656]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.656]                   if (TRUE && !signal) {
[16:18:43.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.656]                     {
[16:18:43.656]                       inherits <- base::inherits
[16:18:43.656]                       invokeRestart <- base::invokeRestart
[16:18:43.656]                       is.null <- base::is.null
[16:18:43.656]                       muffled <- FALSE
[16:18:43.656]                       if (inherits(cond, "message")) {
[16:18:43.656]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.656]                         if (muffled) 
[16:18:43.656]                           invokeRestart("muffleMessage")
[16:18:43.656]                       }
[16:18:43.656]                       else if (inherits(cond, "warning")) {
[16:18:43.656]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.656]                         if (muffled) 
[16:18:43.656]                           invokeRestart("muffleWarning")
[16:18:43.656]                       }
[16:18:43.656]                       else if (inherits(cond, "condition")) {
[16:18:43.656]                         if (!is.null(pattern)) {
[16:18:43.656]                           computeRestarts <- base::computeRestarts
[16:18:43.656]                           grepl <- base::grepl
[16:18:43.656]                           restarts <- computeRestarts(cond)
[16:18:43.656]                           for (restart in restarts) {
[16:18:43.656]                             name <- restart$name
[16:18:43.656]                             if (is.null(name)) 
[16:18:43.656]                               next
[16:18:43.656]                             if (!grepl(pattern, name)) 
[16:18:43.656]                               next
[16:18:43.656]                             invokeRestart(restart)
[16:18:43.656]                             muffled <- TRUE
[16:18:43.656]                             break
[16:18:43.656]                           }
[16:18:43.656]                         }
[16:18:43.656]                       }
[16:18:43.656]                       invisible(muffled)
[16:18:43.656]                     }
[16:18:43.656]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.656]                   }
[16:18:43.656]                 }
[16:18:43.656]                 else {
[16:18:43.656]                   if (TRUE) {
[16:18:43.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.656]                     {
[16:18:43.656]                       inherits <- base::inherits
[16:18:43.656]                       invokeRestart <- base::invokeRestart
[16:18:43.656]                       is.null <- base::is.null
[16:18:43.656]                       muffled <- FALSE
[16:18:43.656]                       if (inherits(cond, "message")) {
[16:18:43.656]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.656]                         if (muffled) 
[16:18:43.656]                           invokeRestart("muffleMessage")
[16:18:43.656]                       }
[16:18:43.656]                       else if (inherits(cond, "warning")) {
[16:18:43.656]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.656]                         if (muffled) 
[16:18:43.656]                           invokeRestart("muffleWarning")
[16:18:43.656]                       }
[16:18:43.656]                       else if (inherits(cond, "condition")) {
[16:18:43.656]                         if (!is.null(pattern)) {
[16:18:43.656]                           computeRestarts <- base::computeRestarts
[16:18:43.656]                           grepl <- base::grepl
[16:18:43.656]                           restarts <- computeRestarts(cond)
[16:18:43.656]                           for (restart in restarts) {
[16:18:43.656]                             name <- restart$name
[16:18:43.656]                             if (is.null(name)) 
[16:18:43.656]                               next
[16:18:43.656]                             if (!grepl(pattern, name)) 
[16:18:43.656]                               next
[16:18:43.656]                             invokeRestart(restart)
[16:18:43.656]                             muffled <- TRUE
[16:18:43.656]                             break
[16:18:43.656]                           }
[16:18:43.656]                         }
[16:18:43.656]                       }
[16:18:43.656]                       invisible(muffled)
[16:18:43.656]                     }
[16:18:43.656]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.656]                   }
[16:18:43.656]                 }
[16:18:43.656]             }
[16:18:43.656]         }))
[16:18:43.656]     }, error = function(ex) {
[16:18:43.656]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.656]                 ...future.rng), started = ...future.startTime, 
[16:18:43.656]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.656]             version = "1.8"), class = "FutureResult")
[16:18:43.656]     }, finally = {
[16:18:43.656]         if (!identical(...future.workdir, getwd())) 
[16:18:43.656]             setwd(...future.workdir)
[16:18:43.656]         {
[16:18:43.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.656]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.656]             }
[16:18:43.656]             base::options(...future.oldOptions)
[16:18:43.656]             if (.Platform$OS.type == "windows") {
[16:18:43.656]                 old_names <- names(...future.oldEnvVars)
[16:18:43.656]                 envs <- base::Sys.getenv()
[16:18:43.656]                 names <- names(envs)
[16:18:43.656]                 common <- intersect(names, old_names)
[16:18:43.656]                 added <- setdiff(names, old_names)
[16:18:43.656]                 removed <- setdiff(old_names, names)
[16:18:43.656]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.656]                   envs[common]]
[16:18:43.656]                 NAMES <- toupper(changed)
[16:18:43.656]                 args <- list()
[16:18:43.656]                 for (kk in seq_along(NAMES)) {
[16:18:43.656]                   name <- changed[[kk]]
[16:18:43.656]                   NAME <- NAMES[[kk]]
[16:18:43.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.656]                     next
[16:18:43.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.656]                 }
[16:18:43.656]                 NAMES <- toupper(added)
[16:18:43.656]                 for (kk in seq_along(NAMES)) {
[16:18:43.656]                   name <- added[[kk]]
[16:18:43.656]                   NAME <- NAMES[[kk]]
[16:18:43.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.656]                     next
[16:18:43.656]                   args[[name]] <- ""
[16:18:43.656]                 }
[16:18:43.656]                 NAMES <- toupper(removed)
[16:18:43.656]                 for (kk in seq_along(NAMES)) {
[16:18:43.656]                   name <- removed[[kk]]
[16:18:43.656]                   NAME <- NAMES[[kk]]
[16:18:43.656]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.656]                     next
[16:18:43.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.656]                 }
[16:18:43.656]                 if (length(args) > 0) 
[16:18:43.656]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.656]             }
[16:18:43.656]             else {
[16:18:43.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.656]             }
[16:18:43.656]             {
[16:18:43.656]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.656]                   0L) {
[16:18:43.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.656]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.656]                   base::options(opts)
[16:18:43.656]                 }
[16:18:43.656]                 {
[16:18:43.656]                   {
[16:18:43.656]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.656]                     NULL
[16:18:43.656]                   }
[16:18:43.656]                   options(future.plan = NULL)
[16:18:43.656]                   if (is.na(NA_character_)) 
[16:18:43.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.656]                     .init = FALSE)
[16:18:43.656]                 }
[16:18:43.656]             }
[16:18:43.656]         }
[16:18:43.656]     })
[16:18:43.656]     if (TRUE) {
[16:18:43.656]         base::sink(type = "output", split = FALSE)
[16:18:43.656]         if (TRUE) {
[16:18:43.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.656]         }
[16:18:43.656]         else {
[16:18:43.656]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.656]         }
[16:18:43.656]         base::close(...future.stdout)
[16:18:43.656]         ...future.stdout <- NULL
[16:18:43.656]     }
[16:18:43.656]     ...future.result$conditions <- ...future.conditions
[16:18:43.656]     ...future.result$finished <- base::Sys.time()
[16:18:43.656]     ...future.result
[16:18:43.656] }
[16:18:43.658] assign_globals() ...
[16:18:43.658] List of 5
[16:18:43.658]  $ ...future.FUN            :function (x)  
[16:18:43.658]  $ MoreArgs                 : NULL
[16:18:43.658]  $ ...future.elements_ii    :List of 1
[16:18:43.658]   ..$ :List of 1
[16:18:43.658]   .. ..$ a: num 0
[16:18:43.658]  $ ...future.seeds_ii       : NULL
[16:18:43.658]  $ ...future.globals.maxSize: NULL
[16:18:43.658]  - attr(*, "where")=List of 5
[16:18:43.658]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.658]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.658]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.658]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.658]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.658]  - attr(*, "resolved")= logi FALSE
[16:18:43.658]  - attr(*, "total_size")= num 904
[16:18:43.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.658]  - attr(*, "already-done")= logi TRUE
[16:18:43.663] - copied ‘...future.FUN’ to environment
[16:18:43.663] - copied ‘MoreArgs’ to environment
[16:18:43.664] - copied ‘...future.elements_ii’ to environment
[16:18:43.664] - copied ‘...future.seeds_ii’ to environment
[16:18:43.664] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.664] assign_globals() ... done
[16:18:43.664] requestCore(): workers = 2
[16:18:43.666] MulticoreFuture started
[16:18:43.667] - Launch lazy future ... done
[16:18:43.667] run() for ‘MulticoreFuture’ ... done
[16:18:43.667] Created future:
[16:18:43.667] plan(): Setting new future strategy stack:
[16:18:43.668] List of future strategies:
[16:18:43.668] 1. sequential:
[16:18:43.668]    - args: function (..., envir = parent.frame())
[16:18:43.668]    - tweaked: FALSE
[16:18:43.668]    - call: NULL
[16:18:43.668] plan(): nbrOfWorkers() = 1
[16:18:43.670] plan(): Setting new future strategy stack:
[16:18:43.670] List of future strategies:
[16:18:43.670] 1. multicore:
[16:18:43.670]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.670]    - tweaked: FALSE
[16:18:43.670]    - call: plan(strategy)
[16:18:43.675] plan(): nbrOfWorkers() = 2
[16:18:43.667] MulticoreFuture:
[16:18:43.667] Label: ‘future_mapply-1’
[16:18:43.667] Expression:
[16:18:43.667] {
[16:18:43.667]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.667]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.667]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.667]         on.exit(options(oopts), add = TRUE)
[16:18:43.667]     }
[16:18:43.667]     {
[16:18:43.667]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.667]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.667]         do.call(mapply, args = args)
[16:18:43.667]     }
[16:18:43.667] }
[16:18:43.667] Lazy evaluation: FALSE
[16:18:43.667] Asynchronous evaluation: TRUE
[16:18:43.667] Local evaluation: TRUE
[16:18:43.667] Environment: R_GlobalEnv
[16:18:43.667] Capture standard output: TRUE
[16:18:43.667] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.667] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.667] Packages: <none>
[16:18:43.667] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:43.667] Resolved: TRUE
[16:18:43.667] Value: <not collected>
[16:18:43.667] Conditions captured: <none>
[16:18:43.667] Early signaling: FALSE
[16:18:43.667] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.667] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.677] Chunk #1 of 2 ... DONE
[16:18:43.677] Chunk #2 of 2 ...
[16:18:43.677]  - Finding globals in '...' for chunk #2 ...
[16:18:43.677] getGlobalsAndPackages() ...
[16:18:43.677] Searching for globals...
[16:18:43.678] 
[16:18:43.678] Searching for globals ... DONE
[16:18:43.678] - globals: [0] <none>
[16:18:43.678] getGlobalsAndPackages() ... DONE
[16:18:43.678]    + additional globals found: [n=0] 
[16:18:43.678]    + additional namespaces needed: [n=0] 
[16:18:43.679]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:43.679]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:43.679]  - seeds: <none>
[16:18:43.679]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.679] getGlobalsAndPackages() ...
[16:18:43.679] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.679] Resolving globals: FALSE
[16:18:43.680] The total size of the 5 globals is 904 bytes (904 bytes)
[16:18:43.681] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:43.681] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:43.681] 
[16:18:43.681] getGlobalsAndPackages() ... DONE
[16:18:43.682] run() for ‘Future’ ...
[16:18:43.682] - state: ‘created’
[16:18:43.682] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:18:43.687] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.687] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:18:43.687]   - Field: ‘label’
[16:18:43.687]   - Field: ‘local’
[16:18:43.687]   - Field: ‘owner’
[16:18:43.688]   - Field: ‘envir’
[16:18:43.688]   - Field: ‘workers’
[16:18:43.688]   - Field: ‘packages’
[16:18:43.688]   - Field: ‘gc’
[16:18:43.688]   - Field: ‘job’
[16:18:43.688]   - Field: ‘conditions’
[16:18:43.689]   - Field: ‘expr’
[16:18:43.689]   - Field: ‘uuid’
[16:18:43.689]   - Field: ‘seed’
[16:18:43.689]   - Field: ‘version’
[16:18:43.689]   - Field: ‘result’
[16:18:43.689]   - Field: ‘asynchronous’
[16:18:43.689]   - Field: ‘calls’
[16:18:43.690]   - Field: ‘globals’
[16:18:43.690]   - Field: ‘stdout’
[16:18:43.690]   - Field: ‘earlySignal’
[16:18:43.690]   - Field: ‘lazy’
[16:18:43.690]   - Field: ‘state’
[16:18:43.690] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:18:43.691] - Launch lazy future ...
[16:18:43.691] Packages needed by the future expression (n = 0): <none>
[16:18:43.691] Packages needed by future strategies (n = 0): <none>
[16:18:43.692] {
[16:18:43.692]     {
[16:18:43.692]         {
[16:18:43.692]             ...future.startTime <- base::Sys.time()
[16:18:43.692]             {
[16:18:43.692]                 {
[16:18:43.692]                   {
[16:18:43.692]                     {
[16:18:43.692]                       base::local({
[16:18:43.692]                         has_future <- base::requireNamespace("future", 
[16:18:43.692]                           quietly = TRUE)
[16:18:43.692]                         if (has_future) {
[16:18:43.692]                           ns <- base::getNamespace("future")
[16:18:43.692]                           version <- ns[[".package"]][["version"]]
[16:18:43.692]                           if (is.null(version)) 
[16:18:43.692]                             version <- utils::packageVersion("future")
[16:18:43.692]                         }
[16:18:43.692]                         else {
[16:18:43.692]                           version <- NULL
[16:18:43.692]                         }
[16:18:43.692]                         if (!has_future || version < "1.8.0") {
[16:18:43.692]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:43.692]                             "", base::R.version$version.string), 
[16:18:43.692]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:43.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:43.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:43.692]                               "release", "version")], collapse = " "), 
[16:18:43.692]                             hostname = base::Sys.info()[["nodename"]])
[16:18:43.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:43.692]                             info)
[16:18:43.692]                           info <- base::paste(info, collapse = "; ")
[16:18:43.692]                           if (!has_future) {
[16:18:43.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:43.692]                               info)
[16:18:43.692]                           }
[16:18:43.692]                           else {
[16:18:43.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:43.692]                               info, version)
[16:18:43.692]                           }
[16:18:43.692]                           base::stop(msg)
[16:18:43.692]                         }
[16:18:43.692]                       })
[16:18:43.692]                     }
[16:18:43.692]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:43.692]                     base::options(mc.cores = 1L)
[16:18:43.692]                   }
[16:18:43.692]                   ...future.strategy.old <- future::plan("list")
[16:18:43.692]                   options(future.plan = NULL)
[16:18:43.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:43.692]                 }
[16:18:43.692]                 ...future.workdir <- getwd()
[16:18:43.692]             }
[16:18:43.692]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:43.692]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:43.692]         }
[16:18:43.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:43.692]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:43.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:43.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:43.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:43.692]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:43.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:43.692]             base::names(...future.oldOptions))
[16:18:43.692]     }
[16:18:43.692]     if (FALSE) {
[16:18:43.692]     }
[16:18:43.692]     else {
[16:18:43.692]         if (TRUE) {
[16:18:43.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:43.692]                 open = "w")
[16:18:43.692]         }
[16:18:43.692]         else {
[16:18:43.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:43.692]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:43.692]         }
[16:18:43.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:43.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:43.692]             base::sink(type = "output", split = FALSE)
[16:18:43.692]             base::close(...future.stdout)
[16:18:43.692]         }, add = TRUE)
[16:18:43.692]     }
[16:18:43.692]     ...future.frame <- base::sys.nframe()
[16:18:43.692]     ...future.conditions <- base::list()
[16:18:43.692]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:43.692]     if (FALSE) {
[16:18:43.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:43.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:43.692]     }
[16:18:43.692]     ...future.result <- base::tryCatch({
[16:18:43.692]         base::withCallingHandlers({
[16:18:43.692]             ...future.value <- base::withVisible(base::local({
[16:18:43.692]                 withCallingHandlers({
[16:18:43.692]                   {
[16:18:43.692]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.692]                     if (!identical(...future.globals.maxSize.org, 
[16:18:43.692]                       ...future.globals.maxSize)) {
[16:18:43.692]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.692]                       on.exit(options(oopts), add = TRUE)
[16:18:43.692]                     }
[16:18:43.692]                     {
[16:18:43.692]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.692]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:43.692]                         USE.NAMES = FALSE)
[16:18:43.692]                       do.call(mapply, args = args)
[16:18:43.692]                     }
[16:18:43.692]                   }
[16:18:43.692]                 }, immediateCondition = function(cond) {
[16:18:43.692]                   save_rds <- function (object, pathname, ...) 
[16:18:43.692]                   {
[16:18:43.692]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:18:43.692]                     if (file_test("-f", pathname_tmp)) {
[16:18:43.692]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.692]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:18:43.692]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.692]                         fi_tmp[["mtime"]])
[16:18:43.692]                     }
[16:18:43.692]                     tryCatch({
[16:18:43.692]                       saveRDS(object, file = pathname_tmp, ...)
[16:18:43.692]                     }, error = function(ex) {
[16:18:43.692]                       msg <- conditionMessage(ex)
[16:18:43.692]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.692]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:18:43.692]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.692]                         fi_tmp[["mtime"]], msg)
[16:18:43.692]                       ex$message <- msg
[16:18:43.692]                       stop(ex)
[16:18:43.692]                     })
[16:18:43.692]                     stopifnot(file_test("-f", pathname_tmp))
[16:18:43.692]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:18:43.692]                     if (!res || file_test("-f", pathname_tmp)) {
[16:18:43.692]                       fi_tmp <- file.info(pathname_tmp)
[16:18:43.692]                       fi <- file.info(pathname)
[16:18:43.692]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:18:43.692]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:18:43.692]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:18:43.692]                         fi[["size"]], fi[["mtime"]])
[16:18:43.692]                       stop(msg)
[16:18:43.692]                     }
[16:18:43.692]                     invisible(pathname)
[16:18:43.692]                   }
[16:18:43.692]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:18:43.692]                     rootPath = tempdir()) 
[16:18:43.692]                   {
[16:18:43.692]                     obj <- list(time = Sys.time(), condition = cond)
[16:18:43.692]                     file <- tempfile(pattern = class(cond)[1], 
[16:18:43.692]                       tmpdir = path, fileext = ".rds")
[16:18:43.692]                     save_rds(obj, file)
[16:18:43.692]                   }
[16:18:43.692]                   saveImmediateCondition(cond, path = "/tmp/RtmpE239th/.future/immediateConditions")
[16:18:43.692]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.692]                   {
[16:18:43.692]                     inherits <- base::inherits
[16:18:43.692]                     invokeRestart <- base::invokeRestart
[16:18:43.692]                     is.null <- base::is.null
[16:18:43.692]                     muffled <- FALSE
[16:18:43.692]                     if (inherits(cond, "message")) {
[16:18:43.692]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:43.692]                       if (muffled) 
[16:18:43.692]                         invokeRestart("muffleMessage")
[16:18:43.692]                     }
[16:18:43.692]                     else if (inherits(cond, "warning")) {
[16:18:43.692]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:43.692]                       if (muffled) 
[16:18:43.692]                         invokeRestart("muffleWarning")
[16:18:43.692]                     }
[16:18:43.692]                     else if (inherits(cond, "condition")) {
[16:18:43.692]                       if (!is.null(pattern)) {
[16:18:43.692]                         computeRestarts <- base::computeRestarts
[16:18:43.692]                         grepl <- base::grepl
[16:18:43.692]                         restarts <- computeRestarts(cond)
[16:18:43.692]                         for (restart in restarts) {
[16:18:43.692]                           name <- restart$name
[16:18:43.692]                           if (is.null(name)) 
[16:18:43.692]                             next
[16:18:43.692]                           if (!grepl(pattern, name)) 
[16:18:43.692]                             next
[16:18:43.692]                           invokeRestart(restart)
[16:18:43.692]                           muffled <- TRUE
[16:18:43.692]                           break
[16:18:43.692]                         }
[16:18:43.692]                       }
[16:18:43.692]                     }
[16:18:43.692]                     invisible(muffled)
[16:18:43.692]                   }
[16:18:43.692]                   muffleCondition(cond)
[16:18:43.692]                 })
[16:18:43.692]             }))
[16:18:43.692]             future::FutureResult(value = ...future.value$value, 
[16:18:43.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.692]                   ...future.rng), globalenv = if (FALSE) 
[16:18:43.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:43.692]                     ...future.globalenv.names))
[16:18:43.692]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:43.692]         }, condition = base::local({
[16:18:43.692]             c <- base::c
[16:18:43.692]             inherits <- base::inherits
[16:18:43.692]             invokeRestart <- base::invokeRestart
[16:18:43.692]             length <- base::length
[16:18:43.692]             list <- base::list
[16:18:43.692]             seq.int <- base::seq.int
[16:18:43.692]             signalCondition <- base::signalCondition
[16:18:43.692]             sys.calls <- base::sys.calls
[16:18:43.692]             `[[` <- base::`[[`
[16:18:43.692]             `+` <- base::`+`
[16:18:43.692]             `<<-` <- base::`<<-`
[16:18:43.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:43.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:43.692]                   3L)]
[16:18:43.692]             }
[16:18:43.692]             function(cond) {
[16:18:43.692]                 is_error <- inherits(cond, "error")
[16:18:43.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:43.692]                   NULL)
[16:18:43.692]                 if (is_error) {
[16:18:43.692]                   sessionInformation <- function() {
[16:18:43.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:43.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:43.692]                       search = base::search(), system = base::Sys.info())
[16:18:43.692]                   }
[16:18:43.692]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:43.692]                     cond$call), session = sessionInformation(), 
[16:18:43.692]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:43.692]                   signalCondition(cond)
[16:18:43.692]                 }
[16:18:43.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:43.692]                 "immediateCondition"))) {
[16:18:43.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:43.692]                   ...future.conditions[[length(...future.conditions) + 
[16:18:43.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:43.692]                   if (TRUE && !signal) {
[16:18:43.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.692]                     {
[16:18:43.692]                       inherits <- base::inherits
[16:18:43.692]                       invokeRestart <- base::invokeRestart
[16:18:43.692]                       is.null <- base::is.null
[16:18:43.692]                       muffled <- FALSE
[16:18:43.692]                       if (inherits(cond, "message")) {
[16:18:43.692]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.692]                         if (muffled) 
[16:18:43.692]                           invokeRestart("muffleMessage")
[16:18:43.692]                       }
[16:18:43.692]                       else if (inherits(cond, "warning")) {
[16:18:43.692]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.692]                         if (muffled) 
[16:18:43.692]                           invokeRestart("muffleWarning")
[16:18:43.692]                       }
[16:18:43.692]                       else if (inherits(cond, "condition")) {
[16:18:43.692]                         if (!is.null(pattern)) {
[16:18:43.692]                           computeRestarts <- base::computeRestarts
[16:18:43.692]                           grepl <- base::grepl
[16:18:43.692]                           restarts <- computeRestarts(cond)
[16:18:43.692]                           for (restart in restarts) {
[16:18:43.692]                             name <- restart$name
[16:18:43.692]                             if (is.null(name)) 
[16:18:43.692]                               next
[16:18:43.692]                             if (!grepl(pattern, name)) 
[16:18:43.692]                               next
[16:18:43.692]                             invokeRestart(restart)
[16:18:43.692]                             muffled <- TRUE
[16:18:43.692]                             break
[16:18:43.692]                           }
[16:18:43.692]                         }
[16:18:43.692]                       }
[16:18:43.692]                       invisible(muffled)
[16:18:43.692]                     }
[16:18:43.692]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.692]                   }
[16:18:43.692]                 }
[16:18:43.692]                 else {
[16:18:43.692]                   if (TRUE) {
[16:18:43.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:43.692]                     {
[16:18:43.692]                       inherits <- base::inherits
[16:18:43.692]                       invokeRestart <- base::invokeRestart
[16:18:43.692]                       is.null <- base::is.null
[16:18:43.692]                       muffled <- FALSE
[16:18:43.692]                       if (inherits(cond, "message")) {
[16:18:43.692]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:43.692]                         if (muffled) 
[16:18:43.692]                           invokeRestart("muffleMessage")
[16:18:43.692]                       }
[16:18:43.692]                       else if (inherits(cond, "warning")) {
[16:18:43.692]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:43.692]                         if (muffled) 
[16:18:43.692]                           invokeRestart("muffleWarning")
[16:18:43.692]                       }
[16:18:43.692]                       else if (inherits(cond, "condition")) {
[16:18:43.692]                         if (!is.null(pattern)) {
[16:18:43.692]                           computeRestarts <- base::computeRestarts
[16:18:43.692]                           grepl <- base::grepl
[16:18:43.692]                           restarts <- computeRestarts(cond)
[16:18:43.692]                           for (restart in restarts) {
[16:18:43.692]                             name <- restart$name
[16:18:43.692]                             if (is.null(name)) 
[16:18:43.692]                               next
[16:18:43.692]                             if (!grepl(pattern, name)) 
[16:18:43.692]                               next
[16:18:43.692]                             invokeRestart(restart)
[16:18:43.692]                             muffled <- TRUE
[16:18:43.692]                             break
[16:18:43.692]                           }
[16:18:43.692]                         }
[16:18:43.692]                       }
[16:18:43.692]                       invisible(muffled)
[16:18:43.692]                     }
[16:18:43.692]                     muffleCondition(cond, pattern = "^muffle")
[16:18:43.692]                   }
[16:18:43.692]                 }
[16:18:43.692]             }
[16:18:43.692]         }))
[16:18:43.692]     }, error = function(ex) {
[16:18:43.692]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:43.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:43.692]                 ...future.rng), started = ...future.startTime, 
[16:18:43.692]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:43.692]             version = "1.8"), class = "FutureResult")
[16:18:43.692]     }, finally = {
[16:18:43.692]         if (!identical(...future.workdir, getwd())) 
[16:18:43.692]             setwd(...future.workdir)
[16:18:43.692]         {
[16:18:43.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:43.692]                 ...future.oldOptions$nwarnings <- NULL
[16:18:43.692]             }
[16:18:43.692]             base::options(...future.oldOptions)
[16:18:43.692]             if (.Platform$OS.type == "windows") {
[16:18:43.692]                 old_names <- names(...future.oldEnvVars)
[16:18:43.692]                 envs <- base::Sys.getenv()
[16:18:43.692]                 names <- names(envs)
[16:18:43.692]                 common <- intersect(names, old_names)
[16:18:43.692]                 added <- setdiff(names, old_names)
[16:18:43.692]                 removed <- setdiff(old_names, names)
[16:18:43.692]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:43.692]                   envs[common]]
[16:18:43.692]                 NAMES <- toupper(changed)
[16:18:43.692]                 args <- list()
[16:18:43.692]                 for (kk in seq_along(NAMES)) {
[16:18:43.692]                   name <- changed[[kk]]
[16:18:43.692]                   NAME <- NAMES[[kk]]
[16:18:43.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.692]                     next
[16:18:43.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.692]                 }
[16:18:43.692]                 NAMES <- toupper(added)
[16:18:43.692]                 for (kk in seq_along(NAMES)) {
[16:18:43.692]                   name <- added[[kk]]
[16:18:43.692]                   NAME <- NAMES[[kk]]
[16:18:43.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.692]                     next
[16:18:43.692]                   args[[name]] <- ""
[16:18:43.692]                 }
[16:18:43.692]                 NAMES <- toupper(removed)
[16:18:43.692]                 for (kk in seq_along(NAMES)) {
[16:18:43.692]                   name <- removed[[kk]]
[16:18:43.692]                   NAME <- NAMES[[kk]]
[16:18:43.692]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:43.692]                     next
[16:18:43.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:43.692]                 }
[16:18:43.692]                 if (length(args) > 0) 
[16:18:43.692]                   base::do.call(base::Sys.setenv, args = args)
[16:18:43.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:43.692]             }
[16:18:43.692]             else {
[16:18:43.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:43.692]             }
[16:18:43.692]             {
[16:18:43.692]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:43.692]                   0L) {
[16:18:43.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:43.692]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:43.692]                   base::options(opts)
[16:18:43.692]                 }
[16:18:43.692]                 {
[16:18:43.692]                   {
[16:18:43.692]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:43.692]                     NULL
[16:18:43.692]                   }
[16:18:43.692]                   options(future.plan = NULL)
[16:18:43.692]                   if (is.na(NA_character_)) 
[16:18:43.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:43.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:43.692]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:43.692]                     .init = FALSE)
[16:18:43.692]                 }
[16:18:43.692]             }
[16:18:43.692]         }
[16:18:43.692]     })
[16:18:43.692]     if (TRUE) {
[16:18:43.692]         base::sink(type = "output", split = FALSE)
[16:18:43.692]         if (TRUE) {
[16:18:43.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:43.692]         }
[16:18:43.692]         else {
[16:18:43.692]             ...future.result["stdout"] <- base::list(NULL)
[16:18:43.692]         }
[16:18:43.692]         base::close(...future.stdout)
[16:18:43.692]         ...future.stdout <- NULL
[16:18:43.692]     }
[16:18:43.692]     ...future.result$conditions <- ...future.conditions
[16:18:43.692]     ...future.result$finished <- base::Sys.time()
[16:18:43.692]     ...future.result
[16:18:43.692] }
[16:18:43.695] assign_globals() ...
[16:18:43.695] List of 5
[16:18:43.695]  $ ...future.FUN            :function (x)  
[16:18:43.695]  $ MoreArgs                 : NULL
[16:18:43.695]  $ ...future.elements_ii    :List of 1
[16:18:43.695]   ..$ :List of 1
[16:18:43.695]   .. ..$ b: num 0
[16:18:43.695]  $ ...future.seeds_ii       : NULL
[16:18:43.695]  $ ...future.globals.maxSize: NULL
[16:18:43.695]  - attr(*, "where")=List of 5
[16:18:43.695]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:18:43.695]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:18:43.695]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:18:43.695]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:18:43.695]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:18:43.695]  - attr(*, "resolved")= logi FALSE
[16:18:43.695]  - attr(*, "total_size")= num 904
[16:18:43.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:43.695]  - attr(*, "already-done")= logi TRUE
[16:18:43.703] - copied ‘...future.FUN’ to environment
[16:18:43.703] - copied ‘MoreArgs’ to environment
[16:18:43.703] - copied ‘...future.elements_ii’ to environment
[16:18:43.703] - copied ‘...future.seeds_ii’ to environment
[16:18:43.703] - copied ‘...future.globals.maxSize’ to environment
[16:18:43.704] assign_globals() ... done
[16:18:43.704] requestCore(): workers = 2
[16:18:43.707] MulticoreFuture started
[16:18:43.707] - Launch lazy future ... done
[16:18:43.707] run() for ‘MulticoreFuture’ ... done
[16:18:43.707] Created future:
[16:18:43.708] plan(): Setting new future strategy stack:
[16:18:43.708] List of future strategies:
[16:18:43.708] 1. sequential:
[16:18:43.708]    - args: function (..., envir = parent.frame())
[16:18:43.708]    - tweaked: FALSE
[16:18:43.708]    - call: NULL
[16:18:43.709] plan(): nbrOfWorkers() = 1
[16:18:43.711] plan(): Setting new future strategy stack:
[16:18:43.711] List of future strategies:
[16:18:43.711] 1. multicore:
[16:18:43.711]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:18:43.711]    - tweaked: FALSE
[16:18:43.711]    - call: plan(strategy)
[16:18:43.716] plan(): nbrOfWorkers() = 2
[16:18:43.708] MulticoreFuture:
[16:18:43.708] Label: ‘future_mapply-2’
[16:18:43.708] Expression:
[16:18:43.708] {
[16:18:43.708]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:43.708]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:43.708]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:43.708]         on.exit(options(oopts), add = TRUE)
[16:18:43.708]     }
[16:18:43.708]     {
[16:18:43.708]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:43.708]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:43.708]         do.call(mapply, args = args)
[16:18:43.708]     }
[16:18:43.708] }
[16:18:43.708] Lazy evaluation: FALSE
[16:18:43.708] Asynchronous evaluation: TRUE
[16:18:43.708] Local evaluation: TRUE
[16:18:43.708] Environment: R_GlobalEnv
[16:18:43.708] Capture standard output: TRUE
[16:18:43.708] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:43.708] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:43.708] Packages: <none>
[16:18:43.708] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:43.708] Resolved: TRUE
[16:18:43.708] Value: <not collected>
[16:18:43.708] Conditions captured: <none>
[16:18:43.708] Early signaling: FALSE
[16:18:43.708] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:43.708] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:43.717] Chunk #2 of 2 ... DONE
[16:18:43.717] Launching 2 futures (chunks) ... DONE
[16:18:43.718] Resolving 2 futures (chunks) ...
[16:18:43.718] resolve() on list ...
[16:18:43.718]  recursive: 0
[16:18:43.718]  length: 2
[16:18:43.718] 
[16:18:43.719] Future #1
[16:18:43.719] result() for MulticoreFuture ...
[16:18:43.720] result() for MulticoreFuture ...
[16:18:43.720] result() for MulticoreFuture ... done
[16:18:43.720] result() for MulticoreFuture ... done
[16:18:43.720] result() for MulticoreFuture ...
[16:18:43.720] result() for MulticoreFuture ... done
[16:18:43.721] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:18:43.721] - nx: 2
[16:18:43.721] - relay: TRUE
[16:18:43.721] - stdout: TRUE
[16:18:43.721] - signal: TRUE
[16:18:43.721] - resignal: FALSE
[16:18:43.721] - force: TRUE
[16:18:43.721] - relayed: [n=2] FALSE, FALSE
[16:18:43.722] - queued futures: [n=2] FALSE, FALSE
[16:18:43.722]  - until=1
[16:18:43.722]  - relaying element #1
[16:18:43.722] result() for MulticoreFuture ...
[16:18:43.722] result() for MulticoreFuture ... done
[16:18:43.722] result() for MulticoreFuture ...
[16:18:43.722] result() for MulticoreFuture ... done
[16:18:43.723] result() for MulticoreFuture ...
[16:18:43.723] result() for MulticoreFuture ... done
[16:18:43.723] result() for MulticoreFuture ...
[16:18:43.723] result() for MulticoreFuture ... done
[16:18:43.723] - relayed: [n=2] TRUE, FALSE
[16:18:43.723] - queued futures: [n=2] TRUE, FALSE
[16:18:43.723] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:18:43.724]  length: 1 (resolved future 1)
[16:18:43.724] Future #2
[16:18:43.724] result() for MulticoreFuture ...
[16:18:43.725] result() for MulticoreFuture ...
[16:18:43.725] result() for MulticoreFuture ... done
[16:18:43.725] result() for MulticoreFuture ... done
[16:18:43.725] result() for MulticoreFuture ...
[16:18:43.725] result() for MulticoreFuture ... done
[16:18:43.726] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:18:43.726] - nx: 2
[16:18:43.726] - relay: TRUE
[16:18:43.726] - stdout: TRUE
[16:18:43.726] - signal: TRUE
[16:18:43.726] - resignal: FALSE
[16:18:43.727] - force: TRUE
[16:18:43.727] - relayed: [n=2] TRUE, FALSE
[16:18:43.727] - queued futures: [n=2] TRUE, FALSE
[16:18:43.727]  - until=2
[16:18:43.727]  - relaying element #2
[16:18:43.727] result() for MulticoreFuture ...
[16:18:43.728] result() for MulticoreFuture ... done
[16:18:43.728] result() for MulticoreFuture ...
[16:18:43.728] result() for MulticoreFuture ... done
[16:18:43.728] result() for MulticoreFuture ...
[16:18:43.728] result() for MulticoreFuture ... done
[16:18:43.728] result() for MulticoreFuture ...
[16:18:43.728] result() for MulticoreFuture ... done
[16:18:43.728] - relayed: [n=2] TRUE, TRUE
[16:18:43.729] - queued futures: [n=2] TRUE, TRUE
[16:18:43.729] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:18:43.729]  length: 0 (resolved future 2)
[16:18:43.729] Relaying remaining futures
[16:18:43.729] signalConditionsASAP(NULL, pos=0) ...
[16:18:43.729] - nx: 2
[16:18:43.729] - relay: TRUE
[16:18:43.729] - stdout: TRUE
[16:18:43.729] - signal: TRUE
[16:18:43.729] - resignal: FALSE
[16:18:43.730] - force: TRUE
[16:18:43.730] - relayed: [n=2] TRUE, TRUE
[16:18:43.730] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:43.730] - relayed: [n=2] TRUE, TRUE
[16:18:43.730] - queued futures: [n=2] TRUE, TRUE
[16:18:43.730] signalConditionsASAP(NULL, pos=0) ... done
[16:18:43.730] resolve() on list ... DONE
[16:18:43.730] result() for MulticoreFuture ...
[16:18:43.730] result() for MulticoreFuture ... done
[16:18:43.731] result() for MulticoreFuture ...
[16:18:43.731] result() for MulticoreFuture ... done
[16:18:43.731] result() for MulticoreFuture ...
[16:18:43.731] result() for MulticoreFuture ... done
[16:18:43.731] result() for MulticoreFuture ...
[16:18:43.731] result() for MulticoreFuture ... done
[16:18:43.731]  - Number of value chunks collected: 2
[16:18:43.731] Resolving 2 futures (chunks) ... DONE
[16:18:43.731] Reducing values from 2 chunks ...
[16:18:43.732]  - Number of values collected after concatenation: 2
[16:18:43.732]  - Number of values expected: 2
[16:18:43.732] Reducing values from 2 chunks ... DONE
[16:18:43.732] future_mapply() ... DONE
[16:18:43.732] plan(): Setting new future strategy stack:
[16:18:43.732] List of future strategies:
[16:18:43.732] 1. sequential:
[16:18:43.732]    - args: function (..., envir = parent.frame())
[16:18:43.732]    - tweaked: FALSE
[16:18:43.732]    - call: plan(sequential)
[16:18:43.733] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:18:43.733] plan(): Setting new future strategy stack:
[16:18:43.733] List of future strategies:
[16:18:43.733] 1. multisession:
[16:18:43.733]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:18:43.733]    - tweaked: FALSE
[16:18:43.733]    - call: plan(strategy)
[16:18:43.734] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:18:43.734] multisession:
[16:18:43.734] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:18:43.734] - tweaked: FALSE
[16:18:43.734] - call: plan(strategy)
[16:18:43.741] getGlobalsAndPackages() ...
[16:18:43.741] Not searching for globals
[16:18:43.741] - globals: [0] <none>
[16:18:43.741] getGlobalsAndPackages() ... DONE
[16:18:43.742] [local output] makeClusterPSOCK() ...
[16:18:43.792] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:18:43.793] [local output] Base port: 11218
[16:18:43.793] [local output] Getting setup options for 2 cluster nodes ...
[16:18:43.794] [local output]  - Node 1 of 2 ...
[16:18:43.794] [local output] localMachine=TRUE => revtunnel=FALSE

[16:18:43.795] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpE239th/worker.rank=1.parallelly.parent=73831.1206766724e9b.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpE239th/worker.rank=1.parallelly.parent=73831.1206766724e9b.pid")'’
[16:18:43.983] - Possible to infer worker's PID: TRUE
[16:18:43.983] [local output] Rscript port: 11218

[16:18:43.984] [local output]  - Node 2 of 2 ...
[16:18:43.984] [local output] localMachine=TRUE => revtunnel=FALSE

[16:18:43.985] [local output] Rscript port: 11218

[16:18:43.985] [local output] Getting setup options for 2 cluster nodes ... done
[16:18:43.985] [local output]  - Parallel setup requested for some PSOCK nodes
[16:18:43.986] [local output] Setting up PSOCK nodes in parallel
[16:18:43.986] List of 36
[16:18:43.986]  $ worker          : chr "localhost"
[16:18:43.986]   ..- attr(*, "localhost")= logi TRUE
[16:18:43.986]  $ master          : chr "localhost"
[16:18:43.986]  $ port            : int 11218
[16:18:43.986]  $ connectTimeout  : num 120
[16:18:43.986]  $ timeout         : num 2592000
[16:18:43.986]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:18:43.986]  $ homogeneous     : logi TRUE
[16:18:43.986]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:18:43.986]  $ rscript_envs    : NULL
[16:18:43.986]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:18:43.986]  $ rscript_startup : NULL
[16:18:43.986]  $ rscript_sh      : chr "sh"
[16:18:43.986]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:18:43.986]  $ methods         : logi TRUE
[16:18:43.986]  $ socketOptions   : chr "no-delay"
[16:18:43.986]  $ useXDR          : logi FALSE
[16:18:43.986]  $ outfile         : chr "/dev/null"
[16:18:43.986]  $ renice          : int NA
[16:18:43.986]  $ rshcmd          : NULL
[16:18:43.986]  $ user            : chr(0) 
[16:18:43.986]  $ revtunnel       : logi FALSE
[16:18:43.986]  $ rshlogfile      : NULL
[16:18:43.986]  $ rshopts         : chr(0) 
[16:18:43.986]  $ rank            : int 1
[16:18:43.986]  $ manual          : logi FALSE
[16:18:43.986]  $ dryrun          : logi FALSE
[16:18:43.986]  $ quiet           : logi FALSE
[16:18:43.986]  $ setup_strategy  : chr "parallel"
[16:18:43.986]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:18:43.986]  $ pidfile         : chr "/tmp/RtmpE239th/worker.rank=1.parallelly.parent=73831.1206766724e9b.pid"
[16:18:43.986]  $ rshcmd_label    : NULL
[16:18:43.986]  $ rsh_call        : NULL
[16:18:43.986]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:18:43.986]  $ localMachine    : logi TRUE
[16:18:43.986]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:18:43.986]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:18:43.986]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:18:43.986]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:18:43.986]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:18:43.986]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:18:43.986]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:18:43.986]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:18:43.986]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:18:43.986]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:18:43.986]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:18:43.986]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:18:43.986]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:18:43.986]  $ arguments       :List of 28
[16:18:43.986]   ..$ worker          : chr "localhost"
[16:18:43.986]   ..$ master          : NULL
[16:18:43.986]   ..$ port            : int 11218
[16:18:43.986]   ..$ connectTimeout  : num 120
[16:18:43.986]   ..$ timeout         : num 2592000
[16:18:43.986]   ..$ rscript         : NULL
[16:18:43.986]   ..$ homogeneous     : NULL
[16:18:43.986]   ..$ rscript_args    : NULL
[16:18:43.986]   ..$ rscript_envs    : NULL
[16:18:43.986]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:18:43.986]   ..$ rscript_startup : NULL
[16:18:43.986]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:18:43.986]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:18:43.986]   ..$ methods         : logi TRUE
[16:18:43.986]   ..$ socketOptions   : chr "no-delay"
[16:18:43.986]   ..$ useXDR          : logi FALSE
[16:18:43.986]   ..$ outfile         : chr "/dev/null"
[16:18:43.986]   ..$ renice          : int NA
[16:18:43.986]   ..$ rshcmd          : NULL
[16:18:43.986]   ..$ user            : NULL
[16:18:43.986]   ..$ revtunnel       : logi NA
[16:18:43.986]   ..$ rshlogfile      : NULL
[16:18:43.986]   ..$ rshopts         : NULL
[16:18:43.986]   ..$ rank            : int 1
[16:18:43.986]   ..$ manual          : logi FALSE
[16:18:43.986]   ..$ dryrun          : logi FALSE
[16:18:43.986]   ..$ quiet           : logi FALSE
[16:18:43.986]   ..$ setup_strategy  : chr "parallel"
[16:18:43.986]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:18:44.002] [local output] System call to launch all workers:
[16:18:44.003] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpE239th/worker.rank=1.parallelly.parent=73831.1206766724e9b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11218 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:18:44.003] [local output] Starting PSOCK main server
[16:18:44.009] [local output] Workers launched
[16:18:44.009] [local output] Waiting for workers to connect back
[16:18:44.009]  - [local output] 0 workers out of 2 ready
[16:18:44.256]  - [local output] 0 workers out of 2 ready
[16:18:44.256]  - [local output] 1 workers out of 2 ready
[16:18:44.257]  - [local output] 2 workers out of 2 ready
[16:18:44.257] [local output] Launching of workers completed
[16:18:44.257] [local output] Collecting session information from workers
[16:18:44.258] [local output]  - Worker #1 of 2
[16:18:44.258] [local output]  - Worker #2 of 2
[16:18:44.258] [local output] makeClusterPSOCK() ... done
[16:18:44.269] Packages needed by the future expression (n = 0): <none>
[16:18:44.270] Packages needed by future strategies (n = 0): <none>
[16:18:44.270] {
[16:18:44.270]     {
[16:18:44.270]         {
[16:18:44.270]             ...future.startTime <- base::Sys.time()
[16:18:44.270]             {
[16:18:44.270]                 {
[16:18:44.270]                   {
[16:18:44.270]                     {
[16:18:44.270]                       base::local({
[16:18:44.270]                         has_future <- base::requireNamespace("future", 
[16:18:44.270]                           quietly = TRUE)
[16:18:44.270]                         if (has_future) {
[16:18:44.270]                           ns <- base::getNamespace("future")
[16:18:44.270]                           version <- ns[[".package"]][["version"]]
[16:18:44.270]                           if (is.null(version)) 
[16:18:44.270]                             version <- utils::packageVersion("future")
[16:18:44.270]                         }
[16:18:44.270]                         else {
[16:18:44.270]                           version <- NULL
[16:18:44.270]                         }
[16:18:44.270]                         if (!has_future || version < "1.8.0") {
[16:18:44.270]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:44.270]                             "", base::R.version$version.string), 
[16:18:44.270]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:44.270]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:44.270]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:44.270]                               "release", "version")], collapse = " "), 
[16:18:44.270]                             hostname = base::Sys.info()[["nodename"]])
[16:18:44.270]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:44.270]                             info)
[16:18:44.270]                           info <- base::paste(info, collapse = "; ")
[16:18:44.270]                           if (!has_future) {
[16:18:44.270]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:44.270]                               info)
[16:18:44.270]                           }
[16:18:44.270]                           else {
[16:18:44.270]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:44.270]                               info, version)
[16:18:44.270]                           }
[16:18:44.270]                           base::stop(msg)
[16:18:44.270]                         }
[16:18:44.270]                       })
[16:18:44.270]                     }
[16:18:44.270]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:44.270]                     base::options(mc.cores = 1L)
[16:18:44.270]                   }
[16:18:44.270]                   ...future.strategy.old <- future::plan("list")
[16:18:44.270]                   options(future.plan = NULL)
[16:18:44.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:44.270]                 }
[16:18:44.270]                 ...future.workdir <- getwd()
[16:18:44.270]             }
[16:18:44.270]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:44.270]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:44.270]         }
[16:18:44.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:44.270]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:44.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:44.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:44.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:44.270]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:44.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:44.270]             base::names(...future.oldOptions))
[16:18:44.270]     }
[16:18:44.270]     if (FALSE) {
[16:18:44.270]     }
[16:18:44.270]     else {
[16:18:44.270]         if (TRUE) {
[16:18:44.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:44.270]                 open = "w")
[16:18:44.270]         }
[16:18:44.270]         else {
[16:18:44.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:44.270]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:44.270]         }
[16:18:44.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:44.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:44.270]             base::sink(type = "output", split = FALSE)
[16:18:44.270]             base::close(...future.stdout)
[16:18:44.270]         }, add = TRUE)
[16:18:44.270]     }
[16:18:44.270]     ...future.frame <- base::sys.nframe()
[16:18:44.270]     ...future.conditions <- base::list()
[16:18:44.270]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:44.270]     if (FALSE) {
[16:18:44.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:44.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:44.270]     }
[16:18:44.270]     ...future.result <- base::tryCatch({
[16:18:44.270]         base::withCallingHandlers({
[16:18:44.270]             ...future.value <- base::withVisible(base::local({
[16:18:44.270]                 ...future.makeSendCondition <- base::local({
[16:18:44.270]                   sendCondition <- NULL
[16:18:44.270]                   function(frame = 1L) {
[16:18:44.270]                     if (is.function(sendCondition)) 
[16:18:44.270]                       return(sendCondition)
[16:18:44.270]                     ns <- getNamespace("parallel")
[16:18:44.270]                     if (exists("sendData", mode = "function", 
[16:18:44.270]                       envir = ns)) {
[16:18:44.270]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:44.270]                         envir = ns)
[16:18:44.270]                       envir <- sys.frame(frame)
[16:18:44.270]                       master <- NULL
[16:18:44.270]                       while (!identical(envir, .GlobalEnv) && 
[16:18:44.270]                         !identical(envir, emptyenv())) {
[16:18:44.270]                         if (exists("master", mode = "list", envir = envir, 
[16:18:44.270]                           inherits = FALSE)) {
[16:18:44.270]                           master <- get("master", mode = "list", 
[16:18:44.270]                             envir = envir, inherits = FALSE)
[16:18:44.270]                           if (inherits(master, c("SOCKnode", 
[16:18:44.270]                             "SOCK0node"))) {
[16:18:44.270]                             sendCondition <<- function(cond) {
[16:18:44.270]                               data <- list(type = "VALUE", value = cond, 
[16:18:44.270]                                 success = TRUE)
[16:18:44.270]                               parallel_sendData(master, data)
[16:18:44.270]                             }
[16:18:44.270]                             return(sendCondition)
[16:18:44.270]                           }
[16:18:44.270]                         }
[16:18:44.270]                         frame <- frame + 1L
[16:18:44.270]                         envir <- sys.frame(frame)
[16:18:44.270]                       }
[16:18:44.270]                     }
[16:18:44.270]                     sendCondition <<- function(cond) NULL
[16:18:44.270]                   }
[16:18:44.270]                 })
[16:18:44.270]                 withCallingHandlers({
[16:18:44.270]                   NA
[16:18:44.270]                 }, immediateCondition = function(cond) {
[16:18:44.270]                   sendCondition <- ...future.makeSendCondition()
[16:18:44.270]                   sendCondition(cond)
[16:18:44.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.270]                   {
[16:18:44.270]                     inherits <- base::inherits
[16:18:44.270]                     invokeRestart <- base::invokeRestart
[16:18:44.270]                     is.null <- base::is.null
[16:18:44.270]                     muffled <- FALSE
[16:18:44.270]                     if (inherits(cond, "message")) {
[16:18:44.270]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:44.270]                       if (muffled) 
[16:18:44.270]                         invokeRestart("muffleMessage")
[16:18:44.270]                     }
[16:18:44.270]                     else if (inherits(cond, "warning")) {
[16:18:44.270]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:44.270]                       if (muffled) 
[16:18:44.270]                         invokeRestart("muffleWarning")
[16:18:44.270]                     }
[16:18:44.270]                     else if (inherits(cond, "condition")) {
[16:18:44.270]                       if (!is.null(pattern)) {
[16:18:44.270]                         computeRestarts <- base::computeRestarts
[16:18:44.270]                         grepl <- base::grepl
[16:18:44.270]                         restarts <- computeRestarts(cond)
[16:18:44.270]                         for (restart in restarts) {
[16:18:44.270]                           name <- restart$name
[16:18:44.270]                           if (is.null(name)) 
[16:18:44.270]                             next
[16:18:44.270]                           if (!grepl(pattern, name)) 
[16:18:44.270]                             next
[16:18:44.270]                           invokeRestart(restart)
[16:18:44.270]                           muffled <- TRUE
[16:18:44.270]                           break
[16:18:44.270]                         }
[16:18:44.270]                       }
[16:18:44.270]                     }
[16:18:44.270]                     invisible(muffled)
[16:18:44.270]                   }
[16:18:44.270]                   muffleCondition(cond)
[16:18:44.270]                 })
[16:18:44.270]             }))
[16:18:44.270]             future::FutureResult(value = ...future.value$value, 
[16:18:44.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.270]                   ...future.rng), globalenv = if (FALSE) 
[16:18:44.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:44.270]                     ...future.globalenv.names))
[16:18:44.270]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:44.270]         }, condition = base::local({
[16:18:44.270]             c <- base::c
[16:18:44.270]             inherits <- base::inherits
[16:18:44.270]             invokeRestart <- base::invokeRestart
[16:18:44.270]             length <- base::length
[16:18:44.270]             list <- base::list
[16:18:44.270]             seq.int <- base::seq.int
[16:18:44.270]             signalCondition <- base::signalCondition
[16:18:44.270]             sys.calls <- base::sys.calls
[16:18:44.270]             `[[` <- base::`[[`
[16:18:44.270]             `+` <- base::`+`
[16:18:44.270]             `<<-` <- base::`<<-`
[16:18:44.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:44.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:44.270]                   3L)]
[16:18:44.270]             }
[16:18:44.270]             function(cond) {
[16:18:44.270]                 is_error <- inherits(cond, "error")
[16:18:44.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:44.270]                   NULL)
[16:18:44.270]                 if (is_error) {
[16:18:44.270]                   sessionInformation <- function() {
[16:18:44.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:44.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:44.270]                       search = base::search(), system = base::Sys.info())
[16:18:44.270]                   }
[16:18:44.270]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:44.270]                     cond$call), session = sessionInformation(), 
[16:18:44.270]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:44.270]                   signalCondition(cond)
[16:18:44.270]                 }
[16:18:44.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:44.270]                 "immediateCondition"))) {
[16:18:44.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:44.270]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:44.270]                   if (TRUE && !signal) {
[16:18:44.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.270]                     {
[16:18:44.270]                       inherits <- base::inherits
[16:18:44.270]                       invokeRestart <- base::invokeRestart
[16:18:44.270]                       is.null <- base::is.null
[16:18:44.270]                       muffled <- FALSE
[16:18:44.270]                       if (inherits(cond, "message")) {
[16:18:44.270]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.270]                         if (muffled) 
[16:18:44.270]                           invokeRestart("muffleMessage")
[16:18:44.270]                       }
[16:18:44.270]                       else if (inherits(cond, "warning")) {
[16:18:44.270]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.270]                         if (muffled) 
[16:18:44.270]                           invokeRestart("muffleWarning")
[16:18:44.270]                       }
[16:18:44.270]                       else if (inherits(cond, "condition")) {
[16:18:44.270]                         if (!is.null(pattern)) {
[16:18:44.270]                           computeRestarts <- base::computeRestarts
[16:18:44.270]                           grepl <- base::grepl
[16:18:44.270]                           restarts <- computeRestarts(cond)
[16:18:44.270]                           for (restart in restarts) {
[16:18:44.270]                             name <- restart$name
[16:18:44.270]                             if (is.null(name)) 
[16:18:44.270]                               next
[16:18:44.270]                             if (!grepl(pattern, name)) 
[16:18:44.270]                               next
[16:18:44.270]                             invokeRestart(restart)
[16:18:44.270]                             muffled <- TRUE
[16:18:44.270]                             break
[16:18:44.270]                           }
[16:18:44.270]                         }
[16:18:44.270]                       }
[16:18:44.270]                       invisible(muffled)
[16:18:44.270]                     }
[16:18:44.270]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.270]                   }
[16:18:44.270]                 }
[16:18:44.270]                 else {
[16:18:44.270]                   if (TRUE) {
[16:18:44.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.270]                     {
[16:18:44.270]                       inherits <- base::inherits
[16:18:44.270]                       invokeRestart <- base::invokeRestart
[16:18:44.270]                       is.null <- base::is.null
[16:18:44.270]                       muffled <- FALSE
[16:18:44.270]                       if (inherits(cond, "message")) {
[16:18:44.270]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.270]                         if (muffled) 
[16:18:44.270]                           invokeRestart("muffleMessage")
[16:18:44.270]                       }
[16:18:44.270]                       else if (inherits(cond, "warning")) {
[16:18:44.270]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.270]                         if (muffled) 
[16:18:44.270]                           invokeRestart("muffleWarning")
[16:18:44.270]                       }
[16:18:44.270]                       else if (inherits(cond, "condition")) {
[16:18:44.270]                         if (!is.null(pattern)) {
[16:18:44.270]                           computeRestarts <- base::computeRestarts
[16:18:44.270]                           grepl <- base::grepl
[16:18:44.270]                           restarts <- computeRestarts(cond)
[16:18:44.270]                           for (restart in restarts) {
[16:18:44.270]                             name <- restart$name
[16:18:44.270]                             if (is.null(name)) 
[16:18:44.270]                               next
[16:18:44.270]                             if (!grepl(pattern, name)) 
[16:18:44.270]                               next
[16:18:44.270]                             invokeRestart(restart)
[16:18:44.270]                             muffled <- TRUE
[16:18:44.270]                             break
[16:18:44.270]                           }
[16:18:44.270]                         }
[16:18:44.270]                       }
[16:18:44.270]                       invisible(muffled)
[16:18:44.270]                     }
[16:18:44.270]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.270]                   }
[16:18:44.270]                 }
[16:18:44.270]             }
[16:18:44.270]         }))
[16:18:44.270]     }, error = function(ex) {
[16:18:44.270]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:44.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.270]                 ...future.rng), started = ...future.startTime, 
[16:18:44.270]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:44.270]             version = "1.8"), class = "FutureResult")
[16:18:44.270]     }, finally = {
[16:18:44.270]         if (!identical(...future.workdir, getwd())) 
[16:18:44.270]             setwd(...future.workdir)
[16:18:44.270]         {
[16:18:44.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:44.270]                 ...future.oldOptions$nwarnings <- NULL
[16:18:44.270]             }
[16:18:44.270]             base::options(...future.oldOptions)
[16:18:44.270]             if (.Platform$OS.type == "windows") {
[16:18:44.270]                 old_names <- names(...future.oldEnvVars)
[16:18:44.270]                 envs <- base::Sys.getenv()
[16:18:44.270]                 names <- names(envs)
[16:18:44.270]                 common <- intersect(names, old_names)
[16:18:44.270]                 added <- setdiff(names, old_names)
[16:18:44.270]                 removed <- setdiff(old_names, names)
[16:18:44.270]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:44.270]                   envs[common]]
[16:18:44.270]                 NAMES <- toupper(changed)
[16:18:44.270]                 args <- list()
[16:18:44.270]                 for (kk in seq_along(NAMES)) {
[16:18:44.270]                   name <- changed[[kk]]
[16:18:44.270]                   NAME <- NAMES[[kk]]
[16:18:44.270]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.270]                     next
[16:18:44.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.270]                 }
[16:18:44.270]                 NAMES <- toupper(added)
[16:18:44.270]                 for (kk in seq_along(NAMES)) {
[16:18:44.270]                   name <- added[[kk]]
[16:18:44.270]                   NAME <- NAMES[[kk]]
[16:18:44.270]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.270]                     next
[16:18:44.270]                   args[[name]] <- ""
[16:18:44.270]                 }
[16:18:44.270]                 NAMES <- toupper(removed)
[16:18:44.270]                 for (kk in seq_along(NAMES)) {
[16:18:44.270]                   name <- removed[[kk]]
[16:18:44.270]                   NAME <- NAMES[[kk]]
[16:18:44.270]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.270]                     next
[16:18:44.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.270]                 }
[16:18:44.270]                 if (length(args) > 0) 
[16:18:44.270]                   base::do.call(base::Sys.setenv, args = args)
[16:18:44.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:44.270]             }
[16:18:44.270]             else {
[16:18:44.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:44.270]             }
[16:18:44.270]             {
[16:18:44.270]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:44.270]                   0L) {
[16:18:44.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:44.270]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:44.270]                   base::options(opts)
[16:18:44.270]                 }
[16:18:44.270]                 {
[16:18:44.270]                   {
[16:18:44.270]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:44.270]                     NULL
[16:18:44.270]                   }
[16:18:44.270]                   options(future.plan = NULL)
[16:18:44.270]                   if (is.na(NA_character_)) 
[16:18:44.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:44.270]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:44.270]                     .init = FALSE)
[16:18:44.270]                 }
[16:18:44.270]             }
[16:18:44.270]         }
[16:18:44.270]     })
[16:18:44.270]     if (TRUE) {
[16:18:44.270]         base::sink(type = "output", split = FALSE)
[16:18:44.270]         if (TRUE) {
[16:18:44.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:44.270]         }
[16:18:44.270]         else {
[16:18:44.270]             ...future.result["stdout"] <- base::list(NULL)
[16:18:44.270]         }
[16:18:44.270]         base::close(...future.stdout)
[16:18:44.270]         ...future.stdout <- NULL
[16:18:44.270]     }
[16:18:44.270]     ...future.result$conditions <- ...future.conditions
[16:18:44.270]     ...future.result$finished <- base::Sys.time()
[16:18:44.270]     ...future.result
[16:18:44.270] }
[16:18:44.324] MultisessionFuture started
[16:18:44.324] result() for ClusterFuture ...
[16:18:44.325] receiveMessageFromWorker() for ClusterFuture ...
[16:18:44.325] - Validating connection of MultisessionFuture
[16:18:44.358] - received message: FutureResult
[16:18:44.358] - Received FutureResult
[16:18:44.358] - Erased future from FutureRegistry
[16:18:44.359] result() for ClusterFuture ...
[16:18:44.359] - result already collected: FutureResult
[16:18:44.359] result() for ClusterFuture ... done
[16:18:44.359] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:44.359] result() for ClusterFuture ... done
[16:18:44.359] result() for ClusterFuture ...
[16:18:44.359] - result already collected: FutureResult
[16:18:44.359] result() for ClusterFuture ... done
[16:18:44.359] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:18:44.363] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[16:18:44.363] future_mapply() ...
[16:18:44.367] Number of chunks: 2
[16:18:44.367] getGlobalsAndPackagesXApply() ...
[16:18:44.367]  - future.globals: TRUE
[16:18:44.367] getGlobalsAndPackages() ...
[16:18:44.367] Searching for globals...
[16:18:44.368] - globals found: [1] ‘FUN’
[16:18:44.368] Searching for globals ... DONE
[16:18:44.368] Resolving globals: FALSE
[16:18:44.368] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:44.369] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:44.369] - globals: [1] ‘FUN’
[16:18:44.369] 
[16:18:44.369] getGlobalsAndPackages() ... DONE
[16:18:44.369]  - globals found/used: [n=1] ‘FUN’
[16:18:44.369]  - needed namespaces: [n=0] 
[16:18:44.369] Finding globals ... DONE
[16:18:44.369] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:44.370] List of 2
[16:18:44.370]  $ ...future.FUN:function (x, ...)  
[16:18:44.370]  $ MoreArgs     : NULL
[16:18:44.370]  - attr(*, "where")=List of 2
[16:18:44.370]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:44.370]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:44.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:44.370]  - attr(*, "resolved")= logi FALSE
[16:18:44.370]  - attr(*, "total_size")= num NA
[16:18:44.372] Packages to be attached in all futures: [n=0] 
[16:18:44.372] getGlobalsAndPackagesXApply() ... DONE
[16:18:44.372] Number of futures (= number of chunks): 2
[16:18:44.373] Launching 2 futures (chunks) ...
[16:18:44.373] Chunk #1 of 2 ...
[16:18:44.373]  - Finding globals in '...' for chunk #1 ...
[16:18:44.373] getGlobalsAndPackages() ...
[16:18:44.373] Searching for globals...
[16:18:44.373] 
[16:18:44.373] Searching for globals ... DONE
[16:18:44.373] - globals: [0] <none>
[16:18:44.374] getGlobalsAndPackages() ... DONE
[16:18:44.374]    + additional globals found: [n=0] 
[16:18:44.374]    + additional namespaces needed: [n=0] 
[16:18:44.374]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:44.374]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:44.374]  - seeds: <none>
[16:18:44.374]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.374] getGlobalsAndPackages() ...
[16:18:44.374] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.374] Resolving globals: FALSE
[16:18:44.375] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:44.375] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:44.375] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.376] 
[16:18:44.376] getGlobalsAndPackages() ... DONE
[16:18:44.376] run() for ‘Future’ ...
[16:18:44.376] - state: ‘created’
[16:18:44.376] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:44.390] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.390] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:44.390]   - Field: ‘node’
[16:18:44.390]   - Field: ‘label’
[16:18:44.390]   - Field: ‘local’
[16:18:44.390]   - Field: ‘owner’
[16:18:44.390]   - Field: ‘envir’
[16:18:44.390]   - Field: ‘workers’
[16:18:44.390]   - Field: ‘packages’
[16:18:44.391]   - Field: ‘gc’
[16:18:44.391]   - Field: ‘conditions’
[16:18:44.391]   - Field: ‘persistent’
[16:18:44.391]   - Field: ‘expr’
[16:18:44.391]   - Field: ‘uuid’
[16:18:44.391]   - Field: ‘seed’
[16:18:44.391]   - Field: ‘version’
[16:18:44.391]   - Field: ‘result’
[16:18:44.391]   - Field: ‘asynchronous’
[16:18:44.391]   - Field: ‘calls’
[16:18:44.391]   - Field: ‘globals’
[16:18:44.392]   - Field: ‘stdout’
[16:18:44.392]   - Field: ‘earlySignal’
[16:18:44.392]   - Field: ‘lazy’
[16:18:44.392]   - Field: ‘state’
[16:18:44.392] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:44.392] - Launch lazy future ...
[16:18:44.392] Packages needed by the future expression (n = 0): <none>
[16:18:44.392] Packages needed by future strategies (n = 0): <none>
[16:18:44.393] {
[16:18:44.393]     {
[16:18:44.393]         {
[16:18:44.393]             ...future.startTime <- base::Sys.time()
[16:18:44.393]             {
[16:18:44.393]                 {
[16:18:44.393]                   {
[16:18:44.393]                     {
[16:18:44.393]                       base::local({
[16:18:44.393]                         has_future <- base::requireNamespace("future", 
[16:18:44.393]                           quietly = TRUE)
[16:18:44.393]                         if (has_future) {
[16:18:44.393]                           ns <- base::getNamespace("future")
[16:18:44.393]                           version <- ns[[".package"]][["version"]]
[16:18:44.393]                           if (is.null(version)) 
[16:18:44.393]                             version <- utils::packageVersion("future")
[16:18:44.393]                         }
[16:18:44.393]                         else {
[16:18:44.393]                           version <- NULL
[16:18:44.393]                         }
[16:18:44.393]                         if (!has_future || version < "1.8.0") {
[16:18:44.393]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:44.393]                             "", base::R.version$version.string), 
[16:18:44.393]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:44.393]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:44.393]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:44.393]                               "release", "version")], collapse = " "), 
[16:18:44.393]                             hostname = base::Sys.info()[["nodename"]])
[16:18:44.393]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:44.393]                             info)
[16:18:44.393]                           info <- base::paste(info, collapse = "; ")
[16:18:44.393]                           if (!has_future) {
[16:18:44.393]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:44.393]                               info)
[16:18:44.393]                           }
[16:18:44.393]                           else {
[16:18:44.393]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:44.393]                               info, version)
[16:18:44.393]                           }
[16:18:44.393]                           base::stop(msg)
[16:18:44.393]                         }
[16:18:44.393]                       })
[16:18:44.393]                     }
[16:18:44.393]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:44.393]                     base::options(mc.cores = 1L)
[16:18:44.393]                   }
[16:18:44.393]                   ...future.strategy.old <- future::plan("list")
[16:18:44.393]                   options(future.plan = NULL)
[16:18:44.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:44.393]                 }
[16:18:44.393]                 ...future.workdir <- getwd()
[16:18:44.393]             }
[16:18:44.393]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:44.393]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:44.393]         }
[16:18:44.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:44.393]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:44.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:44.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:44.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:44.393]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:44.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:44.393]             base::names(...future.oldOptions))
[16:18:44.393]     }
[16:18:44.393]     if (FALSE) {
[16:18:44.393]     }
[16:18:44.393]     else {
[16:18:44.393]         if (TRUE) {
[16:18:44.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:44.393]                 open = "w")
[16:18:44.393]         }
[16:18:44.393]         else {
[16:18:44.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:44.393]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:44.393]         }
[16:18:44.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:44.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:44.393]             base::sink(type = "output", split = FALSE)
[16:18:44.393]             base::close(...future.stdout)
[16:18:44.393]         }, add = TRUE)
[16:18:44.393]     }
[16:18:44.393]     ...future.frame <- base::sys.nframe()
[16:18:44.393]     ...future.conditions <- base::list()
[16:18:44.393]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:44.393]     if (FALSE) {
[16:18:44.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:44.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:44.393]     }
[16:18:44.393]     ...future.result <- base::tryCatch({
[16:18:44.393]         base::withCallingHandlers({
[16:18:44.393]             ...future.value <- base::withVisible(base::local({
[16:18:44.393]                 ...future.makeSendCondition <- base::local({
[16:18:44.393]                   sendCondition <- NULL
[16:18:44.393]                   function(frame = 1L) {
[16:18:44.393]                     if (is.function(sendCondition)) 
[16:18:44.393]                       return(sendCondition)
[16:18:44.393]                     ns <- getNamespace("parallel")
[16:18:44.393]                     if (exists("sendData", mode = "function", 
[16:18:44.393]                       envir = ns)) {
[16:18:44.393]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:44.393]                         envir = ns)
[16:18:44.393]                       envir <- sys.frame(frame)
[16:18:44.393]                       master <- NULL
[16:18:44.393]                       while (!identical(envir, .GlobalEnv) && 
[16:18:44.393]                         !identical(envir, emptyenv())) {
[16:18:44.393]                         if (exists("master", mode = "list", envir = envir, 
[16:18:44.393]                           inherits = FALSE)) {
[16:18:44.393]                           master <- get("master", mode = "list", 
[16:18:44.393]                             envir = envir, inherits = FALSE)
[16:18:44.393]                           if (inherits(master, c("SOCKnode", 
[16:18:44.393]                             "SOCK0node"))) {
[16:18:44.393]                             sendCondition <<- function(cond) {
[16:18:44.393]                               data <- list(type = "VALUE", value = cond, 
[16:18:44.393]                                 success = TRUE)
[16:18:44.393]                               parallel_sendData(master, data)
[16:18:44.393]                             }
[16:18:44.393]                             return(sendCondition)
[16:18:44.393]                           }
[16:18:44.393]                         }
[16:18:44.393]                         frame <- frame + 1L
[16:18:44.393]                         envir <- sys.frame(frame)
[16:18:44.393]                       }
[16:18:44.393]                     }
[16:18:44.393]                     sendCondition <<- function(cond) NULL
[16:18:44.393]                   }
[16:18:44.393]                 })
[16:18:44.393]                 withCallingHandlers({
[16:18:44.393]                   {
[16:18:44.393]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.393]                     if (!identical(...future.globals.maxSize.org, 
[16:18:44.393]                       ...future.globals.maxSize)) {
[16:18:44.393]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.393]                       on.exit(options(oopts), add = TRUE)
[16:18:44.393]                     }
[16:18:44.393]                     {
[16:18:44.393]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.393]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:44.393]                         USE.NAMES = FALSE)
[16:18:44.393]                       do.call(mapply, args = args)
[16:18:44.393]                     }
[16:18:44.393]                   }
[16:18:44.393]                 }, immediateCondition = function(cond) {
[16:18:44.393]                   sendCondition <- ...future.makeSendCondition()
[16:18:44.393]                   sendCondition(cond)
[16:18:44.393]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.393]                   {
[16:18:44.393]                     inherits <- base::inherits
[16:18:44.393]                     invokeRestart <- base::invokeRestart
[16:18:44.393]                     is.null <- base::is.null
[16:18:44.393]                     muffled <- FALSE
[16:18:44.393]                     if (inherits(cond, "message")) {
[16:18:44.393]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:44.393]                       if (muffled) 
[16:18:44.393]                         invokeRestart("muffleMessage")
[16:18:44.393]                     }
[16:18:44.393]                     else if (inherits(cond, "warning")) {
[16:18:44.393]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:44.393]                       if (muffled) 
[16:18:44.393]                         invokeRestart("muffleWarning")
[16:18:44.393]                     }
[16:18:44.393]                     else if (inherits(cond, "condition")) {
[16:18:44.393]                       if (!is.null(pattern)) {
[16:18:44.393]                         computeRestarts <- base::computeRestarts
[16:18:44.393]                         grepl <- base::grepl
[16:18:44.393]                         restarts <- computeRestarts(cond)
[16:18:44.393]                         for (restart in restarts) {
[16:18:44.393]                           name <- restart$name
[16:18:44.393]                           if (is.null(name)) 
[16:18:44.393]                             next
[16:18:44.393]                           if (!grepl(pattern, name)) 
[16:18:44.393]                             next
[16:18:44.393]                           invokeRestart(restart)
[16:18:44.393]                           muffled <- TRUE
[16:18:44.393]                           break
[16:18:44.393]                         }
[16:18:44.393]                       }
[16:18:44.393]                     }
[16:18:44.393]                     invisible(muffled)
[16:18:44.393]                   }
[16:18:44.393]                   muffleCondition(cond)
[16:18:44.393]                 })
[16:18:44.393]             }))
[16:18:44.393]             future::FutureResult(value = ...future.value$value, 
[16:18:44.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.393]                   ...future.rng), globalenv = if (FALSE) 
[16:18:44.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:44.393]                     ...future.globalenv.names))
[16:18:44.393]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:44.393]         }, condition = base::local({
[16:18:44.393]             c <- base::c
[16:18:44.393]             inherits <- base::inherits
[16:18:44.393]             invokeRestart <- base::invokeRestart
[16:18:44.393]             length <- base::length
[16:18:44.393]             list <- base::list
[16:18:44.393]             seq.int <- base::seq.int
[16:18:44.393]             signalCondition <- base::signalCondition
[16:18:44.393]             sys.calls <- base::sys.calls
[16:18:44.393]             `[[` <- base::`[[`
[16:18:44.393]             `+` <- base::`+`
[16:18:44.393]             `<<-` <- base::`<<-`
[16:18:44.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:44.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:44.393]                   3L)]
[16:18:44.393]             }
[16:18:44.393]             function(cond) {
[16:18:44.393]                 is_error <- inherits(cond, "error")
[16:18:44.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:44.393]                   NULL)
[16:18:44.393]                 if (is_error) {
[16:18:44.393]                   sessionInformation <- function() {
[16:18:44.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:44.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:44.393]                       search = base::search(), system = base::Sys.info())
[16:18:44.393]                   }
[16:18:44.393]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:44.393]                     cond$call), session = sessionInformation(), 
[16:18:44.393]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:44.393]                   signalCondition(cond)
[16:18:44.393]                 }
[16:18:44.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:44.393]                 "immediateCondition"))) {
[16:18:44.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:44.393]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:44.393]                   if (TRUE && !signal) {
[16:18:44.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.393]                     {
[16:18:44.393]                       inherits <- base::inherits
[16:18:44.393]                       invokeRestart <- base::invokeRestart
[16:18:44.393]                       is.null <- base::is.null
[16:18:44.393]                       muffled <- FALSE
[16:18:44.393]                       if (inherits(cond, "message")) {
[16:18:44.393]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.393]                         if (muffled) 
[16:18:44.393]                           invokeRestart("muffleMessage")
[16:18:44.393]                       }
[16:18:44.393]                       else if (inherits(cond, "warning")) {
[16:18:44.393]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.393]                         if (muffled) 
[16:18:44.393]                           invokeRestart("muffleWarning")
[16:18:44.393]                       }
[16:18:44.393]                       else if (inherits(cond, "condition")) {
[16:18:44.393]                         if (!is.null(pattern)) {
[16:18:44.393]                           computeRestarts <- base::computeRestarts
[16:18:44.393]                           grepl <- base::grepl
[16:18:44.393]                           restarts <- computeRestarts(cond)
[16:18:44.393]                           for (restart in restarts) {
[16:18:44.393]                             name <- restart$name
[16:18:44.393]                             if (is.null(name)) 
[16:18:44.393]                               next
[16:18:44.393]                             if (!grepl(pattern, name)) 
[16:18:44.393]                               next
[16:18:44.393]                             invokeRestart(restart)
[16:18:44.393]                             muffled <- TRUE
[16:18:44.393]                             break
[16:18:44.393]                           }
[16:18:44.393]                         }
[16:18:44.393]                       }
[16:18:44.393]                       invisible(muffled)
[16:18:44.393]                     }
[16:18:44.393]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.393]                   }
[16:18:44.393]                 }
[16:18:44.393]                 else {
[16:18:44.393]                   if (TRUE) {
[16:18:44.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.393]                     {
[16:18:44.393]                       inherits <- base::inherits
[16:18:44.393]                       invokeRestart <- base::invokeRestart
[16:18:44.393]                       is.null <- base::is.null
[16:18:44.393]                       muffled <- FALSE
[16:18:44.393]                       if (inherits(cond, "message")) {
[16:18:44.393]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.393]                         if (muffled) 
[16:18:44.393]                           invokeRestart("muffleMessage")
[16:18:44.393]                       }
[16:18:44.393]                       else if (inherits(cond, "warning")) {
[16:18:44.393]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.393]                         if (muffled) 
[16:18:44.393]                           invokeRestart("muffleWarning")
[16:18:44.393]                       }
[16:18:44.393]                       else if (inherits(cond, "condition")) {
[16:18:44.393]                         if (!is.null(pattern)) {
[16:18:44.393]                           computeRestarts <- base::computeRestarts
[16:18:44.393]                           grepl <- base::grepl
[16:18:44.393]                           restarts <- computeRestarts(cond)
[16:18:44.393]                           for (restart in restarts) {
[16:18:44.393]                             name <- restart$name
[16:18:44.393]                             if (is.null(name)) 
[16:18:44.393]                               next
[16:18:44.393]                             if (!grepl(pattern, name)) 
[16:18:44.393]                               next
[16:18:44.393]                             invokeRestart(restart)
[16:18:44.393]                             muffled <- TRUE
[16:18:44.393]                             break
[16:18:44.393]                           }
[16:18:44.393]                         }
[16:18:44.393]                       }
[16:18:44.393]                       invisible(muffled)
[16:18:44.393]                     }
[16:18:44.393]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.393]                   }
[16:18:44.393]                 }
[16:18:44.393]             }
[16:18:44.393]         }))
[16:18:44.393]     }, error = function(ex) {
[16:18:44.393]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:44.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.393]                 ...future.rng), started = ...future.startTime, 
[16:18:44.393]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:44.393]             version = "1.8"), class = "FutureResult")
[16:18:44.393]     }, finally = {
[16:18:44.393]         if (!identical(...future.workdir, getwd())) 
[16:18:44.393]             setwd(...future.workdir)
[16:18:44.393]         {
[16:18:44.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:44.393]                 ...future.oldOptions$nwarnings <- NULL
[16:18:44.393]             }
[16:18:44.393]             base::options(...future.oldOptions)
[16:18:44.393]             if (.Platform$OS.type == "windows") {
[16:18:44.393]                 old_names <- names(...future.oldEnvVars)
[16:18:44.393]                 envs <- base::Sys.getenv()
[16:18:44.393]                 names <- names(envs)
[16:18:44.393]                 common <- intersect(names, old_names)
[16:18:44.393]                 added <- setdiff(names, old_names)
[16:18:44.393]                 removed <- setdiff(old_names, names)
[16:18:44.393]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:44.393]                   envs[common]]
[16:18:44.393]                 NAMES <- toupper(changed)
[16:18:44.393]                 args <- list()
[16:18:44.393]                 for (kk in seq_along(NAMES)) {
[16:18:44.393]                   name <- changed[[kk]]
[16:18:44.393]                   NAME <- NAMES[[kk]]
[16:18:44.393]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.393]                     next
[16:18:44.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.393]                 }
[16:18:44.393]                 NAMES <- toupper(added)
[16:18:44.393]                 for (kk in seq_along(NAMES)) {
[16:18:44.393]                   name <- added[[kk]]
[16:18:44.393]                   NAME <- NAMES[[kk]]
[16:18:44.393]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.393]                     next
[16:18:44.393]                   args[[name]] <- ""
[16:18:44.393]                 }
[16:18:44.393]                 NAMES <- toupper(removed)
[16:18:44.393]                 for (kk in seq_along(NAMES)) {
[16:18:44.393]                   name <- removed[[kk]]
[16:18:44.393]                   NAME <- NAMES[[kk]]
[16:18:44.393]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.393]                     next
[16:18:44.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.393]                 }
[16:18:44.393]                 if (length(args) > 0) 
[16:18:44.393]                   base::do.call(base::Sys.setenv, args = args)
[16:18:44.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:44.393]             }
[16:18:44.393]             else {
[16:18:44.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:44.393]             }
[16:18:44.393]             {
[16:18:44.393]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:44.393]                   0L) {
[16:18:44.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:44.393]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:44.393]                   base::options(opts)
[16:18:44.393]                 }
[16:18:44.393]                 {
[16:18:44.393]                   {
[16:18:44.393]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:44.393]                     NULL
[16:18:44.393]                   }
[16:18:44.393]                   options(future.plan = NULL)
[16:18:44.393]                   if (is.na(NA_character_)) 
[16:18:44.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:44.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:44.393]                     .init = FALSE)
[16:18:44.393]                 }
[16:18:44.393]             }
[16:18:44.393]         }
[16:18:44.393]     })
[16:18:44.393]     if (TRUE) {
[16:18:44.393]         base::sink(type = "output", split = FALSE)
[16:18:44.393]         if (TRUE) {
[16:18:44.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:44.393]         }
[16:18:44.393]         else {
[16:18:44.393]             ...future.result["stdout"] <- base::list(NULL)
[16:18:44.393]         }
[16:18:44.393]         base::close(...future.stdout)
[16:18:44.393]         ...future.stdout <- NULL
[16:18:44.393]     }
[16:18:44.393]     ...future.result$conditions <- ...future.conditions
[16:18:44.393]     ...future.result$finished <- base::Sys.time()
[16:18:44.393]     ...future.result
[16:18:44.393] }
[16:18:44.396] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[16:18:44.396] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[16:18:44.396] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[16:18:44.396] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:44.397] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.397] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[16:18:44.397] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[16:18:44.397] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:44.398] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.398] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:44.398] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.399] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[16:18:44.399] MultisessionFuture started
[16:18:44.399] - Launch lazy future ... done
[16:18:44.399] run() for ‘MultisessionFuture’ ... done
[16:18:44.400] Created future:
[16:18:44.400] MultisessionFuture:
[16:18:44.400] Label: ‘future_mapply-1’
[16:18:44.400] Expression:
[16:18:44.400] {
[16:18:44.400]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.400]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:44.400]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.400]         on.exit(options(oopts), add = TRUE)
[16:18:44.400]     }
[16:18:44.400]     {
[16:18:44.400]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.400]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:44.400]         do.call(mapply, args = args)
[16:18:44.400]     }
[16:18:44.400] }
[16:18:44.400] Lazy evaluation: FALSE
[16:18:44.400] Asynchronous evaluation: TRUE
[16:18:44.400] Local evaluation: TRUE
[16:18:44.400] Environment: R_GlobalEnv
[16:18:44.400] Capture standard output: TRUE
[16:18:44.400] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:44.400] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:44.400] Packages: <none>
[16:18:44.400] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:44.400] Resolved: FALSE
[16:18:44.400] Value: <not collected>
[16:18:44.400] Conditions captured: <none>
[16:18:44.400] Early signaling: FALSE
[16:18:44.400] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:44.400] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.411] Chunk #1 of 2 ... DONE
[16:18:44.412] Chunk #2 of 2 ...
[16:18:44.412]  - Finding globals in '...' for chunk #2 ...
[16:18:44.412] getGlobalsAndPackages() ...
[16:18:44.412] Searching for globals...
[16:18:44.412] 
[16:18:44.412] Searching for globals ... DONE
[16:18:44.413] - globals: [0] <none>
[16:18:44.413] getGlobalsAndPackages() ... DONE
[16:18:44.413]    + additional globals found: [n=0] 
[16:18:44.413]    + additional namespaces needed: [n=0] 
[16:18:44.413]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:44.413]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:44.413]  - seeds: <none>
[16:18:44.413]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.413] getGlobalsAndPackages() ...
[16:18:44.413] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.414] Resolving globals: FALSE
[16:18:44.414] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:44.414] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:44.415] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.415] 
[16:18:44.415] getGlobalsAndPackages() ... DONE
[16:18:44.415] run() for ‘Future’ ...
[16:18:44.415] - state: ‘created’
[16:18:44.415] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:44.429] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.430] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:44.430]   - Field: ‘node’
[16:18:44.430]   - Field: ‘label’
[16:18:44.430]   - Field: ‘local’
[16:18:44.430]   - Field: ‘owner’
[16:18:44.430]   - Field: ‘envir’
[16:18:44.430]   - Field: ‘workers’
[16:18:44.430]   - Field: ‘packages’
[16:18:44.430]   - Field: ‘gc’
[16:18:44.430]   - Field: ‘conditions’
[16:18:44.431]   - Field: ‘persistent’
[16:18:44.431]   - Field: ‘expr’
[16:18:44.431]   - Field: ‘uuid’
[16:18:44.431]   - Field: ‘seed’
[16:18:44.431]   - Field: ‘version’
[16:18:44.431]   - Field: ‘result’
[16:18:44.431]   - Field: ‘asynchronous’
[16:18:44.431]   - Field: ‘calls’
[16:18:44.431]   - Field: ‘globals’
[16:18:44.431]   - Field: ‘stdout’
[16:18:44.431]   - Field: ‘earlySignal’
[16:18:44.432]   - Field: ‘lazy’
[16:18:44.432]   - Field: ‘state’
[16:18:44.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:44.432] - Launch lazy future ...
[16:18:44.432] Packages needed by the future expression (n = 0): <none>
[16:18:44.432] Packages needed by future strategies (n = 0): <none>
[16:18:44.433] {
[16:18:44.433]     {
[16:18:44.433]         {
[16:18:44.433]             ...future.startTime <- base::Sys.time()
[16:18:44.433]             {
[16:18:44.433]                 {
[16:18:44.433]                   {
[16:18:44.433]                     {
[16:18:44.433]                       base::local({
[16:18:44.433]                         has_future <- base::requireNamespace("future", 
[16:18:44.433]                           quietly = TRUE)
[16:18:44.433]                         if (has_future) {
[16:18:44.433]                           ns <- base::getNamespace("future")
[16:18:44.433]                           version <- ns[[".package"]][["version"]]
[16:18:44.433]                           if (is.null(version)) 
[16:18:44.433]                             version <- utils::packageVersion("future")
[16:18:44.433]                         }
[16:18:44.433]                         else {
[16:18:44.433]                           version <- NULL
[16:18:44.433]                         }
[16:18:44.433]                         if (!has_future || version < "1.8.0") {
[16:18:44.433]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:44.433]                             "", base::R.version$version.string), 
[16:18:44.433]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:44.433]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:44.433]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:44.433]                               "release", "version")], collapse = " "), 
[16:18:44.433]                             hostname = base::Sys.info()[["nodename"]])
[16:18:44.433]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:44.433]                             info)
[16:18:44.433]                           info <- base::paste(info, collapse = "; ")
[16:18:44.433]                           if (!has_future) {
[16:18:44.433]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:44.433]                               info)
[16:18:44.433]                           }
[16:18:44.433]                           else {
[16:18:44.433]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:44.433]                               info, version)
[16:18:44.433]                           }
[16:18:44.433]                           base::stop(msg)
[16:18:44.433]                         }
[16:18:44.433]                       })
[16:18:44.433]                     }
[16:18:44.433]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:44.433]                     base::options(mc.cores = 1L)
[16:18:44.433]                   }
[16:18:44.433]                   ...future.strategy.old <- future::plan("list")
[16:18:44.433]                   options(future.plan = NULL)
[16:18:44.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:44.433]                 }
[16:18:44.433]                 ...future.workdir <- getwd()
[16:18:44.433]             }
[16:18:44.433]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:44.433]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:44.433]         }
[16:18:44.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:44.433]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:44.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:44.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:44.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:44.433]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:44.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:44.433]             base::names(...future.oldOptions))
[16:18:44.433]     }
[16:18:44.433]     if (FALSE) {
[16:18:44.433]     }
[16:18:44.433]     else {
[16:18:44.433]         if (TRUE) {
[16:18:44.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:44.433]                 open = "w")
[16:18:44.433]         }
[16:18:44.433]         else {
[16:18:44.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:44.433]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:44.433]         }
[16:18:44.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:44.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:44.433]             base::sink(type = "output", split = FALSE)
[16:18:44.433]             base::close(...future.stdout)
[16:18:44.433]         }, add = TRUE)
[16:18:44.433]     }
[16:18:44.433]     ...future.frame <- base::sys.nframe()
[16:18:44.433]     ...future.conditions <- base::list()
[16:18:44.433]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:44.433]     if (FALSE) {
[16:18:44.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:44.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:44.433]     }
[16:18:44.433]     ...future.result <- base::tryCatch({
[16:18:44.433]         base::withCallingHandlers({
[16:18:44.433]             ...future.value <- base::withVisible(base::local({
[16:18:44.433]                 ...future.makeSendCondition <- base::local({
[16:18:44.433]                   sendCondition <- NULL
[16:18:44.433]                   function(frame = 1L) {
[16:18:44.433]                     if (is.function(sendCondition)) 
[16:18:44.433]                       return(sendCondition)
[16:18:44.433]                     ns <- getNamespace("parallel")
[16:18:44.433]                     if (exists("sendData", mode = "function", 
[16:18:44.433]                       envir = ns)) {
[16:18:44.433]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:44.433]                         envir = ns)
[16:18:44.433]                       envir <- sys.frame(frame)
[16:18:44.433]                       master <- NULL
[16:18:44.433]                       while (!identical(envir, .GlobalEnv) && 
[16:18:44.433]                         !identical(envir, emptyenv())) {
[16:18:44.433]                         if (exists("master", mode = "list", envir = envir, 
[16:18:44.433]                           inherits = FALSE)) {
[16:18:44.433]                           master <- get("master", mode = "list", 
[16:18:44.433]                             envir = envir, inherits = FALSE)
[16:18:44.433]                           if (inherits(master, c("SOCKnode", 
[16:18:44.433]                             "SOCK0node"))) {
[16:18:44.433]                             sendCondition <<- function(cond) {
[16:18:44.433]                               data <- list(type = "VALUE", value = cond, 
[16:18:44.433]                                 success = TRUE)
[16:18:44.433]                               parallel_sendData(master, data)
[16:18:44.433]                             }
[16:18:44.433]                             return(sendCondition)
[16:18:44.433]                           }
[16:18:44.433]                         }
[16:18:44.433]                         frame <- frame + 1L
[16:18:44.433]                         envir <- sys.frame(frame)
[16:18:44.433]                       }
[16:18:44.433]                     }
[16:18:44.433]                     sendCondition <<- function(cond) NULL
[16:18:44.433]                   }
[16:18:44.433]                 })
[16:18:44.433]                 withCallingHandlers({
[16:18:44.433]                   {
[16:18:44.433]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.433]                     if (!identical(...future.globals.maxSize.org, 
[16:18:44.433]                       ...future.globals.maxSize)) {
[16:18:44.433]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.433]                       on.exit(options(oopts), add = TRUE)
[16:18:44.433]                     }
[16:18:44.433]                     {
[16:18:44.433]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.433]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:44.433]                         USE.NAMES = FALSE)
[16:18:44.433]                       do.call(mapply, args = args)
[16:18:44.433]                     }
[16:18:44.433]                   }
[16:18:44.433]                 }, immediateCondition = function(cond) {
[16:18:44.433]                   sendCondition <- ...future.makeSendCondition()
[16:18:44.433]                   sendCondition(cond)
[16:18:44.433]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.433]                   {
[16:18:44.433]                     inherits <- base::inherits
[16:18:44.433]                     invokeRestart <- base::invokeRestart
[16:18:44.433]                     is.null <- base::is.null
[16:18:44.433]                     muffled <- FALSE
[16:18:44.433]                     if (inherits(cond, "message")) {
[16:18:44.433]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:44.433]                       if (muffled) 
[16:18:44.433]                         invokeRestart("muffleMessage")
[16:18:44.433]                     }
[16:18:44.433]                     else if (inherits(cond, "warning")) {
[16:18:44.433]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:44.433]                       if (muffled) 
[16:18:44.433]                         invokeRestart("muffleWarning")
[16:18:44.433]                     }
[16:18:44.433]                     else if (inherits(cond, "condition")) {
[16:18:44.433]                       if (!is.null(pattern)) {
[16:18:44.433]                         computeRestarts <- base::computeRestarts
[16:18:44.433]                         grepl <- base::grepl
[16:18:44.433]                         restarts <- computeRestarts(cond)
[16:18:44.433]                         for (restart in restarts) {
[16:18:44.433]                           name <- restart$name
[16:18:44.433]                           if (is.null(name)) 
[16:18:44.433]                             next
[16:18:44.433]                           if (!grepl(pattern, name)) 
[16:18:44.433]                             next
[16:18:44.433]                           invokeRestart(restart)
[16:18:44.433]                           muffled <- TRUE
[16:18:44.433]                           break
[16:18:44.433]                         }
[16:18:44.433]                       }
[16:18:44.433]                     }
[16:18:44.433]                     invisible(muffled)
[16:18:44.433]                   }
[16:18:44.433]                   muffleCondition(cond)
[16:18:44.433]                 })
[16:18:44.433]             }))
[16:18:44.433]             future::FutureResult(value = ...future.value$value, 
[16:18:44.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.433]                   ...future.rng), globalenv = if (FALSE) 
[16:18:44.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:44.433]                     ...future.globalenv.names))
[16:18:44.433]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:44.433]         }, condition = base::local({
[16:18:44.433]             c <- base::c
[16:18:44.433]             inherits <- base::inherits
[16:18:44.433]             invokeRestart <- base::invokeRestart
[16:18:44.433]             length <- base::length
[16:18:44.433]             list <- base::list
[16:18:44.433]             seq.int <- base::seq.int
[16:18:44.433]             signalCondition <- base::signalCondition
[16:18:44.433]             sys.calls <- base::sys.calls
[16:18:44.433]             `[[` <- base::`[[`
[16:18:44.433]             `+` <- base::`+`
[16:18:44.433]             `<<-` <- base::`<<-`
[16:18:44.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:44.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:44.433]                   3L)]
[16:18:44.433]             }
[16:18:44.433]             function(cond) {
[16:18:44.433]                 is_error <- inherits(cond, "error")
[16:18:44.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:44.433]                   NULL)
[16:18:44.433]                 if (is_error) {
[16:18:44.433]                   sessionInformation <- function() {
[16:18:44.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:44.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:44.433]                       search = base::search(), system = base::Sys.info())
[16:18:44.433]                   }
[16:18:44.433]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:44.433]                     cond$call), session = sessionInformation(), 
[16:18:44.433]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:44.433]                   signalCondition(cond)
[16:18:44.433]                 }
[16:18:44.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:44.433]                 "immediateCondition"))) {
[16:18:44.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:44.433]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:44.433]                   if (TRUE && !signal) {
[16:18:44.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.433]                     {
[16:18:44.433]                       inherits <- base::inherits
[16:18:44.433]                       invokeRestart <- base::invokeRestart
[16:18:44.433]                       is.null <- base::is.null
[16:18:44.433]                       muffled <- FALSE
[16:18:44.433]                       if (inherits(cond, "message")) {
[16:18:44.433]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.433]                         if (muffled) 
[16:18:44.433]                           invokeRestart("muffleMessage")
[16:18:44.433]                       }
[16:18:44.433]                       else if (inherits(cond, "warning")) {
[16:18:44.433]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.433]                         if (muffled) 
[16:18:44.433]                           invokeRestart("muffleWarning")
[16:18:44.433]                       }
[16:18:44.433]                       else if (inherits(cond, "condition")) {
[16:18:44.433]                         if (!is.null(pattern)) {
[16:18:44.433]                           computeRestarts <- base::computeRestarts
[16:18:44.433]                           grepl <- base::grepl
[16:18:44.433]                           restarts <- computeRestarts(cond)
[16:18:44.433]                           for (restart in restarts) {
[16:18:44.433]                             name <- restart$name
[16:18:44.433]                             if (is.null(name)) 
[16:18:44.433]                               next
[16:18:44.433]                             if (!grepl(pattern, name)) 
[16:18:44.433]                               next
[16:18:44.433]                             invokeRestart(restart)
[16:18:44.433]                             muffled <- TRUE
[16:18:44.433]                             break
[16:18:44.433]                           }
[16:18:44.433]                         }
[16:18:44.433]                       }
[16:18:44.433]                       invisible(muffled)
[16:18:44.433]                     }
[16:18:44.433]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.433]                   }
[16:18:44.433]                 }
[16:18:44.433]                 else {
[16:18:44.433]                   if (TRUE) {
[16:18:44.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.433]                     {
[16:18:44.433]                       inherits <- base::inherits
[16:18:44.433]                       invokeRestart <- base::invokeRestart
[16:18:44.433]                       is.null <- base::is.null
[16:18:44.433]                       muffled <- FALSE
[16:18:44.433]                       if (inherits(cond, "message")) {
[16:18:44.433]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.433]                         if (muffled) 
[16:18:44.433]                           invokeRestart("muffleMessage")
[16:18:44.433]                       }
[16:18:44.433]                       else if (inherits(cond, "warning")) {
[16:18:44.433]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.433]                         if (muffled) 
[16:18:44.433]                           invokeRestart("muffleWarning")
[16:18:44.433]                       }
[16:18:44.433]                       else if (inherits(cond, "condition")) {
[16:18:44.433]                         if (!is.null(pattern)) {
[16:18:44.433]                           computeRestarts <- base::computeRestarts
[16:18:44.433]                           grepl <- base::grepl
[16:18:44.433]                           restarts <- computeRestarts(cond)
[16:18:44.433]                           for (restart in restarts) {
[16:18:44.433]                             name <- restart$name
[16:18:44.433]                             if (is.null(name)) 
[16:18:44.433]                               next
[16:18:44.433]                             if (!grepl(pattern, name)) 
[16:18:44.433]                               next
[16:18:44.433]                             invokeRestart(restart)
[16:18:44.433]                             muffled <- TRUE
[16:18:44.433]                             break
[16:18:44.433]                           }
[16:18:44.433]                         }
[16:18:44.433]                       }
[16:18:44.433]                       invisible(muffled)
[16:18:44.433]                     }
[16:18:44.433]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.433]                   }
[16:18:44.433]                 }
[16:18:44.433]             }
[16:18:44.433]         }))
[16:18:44.433]     }, error = function(ex) {
[16:18:44.433]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:44.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.433]                 ...future.rng), started = ...future.startTime, 
[16:18:44.433]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:44.433]             version = "1.8"), class = "FutureResult")
[16:18:44.433]     }, finally = {
[16:18:44.433]         if (!identical(...future.workdir, getwd())) 
[16:18:44.433]             setwd(...future.workdir)
[16:18:44.433]         {
[16:18:44.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:44.433]                 ...future.oldOptions$nwarnings <- NULL
[16:18:44.433]             }
[16:18:44.433]             base::options(...future.oldOptions)
[16:18:44.433]             if (.Platform$OS.type == "windows") {
[16:18:44.433]                 old_names <- names(...future.oldEnvVars)
[16:18:44.433]                 envs <- base::Sys.getenv()
[16:18:44.433]                 names <- names(envs)
[16:18:44.433]                 common <- intersect(names, old_names)
[16:18:44.433]                 added <- setdiff(names, old_names)
[16:18:44.433]                 removed <- setdiff(old_names, names)
[16:18:44.433]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:44.433]                   envs[common]]
[16:18:44.433]                 NAMES <- toupper(changed)
[16:18:44.433]                 args <- list()
[16:18:44.433]                 for (kk in seq_along(NAMES)) {
[16:18:44.433]                   name <- changed[[kk]]
[16:18:44.433]                   NAME <- NAMES[[kk]]
[16:18:44.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.433]                     next
[16:18:44.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.433]                 }
[16:18:44.433]                 NAMES <- toupper(added)
[16:18:44.433]                 for (kk in seq_along(NAMES)) {
[16:18:44.433]                   name <- added[[kk]]
[16:18:44.433]                   NAME <- NAMES[[kk]]
[16:18:44.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.433]                     next
[16:18:44.433]                   args[[name]] <- ""
[16:18:44.433]                 }
[16:18:44.433]                 NAMES <- toupper(removed)
[16:18:44.433]                 for (kk in seq_along(NAMES)) {
[16:18:44.433]                   name <- removed[[kk]]
[16:18:44.433]                   NAME <- NAMES[[kk]]
[16:18:44.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.433]                     next
[16:18:44.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.433]                 }
[16:18:44.433]                 if (length(args) > 0) 
[16:18:44.433]                   base::do.call(base::Sys.setenv, args = args)
[16:18:44.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:44.433]             }
[16:18:44.433]             else {
[16:18:44.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:44.433]             }
[16:18:44.433]             {
[16:18:44.433]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:44.433]                   0L) {
[16:18:44.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:44.433]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:44.433]                   base::options(opts)
[16:18:44.433]                 }
[16:18:44.433]                 {
[16:18:44.433]                   {
[16:18:44.433]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:44.433]                     NULL
[16:18:44.433]                   }
[16:18:44.433]                   options(future.plan = NULL)
[16:18:44.433]                   if (is.na(NA_character_)) 
[16:18:44.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:44.433]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:44.433]                     .init = FALSE)
[16:18:44.433]                 }
[16:18:44.433]             }
[16:18:44.433]         }
[16:18:44.433]     })
[16:18:44.433]     if (TRUE) {
[16:18:44.433]         base::sink(type = "output", split = FALSE)
[16:18:44.433]         if (TRUE) {
[16:18:44.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:44.433]         }
[16:18:44.433]         else {
[16:18:44.433]             ...future.result["stdout"] <- base::list(NULL)
[16:18:44.433]         }
[16:18:44.433]         base::close(...future.stdout)
[16:18:44.433]         ...future.stdout <- NULL
[16:18:44.433]     }
[16:18:44.433]     ...future.result$conditions <- ...future.conditions
[16:18:44.433]     ...future.result$finished <- base::Sys.time()
[16:18:44.433]     ...future.result
[16:18:44.433] }
[16:18:44.485] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[16:18:44.485] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[16:18:44.486] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[16:18:44.486] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:44.486] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:44.486] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[16:18:44.487] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[16:18:44.487] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:44.487] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:44.487] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:44.488] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:44.488] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[16:18:44.488] MultisessionFuture started
[16:18:44.488] - Launch lazy future ... done
[16:18:44.489] run() for ‘MultisessionFuture’ ... done
[16:18:44.489] Created future:
[16:18:44.489] MultisessionFuture:
[16:18:44.489] Label: ‘future_mapply-2’
[16:18:44.489] Expression:
[16:18:44.489] {
[16:18:44.489]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.489]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:44.489]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.489]         on.exit(options(oopts), add = TRUE)
[16:18:44.489]     }
[16:18:44.489]     {
[16:18:44.489]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.489]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:44.489]         do.call(mapply, args = args)
[16:18:44.489]     }
[16:18:44.489] }
[16:18:44.489] Lazy evaluation: FALSE
[16:18:44.489] Asynchronous evaluation: TRUE
[16:18:44.489] Local evaluation: TRUE
[16:18:44.489] Environment: R_GlobalEnv
[16:18:44.489] Capture standard output: TRUE
[16:18:44.489] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:44.489] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:44.489] Packages: <none>
[16:18:44.489] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:44.489] Resolved: FALSE
[16:18:44.489] Value: <not collected>
[16:18:44.489] Conditions captured: <none>
[16:18:44.489] Early signaling: FALSE
[16:18:44.489] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:44.489] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.500] Chunk #2 of 2 ... DONE
[16:18:44.501] Launching 2 futures (chunks) ... DONE
[16:18:44.501] Resolving 2 futures (chunks) ...
[16:18:44.501] resolve() on list ...
[16:18:44.501]  recursive: 0
[16:18:44.501]  length: 2
[16:18:44.501] 
[16:18:44.502] receiveMessageFromWorker() for ClusterFuture ...
[16:18:44.502] - Validating connection of MultisessionFuture
[16:18:44.502] - received message: FutureResult
[16:18:44.502] - Received FutureResult
[16:18:44.502] - Erased future from FutureRegistry
[16:18:44.502] result() for ClusterFuture ...
[16:18:44.502] - result already collected: FutureResult
[16:18:44.502] result() for ClusterFuture ... done
[16:18:44.503] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:44.503] Future #1
[16:18:44.503] result() for ClusterFuture ...
[16:18:44.503] - result already collected: FutureResult
[16:18:44.503] result() for ClusterFuture ... done
[16:18:44.503] result() for ClusterFuture ...
[16:18:44.503] - result already collected: FutureResult
[16:18:44.503] result() for ClusterFuture ... done
[16:18:44.503] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:44.503] - nx: 2
[16:18:44.504] - relay: TRUE
[16:18:44.504] - stdout: TRUE
[16:18:44.504] - signal: TRUE
[16:18:44.504] - resignal: FALSE
[16:18:44.504] - force: TRUE
[16:18:44.504] - relayed: [n=2] FALSE, FALSE
[16:18:44.504] - queued futures: [n=2] FALSE, FALSE
[16:18:44.504]  - until=1
[16:18:44.504]  - relaying element #1
[16:18:44.504] result() for ClusterFuture ...
[16:18:44.504] - result already collected: FutureResult
[16:18:44.505] result() for ClusterFuture ... done
[16:18:44.505] result() for ClusterFuture ...
[16:18:44.507] - result already collected: FutureResult
[16:18:44.507] result() for ClusterFuture ... done
[16:18:44.508] result() for ClusterFuture ...
[16:18:44.508] - result already collected: FutureResult
[16:18:44.508] result() for ClusterFuture ... done
[16:18:44.508] result() for ClusterFuture ...
[16:18:44.508] - result already collected: FutureResult
[16:18:44.508] result() for ClusterFuture ... done
[16:18:44.508] - relayed: [n=2] TRUE, FALSE
[16:18:44.508] - queued futures: [n=2] TRUE, FALSE
[16:18:44.508] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:44.508]  length: 1 (resolved future 1)
[16:18:44.570] receiveMessageFromWorker() for ClusterFuture ...
[16:18:44.571] - Validating connection of MultisessionFuture
[16:18:44.571] - received message: FutureResult
[16:18:44.571] - Received FutureResult
[16:18:44.571] - Erased future from FutureRegistry
[16:18:44.571] result() for ClusterFuture ...
[16:18:44.571] - result already collected: FutureResult
[16:18:44.571] result() for ClusterFuture ... done
[16:18:44.571] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:44.572] Future #2
[16:18:44.572] result() for ClusterFuture ...
[16:18:44.572] - result already collected: FutureResult
[16:18:44.572] result() for ClusterFuture ... done
[16:18:44.572] result() for ClusterFuture ...
[16:18:44.572] - result already collected: FutureResult
[16:18:44.572] result() for ClusterFuture ... done
[16:18:44.572] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:44.572] - nx: 2
[16:18:44.572] - relay: TRUE
[16:18:44.572] - stdout: TRUE
[16:18:44.572] - signal: TRUE
[16:18:44.573] - resignal: FALSE
[16:18:44.573] - force: TRUE
[16:18:44.573] - relayed: [n=2] TRUE, FALSE
[16:18:44.573] - queued futures: [n=2] TRUE, FALSE
[16:18:44.573]  - until=2
[16:18:44.573]  - relaying element #2
[16:18:44.573] result() for ClusterFuture ...
[16:18:44.573] - result already collected: FutureResult
[16:18:44.573] result() for ClusterFuture ... done
[16:18:44.573] result() for ClusterFuture ...
[16:18:44.573] - result already collected: FutureResult
[16:18:44.574] result() for ClusterFuture ... done
[16:18:44.574] result() for ClusterFuture ...
[16:18:44.574] - result already collected: FutureResult
[16:18:44.574] result() for ClusterFuture ... done
[16:18:44.574] result() for ClusterFuture ...
[16:18:44.574] - result already collected: FutureResult
[16:18:44.574] result() for ClusterFuture ... done
[16:18:44.574] - relayed: [n=2] TRUE, TRUE
[16:18:44.574] - queued futures: [n=2] TRUE, TRUE
[16:18:44.574] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:44.574]  length: 0 (resolved future 2)
[16:18:44.575] Relaying remaining futures
[16:18:44.575] signalConditionsASAP(NULL, pos=0) ...
[16:18:44.575] - nx: 2
[16:18:44.575] - relay: TRUE
[16:18:44.575] - stdout: TRUE
[16:18:44.575] - signal: TRUE
[16:18:44.575] - resignal: FALSE
[16:18:44.575] - force: TRUE
[16:18:44.575] - relayed: [n=2] TRUE, TRUE
[16:18:44.575] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:44.575] - relayed: [n=2] TRUE, TRUE
[16:18:44.575] - queued futures: [n=2] TRUE, TRUE
[16:18:44.576] signalConditionsASAP(NULL, pos=0) ... done
[16:18:44.576] resolve() on list ... DONE
[16:18:44.576] result() for ClusterFuture ...
[16:18:44.576] - result already collected: FutureResult
[16:18:44.576] result() for ClusterFuture ... done
[16:18:44.576] result() for ClusterFuture ...
[16:18:44.576] - result already collected: FutureResult
[16:18:44.576] result() for ClusterFuture ... done
[16:18:44.576] result() for ClusterFuture ...
[16:18:44.576] - result already collected: FutureResult
[16:18:44.576] result() for ClusterFuture ... done
[16:18:44.577] result() for ClusterFuture ...
[16:18:44.577] - result already collected: FutureResult
[16:18:44.577] result() for ClusterFuture ... done
[16:18:44.577]  - Number of value chunks collected: 2
[16:18:44.577] Resolving 2 futures (chunks) ... DONE
[16:18:44.577] Reducing values from 2 chunks ...
[16:18:44.577]  - Number of values collected after concatenation: 4
[16:18:44.577]  - Number of values expected: 4
[16:18:44.577] Reducing values from 2 chunks ... DONE
[16:18:44.577] future_mapply() ... DONE
[16:18:44.577] future_mapply() ...
[16:18:44.581] Number of chunks: 2
[16:18:44.581] getGlobalsAndPackagesXApply() ...
[16:18:44.581]  - future.globals: TRUE
[16:18:44.582] getGlobalsAndPackages() ...
[16:18:44.582] Searching for globals...
[16:18:44.582] - globals found: [1] ‘FUN’
[16:18:44.582] Searching for globals ... DONE
[16:18:44.582] Resolving globals: FALSE
[16:18:44.583] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:44.583] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:44.583] - globals: [1] ‘FUN’
[16:18:44.583] 
[16:18:44.583] getGlobalsAndPackages() ... DONE
[16:18:44.584]  - globals found/used: [n=1] ‘FUN’
[16:18:44.584]  - needed namespaces: [n=0] 
[16:18:44.584] Finding globals ... DONE
[16:18:44.584] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:44.584] List of 2
[16:18:44.584]  $ ...future.FUN:function (x, ...)  
[16:18:44.584]  $ MoreArgs     : NULL
[16:18:44.584]  - attr(*, "where")=List of 2
[16:18:44.584]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:44.584]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:44.584]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:44.584]  - attr(*, "resolved")= logi FALSE
[16:18:44.584]  - attr(*, "total_size")= num NA
[16:18:44.587] Packages to be attached in all futures: [n=0] 
[16:18:44.587] getGlobalsAndPackagesXApply() ... DONE
[16:18:44.587] Number of futures (= number of chunks): 2
[16:18:44.587] Launching 2 futures (chunks) ...
[16:18:44.587] Chunk #1 of 2 ...
[16:18:44.587]  - Finding globals in '...' for chunk #1 ...
[16:18:44.587] getGlobalsAndPackages() ...
[16:18:44.587] Searching for globals...
[16:18:44.588] 
[16:18:44.588] Searching for globals ... DONE
[16:18:44.588] - globals: [0] <none>
[16:18:44.588] getGlobalsAndPackages() ... DONE
[16:18:44.588]    + additional globals found: [n=0] 
[16:18:44.588]    + additional namespaces needed: [n=0] 
[16:18:44.588]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:44.588]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:44.588]  - seeds: <none>
[16:18:44.589]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.589] getGlobalsAndPackages() ...
[16:18:44.589] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.589] Resolving globals: FALSE
[16:18:44.589] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:44.590] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:44.590] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.590] 
[16:18:44.590] getGlobalsAndPackages() ... DONE
[16:18:44.590] run() for ‘Future’ ...
[16:18:44.590] - state: ‘created’
[16:18:44.591] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:44.604] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.604] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:44.604]   - Field: ‘node’
[16:18:44.604]   - Field: ‘label’
[16:18:44.605]   - Field: ‘local’
[16:18:44.605]   - Field: ‘owner’
[16:18:44.605]   - Field: ‘envir’
[16:18:44.605]   - Field: ‘workers’
[16:18:44.605]   - Field: ‘packages’
[16:18:44.605]   - Field: ‘gc’
[16:18:44.605]   - Field: ‘conditions’
[16:18:44.605]   - Field: ‘persistent’
[16:18:44.605]   - Field: ‘expr’
[16:18:44.605]   - Field: ‘uuid’
[16:18:44.605]   - Field: ‘seed’
[16:18:44.606]   - Field: ‘version’
[16:18:44.606]   - Field: ‘result’
[16:18:44.606]   - Field: ‘asynchronous’
[16:18:44.606]   - Field: ‘calls’
[16:18:44.606]   - Field: ‘globals’
[16:18:44.606]   - Field: ‘stdout’
[16:18:44.606]   - Field: ‘earlySignal’
[16:18:44.606]   - Field: ‘lazy’
[16:18:44.606]   - Field: ‘state’
[16:18:44.606] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:44.606] - Launch lazy future ...
[16:18:44.607] Packages needed by the future expression (n = 0): <none>
[16:18:44.607] Packages needed by future strategies (n = 0): <none>
[16:18:44.607] {
[16:18:44.607]     {
[16:18:44.607]         {
[16:18:44.607]             ...future.startTime <- base::Sys.time()
[16:18:44.607]             {
[16:18:44.607]                 {
[16:18:44.607]                   {
[16:18:44.607]                     {
[16:18:44.607]                       base::local({
[16:18:44.607]                         has_future <- base::requireNamespace("future", 
[16:18:44.607]                           quietly = TRUE)
[16:18:44.607]                         if (has_future) {
[16:18:44.607]                           ns <- base::getNamespace("future")
[16:18:44.607]                           version <- ns[[".package"]][["version"]]
[16:18:44.607]                           if (is.null(version)) 
[16:18:44.607]                             version <- utils::packageVersion("future")
[16:18:44.607]                         }
[16:18:44.607]                         else {
[16:18:44.607]                           version <- NULL
[16:18:44.607]                         }
[16:18:44.607]                         if (!has_future || version < "1.8.0") {
[16:18:44.607]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:44.607]                             "", base::R.version$version.string), 
[16:18:44.607]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:44.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:44.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:44.607]                               "release", "version")], collapse = " "), 
[16:18:44.607]                             hostname = base::Sys.info()[["nodename"]])
[16:18:44.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:44.607]                             info)
[16:18:44.607]                           info <- base::paste(info, collapse = "; ")
[16:18:44.607]                           if (!has_future) {
[16:18:44.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:44.607]                               info)
[16:18:44.607]                           }
[16:18:44.607]                           else {
[16:18:44.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:44.607]                               info, version)
[16:18:44.607]                           }
[16:18:44.607]                           base::stop(msg)
[16:18:44.607]                         }
[16:18:44.607]                       })
[16:18:44.607]                     }
[16:18:44.607]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:44.607]                     base::options(mc.cores = 1L)
[16:18:44.607]                   }
[16:18:44.607]                   ...future.strategy.old <- future::plan("list")
[16:18:44.607]                   options(future.plan = NULL)
[16:18:44.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:44.607]                 }
[16:18:44.607]                 ...future.workdir <- getwd()
[16:18:44.607]             }
[16:18:44.607]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:44.607]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:44.607]         }
[16:18:44.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:44.607]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:44.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:44.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:44.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:44.607]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:44.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:44.607]             base::names(...future.oldOptions))
[16:18:44.607]     }
[16:18:44.607]     if (FALSE) {
[16:18:44.607]     }
[16:18:44.607]     else {
[16:18:44.607]         if (TRUE) {
[16:18:44.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:44.607]                 open = "w")
[16:18:44.607]         }
[16:18:44.607]         else {
[16:18:44.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:44.607]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:44.607]         }
[16:18:44.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:44.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:44.607]             base::sink(type = "output", split = FALSE)
[16:18:44.607]             base::close(...future.stdout)
[16:18:44.607]         }, add = TRUE)
[16:18:44.607]     }
[16:18:44.607]     ...future.frame <- base::sys.nframe()
[16:18:44.607]     ...future.conditions <- base::list()
[16:18:44.607]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:44.607]     if (FALSE) {
[16:18:44.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:44.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:44.607]     }
[16:18:44.607]     ...future.result <- base::tryCatch({
[16:18:44.607]         base::withCallingHandlers({
[16:18:44.607]             ...future.value <- base::withVisible(base::local({
[16:18:44.607]                 ...future.makeSendCondition <- base::local({
[16:18:44.607]                   sendCondition <- NULL
[16:18:44.607]                   function(frame = 1L) {
[16:18:44.607]                     if (is.function(sendCondition)) 
[16:18:44.607]                       return(sendCondition)
[16:18:44.607]                     ns <- getNamespace("parallel")
[16:18:44.607]                     if (exists("sendData", mode = "function", 
[16:18:44.607]                       envir = ns)) {
[16:18:44.607]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:44.607]                         envir = ns)
[16:18:44.607]                       envir <- sys.frame(frame)
[16:18:44.607]                       master <- NULL
[16:18:44.607]                       while (!identical(envir, .GlobalEnv) && 
[16:18:44.607]                         !identical(envir, emptyenv())) {
[16:18:44.607]                         if (exists("master", mode = "list", envir = envir, 
[16:18:44.607]                           inherits = FALSE)) {
[16:18:44.607]                           master <- get("master", mode = "list", 
[16:18:44.607]                             envir = envir, inherits = FALSE)
[16:18:44.607]                           if (inherits(master, c("SOCKnode", 
[16:18:44.607]                             "SOCK0node"))) {
[16:18:44.607]                             sendCondition <<- function(cond) {
[16:18:44.607]                               data <- list(type = "VALUE", value = cond, 
[16:18:44.607]                                 success = TRUE)
[16:18:44.607]                               parallel_sendData(master, data)
[16:18:44.607]                             }
[16:18:44.607]                             return(sendCondition)
[16:18:44.607]                           }
[16:18:44.607]                         }
[16:18:44.607]                         frame <- frame + 1L
[16:18:44.607]                         envir <- sys.frame(frame)
[16:18:44.607]                       }
[16:18:44.607]                     }
[16:18:44.607]                     sendCondition <<- function(cond) NULL
[16:18:44.607]                   }
[16:18:44.607]                 })
[16:18:44.607]                 withCallingHandlers({
[16:18:44.607]                   {
[16:18:44.607]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.607]                     if (!identical(...future.globals.maxSize.org, 
[16:18:44.607]                       ...future.globals.maxSize)) {
[16:18:44.607]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.607]                       on.exit(options(oopts), add = TRUE)
[16:18:44.607]                     }
[16:18:44.607]                     {
[16:18:44.607]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.607]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:44.607]                         USE.NAMES = FALSE)
[16:18:44.607]                       do.call(mapply, args = args)
[16:18:44.607]                     }
[16:18:44.607]                   }
[16:18:44.607]                 }, immediateCondition = function(cond) {
[16:18:44.607]                   sendCondition <- ...future.makeSendCondition()
[16:18:44.607]                   sendCondition(cond)
[16:18:44.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.607]                   {
[16:18:44.607]                     inherits <- base::inherits
[16:18:44.607]                     invokeRestart <- base::invokeRestart
[16:18:44.607]                     is.null <- base::is.null
[16:18:44.607]                     muffled <- FALSE
[16:18:44.607]                     if (inherits(cond, "message")) {
[16:18:44.607]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:44.607]                       if (muffled) 
[16:18:44.607]                         invokeRestart("muffleMessage")
[16:18:44.607]                     }
[16:18:44.607]                     else if (inherits(cond, "warning")) {
[16:18:44.607]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:44.607]                       if (muffled) 
[16:18:44.607]                         invokeRestart("muffleWarning")
[16:18:44.607]                     }
[16:18:44.607]                     else if (inherits(cond, "condition")) {
[16:18:44.607]                       if (!is.null(pattern)) {
[16:18:44.607]                         computeRestarts <- base::computeRestarts
[16:18:44.607]                         grepl <- base::grepl
[16:18:44.607]                         restarts <- computeRestarts(cond)
[16:18:44.607]                         for (restart in restarts) {
[16:18:44.607]                           name <- restart$name
[16:18:44.607]                           if (is.null(name)) 
[16:18:44.607]                             next
[16:18:44.607]                           if (!grepl(pattern, name)) 
[16:18:44.607]                             next
[16:18:44.607]                           invokeRestart(restart)
[16:18:44.607]                           muffled <- TRUE
[16:18:44.607]                           break
[16:18:44.607]                         }
[16:18:44.607]                       }
[16:18:44.607]                     }
[16:18:44.607]                     invisible(muffled)
[16:18:44.607]                   }
[16:18:44.607]                   muffleCondition(cond)
[16:18:44.607]                 })
[16:18:44.607]             }))
[16:18:44.607]             future::FutureResult(value = ...future.value$value, 
[16:18:44.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.607]                   ...future.rng), globalenv = if (FALSE) 
[16:18:44.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:44.607]                     ...future.globalenv.names))
[16:18:44.607]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:44.607]         }, condition = base::local({
[16:18:44.607]             c <- base::c
[16:18:44.607]             inherits <- base::inherits
[16:18:44.607]             invokeRestart <- base::invokeRestart
[16:18:44.607]             length <- base::length
[16:18:44.607]             list <- base::list
[16:18:44.607]             seq.int <- base::seq.int
[16:18:44.607]             signalCondition <- base::signalCondition
[16:18:44.607]             sys.calls <- base::sys.calls
[16:18:44.607]             `[[` <- base::`[[`
[16:18:44.607]             `+` <- base::`+`
[16:18:44.607]             `<<-` <- base::`<<-`
[16:18:44.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:44.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:44.607]                   3L)]
[16:18:44.607]             }
[16:18:44.607]             function(cond) {
[16:18:44.607]                 is_error <- inherits(cond, "error")
[16:18:44.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:44.607]                   NULL)
[16:18:44.607]                 if (is_error) {
[16:18:44.607]                   sessionInformation <- function() {
[16:18:44.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:44.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:44.607]                       search = base::search(), system = base::Sys.info())
[16:18:44.607]                   }
[16:18:44.607]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:44.607]                     cond$call), session = sessionInformation(), 
[16:18:44.607]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:44.607]                   signalCondition(cond)
[16:18:44.607]                 }
[16:18:44.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:44.607]                 "immediateCondition"))) {
[16:18:44.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:44.607]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:44.607]                   if (TRUE && !signal) {
[16:18:44.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.607]                     {
[16:18:44.607]                       inherits <- base::inherits
[16:18:44.607]                       invokeRestart <- base::invokeRestart
[16:18:44.607]                       is.null <- base::is.null
[16:18:44.607]                       muffled <- FALSE
[16:18:44.607]                       if (inherits(cond, "message")) {
[16:18:44.607]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.607]                         if (muffled) 
[16:18:44.607]                           invokeRestart("muffleMessage")
[16:18:44.607]                       }
[16:18:44.607]                       else if (inherits(cond, "warning")) {
[16:18:44.607]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.607]                         if (muffled) 
[16:18:44.607]                           invokeRestart("muffleWarning")
[16:18:44.607]                       }
[16:18:44.607]                       else if (inherits(cond, "condition")) {
[16:18:44.607]                         if (!is.null(pattern)) {
[16:18:44.607]                           computeRestarts <- base::computeRestarts
[16:18:44.607]                           grepl <- base::grepl
[16:18:44.607]                           restarts <- computeRestarts(cond)
[16:18:44.607]                           for (restart in restarts) {
[16:18:44.607]                             name <- restart$name
[16:18:44.607]                             if (is.null(name)) 
[16:18:44.607]                               next
[16:18:44.607]                             if (!grepl(pattern, name)) 
[16:18:44.607]                               next
[16:18:44.607]                             invokeRestart(restart)
[16:18:44.607]                             muffled <- TRUE
[16:18:44.607]                             break
[16:18:44.607]                           }
[16:18:44.607]                         }
[16:18:44.607]                       }
[16:18:44.607]                       invisible(muffled)
[16:18:44.607]                     }
[16:18:44.607]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.607]                   }
[16:18:44.607]                 }
[16:18:44.607]                 else {
[16:18:44.607]                   if (TRUE) {
[16:18:44.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.607]                     {
[16:18:44.607]                       inherits <- base::inherits
[16:18:44.607]                       invokeRestart <- base::invokeRestart
[16:18:44.607]                       is.null <- base::is.null
[16:18:44.607]                       muffled <- FALSE
[16:18:44.607]                       if (inherits(cond, "message")) {
[16:18:44.607]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.607]                         if (muffled) 
[16:18:44.607]                           invokeRestart("muffleMessage")
[16:18:44.607]                       }
[16:18:44.607]                       else if (inherits(cond, "warning")) {
[16:18:44.607]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.607]                         if (muffled) 
[16:18:44.607]                           invokeRestart("muffleWarning")
[16:18:44.607]                       }
[16:18:44.607]                       else if (inherits(cond, "condition")) {
[16:18:44.607]                         if (!is.null(pattern)) {
[16:18:44.607]                           computeRestarts <- base::computeRestarts
[16:18:44.607]                           grepl <- base::grepl
[16:18:44.607]                           restarts <- computeRestarts(cond)
[16:18:44.607]                           for (restart in restarts) {
[16:18:44.607]                             name <- restart$name
[16:18:44.607]                             if (is.null(name)) 
[16:18:44.607]                               next
[16:18:44.607]                             if (!grepl(pattern, name)) 
[16:18:44.607]                               next
[16:18:44.607]                             invokeRestart(restart)
[16:18:44.607]                             muffled <- TRUE
[16:18:44.607]                             break
[16:18:44.607]                           }
[16:18:44.607]                         }
[16:18:44.607]                       }
[16:18:44.607]                       invisible(muffled)
[16:18:44.607]                     }
[16:18:44.607]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.607]                   }
[16:18:44.607]                 }
[16:18:44.607]             }
[16:18:44.607]         }))
[16:18:44.607]     }, error = function(ex) {
[16:18:44.607]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:44.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.607]                 ...future.rng), started = ...future.startTime, 
[16:18:44.607]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:44.607]             version = "1.8"), class = "FutureResult")
[16:18:44.607]     }, finally = {
[16:18:44.607]         if (!identical(...future.workdir, getwd())) 
[16:18:44.607]             setwd(...future.workdir)
[16:18:44.607]         {
[16:18:44.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:44.607]                 ...future.oldOptions$nwarnings <- NULL
[16:18:44.607]             }
[16:18:44.607]             base::options(...future.oldOptions)
[16:18:44.607]             if (.Platform$OS.type == "windows") {
[16:18:44.607]                 old_names <- names(...future.oldEnvVars)
[16:18:44.607]                 envs <- base::Sys.getenv()
[16:18:44.607]                 names <- names(envs)
[16:18:44.607]                 common <- intersect(names, old_names)
[16:18:44.607]                 added <- setdiff(names, old_names)
[16:18:44.607]                 removed <- setdiff(old_names, names)
[16:18:44.607]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:44.607]                   envs[common]]
[16:18:44.607]                 NAMES <- toupper(changed)
[16:18:44.607]                 args <- list()
[16:18:44.607]                 for (kk in seq_along(NAMES)) {
[16:18:44.607]                   name <- changed[[kk]]
[16:18:44.607]                   NAME <- NAMES[[kk]]
[16:18:44.607]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.607]                     next
[16:18:44.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.607]                 }
[16:18:44.607]                 NAMES <- toupper(added)
[16:18:44.607]                 for (kk in seq_along(NAMES)) {
[16:18:44.607]                   name <- added[[kk]]
[16:18:44.607]                   NAME <- NAMES[[kk]]
[16:18:44.607]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.607]                     next
[16:18:44.607]                   args[[name]] <- ""
[16:18:44.607]                 }
[16:18:44.607]                 NAMES <- toupper(removed)
[16:18:44.607]                 for (kk in seq_along(NAMES)) {
[16:18:44.607]                   name <- removed[[kk]]
[16:18:44.607]                   NAME <- NAMES[[kk]]
[16:18:44.607]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.607]                     next
[16:18:44.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.607]                 }
[16:18:44.607]                 if (length(args) > 0) 
[16:18:44.607]                   base::do.call(base::Sys.setenv, args = args)
[16:18:44.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:44.607]             }
[16:18:44.607]             else {
[16:18:44.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:44.607]             }
[16:18:44.607]             {
[16:18:44.607]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:44.607]                   0L) {
[16:18:44.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:44.607]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:44.607]                   base::options(opts)
[16:18:44.607]                 }
[16:18:44.607]                 {
[16:18:44.607]                   {
[16:18:44.607]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:44.607]                     NULL
[16:18:44.607]                   }
[16:18:44.607]                   options(future.plan = NULL)
[16:18:44.607]                   if (is.na(NA_character_)) 
[16:18:44.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:44.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:44.607]                     .init = FALSE)
[16:18:44.607]                 }
[16:18:44.607]             }
[16:18:44.607]         }
[16:18:44.607]     })
[16:18:44.607]     if (TRUE) {
[16:18:44.607]         base::sink(type = "output", split = FALSE)
[16:18:44.607]         if (TRUE) {
[16:18:44.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:44.607]         }
[16:18:44.607]         else {
[16:18:44.607]             ...future.result["stdout"] <- base::list(NULL)
[16:18:44.607]         }
[16:18:44.607]         base::close(...future.stdout)
[16:18:44.607]         ...future.stdout <- NULL
[16:18:44.607]     }
[16:18:44.607]     ...future.result$conditions <- ...future.conditions
[16:18:44.607]     ...future.result$finished <- base::Sys.time()
[16:18:44.607]     ...future.result
[16:18:44.607] }
[16:18:44.610] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[16:18:44.610] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[16:18:44.610] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[16:18:44.611] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:44.611] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.611] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[16:18:44.612] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[16:18:44.612] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:44.612] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.612] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:44.613] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.613] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[16:18:44.613] MultisessionFuture started
[16:18:44.613] - Launch lazy future ... done
[16:18:44.614] run() for ‘MultisessionFuture’ ... done
[16:18:44.614] Created future:
[16:18:44.614] MultisessionFuture:
[16:18:44.614] Label: ‘future_mapply-1’
[16:18:44.614] Expression:
[16:18:44.614] {
[16:18:44.614]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.614]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:44.614]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.614]         on.exit(options(oopts), add = TRUE)
[16:18:44.614]     }
[16:18:44.614]     {
[16:18:44.614]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.614]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:44.614]         do.call(mapply, args = args)
[16:18:44.614]     }
[16:18:44.614] }
[16:18:44.614] Lazy evaluation: FALSE
[16:18:44.614] Asynchronous evaluation: TRUE
[16:18:44.614] Local evaluation: TRUE
[16:18:44.614] Environment: R_GlobalEnv
[16:18:44.614] Capture standard output: TRUE
[16:18:44.614] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:44.614] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:44.614] Packages: <none>
[16:18:44.614] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:44.614] Resolved: FALSE
[16:18:44.614] Value: <not collected>
[16:18:44.614] Conditions captured: <none>
[16:18:44.614] Early signaling: FALSE
[16:18:44.614] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:44.614] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.625] Chunk #1 of 2 ... DONE
[16:18:44.625] Chunk #2 of 2 ...
[16:18:44.625]  - Finding globals in '...' for chunk #2 ...
[16:18:44.625] getGlobalsAndPackages() ...
[16:18:44.626] Searching for globals...
[16:18:44.626] 
[16:18:44.626] Searching for globals ... DONE
[16:18:44.626] - globals: [0] <none>
[16:18:44.626] getGlobalsAndPackages() ... DONE
[16:18:44.626]    + additional globals found: [n=0] 
[16:18:44.626]    + additional namespaces needed: [n=0] 
[16:18:44.626]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:44.627]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:44.627]  - seeds: <none>
[16:18:44.627]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.627] getGlobalsAndPackages() ...
[16:18:44.627] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.627] Resolving globals: FALSE
[16:18:44.627] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:44.628] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:44.628] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.628] 
[16:18:44.628] getGlobalsAndPackages() ... DONE
[16:18:44.629] run() for ‘Future’ ...
[16:18:44.629] - state: ‘created’
[16:18:44.629] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:44.642] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.642] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:44.642]   - Field: ‘node’
[16:18:44.642]   - Field: ‘label’
[16:18:44.642]   - Field: ‘local’
[16:18:44.642]   - Field: ‘owner’
[16:18:44.643]   - Field: ‘envir’
[16:18:44.643]   - Field: ‘workers’
[16:18:44.643]   - Field: ‘packages’
[16:18:44.643]   - Field: ‘gc’
[16:18:44.643]   - Field: ‘conditions’
[16:18:44.643]   - Field: ‘persistent’
[16:18:44.643]   - Field: ‘expr’
[16:18:44.643]   - Field: ‘uuid’
[16:18:44.643]   - Field: ‘seed’
[16:18:44.643]   - Field: ‘version’
[16:18:44.643]   - Field: ‘result’
[16:18:44.644]   - Field: ‘asynchronous’
[16:18:44.644]   - Field: ‘calls’
[16:18:44.644]   - Field: ‘globals’
[16:18:44.644]   - Field: ‘stdout’
[16:18:44.644]   - Field: ‘earlySignal’
[16:18:44.644]   - Field: ‘lazy’
[16:18:44.644]   - Field: ‘state’
[16:18:44.644] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:44.644] - Launch lazy future ...
[16:18:44.645] Packages needed by the future expression (n = 0): <none>
[16:18:44.645] Packages needed by future strategies (n = 0): <none>
[16:18:44.645] {
[16:18:44.645]     {
[16:18:44.645]         {
[16:18:44.645]             ...future.startTime <- base::Sys.time()
[16:18:44.645]             {
[16:18:44.645]                 {
[16:18:44.645]                   {
[16:18:44.645]                     {
[16:18:44.645]                       base::local({
[16:18:44.645]                         has_future <- base::requireNamespace("future", 
[16:18:44.645]                           quietly = TRUE)
[16:18:44.645]                         if (has_future) {
[16:18:44.645]                           ns <- base::getNamespace("future")
[16:18:44.645]                           version <- ns[[".package"]][["version"]]
[16:18:44.645]                           if (is.null(version)) 
[16:18:44.645]                             version <- utils::packageVersion("future")
[16:18:44.645]                         }
[16:18:44.645]                         else {
[16:18:44.645]                           version <- NULL
[16:18:44.645]                         }
[16:18:44.645]                         if (!has_future || version < "1.8.0") {
[16:18:44.645]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:44.645]                             "", base::R.version$version.string), 
[16:18:44.645]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:44.645]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:44.645]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:44.645]                               "release", "version")], collapse = " "), 
[16:18:44.645]                             hostname = base::Sys.info()[["nodename"]])
[16:18:44.645]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:44.645]                             info)
[16:18:44.645]                           info <- base::paste(info, collapse = "; ")
[16:18:44.645]                           if (!has_future) {
[16:18:44.645]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:44.645]                               info)
[16:18:44.645]                           }
[16:18:44.645]                           else {
[16:18:44.645]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:44.645]                               info, version)
[16:18:44.645]                           }
[16:18:44.645]                           base::stop(msg)
[16:18:44.645]                         }
[16:18:44.645]                       })
[16:18:44.645]                     }
[16:18:44.645]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:44.645]                     base::options(mc.cores = 1L)
[16:18:44.645]                   }
[16:18:44.645]                   ...future.strategy.old <- future::plan("list")
[16:18:44.645]                   options(future.plan = NULL)
[16:18:44.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:44.645]                 }
[16:18:44.645]                 ...future.workdir <- getwd()
[16:18:44.645]             }
[16:18:44.645]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:44.645]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:44.645]         }
[16:18:44.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:44.645]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:44.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:44.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:44.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:44.645]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:44.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:44.645]             base::names(...future.oldOptions))
[16:18:44.645]     }
[16:18:44.645]     if (FALSE) {
[16:18:44.645]     }
[16:18:44.645]     else {
[16:18:44.645]         if (TRUE) {
[16:18:44.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:44.645]                 open = "w")
[16:18:44.645]         }
[16:18:44.645]         else {
[16:18:44.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:44.645]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:44.645]         }
[16:18:44.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:44.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:44.645]             base::sink(type = "output", split = FALSE)
[16:18:44.645]             base::close(...future.stdout)
[16:18:44.645]         }, add = TRUE)
[16:18:44.645]     }
[16:18:44.645]     ...future.frame <- base::sys.nframe()
[16:18:44.645]     ...future.conditions <- base::list()
[16:18:44.645]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:44.645]     if (FALSE) {
[16:18:44.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:44.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:44.645]     }
[16:18:44.645]     ...future.result <- base::tryCatch({
[16:18:44.645]         base::withCallingHandlers({
[16:18:44.645]             ...future.value <- base::withVisible(base::local({
[16:18:44.645]                 ...future.makeSendCondition <- base::local({
[16:18:44.645]                   sendCondition <- NULL
[16:18:44.645]                   function(frame = 1L) {
[16:18:44.645]                     if (is.function(sendCondition)) 
[16:18:44.645]                       return(sendCondition)
[16:18:44.645]                     ns <- getNamespace("parallel")
[16:18:44.645]                     if (exists("sendData", mode = "function", 
[16:18:44.645]                       envir = ns)) {
[16:18:44.645]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:44.645]                         envir = ns)
[16:18:44.645]                       envir <- sys.frame(frame)
[16:18:44.645]                       master <- NULL
[16:18:44.645]                       while (!identical(envir, .GlobalEnv) && 
[16:18:44.645]                         !identical(envir, emptyenv())) {
[16:18:44.645]                         if (exists("master", mode = "list", envir = envir, 
[16:18:44.645]                           inherits = FALSE)) {
[16:18:44.645]                           master <- get("master", mode = "list", 
[16:18:44.645]                             envir = envir, inherits = FALSE)
[16:18:44.645]                           if (inherits(master, c("SOCKnode", 
[16:18:44.645]                             "SOCK0node"))) {
[16:18:44.645]                             sendCondition <<- function(cond) {
[16:18:44.645]                               data <- list(type = "VALUE", value = cond, 
[16:18:44.645]                                 success = TRUE)
[16:18:44.645]                               parallel_sendData(master, data)
[16:18:44.645]                             }
[16:18:44.645]                             return(sendCondition)
[16:18:44.645]                           }
[16:18:44.645]                         }
[16:18:44.645]                         frame <- frame + 1L
[16:18:44.645]                         envir <- sys.frame(frame)
[16:18:44.645]                       }
[16:18:44.645]                     }
[16:18:44.645]                     sendCondition <<- function(cond) NULL
[16:18:44.645]                   }
[16:18:44.645]                 })
[16:18:44.645]                 withCallingHandlers({
[16:18:44.645]                   {
[16:18:44.645]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.645]                     if (!identical(...future.globals.maxSize.org, 
[16:18:44.645]                       ...future.globals.maxSize)) {
[16:18:44.645]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.645]                       on.exit(options(oopts), add = TRUE)
[16:18:44.645]                     }
[16:18:44.645]                     {
[16:18:44.645]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.645]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:44.645]                         USE.NAMES = FALSE)
[16:18:44.645]                       do.call(mapply, args = args)
[16:18:44.645]                     }
[16:18:44.645]                   }
[16:18:44.645]                 }, immediateCondition = function(cond) {
[16:18:44.645]                   sendCondition <- ...future.makeSendCondition()
[16:18:44.645]                   sendCondition(cond)
[16:18:44.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.645]                   {
[16:18:44.645]                     inherits <- base::inherits
[16:18:44.645]                     invokeRestart <- base::invokeRestart
[16:18:44.645]                     is.null <- base::is.null
[16:18:44.645]                     muffled <- FALSE
[16:18:44.645]                     if (inherits(cond, "message")) {
[16:18:44.645]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:44.645]                       if (muffled) 
[16:18:44.645]                         invokeRestart("muffleMessage")
[16:18:44.645]                     }
[16:18:44.645]                     else if (inherits(cond, "warning")) {
[16:18:44.645]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:44.645]                       if (muffled) 
[16:18:44.645]                         invokeRestart("muffleWarning")
[16:18:44.645]                     }
[16:18:44.645]                     else if (inherits(cond, "condition")) {
[16:18:44.645]                       if (!is.null(pattern)) {
[16:18:44.645]                         computeRestarts <- base::computeRestarts
[16:18:44.645]                         grepl <- base::grepl
[16:18:44.645]                         restarts <- computeRestarts(cond)
[16:18:44.645]                         for (restart in restarts) {
[16:18:44.645]                           name <- restart$name
[16:18:44.645]                           if (is.null(name)) 
[16:18:44.645]                             next
[16:18:44.645]                           if (!grepl(pattern, name)) 
[16:18:44.645]                             next
[16:18:44.645]                           invokeRestart(restart)
[16:18:44.645]                           muffled <- TRUE
[16:18:44.645]                           break
[16:18:44.645]                         }
[16:18:44.645]                       }
[16:18:44.645]                     }
[16:18:44.645]                     invisible(muffled)
[16:18:44.645]                   }
[16:18:44.645]                   muffleCondition(cond)
[16:18:44.645]                 })
[16:18:44.645]             }))
[16:18:44.645]             future::FutureResult(value = ...future.value$value, 
[16:18:44.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.645]                   ...future.rng), globalenv = if (FALSE) 
[16:18:44.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:44.645]                     ...future.globalenv.names))
[16:18:44.645]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:44.645]         }, condition = base::local({
[16:18:44.645]             c <- base::c
[16:18:44.645]             inherits <- base::inherits
[16:18:44.645]             invokeRestart <- base::invokeRestart
[16:18:44.645]             length <- base::length
[16:18:44.645]             list <- base::list
[16:18:44.645]             seq.int <- base::seq.int
[16:18:44.645]             signalCondition <- base::signalCondition
[16:18:44.645]             sys.calls <- base::sys.calls
[16:18:44.645]             `[[` <- base::`[[`
[16:18:44.645]             `+` <- base::`+`
[16:18:44.645]             `<<-` <- base::`<<-`
[16:18:44.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:44.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:44.645]                   3L)]
[16:18:44.645]             }
[16:18:44.645]             function(cond) {
[16:18:44.645]                 is_error <- inherits(cond, "error")
[16:18:44.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:44.645]                   NULL)
[16:18:44.645]                 if (is_error) {
[16:18:44.645]                   sessionInformation <- function() {
[16:18:44.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:44.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:44.645]                       search = base::search(), system = base::Sys.info())
[16:18:44.645]                   }
[16:18:44.645]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:44.645]                     cond$call), session = sessionInformation(), 
[16:18:44.645]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:44.645]                   signalCondition(cond)
[16:18:44.645]                 }
[16:18:44.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:44.645]                 "immediateCondition"))) {
[16:18:44.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:44.645]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:44.645]                   if (TRUE && !signal) {
[16:18:44.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.645]                     {
[16:18:44.645]                       inherits <- base::inherits
[16:18:44.645]                       invokeRestart <- base::invokeRestart
[16:18:44.645]                       is.null <- base::is.null
[16:18:44.645]                       muffled <- FALSE
[16:18:44.645]                       if (inherits(cond, "message")) {
[16:18:44.645]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.645]                         if (muffled) 
[16:18:44.645]                           invokeRestart("muffleMessage")
[16:18:44.645]                       }
[16:18:44.645]                       else if (inherits(cond, "warning")) {
[16:18:44.645]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.645]                         if (muffled) 
[16:18:44.645]                           invokeRestart("muffleWarning")
[16:18:44.645]                       }
[16:18:44.645]                       else if (inherits(cond, "condition")) {
[16:18:44.645]                         if (!is.null(pattern)) {
[16:18:44.645]                           computeRestarts <- base::computeRestarts
[16:18:44.645]                           grepl <- base::grepl
[16:18:44.645]                           restarts <- computeRestarts(cond)
[16:18:44.645]                           for (restart in restarts) {
[16:18:44.645]                             name <- restart$name
[16:18:44.645]                             if (is.null(name)) 
[16:18:44.645]                               next
[16:18:44.645]                             if (!grepl(pattern, name)) 
[16:18:44.645]                               next
[16:18:44.645]                             invokeRestart(restart)
[16:18:44.645]                             muffled <- TRUE
[16:18:44.645]                             break
[16:18:44.645]                           }
[16:18:44.645]                         }
[16:18:44.645]                       }
[16:18:44.645]                       invisible(muffled)
[16:18:44.645]                     }
[16:18:44.645]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.645]                   }
[16:18:44.645]                 }
[16:18:44.645]                 else {
[16:18:44.645]                   if (TRUE) {
[16:18:44.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.645]                     {
[16:18:44.645]                       inherits <- base::inherits
[16:18:44.645]                       invokeRestart <- base::invokeRestart
[16:18:44.645]                       is.null <- base::is.null
[16:18:44.645]                       muffled <- FALSE
[16:18:44.645]                       if (inherits(cond, "message")) {
[16:18:44.645]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.645]                         if (muffled) 
[16:18:44.645]                           invokeRestart("muffleMessage")
[16:18:44.645]                       }
[16:18:44.645]                       else if (inherits(cond, "warning")) {
[16:18:44.645]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.645]                         if (muffled) 
[16:18:44.645]                           invokeRestart("muffleWarning")
[16:18:44.645]                       }
[16:18:44.645]                       else if (inherits(cond, "condition")) {
[16:18:44.645]                         if (!is.null(pattern)) {
[16:18:44.645]                           computeRestarts <- base::computeRestarts
[16:18:44.645]                           grepl <- base::grepl
[16:18:44.645]                           restarts <- computeRestarts(cond)
[16:18:44.645]                           for (restart in restarts) {
[16:18:44.645]                             name <- restart$name
[16:18:44.645]                             if (is.null(name)) 
[16:18:44.645]                               next
[16:18:44.645]                             if (!grepl(pattern, name)) 
[16:18:44.645]                               next
[16:18:44.645]                             invokeRestart(restart)
[16:18:44.645]                             muffled <- TRUE
[16:18:44.645]                             break
[16:18:44.645]                           }
[16:18:44.645]                         }
[16:18:44.645]                       }
[16:18:44.645]                       invisible(muffled)
[16:18:44.645]                     }
[16:18:44.645]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.645]                   }
[16:18:44.645]                 }
[16:18:44.645]             }
[16:18:44.645]         }))
[16:18:44.645]     }, error = function(ex) {
[16:18:44.645]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:44.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.645]                 ...future.rng), started = ...future.startTime, 
[16:18:44.645]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:44.645]             version = "1.8"), class = "FutureResult")
[16:18:44.645]     }, finally = {
[16:18:44.645]         if (!identical(...future.workdir, getwd())) 
[16:18:44.645]             setwd(...future.workdir)
[16:18:44.645]         {
[16:18:44.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:44.645]                 ...future.oldOptions$nwarnings <- NULL
[16:18:44.645]             }
[16:18:44.645]             base::options(...future.oldOptions)
[16:18:44.645]             if (.Platform$OS.type == "windows") {
[16:18:44.645]                 old_names <- names(...future.oldEnvVars)
[16:18:44.645]                 envs <- base::Sys.getenv()
[16:18:44.645]                 names <- names(envs)
[16:18:44.645]                 common <- intersect(names, old_names)
[16:18:44.645]                 added <- setdiff(names, old_names)
[16:18:44.645]                 removed <- setdiff(old_names, names)
[16:18:44.645]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:44.645]                   envs[common]]
[16:18:44.645]                 NAMES <- toupper(changed)
[16:18:44.645]                 args <- list()
[16:18:44.645]                 for (kk in seq_along(NAMES)) {
[16:18:44.645]                   name <- changed[[kk]]
[16:18:44.645]                   NAME <- NAMES[[kk]]
[16:18:44.645]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.645]                     next
[16:18:44.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.645]                 }
[16:18:44.645]                 NAMES <- toupper(added)
[16:18:44.645]                 for (kk in seq_along(NAMES)) {
[16:18:44.645]                   name <- added[[kk]]
[16:18:44.645]                   NAME <- NAMES[[kk]]
[16:18:44.645]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.645]                     next
[16:18:44.645]                   args[[name]] <- ""
[16:18:44.645]                 }
[16:18:44.645]                 NAMES <- toupper(removed)
[16:18:44.645]                 for (kk in seq_along(NAMES)) {
[16:18:44.645]                   name <- removed[[kk]]
[16:18:44.645]                   NAME <- NAMES[[kk]]
[16:18:44.645]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.645]                     next
[16:18:44.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.645]                 }
[16:18:44.645]                 if (length(args) > 0) 
[16:18:44.645]                   base::do.call(base::Sys.setenv, args = args)
[16:18:44.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:44.645]             }
[16:18:44.645]             else {
[16:18:44.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:44.645]             }
[16:18:44.645]             {
[16:18:44.645]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:44.645]                   0L) {
[16:18:44.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:44.645]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:44.645]                   base::options(opts)
[16:18:44.645]                 }
[16:18:44.645]                 {
[16:18:44.645]                   {
[16:18:44.645]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:44.645]                     NULL
[16:18:44.645]                   }
[16:18:44.645]                   options(future.plan = NULL)
[16:18:44.645]                   if (is.na(NA_character_)) 
[16:18:44.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:44.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:44.645]                     .init = FALSE)
[16:18:44.645]                 }
[16:18:44.645]             }
[16:18:44.645]         }
[16:18:44.645]     })
[16:18:44.645]     if (TRUE) {
[16:18:44.645]         base::sink(type = "output", split = FALSE)
[16:18:44.645]         if (TRUE) {
[16:18:44.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:44.645]         }
[16:18:44.645]         else {
[16:18:44.645]             ...future.result["stdout"] <- base::list(NULL)
[16:18:44.645]         }
[16:18:44.645]         base::close(...future.stdout)
[16:18:44.645]         ...future.stdout <- NULL
[16:18:44.645]     }
[16:18:44.645]     ...future.result$conditions <- ...future.conditions
[16:18:44.645]     ...future.result$finished <- base::Sys.time()
[16:18:44.645]     ...future.result
[16:18:44.645] }
[16:18:44.648] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[16:18:44.648] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[16:18:44.648] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[16:18:44.648] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:44.649] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:44.649] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[16:18:44.649] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[16:18:44.649] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:44.649] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:44.650] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:44.653] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:44.653] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[16:18:44.654] MultisessionFuture started
[16:18:44.654] - Launch lazy future ... done
[16:18:44.654] run() for ‘MultisessionFuture’ ... done
[16:18:44.654] Created future:
[16:18:44.654] MultisessionFuture:
[16:18:44.654] Label: ‘future_mapply-2’
[16:18:44.654] Expression:
[16:18:44.654] {
[16:18:44.654]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.654]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:44.654]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.654]         on.exit(options(oopts), add = TRUE)
[16:18:44.654]     }
[16:18:44.654]     {
[16:18:44.654]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.654]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:44.654]         do.call(mapply, args = args)
[16:18:44.654]     }
[16:18:44.654] }
[16:18:44.654] Lazy evaluation: FALSE
[16:18:44.654] Asynchronous evaluation: TRUE
[16:18:44.654] Local evaluation: TRUE
[16:18:44.654] Environment: R_GlobalEnv
[16:18:44.654] Capture standard output: TRUE
[16:18:44.654] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:44.654] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:44.654] Packages: <none>
[16:18:44.654] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:44.654] Resolved: FALSE
[16:18:44.654] Value: <not collected>
[16:18:44.654] Conditions captured: <none>
[16:18:44.654] Early signaling: FALSE
[16:18:44.654] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:44.654] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.666] Chunk #2 of 2 ... DONE
[16:18:44.666] Launching 2 futures (chunks) ... DONE
[16:18:44.666] Resolving 2 futures (chunks) ...
[16:18:44.666] resolve() on list ...
[16:18:44.666]  recursive: 0
[16:18:44.666]  length: 2
[16:18:44.666] 
[16:18:44.667] receiveMessageFromWorker() for ClusterFuture ...
[16:18:44.667] - Validating connection of MultisessionFuture
[16:18:44.667] - received message: FutureResult
[16:18:44.667] - Received FutureResult
[16:18:44.667] - Erased future from FutureRegistry
[16:18:44.667] result() for ClusterFuture ...
[16:18:44.668] - result already collected: FutureResult
[16:18:44.668] result() for ClusterFuture ... done
[16:18:44.668] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:44.668] Future #1
[16:18:44.668] result() for ClusterFuture ...
[16:18:44.668] - result already collected: FutureResult
[16:18:44.668] result() for ClusterFuture ... done
[16:18:44.668] result() for ClusterFuture ...
[16:18:44.668] - result already collected: FutureResult
[16:18:44.668] result() for ClusterFuture ... done
[16:18:44.669] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:44.669] - nx: 2
[16:18:44.669] - relay: TRUE
[16:18:44.669] - stdout: TRUE
[16:18:44.669] - signal: TRUE
[16:18:44.669] - resignal: FALSE
[16:18:44.669] - force: TRUE
[16:18:44.669] - relayed: [n=2] FALSE, FALSE
[16:18:44.669] - queued futures: [n=2] FALSE, FALSE
[16:18:44.669]  - until=1
[16:18:44.669]  - relaying element #1
[16:18:44.669] result() for ClusterFuture ...
[16:18:44.670] - result already collected: FutureResult
[16:18:44.670] result() for ClusterFuture ... done
[16:18:44.670] result() for ClusterFuture ...
[16:18:44.670] - result already collected: FutureResult
[16:18:44.670] result() for ClusterFuture ... done
[16:18:44.670] result() for ClusterFuture ...
[16:18:44.670] - result already collected: FutureResult
[16:18:44.670] result() for ClusterFuture ... done
[16:18:44.670] result() for ClusterFuture ...
[16:18:44.670] - result already collected: FutureResult
[16:18:44.670] result() for ClusterFuture ... done
[16:18:44.671] - relayed: [n=2] TRUE, FALSE
[16:18:44.671] - queued futures: [n=2] TRUE, FALSE
[16:18:44.671] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:44.671]  length: 1 (resolved future 1)
[16:18:44.698] receiveMessageFromWorker() for ClusterFuture ...
[16:18:44.698] - Validating connection of MultisessionFuture
[16:18:44.698] - received message: FutureResult
[16:18:44.698] - Received FutureResult
[16:18:44.698] - Erased future from FutureRegistry
[16:18:44.698] result() for ClusterFuture ...
[16:18:44.698] - result already collected: FutureResult
[16:18:44.699] result() for ClusterFuture ... done
[16:18:44.699] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:44.699] Future #2
[16:18:44.699] result() for ClusterFuture ...
[16:18:44.699] - result already collected: FutureResult
[16:18:44.699] result() for ClusterFuture ... done
[16:18:44.699] result() for ClusterFuture ...
[16:18:44.699] - result already collected: FutureResult
[16:18:44.699] result() for ClusterFuture ... done
[16:18:44.699] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:44.699] - nx: 2
[16:18:44.700] - relay: TRUE
[16:18:44.700] - stdout: TRUE
[16:18:44.700] - signal: TRUE
[16:18:44.700] - resignal: FALSE
[16:18:44.700] - force: TRUE
[16:18:44.700] - relayed: [n=2] TRUE, FALSE
[16:18:44.700] - queued futures: [n=2] TRUE, FALSE
[16:18:44.700]  - until=2
[16:18:44.700]  - relaying element #2
[16:18:44.700] result() for ClusterFuture ...
[16:18:44.701] - result already collected: FutureResult
[16:18:44.701] result() for ClusterFuture ... done
[16:18:44.701] result() for ClusterFuture ...
[16:18:44.701] - result already collected: FutureResult
[16:18:44.701] result() for ClusterFuture ... done
[16:18:44.701] result() for ClusterFuture ...
[16:18:44.701] - result already collected: FutureResult
[16:18:44.701] result() for ClusterFuture ... done
[16:18:44.701] result() for ClusterFuture ...
[16:18:44.701] - result already collected: FutureResult
[16:18:44.701] result() for ClusterFuture ... done
[16:18:44.702] - relayed: [n=2] TRUE, TRUE
[16:18:44.702] - queued futures: [n=2] TRUE, TRUE
[16:18:44.702] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:44.702]  length: 0 (resolved future 2)
[16:18:44.702] Relaying remaining futures
[16:18:44.702] signalConditionsASAP(NULL, pos=0) ...
[16:18:44.702] - nx: 2
[16:18:44.702] - relay: TRUE
[16:18:44.702] - stdout: TRUE
[16:18:44.702] - signal: TRUE
[16:18:44.702] - resignal: FALSE
[16:18:44.702] - force: TRUE
[16:18:44.703] - relayed: [n=2] TRUE, TRUE
[16:18:44.703] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:44.703] - relayed: [n=2] TRUE, TRUE
[16:18:44.703] - queued futures: [n=2] TRUE, TRUE
[16:18:44.703] signalConditionsASAP(NULL, pos=0) ... done
[16:18:44.703] resolve() on list ... DONE
[16:18:44.703] result() for ClusterFuture ...
[16:18:44.703] - result already collected: FutureResult
[16:18:44.703] result() for ClusterFuture ... done
[16:18:44.703] result() for ClusterFuture ...
[16:18:44.704] - result already collected: FutureResult
[16:18:44.704] result() for ClusterFuture ... done
[16:18:44.704] result() for ClusterFuture ...
[16:18:44.704] - result already collected: FutureResult
[16:18:44.704] result() for ClusterFuture ... done
[16:18:44.704] result() for ClusterFuture ...
[16:18:44.704] - result already collected: FutureResult
[16:18:44.704] result() for ClusterFuture ... done
[16:18:44.704]  - Number of value chunks collected: 2
[16:18:44.704] Resolving 2 futures (chunks) ... DONE
[16:18:44.704] Reducing values from 2 chunks ...
[16:18:44.705]  - Number of values collected after concatenation: 4
[16:18:44.705]  - Number of values expected: 4
[16:18:44.705] Reducing values from 2 chunks ... DONE
[16:18:44.705] future_mapply() ... DONE
[16:18:44.705] future_mapply() ...
[16:18:44.709] Number of chunks: 2
[16:18:44.709] getGlobalsAndPackagesXApply() ...
[16:18:44.709]  - future.globals: TRUE
[16:18:44.709] getGlobalsAndPackages() ...
[16:18:44.709] Searching for globals...
[16:18:44.710] - globals found: [1] ‘FUN’
[16:18:44.710] Searching for globals ... DONE
[16:18:44.710] Resolving globals: FALSE
[16:18:44.710] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:44.711] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:44.711] - globals: [1] ‘FUN’
[16:18:44.711] 
[16:18:44.711] getGlobalsAndPackages() ... DONE
[16:18:44.711]  - globals found/used: [n=1] ‘FUN’
[16:18:44.711]  - needed namespaces: [n=0] 
[16:18:44.711] Finding globals ... DONE
[16:18:44.712] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:44.712] List of 2
[16:18:44.712]  $ ...future.FUN:function (x, ...)  
[16:18:44.712]  $ MoreArgs     : NULL
[16:18:44.712]  - attr(*, "where")=List of 2
[16:18:44.712]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:44.712]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:44.712]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:44.712]  - attr(*, "resolved")= logi FALSE
[16:18:44.712]  - attr(*, "total_size")= num NA
[16:18:44.714] Packages to be attached in all futures: [n=0] 
[16:18:44.714] getGlobalsAndPackagesXApply() ... DONE
[16:18:44.715] Number of futures (= number of chunks): 2
[16:18:44.715] Launching 2 futures (chunks) ...
[16:18:44.715] Chunk #1 of 2 ...
[16:18:44.715]  - Finding globals in '...' for chunk #1 ...
[16:18:44.715] getGlobalsAndPackages() ...
[16:18:44.715] Searching for globals...
[16:18:44.716] 
[16:18:44.716] Searching for globals ... DONE
[16:18:44.716] - globals: [0] <none>
[16:18:44.716] getGlobalsAndPackages() ... DONE
[16:18:44.716]    + additional globals found: [n=0] 
[16:18:44.716]    + additional namespaces needed: [n=0] 
[16:18:44.716]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:44.716]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:44.716]  - seeds: <none>
[16:18:44.716]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.717] getGlobalsAndPackages() ...
[16:18:44.717] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.717] Resolving globals: FALSE
[16:18:44.717] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:44.718] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:44.718] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.718] 
[16:18:44.718] getGlobalsAndPackages() ... DONE
[16:18:44.718] run() for ‘Future’ ...
[16:18:44.718] - state: ‘created’
[16:18:44.719] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:44.733] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.734] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:44.734]   - Field: ‘node’
[16:18:44.734]   - Field: ‘label’
[16:18:44.734]   - Field: ‘local’
[16:18:44.734]   - Field: ‘owner’
[16:18:44.734]   - Field: ‘envir’
[16:18:44.736]   - Field: ‘workers’
[16:18:44.737]   - Field: ‘packages’
[16:18:44.737]   - Field: ‘gc’
[16:18:44.737]   - Field: ‘conditions’
[16:18:44.737]   - Field: ‘persistent’
[16:18:44.737]   - Field: ‘expr’
[16:18:44.737]   - Field: ‘uuid’
[16:18:44.737]   - Field: ‘seed’
[16:18:44.737]   - Field: ‘version’
[16:18:44.737]   - Field: ‘result’
[16:18:44.737]   - Field: ‘asynchronous’
[16:18:44.737]   - Field: ‘calls’
[16:18:44.737]   - Field: ‘globals’
[16:18:44.738]   - Field: ‘stdout’
[16:18:44.738]   - Field: ‘earlySignal’
[16:18:44.738]   - Field: ‘lazy’
[16:18:44.738]   - Field: ‘state’
[16:18:44.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:44.738] - Launch lazy future ...
[16:18:44.738] Packages needed by the future expression (n = 0): <none>
[16:18:44.738] Packages needed by future strategies (n = 0): <none>
[16:18:44.739] {
[16:18:44.739]     {
[16:18:44.739]         {
[16:18:44.739]             ...future.startTime <- base::Sys.time()
[16:18:44.739]             {
[16:18:44.739]                 {
[16:18:44.739]                   {
[16:18:44.739]                     {
[16:18:44.739]                       base::local({
[16:18:44.739]                         has_future <- base::requireNamespace("future", 
[16:18:44.739]                           quietly = TRUE)
[16:18:44.739]                         if (has_future) {
[16:18:44.739]                           ns <- base::getNamespace("future")
[16:18:44.739]                           version <- ns[[".package"]][["version"]]
[16:18:44.739]                           if (is.null(version)) 
[16:18:44.739]                             version <- utils::packageVersion("future")
[16:18:44.739]                         }
[16:18:44.739]                         else {
[16:18:44.739]                           version <- NULL
[16:18:44.739]                         }
[16:18:44.739]                         if (!has_future || version < "1.8.0") {
[16:18:44.739]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:44.739]                             "", base::R.version$version.string), 
[16:18:44.739]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:44.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:44.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:44.739]                               "release", "version")], collapse = " "), 
[16:18:44.739]                             hostname = base::Sys.info()[["nodename"]])
[16:18:44.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:44.739]                             info)
[16:18:44.739]                           info <- base::paste(info, collapse = "; ")
[16:18:44.739]                           if (!has_future) {
[16:18:44.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:44.739]                               info)
[16:18:44.739]                           }
[16:18:44.739]                           else {
[16:18:44.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:44.739]                               info, version)
[16:18:44.739]                           }
[16:18:44.739]                           base::stop(msg)
[16:18:44.739]                         }
[16:18:44.739]                       })
[16:18:44.739]                     }
[16:18:44.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:44.739]                     base::options(mc.cores = 1L)
[16:18:44.739]                   }
[16:18:44.739]                   ...future.strategy.old <- future::plan("list")
[16:18:44.739]                   options(future.plan = NULL)
[16:18:44.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:44.739]                 }
[16:18:44.739]                 ...future.workdir <- getwd()
[16:18:44.739]             }
[16:18:44.739]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:44.739]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:44.739]         }
[16:18:44.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:44.739]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:44.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:44.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:44.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:44.739]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:44.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:44.739]             base::names(...future.oldOptions))
[16:18:44.739]     }
[16:18:44.739]     if (FALSE) {
[16:18:44.739]     }
[16:18:44.739]     else {
[16:18:44.739]         if (TRUE) {
[16:18:44.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:44.739]                 open = "w")
[16:18:44.739]         }
[16:18:44.739]         else {
[16:18:44.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:44.739]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:44.739]         }
[16:18:44.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:44.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:44.739]             base::sink(type = "output", split = FALSE)
[16:18:44.739]             base::close(...future.stdout)
[16:18:44.739]         }, add = TRUE)
[16:18:44.739]     }
[16:18:44.739]     ...future.frame <- base::sys.nframe()
[16:18:44.739]     ...future.conditions <- base::list()
[16:18:44.739]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:44.739]     if (FALSE) {
[16:18:44.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:44.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:44.739]     }
[16:18:44.739]     ...future.result <- base::tryCatch({
[16:18:44.739]         base::withCallingHandlers({
[16:18:44.739]             ...future.value <- base::withVisible(base::local({
[16:18:44.739]                 ...future.makeSendCondition <- base::local({
[16:18:44.739]                   sendCondition <- NULL
[16:18:44.739]                   function(frame = 1L) {
[16:18:44.739]                     if (is.function(sendCondition)) 
[16:18:44.739]                       return(sendCondition)
[16:18:44.739]                     ns <- getNamespace("parallel")
[16:18:44.739]                     if (exists("sendData", mode = "function", 
[16:18:44.739]                       envir = ns)) {
[16:18:44.739]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:44.739]                         envir = ns)
[16:18:44.739]                       envir <- sys.frame(frame)
[16:18:44.739]                       master <- NULL
[16:18:44.739]                       while (!identical(envir, .GlobalEnv) && 
[16:18:44.739]                         !identical(envir, emptyenv())) {
[16:18:44.739]                         if (exists("master", mode = "list", envir = envir, 
[16:18:44.739]                           inherits = FALSE)) {
[16:18:44.739]                           master <- get("master", mode = "list", 
[16:18:44.739]                             envir = envir, inherits = FALSE)
[16:18:44.739]                           if (inherits(master, c("SOCKnode", 
[16:18:44.739]                             "SOCK0node"))) {
[16:18:44.739]                             sendCondition <<- function(cond) {
[16:18:44.739]                               data <- list(type = "VALUE", value = cond, 
[16:18:44.739]                                 success = TRUE)
[16:18:44.739]                               parallel_sendData(master, data)
[16:18:44.739]                             }
[16:18:44.739]                             return(sendCondition)
[16:18:44.739]                           }
[16:18:44.739]                         }
[16:18:44.739]                         frame <- frame + 1L
[16:18:44.739]                         envir <- sys.frame(frame)
[16:18:44.739]                       }
[16:18:44.739]                     }
[16:18:44.739]                     sendCondition <<- function(cond) NULL
[16:18:44.739]                   }
[16:18:44.739]                 })
[16:18:44.739]                 withCallingHandlers({
[16:18:44.739]                   {
[16:18:44.739]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.739]                     if (!identical(...future.globals.maxSize.org, 
[16:18:44.739]                       ...future.globals.maxSize)) {
[16:18:44.739]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.739]                       on.exit(options(oopts), add = TRUE)
[16:18:44.739]                     }
[16:18:44.739]                     {
[16:18:44.739]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.739]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:44.739]                         USE.NAMES = FALSE)
[16:18:44.739]                       do.call(mapply, args = args)
[16:18:44.739]                     }
[16:18:44.739]                   }
[16:18:44.739]                 }, immediateCondition = function(cond) {
[16:18:44.739]                   sendCondition <- ...future.makeSendCondition()
[16:18:44.739]                   sendCondition(cond)
[16:18:44.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.739]                   {
[16:18:44.739]                     inherits <- base::inherits
[16:18:44.739]                     invokeRestart <- base::invokeRestart
[16:18:44.739]                     is.null <- base::is.null
[16:18:44.739]                     muffled <- FALSE
[16:18:44.739]                     if (inherits(cond, "message")) {
[16:18:44.739]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:44.739]                       if (muffled) 
[16:18:44.739]                         invokeRestart("muffleMessage")
[16:18:44.739]                     }
[16:18:44.739]                     else if (inherits(cond, "warning")) {
[16:18:44.739]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:44.739]                       if (muffled) 
[16:18:44.739]                         invokeRestart("muffleWarning")
[16:18:44.739]                     }
[16:18:44.739]                     else if (inherits(cond, "condition")) {
[16:18:44.739]                       if (!is.null(pattern)) {
[16:18:44.739]                         computeRestarts <- base::computeRestarts
[16:18:44.739]                         grepl <- base::grepl
[16:18:44.739]                         restarts <- computeRestarts(cond)
[16:18:44.739]                         for (restart in restarts) {
[16:18:44.739]                           name <- restart$name
[16:18:44.739]                           if (is.null(name)) 
[16:18:44.739]                             next
[16:18:44.739]                           if (!grepl(pattern, name)) 
[16:18:44.739]                             next
[16:18:44.739]                           invokeRestart(restart)
[16:18:44.739]                           muffled <- TRUE
[16:18:44.739]                           break
[16:18:44.739]                         }
[16:18:44.739]                       }
[16:18:44.739]                     }
[16:18:44.739]                     invisible(muffled)
[16:18:44.739]                   }
[16:18:44.739]                   muffleCondition(cond)
[16:18:44.739]                 })
[16:18:44.739]             }))
[16:18:44.739]             future::FutureResult(value = ...future.value$value, 
[16:18:44.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.739]                   ...future.rng), globalenv = if (FALSE) 
[16:18:44.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:44.739]                     ...future.globalenv.names))
[16:18:44.739]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:44.739]         }, condition = base::local({
[16:18:44.739]             c <- base::c
[16:18:44.739]             inherits <- base::inherits
[16:18:44.739]             invokeRestart <- base::invokeRestart
[16:18:44.739]             length <- base::length
[16:18:44.739]             list <- base::list
[16:18:44.739]             seq.int <- base::seq.int
[16:18:44.739]             signalCondition <- base::signalCondition
[16:18:44.739]             sys.calls <- base::sys.calls
[16:18:44.739]             `[[` <- base::`[[`
[16:18:44.739]             `+` <- base::`+`
[16:18:44.739]             `<<-` <- base::`<<-`
[16:18:44.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:44.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:44.739]                   3L)]
[16:18:44.739]             }
[16:18:44.739]             function(cond) {
[16:18:44.739]                 is_error <- inherits(cond, "error")
[16:18:44.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:44.739]                   NULL)
[16:18:44.739]                 if (is_error) {
[16:18:44.739]                   sessionInformation <- function() {
[16:18:44.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:44.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:44.739]                       search = base::search(), system = base::Sys.info())
[16:18:44.739]                   }
[16:18:44.739]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:44.739]                     cond$call), session = sessionInformation(), 
[16:18:44.739]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:44.739]                   signalCondition(cond)
[16:18:44.739]                 }
[16:18:44.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:44.739]                 "immediateCondition"))) {
[16:18:44.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:44.739]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:44.739]                   if (TRUE && !signal) {
[16:18:44.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.739]                     {
[16:18:44.739]                       inherits <- base::inherits
[16:18:44.739]                       invokeRestart <- base::invokeRestart
[16:18:44.739]                       is.null <- base::is.null
[16:18:44.739]                       muffled <- FALSE
[16:18:44.739]                       if (inherits(cond, "message")) {
[16:18:44.739]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.739]                         if (muffled) 
[16:18:44.739]                           invokeRestart("muffleMessage")
[16:18:44.739]                       }
[16:18:44.739]                       else if (inherits(cond, "warning")) {
[16:18:44.739]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.739]                         if (muffled) 
[16:18:44.739]                           invokeRestart("muffleWarning")
[16:18:44.739]                       }
[16:18:44.739]                       else if (inherits(cond, "condition")) {
[16:18:44.739]                         if (!is.null(pattern)) {
[16:18:44.739]                           computeRestarts <- base::computeRestarts
[16:18:44.739]                           grepl <- base::grepl
[16:18:44.739]                           restarts <- computeRestarts(cond)
[16:18:44.739]                           for (restart in restarts) {
[16:18:44.739]                             name <- restart$name
[16:18:44.739]                             if (is.null(name)) 
[16:18:44.739]                               next
[16:18:44.739]                             if (!grepl(pattern, name)) 
[16:18:44.739]                               next
[16:18:44.739]                             invokeRestart(restart)
[16:18:44.739]                             muffled <- TRUE
[16:18:44.739]                             break
[16:18:44.739]                           }
[16:18:44.739]                         }
[16:18:44.739]                       }
[16:18:44.739]                       invisible(muffled)
[16:18:44.739]                     }
[16:18:44.739]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.739]                   }
[16:18:44.739]                 }
[16:18:44.739]                 else {
[16:18:44.739]                   if (TRUE) {
[16:18:44.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.739]                     {
[16:18:44.739]                       inherits <- base::inherits
[16:18:44.739]                       invokeRestart <- base::invokeRestart
[16:18:44.739]                       is.null <- base::is.null
[16:18:44.739]                       muffled <- FALSE
[16:18:44.739]                       if (inherits(cond, "message")) {
[16:18:44.739]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.739]                         if (muffled) 
[16:18:44.739]                           invokeRestart("muffleMessage")
[16:18:44.739]                       }
[16:18:44.739]                       else if (inherits(cond, "warning")) {
[16:18:44.739]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.739]                         if (muffled) 
[16:18:44.739]                           invokeRestart("muffleWarning")
[16:18:44.739]                       }
[16:18:44.739]                       else if (inherits(cond, "condition")) {
[16:18:44.739]                         if (!is.null(pattern)) {
[16:18:44.739]                           computeRestarts <- base::computeRestarts
[16:18:44.739]                           grepl <- base::grepl
[16:18:44.739]                           restarts <- computeRestarts(cond)
[16:18:44.739]                           for (restart in restarts) {
[16:18:44.739]                             name <- restart$name
[16:18:44.739]                             if (is.null(name)) 
[16:18:44.739]                               next
[16:18:44.739]                             if (!grepl(pattern, name)) 
[16:18:44.739]                               next
[16:18:44.739]                             invokeRestart(restart)
[16:18:44.739]                             muffled <- TRUE
[16:18:44.739]                             break
[16:18:44.739]                           }
[16:18:44.739]                         }
[16:18:44.739]                       }
[16:18:44.739]                       invisible(muffled)
[16:18:44.739]                     }
[16:18:44.739]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.739]                   }
[16:18:44.739]                 }
[16:18:44.739]             }
[16:18:44.739]         }))
[16:18:44.739]     }, error = function(ex) {
[16:18:44.739]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:44.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.739]                 ...future.rng), started = ...future.startTime, 
[16:18:44.739]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:44.739]             version = "1.8"), class = "FutureResult")
[16:18:44.739]     }, finally = {
[16:18:44.739]         if (!identical(...future.workdir, getwd())) 
[16:18:44.739]             setwd(...future.workdir)
[16:18:44.739]         {
[16:18:44.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:44.739]                 ...future.oldOptions$nwarnings <- NULL
[16:18:44.739]             }
[16:18:44.739]             base::options(...future.oldOptions)
[16:18:44.739]             if (.Platform$OS.type == "windows") {
[16:18:44.739]                 old_names <- names(...future.oldEnvVars)
[16:18:44.739]                 envs <- base::Sys.getenv()
[16:18:44.739]                 names <- names(envs)
[16:18:44.739]                 common <- intersect(names, old_names)
[16:18:44.739]                 added <- setdiff(names, old_names)
[16:18:44.739]                 removed <- setdiff(old_names, names)
[16:18:44.739]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:44.739]                   envs[common]]
[16:18:44.739]                 NAMES <- toupper(changed)
[16:18:44.739]                 args <- list()
[16:18:44.739]                 for (kk in seq_along(NAMES)) {
[16:18:44.739]                   name <- changed[[kk]]
[16:18:44.739]                   NAME <- NAMES[[kk]]
[16:18:44.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.739]                     next
[16:18:44.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.739]                 }
[16:18:44.739]                 NAMES <- toupper(added)
[16:18:44.739]                 for (kk in seq_along(NAMES)) {
[16:18:44.739]                   name <- added[[kk]]
[16:18:44.739]                   NAME <- NAMES[[kk]]
[16:18:44.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.739]                     next
[16:18:44.739]                   args[[name]] <- ""
[16:18:44.739]                 }
[16:18:44.739]                 NAMES <- toupper(removed)
[16:18:44.739]                 for (kk in seq_along(NAMES)) {
[16:18:44.739]                   name <- removed[[kk]]
[16:18:44.739]                   NAME <- NAMES[[kk]]
[16:18:44.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.739]                     next
[16:18:44.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.739]                 }
[16:18:44.739]                 if (length(args) > 0) 
[16:18:44.739]                   base::do.call(base::Sys.setenv, args = args)
[16:18:44.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:44.739]             }
[16:18:44.739]             else {
[16:18:44.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:44.739]             }
[16:18:44.739]             {
[16:18:44.739]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:44.739]                   0L) {
[16:18:44.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:44.739]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:44.739]                   base::options(opts)
[16:18:44.739]                 }
[16:18:44.739]                 {
[16:18:44.739]                   {
[16:18:44.739]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:44.739]                     NULL
[16:18:44.739]                   }
[16:18:44.739]                   options(future.plan = NULL)
[16:18:44.739]                   if (is.na(NA_character_)) 
[16:18:44.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:44.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:44.739]                     .init = FALSE)
[16:18:44.739]                 }
[16:18:44.739]             }
[16:18:44.739]         }
[16:18:44.739]     })
[16:18:44.739]     if (TRUE) {
[16:18:44.739]         base::sink(type = "output", split = FALSE)
[16:18:44.739]         if (TRUE) {
[16:18:44.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:44.739]         }
[16:18:44.739]         else {
[16:18:44.739]             ...future.result["stdout"] <- base::list(NULL)
[16:18:44.739]         }
[16:18:44.739]         base::close(...future.stdout)
[16:18:44.739]         ...future.stdout <- NULL
[16:18:44.739]     }
[16:18:44.739]     ...future.result$conditions <- ...future.conditions
[16:18:44.739]     ...future.result$finished <- base::Sys.time()
[16:18:44.739]     ...future.result
[16:18:44.739] }
[16:18:44.742] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[16:18:44.742] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[16:18:44.742] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[16:18:44.742] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:44.743] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.743] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[16:18:44.743] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[16:18:44.743] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:44.744] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.744] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:44.744] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.744] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[16:18:44.745] MultisessionFuture started
[16:18:44.745] - Launch lazy future ... done
[16:18:44.745] run() for ‘MultisessionFuture’ ... done
[16:18:44.745] Created future:
[16:18:44.746] MultisessionFuture:
[16:18:44.746] Label: ‘future_mapply-1’
[16:18:44.746] Expression:
[16:18:44.746] {
[16:18:44.746]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.746]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:44.746]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.746]         on.exit(options(oopts), add = TRUE)
[16:18:44.746]     }
[16:18:44.746]     {
[16:18:44.746]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.746]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:44.746]         do.call(mapply, args = args)
[16:18:44.746]     }
[16:18:44.746] }
[16:18:44.746] Lazy evaluation: FALSE
[16:18:44.746] Asynchronous evaluation: TRUE
[16:18:44.746] Local evaluation: TRUE
[16:18:44.746] Environment: R_GlobalEnv
[16:18:44.746] Capture standard output: TRUE
[16:18:44.746] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:44.746] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:44.746] Packages: <none>
[16:18:44.746] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:44.746] Resolved: FALSE
[16:18:44.746] Value: <not collected>
[16:18:44.746] Conditions captured: <none>
[16:18:44.746] Early signaling: FALSE
[16:18:44.746] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:44.746] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.757] Chunk #1 of 2 ... DONE
[16:18:44.757] Chunk #2 of 2 ...
[16:18:44.757]  - Finding globals in '...' for chunk #2 ...
[16:18:44.757] getGlobalsAndPackages() ...
[16:18:44.757] Searching for globals...
[16:18:44.758] 
[16:18:44.758] Searching for globals ... DONE
[16:18:44.758] - globals: [0] <none>
[16:18:44.758] getGlobalsAndPackages() ... DONE
[16:18:44.758]    + additional globals found: [n=0] 
[16:18:44.758]    + additional namespaces needed: [n=0] 
[16:18:44.758]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:44.758]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:44.758]  - seeds: <none>
[16:18:44.759]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.759] getGlobalsAndPackages() ...
[16:18:44.759] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.759] Resolving globals: FALSE
[16:18:44.759] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:44.760] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:44.760] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.760] 
[16:18:44.760] getGlobalsAndPackages() ... DONE
[16:18:44.760] run() for ‘Future’ ...
[16:18:44.760] - state: ‘created’
[16:18:44.761] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:44.774] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.774] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:44.774]   - Field: ‘node’
[16:18:44.774]   - Field: ‘label’
[16:18:44.774]   - Field: ‘local’
[16:18:44.774]   - Field: ‘owner’
[16:18:44.775]   - Field: ‘envir’
[16:18:44.775]   - Field: ‘workers’
[16:18:44.775]   - Field: ‘packages’
[16:18:44.775]   - Field: ‘gc’
[16:18:44.775]   - Field: ‘conditions’
[16:18:44.775]   - Field: ‘persistent’
[16:18:44.775]   - Field: ‘expr’
[16:18:44.775]   - Field: ‘uuid’
[16:18:44.775]   - Field: ‘seed’
[16:18:44.775]   - Field: ‘version’
[16:18:44.775]   - Field: ‘result’
[16:18:44.776]   - Field: ‘asynchronous’
[16:18:44.776]   - Field: ‘calls’
[16:18:44.776]   - Field: ‘globals’
[16:18:44.776]   - Field: ‘stdout’
[16:18:44.776]   - Field: ‘earlySignal’
[16:18:44.776]   - Field: ‘lazy’
[16:18:44.776]   - Field: ‘state’
[16:18:44.776] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:44.776] - Launch lazy future ...
[16:18:44.777] Packages needed by the future expression (n = 0): <none>
[16:18:44.777] Packages needed by future strategies (n = 0): <none>
[16:18:44.777] {
[16:18:44.777]     {
[16:18:44.777]         {
[16:18:44.777]             ...future.startTime <- base::Sys.time()
[16:18:44.777]             {
[16:18:44.777]                 {
[16:18:44.777]                   {
[16:18:44.777]                     {
[16:18:44.777]                       base::local({
[16:18:44.777]                         has_future <- base::requireNamespace("future", 
[16:18:44.777]                           quietly = TRUE)
[16:18:44.777]                         if (has_future) {
[16:18:44.777]                           ns <- base::getNamespace("future")
[16:18:44.777]                           version <- ns[[".package"]][["version"]]
[16:18:44.777]                           if (is.null(version)) 
[16:18:44.777]                             version <- utils::packageVersion("future")
[16:18:44.777]                         }
[16:18:44.777]                         else {
[16:18:44.777]                           version <- NULL
[16:18:44.777]                         }
[16:18:44.777]                         if (!has_future || version < "1.8.0") {
[16:18:44.777]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:44.777]                             "", base::R.version$version.string), 
[16:18:44.777]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:44.777]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:44.777]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:44.777]                               "release", "version")], collapse = " "), 
[16:18:44.777]                             hostname = base::Sys.info()[["nodename"]])
[16:18:44.777]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:44.777]                             info)
[16:18:44.777]                           info <- base::paste(info, collapse = "; ")
[16:18:44.777]                           if (!has_future) {
[16:18:44.777]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:44.777]                               info)
[16:18:44.777]                           }
[16:18:44.777]                           else {
[16:18:44.777]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:44.777]                               info, version)
[16:18:44.777]                           }
[16:18:44.777]                           base::stop(msg)
[16:18:44.777]                         }
[16:18:44.777]                       })
[16:18:44.777]                     }
[16:18:44.777]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:44.777]                     base::options(mc.cores = 1L)
[16:18:44.777]                   }
[16:18:44.777]                   ...future.strategy.old <- future::plan("list")
[16:18:44.777]                   options(future.plan = NULL)
[16:18:44.777]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.777]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:44.777]                 }
[16:18:44.777]                 ...future.workdir <- getwd()
[16:18:44.777]             }
[16:18:44.777]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:44.777]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:44.777]         }
[16:18:44.777]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:44.777]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:44.777]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:44.777]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:44.777]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:44.777]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:44.777]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:44.777]             base::names(...future.oldOptions))
[16:18:44.777]     }
[16:18:44.777]     if (FALSE) {
[16:18:44.777]     }
[16:18:44.777]     else {
[16:18:44.777]         if (TRUE) {
[16:18:44.777]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:44.777]                 open = "w")
[16:18:44.777]         }
[16:18:44.777]         else {
[16:18:44.777]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:44.777]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:44.777]         }
[16:18:44.777]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:44.777]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:44.777]             base::sink(type = "output", split = FALSE)
[16:18:44.777]             base::close(...future.stdout)
[16:18:44.777]         }, add = TRUE)
[16:18:44.777]     }
[16:18:44.777]     ...future.frame <- base::sys.nframe()
[16:18:44.777]     ...future.conditions <- base::list()
[16:18:44.777]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:44.777]     if (FALSE) {
[16:18:44.777]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:44.777]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:44.777]     }
[16:18:44.777]     ...future.result <- base::tryCatch({
[16:18:44.777]         base::withCallingHandlers({
[16:18:44.777]             ...future.value <- base::withVisible(base::local({
[16:18:44.777]                 ...future.makeSendCondition <- base::local({
[16:18:44.777]                   sendCondition <- NULL
[16:18:44.777]                   function(frame = 1L) {
[16:18:44.777]                     if (is.function(sendCondition)) 
[16:18:44.777]                       return(sendCondition)
[16:18:44.777]                     ns <- getNamespace("parallel")
[16:18:44.777]                     if (exists("sendData", mode = "function", 
[16:18:44.777]                       envir = ns)) {
[16:18:44.777]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:44.777]                         envir = ns)
[16:18:44.777]                       envir <- sys.frame(frame)
[16:18:44.777]                       master <- NULL
[16:18:44.777]                       while (!identical(envir, .GlobalEnv) && 
[16:18:44.777]                         !identical(envir, emptyenv())) {
[16:18:44.777]                         if (exists("master", mode = "list", envir = envir, 
[16:18:44.777]                           inherits = FALSE)) {
[16:18:44.777]                           master <- get("master", mode = "list", 
[16:18:44.777]                             envir = envir, inherits = FALSE)
[16:18:44.777]                           if (inherits(master, c("SOCKnode", 
[16:18:44.777]                             "SOCK0node"))) {
[16:18:44.777]                             sendCondition <<- function(cond) {
[16:18:44.777]                               data <- list(type = "VALUE", value = cond, 
[16:18:44.777]                                 success = TRUE)
[16:18:44.777]                               parallel_sendData(master, data)
[16:18:44.777]                             }
[16:18:44.777]                             return(sendCondition)
[16:18:44.777]                           }
[16:18:44.777]                         }
[16:18:44.777]                         frame <- frame + 1L
[16:18:44.777]                         envir <- sys.frame(frame)
[16:18:44.777]                       }
[16:18:44.777]                     }
[16:18:44.777]                     sendCondition <<- function(cond) NULL
[16:18:44.777]                   }
[16:18:44.777]                 })
[16:18:44.777]                 withCallingHandlers({
[16:18:44.777]                   {
[16:18:44.777]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.777]                     if (!identical(...future.globals.maxSize.org, 
[16:18:44.777]                       ...future.globals.maxSize)) {
[16:18:44.777]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.777]                       on.exit(options(oopts), add = TRUE)
[16:18:44.777]                     }
[16:18:44.777]                     {
[16:18:44.777]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.777]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:44.777]                         USE.NAMES = FALSE)
[16:18:44.777]                       do.call(mapply, args = args)
[16:18:44.777]                     }
[16:18:44.777]                   }
[16:18:44.777]                 }, immediateCondition = function(cond) {
[16:18:44.777]                   sendCondition <- ...future.makeSendCondition()
[16:18:44.777]                   sendCondition(cond)
[16:18:44.777]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.777]                   {
[16:18:44.777]                     inherits <- base::inherits
[16:18:44.777]                     invokeRestart <- base::invokeRestart
[16:18:44.777]                     is.null <- base::is.null
[16:18:44.777]                     muffled <- FALSE
[16:18:44.777]                     if (inherits(cond, "message")) {
[16:18:44.777]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:44.777]                       if (muffled) 
[16:18:44.777]                         invokeRestart("muffleMessage")
[16:18:44.777]                     }
[16:18:44.777]                     else if (inherits(cond, "warning")) {
[16:18:44.777]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:44.777]                       if (muffled) 
[16:18:44.777]                         invokeRestart("muffleWarning")
[16:18:44.777]                     }
[16:18:44.777]                     else if (inherits(cond, "condition")) {
[16:18:44.777]                       if (!is.null(pattern)) {
[16:18:44.777]                         computeRestarts <- base::computeRestarts
[16:18:44.777]                         grepl <- base::grepl
[16:18:44.777]                         restarts <- computeRestarts(cond)
[16:18:44.777]                         for (restart in restarts) {
[16:18:44.777]                           name <- restart$name
[16:18:44.777]                           if (is.null(name)) 
[16:18:44.777]                             next
[16:18:44.777]                           if (!grepl(pattern, name)) 
[16:18:44.777]                             next
[16:18:44.777]                           invokeRestart(restart)
[16:18:44.777]                           muffled <- TRUE
[16:18:44.777]                           break
[16:18:44.777]                         }
[16:18:44.777]                       }
[16:18:44.777]                     }
[16:18:44.777]                     invisible(muffled)
[16:18:44.777]                   }
[16:18:44.777]                   muffleCondition(cond)
[16:18:44.777]                 })
[16:18:44.777]             }))
[16:18:44.777]             future::FutureResult(value = ...future.value$value, 
[16:18:44.777]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.777]                   ...future.rng), globalenv = if (FALSE) 
[16:18:44.777]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:44.777]                     ...future.globalenv.names))
[16:18:44.777]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:44.777]         }, condition = base::local({
[16:18:44.777]             c <- base::c
[16:18:44.777]             inherits <- base::inherits
[16:18:44.777]             invokeRestart <- base::invokeRestart
[16:18:44.777]             length <- base::length
[16:18:44.777]             list <- base::list
[16:18:44.777]             seq.int <- base::seq.int
[16:18:44.777]             signalCondition <- base::signalCondition
[16:18:44.777]             sys.calls <- base::sys.calls
[16:18:44.777]             `[[` <- base::`[[`
[16:18:44.777]             `+` <- base::`+`
[16:18:44.777]             `<<-` <- base::`<<-`
[16:18:44.777]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:44.777]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:44.777]                   3L)]
[16:18:44.777]             }
[16:18:44.777]             function(cond) {
[16:18:44.777]                 is_error <- inherits(cond, "error")
[16:18:44.777]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:44.777]                   NULL)
[16:18:44.777]                 if (is_error) {
[16:18:44.777]                   sessionInformation <- function() {
[16:18:44.777]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:44.777]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:44.777]                       search = base::search(), system = base::Sys.info())
[16:18:44.777]                   }
[16:18:44.777]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.777]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:44.777]                     cond$call), session = sessionInformation(), 
[16:18:44.777]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:44.777]                   signalCondition(cond)
[16:18:44.777]                 }
[16:18:44.777]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:44.777]                 "immediateCondition"))) {
[16:18:44.777]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:44.777]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.777]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:44.777]                   if (TRUE && !signal) {
[16:18:44.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.777]                     {
[16:18:44.777]                       inherits <- base::inherits
[16:18:44.777]                       invokeRestart <- base::invokeRestart
[16:18:44.777]                       is.null <- base::is.null
[16:18:44.777]                       muffled <- FALSE
[16:18:44.777]                       if (inherits(cond, "message")) {
[16:18:44.777]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.777]                         if (muffled) 
[16:18:44.777]                           invokeRestart("muffleMessage")
[16:18:44.777]                       }
[16:18:44.777]                       else if (inherits(cond, "warning")) {
[16:18:44.777]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.777]                         if (muffled) 
[16:18:44.777]                           invokeRestart("muffleWarning")
[16:18:44.777]                       }
[16:18:44.777]                       else if (inherits(cond, "condition")) {
[16:18:44.777]                         if (!is.null(pattern)) {
[16:18:44.777]                           computeRestarts <- base::computeRestarts
[16:18:44.777]                           grepl <- base::grepl
[16:18:44.777]                           restarts <- computeRestarts(cond)
[16:18:44.777]                           for (restart in restarts) {
[16:18:44.777]                             name <- restart$name
[16:18:44.777]                             if (is.null(name)) 
[16:18:44.777]                               next
[16:18:44.777]                             if (!grepl(pattern, name)) 
[16:18:44.777]                               next
[16:18:44.777]                             invokeRestart(restart)
[16:18:44.777]                             muffled <- TRUE
[16:18:44.777]                             break
[16:18:44.777]                           }
[16:18:44.777]                         }
[16:18:44.777]                       }
[16:18:44.777]                       invisible(muffled)
[16:18:44.777]                     }
[16:18:44.777]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.777]                   }
[16:18:44.777]                 }
[16:18:44.777]                 else {
[16:18:44.777]                   if (TRUE) {
[16:18:44.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.777]                     {
[16:18:44.777]                       inherits <- base::inherits
[16:18:44.777]                       invokeRestart <- base::invokeRestart
[16:18:44.777]                       is.null <- base::is.null
[16:18:44.777]                       muffled <- FALSE
[16:18:44.777]                       if (inherits(cond, "message")) {
[16:18:44.777]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.777]                         if (muffled) 
[16:18:44.777]                           invokeRestart("muffleMessage")
[16:18:44.777]                       }
[16:18:44.777]                       else if (inherits(cond, "warning")) {
[16:18:44.777]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.777]                         if (muffled) 
[16:18:44.777]                           invokeRestart("muffleWarning")
[16:18:44.777]                       }
[16:18:44.777]                       else if (inherits(cond, "condition")) {
[16:18:44.777]                         if (!is.null(pattern)) {
[16:18:44.777]                           computeRestarts <- base::computeRestarts
[16:18:44.777]                           grepl <- base::grepl
[16:18:44.777]                           restarts <- computeRestarts(cond)
[16:18:44.777]                           for (restart in restarts) {
[16:18:44.777]                             name <- restart$name
[16:18:44.777]                             if (is.null(name)) 
[16:18:44.777]                               next
[16:18:44.777]                             if (!grepl(pattern, name)) 
[16:18:44.777]                               next
[16:18:44.777]                             invokeRestart(restart)
[16:18:44.777]                             muffled <- TRUE
[16:18:44.777]                             break
[16:18:44.777]                           }
[16:18:44.777]                         }
[16:18:44.777]                       }
[16:18:44.777]                       invisible(muffled)
[16:18:44.777]                     }
[16:18:44.777]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.777]                   }
[16:18:44.777]                 }
[16:18:44.777]             }
[16:18:44.777]         }))
[16:18:44.777]     }, error = function(ex) {
[16:18:44.777]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:44.777]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.777]                 ...future.rng), started = ...future.startTime, 
[16:18:44.777]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:44.777]             version = "1.8"), class = "FutureResult")
[16:18:44.777]     }, finally = {
[16:18:44.777]         if (!identical(...future.workdir, getwd())) 
[16:18:44.777]             setwd(...future.workdir)
[16:18:44.777]         {
[16:18:44.777]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:44.777]                 ...future.oldOptions$nwarnings <- NULL
[16:18:44.777]             }
[16:18:44.777]             base::options(...future.oldOptions)
[16:18:44.777]             if (.Platform$OS.type == "windows") {
[16:18:44.777]                 old_names <- names(...future.oldEnvVars)
[16:18:44.777]                 envs <- base::Sys.getenv()
[16:18:44.777]                 names <- names(envs)
[16:18:44.777]                 common <- intersect(names, old_names)
[16:18:44.777]                 added <- setdiff(names, old_names)
[16:18:44.777]                 removed <- setdiff(old_names, names)
[16:18:44.777]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:44.777]                   envs[common]]
[16:18:44.777]                 NAMES <- toupper(changed)
[16:18:44.777]                 args <- list()
[16:18:44.777]                 for (kk in seq_along(NAMES)) {
[16:18:44.777]                   name <- changed[[kk]]
[16:18:44.777]                   NAME <- NAMES[[kk]]
[16:18:44.777]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.777]                     next
[16:18:44.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.777]                 }
[16:18:44.777]                 NAMES <- toupper(added)
[16:18:44.777]                 for (kk in seq_along(NAMES)) {
[16:18:44.777]                   name <- added[[kk]]
[16:18:44.777]                   NAME <- NAMES[[kk]]
[16:18:44.777]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.777]                     next
[16:18:44.777]                   args[[name]] <- ""
[16:18:44.777]                 }
[16:18:44.777]                 NAMES <- toupper(removed)
[16:18:44.777]                 for (kk in seq_along(NAMES)) {
[16:18:44.777]                   name <- removed[[kk]]
[16:18:44.777]                   NAME <- NAMES[[kk]]
[16:18:44.777]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.777]                     next
[16:18:44.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.777]                 }
[16:18:44.777]                 if (length(args) > 0) 
[16:18:44.777]                   base::do.call(base::Sys.setenv, args = args)
[16:18:44.777]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:44.777]             }
[16:18:44.777]             else {
[16:18:44.777]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:44.777]             }
[16:18:44.777]             {
[16:18:44.777]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:44.777]                   0L) {
[16:18:44.777]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:44.777]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:44.777]                   base::options(opts)
[16:18:44.777]                 }
[16:18:44.777]                 {
[16:18:44.777]                   {
[16:18:44.777]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:44.777]                     NULL
[16:18:44.777]                   }
[16:18:44.777]                   options(future.plan = NULL)
[16:18:44.777]                   if (is.na(NA_character_)) 
[16:18:44.777]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.777]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:44.777]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:44.777]                     .init = FALSE)
[16:18:44.777]                 }
[16:18:44.777]             }
[16:18:44.777]         }
[16:18:44.777]     })
[16:18:44.777]     if (TRUE) {
[16:18:44.777]         base::sink(type = "output", split = FALSE)
[16:18:44.777]         if (TRUE) {
[16:18:44.777]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:44.777]         }
[16:18:44.777]         else {
[16:18:44.777]             ...future.result["stdout"] <- base::list(NULL)
[16:18:44.777]         }
[16:18:44.777]         base::close(...future.stdout)
[16:18:44.777]         ...future.stdout <- NULL
[16:18:44.777]     }
[16:18:44.777]     ...future.result$conditions <- ...future.conditions
[16:18:44.777]     ...future.result$finished <- base::Sys.time()
[16:18:44.777]     ...future.result
[16:18:44.777] }
[16:18:44.780] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[16:18:44.780] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[16:18:44.780] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[16:18:44.780] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:44.781] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:44.781] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[16:18:44.781] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[16:18:44.781] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:44.782] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:44.782] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:44.782] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:44.782] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[16:18:44.782] MultisessionFuture started
[16:18:44.783] - Launch lazy future ... done
[16:18:44.783] run() for ‘MultisessionFuture’ ... done
[16:18:44.783] Created future:
[16:18:44.783] MultisessionFuture:
[16:18:44.783] Label: ‘future_mapply-2’
[16:18:44.783] Expression:
[16:18:44.783] {
[16:18:44.783]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.783]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:44.783]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.783]         on.exit(options(oopts), add = TRUE)
[16:18:44.783]     }
[16:18:44.783]     {
[16:18:44.783]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.783]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:44.783]         do.call(mapply, args = args)
[16:18:44.783]     }
[16:18:44.783] }
[16:18:44.783] Lazy evaluation: FALSE
[16:18:44.783] Asynchronous evaluation: TRUE
[16:18:44.783] Local evaluation: TRUE
[16:18:44.783] Environment: R_GlobalEnv
[16:18:44.783] Capture standard output: TRUE
[16:18:44.783] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:44.783] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:44.783] Packages: <none>
[16:18:44.783] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:44.783] Resolved: FALSE
[16:18:44.783] Value: <not collected>
[16:18:44.783] Conditions captured: <none>
[16:18:44.783] Early signaling: FALSE
[16:18:44.783] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:44.783] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.794] Chunk #2 of 2 ... DONE
[16:18:44.794] Launching 2 futures (chunks) ... DONE
[16:18:44.794] Resolving 2 futures (chunks) ...
[16:18:44.795] resolve() on list ...
[16:18:44.795]  recursive: 0
[16:18:44.795]  length: 2
[16:18:44.795] 
[16:18:44.795] receiveMessageFromWorker() for ClusterFuture ...
[16:18:44.795] - Validating connection of MultisessionFuture
[16:18:44.796] - received message: FutureResult
[16:18:44.796] - Received FutureResult
[16:18:44.796] - Erased future from FutureRegistry
[16:18:44.796] result() for ClusterFuture ...
[16:18:44.796] - result already collected: FutureResult
[16:18:44.796] result() for ClusterFuture ... done
[16:18:44.796] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:44.796] Future #1
[16:18:44.796] result() for ClusterFuture ...
[16:18:44.796] - result already collected: FutureResult
[16:18:44.797] result() for ClusterFuture ... done
[16:18:44.797] result() for ClusterFuture ...
[16:18:44.797] - result already collected: FutureResult
[16:18:44.797] result() for ClusterFuture ... done
[16:18:44.797] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:44.797] - nx: 2
[16:18:44.797] - relay: TRUE
[16:18:44.797] - stdout: TRUE
[16:18:44.797] - signal: TRUE
[16:18:44.797] - resignal: FALSE
[16:18:44.797] - force: TRUE
[16:18:44.798] - relayed: [n=2] FALSE, FALSE
[16:18:44.798] - queued futures: [n=2] FALSE, FALSE
[16:18:44.798]  - until=1
[16:18:44.798]  - relaying element #1
[16:18:44.798] result() for ClusterFuture ...
[16:18:44.798] - result already collected: FutureResult
[16:18:44.798] result() for ClusterFuture ... done
[16:18:44.798] result() for ClusterFuture ...
[16:18:44.798] - result already collected: FutureResult
[16:18:44.798] result() for ClusterFuture ... done
[16:18:44.798] result() for ClusterFuture ...
[16:18:44.799] - result already collected: FutureResult
[16:18:44.799] result() for ClusterFuture ... done
[16:18:44.799] result() for ClusterFuture ...
[16:18:44.799] - result already collected: FutureResult
[16:18:44.799] result() for ClusterFuture ... done
[16:18:44.799] - relayed: [n=2] TRUE, FALSE
[16:18:44.799] - queued futures: [n=2] TRUE, FALSE
[16:18:44.799] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:44.799]  length: 1 (resolved future 1)
[16:18:44.826] receiveMessageFromWorker() for ClusterFuture ...
[16:18:44.826] - Validating connection of MultisessionFuture
[16:18:44.826] - received message: FutureResult
[16:18:44.826] - Received FutureResult
[16:18:44.827] - Erased future from FutureRegistry
[16:18:44.827] result() for ClusterFuture ...
[16:18:44.827] - result already collected: FutureResult
[16:18:44.827] result() for ClusterFuture ... done
[16:18:44.827] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:44.827] Future #2
[16:18:44.827] result() for ClusterFuture ...
[16:18:44.827] - result already collected: FutureResult
[16:18:44.827] result() for ClusterFuture ... done
[16:18:44.827] result() for ClusterFuture ...
[16:18:44.827] - result already collected: FutureResult
[16:18:44.827] result() for ClusterFuture ... done
[16:18:44.828] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:44.828] - nx: 2
[16:18:44.828] - relay: TRUE
[16:18:44.828] - stdout: TRUE
[16:18:44.828] - signal: TRUE
[16:18:44.828] - resignal: FALSE
[16:18:44.828] - force: TRUE
[16:18:44.828] - relayed: [n=2] TRUE, FALSE
[16:18:44.828] - queued futures: [n=2] TRUE, FALSE
[16:18:44.828]  - until=2
[16:18:44.828]  - relaying element #2
[16:18:44.829] result() for ClusterFuture ...
[16:18:44.829] - result already collected: FutureResult
[16:18:44.829] result() for ClusterFuture ... done
[16:18:44.829] result() for ClusterFuture ...
[16:18:44.829] - result already collected: FutureResult
[16:18:44.829] result() for ClusterFuture ... done
[16:18:44.829] result() for ClusterFuture ...
[16:18:44.829] - result already collected: FutureResult
[16:18:44.829] result() for ClusterFuture ... done
[16:18:44.829] result() for ClusterFuture ...
[16:18:44.829] - result already collected: FutureResult
[16:18:44.830] result() for ClusterFuture ... done
[16:18:44.830] - relayed: [n=2] TRUE, TRUE
[16:18:44.830] - queued futures: [n=2] TRUE, TRUE
[16:18:44.830] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:44.830]  length: 0 (resolved future 2)
[16:18:44.830] Relaying remaining futures
[16:18:44.830] signalConditionsASAP(NULL, pos=0) ...
[16:18:44.830] - nx: 2
[16:18:44.830] - relay: TRUE
[16:18:44.830] - stdout: TRUE
[16:18:44.830] - signal: TRUE
[16:18:44.830] - resignal: FALSE
[16:18:44.831] - force: TRUE
[16:18:44.831] - relayed: [n=2] TRUE, TRUE
[16:18:44.831] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:44.831] - relayed: [n=2] TRUE, TRUE
[16:18:44.831] - queued futures: [n=2] TRUE, TRUE
[16:18:44.831] signalConditionsASAP(NULL, pos=0) ... done
[16:18:44.831] resolve() on list ... DONE
[16:18:44.831] result() for ClusterFuture ...
[16:18:44.831] - result already collected: FutureResult
[16:18:44.831] result() for ClusterFuture ... done
[16:18:44.831] result() for ClusterFuture ...
[16:18:44.832] - result already collected: FutureResult
[16:18:44.832] result() for ClusterFuture ... done
[16:18:44.832] result() for ClusterFuture ...
[16:18:44.832] - result already collected: FutureResult
[16:18:44.832] result() for ClusterFuture ... done
[16:18:44.832] result() for ClusterFuture ...
[16:18:44.832] - result already collected: FutureResult
[16:18:44.832] result() for ClusterFuture ... done
[16:18:44.832]  - Number of value chunks collected: 2
[16:18:44.832] Resolving 2 futures (chunks) ... DONE
[16:18:44.833] Reducing values from 2 chunks ...
[16:18:44.833]  - Number of values collected after concatenation: 4
[16:18:44.833]  - Number of values expected: 4
[16:18:44.833] Reducing values from 2 chunks ... DONE
[16:18:44.833] future_mapply() ... DONE
[16:18:44.833] future_mapply() ...
[16:18:44.837] Number of chunks: 2
[16:18:44.837] getGlobalsAndPackagesXApply() ...
[16:18:44.837]  - future.globals: TRUE
[16:18:44.837] getGlobalsAndPackages() ...
[16:18:44.837] Searching for globals...
[16:18:44.838] - globals found: [1] ‘FUN’
[16:18:44.838] Searching for globals ... DONE
[16:18:44.838] Resolving globals: FALSE
[16:18:44.838] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:44.839] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:44.839] - globals: [1] ‘FUN’
[16:18:44.839] 
[16:18:44.839] getGlobalsAndPackages() ... DONE
[16:18:44.839]  - globals found/used: [n=1] ‘FUN’
[16:18:44.839]  - needed namespaces: [n=0] 
[16:18:44.839] Finding globals ... DONE
[16:18:44.840] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:44.840] List of 2
[16:18:44.840]  $ ...future.FUN:function (x, ...)  
[16:18:44.840]  $ MoreArgs     :List of 1
[16:18:44.840]   ..$ x: num 42
[16:18:44.840]  - attr(*, "where")=List of 2
[16:18:44.840]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:44.840]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:44.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:44.840]  - attr(*, "resolved")= logi FALSE
[16:18:44.840]  - attr(*, "total_size")= num NA
[16:18:44.843] Packages to be attached in all futures: [n=0] 
[16:18:44.843] getGlobalsAndPackagesXApply() ... DONE
[16:18:44.843] Number of futures (= number of chunks): 2
[16:18:44.843] Launching 2 futures (chunks) ...
[16:18:44.843] Chunk #1 of 2 ...
[16:18:44.843]  - Finding globals in '...' for chunk #1 ...
[16:18:44.843] getGlobalsAndPackages() ...
[16:18:44.843] Searching for globals...
[16:18:44.844] 
[16:18:44.844] Searching for globals ... DONE
[16:18:44.844] - globals: [0] <none>
[16:18:44.844] getGlobalsAndPackages() ... DONE
[16:18:44.844]    + additional globals found: [n=0] 
[16:18:44.844]    + additional namespaces needed: [n=0] 
[16:18:44.844]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:44.844]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:44.844]  - seeds: <none>
[16:18:44.844]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.845] getGlobalsAndPackages() ...
[16:18:44.845] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.845] Resolving globals: FALSE
[16:18:44.845] The total size of the 5 globals is 224 bytes (224 bytes)
[16:18:44.846] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[16:18:44.846] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.846] 
[16:18:44.846] getGlobalsAndPackages() ... DONE
[16:18:44.846] run() for ‘Future’ ...
[16:18:44.846] - state: ‘created’
[16:18:44.847] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:44.860] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.860] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:44.861]   - Field: ‘node’
[16:18:44.861]   - Field: ‘label’
[16:18:44.861]   - Field: ‘local’
[16:18:44.861]   - Field: ‘owner’
[16:18:44.861]   - Field: ‘envir’
[16:18:44.861]   - Field: ‘workers’
[16:18:44.861]   - Field: ‘packages’
[16:18:44.861]   - Field: ‘gc’
[16:18:44.861]   - Field: ‘conditions’
[16:18:44.861]   - Field: ‘persistent’
[16:18:44.861]   - Field: ‘expr’
[16:18:44.862]   - Field: ‘uuid’
[16:18:44.862]   - Field: ‘seed’
[16:18:44.862]   - Field: ‘version’
[16:18:44.862]   - Field: ‘result’
[16:18:44.862]   - Field: ‘asynchronous’
[16:18:44.862]   - Field: ‘calls’
[16:18:44.862]   - Field: ‘globals’
[16:18:44.862]   - Field: ‘stdout’
[16:18:44.862]   - Field: ‘earlySignal’
[16:18:44.862]   - Field: ‘lazy’
[16:18:44.862]   - Field: ‘state’
[16:18:44.863] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:44.863] - Launch lazy future ...
[16:18:44.863] Packages needed by the future expression (n = 0): <none>
[16:18:44.863] Packages needed by future strategies (n = 0): <none>
[16:18:44.863] {
[16:18:44.863]     {
[16:18:44.863]         {
[16:18:44.863]             ...future.startTime <- base::Sys.time()
[16:18:44.863]             {
[16:18:44.863]                 {
[16:18:44.863]                   {
[16:18:44.863]                     {
[16:18:44.863]                       base::local({
[16:18:44.863]                         has_future <- base::requireNamespace("future", 
[16:18:44.863]                           quietly = TRUE)
[16:18:44.863]                         if (has_future) {
[16:18:44.863]                           ns <- base::getNamespace("future")
[16:18:44.863]                           version <- ns[[".package"]][["version"]]
[16:18:44.863]                           if (is.null(version)) 
[16:18:44.863]                             version <- utils::packageVersion("future")
[16:18:44.863]                         }
[16:18:44.863]                         else {
[16:18:44.863]                           version <- NULL
[16:18:44.863]                         }
[16:18:44.863]                         if (!has_future || version < "1.8.0") {
[16:18:44.863]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:44.863]                             "", base::R.version$version.string), 
[16:18:44.863]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:44.863]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:44.863]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:44.863]                               "release", "version")], collapse = " "), 
[16:18:44.863]                             hostname = base::Sys.info()[["nodename"]])
[16:18:44.863]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:44.863]                             info)
[16:18:44.863]                           info <- base::paste(info, collapse = "; ")
[16:18:44.863]                           if (!has_future) {
[16:18:44.863]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:44.863]                               info)
[16:18:44.863]                           }
[16:18:44.863]                           else {
[16:18:44.863]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:44.863]                               info, version)
[16:18:44.863]                           }
[16:18:44.863]                           base::stop(msg)
[16:18:44.863]                         }
[16:18:44.863]                       })
[16:18:44.863]                     }
[16:18:44.863]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:44.863]                     base::options(mc.cores = 1L)
[16:18:44.863]                   }
[16:18:44.863]                   ...future.strategy.old <- future::plan("list")
[16:18:44.863]                   options(future.plan = NULL)
[16:18:44.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:44.863]                 }
[16:18:44.863]                 ...future.workdir <- getwd()
[16:18:44.863]             }
[16:18:44.863]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:44.863]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:44.863]         }
[16:18:44.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:44.863]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:44.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:44.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:44.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:44.863]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:44.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:44.863]             base::names(...future.oldOptions))
[16:18:44.863]     }
[16:18:44.863]     if (FALSE) {
[16:18:44.863]     }
[16:18:44.863]     else {
[16:18:44.863]         if (TRUE) {
[16:18:44.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:44.863]                 open = "w")
[16:18:44.863]         }
[16:18:44.863]         else {
[16:18:44.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:44.863]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:44.863]         }
[16:18:44.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:44.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:44.863]             base::sink(type = "output", split = FALSE)
[16:18:44.863]             base::close(...future.stdout)
[16:18:44.863]         }, add = TRUE)
[16:18:44.863]     }
[16:18:44.863]     ...future.frame <- base::sys.nframe()
[16:18:44.863]     ...future.conditions <- base::list()
[16:18:44.863]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:44.863]     if (FALSE) {
[16:18:44.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:44.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:44.863]     }
[16:18:44.863]     ...future.result <- base::tryCatch({
[16:18:44.863]         base::withCallingHandlers({
[16:18:44.863]             ...future.value <- base::withVisible(base::local({
[16:18:44.863]                 ...future.makeSendCondition <- base::local({
[16:18:44.863]                   sendCondition <- NULL
[16:18:44.863]                   function(frame = 1L) {
[16:18:44.863]                     if (is.function(sendCondition)) 
[16:18:44.863]                       return(sendCondition)
[16:18:44.863]                     ns <- getNamespace("parallel")
[16:18:44.863]                     if (exists("sendData", mode = "function", 
[16:18:44.863]                       envir = ns)) {
[16:18:44.863]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:44.863]                         envir = ns)
[16:18:44.863]                       envir <- sys.frame(frame)
[16:18:44.863]                       master <- NULL
[16:18:44.863]                       while (!identical(envir, .GlobalEnv) && 
[16:18:44.863]                         !identical(envir, emptyenv())) {
[16:18:44.863]                         if (exists("master", mode = "list", envir = envir, 
[16:18:44.863]                           inherits = FALSE)) {
[16:18:44.863]                           master <- get("master", mode = "list", 
[16:18:44.863]                             envir = envir, inherits = FALSE)
[16:18:44.863]                           if (inherits(master, c("SOCKnode", 
[16:18:44.863]                             "SOCK0node"))) {
[16:18:44.863]                             sendCondition <<- function(cond) {
[16:18:44.863]                               data <- list(type = "VALUE", value = cond, 
[16:18:44.863]                                 success = TRUE)
[16:18:44.863]                               parallel_sendData(master, data)
[16:18:44.863]                             }
[16:18:44.863]                             return(sendCondition)
[16:18:44.863]                           }
[16:18:44.863]                         }
[16:18:44.863]                         frame <- frame + 1L
[16:18:44.863]                         envir <- sys.frame(frame)
[16:18:44.863]                       }
[16:18:44.863]                     }
[16:18:44.863]                     sendCondition <<- function(cond) NULL
[16:18:44.863]                   }
[16:18:44.863]                 })
[16:18:44.863]                 withCallingHandlers({
[16:18:44.863]                   {
[16:18:44.863]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.863]                     if (!identical(...future.globals.maxSize.org, 
[16:18:44.863]                       ...future.globals.maxSize)) {
[16:18:44.863]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.863]                       on.exit(options(oopts), add = TRUE)
[16:18:44.863]                     }
[16:18:44.863]                     {
[16:18:44.863]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.863]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:44.863]                         USE.NAMES = FALSE)
[16:18:44.863]                       do.call(mapply, args = args)
[16:18:44.863]                     }
[16:18:44.863]                   }
[16:18:44.863]                 }, immediateCondition = function(cond) {
[16:18:44.863]                   sendCondition <- ...future.makeSendCondition()
[16:18:44.863]                   sendCondition(cond)
[16:18:44.863]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.863]                   {
[16:18:44.863]                     inherits <- base::inherits
[16:18:44.863]                     invokeRestart <- base::invokeRestart
[16:18:44.863]                     is.null <- base::is.null
[16:18:44.863]                     muffled <- FALSE
[16:18:44.863]                     if (inherits(cond, "message")) {
[16:18:44.863]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:44.863]                       if (muffled) 
[16:18:44.863]                         invokeRestart("muffleMessage")
[16:18:44.863]                     }
[16:18:44.863]                     else if (inherits(cond, "warning")) {
[16:18:44.863]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:44.863]                       if (muffled) 
[16:18:44.863]                         invokeRestart("muffleWarning")
[16:18:44.863]                     }
[16:18:44.863]                     else if (inherits(cond, "condition")) {
[16:18:44.863]                       if (!is.null(pattern)) {
[16:18:44.863]                         computeRestarts <- base::computeRestarts
[16:18:44.863]                         grepl <- base::grepl
[16:18:44.863]                         restarts <- computeRestarts(cond)
[16:18:44.863]                         for (restart in restarts) {
[16:18:44.863]                           name <- restart$name
[16:18:44.863]                           if (is.null(name)) 
[16:18:44.863]                             next
[16:18:44.863]                           if (!grepl(pattern, name)) 
[16:18:44.863]                             next
[16:18:44.863]                           invokeRestart(restart)
[16:18:44.863]                           muffled <- TRUE
[16:18:44.863]                           break
[16:18:44.863]                         }
[16:18:44.863]                       }
[16:18:44.863]                     }
[16:18:44.863]                     invisible(muffled)
[16:18:44.863]                   }
[16:18:44.863]                   muffleCondition(cond)
[16:18:44.863]                 })
[16:18:44.863]             }))
[16:18:44.863]             future::FutureResult(value = ...future.value$value, 
[16:18:44.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.863]                   ...future.rng), globalenv = if (FALSE) 
[16:18:44.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:44.863]                     ...future.globalenv.names))
[16:18:44.863]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:44.863]         }, condition = base::local({
[16:18:44.863]             c <- base::c
[16:18:44.863]             inherits <- base::inherits
[16:18:44.863]             invokeRestart <- base::invokeRestart
[16:18:44.863]             length <- base::length
[16:18:44.863]             list <- base::list
[16:18:44.863]             seq.int <- base::seq.int
[16:18:44.863]             signalCondition <- base::signalCondition
[16:18:44.863]             sys.calls <- base::sys.calls
[16:18:44.863]             `[[` <- base::`[[`
[16:18:44.863]             `+` <- base::`+`
[16:18:44.863]             `<<-` <- base::`<<-`
[16:18:44.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:44.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:44.863]                   3L)]
[16:18:44.863]             }
[16:18:44.863]             function(cond) {
[16:18:44.863]                 is_error <- inherits(cond, "error")
[16:18:44.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:44.863]                   NULL)
[16:18:44.863]                 if (is_error) {
[16:18:44.863]                   sessionInformation <- function() {
[16:18:44.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:44.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:44.863]                       search = base::search(), system = base::Sys.info())
[16:18:44.863]                   }
[16:18:44.863]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:44.863]                     cond$call), session = sessionInformation(), 
[16:18:44.863]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:44.863]                   signalCondition(cond)
[16:18:44.863]                 }
[16:18:44.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:44.863]                 "immediateCondition"))) {
[16:18:44.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:44.863]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:44.863]                   if (TRUE && !signal) {
[16:18:44.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.863]                     {
[16:18:44.863]                       inherits <- base::inherits
[16:18:44.863]                       invokeRestart <- base::invokeRestart
[16:18:44.863]                       is.null <- base::is.null
[16:18:44.863]                       muffled <- FALSE
[16:18:44.863]                       if (inherits(cond, "message")) {
[16:18:44.863]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.863]                         if (muffled) 
[16:18:44.863]                           invokeRestart("muffleMessage")
[16:18:44.863]                       }
[16:18:44.863]                       else if (inherits(cond, "warning")) {
[16:18:44.863]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.863]                         if (muffled) 
[16:18:44.863]                           invokeRestart("muffleWarning")
[16:18:44.863]                       }
[16:18:44.863]                       else if (inherits(cond, "condition")) {
[16:18:44.863]                         if (!is.null(pattern)) {
[16:18:44.863]                           computeRestarts <- base::computeRestarts
[16:18:44.863]                           grepl <- base::grepl
[16:18:44.863]                           restarts <- computeRestarts(cond)
[16:18:44.863]                           for (restart in restarts) {
[16:18:44.863]                             name <- restart$name
[16:18:44.863]                             if (is.null(name)) 
[16:18:44.863]                               next
[16:18:44.863]                             if (!grepl(pattern, name)) 
[16:18:44.863]                               next
[16:18:44.863]                             invokeRestart(restart)
[16:18:44.863]                             muffled <- TRUE
[16:18:44.863]                             break
[16:18:44.863]                           }
[16:18:44.863]                         }
[16:18:44.863]                       }
[16:18:44.863]                       invisible(muffled)
[16:18:44.863]                     }
[16:18:44.863]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.863]                   }
[16:18:44.863]                 }
[16:18:44.863]                 else {
[16:18:44.863]                   if (TRUE) {
[16:18:44.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.863]                     {
[16:18:44.863]                       inherits <- base::inherits
[16:18:44.863]                       invokeRestart <- base::invokeRestart
[16:18:44.863]                       is.null <- base::is.null
[16:18:44.863]                       muffled <- FALSE
[16:18:44.863]                       if (inherits(cond, "message")) {
[16:18:44.863]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.863]                         if (muffled) 
[16:18:44.863]                           invokeRestart("muffleMessage")
[16:18:44.863]                       }
[16:18:44.863]                       else if (inherits(cond, "warning")) {
[16:18:44.863]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.863]                         if (muffled) 
[16:18:44.863]                           invokeRestart("muffleWarning")
[16:18:44.863]                       }
[16:18:44.863]                       else if (inherits(cond, "condition")) {
[16:18:44.863]                         if (!is.null(pattern)) {
[16:18:44.863]                           computeRestarts <- base::computeRestarts
[16:18:44.863]                           grepl <- base::grepl
[16:18:44.863]                           restarts <- computeRestarts(cond)
[16:18:44.863]                           for (restart in restarts) {
[16:18:44.863]                             name <- restart$name
[16:18:44.863]                             if (is.null(name)) 
[16:18:44.863]                               next
[16:18:44.863]                             if (!grepl(pattern, name)) 
[16:18:44.863]                               next
[16:18:44.863]                             invokeRestart(restart)
[16:18:44.863]                             muffled <- TRUE
[16:18:44.863]                             break
[16:18:44.863]                           }
[16:18:44.863]                         }
[16:18:44.863]                       }
[16:18:44.863]                       invisible(muffled)
[16:18:44.863]                     }
[16:18:44.863]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.863]                   }
[16:18:44.863]                 }
[16:18:44.863]             }
[16:18:44.863]         }))
[16:18:44.863]     }, error = function(ex) {
[16:18:44.863]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:44.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.863]                 ...future.rng), started = ...future.startTime, 
[16:18:44.863]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:44.863]             version = "1.8"), class = "FutureResult")
[16:18:44.863]     }, finally = {
[16:18:44.863]         if (!identical(...future.workdir, getwd())) 
[16:18:44.863]             setwd(...future.workdir)
[16:18:44.863]         {
[16:18:44.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:44.863]                 ...future.oldOptions$nwarnings <- NULL
[16:18:44.863]             }
[16:18:44.863]             base::options(...future.oldOptions)
[16:18:44.863]             if (.Platform$OS.type == "windows") {
[16:18:44.863]                 old_names <- names(...future.oldEnvVars)
[16:18:44.863]                 envs <- base::Sys.getenv()
[16:18:44.863]                 names <- names(envs)
[16:18:44.863]                 common <- intersect(names, old_names)
[16:18:44.863]                 added <- setdiff(names, old_names)
[16:18:44.863]                 removed <- setdiff(old_names, names)
[16:18:44.863]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:44.863]                   envs[common]]
[16:18:44.863]                 NAMES <- toupper(changed)
[16:18:44.863]                 args <- list()
[16:18:44.863]                 for (kk in seq_along(NAMES)) {
[16:18:44.863]                   name <- changed[[kk]]
[16:18:44.863]                   NAME <- NAMES[[kk]]
[16:18:44.863]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.863]                     next
[16:18:44.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.863]                 }
[16:18:44.863]                 NAMES <- toupper(added)
[16:18:44.863]                 for (kk in seq_along(NAMES)) {
[16:18:44.863]                   name <- added[[kk]]
[16:18:44.863]                   NAME <- NAMES[[kk]]
[16:18:44.863]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.863]                     next
[16:18:44.863]                   args[[name]] <- ""
[16:18:44.863]                 }
[16:18:44.863]                 NAMES <- toupper(removed)
[16:18:44.863]                 for (kk in seq_along(NAMES)) {
[16:18:44.863]                   name <- removed[[kk]]
[16:18:44.863]                   NAME <- NAMES[[kk]]
[16:18:44.863]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.863]                     next
[16:18:44.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.863]                 }
[16:18:44.863]                 if (length(args) > 0) 
[16:18:44.863]                   base::do.call(base::Sys.setenv, args = args)
[16:18:44.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:44.863]             }
[16:18:44.863]             else {
[16:18:44.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:44.863]             }
[16:18:44.863]             {
[16:18:44.863]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:44.863]                   0L) {
[16:18:44.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:44.863]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:44.863]                   base::options(opts)
[16:18:44.863]                 }
[16:18:44.863]                 {
[16:18:44.863]                   {
[16:18:44.863]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:44.863]                     NULL
[16:18:44.863]                   }
[16:18:44.863]                   options(future.plan = NULL)
[16:18:44.863]                   if (is.na(NA_character_)) 
[16:18:44.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:44.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:44.863]                     .init = FALSE)
[16:18:44.863]                 }
[16:18:44.863]             }
[16:18:44.863]         }
[16:18:44.863]     })
[16:18:44.863]     if (TRUE) {
[16:18:44.863]         base::sink(type = "output", split = FALSE)
[16:18:44.863]         if (TRUE) {
[16:18:44.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:44.863]         }
[16:18:44.863]         else {
[16:18:44.863]             ...future.result["stdout"] <- base::list(NULL)
[16:18:44.863]         }
[16:18:44.863]         base::close(...future.stdout)
[16:18:44.863]         ...future.stdout <- NULL
[16:18:44.863]     }
[16:18:44.863]     ...future.result$conditions <- ...future.conditions
[16:18:44.863]     ...future.result$finished <- base::Sys.time()
[16:18:44.863]     ...future.result
[16:18:44.863] }
[16:18:44.866] Exporting 5 global objects (224 bytes) to cluster node #1 ...
[16:18:44.866] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[16:18:44.867] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[16:18:44.867] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[16:18:44.867] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[16:18:44.867] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:18:44.868] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:18:44.868] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:44.868] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.869] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:44.869] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.869] Exporting 5 global objects (224 bytes) to cluster node #1 ... DONE
[16:18:44.870] MultisessionFuture started
[16:18:44.870] - Launch lazy future ... done
[16:18:44.870] run() for ‘MultisessionFuture’ ... done
[16:18:44.870] Created future:
[16:18:44.870] MultisessionFuture:
[16:18:44.870] Label: ‘future_mapply-1’
[16:18:44.870] Expression:
[16:18:44.870] {
[16:18:44.870]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.870]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:44.870]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.870]         on.exit(options(oopts), add = TRUE)
[16:18:44.870]     }
[16:18:44.870]     {
[16:18:44.870]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.870]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:44.870]         do.call(mapply, args = args)
[16:18:44.870]     }
[16:18:44.870] }
[16:18:44.870] Lazy evaluation: FALSE
[16:18:44.870] Asynchronous evaluation: TRUE
[16:18:44.870] Local evaluation: TRUE
[16:18:44.870] Environment: R_GlobalEnv
[16:18:44.870] Capture standard output: TRUE
[16:18:44.870] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:44.870] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:44.870] Packages: <none>
[16:18:44.870] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:44.870] Resolved: FALSE
[16:18:44.870] Value: <not collected>
[16:18:44.870] Conditions captured: <none>
[16:18:44.870] Early signaling: FALSE
[16:18:44.870] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:44.870] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.882] Chunk #1 of 2 ... DONE
[16:18:44.882] Chunk #2 of 2 ...
[16:18:44.882]  - Finding globals in '...' for chunk #2 ...
[16:18:44.882] getGlobalsAndPackages() ...
[16:18:44.882] Searching for globals...
[16:18:44.882] 
[16:18:44.882] Searching for globals ... DONE
[16:18:44.882] - globals: [0] <none>
[16:18:44.883] getGlobalsAndPackages() ... DONE
[16:18:44.883]    + additional globals found: [n=0] 
[16:18:44.883]    + additional namespaces needed: [n=0] 
[16:18:44.883]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:44.883]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:44.883]  - seeds: <none>
[16:18:44.883]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.883] getGlobalsAndPackages() ...
[16:18:44.883] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.883] Resolving globals: FALSE
[16:18:44.884] The total size of the 5 globals is 224 bytes (224 bytes)
[16:18:44.884] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[16:18:44.884] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.885] 
[16:18:44.885] getGlobalsAndPackages() ... DONE
[16:18:44.885] run() for ‘Future’ ...
[16:18:44.885] - state: ‘created’
[16:18:44.885] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:44.900] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.900] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:44.900]   - Field: ‘node’
[16:18:44.900]   - Field: ‘label’
[16:18:44.900]   - Field: ‘local’
[16:18:44.901]   - Field: ‘owner’
[16:18:44.901]   - Field: ‘envir’
[16:18:44.901]   - Field: ‘workers’
[16:18:44.901]   - Field: ‘packages’
[16:18:44.901]   - Field: ‘gc’
[16:18:44.901]   - Field: ‘conditions’
[16:18:44.901]   - Field: ‘persistent’
[16:18:44.901]   - Field: ‘expr’
[16:18:44.901]   - Field: ‘uuid’
[16:18:44.901]   - Field: ‘seed’
[16:18:44.901]   - Field: ‘version’
[16:18:44.902]   - Field: ‘result’
[16:18:44.902]   - Field: ‘asynchronous’
[16:18:44.902]   - Field: ‘calls’
[16:18:44.902]   - Field: ‘globals’
[16:18:44.902]   - Field: ‘stdout’
[16:18:44.902]   - Field: ‘earlySignal’
[16:18:44.902]   - Field: ‘lazy’
[16:18:44.902]   - Field: ‘state’
[16:18:44.902] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:44.902] - Launch lazy future ...
[16:18:44.903] Packages needed by the future expression (n = 0): <none>
[16:18:44.903] Packages needed by future strategies (n = 0): <none>
[16:18:44.903] {
[16:18:44.903]     {
[16:18:44.903]         {
[16:18:44.903]             ...future.startTime <- base::Sys.time()
[16:18:44.903]             {
[16:18:44.903]                 {
[16:18:44.903]                   {
[16:18:44.903]                     {
[16:18:44.903]                       base::local({
[16:18:44.903]                         has_future <- base::requireNamespace("future", 
[16:18:44.903]                           quietly = TRUE)
[16:18:44.903]                         if (has_future) {
[16:18:44.903]                           ns <- base::getNamespace("future")
[16:18:44.903]                           version <- ns[[".package"]][["version"]]
[16:18:44.903]                           if (is.null(version)) 
[16:18:44.903]                             version <- utils::packageVersion("future")
[16:18:44.903]                         }
[16:18:44.903]                         else {
[16:18:44.903]                           version <- NULL
[16:18:44.903]                         }
[16:18:44.903]                         if (!has_future || version < "1.8.0") {
[16:18:44.903]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:44.903]                             "", base::R.version$version.string), 
[16:18:44.903]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:44.903]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:44.903]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:44.903]                               "release", "version")], collapse = " "), 
[16:18:44.903]                             hostname = base::Sys.info()[["nodename"]])
[16:18:44.903]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:44.903]                             info)
[16:18:44.903]                           info <- base::paste(info, collapse = "; ")
[16:18:44.903]                           if (!has_future) {
[16:18:44.903]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:44.903]                               info)
[16:18:44.903]                           }
[16:18:44.903]                           else {
[16:18:44.903]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:44.903]                               info, version)
[16:18:44.903]                           }
[16:18:44.903]                           base::stop(msg)
[16:18:44.903]                         }
[16:18:44.903]                       })
[16:18:44.903]                     }
[16:18:44.903]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:44.903]                     base::options(mc.cores = 1L)
[16:18:44.903]                   }
[16:18:44.903]                   ...future.strategy.old <- future::plan("list")
[16:18:44.903]                   options(future.plan = NULL)
[16:18:44.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:44.903]                 }
[16:18:44.903]                 ...future.workdir <- getwd()
[16:18:44.903]             }
[16:18:44.903]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:44.903]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:44.903]         }
[16:18:44.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:44.903]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:44.903]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:44.903]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:44.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:44.903]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:44.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:44.903]             base::names(...future.oldOptions))
[16:18:44.903]     }
[16:18:44.903]     if (FALSE) {
[16:18:44.903]     }
[16:18:44.903]     else {
[16:18:44.903]         if (TRUE) {
[16:18:44.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:44.903]                 open = "w")
[16:18:44.903]         }
[16:18:44.903]         else {
[16:18:44.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:44.903]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:44.903]         }
[16:18:44.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:44.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:44.903]             base::sink(type = "output", split = FALSE)
[16:18:44.903]             base::close(...future.stdout)
[16:18:44.903]         }, add = TRUE)
[16:18:44.903]     }
[16:18:44.903]     ...future.frame <- base::sys.nframe()
[16:18:44.903]     ...future.conditions <- base::list()
[16:18:44.903]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:44.903]     if (FALSE) {
[16:18:44.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:44.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:44.903]     }
[16:18:44.903]     ...future.result <- base::tryCatch({
[16:18:44.903]         base::withCallingHandlers({
[16:18:44.903]             ...future.value <- base::withVisible(base::local({
[16:18:44.903]                 ...future.makeSendCondition <- base::local({
[16:18:44.903]                   sendCondition <- NULL
[16:18:44.903]                   function(frame = 1L) {
[16:18:44.903]                     if (is.function(sendCondition)) 
[16:18:44.903]                       return(sendCondition)
[16:18:44.903]                     ns <- getNamespace("parallel")
[16:18:44.903]                     if (exists("sendData", mode = "function", 
[16:18:44.903]                       envir = ns)) {
[16:18:44.903]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:44.903]                         envir = ns)
[16:18:44.903]                       envir <- sys.frame(frame)
[16:18:44.903]                       master <- NULL
[16:18:44.903]                       while (!identical(envir, .GlobalEnv) && 
[16:18:44.903]                         !identical(envir, emptyenv())) {
[16:18:44.903]                         if (exists("master", mode = "list", envir = envir, 
[16:18:44.903]                           inherits = FALSE)) {
[16:18:44.903]                           master <- get("master", mode = "list", 
[16:18:44.903]                             envir = envir, inherits = FALSE)
[16:18:44.903]                           if (inherits(master, c("SOCKnode", 
[16:18:44.903]                             "SOCK0node"))) {
[16:18:44.903]                             sendCondition <<- function(cond) {
[16:18:44.903]                               data <- list(type = "VALUE", value = cond, 
[16:18:44.903]                                 success = TRUE)
[16:18:44.903]                               parallel_sendData(master, data)
[16:18:44.903]                             }
[16:18:44.903]                             return(sendCondition)
[16:18:44.903]                           }
[16:18:44.903]                         }
[16:18:44.903]                         frame <- frame + 1L
[16:18:44.903]                         envir <- sys.frame(frame)
[16:18:44.903]                       }
[16:18:44.903]                     }
[16:18:44.903]                     sendCondition <<- function(cond) NULL
[16:18:44.903]                   }
[16:18:44.903]                 })
[16:18:44.903]                 withCallingHandlers({
[16:18:44.903]                   {
[16:18:44.903]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.903]                     if (!identical(...future.globals.maxSize.org, 
[16:18:44.903]                       ...future.globals.maxSize)) {
[16:18:44.903]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.903]                       on.exit(options(oopts), add = TRUE)
[16:18:44.903]                     }
[16:18:44.903]                     {
[16:18:44.903]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.903]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:44.903]                         USE.NAMES = FALSE)
[16:18:44.903]                       do.call(mapply, args = args)
[16:18:44.903]                     }
[16:18:44.903]                   }
[16:18:44.903]                 }, immediateCondition = function(cond) {
[16:18:44.903]                   sendCondition <- ...future.makeSendCondition()
[16:18:44.903]                   sendCondition(cond)
[16:18:44.903]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.903]                   {
[16:18:44.903]                     inherits <- base::inherits
[16:18:44.903]                     invokeRestart <- base::invokeRestart
[16:18:44.903]                     is.null <- base::is.null
[16:18:44.903]                     muffled <- FALSE
[16:18:44.903]                     if (inherits(cond, "message")) {
[16:18:44.903]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:44.903]                       if (muffled) 
[16:18:44.903]                         invokeRestart("muffleMessage")
[16:18:44.903]                     }
[16:18:44.903]                     else if (inherits(cond, "warning")) {
[16:18:44.903]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:44.903]                       if (muffled) 
[16:18:44.903]                         invokeRestart("muffleWarning")
[16:18:44.903]                     }
[16:18:44.903]                     else if (inherits(cond, "condition")) {
[16:18:44.903]                       if (!is.null(pattern)) {
[16:18:44.903]                         computeRestarts <- base::computeRestarts
[16:18:44.903]                         grepl <- base::grepl
[16:18:44.903]                         restarts <- computeRestarts(cond)
[16:18:44.903]                         for (restart in restarts) {
[16:18:44.903]                           name <- restart$name
[16:18:44.903]                           if (is.null(name)) 
[16:18:44.903]                             next
[16:18:44.903]                           if (!grepl(pattern, name)) 
[16:18:44.903]                             next
[16:18:44.903]                           invokeRestart(restart)
[16:18:44.903]                           muffled <- TRUE
[16:18:44.903]                           break
[16:18:44.903]                         }
[16:18:44.903]                       }
[16:18:44.903]                     }
[16:18:44.903]                     invisible(muffled)
[16:18:44.903]                   }
[16:18:44.903]                   muffleCondition(cond)
[16:18:44.903]                 })
[16:18:44.903]             }))
[16:18:44.903]             future::FutureResult(value = ...future.value$value, 
[16:18:44.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.903]                   ...future.rng), globalenv = if (FALSE) 
[16:18:44.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:44.903]                     ...future.globalenv.names))
[16:18:44.903]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:44.903]         }, condition = base::local({
[16:18:44.903]             c <- base::c
[16:18:44.903]             inherits <- base::inherits
[16:18:44.903]             invokeRestart <- base::invokeRestart
[16:18:44.903]             length <- base::length
[16:18:44.903]             list <- base::list
[16:18:44.903]             seq.int <- base::seq.int
[16:18:44.903]             signalCondition <- base::signalCondition
[16:18:44.903]             sys.calls <- base::sys.calls
[16:18:44.903]             `[[` <- base::`[[`
[16:18:44.903]             `+` <- base::`+`
[16:18:44.903]             `<<-` <- base::`<<-`
[16:18:44.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:44.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:44.903]                   3L)]
[16:18:44.903]             }
[16:18:44.903]             function(cond) {
[16:18:44.903]                 is_error <- inherits(cond, "error")
[16:18:44.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:44.903]                   NULL)
[16:18:44.903]                 if (is_error) {
[16:18:44.903]                   sessionInformation <- function() {
[16:18:44.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:44.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:44.903]                       search = base::search(), system = base::Sys.info())
[16:18:44.903]                   }
[16:18:44.903]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:44.903]                     cond$call), session = sessionInformation(), 
[16:18:44.903]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:44.903]                   signalCondition(cond)
[16:18:44.903]                 }
[16:18:44.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:44.903]                 "immediateCondition"))) {
[16:18:44.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:44.903]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:44.903]                   if (TRUE && !signal) {
[16:18:44.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.903]                     {
[16:18:44.903]                       inherits <- base::inherits
[16:18:44.903]                       invokeRestart <- base::invokeRestart
[16:18:44.903]                       is.null <- base::is.null
[16:18:44.903]                       muffled <- FALSE
[16:18:44.903]                       if (inherits(cond, "message")) {
[16:18:44.903]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.903]                         if (muffled) 
[16:18:44.903]                           invokeRestart("muffleMessage")
[16:18:44.903]                       }
[16:18:44.903]                       else if (inherits(cond, "warning")) {
[16:18:44.903]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.903]                         if (muffled) 
[16:18:44.903]                           invokeRestart("muffleWarning")
[16:18:44.903]                       }
[16:18:44.903]                       else if (inherits(cond, "condition")) {
[16:18:44.903]                         if (!is.null(pattern)) {
[16:18:44.903]                           computeRestarts <- base::computeRestarts
[16:18:44.903]                           grepl <- base::grepl
[16:18:44.903]                           restarts <- computeRestarts(cond)
[16:18:44.903]                           for (restart in restarts) {
[16:18:44.903]                             name <- restart$name
[16:18:44.903]                             if (is.null(name)) 
[16:18:44.903]                               next
[16:18:44.903]                             if (!grepl(pattern, name)) 
[16:18:44.903]                               next
[16:18:44.903]                             invokeRestart(restart)
[16:18:44.903]                             muffled <- TRUE
[16:18:44.903]                             break
[16:18:44.903]                           }
[16:18:44.903]                         }
[16:18:44.903]                       }
[16:18:44.903]                       invisible(muffled)
[16:18:44.903]                     }
[16:18:44.903]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.903]                   }
[16:18:44.903]                 }
[16:18:44.903]                 else {
[16:18:44.903]                   if (TRUE) {
[16:18:44.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.903]                     {
[16:18:44.903]                       inherits <- base::inherits
[16:18:44.903]                       invokeRestart <- base::invokeRestart
[16:18:44.903]                       is.null <- base::is.null
[16:18:44.903]                       muffled <- FALSE
[16:18:44.903]                       if (inherits(cond, "message")) {
[16:18:44.903]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.903]                         if (muffled) 
[16:18:44.903]                           invokeRestart("muffleMessage")
[16:18:44.903]                       }
[16:18:44.903]                       else if (inherits(cond, "warning")) {
[16:18:44.903]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.903]                         if (muffled) 
[16:18:44.903]                           invokeRestart("muffleWarning")
[16:18:44.903]                       }
[16:18:44.903]                       else if (inherits(cond, "condition")) {
[16:18:44.903]                         if (!is.null(pattern)) {
[16:18:44.903]                           computeRestarts <- base::computeRestarts
[16:18:44.903]                           grepl <- base::grepl
[16:18:44.903]                           restarts <- computeRestarts(cond)
[16:18:44.903]                           for (restart in restarts) {
[16:18:44.903]                             name <- restart$name
[16:18:44.903]                             if (is.null(name)) 
[16:18:44.903]                               next
[16:18:44.903]                             if (!grepl(pattern, name)) 
[16:18:44.903]                               next
[16:18:44.903]                             invokeRestart(restart)
[16:18:44.903]                             muffled <- TRUE
[16:18:44.903]                             break
[16:18:44.903]                           }
[16:18:44.903]                         }
[16:18:44.903]                       }
[16:18:44.903]                       invisible(muffled)
[16:18:44.903]                     }
[16:18:44.903]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.903]                   }
[16:18:44.903]                 }
[16:18:44.903]             }
[16:18:44.903]         }))
[16:18:44.903]     }, error = function(ex) {
[16:18:44.903]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:44.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.903]                 ...future.rng), started = ...future.startTime, 
[16:18:44.903]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:44.903]             version = "1.8"), class = "FutureResult")
[16:18:44.903]     }, finally = {
[16:18:44.903]         if (!identical(...future.workdir, getwd())) 
[16:18:44.903]             setwd(...future.workdir)
[16:18:44.903]         {
[16:18:44.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:44.903]                 ...future.oldOptions$nwarnings <- NULL
[16:18:44.903]             }
[16:18:44.903]             base::options(...future.oldOptions)
[16:18:44.903]             if (.Platform$OS.type == "windows") {
[16:18:44.903]                 old_names <- names(...future.oldEnvVars)
[16:18:44.903]                 envs <- base::Sys.getenv()
[16:18:44.903]                 names <- names(envs)
[16:18:44.903]                 common <- intersect(names, old_names)
[16:18:44.903]                 added <- setdiff(names, old_names)
[16:18:44.903]                 removed <- setdiff(old_names, names)
[16:18:44.903]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:44.903]                   envs[common]]
[16:18:44.903]                 NAMES <- toupper(changed)
[16:18:44.903]                 args <- list()
[16:18:44.903]                 for (kk in seq_along(NAMES)) {
[16:18:44.903]                   name <- changed[[kk]]
[16:18:44.903]                   NAME <- NAMES[[kk]]
[16:18:44.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.903]                     next
[16:18:44.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.903]                 }
[16:18:44.903]                 NAMES <- toupper(added)
[16:18:44.903]                 for (kk in seq_along(NAMES)) {
[16:18:44.903]                   name <- added[[kk]]
[16:18:44.903]                   NAME <- NAMES[[kk]]
[16:18:44.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.903]                     next
[16:18:44.903]                   args[[name]] <- ""
[16:18:44.903]                 }
[16:18:44.903]                 NAMES <- toupper(removed)
[16:18:44.903]                 for (kk in seq_along(NAMES)) {
[16:18:44.903]                   name <- removed[[kk]]
[16:18:44.903]                   NAME <- NAMES[[kk]]
[16:18:44.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.903]                     next
[16:18:44.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.903]                 }
[16:18:44.903]                 if (length(args) > 0) 
[16:18:44.903]                   base::do.call(base::Sys.setenv, args = args)
[16:18:44.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:44.903]             }
[16:18:44.903]             else {
[16:18:44.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:44.903]             }
[16:18:44.903]             {
[16:18:44.903]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:44.903]                   0L) {
[16:18:44.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:44.903]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:44.903]                   base::options(opts)
[16:18:44.903]                 }
[16:18:44.903]                 {
[16:18:44.903]                   {
[16:18:44.903]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:44.903]                     NULL
[16:18:44.903]                   }
[16:18:44.903]                   options(future.plan = NULL)
[16:18:44.903]                   if (is.na(NA_character_)) 
[16:18:44.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:44.903]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:44.903]                     .init = FALSE)
[16:18:44.903]                 }
[16:18:44.903]             }
[16:18:44.903]         }
[16:18:44.903]     })
[16:18:44.903]     if (TRUE) {
[16:18:44.903]         base::sink(type = "output", split = FALSE)
[16:18:44.903]         if (TRUE) {
[16:18:44.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:44.903]         }
[16:18:44.903]         else {
[16:18:44.903]             ...future.result["stdout"] <- base::list(NULL)
[16:18:44.903]         }
[16:18:44.903]         base::close(...future.stdout)
[16:18:44.903]         ...future.stdout <- NULL
[16:18:44.903]     }
[16:18:44.903]     ...future.result$conditions <- ...future.conditions
[16:18:44.903]     ...future.result$finished <- base::Sys.time()
[16:18:44.903]     ...future.result
[16:18:44.903] }
[16:18:44.906] Exporting 5 global objects (224 bytes) to cluster node #2 ...
[16:18:44.906] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[16:18:44.906] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[16:18:44.907] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[16:18:44.907] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[16:18:44.907] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:18:44.907] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:18:44.907] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:44.908] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:44.908] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:44.908] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:44.908] Exporting 5 global objects (224 bytes) to cluster node #2 ... DONE
[16:18:44.909] MultisessionFuture started
[16:18:44.909] - Launch lazy future ... done
[16:18:44.909] run() for ‘MultisessionFuture’ ... done
[16:18:44.909] Created future:
[16:18:44.909] MultisessionFuture:
[16:18:44.909] Label: ‘future_mapply-2’
[16:18:44.909] Expression:
[16:18:44.909] {
[16:18:44.909]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.909]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:44.909]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.909]         on.exit(options(oopts), add = TRUE)
[16:18:44.909]     }
[16:18:44.909]     {
[16:18:44.909]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.909]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:44.909]         do.call(mapply, args = args)
[16:18:44.909]     }
[16:18:44.909] }
[16:18:44.909] Lazy evaluation: FALSE
[16:18:44.909] Asynchronous evaluation: TRUE
[16:18:44.909] Local evaluation: TRUE
[16:18:44.909] Environment: R_GlobalEnv
[16:18:44.909] Capture standard output: TRUE
[16:18:44.909] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:44.909] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:44.909] Packages: <none>
[16:18:44.909] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:44.909] Resolved: FALSE
[16:18:44.909] Value: <not collected>
[16:18:44.909] Conditions captured: <none>
[16:18:44.909] Early signaling: FALSE
[16:18:44.909] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:44.909] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.921] Chunk #2 of 2 ... DONE
[16:18:44.921] Launching 2 futures (chunks) ... DONE
[16:18:44.921] Resolving 2 futures (chunks) ...
[16:18:44.921] resolve() on list ...
[16:18:44.921]  recursive: 0
[16:18:44.921]  length: 2
[16:18:44.921] 
[16:18:44.922] receiveMessageFromWorker() for ClusterFuture ...
[16:18:44.922] - Validating connection of MultisessionFuture
[16:18:44.922] - received message: FutureResult
[16:18:44.922] - Received FutureResult
[16:18:44.922] - Erased future from FutureRegistry
[16:18:44.922] result() for ClusterFuture ...
[16:18:44.922] - result already collected: FutureResult
[16:18:44.923] result() for ClusterFuture ... done
[16:18:44.923] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:44.923] Future #1
[16:18:44.923] result() for ClusterFuture ...
[16:18:44.923] - result already collected: FutureResult
[16:18:44.923] result() for ClusterFuture ... done
[16:18:44.923] result() for ClusterFuture ...
[16:18:44.923] - result already collected: FutureResult
[16:18:44.923] result() for ClusterFuture ... done
[16:18:44.923] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:44.924] - nx: 2
[16:18:44.924] - relay: TRUE
[16:18:44.924] - stdout: TRUE
[16:18:44.924] - signal: TRUE
[16:18:44.926] - resignal: FALSE
[16:18:44.926] - force: TRUE
[16:18:44.926] - relayed: [n=2] FALSE, FALSE
[16:18:44.926] - queued futures: [n=2] FALSE, FALSE
[16:18:44.927]  - until=1
[16:18:44.927]  - relaying element #1
[16:18:44.927] result() for ClusterFuture ...
[16:18:44.927] - result already collected: FutureResult
[16:18:44.927] result() for ClusterFuture ... done
[16:18:44.927] result() for ClusterFuture ...
[16:18:44.927] - result already collected: FutureResult
[16:18:44.927] result() for ClusterFuture ... done
[16:18:44.927] result() for ClusterFuture ...
[16:18:44.927] - result already collected: FutureResult
[16:18:44.928] result() for ClusterFuture ... done
[16:18:44.928] result() for ClusterFuture ...
[16:18:44.928] - result already collected: FutureResult
[16:18:44.928] result() for ClusterFuture ... done
[16:18:44.928] - relayed: [n=2] TRUE, FALSE
[16:18:44.928] - queued futures: [n=2] TRUE, FALSE
[16:18:44.928] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:44.928]  length: 1 (resolved future 1)
[16:18:44.954] receiveMessageFromWorker() for ClusterFuture ...
[16:18:44.954] - Validating connection of MultisessionFuture
[16:18:44.954] - received message: FutureResult
[16:18:44.954] - Received FutureResult
[16:18:44.954] - Erased future from FutureRegistry
[16:18:44.955] result() for ClusterFuture ...
[16:18:44.955] - result already collected: FutureResult
[16:18:44.955] result() for ClusterFuture ... done
[16:18:44.955] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:44.955] Future #2
[16:18:44.955] result() for ClusterFuture ...
[16:18:44.955] - result already collected: FutureResult
[16:18:44.955] result() for ClusterFuture ... done
[16:18:44.955] result() for ClusterFuture ...
[16:18:44.955] - result already collected: FutureResult
[16:18:44.955] result() for ClusterFuture ... done
[16:18:44.956] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:44.956] - nx: 2
[16:18:44.956] - relay: TRUE
[16:18:44.956] - stdout: TRUE
[16:18:44.956] - signal: TRUE
[16:18:44.956] - resignal: FALSE
[16:18:44.956] - force: TRUE
[16:18:44.956] - relayed: [n=2] TRUE, FALSE
[16:18:44.956] - queued futures: [n=2] TRUE, FALSE
[16:18:44.956]  - until=2
[16:18:44.956]  - relaying element #2
[16:18:44.956] result() for ClusterFuture ...
[16:18:44.957] - result already collected: FutureResult
[16:18:44.957] result() for ClusterFuture ... done
[16:18:44.957] result() for ClusterFuture ...
[16:18:44.957] - result already collected: FutureResult
[16:18:44.957] result() for ClusterFuture ... done
[16:18:44.957] result() for ClusterFuture ...
[16:18:44.957] - result already collected: FutureResult
[16:18:44.957] result() for ClusterFuture ... done
[16:18:44.957] result() for ClusterFuture ...
[16:18:44.957] - result already collected: FutureResult
[16:18:44.957] result() for ClusterFuture ... done
[16:18:44.958] - relayed: [n=2] TRUE, TRUE
[16:18:44.958] - queued futures: [n=2] TRUE, TRUE
[16:18:44.958] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:44.958]  length: 0 (resolved future 2)
[16:18:44.958] Relaying remaining futures
[16:18:44.958] signalConditionsASAP(NULL, pos=0) ...
[16:18:44.958] - nx: 2
[16:18:44.958] - relay: TRUE
[16:18:44.958] - stdout: TRUE
[16:18:44.958] - signal: TRUE
[16:18:44.958] - resignal: FALSE
[16:18:44.958] - force: TRUE
[16:18:44.959] - relayed: [n=2] TRUE, TRUE
[16:18:44.959] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:44.959] - relayed: [n=2] TRUE, TRUE
[16:18:44.959] - queued futures: [n=2] TRUE, TRUE
[16:18:44.959] signalConditionsASAP(NULL, pos=0) ... done
[16:18:44.959] resolve() on list ... DONE
[16:18:44.959] result() for ClusterFuture ...
[16:18:44.959] - result already collected: FutureResult
[16:18:44.959] result() for ClusterFuture ... done
[16:18:44.959] result() for ClusterFuture ...
[16:18:44.959] - result already collected: FutureResult
[16:18:44.960] result() for ClusterFuture ... done
[16:18:44.960] result() for ClusterFuture ...
[16:18:44.960] - result already collected: FutureResult
[16:18:44.960] result() for ClusterFuture ... done
[16:18:44.960] result() for ClusterFuture ...
[16:18:44.960] - result already collected: FutureResult
[16:18:44.960] result() for ClusterFuture ... done
[16:18:44.960]  - Number of value chunks collected: 2
[16:18:44.960] Resolving 2 futures (chunks) ... DONE
[16:18:44.960] Reducing values from 2 chunks ...
[16:18:44.960]  - Number of values collected after concatenation: 4
[16:18:44.961]  - Number of values expected: 4
[16:18:44.961] Reducing values from 2 chunks ... DONE
[16:18:44.961] future_mapply() ... DONE
[16:18:44.961] future_mapply() ...
[16:18:44.965] Number of chunks: 2
[16:18:44.965] getGlobalsAndPackagesXApply() ...
[16:18:44.965]  - future.globals: TRUE
[16:18:44.965] getGlobalsAndPackages() ...
[16:18:44.965] Searching for globals...
[16:18:44.966] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[16:18:44.967] Searching for globals ... DONE
[16:18:44.967] Resolving globals: FALSE
[16:18:44.967] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[16:18:44.967] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[16:18:44.967] - globals: [1] ‘FUN’
[16:18:44.968] 
[16:18:44.968] getGlobalsAndPackages() ... DONE
[16:18:44.968]  - globals found/used: [n=1] ‘FUN’
[16:18:44.968]  - needed namespaces: [n=0] 
[16:18:44.968] Finding globals ... DONE
[16:18:44.968] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:44.968] List of 2
[16:18:44.968]  $ ...future.FUN:function (x, y)  
[16:18:44.968]  $ MoreArgs     : NULL
[16:18:44.968]  - attr(*, "where")=List of 2
[16:18:44.968]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:44.968]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:44.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:44.968]  - attr(*, "resolved")= logi FALSE
[16:18:44.968]  - attr(*, "total_size")= num NA
[16:18:44.971] Packages to be attached in all futures: [n=0] 
[16:18:44.971] getGlobalsAndPackagesXApply() ... DONE
[16:18:44.971] Number of futures (= number of chunks): 2
[16:18:44.971] Launching 2 futures (chunks) ...
[16:18:44.971] Chunk #1 of 2 ...
[16:18:44.971]  - Finding globals in '...' for chunk #1 ...
[16:18:44.971] getGlobalsAndPackages() ...
[16:18:44.972] Searching for globals...
[16:18:44.972] 
[16:18:44.972] Searching for globals ... DONE
[16:18:44.972] - globals: [0] <none>
[16:18:44.972] getGlobalsAndPackages() ... DONE
[16:18:44.972]    + additional globals found: [n=0] 
[16:18:44.972]    + additional namespaces needed: [n=0] 
[16:18:44.972]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:44.973]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:44.973]  - seeds: <none>
[16:18:44.973]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.973] getGlobalsAndPackages() ...
[16:18:44.973] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.973] Resolving globals: FALSE
[16:18:44.973] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[16:18:44.974] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:44.974] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:44.974] 
[16:18:44.974] getGlobalsAndPackages() ... DONE
[16:18:44.975] run() for ‘Future’ ...
[16:18:44.975] - state: ‘created’
[16:18:44.975] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:44.988] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:44.989] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:44.989]   - Field: ‘node’
[16:18:44.989]   - Field: ‘label’
[16:18:44.989]   - Field: ‘local’
[16:18:44.989]   - Field: ‘owner’
[16:18:44.989]   - Field: ‘envir’
[16:18:44.989]   - Field: ‘workers’
[16:18:44.989]   - Field: ‘packages’
[16:18:44.989]   - Field: ‘gc’
[16:18:44.989]   - Field: ‘conditions’
[16:18:44.990]   - Field: ‘persistent’
[16:18:44.990]   - Field: ‘expr’
[16:18:44.990]   - Field: ‘uuid’
[16:18:44.990]   - Field: ‘seed’
[16:18:44.990]   - Field: ‘version’
[16:18:44.990]   - Field: ‘result’
[16:18:44.990]   - Field: ‘asynchronous’
[16:18:44.990]   - Field: ‘calls’
[16:18:44.990]   - Field: ‘globals’
[16:18:44.990]   - Field: ‘stdout’
[16:18:44.991]   - Field: ‘earlySignal’
[16:18:44.991]   - Field: ‘lazy’
[16:18:44.991]   - Field: ‘state’
[16:18:44.991] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:44.991] - Launch lazy future ...
[16:18:44.991] Packages needed by the future expression (n = 0): <none>
[16:18:44.991] Packages needed by future strategies (n = 0): <none>
[16:18:44.992] {
[16:18:44.992]     {
[16:18:44.992]         {
[16:18:44.992]             ...future.startTime <- base::Sys.time()
[16:18:44.992]             {
[16:18:44.992]                 {
[16:18:44.992]                   {
[16:18:44.992]                     {
[16:18:44.992]                       base::local({
[16:18:44.992]                         has_future <- base::requireNamespace("future", 
[16:18:44.992]                           quietly = TRUE)
[16:18:44.992]                         if (has_future) {
[16:18:44.992]                           ns <- base::getNamespace("future")
[16:18:44.992]                           version <- ns[[".package"]][["version"]]
[16:18:44.992]                           if (is.null(version)) 
[16:18:44.992]                             version <- utils::packageVersion("future")
[16:18:44.992]                         }
[16:18:44.992]                         else {
[16:18:44.992]                           version <- NULL
[16:18:44.992]                         }
[16:18:44.992]                         if (!has_future || version < "1.8.0") {
[16:18:44.992]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:44.992]                             "", base::R.version$version.string), 
[16:18:44.992]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:44.992]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:44.992]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:44.992]                               "release", "version")], collapse = " "), 
[16:18:44.992]                             hostname = base::Sys.info()[["nodename"]])
[16:18:44.992]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:44.992]                             info)
[16:18:44.992]                           info <- base::paste(info, collapse = "; ")
[16:18:44.992]                           if (!has_future) {
[16:18:44.992]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:44.992]                               info)
[16:18:44.992]                           }
[16:18:44.992]                           else {
[16:18:44.992]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:44.992]                               info, version)
[16:18:44.992]                           }
[16:18:44.992]                           base::stop(msg)
[16:18:44.992]                         }
[16:18:44.992]                       })
[16:18:44.992]                     }
[16:18:44.992]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:44.992]                     base::options(mc.cores = 1L)
[16:18:44.992]                   }
[16:18:44.992]                   ...future.strategy.old <- future::plan("list")
[16:18:44.992]                   options(future.plan = NULL)
[16:18:44.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:44.992]                 }
[16:18:44.992]                 ...future.workdir <- getwd()
[16:18:44.992]             }
[16:18:44.992]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:44.992]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:44.992]         }
[16:18:44.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:44.992]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:44.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:44.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:44.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:44.992]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:44.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:44.992]             base::names(...future.oldOptions))
[16:18:44.992]     }
[16:18:44.992]     if (FALSE) {
[16:18:44.992]     }
[16:18:44.992]     else {
[16:18:44.992]         if (TRUE) {
[16:18:44.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:44.992]                 open = "w")
[16:18:44.992]         }
[16:18:44.992]         else {
[16:18:44.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:44.992]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:44.992]         }
[16:18:44.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:44.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:44.992]             base::sink(type = "output", split = FALSE)
[16:18:44.992]             base::close(...future.stdout)
[16:18:44.992]         }, add = TRUE)
[16:18:44.992]     }
[16:18:44.992]     ...future.frame <- base::sys.nframe()
[16:18:44.992]     ...future.conditions <- base::list()
[16:18:44.992]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:44.992]     if (FALSE) {
[16:18:44.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:44.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:44.992]     }
[16:18:44.992]     ...future.result <- base::tryCatch({
[16:18:44.992]         base::withCallingHandlers({
[16:18:44.992]             ...future.value <- base::withVisible(base::local({
[16:18:44.992]                 ...future.makeSendCondition <- base::local({
[16:18:44.992]                   sendCondition <- NULL
[16:18:44.992]                   function(frame = 1L) {
[16:18:44.992]                     if (is.function(sendCondition)) 
[16:18:44.992]                       return(sendCondition)
[16:18:44.992]                     ns <- getNamespace("parallel")
[16:18:44.992]                     if (exists("sendData", mode = "function", 
[16:18:44.992]                       envir = ns)) {
[16:18:44.992]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:44.992]                         envir = ns)
[16:18:44.992]                       envir <- sys.frame(frame)
[16:18:44.992]                       master <- NULL
[16:18:44.992]                       while (!identical(envir, .GlobalEnv) && 
[16:18:44.992]                         !identical(envir, emptyenv())) {
[16:18:44.992]                         if (exists("master", mode = "list", envir = envir, 
[16:18:44.992]                           inherits = FALSE)) {
[16:18:44.992]                           master <- get("master", mode = "list", 
[16:18:44.992]                             envir = envir, inherits = FALSE)
[16:18:44.992]                           if (inherits(master, c("SOCKnode", 
[16:18:44.992]                             "SOCK0node"))) {
[16:18:44.992]                             sendCondition <<- function(cond) {
[16:18:44.992]                               data <- list(type = "VALUE", value = cond, 
[16:18:44.992]                                 success = TRUE)
[16:18:44.992]                               parallel_sendData(master, data)
[16:18:44.992]                             }
[16:18:44.992]                             return(sendCondition)
[16:18:44.992]                           }
[16:18:44.992]                         }
[16:18:44.992]                         frame <- frame + 1L
[16:18:44.992]                         envir <- sys.frame(frame)
[16:18:44.992]                       }
[16:18:44.992]                     }
[16:18:44.992]                     sendCondition <<- function(cond) NULL
[16:18:44.992]                   }
[16:18:44.992]                 })
[16:18:44.992]                 withCallingHandlers({
[16:18:44.992]                   {
[16:18:44.992]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.992]                     if (!identical(...future.globals.maxSize.org, 
[16:18:44.992]                       ...future.globals.maxSize)) {
[16:18:44.992]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.992]                       on.exit(options(oopts), add = TRUE)
[16:18:44.992]                     }
[16:18:44.992]                     {
[16:18:44.992]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.992]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:44.992]                         USE.NAMES = FALSE)
[16:18:44.992]                       do.call(mapply, args = args)
[16:18:44.992]                     }
[16:18:44.992]                   }
[16:18:44.992]                 }, immediateCondition = function(cond) {
[16:18:44.992]                   sendCondition <- ...future.makeSendCondition()
[16:18:44.992]                   sendCondition(cond)
[16:18:44.992]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.992]                   {
[16:18:44.992]                     inherits <- base::inherits
[16:18:44.992]                     invokeRestart <- base::invokeRestart
[16:18:44.992]                     is.null <- base::is.null
[16:18:44.992]                     muffled <- FALSE
[16:18:44.992]                     if (inherits(cond, "message")) {
[16:18:44.992]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:44.992]                       if (muffled) 
[16:18:44.992]                         invokeRestart("muffleMessage")
[16:18:44.992]                     }
[16:18:44.992]                     else if (inherits(cond, "warning")) {
[16:18:44.992]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:44.992]                       if (muffled) 
[16:18:44.992]                         invokeRestart("muffleWarning")
[16:18:44.992]                     }
[16:18:44.992]                     else if (inherits(cond, "condition")) {
[16:18:44.992]                       if (!is.null(pattern)) {
[16:18:44.992]                         computeRestarts <- base::computeRestarts
[16:18:44.992]                         grepl <- base::grepl
[16:18:44.992]                         restarts <- computeRestarts(cond)
[16:18:44.992]                         for (restart in restarts) {
[16:18:44.992]                           name <- restart$name
[16:18:44.992]                           if (is.null(name)) 
[16:18:44.992]                             next
[16:18:44.992]                           if (!grepl(pattern, name)) 
[16:18:44.992]                             next
[16:18:44.992]                           invokeRestart(restart)
[16:18:44.992]                           muffled <- TRUE
[16:18:44.992]                           break
[16:18:44.992]                         }
[16:18:44.992]                       }
[16:18:44.992]                     }
[16:18:44.992]                     invisible(muffled)
[16:18:44.992]                   }
[16:18:44.992]                   muffleCondition(cond)
[16:18:44.992]                 })
[16:18:44.992]             }))
[16:18:44.992]             future::FutureResult(value = ...future.value$value, 
[16:18:44.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.992]                   ...future.rng), globalenv = if (FALSE) 
[16:18:44.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:44.992]                     ...future.globalenv.names))
[16:18:44.992]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:44.992]         }, condition = base::local({
[16:18:44.992]             c <- base::c
[16:18:44.992]             inherits <- base::inherits
[16:18:44.992]             invokeRestart <- base::invokeRestart
[16:18:44.992]             length <- base::length
[16:18:44.992]             list <- base::list
[16:18:44.992]             seq.int <- base::seq.int
[16:18:44.992]             signalCondition <- base::signalCondition
[16:18:44.992]             sys.calls <- base::sys.calls
[16:18:44.992]             `[[` <- base::`[[`
[16:18:44.992]             `+` <- base::`+`
[16:18:44.992]             `<<-` <- base::`<<-`
[16:18:44.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:44.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:44.992]                   3L)]
[16:18:44.992]             }
[16:18:44.992]             function(cond) {
[16:18:44.992]                 is_error <- inherits(cond, "error")
[16:18:44.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:44.992]                   NULL)
[16:18:44.992]                 if (is_error) {
[16:18:44.992]                   sessionInformation <- function() {
[16:18:44.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:44.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:44.992]                       search = base::search(), system = base::Sys.info())
[16:18:44.992]                   }
[16:18:44.992]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:44.992]                     cond$call), session = sessionInformation(), 
[16:18:44.992]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:44.992]                   signalCondition(cond)
[16:18:44.992]                 }
[16:18:44.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:44.992]                 "immediateCondition"))) {
[16:18:44.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:44.992]                   ...future.conditions[[length(...future.conditions) + 
[16:18:44.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:44.992]                   if (TRUE && !signal) {
[16:18:44.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.992]                     {
[16:18:44.992]                       inherits <- base::inherits
[16:18:44.992]                       invokeRestart <- base::invokeRestart
[16:18:44.992]                       is.null <- base::is.null
[16:18:44.992]                       muffled <- FALSE
[16:18:44.992]                       if (inherits(cond, "message")) {
[16:18:44.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.992]                         if (muffled) 
[16:18:44.992]                           invokeRestart("muffleMessage")
[16:18:44.992]                       }
[16:18:44.992]                       else if (inherits(cond, "warning")) {
[16:18:44.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.992]                         if (muffled) 
[16:18:44.992]                           invokeRestart("muffleWarning")
[16:18:44.992]                       }
[16:18:44.992]                       else if (inherits(cond, "condition")) {
[16:18:44.992]                         if (!is.null(pattern)) {
[16:18:44.992]                           computeRestarts <- base::computeRestarts
[16:18:44.992]                           grepl <- base::grepl
[16:18:44.992]                           restarts <- computeRestarts(cond)
[16:18:44.992]                           for (restart in restarts) {
[16:18:44.992]                             name <- restart$name
[16:18:44.992]                             if (is.null(name)) 
[16:18:44.992]                               next
[16:18:44.992]                             if (!grepl(pattern, name)) 
[16:18:44.992]                               next
[16:18:44.992]                             invokeRestart(restart)
[16:18:44.992]                             muffled <- TRUE
[16:18:44.992]                             break
[16:18:44.992]                           }
[16:18:44.992]                         }
[16:18:44.992]                       }
[16:18:44.992]                       invisible(muffled)
[16:18:44.992]                     }
[16:18:44.992]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.992]                   }
[16:18:44.992]                 }
[16:18:44.992]                 else {
[16:18:44.992]                   if (TRUE) {
[16:18:44.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:44.992]                     {
[16:18:44.992]                       inherits <- base::inherits
[16:18:44.992]                       invokeRestart <- base::invokeRestart
[16:18:44.992]                       is.null <- base::is.null
[16:18:44.992]                       muffled <- FALSE
[16:18:44.992]                       if (inherits(cond, "message")) {
[16:18:44.992]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:44.992]                         if (muffled) 
[16:18:44.992]                           invokeRestart("muffleMessage")
[16:18:44.992]                       }
[16:18:44.992]                       else if (inherits(cond, "warning")) {
[16:18:44.992]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:44.992]                         if (muffled) 
[16:18:44.992]                           invokeRestart("muffleWarning")
[16:18:44.992]                       }
[16:18:44.992]                       else if (inherits(cond, "condition")) {
[16:18:44.992]                         if (!is.null(pattern)) {
[16:18:44.992]                           computeRestarts <- base::computeRestarts
[16:18:44.992]                           grepl <- base::grepl
[16:18:44.992]                           restarts <- computeRestarts(cond)
[16:18:44.992]                           for (restart in restarts) {
[16:18:44.992]                             name <- restart$name
[16:18:44.992]                             if (is.null(name)) 
[16:18:44.992]                               next
[16:18:44.992]                             if (!grepl(pattern, name)) 
[16:18:44.992]                               next
[16:18:44.992]                             invokeRestart(restart)
[16:18:44.992]                             muffled <- TRUE
[16:18:44.992]                             break
[16:18:44.992]                           }
[16:18:44.992]                         }
[16:18:44.992]                       }
[16:18:44.992]                       invisible(muffled)
[16:18:44.992]                     }
[16:18:44.992]                     muffleCondition(cond, pattern = "^muffle")
[16:18:44.992]                   }
[16:18:44.992]                 }
[16:18:44.992]             }
[16:18:44.992]         }))
[16:18:44.992]     }, error = function(ex) {
[16:18:44.992]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:44.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:44.992]                 ...future.rng), started = ...future.startTime, 
[16:18:44.992]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:44.992]             version = "1.8"), class = "FutureResult")
[16:18:44.992]     }, finally = {
[16:18:44.992]         if (!identical(...future.workdir, getwd())) 
[16:18:44.992]             setwd(...future.workdir)
[16:18:44.992]         {
[16:18:44.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:44.992]                 ...future.oldOptions$nwarnings <- NULL
[16:18:44.992]             }
[16:18:44.992]             base::options(...future.oldOptions)
[16:18:44.992]             if (.Platform$OS.type == "windows") {
[16:18:44.992]                 old_names <- names(...future.oldEnvVars)
[16:18:44.992]                 envs <- base::Sys.getenv()
[16:18:44.992]                 names <- names(envs)
[16:18:44.992]                 common <- intersect(names, old_names)
[16:18:44.992]                 added <- setdiff(names, old_names)
[16:18:44.992]                 removed <- setdiff(old_names, names)
[16:18:44.992]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:44.992]                   envs[common]]
[16:18:44.992]                 NAMES <- toupper(changed)
[16:18:44.992]                 args <- list()
[16:18:44.992]                 for (kk in seq_along(NAMES)) {
[16:18:44.992]                   name <- changed[[kk]]
[16:18:44.992]                   NAME <- NAMES[[kk]]
[16:18:44.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.992]                     next
[16:18:44.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.992]                 }
[16:18:44.992]                 NAMES <- toupper(added)
[16:18:44.992]                 for (kk in seq_along(NAMES)) {
[16:18:44.992]                   name <- added[[kk]]
[16:18:44.992]                   NAME <- NAMES[[kk]]
[16:18:44.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.992]                     next
[16:18:44.992]                   args[[name]] <- ""
[16:18:44.992]                 }
[16:18:44.992]                 NAMES <- toupper(removed)
[16:18:44.992]                 for (kk in seq_along(NAMES)) {
[16:18:44.992]                   name <- removed[[kk]]
[16:18:44.992]                   NAME <- NAMES[[kk]]
[16:18:44.992]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:44.992]                     next
[16:18:44.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:44.992]                 }
[16:18:44.992]                 if (length(args) > 0) 
[16:18:44.992]                   base::do.call(base::Sys.setenv, args = args)
[16:18:44.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:44.992]             }
[16:18:44.992]             else {
[16:18:44.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:44.992]             }
[16:18:44.992]             {
[16:18:44.992]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:44.992]                   0L) {
[16:18:44.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:44.992]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:44.992]                   base::options(opts)
[16:18:44.992]                 }
[16:18:44.992]                 {
[16:18:44.992]                   {
[16:18:44.992]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:44.992]                     NULL
[16:18:44.992]                   }
[16:18:44.992]                   options(future.plan = NULL)
[16:18:44.992]                   if (is.na(NA_character_)) 
[16:18:44.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:44.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:44.992]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:44.992]                     .init = FALSE)
[16:18:44.992]                 }
[16:18:44.992]             }
[16:18:44.992]         }
[16:18:44.992]     })
[16:18:44.992]     if (TRUE) {
[16:18:44.992]         base::sink(type = "output", split = FALSE)
[16:18:44.992]         if (TRUE) {
[16:18:44.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:44.992]         }
[16:18:44.992]         else {
[16:18:44.992]             ...future.result["stdout"] <- base::list(NULL)
[16:18:44.992]         }
[16:18:44.992]         base::close(...future.stdout)
[16:18:44.992]         ...future.stdout <- NULL
[16:18:44.992]     }
[16:18:44.992]     ...future.result$conditions <- ...future.conditions
[16:18:44.992]     ...future.result$finished <- base::Sys.time()
[16:18:44.992]     ...future.result
[16:18:44.992] }
[16:18:44.995] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[16:18:44.995] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[16:18:44.995] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[16:18:44.995] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:44.995] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.996] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:18:44.996] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:18:44.996] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:44.996] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.997] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:44.997] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:44.997] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[16:18:44.997] MultisessionFuture started
[16:18:44.998] - Launch lazy future ... done
[16:18:44.998] run() for ‘MultisessionFuture’ ... done
[16:18:44.998] Created future:
[16:18:44.998] MultisessionFuture:
[16:18:44.998] Label: ‘future_mapply-1’
[16:18:44.998] Expression:
[16:18:44.998] {
[16:18:44.998]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:44.998]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:44.998]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:44.998]         on.exit(options(oopts), add = TRUE)
[16:18:44.998]     }
[16:18:44.998]     {
[16:18:44.998]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:44.998]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:44.998]         do.call(mapply, args = args)
[16:18:44.998]     }
[16:18:44.998] }
[16:18:44.998] Lazy evaluation: FALSE
[16:18:44.998] Asynchronous evaluation: TRUE
[16:18:44.998] Local evaluation: TRUE
[16:18:44.998] Environment: R_GlobalEnv
[16:18:44.998] Capture standard output: TRUE
[16:18:44.998] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:44.998] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:44.998] Packages: <none>
[16:18:44.998] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:44.998] Resolved: FALSE
[16:18:44.998] Value: <not collected>
[16:18:44.998] Conditions captured: <none>
[16:18:44.998] Early signaling: FALSE
[16:18:44.998] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:44.998] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.009] Chunk #1 of 2 ... DONE
[16:18:45.009] Chunk #2 of 2 ...
[16:18:45.009]  - Finding globals in '...' for chunk #2 ...
[16:18:45.010] getGlobalsAndPackages() ...
[16:18:45.010] Searching for globals...
[16:18:45.010] 
[16:18:45.010] Searching for globals ... DONE
[16:18:45.010] - globals: [0] <none>
[16:18:45.010] getGlobalsAndPackages() ... DONE
[16:18:45.010]    + additional globals found: [n=0] 
[16:18:45.010]    + additional namespaces needed: [n=0] 
[16:18:45.010]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:45.011]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:45.011]  - seeds: <none>
[16:18:45.011]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.011] getGlobalsAndPackages() ...
[16:18:45.011] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.011] Resolving globals: FALSE
[16:18:45.012] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[16:18:45.012] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:45.012] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.012] 
[16:18:45.012] getGlobalsAndPackages() ... DONE
[16:18:45.013] run() for ‘Future’ ...
[16:18:45.013] - state: ‘created’
[16:18:45.013] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.027] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.027]   - Field: ‘node’
[16:18:45.027]   - Field: ‘label’
[16:18:45.027]   - Field: ‘local’
[16:18:45.027]   - Field: ‘owner’
[16:18:45.027]   - Field: ‘envir’
[16:18:45.027]   - Field: ‘workers’
[16:18:45.027]   - Field: ‘packages’
[16:18:45.027]   - Field: ‘gc’
[16:18:45.028]   - Field: ‘conditions’
[16:18:45.028]   - Field: ‘persistent’
[16:18:45.028]   - Field: ‘expr’
[16:18:45.028]   - Field: ‘uuid’
[16:18:45.028]   - Field: ‘seed’
[16:18:45.028]   - Field: ‘version’
[16:18:45.028]   - Field: ‘result’
[16:18:45.028]   - Field: ‘asynchronous’
[16:18:45.028]   - Field: ‘calls’
[16:18:45.028]   - Field: ‘globals’
[16:18:45.028]   - Field: ‘stdout’
[16:18:45.029]   - Field: ‘earlySignal’
[16:18:45.029]   - Field: ‘lazy’
[16:18:45.029]   - Field: ‘state’
[16:18:45.029] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.029] - Launch lazy future ...
[16:18:45.029] Packages needed by the future expression (n = 0): <none>
[16:18:45.029] Packages needed by future strategies (n = 0): <none>
[16:18:45.030] {
[16:18:45.030]     {
[16:18:45.030]         {
[16:18:45.030]             ...future.startTime <- base::Sys.time()
[16:18:45.030]             {
[16:18:45.030]                 {
[16:18:45.030]                   {
[16:18:45.030]                     {
[16:18:45.030]                       base::local({
[16:18:45.030]                         has_future <- base::requireNamespace("future", 
[16:18:45.030]                           quietly = TRUE)
[16:18:45.030]                         if (has_future) {
[16:18:45.030]                           ns <- base::getNamespace("future")
[16:18:45.030]                           version <- ns[[".package"]][["version"]]
[16:18:45.030]                           if (is.null(version)) 
[16:18:45.030]                             version <- utils::packageVersion("future")
[16:18:45.030]                         }
[16:18:45.030]                         else {
[16:18:45.030]                           version <- NULL
[16:18:45.030]                         }
[16:18:45.030]                         if (!has_future || version < "1.8.0") {
[16:18:45.030]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.030]                             "", base::R.version$version.string), 
[16:18:45.030]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.030]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.030]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.030]                               "release", "version")], collapse = " "), 
[16:18:45.030]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.030]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.030]                             info)
[16:18:45.030]                           info <- base::paste(info, collapse = "; ")
[16:18:45.030]                           if (!has_future) {
[16:18:45.030]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.030]                               info)
[16:18:45.030]                           }
[16:18:45.030]                           else {
[16:18:45.030]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.030]                               info, version)
[16:18:45.030]                           }
[16:18:45.030]                           base::stop(msg)
[16:18:45.030]                         }
[16:18:45.030]                       })
[16:18:45.030]                     }
[16:18:45.030]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.030]                     base::options(mc.cores = 1L)
[16:18:45.030]                   }
[16:18:45.030]                   ...future.strategy.old <- future::plan("list")
[16:18:45.030]                   options(future.plan = NULL)
[16:18:45.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.030]                 }
[16:18:45.030]                 ...future.workdir <- getwd()
[16:18:45.030]             }
[16:18:45.030]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.030]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.030]         }
[16:18:45.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.030]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:45.030]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.030]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.030]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.030]             base::names(...future.oldOptions))
[16:18:45.030]     }
[16:18:45.030]     if (FALSE) {
[16:18:45.030]     }
[16:18:45.030]     else {
[16:18:45.030]         if (TRUE) {
[16:18:45.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.030]                 open = "w")
[16:18:45.030]         }
[16:18:45.030]         else {
[16:18:45.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.030]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.030]         }
[16:18:45.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.030]             base::sink(type = "output", split = FALSE)
[16:18:45.030]             base::close(...future.stdout)
[16:18:45.030]         }, add = TRUE)
[16:18:45.030]     }
[16:18:45.030]     ...future.frame <- base::sys.nframe()
[16:18:45.030]     ...future.conditions <- base::list()
[16:18:45.030]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.030]     if (FALSE) {
[16:18:45.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.030]     }
[16:18:45.030]     ...future.result <- base::tryCatch({
[16:18:45.030]         base::withCallingHandlers({
[16:18:45.030]             ...future.value <- base::withVisible(base::local({
[16:18:45.030]                 ...future.makeSendCondition <- base::local({
[16:18:45.030]                   sendCondition <- NULL
[16:18:45.030]                   function(frame = 1L) {
[16:18:45.030]                     if (is.function(sendCondition)) 
[16:18:45.030]                       return(sendCondition)
[16:18:45.030]                     ns <- getNamespace("parallel")
[16:18:45.030]                     if (exists("sendData", mode = "function", 
[16:18:45.030]                       envir = ns)) {
[16:18:45.030]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.030]                         envir = ns)
[16:18:45.030]                       envir <- sys.frame(frame)
[16:18:45.030]                       master <- NULL
[16:18:45.030]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.030]                         !identical(envir, emptyenv())) {
[16:18:45.030]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.030]                           inherits = FALSE)) {
[16:18:45.030]                           master <- get("master", mode = "list", 
[16:18:45.030]                             envir = envir, inherits = FALSE)
[16:18:45.030]                           if (inherits(master, c("SOCKnode", 
[16:18:45.030]                             "SOCK0node"))) {
[16:18:45.030]                             sendCondition <<- function(cond) {
[16:18:45.030]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.030]                                 success = TRUE)
[16:18:45.030]                               parallel_sendData(master, data)
[16:18:45.030]                             }
[16:18:45.030]                             return(sendCondition)
[16:18:45.030]                           }
[16:18:45.030]                         }
[16:18:45.030]                         frame <- frame + 1L
[16:18:45.030]                         envir <- sys.frame(frame)
[16:18:45.030]                       }
[16:18:45.030]                     }
[16:18:45.030]                     sendCondition <<- function(cond) NULL
[16:18:45.030]                   }
[16:18:45.030]                 })
[16:18:45.030]                 withCallingHandlers({
[16:18:45.030]                   {
[16:18:45.030]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.030]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.030]                       ...future.globals.maxSize)) {
[16:18:45.030]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.030]                       on.exit(options(oopts), add = TRUE)
[16:18:45.030]                     }
[16:18:45.030]                     {
[16:18:45.030]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.030]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.030]                         USE.NAMES = FALSE)
[16:18:45.030]                       do.call(mapply, args = args)
[16:18:45.030]                     }
[16:18:45.030]                   }
[16:18:45.030]                 }, immediateCondition = function(cond) {
[16:18:45.030]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.030]                   sendCondition(cond)
[16:18:45.030]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.030]                   {
[16:18:45.030]                     inherits <- base::inherits
[16:18:45.030]                     invokeRestart <- base::invokeRestart
[16:18:45.030]                     is.null <- base::is.null
[16:18:45.030]                     muffled <- FALSE
[16:18:45.030]                     if (inherits(cond, "message")) {
[16:18:45.030]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.030]                       if (muffled) 
[16:18:45.030]                         invokeRestart("muffleMessage")
[16:18:45.030]                     }
[16:18:45.030]                     else if (inherits(cond, "warning")) {
[16:18:45.030]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.030]                       if (muffled) 
[16:18:45.030]                         invokeRestart("muffleWarning")
[16:18:45.030]                     }
[16:18:45.030]                     else if (inherits(cond, "condition")) {
[16:18:45.030]                       if (!is.null(pattern)) {
[16:18:45.030]                         computeRestarts <- base::computeRestarts
[16:18:45.030]                         grepl <- base::grepl
[16:18:45.030]                         restarts <- computeRestarts(cond)
[16:18:45.030]                         for (restart in restarts) {
[16:18:45.030]                           name <- restart$name
[16:18:45.030]                           if (is.null(name)) 
[16:18:45.030]                             next
[16:18:45.030]                           if (!grepl(pattern, name)) 
[16:18:45.030]                             next
[16:18:45.030]                           invokeRestart(restart)
[16:18:45.030]                           muffled <- TRUE
[16:18:45.030]                           break
[16:18:45.030]                         }
[16:18:45.030]                       }
[16:18:45.030]                     }
[16:18:45.030]                     invisible(muffled)
[16:18:45.030]                   }
[16:18:45.030]                   muffleCondition(cond)
[16:18:45.030]                 })
[16:18:45.030]             }))
[16:18:45.030]             future::FutureResult(value = ...future.value$value, 
[16:18:45.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.030]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.030]                     ...future.globalenv.names))
[16:18:45.030]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.030]         }, condition = base::local({
[16:18:45.030]             c <- base::c
[16:18:45.030]             inherits <- base::inherits
[16:18:45.030]             invokeRestart <- base::invokeRestart
[16:18:45.030]             length <- base::length
[16:18:45.030]             list <- base::list
[16:18:45.030]             seq.int <- base::seq.int
[16:18:45.030]             signalCondition <- base::signalCondition
[16:18:45.030]             sys.calls <- base::sys.calls
[16:18:45.030]             `[[` <- base::`[[`
[16:18:45.030]             `+` <- base::`+`
[16:18:45.030]             `<<-` <- base::`<<-`
[16:18:45.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.030]                   3L)]
[16:18:45.030]             }
[16:18:45.030]             function(cond) {
[16:18:45.030]                 is_error <- inherits(cond, "error")
[16:18:45.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.030]                   NULL)
[16:18:45.030]                 if (is_error) {
[16:18:45.030]                   sessionInformation <- function() {
[16:18:45.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.030]                       search = base::search(), system = base::Sys.info())
[16:18:45.030]                   }
[16:18:45.030]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.030]                     cond$call), session = sessionInformation(), 
[16:18:45.030]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.030]                   signalCondition(cond)
[16:18:45.030]                 }
[16:18:45.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.030]                 "immediateCondition"))) {
[16:18:45.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.030]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.030]                   if (TRUE && !signal) {
[16:18:45.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.030]                     {
[16:18:45.030]                       inherits <- base::inherits
[16:18:45.030]                       invokeRestart <- base::invokeRestart
[16:18:45.030]                       is.null <- base::is.null
[16:18:45.030]                       muffled <- FALSE
[16:18:45.030]                       if (inherits(cond, "message")) {
[16:18:45.030]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.030]                         if (muffled) 
[16:18:45.030]                           invokeRestart("muffleMessage")
[16:18:45.030]                       }
[16:18:45.030]                       else if (inherits(cond, "warning")) {
[16:18:45.030]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.030]                         if (muffled) 
[16:18:45.030]                           invokeRestart("muffleWarning")
[16:18:45.030]                       }
[16:18:45.030]                       else if (inherits(cond, "condition")) {
[16:18:45.030]                         if (!is.null(pattern)) {
[16:18:45.030]                           computeRestarts <- base::computeRestarts
[16:18:45.030]                           grepl <- base::grepl
[16:18:45.030]                           restarts <- computeRestarts(cond)
[16:18:45.030]                           for (restart in restarts) {
[16:18:45.030]                             name <- restart$name
[16:18:45.030]                             if (is.null(name)) 
[16:18:45.030]                               next
[16:18:45.030]                             if (!grepl(pattern, name)) 
[16:18:45.030]                               next
[16:18:45.030]                             invokeRestart(restart)
[16:18:45.030]                             muffled <- TRUE
[16:18:45.030]                             break
[16:18:45.030]                           }
[16:18:45.030]                         }
[16:18:45.030]                       }
[16:18:45.030]                       invisible(muffled)
[16:18:45.030]                     }
[16:18:45.030]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.030]                   }
[16:18:45.030]                 }
[16:18:45.030]                 else {
[16:18:45.030]                   if (TRUE) {
[16:18:45.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.030]                     {
[16:18:45.030]                       inherits <- base::inherits
[16:18:45.030]                       invokeRestart <- base::invokeRestart
[16:18:45.030]                       is.null <- base::is.null
[16:18:45.030]                       muffled <- FALSE
[16:18:45.030]                       if (inherits(cond, "message")) {
[16:18:45.030]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.030]                         if (muffled) 
[16:18:45.030]                           invokeRestart("muffleMessage")
[16:18:45.030]                       }
[16:18:45.030]                       else if (inherits(cond, "warning")) {
[16:18:45.030]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.030]                         if (muffled) 
[16:18:45.030]                           invokeRestart("muffleWarning")
[16:18:45.030]                       }
[16:18:45.030]                       else if (inherits(cond, "condition")) {
[16:18:45.030]                         if (!is.null(pattern)) {
[16:18:45.030]                           computeRestarts <- base::computeRestarts
[16:18:45.030]                           grepl <- base::grepl
[16:18:45.030]                           restarts <- computeRestarts(cond)
[16:18:45.030]                           for (restart in restarts) {
[16:18:45.030]                             name <- restart$name
[16:18:45.030]                             if (is.null(name)) 
[16:18:45.030]                               next
[16:18:45.030]                             if (!grepl(pattern, name)) 
[16:18:45.030]                               next
[16:18:45.030]                             invokeRestart(restart)
[16:18:45.030]                             muffled <- TRUE
[16:18:45.030]                             break
[16:18:45.030]                           }
[16:18:45.030]                         }
[16:18:45.030]                       }
[16:18:45.030]                       invisible(muffled)
[16:18:45.030]                     }
[16:18:45.030]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.030]                   }
[16:18:45.030]                 }
[16:18:45.030]             }
[16:18:45.030]         }))
[16:18:45.030]     }, error = function(ex) {
[16:18:45.030]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.030]                 ...future.rng), started = ...future.startTime, 
[16:18:45.030]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.030]             version = "1.8"), class = "FutureResult")
[16:18:45.030]     }, finally = {
[16:18:45.030]         if (!identical(...future.workdir, getwd())) 
[16:18:45.030]             setwd(...future.workdir)
[16:18:45.030]         {
[16:18:45.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.030]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.030]             }
[16:18:45.030]             base::options(...future.oldOptions)
[16:18:45.030]             if (.Platform$OS.type == "windows") {
[16:18:45.030]                 old_names <- names(...future.oldEnvVars)
[16:18:45.030]                 envs <- base::Sys.getenv()
[16:18:45.030]                 names <- names(envs)
[16:18:45.030]                 common <- intersect(names, old_names)
[16:18:45.030]                 added <- setdiff(names, old_names)
[16:18:45.030]                 removed <- setdiff(old_names, names)
[16:18:45.030]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.030]                   envs[common]]
[16:18:45.030]                 NAMES <- toupper(changed)
[16:18:45.030]                 args <- list()
[16:18:45.030]                 for (kk in seq_along(NAMES)) {
[16:18:45.030]                   name <- changed[[kk]]
[16:18:45.030]                   NAME <- NAMES[[kk]]
[16:18:45.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.030]                     next
[16:18:45.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.030]                 }
[16:18:45.030]                 NAMES <- toupper(added)
[16:18:45.030]                 for (kk in seq_along(NAMES)) {
[16:18:45.030]                   name <- added[[kk]]
[16:18:45.030]                   NAME <- NAMES[[kk]]
[16:18:45.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.030]                     next
[16:18:45.030]                   args[[name]] <- ""
[16:18:45.030]                 }
[16:18:45.030]                 NAMES <- toupper(removed)
[16:18:45.030]                 for (kk in seq_along(NAMES)) {
[16:18:45.030]                   name <- removed[[kk]]
[16:18:45.030]                   NAME <- NAMES[[kk]]
[16:18:45.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.030]                     next
[16:18:45.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.030]                 }
[16:18:45.030]                 if (length(args) > 0) 
[16:18:45.030]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.030]             }
[16:18:45.030]             else {
[16:18:45.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.030]             }
[16:18:45.030]             {
[16:18:45.030]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.030]                   0L) {
[16:18:45.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.030]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.030]                   base::options(opts)
[16:18:45.030]                 }
[16:18:45.030]                 {
[16:18:45.030]                   {
[16:18:45.030]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.030]                     NULL
[16:18:45.030]                   }
[16:18:45.030]                   options(future.plan = NULL)
[16:18:45.030]                   if (is.na(NA_character_)) 
[16:18:45.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.030]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.030]                     .init = FALSE)
[16:18:45.030]                 }
[16:18:45.030]             }
[16:18:45.030]         }
[16:18:45.030]     })
[16:18:45.030]     if (TRUE) {
[16:18:45.030]         base::sink(type = "output", split = FALSE)
[16:18:45.030]         if (TRUE) {
[16:18:45.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.030]         }
[16:18:45.030]         else {
[16:18:45.030]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.030]         }
[16:18:45.030]         base::close(...future.stdout)
[16:18:45.030]         ...future.stdout <- NULL
[16:18:45.030]     }
[16:18:45.030]     ...future.result$conditions <- ...future.conditions
[16:18:45.030]     ...future.result$finished <- base::Sys.time()
[16:18:45.030]     ...future.result
[16:18:45.030] }
[16:18:45.032] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[16:18:45.033] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[16:18:45.033] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[16:18:45.033] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:45.033] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.034] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[16:18:45.034] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[16:18:45.034] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:45.034] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.034] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:45.035] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.035] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[16:18:45.035] MultisessionFuture started
[16:18:45.035] - Launch lazy future ... done
[16:18:45.035] run() for ‘MultisessionFuture’ ... done
[16:18:45.036] Created future:
[16:18:45.036] MultisessionFuture:
[16:18:45.036] Label: ‘future_mapply-2’
[16:18:45.036] Expression:
[16:18:45.036] {
[16:18:45.036]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.036]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.036]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.036]         on.exit(options(oopts), add = TRUE)
[16:18:45.036]     }
[16:18:45.036]     {
[16:18:45.036]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.036]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.036]         do.call(mapply, args = args)
[16:18:45.036]     }
[16:18:45.036] }
[16:18:45.036] Lazy evaluation: FALSE
[16:18:45.036] Asynchronous evaluation: TRUE
[16:18:45.036] Local evaluation: TRUE
[16:18:45.036] Environment: R_GlobalEnv
[16:18:45.036] Capture standard output: TRUE
[16:18:45.036] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.036] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.036] Packages: <none>
[16:18:45.036] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.036] Resolved: FALSE
[16:18:45.036] Value: <not collected>
[16:18:45.036] Conditions captured: <none>
[16:18:45.036] Early signaling: FALSE
[16:18:45.036] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.036] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.047] Chunk #2 of 2 ... DONE
[16:18:45.047] Launching 2 futures (chunks) ... DONE
[16:18:45.047] Resolving 2 futures (chunks) ...
[16:18:45.048] resolve() on list ...
[16:18:45.048]  recursive: 0
[16:18:45.048]  length: 2
[16:18:45.048] 
[16:18:45.048] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.049] - Validating connection of MultisessionFuture
[16:18:45.049] - received message: FutureResult
[16:18:45.049] - Received FutureResult
[16:18:45.049] - Erased future from FutureRegistry
[16:18:45.049] result() for ClusterFuture ...
[16:18:45.049] - result already collected: FutureResult
[16:18:45.049] result() for ClusterFuture ... done
[16:18:45.049] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.049] Future #1
[16:18:45.049] result() for ClusterFuture ...
[16:18:45.050] - result already collected: FutureResult
[16:18:45.050] result() for ClusterFuture ... done
[16:18:45.050] result() for ClusterFuture ...
[16:18:45.050] - result already collected: FutureResult
[16:18:45.050] result() for ClusterFuture ... done
[16:18:45.050] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:45.050] - nx: 2
[16:18:45.050] - relay: TRUE
[16:18:45.050] - stdout: TRUE
[16:18:45.050] - signal: TRUE
[16:18:45.050] - resignal: FALSE
[16:18:45.051] - force: TRUE
[16:18:45.051] - relayed: [n=2] FALSE, FALSE
[16:18:45.051] - queued futures: [n=2] FALSE, FALSE
[16:18:45.051]  - until=1
[16:18:45.051]  - relaying element #1
[16:18:45.051] result() for ClusterFuture ...
[16:18:45.051] - result already collected: FutureResult
[16:18:45.051] result() for ClusterFuture ... done
[16:18:45.051] result() for ClusterFuture ...
[16:18:45.051] - result already collected: FutureResult
[16:18:45.051] result() for ClusterFuture ... done
[16:18:45.052] result() for ClusterFuture ...
[16:18:45.052] - result already collected: FutureResult
[16:18:45.052] result() for ClusterFuture ... done
[16:18:45.052] result() for ClusterFuture ...
[16:18:45.052] - result already collected: FutureResult
[16:18:45.052] result() for ClusterFuture ... done
[16:18:45.052] - relayed: [n=2] TRUE, FALSE
[16:18:45.052] - queued futures: [n=2] TRUE, FALSE
[16:18:45.052] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:45.052]  length: 1 (resolved future 1)
[16:18:45.078] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.078] - Validating connection of MultisessionFuture
[16:18:45.078] - received message: FutureResult
[16:18:45.078] - Received FutureResult
[16:18:45.079] - Erased future from FutureRegistry
[16:18:45.079] result() for ClusterFuture ...
[16:18:45.079] - result already collected: FutureResult
[16:18:45.079] result() for ClusterFuture ... done
[16:18:45.079] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.079] Future #2
[16:18:45.079] result() for ClusterFuture ...
[16:18:45.079] - result already collected: FutureResult
[16:18:45.080] result() for ClusterFuture ... done
[16:18:45.080] result() for ClusterFuture ...
[16:18:45.080] - result already collected: FutureResult
[16:18:45.080] result() for ClusterFuture ... done
[16:18:45.080] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:45.080] - nx: 2
[16:18:45.080] - relay: TRUE
[16:18:45.080] - stdout: TRUE
[16:18:45.080] - signal: TRUE
[16:18:45.080] - resignal: FALSE
[16:18:45.081] - force: TRUE
[16:18:45.081] - relayed: [n=2] TRUE, FALSE
[16:18:45.081] - queued futures: [n=2] TRUE, FALSE
[16:18:45.081]  - until=2
[16:18:45.081]  - relaying element #2
[16:18:45.081] result() for ClusterFuture ...
[16:18:45.081] - result already collected: FutureResult
[16:18:45.081] result() for ClusterFuture ... done
[16:18:45.081] result() for ClusterFuture ...
[16:18:45.081] - result already collected: FutureResult
[16:18:45.081] result() for ClusterFuture ... done
[16:18:45.082] result() for ClusterFuture ...
[16:18:45.082] - result already collected: FutureResult
[16:18:45.082] result() for ClusterFuture ... done
[16:18:45.082] result() for ClusterFuture ...
[16:18:45.082] - result already collected: FutureResult
[16:18:45.082] result() for ClusterFuture ... done
[16:18:45.082] - relayed: [n=2] TRUE, TRUE
[16:18:45.082] - queued futures: [n=2] TRUE, TRUE
[16:18:45.082] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:45.082]  length: 0 (resolved future 2)
[16:18:45.083] Relaying remaining futures
[16:18:45.083] signalConditionsASAP(NULL, pos=0) ...
[16:18:45.083] - nx: 2
[16:18:45.083] - relay: TRUE
[16:18:45.083] - stdout: TRUE
[16:18:45.083] - signal: TRUE
[16:18:45.083] - resignal: FALSE
[16:18:45.083] - force: TRUE
[16:18:45.083] - relayed: [n=2] TRUE, TRUE
[16:18:45.083] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:45.083] - relayed: [n=2] TRUE, TRUE
[16:18:45.084] - queued futures: [n=2] TRUE, TRUE
[16:18:45.084] signalConditionsASAP(NULL, pos=0) ... done
[16:18:45.084] resolve() on list ... DONE
[16:18:45.084] result() for ClusterFuture ...
[16:18:45.084] - result already collected: FutureResult
[16:18:45.084] result() for ClusterFuture ... done
[16:18:45.084] result() for ClusterFuture ...
[16:18:45.084] - result already collected: FutureResult
[16:18:45.084] result() for ClusterFuture ... done
[16:18:45.084] result() for ClusterFuture ...
[16:18:45.085] - result already collected: FutureResult
[16:18:45.085] result() for ClusterFuture ... done
[16:18:45.085] result() for ClusterFuture ...
[16:18:45.085] - result already collected: FutureResult
[16:18:45.085] result() for ClusterFuture ... done
[16:18:45.085]  - Number of value chunks collected: 2
[16:18:45.085] Resolving 2 futures (chunks) ... DONE
[16:18:45.085] Reducing values from 2 chunks ...
[16:18:45.085]  - Number of values collected after concatenation: 3
[16:18:45.085]  - Number of values expected: 3
[16:18:45.086] Reducing values from 2 chunks ... DONE
[16:18:45.086] future_mapply() ... DONE
- future_.mapply()
[16:18:45.086] future_mapply() ...
[16:18:45.090] Number of chunks: 2
[16:18:45.091] getGlobalsAndPackagesXApply() ...
[16:18:45.091]  - future.globals: TRUE
[16:18:45.091] getGlobalsAndPackages() ...
[16:18:45.091] Searching for globals...
[16:18:45.092] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[16:18:45.093] Searching for globals ... DONE
[16:18:45.093] Resolving globals: FALSE
[16:18:45.093] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[16:18:45.094] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[16:18:45.094] - globals: [1] ‘FUN’
[16:18:45.094] 
[16:18:45.094] getGlobalsAndPackages() ... DONE
[16:18:45.094]  - globals found/used: [n=1] ‘FUN’
[16:18:45.094]  - needed namespaces: [n=0] 
[16:18:45.094] Finding globals ... DONE
[16:18:45.094] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:45.094] List of 2
[16:18:45.094]  $ ...future.FUN:function (x, y)  
[16:18:45.094]  $ MoreArgs     : list()
[16:18:45.094]  - attr(*, "where")=List of 2
[16:18:45.094]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:45.094]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:45.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:45.094]  - attr(*, "resolved")= logi FALSE
[16:18:45.094]  - attr(*, "total_size")= num NA
[16:18:45.097] Packages to be attached in all futures: [n=0] 
[16:18:45.097] getGlobalsAndPackagesXApply() ... DONE
[16:18:45.097] Number of futures (= number of chunks): 2
[16:18:45.098] Launching 2 futures (chunks) ...
[16:18:45.098] Chunk #1 of 2 ...
[16:18:45.098]  - Finding globals in '...' for chunk #1 ...
[16:18:45.098] getGlobalsAndPackages() ...
[16:18:45.098] Searching for globals...
[16:18:45.098] 
[16:18:45.098] Searching for globals ... DONE
[16:18:45.099] - globals: [0] <none>
[16:18:45.099] getGlobalsAndPackages() ... DONE
[16:18:45.099]    + additional globals found: [n=0] 
[16:18:45.099]    + additional namespaces needed: [n=0] 
[16:18:45.099]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:45.099]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:45.099]  - seeds: <none>
[16:18:45.099]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.099] getGlobalsAndPackages() ...
[16:18:45.099] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.100] Resolving globals: FALSE
[16:18:45.100] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[16:18:45.101] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:45.101] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.101] 
[16:18:45.101] getGlobalsAndPackages() ... DONE
[16:18:45.101] run() for ‘Future’ ...
[16:18:45.101] - state: ‘created’
[16:18:45.102] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.118] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.118] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.119]   - Field: ‘node’
[16:18:45.119]   - Field: ‘label’
[16:18:45.119]   - Field: ‘local’
[16:18:45.119]   - Field: ‘owner’
[16:18:45.119]   - Field: ‘envir’
[16:18:45.119]   - Field: ‘workers’
[16:18:45.119]   - Field: ‘packages’
[16:18:45.119]   - Field: ‘gc’
[16:18:45.119]   - Field: ‘conditions’
[16:18:45.119]   - Field: ‘persistent’
[16:18:45.120]   - Field: ‘expr’
[16:18:45.120]   - Field: ‘uuid’
[16:18:45.120]   - Field: ‘seed’
[16:18:45.120]   - Field: ‘version’
[16:18:45.120]   - Field: ‘result’
[16:18:45.120]   - Field: ‘asynchronous’
[16:18:45.120]   - Field: ‘calls’
[16:18:45.120]   - Field: ‘globals’
[16:18:45.120]   - Field: ‘stdout’
[16:18:45.120]   - Field: ‘earlySignal’
[16:18:45.121]   - Field: ‘lazy’
[16:18:45.121]   - Field: ‘state’
[16:18:45.121] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.121] - Launch lazy future ...
[16:18:45.121] Packages needed by the future expression (n = 0): <none>
[16:18:45.121] Packages needed by future strategies (n = 0): <none>
[16:18:45.122] {
[16:18:45.122]     {
[16:18:45.122]         {
[16:18:45.122]             ...future.startTime <- base::Sys.time()
[16:18:45.122]             {
[16:18:45.122]                 {
[16:18:45.122]                   {
[16:18:45.122]                     {
[16:18:45.122]                       base::local({
[16:18:45.122]                         has_future <- base::requireNamespace("future", 
[16:18:45.122]                           quietly = TRUE)
[16:18:45.122]                         if (has_future) {
[16:18:45.122]                           ns <- base::getNamespace("future")
[16:18:45.122]                           version <- ns[[".package"]][["version"]]
[16:18:45.122]                           if (is.null(version)) 
[16:18:45.122]                             version <- utils::packageVersion("future")
[16:18:45.122]                         }
[16:18:45.122]                         else {
[16:18:45.122]                           version <- NULL
[16:18:45.122]                         }
[16:18:45.122]                         if (!has_future || version < "1.8.0") {
[16:18:45.122]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.122]                             "", base::R.version$version.string), 
[16:18:45.122]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.122]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.122]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.122]                               "release", "version")], collapse = " "), 
[16:18:45.122]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.122]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.122]                             info)
[16:18:45.122]                           info <- base::paste(info, collapse = "; ")
[16:18:45.122]                           if (!has_future) {
[16:18:45.122]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.122]                               info)
[16:18:45.122]                           }
[16:18:45.122]                           else {
[16:18:45.122]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.122]                               info, version)
[16:18:45.122]                           }
[16:18:45.122]                           base::stop(msg)
[16:18:45.122]                         }
[16:18:45.122]                       })
[16:18:45.122]                     }
[16:18:45.122]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.122]                     base::options(mc.cores = 1L)
[16:18:45.122]                   }
[16:18:45.122]                   ...future.strategy.old <- future::plan("list")
[16:18:45.122]                   options(future.plan = NULL)
[16:18:45.122]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.122]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.122]                 }
[16:18:45.122]                 ...future.workdir <- getwd()
[16:18:45.122]             }
[16:18:45.122]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.122]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.122]         }
[16:18:45.122]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.122]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:45.122]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.122]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.122]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.122]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.122]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.122]             base::names(...future.oldOptions))
[16:18:45.122]     }
[16:18:45.122]     if (FALSE) {
[16:18:45.122]     }
[16:18:45.122]     else {
[16:18:45.122]         if (TRUE) {
[16:18:45.122]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.122]                 open = "w")
[16:18:45.122]         }
[16:18:45.122]         else {
[16:18:45.122]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.122]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.122]         }
[16:18:45.122]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.122]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.122]             base::sink(type = "output", split = FALSE)
[16:18:45.122]             base::close(...future.stdout)
[16:18:45.122]         }, add = TRUE)
[16:18:45.122]     }
[16:18:45.122]     ...future.frame <- base::sys.nframe()
[16:18:45.122]     ...future.conditions <- base::list()
[16:18:45.122]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.122]     if (FALSE) {
[16:18:45.122]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.122]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.122]     }
[16:18:45.122]     ...future.result <- base::tryCatch({
[16:18:45.122]         base::withCallingHandlers({
[16:18:45.122]             ...future.value <- base::withVisible(base::local({
[16:18:45.122]                 ...future.makeSendCondition <- base::local({
[16:18:45.122]                   sendCondition <- NULL
[16:18:45.122]                   function(frame = 1L) {
[16:18:45.122]                     if (is.function(sendCondition)) 
[16:18:45.122]                       return(sendCondition)
[16:18:45.122]                     ns <- getNamespace("parallel")
[16:18:45.122]                     if (exists("sendData", mode = "function", 
[16:18:45.122]                       envir = ns)) {
[16:18:45.122]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.122]                         envir = ns)
[16:18:45.122]                       envir <- sys.frame(frame)
[16:18:45.122]                       master <- NULL
[16:18:45.122]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.122]                         !identical(envir, emptyenv())) {
[16:18:45.122]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.122]                           inherits = FALSE)) {
[16:18:45.122]                           master <- get("master", mode = "list", 
[16:18:45.122]                             envir = envir, inherits = FALSE)
[16:18:45.122]                           if (inherits(master, c("SOCKnode", 
[16:18:45.122]                             "SOCK0node"))) {
[16:18:45.122]                             sendCondition <<- function(cond) {
[16:18:45.122]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.122]                                 success = TRUE)
[16:18:45.122]                               parallel_sendData(master, data)
[16:18:45.122]                             }
[16:18:45.122]                             return(sendCondition)
[16:18:45.122]                           }
[16:18:45.122]                         }
[16:18:45.122]                         frame <- frame + 1L
[16:18:45.122]                         envir <- sys.frame(frame)
[16:18:45.122]                       }
[16:18:45.122]                     }
[16:18:45.122]                     sendCondition <<- function(cond) NULL
[16:18:45.122]                   }
[16:18:45.122]                 })
[16:18:45.122]                 withCallingHandlers({
[16:18:45.122]                   {
[16:18:45.122]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.122]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.122]                       ...future.globals.maxSize)) {
[16:18:45.122]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.122]                       on.exit(options(oopts), add = TRUE)
[16:18:45.122]                     }
[16:18:45.122]                     {
[16:18:45.122]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.122]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.122]                         USE.NAMES = FALSE)
[16:18:45.122]                       do.call(mapply, args = args)
[16:18:45.122]                     }
[16:18:45.122]                   }
[16:18:45.122]                 }, immediateCondition = function(cond) {
[16:18:45.122]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.122]                   sendCondition(cond)
[16:18:45.122]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.122]                   {
[16:18:45.122]                     inherits <- base::inherits
[16:18:45.122]                     invokeRestart <- base::invokeRestart
[16:18:45.122]                     is.null <- base::is.null
[16:18:45.122]                     muffled <- FALSE
[16:18:45.122]                     if (inherits(cond, "message")) {
[16:18:45.122]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.122]                       if (muffled) 
[16:18:45.122]                         invokeRestart("muffleMessage")
[16:18:45.122]                     }
[16:18:45.122]                     else if (inherits(cond, "warning")) {
[16:18:45.122]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.122]                       if (muffled) 
[16:18:45.122]                         invokeRestart("muffleWarning")
[16:18:45.122]                     }
[16:18:45.122]                     else if (inherits(cond, "condition")) {
[16:18:45.122]                       if (!is.null(pattern)) {
[16:18:45.122]                         computeRestarts <- base::computeRestarts
[16:18:45.122]                         grepl <- base::grepl
[16:18:45.122]                         restarts <- computeRestarts(cond)
[16:18:45.122]                         for (restart in restarts) {
[16:18:45.122]                           name <- restart$name
[16:18:45.122]                           if (is.null(name)) 
[16:18:45.122]                             next
[16:18:45.122]                           if (!grepl(pattern, name)) 
[16:18:45.122]                             next
[16:18:45.122]                           invokeRestart(restart)
[16:18:45.122]                           muffled <- TRUE
[16:18:45.122]                           break
[16:18:45.122]                         }
[16:18:45.122]                       }
[16:18:45.122]                     }
[16:18:45.122]                     invisible(muffled)
[16:18:45.122]                   }
[16:18:45.122]                   muffleCondition(cond)
[16:18:45.122]                 })
[16:18:45.122]             }))
[16:18:45.122]             future::FutureResult(value = ...future.value$value, 
[16:18:45.122]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.122]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.122]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.122]                     ...future.globalenv.names))
[16:18:45.122]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.122]         }, condition = base::local({
[16:18:45.122]             c <- base::c
[16:18:45.122]             inherits <- base::inherits
[16:18:45.122]             invokeRestart <- base::invokeRestart
[16:18:45.122]             length <- base::length
[16:18:45.122]             list <- base::list
[16:18:45.122]             seq.int <- base::seq.int
[16:18:45.122]             signalCondition <- base::signalCondition
[16:18:45.122]             sys.calls <- base::sys.calls
[16:18:45.122]             `[[` <- base::`[[`
[16:18:45.122]             `+` <- base::`+`
[16:18:45.122]             `<<-` <- base::`<<-`
[16:18:45.122]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.122]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.122]                   3L)]
[16:18:45.122]             }
[16:18:45.122]             function(cond) {
[16:18:45.122]                 is_error <- inherits(cond, "error")
[16:18:45.122]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.122]                   NULL)
[16:18:45.122]                 if (is_error) {
[16:18:45.122]                   sessionInformation <- function() {
[16:18:45.122]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.122]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.122]                       search = base::search(), system = base::Sys.info())
[16:18:45.122]                   }
[16:18:45.122]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.122]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.122]                     cond$call), session = sessionInformation(), 
[16:18:45.122]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.122]                   signalCondition(cond)
[16:18:45.122]                 }
[16:18:45.122]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.122]                 "immediateCondition"))) {
[16:18:45.122]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.122]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.122]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.122]                   if (TRUE && !signal) {
[16:18:45.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.122]                     {
[16:18:45.122]                       inherits <- base::inherits
[16:18:45.122]                       invokeRestart <- base::invokeRestart
[16:18:45.122]                       is.null <- base::is.null
[16:18:45.122]                       muffled <- FALSE
[16:18:45.122]                       if (inherits(cond, "message")) {
[16:18:45.122]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.122]                         if (muffled) 
[16:18:45.122]                           invokeRestart("muffleMessage")
[16:18:45.122]                       }
[16:18:45.122]                       else if (inherits(cond, "warning")) {
[16:18:45.122]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.122]                         if (muffled) 
[16:18:45.122]                           invokeRestart("muffleWarning")
[16:18:45.122]                       }
[16:18:45.122]                       else if (inherits(cond, "condition")) {
[16:18:45.122]                         if (!is.null(pattern)) {
[16:18:45.122]                           computeRestarts <- base::computeRestarts
[16:18:45.122]                           grepl <- base::grepl
[16:18:45.122]                           restarts <- computeRestarts(cond)
[16:18:45.122]                           for (restart in restarts) {
[16:18:45.122]                             name <- restart$name
[16:18:45.122]                             if (is.null(name)) 
[16:18:45.122]                               next
[16:18:45.122]                             if (!grepl(pattern, name)) 
[16:18:45.122]                               next
[16:18:45.122]                             invokeRestart(restart)
[16:18:45.122]                             muffled <- TRUE
[16:18:45.122]                             break
[16:18:45.122]                           }
[16:18:45.122]                         }
[16:18:45.122]                       }
[16:18:45.122]                       invisible(muffled)
[16:18:45.122]                     }
[16:18:45.122]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.122]                   }
[16:18:45.122]                 }
[16:18:45.122]                 else {
[16:18:45.122]                   if (TRUE) {
[16:18:45.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.122]                     {
[16:18:45.122]                       inherits <- base::inherits
[16:18:45.122]                       invokeRestart <- base::invokeRestart
[16:18:45.122]                       is.null <- base::is.null
[16:18:45.122]                       muffled <- FALSE
[16:18:45.122]                       if (inherits(cond, "message")) {
[16:18:45.122]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.122]                         if (muffled) 
[16:18:45.122]                           invokeRestart("muffleMessage")
[16:18:45.122]                       }
[16:18:45.122]                       else if (inherits(cond, "warning")) {
[16:18:45.122]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.122]                         if (muffled) 
[16:18:45.122]                           invokeRestart("muffleWarning")
[16:18:45.122]                       }
[16:18:45.122]                       else if (inherits(cond, "condition")) {
[16:18:45.122]                         if (!is.null(pattern)) {
[16:18:45.122]                           computeRestarts <- base::computeRestarts
[16:18:45.122]                           grepl <- base::grepl
[16:18:45.122]                           restarts <- computeRestarts(cond)
[16:18:45.122]                           for (restart in restarts) {
[16:18:45.122]                             name <- restart$name
[16:18:45.122]                             if (is.null(name)) 
[16:18:45.122]                               next
[16:18:45.122]                             if (!grepl(pattern, name)) 
[16:18:45.122]                               next
[16:18:45.122]                             invokeRestart(restart)
[16:18:45.122]                             muffled <- TRUE
[16:18:45.122]                             break
[16:18:45.122]                           }
[16:18:45.122]                         }
[16:18:45.122]                       }
[16:18:45.122]                       invisible(muffled)
[16:18:45.122]                     }
[16:18:45.122]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.122]                   }
[16:18:45.122]                 }
[16:18:45.122]             }
[16:18:45.122]         }))
[16:18:45.122]     }, error = function(ex) {
[16:18:45.122]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.122]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.122]                 ...future.rng), started = ...future.startTime, 
[16:18:45.122]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.122]             version = "1.8"), class = "FutureResult")
[16:18:45.122]     }, finally = {
[16:18:45.122]         if (!identical(...future.workdir, getwd())) 
[16:18:45.122]             setwd(...future.workdir)
[16:18:45.122]         {
[16:18:45.122]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.122]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.122]             }
[16:18:45.122]             base::options(...future.oldOptions)
[16:18:45.122]             if (.Platform$OS.type == "windows") {
[16:18:45.122]                 old_names <- names(...future.oldEnvVars)
[16:18:45.122]                 envs <- base::Sys.getenv()
[16:18:45.122]                 names <- names(envs)
[16:18:45.122]                 common <- intersect(names, old_names)
[16:18:45.122]                 added <- setdiff(names, old_names)
[16:18:45.122]                 removed <- setdiff(old_names, names)
[16:18:45.122]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.122]                   envs[common]]
[16:18:45.122]                 NAMES <- toupper(changed)
[16:18:45.122]                 args <- list()
[16:18:45.122]                 for (kk in seq_along(NAMES)) {
[16:18:45.122]                   name <- changed[[kk]]
[16:18:45.122]                   NAME <- NAMES[[kk]]
[16:18:45.122]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.122]                     next
[16:18:45.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.122]                 }
[16:18:45.122]                 NAMES <- toupper(added)
[16:18:45.122]                 for (kk in seq_along(NAMES)) {
[16:18:45.122]                   name <- added[[kk]]
[16:18:45.122]                   NAME <- NAMES[[kk]]
[16:18:45.122]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.122]                     next
[16:18:45.122]                   args[[name]] <- ""
[16:18:45.122]                 }
[16:18:45.122]                 NAMES <- toupper(removed)
[16:18:45.122]                 for (kk in seq_along(NAMES)) {
[16:18:45.122]                   name <- removed[[kk]]
[16:18:45.122]                   NAME <- NAMES[[kk]]
[16:18:45.122]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.122]                     next
[16:18:45.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.122]                 }
[16:18:45.122]                 if (length(args) > 0) 
[16:18:45.122]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.122]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.122]             }
[16:18:45.122]             else {
[16:18:45.122]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.122]             }
[16:18:45.122]             {
[16:18:45.122]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.122]                   0L) {
[16:18:45.122]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.122]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.122]                   base::options(opts)
[16:18:45.122]                 }
[16:18:45.122]                 {
[16:18:45.122]                   {
[16:18:45.122]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.122]                     NULL
[16:18:45.122]                   }
[16:18:45.122]                   options(future.plan = NULL)
[16:18:45.122]                   if (is.na(NA_character_)) 
[16:18:45.122]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.122]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.122]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.122]                     .init = FALSE)
[16:18:45.122]                 }
[16:18:45.122]             }
[16:18:45.122]         }
[16:18:45.122]     })
[16:18:45.122]     if (TRUE) {
[16:18:45.122]         base::sink(type = "output", split = FALSE)
[16:18:45.122]         if (TRUE) {
[16:18:45.122]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.122]         }
[16:18:45.122]         else {
[16:18:45.122]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.122]         }
[16:18:45.122]         base::close(...future.stdout)
[16:18:45.122]         ...future.stdout <- NULL
[16:18:45.122]     }
[16:18:45.122]     ...future.result$conditions <- ...future.conditions
[16:18:45.122]     ...future.result$finished <- base::Sys.time()
[16:18:45.122]     ...future.result
[16:18:45.122] }
[16:18:45.125] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[16:18:45.125] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[16:18:45.125] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[16:18:45.125] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:45.126] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.126] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:18:45.126] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:18:45.126] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:45.127] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.127] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:45.127] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.127] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[16:18:45.128] MultisessionFuture started
[16:18:45.128] - Launch lazy future ... done
[16:18:45.128] run() for ‘MultisessionFuture’ ... done
[16:18:45.128] Created future:
[16:18:45.128] MultisessionFuture:
[16:18:45.128] Label: ‘future_.mapply-1’
[16:18:45.128] Expression:
[16:18:45.128] {
[16:18:45.128]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.128]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.128]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.128]         on.exit(options(oopts), add = TRUE)
[16:18:45.128]     }
[16:18:45.128]     {
[16:18:45.128]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.128]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.128]         do.call(mapply, args = args)
[16:18:45.128]     }
[16:18:45.128] }
[16:18:45.128] Lazy evaluation: FALSE
[16:18:45.128] Asynchronous evaluation: TRUE
[16:18:45.128] Local evaluation: TRUE
[16:18:45.128] Environment: R_GlobalEnv
[16:18:45.128] Capture standard output: TRUE
[16:18:45.128] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.128] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.128] Packages: <none>
[16:18:45.128] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.128] Resolved: FALSE
[16:18:45.128] Value: <not collected>
[16:18:45.128] Conditions captured: <none>
[16:18:45.128] Early signaling: FALSE
[16:18:45.128] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.128] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.140] Chunk #1 of 2 ... DONE
[16:18:45.140] Chunk #2 of 2 ...
[16:18:45.140]  - Finding globals in '...' for chunk #2 ...
[16:18:45.140] getGlobalsAndPackages() ...
[16:18:45.140] Searching for globals...
[16:18:45.141] 
[16:18:45.141] Searching for globals ... DONE
[16:18:45.141] - globals: [0] <none>
[16:18:45.141] getGlobalsAndPackages() ... DONE
[16:18:45.141]    + additional globals found: [n=0] 
[16:18:45.141]    + additional namespaces needed: [n=0] 
[16:18:45.141]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:45.141]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:45.141]  - seeds: <none>
[16:18:45.141]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.142] getGlobalsAndPackages() ...
[16:18:45.142] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.142] Resolving globals: FALSE
[16:18:45.142] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[16:18:45.143] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:45.143] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.143] 
[16:18:45.143] getGlobalsAndPackages() ... DONE
[16:18:45.143] run() for ‘Future’ ...
[16:18:45.144] - state: ‘created’
[16:18:45.144] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.157] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.158] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.158]   - Field: ‘node’
[16:18:45.158]   - Field: ‘label’
[16:18:45.158]   - Field: ‘local’
[16:18:45.158]   - Field: ‘owner’
[16:18:45.158]   - Field: ‘envir’
[16:18:45.158]   - Field: ‘workers’
[16:18:45.158]   - Field: ‘packages’
[16:18:45.158]   - Field: ‘gc’
[16:18:45.159]   - Field: ‘conditions’
[16:18:45.159]   - Field: ‘persistent’
[16:18:45.159]   - Field: ‘expr’
[16:18:45.159]   - Field: ‘uuid’
[16:18:45.159]   - Field: ‘seed’
[16:18:45.159]   - Field: ‘version’
[16:18:45.159]   - Field: ‘result’
[16:18:45.159]   - Field: ‘asynchronous’
[16:18:45.159]   - Field: ‘calls’
[16:18:45.159]   - Field: ‘globals’
[16:18:45.159]   - Field: ‘stdout’
[16:18:45.160]   - Field: ‘earlySignal’
[16:18:45.160]   - Field: ‘lazy’
[16:18:45.160]   - Field: ‘state’
[16:18:45.160] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.160] - Launch lazy future ...
[16:18:45.160] Packages needed by the future expression (n = 0): <none>
[16:18:45.160] Packages needed by future strategies (n = 0): <none>
[16:18:45.161] {
[16:18:45.161]     {
[16:18:45.161]         {
[16:18:45.161]             ...future.startTime <- base::Sys.time()
[16:18:45.161]             {
[16:18:45.161]                 {
[16:18:45.161]                   {
[16:18:45.161]                     {
[16:18:45.161]                       base::local({
[16:18:45.161]                         has_future <- base::requireNamespace("future", 
[16:18:45.161]                           quietly = TRUE)
[16:18:45.161]                         if (has_future) {
[16:18:45.161]                           ns <- base::getNamespace("future")
[16:18:45.161]                           version <- ns[[".package"]][["version"]]
[16:18:45.161]                           if (is.null(version)) 
[16:18:45.161]                             version <- utils::packageVersion("future")
[16:18:45.161]                         }
[16:18:45.161]                         else {
[16:18:45.161]                           version <- NULL
[16:18:45.161]                         }
[16:18:45.161]                         if (!has_future || version < "1.8.0") {
[16:18:45.161]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.161]                             "", base::R.version$version.string), 
[16:18:45.161]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.161]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.161]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.161]                               "release", "version")], collapse = " "), 
[16:18:45.161]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.161]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.161]                             info)
[16:18:45.161]                           info <- base::paste(info, collapse = "; ")
[16:18:45.161]                           if (!has_future) {
[16:18:45.161]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.161]                               info)
[16:18:45.161]                           }
[16:18:45.161]                           else {
[16:18:45.161]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.161]                               info, version)
[16:18:45.161]                           }
[16:18:45.161]                           base::stop(msg)
[16:18:45.161]                         }
[16:18:45.161]                       })
[16:18:45.161]                     }
[16:18:45.161]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.161]                     base::options(mc.cores = 1L)
[16:18:45.161]                   }
[16:18:45.161]                   ...future.strategy.old <- future::plan("list")
[16:18:45.161]                   options(future.plan = NULL)
[16:18:45.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.161]                 }
[16:18:45.161]                 ...future.workdir <- getwd()
[16:18:45.161]             }
[16:18:45.161]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.161]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.161]         }
[16:18:45.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.161]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:45.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.161]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.161]             base::names(...future.oldOptions))
[16:18:45.161]     }
[16:18:45.161]     if (FALSE) {
[16:18:45.161]     }
[16:18:45.161]     else {
[16:18:45.161]         if (TRUE) {
[16:18:45.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.161]                 open = "w")
[16:18:45.161]         }
[16:18:45.161]         else {
[16:18:45.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.161]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.161]         }
[16:18:45.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.161]             base::sink(type = "output", split = FALSE)
[16:18:45.161]             base::close(...future.stdout)
[16:18:45.161]         }, add = TRUE)
[16:18:45.161]     }
[16:18:45.161]     ...future.frame <- base::sys.nframe()
[16:18:45.161]     ...future.conditions <- base::list()
[16:18:45.161]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.161]     if (FALSE) {
[16:18:45.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.161]     }
[16:18:45.161]     ...future.result <- base::tryCatch({
[16:18:45.161]         base::withCallingHandlers({
[16:18:45.161]             ...future.value <- base::withVisible(base::local({
[16:18:45.161]                 ...future.makeSendCondition <- base::local({
[16:18:45.161]                   sendCondition <- NULL
[16:18:45.161]                   function(frame = 1L) {
[16:18:45.161]                     if (is.function(sendCondition)) 
[16:18:45.161]                       return(sendCondition)
[16:18:45.161]                     ns <- getNamespace("parallel")
[16:18:45.161]                     if (exists("sendData", mode = "function", 
[16:18:45.161]                       envir = ns)) {
[16:18:45.161]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.161]                         envir = ns)
[16:18:45.161]                       envir <- sys.frame(frame)
[16:18:45.161]                       master <- NULL
[16:18:45.161]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.161]                         !identical(envir, emptyenv())) {
[16:18:45.161]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.161]                           inherits = FALSE)) {
[16:18:45.161]                           master <- get("master", mode = "list", 
[16:18:45.161]                             envir = envir, inherits = FALSE)
[16:18:45.161]                           if (inherits(master, c("SOCKnode", 
[16:18:45.161]                             "SOCK0node"))) {
[16:18:45.161]                             sendCondition <<- function(cond) {
[16:18:45.161]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.161]                                 success = TRUE)
[16:18:45.161]                               parallel_sendData(master, data)
[16:18:45.161]                             }
[16:18:45.161]                             return(sendCondition)
[16:18:45.161]                           }
[16:18:45.161]                         }
[16:18:45.161]                         frame <- frame + 1L
[16:18:45.161]                         envir <- sys.frame(frame)
[16:18:45.161]                       }
[16:18:45.161]                     }
[16:18:45.161]                     sendCondition <<- function(cond) NULL
[16:18:45.161]                   }
[16:18:45.161]                 })
[16:18:45.161]                 withCallingHandlers({
[16:18:45.161]                   {
[16:18:45.161]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.161]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.161]                       ...future.globals.maxSize)) {
[16:18:45.161]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.161]                       on.exit(options(oopts), add = TRUE)
[16:18:45.161]                     }
[16:18:45.161]                     {
[16:18:45.161]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.161]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.161]                         USE.NAMES = FALSE)
[16:18:45.161]                       do.call(mapply, args = args)
[16:18:45.161]                     }
[16:18:45.161]                   }
[16:18:45.161]                 }, immediateCondition = function(cond) {
[16:18:45.161]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.161]                   sendCondition(cond)
[16:18:45.161]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.161]                   {
[16:18:45.161]                     inherits <- base::inherits
[16:18:45.161]                     invokeRestart <- base::invokeRestart
[16:18:45.161]                     is.null <- base::is.null
[16:18:45.161]                     muffled <- FALSE
[16:18:45.161]                     if (inherits(cond, "message")) {
[16:18:45.161]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.161]                       if (muffled) 
[16:18:45.161]                         invokeRestart("muffleMessage")
[16:18:45.161]                     }
[16:18:45.161]                     else if (inherits(cond, "warning")) {
[16:18:45.161]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.161]                       if (muffled) 
[16:18:45.161]                         invokeRestart("muffleWarning")
[16:18:45.161]                     }
[16:18:45.161]                     else if (inherits(cond, "condition")) {
[16:18:45.161]                       if (!is.null(pattern)) {
[16:18:45.161]                         computeRestarts <- base::computeRestarts
[16:18:45.161]                         grepl <- base::grepl
[16:18:45.161]                         restarts <- computeRestarts(cond)
[16:18:45.161]                         for (restart in restarts) {
[16:18:45.161]                           name <- restart$name
[16:18:45.161]                           if (is.null(name)) 
[16:18:45.161]                             next
[16:18:45.161]                           if (!grepl(pattern, name)) 
[16:18:45.161]                             next
[16:18:45.161]                           invokeRestart(restart)
[16:18:45.161]                           muffled <- TRUE
[16:18:45.161]                           break
[16:18:45.161]                         }
[16:18:45.161]                       }
[16:18:45.161]                     }
[16:18:45.161]                     invisible(muffled)
[16:18:45.161]                   }
[16:18:45.161]                   muffleCondition(cond)
[16:18:45.161]                 })
[16:18:45.161]             }))
[16:18:45.161]             future::FutureResult(value = ...future.value$value, 
[16:18:45.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.161]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.161]                     ...future.globalenv.names))
[16:18:45.161]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.161]         }, condition = base::local({
[16:18:45.161]             c <- base::c
[16:18:45.161]             inherits <- base::inherits
[16:18:45.161]             invokeRestart <- base::invokeRestart
[16:18:45.161]             length <- base::length
[16:18:45.161]             list <- base::list
[16:18:45.161]             seq.int <- base::seq.int
[16:18:45.161]             signalCondition <- base::signalCondition
[16:18:45.161]             sys.calls <- base::sys.calls
[16:18:45.161]             `[[` <- base::`[[`
[16:18:45.161]             `+` <- base::`+`
[16:18:45.161]             `<<-` <- base::`<<-`
[16:18:45.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.161]                   3L)]
[16:18:45.161]             }
[16:18:45.161]             function(cond) {
[16:18:45.161]                 is_error <- inherits(cond, "error")
[16:18:45.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.161]                   NULL)
[16:18:45.161]                 if (is_error) {
[16:18:45.161]                   sessionInformation <- function() {
[16:18:45.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.161]                       search = base::search(), system = base::Sys.info())
[16:18:45.161]                   }
[16:18:45.161]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.161]                     cond$call), session = sessionInformation(), 
[16:18:45.161]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.161]                   signalCondition(cond)
[16:18:45.161]                 }
[16:18:45.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.161]                 "immediateCondition"))) {
[16:18:45.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.161]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.161]                   if (TRUE && !signal) {
[16:18:45.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.161]                     {
[16:18:45.161]                       inherits <- base::inherits
[16:18:45.161]                       invokeRestart <- base::invokeRestart
[16:18:45.161]                       is.null <- base::is.null
[16:18:45.161]                       muffled <- FALSE
[16:18:45.161]                       if (inherits(cond, "message")) {
[16:18:45.161]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.161]                         if (muffled) 
[16:18:45.161]                           invokeRestart("muffleMessage")
[16:18:45.161]                       }
[16:18:45.161]                       else if (inherits(cond, "warning")) {
[16:18:45.161]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.161]                         if (muffled) 
[16:18:45.161]                           invokeRestart("muffleWarning")
[16:18:45.161]                       }
[16:18:45.161]                       else if (inherits(cond, "condition")) {
[16:18:45.161]                         if (!is.null(pattern)) {
[16:18:45.161]                           computeRestarts <- base::computeRestarts
[16:18:45.161]                           grepl <- base::grepl
[16:18:45.161]                           restarts <- computeRestarts(cond)
[16:18:45.161]                           for (restart in restarts) {
[16:18:45.161]                             name <- restart$name
[16:18:45.161]                             if (is.null(name)) 
[16:18:45.161]                               next
[16:18:45.161]                             if (!grepl(pattern, name)) 
[16:18:45.161]                               next
[16:18:45.161]                             invokeRestart(restart)
[16:18:45.161]                             muffled <- TRUE
[16:18:45.161]                             break
[16:18:45.161]                           }
[16:18:45.161]                         }
[16:18:45.161]                       }
[16:18:45.161]                       invisible(muffled)
[16:18:45.161]                     }
[16:18:45.161]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.161]                   }
[16:18:45.161]                 }
[16:18:45.161]                 else {
[16:18:45.161]                   if (TRUE) {
[16:18:45.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.161]                     {
[16:18:45.161]                       inherits <- base::inherits
[16:18:45.161]                       invokeRestart <- base::invokeRestart
[16:18:45.161]                       is.null <- base::is.null
[16:18:45.161]                       muffled <- FALSE
[16:18:45.161]                       if (inherits(cond, "message")) {
[16:18:45.161]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.161]                         if (muffled) 
[16:18:45.161]                           invokeRestart("muffleMessage")
[16:18:45.161]                       }
[16:18:45.161]                       else if (inherits(cond, "warning")) {
[16:18:45.161]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.161]                         if (muffled) 
[16:18:45.161]                           invokeRestart("muffleWarning")
[16:18:45.161]                       }
[16:18:45.161]                       else if (inherits(cond, "condition")) {
[16:18:45.161]                         if (!is.null(pattern)) {
[16:18:45.161]                           computeRestarts <- base::computeRestarts
[16:18:45.161]                           grepl <- base::grepl
[16:18:45.161]                           restarts <- computeRestarts(cond)
[16:18:45.161]                           for (restart in restarts) {
[16:18:45.161]                             name <- restart$name
[16:18:45.161]                             if (is.null(name)) 
[16:18:45.161]                               next
[16:18:45.161]                             if (!grepl(pattern, name)) 
[16:18:45.161]                               next
[16:18:45.161]                             invokeRestart(restart)
[16:18:45.161]                             muffled <- TRUE
[16:18:45.161]                             break
[16:18:45.161]                           }
[16:18:45.161]                         }
[16:18:45.161]                       }
[16:18:45.161]                       invisible(muffled)
[16:18:45.161]                     }
[16:18:45.161]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.161]                   }
[16:18:45.161]                 }
[16:18:45.161]             }
[16:18:45.161]         }))
[16:18:45.161]     }, error = function(ex) {
[16:18:45.161]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.161]                 ...future.rng), started = ...future.startTime, 
[16:18:45.161]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.161]             version = "1.8"), class = "FutureResult")
[16:18:45.161]     }, finally = {
[16:18:45.161]         if (!identical(...future.workdir, getwd())) 
[16:18:45.161]             setwd(...future.workdir)
[16:18:45.161]         {
[16:18:45.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.161]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.161]             }
[16:18:45.161]             base::options(...future.oldOptions)
[16:18:45.161]             if (.Platform$OS.type == "windows") {
[16:18:45.161]                 old_names <- names(...future.oldEnvVars)
[16:18:45.161]                 envs <- base::Sys.getenv()
[16:18:45.161]                 names <- names(envs)
[16:18:45.161]                 common <- intersect(names, old_names)
[16:18:45.161]                 added <- setdiff(names, old_names)
[16:18:45.161]                 removed <- setdiff(old_names, names)
[16:18:45.161]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.161]                   envs[common]]
[16:18:45.161]                 NAMES <- toupper(changed)
[16:18:45.161]                 args <- list()
[16:18:45.161]                 for (kk in seq_along(NAMES)) {
[16:18:45.161]                   name <- changed[[kk]]
[16:18:45.161]                   NAME <- NAMES[[kk]]
[16:18:45.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.161]                     next
[16:18:45.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.161]                 }
[16:18:45.161]                 NAMES <- toupper(added)
[16:18:45.161]                 for (kk in seq_along(NAMES)) {
[16:18:45.161]                   name <- added[[kk]]
[16:18:45.161]                   NAME <- NAMES[[kk]]
[16:18:45.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.161]                     next
[16:18:45.161]                   args[[name]] <- ""
[16:18:45.161]                 }
[16:18:45.161]                 NAMES <- toupper(removed)
[16:18:45.161]                 for (kk in seq_along(NAMES)) {
[16:18:45.161]                   name <- removed[[kk]]
[16:18:45.161]                   NAME <- NAMES[[kk]]
[16:18:45.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.161]                     next
[16:18:45.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.161]                 }
[16:18:45.161]                 if (length(args) > 0) 
[16:18:45.161]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.161]             }
[16:18:45.161]             else {
[16:18:45.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.161]             }
[16:18:45.161]             {
[16:18:45.161]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.161]                   0L) {
[16:18:45.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.161]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.161]                   base::options(opts)
[16:18:45.161]                 }
[16:18:45.161]                 {
[16:18:45.161]                   {
[16:18:45.161]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.161]                     NULL
[16:18:45.161]                   }
[16:18:45.161]                   options(future.plan = NULL)
[16:18:45.161]                   if (is.na(NA_character_)) 
[16:18:45.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.161]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.161]                     .init = FALSE)
[16:18:45.161]                 }
[16:18:45.161]             }
[16:18:45.161]         }
[16:18:45.161]     })
[16:18:45.161]     if (TRUE) {
[16:18:45.161]         base::sink(type = "output", split = FALSE)
[16:18:45.161]         if (TRUE) {
[16:18:45.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.161]         }
[16:18:45.161]         else {
[16:18:45.161]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.161]         }
[16:18:45.161]         base::close(...future.stdout)
[16:18:45.161]         ...future.stdout <- NULL
[16:18:45.161]     }
[16:18:45.161]     ...future.result$conditions <- ...future.conditions
[16:18:45.161]     ...future.result$finished <- base::Sys.time()
[16:18:45.161]     ...future.result
[16:18:45.161] }
[16:18:45.164] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[16:18:45.164] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[16:18:45.164] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[16:18:45.164] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:45.165] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.165] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[16:18:45.165] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[16:18:45.165] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:45.166] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.166] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:45.166] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.166] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[16:18:45.167] MultisessionFuture started
[16:18:45.167] - Launch lazy future ... done
[16:18:45.167] run() for ‘MultisessionFuture’ ... done
[16:18:45.167] Created future:
[16:18:45.167] MultisessionFuture:
[16:18:45.167] Label: ‘future_.mapply-2’
[16:18:45.167] Expression:
[16:18:45.167] {
[16:18:45.167]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.167]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.167]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.167]         on.exit(options(oopts), add = TRUE)
[16:18:45.167]     }
[16:18:45.167]     {
[16:18:45.167]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.167]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.167]         do.call(mapply, args = args)
[16:18:45.167]     }
[16:18:45.167] }
[16:18:45.167] Lazy evaluation: FALSE
[16:18:45.167] Asynchronous evaluation: TRUE
[16:18:45.167] Local evaluation: TRUE
[16:18:45.167] Environment: R_GlobalEnv
[16:18:45.167] Capture standard output: TRUE
[16:18:45.167] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.167] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.167] Packages: <none>
[16:18:45.167] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.167] Resolved: FALSE
[16:18:45.167] Value: <not collected>
[16:18:45.167] Conditions captured: <none>
[16:18:45.167] Early signaling: FALSE
[16:18:45.167] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.167] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.179] Chunk #2 of 2 ... DONE
[16:18:45.179] Launching 2 futures (chunks) ... DONE
[16:18:45.179] Resolving 2 futures (chunks) ...
[16:18:45.179] resolve() on list ...
[16:18:45.179]  recursive: 0
[16:18:45.179]  length: 2
[16:18:45.179] 
[16:18:45.180] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.180] - Validating connection of MultisessionFuture
[16:18:45.180] - received message: FutureResult
[16:18:45.180] - Received FutureResult
[16:18:45.180] - Erased future from FutureRegistry
[16:18:45.181] result() for ClusterFuture ...
[16:18:45.181] - result already collected: FutureResult
[16:18:45.181] result() for ClusterFuture ... done
[16:18:45.181] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.181] Future #1
[16:18:45.181] result() for ClusterFuture ...
[16:18:45.181] - result already collected: FutureResult
[16:18:45.181] result() for ClusterFuture ... done
[16:18:45.181] result() for ClusterFuture ...
[16:18:45.181] - result already collected: FutureResult
[16:18:45.181] result() for ClusterFuture ... done
[16:18:45.182] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:45.182] - nx: 2
[16:18:45.182] - relay: TRUE
[16:18:45.182] - stdout: TRUE
[16:18:45.182] - signal: TRUE
[16:18:45.182] - resignal: FALSE
[16:18:45.182] - force: TRUE
[16:18:45.182] - relayed: [n=2] FALSE, FALSE
[16:18:45.182] - queued futures: [n=2] FALSE, FALSE
[16:18:45.182]  - until=1
[16:18:45.182]  - relaying element #1
[16:18:45.182] result() for ClusterFuture ...
[16:18:45.183] - result already collected: FutureResult
[16:18:45.183] result() for ClusterFuture ... done
[16:18:45.183] result() for ClusterFuture ...
[16:18:45.183] - result already collected: FutureResult
[16:18:45.183] result() for ClusterFuture ... done
[16:18:45.183] result() for ClusterFuture ...
[16:18:45.183] - result already collected: FutureResult
[16:18:45.183] result() for ClusterFuture ... done
[16:18:45.183] result() for ClusterFuture ...
[16:18:45.183] - result already collected: FutureResult
[16:18:45.183] result() for ClusterFuture ... done
[16:18:45.184] - relayed: [n=2] TRUE, FALSE
[16:18:45.184] - queued futures: [n=2] TRUE, FALSE
[16:18:45.184] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:45.184]  length: 1 (resolved future 1)
[16:18:45.210] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.210] - Validating connection of MultisessionFuture
[16:18:45.210] - received message: FutureResult
[16:18:45.210] - Received FutureResult
[16:18:45.211] - Erased future from FutureRegistry
[16:18:45.211] result() for ClusterFuture ...
[16:18:45.211] - result already collected: FutureResult
[16:18:45.211] result() for ClusterFuture ... done
[16:18:45.211] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.211] Future #2
[16:18:45.211] result() for ClusterFuture ...
[16:18:45.211] - result already collected: FutureResult
[16:18:45.211] result() for ClusterFuture ... done
[16:18:45.212] result() for ClusterFuture ...
[16:18:45.212] - result already collected: FutureResult
[16:18:45.212] result() for ClusterFuture ... done
[16:18:45.212] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:45.212] - nx: 2
[16:18:45.212] - relay: TRUE
[16:18:45.212] - stdout: TRUE
[16:18:45.212] - signal: TRUE
[16:18:45.212] - resignal: FALSE
[16:18:45.212] - force: TRUE
[16:18:45.212] - relayed: [n=2] TRUE, FALSE
[16:18:45.213] - queued futures: [n=2] TRUE, FALSE
[16:18:45.213]  - until=2
[16:18:45.213]  - relaying element #2
[16:18:45.213] result() for ClusterFuture ...
[16:18:45.213] - result already collected: FutureResult
[16:18:45.213] result() for ClusterFuture ... done
[16:18:45.213] result() for ClusterFuture ...
[16:18:45.213] - result already collected: FutureResult
[16:18:45.213] result() for ClusterFuture ... done
[16:18:45.213] result() for ClusterFuture ...
[16:18:45.214] - result already collected: FutureResult
[16:18:45.214] result() for ClusterFuture ... done
[16:18:45.214] result() for ClusterFuture ...
[16:18:45.214] - result already collected: FutureResult
[16:18:45.214] result() for ClusterFuture ... done
[16:18:45.214] - relayed: [n=2] TRUE, TRUE
[16:18:45.214] - queued futures: [n=2] TRUE, TRUE
[16:18:45.214] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:45.214]  length: 0 (resolved future 2)
[16:18:45.214] Relaying remaining futures
[16:18:45.214] signalConditionsASAP(NULL, pos=0) ...
[16:18:45.214] - nx: 2
[16:18:45.215] - relay: TRUE
[16:18:45.215] - stdout: TRUE
[16:18:45.215] - signal: TRUE
[16:18:45.215] - resignal: FALSE
[16:18:45.215] - force: TRUE
[16:18:45.215] - relayed: [n=2] TRUE, TRUE
[16:18:45.215] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:45.215] - relayed: [n=2] TRUE, TRUE
[16:18:45.215] - queued futures: [n=2] TRUE, TRUE
[16:18:45.215] signalConditionsASAP(NULL, pos=0) ... done
[16:18:45.215] resolve() on list ... DONE
[16:18:45.216] result() for ClusterFuture ...
[16:18:45.216] - result already collected: FutureResult
[16:18:45.216] result() for ClusterFuture ... done
[16:18:45.216] result() for ClusterFuture ...
[16:18:45.216] - result already collected: FutureResult
[16:18:45.216] result() for ClusterFuture ... done
[16:18:45.216] result() for ClusterFuture ...
[16:18:45.216] - result already collected: FutureResult
[16:18:45.216] result() for ClusterFuture ... done
[16:18:45.216] result() for ClusterFuture ...
[16:18:45.216] - result already collected: FutureResult
[16:18:45.217] result() for ClusterFuture ... done
[16:18:45.217]  - Number of value chunks collected: 2
[16:18:45.217] Resolving 2 futures (chunks) ... DONE
[16:18:45.217] Reducing values from 2 chunks ...
[16:18:45.217]  - Number of values collected after concatenation: 3
[16:18:45.217]  - Number of values expected: 3
[16:18:45.217] Reducing values from 2 chunks ... DONE
[16:18:45.217] future_mapply() ... DONE
[16:18:45.217] future_mapply() ...
[16:18:45.222] Number of chunks: 5
[16:18:45.222] getGlobalsAndPackagesXApply() ...
[16:18:45.222]  - future.globals: TRUE
[16:18:45.222] getGlobalsAndPackages() ...
[16:18:45.222] Searching for globals...
[16:18:45.223] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:45.223] Searching for globals ... DONE
[16:18:45.224] Resolving globals: FALSE
[16:18:45.224] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:45.224] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:45.224] - globals: [1] ‘FUN’
[16:18:45.225] 
[16:18:45.225] getGlobalsAndPackages() ... DONE
[16:18:45.225]  - globals found/used: [n=1] ‘FUN’
[16:18:45.225]  - needed namespaces: [n=0] 
[16:18:45.225] Finding globals ... DONE
[16:18:45.225] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:45.225] List of 2
[16:18:45.225]  $ ...future.FUN:function (C, k)  
[16:18:45.225]  $ MoreArgs     : NULL
[16:18:45.225]  - attr(*, "where")=List of 2
[16:18:45.225]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:45.225]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:45.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:45.225]  - attr(*, "resolved")= logi FALSE
[16:18:45.225]  - attr(*, "total_size")= num NA
[16:18:45.228] Packages to be attached in all futures: [n=0] 
[16:18:45.228] getGlobalsAndPackagesXApply() ... DONE
[16:18:45.228] Number of futures (= number of chunks): 5
[16:18:45.228] Launching 5 futures (chunks) ...
[16:18:45.228] Chunk #1 of 5 ...
[16:18:45.228]  - Finding globals in '...' for chunk #1 ...
[16:18:45.229] getGlobalsAndPackages() ...
[16:18:45.229] Searching for globals...
[16:18:45.229] 
[16:18:45.229] Searching for globals ... DONE
[16:18:45.229] - globals: [0] <none>
[16:18:45.229] getGlobalsAndPackages() ... DONE
[16:18:45.229]    + additional globals found: [n=0] 
[16:18:45.229]    + additional namespaces needed: [n=0] 
[16:18:45.230]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:45.230]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:45.230]  - seeds: <none>
[16:18:45.230]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.230] getGlobalsAndPackages() ...
[16:18:45.230] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.230] Resolving globals: FALSE
[16:18:45.231] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:45.231] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:45.231] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.231] 
[16:18:45.231] getGlobalsAndPackages() ... DONE
[16:18:45.232] run() for ‘Future’ ...
[16:18:45.232] - state: ‘created’
[16:18:45.232] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.246] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.246] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.246]   - Field: ‘node’
[16:18:45.246]   - Field: ‘label’
[16:18:45.246]   - Field: ‘local’
[16:18:45.246]   - Field: ‘owner’
[16:18:45.246]   - Field: ‘envir’
[16:18:45.247]   - Field: ‘workers’
[16:18:45.247]   - Field: ‘packages’
[16:18:45.247]   - Field: ‘gc’
[16:18:45.247]   - Field: ‘conditions’
[16:18:45.247]   - Field: ‘persistent’
[16:18:45.247]   - Field: ‘expr’
[16:18:45.247]   - Field: ‘uuid’
[16:18:45.247]   - Field: ‘seed’
[16:18:45.247]   - Field: ‘version’
[16:18:45.247]   - Field: ‘result’
[16:18:45.247]   - Field: ‘asynchronous’
[16:18:45.248]   - Field: ‘calls’
[16:18:45.248]   - Field: ‘globals’
[16:18:45.248]   - Field: ‘stdout’
[16:18:45.248]   - Field: ‘earlySignal’
[16:18:45.248]   - Field: ‘lazy’
[16:18:45.248]   - Field: ‘state’
[16:18:45.248] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.248] - Launch lazy future ...
[16:18:45.249] Packages needed by the future expression (n = 0): <none>
[16:18:45.249] Packages needed by future strategies (n = 0): <none>
[16:18:45.249] {
[16:18:45.249]     {
[16:18:45.249]         {
[16:18:45.249]             ...future.startTime <- base::Sys.time()
[16:18:45.249]             {
[16:18:45.249]                 {
[16:18:45.249]                   {
[16:18:45.249]                     {
[16:18:45.249]                       base::local({
[16:18:45.249]                         has_future <- base::requireNamespace("future", 
[16:18:45.249]                           quietly = TRUE)
[16:18:45.249]                         if (has_future) {
[16:18:45.249]                           ns <- base::getNamespace("future")
[16:18:45.249]                           version <- ns[[".package"]][["version"]]
[16:18:45.249]                           if (is.null(version)) 
[16:18:45.249]                             version <- utils::packageVersion("future")
[16:18:45.249]                         }
[16:18:45.249]                         else {
[16:18:45.249]                           version <- NULL
[16:18:45.249]                         }
[16:18:45.249]                         if (!has_future || version < "1.8.0") {
[16:18:45.249]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.249]                             "", base::R.version$version.string), 
[16:18:45.249]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.249]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.249]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.249]                               "release", "version")], collapse = " "), 
[16:18:45.249]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.249]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.249]                             info)
[16:18:45.249]                           info <- base::paste(info, collapse = "; ")
[16:18:45.249]                           if (!has_future) {
[16:18:45.249]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.249]                               info)
[16:18:45.249]                           }
[16:18:45.249]                           else {
[16:18:45.249]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.249]                               info, version)
[16:18:45.249]                           }
[16:18:45.249]                           base::stop(msg)
[16:18:45.249]                         }
[16:18:45.249]                       })
[16:18:45.249]                     }
[16:18:45.249]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.249]                     base::options(mc.cores = 1L)
[16:18:45.249]                   }
[16:18:45.249]                   ...future.strategy.old <- future::plan("list")
[16:18:45.249]                   options(future.plan = NULL)
[16:18:45.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.249]                 }
[16:18:45.249]                 ...future.workdir <- getwd()
[16:18:45.249]             }
[16:18:45.249]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.249]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.249]         }
[16:18:45.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.249]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:45.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.249]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.249]             base::names(...future.oldOptions))
[16:18:45.249]     }
[16:18:45.249]     if (FALSE) {
[16:18:45.249]     }
[16:18:45.249]     else {
[16:18:45.249]         if (TRUE) {
[16:18:45.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.249]                 open = "w")
[16:18:45.249]         }
[16:18:45.249]         else {
[16:18:45.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.249]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.249]         }
[16:18:45.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.249]             base::sink(type = "output", split = FALSE)
[16:18:45.249]             base::close(...future.stdout)
[16:18:45.249]         }, add = TRUE)
[16:18:45.249]     }
[16:18:45.249]     ...future.frame <- base::sys.nframe()
[16:18:45.249]     ...future.conditions <- base::list()
[16:18:45.249]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.249]     if (FALSE) {
[16:18:45.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.249]     }
[16:18:45.249]     ...future.result <- base::tryCatch({
[16:18:45.249]         base::withCallingHandlers({
[16:18:45.249]             ...future.value <- base::withVisible(base::local({
[16:18:45.249]                 ...future.makeSendCondition <- base::local({
[16:18:45.249]                   sendCondition <- NULL
[16:18:45.249]                   function(frame = 1L) {
[16:18:45.249]                     if (is.function(sendCondition)) 
[16:18:45.249]                       return(sendCondition)
[16:18:45.249]                     ns <- getNamespace("parallel")
[16:18:45.249]                     if (exists("sendData", mode = "function", 
[16:18:45.249]                       envir = ns)) {
[16:18:45.249]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.249]                         envir = ns)
[16:18:45.249]                       envir <- sys.frame(frame)
[16:18:45.249]                       master <- NULL
[16:18:45.249]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.249]                         !identical(envir, emptyenv())) {
[16:18:45.249]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.249]                           inherits = FALSE)) {
[16:18:45.249]                           master <- get("master", mode = "list", 
[16:18:45.249]                             envir = envir, inherits = FALSE)
[16:18:45.249]                           if (inherits(master, c("SOCKnode", 
[16:18:45.249]                             "SOCK0node"))) {
[16:18:45.249]                             sendCondition <<- function(cond) {
[16:18:45.249]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.249]                                 success = TRUE)
[16:18:45.249]                               parallel_sendData(master, data)
[16:18:45.249]                             }
[16:18:45.249]                             return(sendCondition)
[16:18:45.249]                           }
[16:18:45.249]                         }
[16:18:45.249]                         frame <- frame + 1L
[16:18:45.249]                         envir <- sys.frame(frame)
[16:18:45.249]                       }
[16:18:45.249]                     }
[16:18:45.249]                     sendCondition <<- function(cond) NULL
[16:18:45.249]                   }
[16:18:45.249]                 })
[16:18:45.249]                 withCallingHandlers({
[16:18:45.249]                   {
[16:18:45.249]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.249]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.249]                       ...future.globals.maxSize)) {
[16:18:45.249]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.249]                       on.exit(options(oopts), add = TRUE)
[16:18:45.249]                     }
[16:18:45.249]                     {
[16:18:45.249]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.249]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.249]                         USE.NAMES = FALSE)
[16:18:45.249]                       do.call(mapply, args = args)
[16:18:45.249]                     }
[16:18:45.249]                   }
[16:18:45.249]                 }, immediateCondition = function(cond) {
[16:18:45.249]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.249]                   sendCondition(cond)
[16:18:45.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.249]                   {
[16:18:45.249]                     inherits <- base::inherits
[16:18:45.249]                     invokeRestart <- base::invokeRestart
[16:18:45.249]                     is.null <- base::is.null
[16:18:45.249]                     muffled <- FALSE
[16:18:45.249]                     if (inherits(cond, "message")) {
[16:18:45.249]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.249]                       if (muffled) 
[16:18:45.249]                         invokeRestart("muffleMessage")
[16:18:45.249]                     }
[16:18:45.249]                     else if (inherits(cond, "warning")) {
[16:18:45.249]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.249]                       if (muffled) 
[16:18:45.249]                         invokeRestart("muffleWarning")
[16:18:45.249]                     }
[16:18:45.249]                     else if (inherits(cond, "condition")) {
[16:18:45.249]                       if (!is.null(pattern)) {
[16:18:45.249]                         computeRestarts <- base::computeRestarts
[16:18:45.249]                         grepl <- base::grepl
[16:18:45.249]                         restarts <- computeRestarts(cond)
[16:18:45.249]                         for (restart in restarts) {
[16:18:45.249]                           name <- restart$name
[16:18:45.249]                           if (is.null(name)) 
[16:18:45.249]                             next
[16:18:45.249]                           if (!grepl(pattern, name)) 
[16:18:45.249]                             next
[16:18:45.249]                           invokeRestart(restart)
[16:18:45.249]                           muffled <- TRUE
[16:18:45.249]                           break
[16:18:45.249]                         }
[16:18:45.249]                       }
[16:18:45.249]                     }
[16:18:45.249]                     invisible(muffled)
[16:18:45.249]                   }
[16:18:45.249]                   muffleCondition(cond)
[16:18:45.249]                 })
[16:18:45.249]             }))
[16:18:45.249]             future::FutureResult(value = ...future.value$value, 
[16:18:45.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.249]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.249]                     ...future.globalenv.names))
[16:18:45.249]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.249]         }, condition = base::local({
[16:18:45.249]             c <- base::c
[16:18:45.249]             inherits <- base::inherits
[16:18:45.249]             invokeRestart <- base::invokeRestart
[16:18:45.249]             length <- base::length
[16:18:45.249]             list <- base::list
[16:18:45.249]             seq.int <- base::seq.int
[16:18:45.249]             signalCondition <- base::signalCondition
[16:18:45.249]             sys.calls <- base::sys.calls
[16:18:45.249]             `[[` <- base::`[[`
[16:18:45.249]             `+` <- base::`+`
[16:18:45.249]             `<<-` <- base::`<<-`
[16:18:45.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.249]                   3L)]
[16:18:45.249]             }
[16:18:45.249]             function(cond) {
[16:18:45.249]                 is_error <- inherits(cond, "error")
[16:18:45.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.249]                   NULL)
[16:18:45.249]                 if (is_error) {
[16:18:45.249]                   sessionInformation <- function() {
[16:18:45.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.249]                       search = base::search(), system = base::Sys.info())
[16:18:45.249]                   }
[16:18:45.249]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.249]                     cond$call), session = sessionInformation(), 
[16:18:45.249]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.249]                   signalCondition(cond)
[16:18:45.249]                 }
[16:18:45.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.249]                 "immediateCondition"))) {
[16:18:45.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.249]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.249]                   if (TRUE && !signal) {
[16:18:45.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.249]                     {
[16:18:45.249]                       inherits <- base::inherits
[16:18:45.249]                       invokeRestart <- base::invokeRestart
[16:18:45.249]                       is.null <- base::is.null
[16:18:45.249]                       muffled <- FALSE
[16:18:45.249]                       if (inherits(cond, "message")) {
[16:18:45.249]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.249]                         if (muffled) 
[16:18:45.249]                           invokeRestart("muffleMessage")
[16:18:45.249]                       }
[16:18:45.249]                       else if (inherits(cond, "warning")) {
[16:18:45.249]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.249]                         if (muffled) 
[16:18:45.249]                           invokeRestart("muffleWarning")
[16:18:45.249]                       }
[16:18:45.249]                       else if (inherits(cond, "condition")) {
[16:18:45.249]                         if (!is.null(pattern)) {
[16:18:45.249]                           computeRestarts <- base::computeRestarts
[16:18:45.249]                           grepl <- base::grepl
[16:18:45.249]                           restarts <- computeRestarts(cond)
[16:18:45.249]                           for (restart in restarts) {
[16:18:45.249]                             name <- restart$name
[16:18:45.249]                             if (is.null(name)) 
[16:18:45.249]                               next
[16:18:45.249]                             if (!grepl(pattern, name)) 
[16:18:45.249]                               next
[16:18:45.249]                             invokeRestart(restart)
[16:18:45.249]                             muffled <- TRUE
[16:18:45.249]                             break
[16:18:45.249]                           }
[16:18:45.249]                         }
[16:18:45.249]                       }
[16:18:45.249]                       invisible(muffled)
[16:18:45.249]                     }
[16:18:45.249]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.249]                   }
[16:18:45.249]                 }
[16:18:45.249]                 else {
[16:18:45.249]                   if (TRUE) {
[16:18:45.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.249]                     {
[16:18:45.249]                       inherits <- base::inherits
[16:18:45.249]                       invokeRestart <- base::invokeRestart
[16:18:45.249]                       is.null <- base::is.null
[16:18:45.249]                       muffled <- FALSE
[16:18:45.249]                       if (inherits(cond, "message")) {
[16:18:45.249]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.249]                         if (muffled) 
[16:18:45.249]                           invokeRestart("muffleMessage")
[16:18:45.249]                       }
[16:18:45.249]                       else if (inherits(cond, "warning")) {
[16:18:45.249]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.249]                         if (muffled) 
[16:18:45.249]                           invokeRestart("muffleWarning")
[16:18:45.249]                       }
[16:18:45.249]                       else if (inherits(cond, "condition")) {
[16:18:45.249]                         if (!is.null(pattern)) {
[16:18:45.249]                           computeRestarts <- base::computeRestarts
[16:18:45.249]                           grepl <- base::grepl
[16:18:45.249]                           restarts <- computeRestarts(cond)
[16:18:45.249]                           for (restart in restarts) {
[16:18:45.249]                             name <- restart$name
[16:18:45.249]                             if (is.null(name)) 
[16:18:45.249]                               next
[16:18:45.249]                             if (!grepl(pattern, name)) 
[16:18:45.249]                               next
[16:18:45.249]                             invokeRestart(restart)
[16:18:45.249]                             muffled <- TRUE
[16:18:45.249]                             break
[16:18:45.249]                           }
[16:18:45.249]                         }
[16:18:45.249]                       }
[16:18:45.249]                       invisible(muffled)
[16:18:45.249]                     }
[16:18:45.249]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.249]                   }
[16:18:45.249]                 }
[16:18:45.249]             }
[16:18:45.249]         }))
[16:18:45.249]     }, error = function(ex) {
[16:18:45.249]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.249]                 ...future.rng), started = ...future.startTime, 
[16:18:45.249]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.249]             version = "1.8"), class = "FutureResult")
[16:18:45.249]     }, finally = {
[16:18:45.249]         if (!identical(...future.workdir, getwd())) 
[16:18:45.249]             setwd(...future.workdir)
[16:18:45.249]         {
[16:18:45.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.249]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.249]             }
[16:18:45.249]             base::options(...future.oldOptions)
[16:18:45.249]             if (.Platform$OS.type == "windows") {
[16:18:45.249]                 old_names <- names(...future.oldEnvVars)
[16:18:45.249]                 envs <- base::Sys.getenv()
[16:18:45.249]                 names <- names(envs)
[16:18:45.249]                 common <- intersect(names, old_names)
[16:18:45.249]                 added <- setdiff(names, old_names)
[16:18:45.249]                 removed <- setdiff(old_names, names)
[16:18:45.249]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.249]                   envs[common]]
[16:18:45.249]                 NAMES <- toupper(changed)
[16:18:45.249]                 args <- list()
[16:18:45.249]                 for (kk in seq_along(NAMES)) {
[16:18:45.249]                   name <- changed[[kk]]
[16:18:45.249]                   NAME <- NAMES[[kk]]
[16:18:45.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.249]                     next
[16:18:45.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.249]                 }
[16:18:45.249]                 NAMES <- toupper(added)
[16:18:45.249]                 for (kk in seq_along(NAMES)) {
[16:18:45.249]                   name <- added[[kk]]
[16:18:45.249]                   NAME <- NAMES[[kk]]
[16:18:45.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.249]                     next
[16:18:45.249]                   args[[name]] <- ""
[16:18:45.249]                 }
[16:18:45.249]                 NAMES <- toupper(removed)
[16:18:45.249]                 for (kk in seq_along(NAMES)) {
[16:18:45.249]                   name <- removed[[kk]]
[16:18:45.249]                   NAME <- NAMES[[kk]]
[16:18:45.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.249]                     next
[16:18:45.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.249]                 }
[16:18:45.249]                 if (length(args) > 0) 
[16:18:45.249]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.249]             }
[16:18:45.249]             else {
[16:18:45.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.249]             }
[16:18:45.249]             {
[16:18:45.249]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.249]                   0L) {
[16:18:45.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.249]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.249]                   base::options(opts)
[16:18:45.249]                 }
[16:18:45.249]                 {
[16:18:45.249]                   {
[16:18:45.249]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.249]                     NULL
[16:18:45.249]                   }
[16:18:45.249]                   options(future.plan = NULL)
[16:18:45.249]                   if (is.na(NA_character_)) 
[16:18:45.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.249]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.249]                     .init = FALSE)
[16:18:45.249]                 }
[16:18:45.249]             }
[16:18:45.249]         }
[16:18:45.249]     })
[16:18:45.249]     if (TRUE) {
[16:18:45.249]         base::sink(type = "output", split = FALSE)
[16:18:45.249]         if (TRUE) {
[16:18:45.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.249]         }
[16:18:45.249]         else {
[16:18:45.249]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.249]         }
[16:18:45.249]         base::close(...future.stdout)
[16:18:45.249]         ...future.stdout <- NULL
[16:18:45.249]     }
[16:18:45.249]     ...future.result$conditions <- ...future.conditions
[16:18:45.249]     ...future.result$finished <- base::Sys.time()
[16:18:45.249]     ...future.result
[16:18:45.249] }
[16:18:45.252] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[16:18:45.252] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[16:18:45.252] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[16:18:45.253] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:45.253] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.253] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[16:18:45.253] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[16:18:45.253] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:45.254] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.254] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:45.254] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.254] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[16:18:45.255] MultisessionFuture started
[16:18:45.255] - Launch lazy future ... done
[16:18:45.255] run() for ‘MultisessionFuture’ ... done
[16:18:45.255] Created future:
[16:18:45.255] MultisessionFuture:
[16:18:45.255] Label: ‘future_mapply-1’
[16:18:45.255] Expression:
[16:18:45.255] {
[16:18:45.255]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.255]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.255]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.255]         on.exit(options(oopts), add = TRUE)
[16:18:45.255]     }
[16:18:45.255]     {
[16:18:45.255]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.255]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.255]         do.call(mapply, args = args)
[16:18:45.255]     }
[16:18:45.255] }
[16:18:45.255] Lazy evaluation: FALSE
[16:18:45.255] Asynchronous evaluation: TRUE
[16:18:45.255] Local evaluation: TRUE
[16:18:45.255] Environment: R_GlobalEnv
[16:18:45.255] Capture standard output: TRUE
[16:18:45.255] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.255] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.255] Packages: <none>
[16:18:45.255] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.255] Resolved: FALSE
[16:18:45.255] Value: <not collected>
[16:18:45.255] Conditions captured: <none>
[16:18:45.255] Early signaling: FALSE
[16:18:45.255] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.255] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.267] Chunk #1 of 5 ... DONE
[16:18:45.267] Chunk #2 of 5 ...
[16:18:45.267]  - Finding globals in '...' for chunk #2 ...
[16:18:45.267] getGlobalsAndPackages() ...
[16:18:45.267] Searching for globals...
[16:18:45.268] 
[16:18:45.268] Searching for globals ... DONE
[16:18:45.268] - globals: [0] <none>
[16:18:45.268] getGlobalsAndPackages() ... DONE
[16:18:45.268]    + additional globals found: [n=0] 
[16:18:45.268]    + additional namespaces needed: [n=0] 
[16:18:45.268]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:45.268]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:45.268]  - seeds: <none>
[16:18:45.268]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.269] getGlobalsAndPackages() ...
[16:18:45.269] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.269] Resolving globals: FALSE
[16:18:45.269] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:45.270] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:45.270] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.270] 
[16:18:45.270] getGlobalsAndPackages() ... DONE
[16:18:45.270] run() for ‘Future’ ...
[16:18:45.270] - state: ‘created’
[16:18:45.271] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.285] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.286]   - Field: ‘node’
[16:18:45.286]   - Field: ‘label’
[16:18:45.286]   - Field: ‘local’
[16:18:45.286]   - Field: ‘owner’
[16:18:45.286]   - Field: ‘envir’
[16:18:45.286]   - Field: ‘workers’
[16:18:45.286]   - Field: ‘packages’
[16:18:45.286]   - Field: ‘gc’
[16:18:45.286]   - Field: ‘conditions’
[16:18:45.287]   - Field: ‘persistent’
[16:18:45.287]   - Field: ‘expr’
[16:18:45.287]   - Field: ‘uuid’
[16:18:45.287]   - Field: ‘seed’
[16:18:45.287]   - Field: ‘version’
[16:18:45.287]   - Field: ‘result’
[16:18:45.287]   - Field: ‘asynchronous’
[16:18:45.287]   - Field: ‘calls’
[16:18:45.287]   - Field: ‘globals’
[16:18:45.287]   - Field: ‘stdout’
[16:18:45.287]   - Field: ‘earlySignal’
[16:18:45.288]   - Field: ‘lazy’
[16:18:45.288]   - Field: ‘state’
[16:18:45.288] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.288] - Launch lazy future ...
[16:18:45.288] Packages needed by the future expression (n = 0): <none>
[16:18:45.288] Packages needed by future strategies (n = 0): <none>
[16:18:45.289] {
[16:18:45.289]     {
[16:18:45.289]         {
[16:18:45.289]             ...future.startTime <- base::Sys.time()
[16:18:45.289]             {
[16:18:45.289]                 {
[16:18:45.289]                   {
[16:18:45.289]                     {
[16:18:45.289]                       base::local({
[16:18:45.289]                         has_future <- base::requireNamespace("future", 
[16:18:45.289]                           quietly = TRUE)
[16:18:45.289]                         if (has_future) {
[16:18:45.289]                           ns <- base::getNamespace("future")
[16:18:45.289]                           version <- ns[[".package"]][["version"]]
[16:18:45.289]                           if (is.null(version)) 
[16:18:45.289]                             version <- utils::packageVersion("future")
[16:18:45.289]                         }
[16:18:45.289]                         else {
[16:18:45.289]                           version <- NULL
[16:18:45.289]                         }
[16:18:45.289]                         if (!has_future || version < "1.8.0") {
[16:18:45.289]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.289]                             "", base::R.version$version.string), 
[16:18:45.289]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.289]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.289]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.289]                               "release", "version")], collapse = " "), 
[16:18:45.289]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.289]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.289]                             info)
[16:18:45.289]                           info <- base::paste(info, collapse = "; ")
[16:18:45.289]                           if (!has_future) {
[16:18:45.289]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.289]                               info)
[16:18:45.289]                           }
[16:18:45.289]                           else {
[16:18:45.289]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.289]                               info, version)
[16:18:45.289]                           }
[16:18:45.289]                           base::stop(msg)
[16:18:45.289]                         }
[16:18:45.289]                       })
[16:18:45.289]                     }
[16:18:45.289]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.289]                     base::options(mc.cores = 1L)
[16:18:45.289]                   }
[16:18:45.289]                   ...future.strategy.old <- future::plan("list")
[16:18:45.289]                   options(future.plan = NULL)
[16:18:45.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.289]                 }
[16:18:45.289]                 ...future.workdir <- getwd()
[16:18:45.289]             }
[16:18:45.289]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.289]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.289]         }
[16:18:45.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.289]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:45.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.289]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.289]             base::names(...future.oldOptions))
[16:18:45.289]     }
[16:18:45.289]     if (FALSE) {
[16:18:45.289]     }
[16:18:45.289]     else {
[16:18:45.289]         if (TRUE) {
[16:18:45.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.289]                 open = "w")
[16:18:45.289]         }
[16:18:45.289]         else {
[16:18:45.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.289]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.289]         }
[16:18:45.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.289]             base::sink(type = "output", split = FALSE)
[16:18:45.289]             base::close(...future.stdout)
[16:18:45.289]         }, add = TRUE)
[16:18:45.289]     }
[16:18:45.289]     ...future.frame <- base::sys.nframe()
[16:18:45.289]     ...future.conditions <- base::list()
[16:18:45.289]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.289]     if (FALSE) {
[16:18:45.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.289]     }
[16:18:45.289]     ...future.result <- base::tryCatch({
[16:18:45.289]         base::withCallingHandlers({
[16:18:45.289]             ...future.value <- base::withVisible(base::local({
[16:18:45.289]                 ...future.makeSendCondition <- base::local({
[16:18:45.289]                   sendCondition <- NULL
[16:18:45.289]                   function(frame = 1L) {
[16:18:45.289]                     if (is.function(sendCondition)) 
[16:18:45.289]                       return(sendCondition)
[16:18:45.289]                     ns <- getNamespace("parallel")
[16:18:45.289]                     if (exists("sendData", mode = "function", 
[16:18:45.289]                       envir = ns)) {
[16:18:45.289]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.289]                         envir = ns)
[16:18:45.289]                       envir <- sys.frame(frame)
[16:18:45.289]                       master <- NULL
[16:18:45.289]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.289]                         !identical(envir, emptyenv())) {
[16:18:45.289]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.289]                           inherits = FALSE)) {
[16:18:45.289]                           master <- get("master", mode = "list", 
[16:18:45.289]                             envir = envir, inherits = FALSE)
[16:18:45.289]                           if (inherits(master, c("SOCKnode", 
[16:18:45.289]                             "SOCK0node"))) {
[16:18:45.289]                             sendCondition <<- function(cond) {
[16:18:45.289]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.289]                                 success = TRUE)
[16:18:45.289]                               parallel_sendData(master, data)
[16:18:45.289]                             }
[16:18:45.289]                             return(sendCondition)
[16:18:45.289]                           }
[16:18:45.289]                         }
[16:18:45.289]                         frame <- frame + 1L
[16:18:45.289]                         envir <- sys.frame(frame)
[16:18:45.289]                       }
[16:18:45.289]                     }
[16:18:45.289]                     sendCondition <<- function(cond) NULL
[16:18:45.289]                   }
[16:18:45.289]                 })
[16:18:45.289]                 withCallingHandlers({
[16:18:45.289]                   {
[16:18:45.289]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.289]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.289]                       ...future.globals.maxSize)) {
[16:18:45.289]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.289]                       on.exit(options(oopts), add = TRUE)
[16:18:45.289]                     }
[16:18:45.289]                     {
[16:18:45.289]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.289]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.289]                         USE.NAMES = FALSE)
[16:18:45.289]                       do.call(mapply, args = args)
[16:18:45.289]                     }
[16:18:45.289]                   }
[16:18:45.289]                 }, immediateCondition = function(cond) {
[16:18:45.289]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.289]                   sendCondition(cond)
[16:18:45.289]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.289]                   {
[16:18:45.289]                     inherits <- base::inherits
[16:18:45.289]                     invokeRestart <- base::invokeRestart
[16:18:45.289]                     is.null <- base::is.null
[16:18:45.289]                     muffled <- FALSE
[16:18:45.289]                     if (inherits(cond, "message")) {
[16:18:45.289]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.289]                       if (muffled) 
[16:18:45.289]                         invokeRestart("muffleMessage")
[16:18:45.289]                     }
[16:18:45.289]                     else if (inherits(cond, "warning")) {
[16:18:45.289]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.289]                       if (muffled) 
[16:18:45.289]                         invokeRestart("muffleWarning")
[16:18:45.289]                     }
[16:18:45.289]                     else if (inherits(cond, "condition")) {
[16:18:45.289]                       if (!is.null(pattern)) {
[16:18:45.289]                         computeRestarts <- base::computeRestarts
[16:18:45.289]                         grepl <- base::grepl
[16:18:45.289]                         restarts <- computeRestarts(cond)
[16:18:45.289]                         for (restart in restarts) {
[16:18:45.289]                           name <- restart$name
[16:18:45.289]                           if (is.null(name)) 
[16:18:45.289]                             next
[16:18:45.289]                           if (!grepl(pattern, name)) 
[16:18:45.289]                             next
[16:18:45.289]                           invokeRestart(restart)
[16:18:45.289]                           muffled <- TRUE
[16:18:45.289]                           break
[16:18:45.289]                         }
[16:18:45.289]                       }
[16:18:45.289]                     }
[16:18:45.289]                     invisible(muffled)
[16:18:45.289]                   }
[16:18:45.289]                   muffleCondition(cond)
[16:18:45.289]                 })
[16:18:45.289]             }))
[16:18:45.289]             future::FutureResult(value = ...future.value$value, 
[16:18:45.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.289]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.289]                     ...future.globalenv.names))
[16:18:45.289]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.289]         }, condition = base::local({
[16:18:45.289]             c <- base::c
[16:18:45.289]             inherits <- base::inherits
[16:18:45.289]             invokeRestart <- base::invokeRestart
[16:18:45.289]             length <- base::length
[16:18:45.289]             list <- base::list
[16:18:45.289]             seq.int <- base::seq.int
[16:18:45.289]             signalCondition <- base::signalCondition
[16:18:45.289]             sys.calls <- base::sys.calls
[16:18:45.289]             `[[` <- base::`[[`
[16:18:45.289]             `+` <- base::`+`
[16:18:45.289]             `<<-` <- base::`<<-`
[16:18:45.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.289]                   3L)]
[16:18:45.289]             }
[16:18:45.289]             function(cond) {
[16:18:45.289]                 is_error <- inherits(cond, "error")
[16:18:45.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.289]                   NULL)
[16:18:45.289]                 if (is_error) {
[16:18:45.289]                   sessionInformation <- function() {
[16:18:45.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.289]                       search = base::search(), system = base::Sys.info())
[16:18:45.289]                   }
[16:18:45.289]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.289]                     cond$call), session = sessionInformation(), 
[16:18:45.289]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.289]                   signalCondition(cond)
[16:18:45.289]                 }
[16:18:45.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.289]                 "immediateCondition"))) {
[16:18:45.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.289]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.289]                   if (TRUE && !signal) {
[16:18:45.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.289]                     {
[16:18:45.289]                       inherits <- base::inherits
[16:18:45.289]                       invokeRestart <- base::invokeRestart
[16:18:45.289]                       is.null <- base::is.null
[16:18:45.289]                       muffled <- FALSE
[16:18:45.289]                       if (inherits(cond, "message")) {
[16:18:45.289]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.289]                         if (muffled) 
[16:18:45.289]                           invokeRestart("muffleMessage")
[16:18:45.289]                       }
[16:18:45.289]                       else if (inherits(cond, "warning")) {
[16:18:45.289]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.289]                         if (muffled) 
[16:18:45.289]                           invokeRestart("muffleWarning")
[16:18:45.289]                       }
[16:18:45.289]                       else if (inherits(cond, "condition")) {
[16:18:45.289]                         if (!is.null(pattern)) {
[16:18:45.289]                           computeRestarts <- base::computeRestarts
[16:18:45.289]                           grepl <- base::grepl
[16:18:45.289]                           restarts <- computeRestarts(cond)
[16:18:45.289]                           for (restart in restarts) {
[16:18:45.289]                             name <- restart$name
[16:18:45.289]                             if (is.null(name)) 
[16:18:45.289]                               next
[16:18:45.289]                             if (!grepl(pattern, name)) 
[16:18:45.289]                               next
[16:18:45.289]                             invokeRestart(restart)
[16:18:45.289]                             muffled <- TRUE
[16:18:45.289]                             break
[16:18:45.289]                           }
[16:18:45.289]                         }
[16:18:45.289]                       }
[16:18:45.289]                       invisible(muffled)
[16:18:45.289]                     }
[16:18:45.289]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.289]                   }
[16:18:45.289]                 }
[16:18:45.289]                 else {
[16:18:45.289]                   if (TRUE) {
[16:18:45.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.289]                     {
[16:18:45.289]                       inherits <- base::inherits
[16:18:45.289]                       invokeRestart <- base::invokeRestart
[16:18:45.289]                       is.null <- base::is.null
[16:18:45.289]                       muffled <- FALSE
[16:18:45.289]                       if (inherits(cond, "message")) {
[16:18:45.289]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.289]                         if (muffled) 
[16:18:45.289]                           invokeRestart("muffleMessage")
[16:18:45.289]                       }
[16:18:45.289]                       else if (inherits(cond, "warning")) {
[16:18:45.289]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.289]                         if (muffled) 
[16:18:45.289]                           invokeRestart("muffleWarning")
[16:18:45.289]                       }
[16:18:45.289]                       else if (inherits(cond, "condition")) {
[16:18:45.289]                         if (!is.null(pattern)) {
[16:18:45.289]                           computeRestarts <- base::computeRestarts
[16:18:45.289]                           grepl <- base::grepl
[16:18:45.289]                           restarts <- computeRestarts(cond)
[16:18:45.289]                           for (restart in restarts) {
[16:18:45.289]                             name <- restart$name
[16:18:45.289]                             if (is.null(name)) 
[16:18:45.289]                               next
[16:18:45.289]                             if (!grepl(pattern, name)) 
[16:18:45.289]                               next
[16:18:45.289]                             invokeRestart(restart)
[16:18:45.289]                             muffled <- TRUE
[16:18:45.289]                             break
[16:18:45.289]                           }
[16:18:45.289]                         }
[16:18:45.289]                       }
[16:18:45.289]                       invisible(muffled)
[16:18:45.289]                     }
[16:18:45.289]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.289]                   }
[16:18:45.289]                 }
[16:18:45.289]             }
[16:18:45.289]         }))
[16:18:45.289]     }, error = function(ex) {
[16:18:45.289]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.289]                 ...future.rng), started = ...future.startTime, 
[16:18:45.289]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.289]             version = "1.8"), class = "FutureResult")
[16:18:45.289]     }, finally = {
[16:18:45.289]         if (!identical(...future.workdir, getwd())) 
[16:18:45.289]             setwd(...future.workdir)
[16:18:45.289]         {
[16:18:45.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.289]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.289]             }
[16:18:45.289]             base::options(...future.oldOptions)
[16:18:45.289]             if (.Platform$OS.type == "windows") {
[16:18:45.289]                 old_names <- names(...future.oldEnvVars)
[16:18:45.289]                 envs <- base::Sys.getenv()
[16:18:45.289]                 names <- names(envs)
[16:18:45.289]                 common <- intersect(names, old_names)
[16:18:45.289]                 added <- setdiff(names, old_names)
[16:18:45.289]                 removed <- setdiff(old_names, names)
[16:18:45.289]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.289]                   envs[common]]
[16:18:45.289]                 NAMES <- toupper(changed)
[16:18:45.289]                 args <- list()
[16:18:45.289]                 for (kk in seq_along(NAMES)) {
[16:18:45.289]                   name <- changed[[kk]]
[16:18:45.289]                   NAME <- NAMES[[kk]]
[16:18:45.289]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.289]                     next
[16:18:45.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.289]                 }
[16:18:45.289]                 NAMES <- toupper(added)
[16:18:45.289]                 for (kk in seq_along(NAMES)) {
[16:18:45.289]                   name <- added[[kk]]
[16:18:45.289]                   NAME <- NAMES[[kk]]
[16:18:45.289]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.289]                     next
[16:18:45.289]                   args[[name]] <- ""
[16:18:45.289]                 }
[16:18:45.289]                 NAMES <- toupper(removed)
[16:18:45.289]                 for (kk in seq_along(NAMES)) {
[16:18:45.289]                   name <- removed[[kk]]
[16:18:45.289]                   NAME <- NAMES[[kk]]
[16:18:45.289]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.289]                     next
[16:18:45.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.289]                 }
[16:18:45.289]                 if (length(args) > 0) 
[16:18:45.289]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.289]             }
[16:18:45.289]             else {
[16:18:45.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.289]             }
[16:18:45.289]             {
[16:18:45.289]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.289]                   0L) {
[16:18:45.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.289]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.289]                   base::options(opts)
[16:18:45.289]                 }
[16:18:45.289]                 {
[16:18:45.289]                   {
[16:18:45.289]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.289]                     NULL
[16:18:45.289]                   }
[16:18:45.289]                   options(future.plan = NULL)
[16:18:45.289]                   if (is.na(NA_character_)) 
[16:18:45.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.289]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.289]                     .init = FALSE)
[16:18:45.289]                 }
[16:18:45.289]             }
[16:18:45.289]         }
[16:18:45.289]     })
[16:18:45.289]     if (TRUE) {
[16:18:45.289]         base::sink(type = "output", split = FALSE)
[16:18:45.289]         if (TRUE) {
[16:18:45.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.289]         }
[16:18:45.289]         else {
[16:18:45.289]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.289]         }
[16:18:45.289]         base::close(...future.stdout)
[16:18:45.289]         ...future.stdout <- NULL
[16:18:45.289]     }
[16:18:45.289]     ...future.result$conditions <- ...future.conditions
[16:18:45.289]     ...future.result$finished <- base::Sys.time()
[16:18:45.289]     ...future.result
[16:18:45.289] }
[16:18:45.292] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[16:18:45.292] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[16:18:45.293] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[16:18:45.293] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:45.293] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.293] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[16:18:45.294] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[16:18:45.294] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:45.294] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.294] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:45.294] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.295] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[16:18:45.298] MultisessionFuture started
[16:18:45.298] - Launch lazy future ... done
[16:18:45.298] run() for ‘MultisessionFuture’ ... done
[16:18:45.298] Created future:
[16:18:45.298] MultisessionFuture:
[16:18:45.298] Label: ‘future_mapply-2’
[16:18:45.298] Expression:
[16:18:45.298] {
[16:18:45.298]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.298]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.298]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.298]         on.exit(options(oopts), add = TRUE)
[16:18:45.298]     }
[16:18:45.298]     {
[16:18:45.298]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.298]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.298]         do.call(mapply, args = args)
[16:18:45.298]     }
[16:18:45.298] }
[16:18:45.298] Lazy evaluation: FALSE
[16:18:45.298] Asynchronous evaluation: TRUE
[16:18:45.298] Local evaluation: TRUE
[16:18:45.298] Environment: R_GlobalEnv
[16:18:45.298] Capture standard output: TRUE
[16:18:45.298] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.298] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.298] Packages: <none>
[16:18:45.298] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.298] Resolved: FALSE
[16:18:45.298] Value: <not collected>
[16:18:45.298] Conditions captured: <none>
[16:18:45.298] Early signaling: FALSE
[16:18:45.298] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.298] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.310] Chunk #2 of 5 ... DONE
[16:18:45.310] Chunk #3 of 5 ...
[16:18:45.310]  - Finding globals in '...' for chunk #3 ...
[16:18:45.310] getGlobalsAndPackages() ...
[16:18:45.310] Searching for globals...
[16:18:45.311] 
[16:18:45.311] Searching for globals ... DONE
[16:18:45.311] - globals: [0] <none>
[16:18:45.311] getGlobalsAndPackages() ... DONE
[16:18:45.311]    + additional globals found: [n=0] 
[16:18:45.311]    + additional namespaces needed: [n=0] 
[16:18:45.311]  - Finding globals in '...' for chunk #3 ... DONE
[16:18:45.311]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:45.311]  - seeds: <none>
[16:18:45.311]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.312] getGlobalsAndPackages() ...
[16:18:45.312] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.312] Resolving globals: FALSE
[16:18:45.312] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:45.313] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:45.313] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.313] 
[16:18:45.313] getGlobalsAndPackages() ... DONE
[16:18:45.314] run() for ‘Future’ ...
[16:18:45.314] - state: ‘created’
[16:18:45.314] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.328] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.328]   - Field: ‘node’
[16:18:45.328]   - Field: ‘label’
[16:18:45.328]   - Field: ‘local’
[16:18:45.328]   - Field: ‘owner’
[16:18:45.328]   - Field: ‘envir’
[16:18:45.328]   - Field: ‘workers’
[16:18:45.329]   - Field: ‘packages’
[16:18:45.329]   - Field: ‘gc’
[16:18:45.329]   - Field: ‘conditions’
[16:18:45.329]   - Field: ‘persistent’
[16:18:45.329]   - Field: ‘expr’
[16:18:45.329]   - Field: ‘uuid’
[16:18:45.329]   - Field: ‘seed’
[16:18:45.329]   - Field: ‘version’
[16:18:45.329]   - Field: ‘result’
[16:18:45.329]   - Field: ‘asynchronous’
[16:18:45.329]   - Field: ‘calls’
[16:18:45.330]   - Field: ‘globals’
[16:18:45.330]   - Field: ‘stdout’
[16:18:45.330]   - Field: ‘earlySignal’
[16:18:45.330]   - Field: ‘lazy’
[16:18:45.330]   - Field: ‘state’
[16:18:45.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.330] - Launch lazy future ...
[16:18:45.330] Packages needed by the future expression (n = 0): <none>
[16:18:45.331] Packages needed by future strategies (n = 0): <none>
[16:18:45.331] {
[16:18:45.331]     {
[16:18:45.331]         {
[16:18:45.331]             ...future.startTime <- base::Sys.time()
[16:18:45.331]             {
[16:18:45.331]                 {
[16:18:45.331]                   {
[16:18:45.331]                     {
[16:18:45.331]                       base::local({
[16:18:45.331]                         has_future <- base::requireNamespace("future", 
[16:18:45.331]                           quietly = TRUE)
[16:18:45.331]                         if (has_future) {
[16:18:45.331]                           ns <- base::getNamespace("future")
[16:18:45.331]                           version <- ns[[".package"]][["version"]]
[16:18:45.331]                           if (is.null(version)) 
[16:18:45.331]                             version <- utils::packageVersion("future")
[16:18:45.331]                         }
[16:18:45.331]                         else {
[16:18:45.331]                           version <- NULL
[16:18:45.331]                         }
[16:18:45.331]                         if (!has_future || version < "1.8.0") {
[16:18:45.331]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.331]                             "", base::R.version$version.string), 
[16:18:45.331]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.331]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.331]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.331]                               "release", "version")], collapse = " "), 
[16:18:45.331]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.331]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.331]                             info)
[16:18:45.331]                           info <- base::paste(info, collapse = "; ")
[16:18:45.331]                           if (!has_future) {
[16:18:45.331]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.331]                               info)
[16:18:45.331]                           }
[16:18:45.331]                           else {
[16:18:45.331]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.331]                               info, version)
[16:18:45.331]                           }
[16:18:45.331]                           base::stop(msg)
[16:18:45.331]                         }
[16:18:45.331]                       })
[16:18:45.331]                     }
[16:18:45.331]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.331]                     base::options(mc.cores = 1L)
[16:18:45.331]                   }
[16:18:45.331]                   ...future.strategy.old <- future::plan("list")
[16:18:45.331]                   options(future.plan = NULL)
[16:18:45.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.331]                 }
[16:18:45.331]                 ...future.workdir <- getwd()
[16:18:45.331]             }
[16:18:45.331]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.331]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.331]         }
[16:18:45.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.331]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:45.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.331]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.331]             base::names(...future.oldOptions))
[16:18:45.331]     }
[16:18:45.331]     if (FALSE) {
[16:18:45.331]     }
[16:18:45.331]     else {
[16:18:45.331]         if (TRUE) {
[16:18:45.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.331]                 open = "w")
[16:18:45.331]         }
[16:18:45.331]         else {
[16:18:45.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.331]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.331]         }
[16:18:45.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.331]             base::sink(type = "output", split = FALSE)
[16:18:45.331]             base::close(...future.stdout)
[16:18:45.331]         }, add = TRUE)
[16:18:45.331]     }
[16:18:45.331]     ...future.frame <- base::sys.nframe()
[16:18:45.331]     ...future.conditions <- base::list()
[16:18:45.331]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.331]     if (FALSE) {
[16:18:45.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.331]     }
[16:18:45.331]     ...future.result <- base::tryCatch({
[16:18:45.331]         base::withCallingHandlers({
[16:18:45.331]             ...future.value <- base::withVisible(base::local({
[16:18:45.331]                 ...future.makeSendCondition <- base::local({
[16:18:45.331]                   sendCondition <- NULL
[16:18:45.331]                   function(frame = 1L) {
[16:18:45.331]                     if (is.function(sendCondition)) 
[16:18:45.331]                       return(sendCondition)
[16:18:45.331]                     ns <- getNamespace("parallel")
[16:18:45.331]                     if (exists("sendData", mode = "function", 
[16:18:45.331]                       envir = ns)) {
[16:18:45.331]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.331]                         envir = ns)
[16:18:45.331]                       envir <- sys.frame(frame)
[16:18:45.331]                       master <- NULL
[16:18:45.331]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.331]                         !identical(envir, emptyenv())) {
[16:18:45.331]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.331]                           inherits = FALSE)) {
[16:18:45.331]                           master <- get("master", mode = "list", 
[16:18:45.331]                             envir = envir, inherits = FALSE)
[16:18:45.331]                           if (inherits(master, c("SOCKnode", 
[16:18:45.331]                             "SOCK0node"))) {
[16:18:45.331]                             sendCondition <<- function(cond) {
[16:18:45.331]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.331]                                 success = TRUE)
[16:18:45.331]                               parallel_sendData(master, data)
[16:18:45.331]                             }
[16:18:45.331]                             return(sendCondition)
[16:18:45.331]                           }
[16:18:45.331]                         }
[16:18:45.331]                         frame <- frame + 1L
[16:18:45.331]                         envir <- sys.frame(frame)
[16:18:45.331]                       }
[16:18:45.331]                     }
[16:18:45.331]                     sendCondition <<- function(cond) NULL
[16:18:45.331]                   }
[16:18:45.331]                 })
[16:18:45.331]                 withCallingHandlers({
[16:18:45.331]                   {
[16:18:45.331]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.331]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.331]                       ...future.globals.maxSize)) {
[16:18:45.331]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.331]                       on.exit(options(oopts), add = TRUE)
[16:18:45.331]                     }
[16:18:45.331]                     {
[16:18:45.331]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.331]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.331]                         USE.NAMES = FALSE)
[16:18:45.331]                       do.call(mapply, args = args)
[16:18:45.331]                     }
[16:18:45.331]                   }
[16:18:45.331]                 }, immediateCondition = function(cond) {
[16:18:45.331]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.331]                   sendCondition(cond)
[16:18:45.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.331]                   {
[16:18:45.331]                     inherits <- base::inherits
[16:18:45.331]                     invokeRestart <- base::invokeRestart
[16:18:45.331]                     is.null <- base::is.null
[16:18:45.331]                     muffled <- FALSE
[16:18:45.331]                     if (inherits(cond, "message")) {
[16:18:45.331]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.331]                       if (muffled) 
[16:18:45.331]                         invokeRestart("muffleMessage")
[16:18:45.331]                     }
[16:18:45.331]                     else if (inherits(cond, "warning")) {
[16:18:45.331]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.331]                       if (muffled) 
[16:18:45.331]                         invokeRestart("muffleWarning")
[16:18:45.331]                     }
[16:18:45.331]                     else if (inherits(cond, "condition")) {
[16:18:45.331]                       if (!is.null(pattern)) {
[16:18:45.331]                         computeRestarts <- base::computeRestarts
[16:18:45.331]                         grepl <- base::grepl
[16:18:45.331]                         restarts <- computeRestarts(cond)
[16:18:45.331]                         for (restart in restarts) {
[16:18:45.331]                           name <- restart$name
[16:18:45.331]                           if (is.null(name)) 
[16:18:45.331]                             next
[16:18:45.331]                           if (!grepl(pattern, name)) 
[16:18:45.331]                             next
[16:18:45.331]                           invokeRestart(restart)
[16:18:45.331]                           muffled <- TRUE
[16:18:45.331]                           break
[16:18:45.331]                         }
[16:18:45.331]                       }
[16:18:45.331]                     }
[16:18:45.331]                     invisible(muffled)
[16:18:45.331]                   }
[16:18:45.331]                   muffleCondition(cond)
[16:18:45.331]                 })
[16:18:45.331]             }))
[16:18:45.331]             future::FutureResult(value = ...future.value$value, 
[16:18:45.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.331]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.331]                     ...future.globalenv.names))
[16:18:45.331]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.331]         }, condition = base::local({
[16:18:45.331]             c <- base::c
[16:18:45.331]             inherits <- base::inherits
[16:18:45.331]             invokeRestart <- base::invokeRestart
[16:18:45.331]             length <- base::length
[16:18:45.331]             list <- base::list
[16:18:45.331]             seq.int <- base::seq.int
[16:18:45.331]             signalCondition <- base::signalCondition
[16:18:45.331]             sys.calls <- base::sys.calls
[16:18:45.331]             `[[` <- base::`[[`
[16:18:45.331]             `+` <- base::`+`
[16:18:45.331]             `<<-` <- base::`<<-`
[16:18:45.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.331]                   3L)]
[16:18:45.331]             }
[16:18:45.331]             function(cond) {
[16:18:45.331]                 is_error <- inherits(cond, "error")
[16:18:45.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.331]                   NULL)
[16:18:45.331]                 if (is_error) {
[16:18:45.331]                   sessionInformation <- function() {
[16:18:45.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.331]                       search = base::search(), system = base::Sys.info())
[16:18:45.331]                   }
[16:18:45.331]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.331]                     cond$call), session = sessionInformation(), 
[16:18:45.331]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.331]                   signalCondition(cond)
[16:18:45.331]                 }
[16:18:45.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.331]                 "immediateCondition"))) {
[16:18:45.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.331]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.331]                   if (TRUE && !signal) {
[16:18:45.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.331]                     {
[16:18:45.331]                       inherits <- base::inherits
[16:18:45.331]                       invokeRestart <- base::invokeRestart
[16:18:45.331]                       is.null <- base::is.null
[16:18:45.331]                       muffled <- FALSE
[16:18:45.331]                       if (inherits(cond, "message")) {
[16:18:45.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.331]                         if (muffled) 
[16:18:45.331]                           invokeRestart("muffleMessage")
[16:18:45.331]                       }
[16:18:45.331]                       else if (inherits(cond, "warning")) {
[16:18:45.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.331]                         if (muffled) 
[16:18:45.331]                           invokeRestart("muffleWarning")
[16:18:45.331]                       }
[16:18:45.331]                       else if (inherits(cond, "condition")) {
[16:18:45.331]                         if (!is.null(pattern)) {
[16:18:45.331]                           computeRestarts <- base::computeRestarts
[16:18:45.331]                           grepl <- base::grepl
[16:18:45.331]                           restarts <- computeRestarts(cond)
[16:18:45.331]                           for (restart in restarts) {
[16:18:45.331]                             name <- restart$name
[16:18:45.331]                             if (is.null(name)) 
[16:18:45.331]                               next
[16:18:45.331]                             if (!grepl(pattern, name)) 
[16:18:45.331]                               next
[16:18:45.331]                             invokeRestart(restart)
[16:18:45.331]                             muffled <- TRUE
[16:18:45.331]                             break
[16:18:45.331]                           }
[16:18:45.331]                         }
[16:18:45.331]                       }
[16:18:45.331]                       invisible(muffled)
[16:18:45.331]                     }
[16:18:45.331]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.331]                   }
[16:18:45.331]                 }
[16:18:45.331]                 else {
[16:18:45.331]                   if (TRUE) {
[16:18:45.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.331]                     {
[16:18:45.331]                       inherits <- base::inherits
[16:18:45.331]                       invokeRestart <- base::invokeRestart
[16:18:45.331]                       is.null <- base::is.null
[16:18:45.331]                       muffled <- FALSE
[16:18:45.331]                       if (inherits(cond, "message")) {
[16:18:45.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.331]                         if (muffled) 
[16:18:45.331]                           invokeRestart("muffleMessage")
[16:18:45.331]                       }
[16:18:45.331]                       else if (inherits(cond, "warning")) {
[16:18:45.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.331]                         if (muffled) 
[16:18:45.331]                           invokeRestart("muffleWarning")
[16:18:45.331]                       }
[16:18:45.331]                       else if (inherits(cond, "condition")) {
[16:18:45.331]                         if (!is.null(pattern)) {
[16:18:45.331]                           computeRestarts <- base::computeRestarts
[16:18:45.331]                           grepl <- base::grepl
[16:18:45.331]                           restarts <- computeRestarts(cond)
[16:18:45.331]                           for (restart in restarts) {
[16:18:45.331]                             name <- restart$name
[16:18:45.331]                             if (is.null(name)) 
[16:18:45.331]                               next
[16:18:45.331]                             if (!grepl(pattern, name)) 
[16:18:45.331]                               next
[16:18:45.331]                             invokeRestart(restart)
[16:18:45.331]                             muffled <- TRUE
[16:18:45.331]                             break
[16:18:45.331]                           }
[16:18:45.331]                         }
[16:18:45.331]                       }
[16:18:45.331]                       invisible(muffled)
[16:18:45.331]                     }
[16:18:45.331]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.331]                   }
[16:18:45.331]                 }
[16:18:45.331]             }
[16:18:45.331]         }))
[16:18:45.331]     }, error = function(ex) {
[16:18:45.331]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.331]                 ...future.rng), started = ...future.startTime, 
[16:18:45.331]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.331]             version = "1.8"), class = "FutureResult")
[16:18:45.331]     }, finally = {
[16:18:45.331]         if (!identical(...future.workdir, getwd())) 
[16:18:45.331]             setwd(...future.workdir)
[16:18:45.331]         {
[16:18:45.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.331]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.331]             }
[16:18:45.331]             base::options(...future.oldOptions)
[16:18:45.331]             if (.Platform$OS.type == "windows") {
[16:18:45.331]                 old_names <- names(...future.oldEnvVars)
[16:18:45.331]                 envs <- base::Sys.getenv()
[16:18:45.331]                 names <- names(envs)
[16:18:45.331]                 common <- intersect(names, old_names)
[16:18:45.331]                 added <- setdiff(names, old_names)
[16:18:45.331]                 removed <- setdiff(old_names, names)
[16:18:45.331]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.331]                   envs[common]]
[16:18:45.331]                 NAMES <- toupper(changed)
[16:18:45.331]                 args <- list()
[16:18:45.331]                 for (kk in seq_along(NAMES)) {
[16:18:45.331]                   name <- changed[[kk]]
[16:18:45.331]                   NAME <- NAMES[[kk]]
[16:18:45.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.331]                     next
[16:18:45.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.331]                 }
[16:18:45.331]                 NAMES <- toupper(added)
[16:18:45.331]                 for (kk in seq_along(NAMES)) {
[16:18:45.331]                   name <- added[[kk]]
[16:18:45.331]                   NAME <- NAMES[[kk]]
[16:18:45.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.331]                     next
[16:18:45.331]                   args[[name]] <- ""
[16:18:45.331]                 }
[16:18:45.331]                 NAMES <- toupper(removed)
[16:18:45.331]                 for (kk in seq_along(NAMES)) {
[16:18:45.331]                   name <- removed[[kk]]
[16:18:45.331]                   NAME <- NAMES[[kk]]
[16:18:45.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.331]                     next
[16:18:45.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.331]                 }
[16:18:45.331]                 if (length(args) > 0) 
[16:18:45.331]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.331]             }
[16:18:45.331]             else {
[16:18:45.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.331]             }
[16:18:45.331]             {
[16:18:45.331]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.331]                   0L) {
[16:18:45.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.331]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.331]                   base::options(opts)
[16:18:45.331]                 }
[16:18:45.331]                 {
[16:18:45.331]                   {
[16:18:45.331]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.331]                     NULL
[16:18:45.331]                   }
[16:18:45.331]                   options(future.plan = NULL)
[16:18:45.331]                   if (is.na(NA_character_)) 
[16:18:45.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.331]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.331]                     .init = FALSE)
[16:18:45.331]                 }
[16:18:45.331]             }
[16:18:45.331]         }
[16:18:45.331]     })
[16:18:45.331]     if (TRUE) {
[16:18:45.331]         base::sink(type = "output", split = FALSE)
[16:18:45.331]         if (TRUE) {
[16:18:45.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.331]         }
[16:18:45.331]         else {
[16:18:45.331]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.331]         }
[16:18:45.331]         base::close(...future.stdout)
[16:18:45.331]         ...future.stdout <- NULL
[16:18:45.331]     }
[16:18:45.331]     ...future.result$conditions <- ...future.conditions
[16:18:45.331]     ...future.result$finished <- base::Sys.time()
[16:18:45.331]     ...future.result
[16:18:45.331] }
[16:18:45.333] Poll #1 (0): usedNodes() = 2, workers = 2
[16:18:45.344] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.344] - Validating connection of MultisessionFuture
[16:18:45.344] - received message: FutureResult
[16:18:45.345] - Received FutureResult
[16:18:45.345] - Erased future from FutureRegistry
[16:18:45.345] result() for ClusterFuture ...
[16:18:45.345] - result already collected: FutureResult
[16:18:45.345] result() for ClusterFuture ... done
[16:18:45.345] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.345] result() for ClusterFuture ...
[16:18:45.345] - result already collected: FutureResult
[16:18:45.345] result() for ClusterFuture ... done
[16:18:45.346] result() for ClusterFuture ...
[16:18:45.346] - result already collected: FutureResult
[16:18:45.346] result() for ClusterFuture ... done
[16:18:45.346] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[16:18:45.347] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[16:18:45.347] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[16:18:45.347] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:45.347] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.348] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[16:18:45.348] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[16:18:45.348] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:45.348] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.348] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:45.349] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.349] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[16:18:45.349] MultisessionFuture started
[16:18:45.349] - Launch lazy future ... done
[16:18:45.350] run() for ‘MultisessionFuture’ ... done
[16:18:45.350] Created future:
[16:18:45.350] MultisessionFuture:
[16:18:45.350] Label: ‘future_mapply-3’
[16:18:45.350] Expression:
[16:18:45.350] {
[16:18:45.350]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.350]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.350]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.350]         on.exit(options(oopts), add = TRUE)
[16:18:45.350]     }
[16:18:45.350]     {
[16:18:45.350]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.350]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.350]         do.call(mapply, args = args)
[16:18:45.350]     }
[16:18:45.350] }
[16:18:45.350] Lazy evaluation: FALSE
[16:18:45.350] Asynchronous evaluation: TRUE
[16:18:45.350] Local evaluation: TRUE
[16:18:45.350] Environment: R_GlobalEnv
[16:18:45.350] Capture standard output: TRUE
[16:18:45.350] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.350] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.350] Packages: <none>
[16:18:45.350] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.350] Resolved: FALSE
[16:18:45.350] Value: <not collected>
[16:18:45.350] Conditions captured: <none>
[16:18:45.350] Early signaling: FALSE
[16:18:45.350] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.350] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.361] Chunk #3 of 5 ... DONE
[16:18:45.361] Chunk #4 of 5 ...
[16:18:45.362]  - Finding globals in '...' for chunk #4 ...
[16:18:45.362] getGlobalsAndPackages() ...
[16:18:45.362] Searching for globals...
[16:18:45.362] 
[16:18:45.362] Searching for globals ... DONE
[16:18:45.362] - globals: [0] <none>
[16:18:45.362] getGlobalsAndPackages() ... DONE
[16:18:45.362]    + additional globals found: [n=0] 
[16:18:45.363]    + additional namespaces needed: [n=0] 
[16:18:45.363]  - Finding globals in '...' for chunk #4 ... DONE
[16:18:45.363]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:45.363]  - seeds: <none>
[16:18:45.363]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.363] getGlobalsAndPackages() ...
[16:18:45.363] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.363] Resolving globals: FALSE
[16:18:45.364] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:45.364] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:45.364] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.364] 
[16:18:45.364] getGlobalsAndPackages() ... DONE
[16:18:45.365] run() for ‘Future’ ...
[16:18:45.365] - state: ‘created’
[16:18:45.365] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.379] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.379]   - Field: ‘node’
[16:18:45.379]   - Field: ‘label’
[16:18:45.379]   - Field: ‘local’
[16:18:45.379]   - Field: ‘owner’
[16:18:45.379]   - Field: ‘envir’
[16:18:45.380]   - Field: ‘workers’
[16:18:45.380]   - Field: ‘packages’
[16:18:45.380]   - Field: ‘gc’
[16:18:45.380]   - Field: ‘conditions’
[16:18:45.380]   - Field: ‘persistent’
[16:18:45.380]   - Field: ‘expr’
[16:18:45.380]   - Field: ‘uuid’
[16:18:45.380]   - Field: ‘seed’
[16:18:45.380]   - Field: ‘version’
[16:18:45.380]   - Field: ‘result’
[16:18:45.380]   - Field: ‘asynchronous’
[16:18:45.381]   - Field: ‘calls’
[16:18:45.381]   - Field: ‘globals’
[16:18:45.381]   - Field: ‘stdout’
[16:18:45.381]   - Field: ‘earlySignal’
[16:18:45.381]   - Field: ‘lazy’
[16:18:45.381]   - Field: ‘state’
[16:18:45.381] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.381] - Launch lazy future ...
[16:18:45.381] Packages needed by the future expression (n = 0): <none>
[16:18:45.382] Packages needed by future strategies (n = 0): <none>
[16:18:45.382] {
[16:18:45.382]     {
[16:18:45.382]         {
[16:18:45.382]             ...future.startTime <- base::Sys.time()
[16:18:45.382]             {
[16:18:45.382]                 {
[16:18:45.382]                   {
[16:18:45.382]                     {
[16:18:45.382]                       base::local({
[16:18:45.382]                         has_future <- base::requireNamespace("future", 
[16:18:45.382]                           quietly = TRUE)
[16:18:45.382]                         if (has_future) {
[16:18:45.382]                           ns <- base::getNamespace("future")
[16:18:45.382]                           version <- ns[[".package"]][["version"]]
[16:18:45.382]                           if (is.null(version)) 
[16:18:45.382]                             version <- utils::packageVersion("future")
[16:18:45.382]                         }
[16:18:45.382]                         else {
[16:18:45.382]                           version <- NULL
[16:18:45.382]                         }
[16:18:45.382]                         if (!has_future || version < "1.8.0") {
[16:18:45.382]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.382]                             "", base::R.version$version.string), 
[16:18:45.382]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.382]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.382]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.382]                               "release", "version")], collapse = " "), 
[16:18:45.382]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.382]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.382]                             info)
[16:18:45.382]                           info <- base::paste(info, collapse = "; ")
[16:18:45.382]                           if (!has_future) {
[16:18:45.382]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.382]                               info)
[16:18:45.382]                           }
[16:18:45.382]                           else {
[16:18:45.382]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.382]                               info, version)
[16:18:45.382]                           }
[16:18:45.382]                           base::stop(msg)
[16:18:45.382]                         }
[16:18:45.382]                       })
[16:18:45.382]                     }
[16:18:45.382]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.382]                     base::options(mc.cores = 1L)
[16:18:45.382]                   }
[16:18:45.382]                   ...future.strategy.old <- future::plan("list")
[16:18:45.382]                   options(future.plan = NULL)
[16:18:45.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.382]                 }
[16:18:45.382]                 ...future.workdir <- getwd()
[16:18:45.382]             }
[16:18:45.382]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.382]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.382]         }
[16:18:45.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.382]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:45.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.382]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.382]             base::names(...future.oldOptions))
[16:18:45.382]     }
[16:18:45.382]     if (FALSE) {
[16:18:45.382]     }
[16:18:45.382]     else {
[16:18:45.382]         if (TRUE) {
[16:18:45.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.382]                 open = "w")
[16:18:45.382]         }
[16:18:45.382]         else {
[16:18:45.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.382]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.382]         }
[16:18:45.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.382]             base::sink(type = "output", split = FALSE)
[16:18:45.382]             base::close(...future.stdout)
[16:18:45.382]         }, add = TRUE)
[16:18:45.382]     }
[16:18:45.382]     ...future.frame <- base::sys.nframe()
[16:18:45.382]     ...future.conditions <- base::list()
[16:18:45.382]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.382]     if (FALSE) {
[16:18:45.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.382]     }
[16:18:45.382]     ...future.result <- base::tryCatch({
[16:18:45.382]         base::withCallingHandlers({
[16:18:45.382]             ...future.value <- base::withVisible(base::local({
[16:18:45.382]                 ...future.makeSendCondition <- base::local({
[16:18:45.382]                   sendCondition <- NULL
[16:18:45.382]                   function(frame = 1L) {
[16:18:45.382]                     if (is.function(sendCondition)) 
[16:18:45.382]                       return(sendCondition)
[16:18:45.382]                     ns <- getNamespace("parallel")
[16:18:45.382]                     if (exists("sendData", mode = "function", 
[16:18:45.382]                       envir = ns)) {
[16:18:45.382]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.382]                         envir = ns)
[16:18:45.382]                       envir <- sys.frame(frame)
[16:18:45.382]                       master <- NULL
[16:18:45.382]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.382]                         !identical(envir, emptyenv())) {
[16:18:45.382]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.382]                           inherits = FALSE)) {
[16:18:45.382]                           master <- get("master", mode = "list", 
[16:18:45.382]                             envir = envir, inherits = FALSE)
[16:18:45.382]                           if (inherits(master, c("SOCKnode", 
[16:18:45.382]                             "SOCK0node"))) {
[16:18:45.382]                             sendCondition <<- function(cond) {
[16:18:45.382]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.382]                                 success = TRUE)
[16:18:45.382]                               parallel_sendData(master, data)
[16:18:45.382]                             }
[16:18:45.382]                             return(sendCondition)
[16:18:45.382]                           }
[16:18:45.382]                         }
[16:18:45.382]                         frame <- frame + 1L
[16:18:45.382]                         envir <- sys.frame(frame)
[16:18:45.382]                       }
[16:18:45.382]                     }
[16:18:45.382]                     sendCondition <<- function(cond) NULL
[16:18:45.382]                   }
[16:18:45.382]                 })
[16:18:45.382]                 withCallingHandlers({
[16:18:45.382]                   {
[16:18:45.382]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.382]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.382]                       ...future.globals.maxSize)) {
[16:18:45.382]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.382]                       on.exit(options(oopts), add = TRUE)
[16:18:45.382]                     }
[16:18:45.382]                     {
[16:18:45.382]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.382]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.382]                         USE.NAMES = FALSE)
[16:18:45.382]                       do.call(mapply, args = args)
[16:18:45.382]                     }
[16:18:45.382]                   }
[16:18:45.382]                 }, immediateCondition = function(cond) {
[16:18:45.382]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.382]                   sendCondition(cond)
[16:18:45.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.382]                   {
[16:18:45.382]                     inherits <- base::inherits
[16:18:45.382]                     invokeRestart <- base::invokeRestart
[16:18:45.382]                     is.null <- base::is.null
[16:18:45.382]                     muffled <- FALSE
[16:18:45.382]                     if (inherits(cond, "message")) {
[16:18:45.382]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.382]                       if (muffled) 
[16:18:45.382]                         invokeRestart("muffleMessage")
[16:18:45.382]                     }
[16:18:45.382]                     else if (inherits(cond, "warning")) {
[16:18:45.382]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.382]                       if (muffled) 
[16:18:45.382]                         invokeRestart("muffleWarning")
[16:18:45.382]                     }
[16:18:45.382]                     else if (inherits(cond, "condition")) {
[16:18:45.382]                       if (!is.null(pattern)) {
[16:18:45.382]                         computeRestarts <- base::computeRestarts
[16:18:45.382]                         grepl <- base::grepl
[16:18:45.382]                         restarts <- computeRestarts(cond)
[16:18:45.382]                         for (restart in restarts) {
[16:18:45.382]                           name <- restart$name
[16:18:45.382]                           if (is.null(name)) 
[16:18:45.382]                             next
[16:18:45.382]                           if (!grepl(pattern, name)) 
[16:18:45.382]                             next
[16:18:45.382]                           invokeRestart(restart)
[16:18:45.382]                           muffled <- TRUE
[16:18:45.382]                           break
[16:18:45.382]                         }
[16:18:45.382]                       }
[16:18:45.382]                     }
[16:18:45.382]                     invisible(muffled)
[16:18:45.382]                   }
[16:18:45.382]                   muffleCondition(cond)
[16:18:45.382]                 })
[16:18:45.382]             }))
[16:18:45.382]             future::FutureResult(value = ...future.value$value, 
[16:18:45.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.382]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.382]                     ...future.globalenv.names))
[16:18:45.382]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.382]         }, condition = base::local({
[16:18:45.382]             c <- base::c
[16:18:45.382]             inherits <- base::inherits
[16:18:45.382]             invokeRestart <- base::invokeRestart
[16:18:45.382]             length <- base::length
[16:18:45.382]             list <- base::list
[16:18:45.382]             seq.int <- base::seq.int
[16:18:45.382]             signalCondition <- base::signalCondition
[16:18:45.382]             sys.calls <- base::sys.calls
[16:18:45.382]             `[[` <- base::`[[`
[16:18:45.382]             `+` <- base::`+`
[16:18:45.382]             `<<-` <- base::`<<-`
[16:18:45.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.382]                   3L)]
[16:18:45.382]             }
[16:18:45.382]             function(cond) {
[16:18:45.382]                 is_error <- inherits(cond, "error")
[16:18:45.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.382]                   NULL)
[16:18:45.382]                 if (is_error) {
[16:18:45.382]                   sessionInformation <- function() {
[16:18:45.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.382]                       search = base::search(), system = base::Sys.info())
[16:18:45.382]                   }
[16:18:45.382]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.382]                     cond$call), session = sessionInformation(), 
[16:18:45.382]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.382]                   signalCondition(cond)
[16:18:45.382]                 }
[16:18:45.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.382]                 "immediateCondition"))) {
[16:18:45.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.382]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.382]                   if (TRUE && !signal) {
[16:18:45.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.382]                     {
[16:18:45.382]                       inherits <- base::inherits
[16:18:45.382]                       invokeRestart <- base::invokeRestart
[16:18:45.382]                       is.null <- base::is.null
[16:18:45.382]                       muffled <- FALSE
[16:18:45.382]                       if (inherits(cond, "message")) {
[16:18:45.382]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.382]                         if (muffled) 
[16:18:45.382]                           invokeRestart("muffleMessage")
[16:18:45.382]                       }
[16:18:45.382]                       else if (inherits(cond, "warning")) {
[16:18:45.382]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.382]                         if (muffled) 
[16:18:45.382]                           invokeRestart("muffleWarning")
[16:18:45.382]                       }
[16:18:45.382]                       else if (inherits(cond, "condition")) {
[16:18:45.382]                         if (!is.null(pattern)) {
[16:18:45.382]                           computeRestarts <- base::computeRestarts
[16:18:45.382]                           grepl <- base::grepl
[16:18:45.382]                           restarts <- computeRestarts(cond)
[16:18:45.382]                           for (restart in restarts) {
[16:18:45.382]                             name <- restart$name
[16:18:45.382]                             if (is.null(name)) 
[16:18:45.382]                               next
[16:18:45.382]                             if (!grepl(pattern, name)) 
[16:18:45.382]                               next
[16:18:45.382]                             invokeRestart(restart)
[16:18:45.382]                             muffled <- TRUE
[16:18:45.382]                             break
[16:18:45.382]                           }
[16:18:45.382]                         }
[16:18:45.382]                       }
[16:18:45.382]                       invisible(muffled)
[16:18:45.382]                     }
[16:18:45.382]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.382]                   }
[16:18:45.382]                 }
[16:18:45.382]                 else {
[16:18:45.382]                   if (TRUE) {
[16:18:45.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.382]                     {
[16:18:45.382]                       inherits <- base::inherits
[16:18:45.382]                       invokeRestart <- base::invokeRestart
[16:18:45.382]                       is.null <- base::is.null
[16:18:45.382]                       muffled <- FALSE
[16:18:45.382]                       if (inherits(cond, "message")) {
[16:18:45.382]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.382]                         if (muffled) 
[16:18:45.382]                           invokeRestart("muffleMessage")
[16:18:45.382]                       }
[16:18:45.382]                       else if (inherits(cond, "warning")) {
[16:18:45.382]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.382]                         if (muffled) 
[16:18:45.382]                           invokeRestart("muffleWarning")
[16:18:45.382]                       }
[16:18:45.382]                       else if (inherits(cond, "condition")) {
[16:18:45.382]                         if (!is.null(pattern)) {
[16:18:45.382]                           computeRestarts <- base::computeRestarts
[16:18:45.382]                           grepl <- base::grepl
[16:18:45.382]                           restarts <- computeRestarts(cond)
[16:18:45.382]                           for (restart in restarts) {
[16:18:45.382]                             name <- restart$name
[16:18:45.382]                             if (is.null(name)) 
[16:18:45.382]                               next
[16:18:45.382]                             if (!grepl(pattern, name)) 
[16:18:45.382]                               next
[16:18:45.382]                             invokeRestart(restart)
[16:18:45.382]                             muffled <- TRUE
[16:18:45.382]                             break
[16:18:45.382]                           }
[16:18:45.382]                         }
[16:18:45.382]                       }
[16:18:45.382]                       invisible(muffled)
[16:18:45.382]                     }
[16:18:45.382]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.382]                   }
[16:18:45.382]                 }
[16:18:45.382]             }
[16:18:45.382]         }))
[16:18:45.382]     }, error = function(ex) {
[16:18:45.382]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.382]                 ...future.rng), started = ...future.startTime, 
[16:18:45.382]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.382]             version = "1.8"), class = "FutureResult")
[16:18:45.382]     }, finally = {
[16:18:45.382]         if (!identical(...future.workdir, getwd())) 
[16:18:45.382]             setwd(...future.workdir)
[16:18:45.382]         {
[16:18:45.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.382]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.382]             }
[16:18:45.382]             base::options(...future.oldOptions)
[16:18:45.382]             if (.Platform$OS.type == "windows") {
[16:18:45.382]                 old_names <- names(...future.oldEnvVars)
[16:18:45.382]                 envs <- base::Sys.getenv()
[16:18:45.382]                 names <- names(envs)
[16:18:45.382]                 common <- intersect(names, old_names)
[16:18:45.382]                 added <- setdiff(names, old_names)
[16:18:45.382]                 removed <- setdiff(old_names, names)
[16:18:45.382]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.382]                   envs[common]]
[16:18:45.382]                 NAMES <- toupper(changed)
[16:18:45.382]                 args <- list()
[16:18:45.382]                 for (kk in seq_along(NAMES)) {
[16:18:45.382]                   name <- changed[[kk]]
[16:18:45.382]                   NAME <- NAMES[[kk]]
[16:18:45.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.382]                     next
[16:18:45.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.382]                 }
[16:18:45.382]                 NAMES <- toupper(added)
[16:18:45.382]                 for (kk in seq_along(NAMES)) {
[16:18:45.382]                   name <- added[[kk]]
[16:18:45.382]                   NAME <- NAMES[[kk]]
[16:18:45.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.382]                     next
[16:18:45.382]                   args[[name]] <- ""
[16:18:45.382]                 }
[16:18:45.382]                 NAMES <- toupper(removed)
[16:18:45.382]                 for (kk in seq_along(NAMES)) {
[16:18:45.382]                   name <- removed[[kk]]
[16:18:45.382]                   NAME <- NAMES[[kk]]
[16:18:45.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.382]                     next
[16:18:45.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.382]                 }
[16:18:45.382]                 if (length(args) > 0) 
[16:18:45.382]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.382]             }
[16:18:45.382]             else {
[16:18:45.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.382]             }
[16:18:45.382]             {
[16:18:45.382]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.382]                   0L) {
[16:18:45.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.382]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.382]                   base::options(opts)
[16:18:45.382]                 }
[16:18:45.382]                 {
[16:18:45.382]                   {
[16:18:45.382]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.382]                     NULL
[16:18:45.382]                   }
[16:18:45.382]                   options(future.plan = NULL)
[16:18:45.382]                   if (is.na(NA_character_)) 
[16:18:45.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.382]                     .init = FALSE)
[16:18:45.382]                 }
[16:18:45.382]             }
[16:18:45.382]         }
[16:18:45.382]     })
[16:18:45.382]     if (TRUE) {
[16:18:45.382]         base::sink(type = "output", split = FALSE)
[16:18:45.382]         if (TRUE) {
[16:18:45.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.382]         }
[16:18:45.382]         else {
[16:18:45.382]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.382]         }
[16:18:45.382]         base::close(...future.stdout)
[16:18:45.382]         ...future.stdout <- NULL
[16:18:45.382]     }
[16:18:45.382]     ...future.result$conditions <- ...future.conditions
[16:18:45.382]     ...future.result$finished <- base::Sys.time()
[16:18:45.382]     ...future.result
[16:18:45.382] }
[16:18:45.384] Poll #1 (0): usedNodes() = 2, workers = 2
[16:18:45.395] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.395] - Validating connection of MultisessionFuture
[16:18:45.395] - received message: FutureResult
[16:18:45.395] - Received FutureResult
[16:18:45.396] - Erased future from FutureRegistry
[16:18:45.396] result() for ClusterFuture ...
[16:18:45.396] - result already collected: FutureResult
[16:18:45.396] result() for ClusterFuture ... done
[16:18:45.396] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.396] result() for ClusterFuture ...
[16:18:45.396] - result already collected: FutureResult
[16:18:45.396] result() for ClusterFuture ... done
[16:18:45.396] result() for ClusterFuture ...
[16:18:45.396] - result already collected: FutureResult
[16:18:45.397] result() for ClusterFuture ... done
[16:18:45.397] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[16:18:45.397] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[16:18:45.398] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[16:18:45.398] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:45.398] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.398] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[16:18:45.399] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[16:18:45.399] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:45.399] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.399] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:45.399] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.400] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[16:18:45.400] MultisessionFuture started
[16:18:45.400] - Launch lazy future ... done
[16:18:45.400] run() for ‘MultisessionFuture’ ... done
[16:18:45.400] Created future:
[16:18:45.400] MultisessionFuture:
[16:18:45.400] Label: ‘future_mapply-4’
[16:18:45.400] Expression:
[16:18:45.400] {
[16:18:45.400]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.400]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.400]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.400]         on.exit(options(oopts), add = TRUE)
[16:18:45.400]     }
[16:18:45.400]     {
[16:18:45.400]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.400]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.400]         do.call(mapply, args = args)
[16:18:45.400]     }
[16:18:45.400] }
[16:18:45.400] Lazy evaluation: FALSE
[16:18:45.400] Asynchronous evaluation: TRUE
[16:18:45.400] Local evaluation: TRUE
[16:18:45.400] Environment: R_GlobalEnv
[16:18:45.400] Capture standard output: TRUE
[16:18:45.400] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.400] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.400] Packages: <none>
[16:18:45.400] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.400] Resolved: FALSE
[16:18:45.400] Value: <not collected>
[16:18:45.400] Conditions captured: <none>
[16:18:45.400] Early signaling: FALSE
[16:18:45.400] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.400] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.412] Chunk #4 of 5 ... DONE
[16:18:45.412] Chunk #5 of 5 ...
[16:18:45.412]  - Finding globals in '...' for chunk #5 ...
[16:18:45.412] getGlobalsAndPackages() ...
[16:18:45.412] Searching for globals...
[16:18:45.413] 
[16:18:45.413] Searching for globals ... DONE
[16:18:45.413] - globals: [0] <none>
[16:18:45.413] getGlobalsAndPackages() ... DONE
[16:18:45.413]    + additional globals found: [n=0] 
[16:18:45.413]    + additional namespaces needed: [n=0] 
[16:18:45.413]  - Finding globals in '...' for chunk #5 ... DONE
[16:18:45.413]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:18:45.414]  - seeds: <none>
[16:18:45.414]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.414] getGlobalsAndPackages() ...
[16:18:45.414] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.414] Resolving globals: FALSE
[16:18:45.414] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:45.415] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:45.415] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.415] 
[16:18:45.415] getGlobalsAndPackages() ... DONE
[16:18:45.415] run() for ‘Future’ ...
[16:18:45.416] - state: ‘created’
[16:18:45.416] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.429] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.430]   - Field: ‘node’
[16:18:45.430]   - Field: ‘label’
[16:18:45.430]   - Field: ‘local’
[16:18:45.430]   - Field: ‘owner’
[16:18:45.430]   - Field: ‘envir’
[16:18:45.430]   - Field: ‘workers’
[16:18:45.430]   - Field: ‘packages’
[16:18:45.430]   - Field: ‘gc’
[16:18:45.430]   - Field: ‘conditions’
[16:18:45.430]   - Field: ‘persistent’
[16:18:45.430]   - Field: ‘expr’
[16:18:45.431]   - Field: ‘uuid’
[16:18:45.431]   - Field: ‘seed’
[16:18:45.431]   - Field: ‘version’
[16:18:45.431]   - Field: ‘result’
[16:18:45.431]   - Field: ‘asynchronous’
[16:18:45.431]   - Field: ‘calls’
[16:18:45.431]   - Field: ‘globals’
[16:18:45.431]   - Field: ‘stdout’
[16:18:45.431]   - Field: ‘earlySignal’
[16:18:45.431]   - Field: ‘lazy’
[16:18:45.431]   - Field: ‘state’
[16:18:45.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.432] - Launch lazy future ...
[16:18:45.432] Packages needed by the future expression (n = 0): <none>
[16:18:45.432] Packages needed by future strategies (n = 0): <none>
[16:18:45.432] {
[16:18:45.432]     {
[16:18:45.432]         {
[16:18:45.432]             ...future.startTime <- base::Sys.time()
[16:18:45.432]             {
[16:18:45.432]                 {
[16:18:45.432]                   {
[16:18:45.432]                     {
[16:18:45.432]                       base::local({
[16:18:45.432]                         has_future <- base::requireNamespace("future", 
[16:18:45.432]                           quietly = TRUE)
[16:18:45.432]                         if (has_future) {
[16:18:45.432]                           ns <- base::getNamespace("future")
[16:18:45.432]                           version <- ns[[".package"]][["version"]]
[16:18:45.432]                           if (is.null(version)) 
[16:18:45.432]                             version <- utils::packageVersion("future")
[16:18:45.432]                         }
[16:18:45.432]                         else {
[16:18:45.432]                           version <- NULL
[16:18:45.432]                         }
[16:18:45.432]                         if (!has_future || version < "1.8.0") {
[16:18:45.432]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.432]                             "", base::R.version$version.string), 
[16:18:45.432]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.432]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.432]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.432]                               "release", "version")], collapse = " "), 
[16:18:45.432]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.432]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.432]                             info)
[16:18:45.432]                           info <- base::paste(info, collapse = "; ")
[16:18:45.432]                           if (!has_future) {
[16:18:45.432]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.432]                               info)
[16:18:45.432]                           }
[16:18:45.432]                           else {
[16:18:45.432]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.432]                               info, version)
[16:18:45.432]                           }
[16:18:45.432]                           base::stop(msg)
[16:18:45.432]                         }
[16:18:45.432]                       })
[16:18:45.432]                     }
[16:18:45.432]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.432]                     base::options(mc.cores = 1L)
[16:18:45.432]                   }
[16:18:45.432]                   ...future.strategy.old <- future::plan("list")
[16:18:45.432]                   options(future.plan = NULL)
[16:18:45.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.432]                 }
[16:18:45.432]                 ...future.workdir <- getwd()
[16:18:45.432]             }
[16:18:45.432]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.432]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.432]         }
[16:18:45.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.432]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:18:45.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.432]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.432]             base::names(...future.oldOptions))
[16:18:45.432]     }
[16:18:45.432]     if (FALSE) {
[16:18:45.432]     }
[16:18:45.432]     else {
[16:18:45.432]         if (TRUE) {
[16:18:45.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.432]                 open = "w")
[16:18:45.432]         }
[16:18:45.432]         else {
[16:18:45.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.432]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.432]         }
[16:18:45.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.432]             base::sink(type = "output", split = FALSE)
[16:18:45.432]             base::close(...future.stdout)
[16:18:45.432]         }, add = TRUE)
[16:18:45.432]     }
[16:18:45.432]     ...future.frame <- base::sys.nframe()
[16:18:45.432]     ...future.conditions <- base::list()
[16:18:45.432]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.432]     if (FALSE) {
[16:18:45.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.432]     }
[16:18:45.432]     ...future.result <- base::tryCatch({
[16:18:45.432]         base::withCallingHandlers({
[16:18:45.432]             ...future.value <- base::withVisible(base::local({
[16:18:45.432]                 ...future.makeSendCondition <- base::local({
[16:18:45.432]                   sendCondition <- NULL
[16:18:45.432]                   function(frame = 1L) {
[16:18:45.432]                     if (is.function(sendCondition)) 
[16:18:45.432]                       return(sendCondition)
[16:18:45.432]                     ns <- getNamespace("parallel")
[16:18:45.432]                     if (exists("sendData", mode = "function", 
[16:18:45.432]                       envir = ns)) {
[16:18:45.432]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.432]                         envir = ns)
[16:18:45.432]                       envir <- sys.frame(frame)
[16:18:45.432]                       master <- NULL
[16:18:45.432]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.432]                         !identical(envir, emptyenv())) {
[16:18:45.432]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.432]                           inherits = FALSE)) {
[16:18:45.432]                           master <- get("master", mode = "list", 
[16:18:45.432]                             envir = envir, inherits = FALSE)
[16:18:45.432]                           if (inherits(master, c("SOCKnode", 
[16:18:45.432]                             "SOCK0node"))) {
[16:18:45.432]                             sendCondition <<- function(cond) {
[16:18:45.432]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.432]                                 success = TRUE)
[16:18:45.432]                               parallel_sendData(master, data)
[16:18:45.432]                             }
[16:18:45.432]                             return(sendCondition)
[16:18:45.432]                           }
[16:18:45.432]                         }
[16:18:45.432]                         frame <- frame + 1L
[16:18:45.432]                         envir <- sys.frame(frame)
[16:18:45.432]                       }
[16:18:45.432]                     }
[16:18:45.432]                     sendCondition <<- function(cond) NULL
[16:18:45.432]                   }
[16:18:45.432]                 })
[16:18:45.432]                 withCallingHandlers({
[16:18:45.432]                   {
[16:18:45.432]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.432]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.432]                       ...future.globals.maxSize)) {
[16:18:45.432]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.432]                       on.exit(options(oopts), add = TRUE)
[16:18:45.432]                     }
[16:18:45.432]                     {
[16:18:45.432]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.432]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.432]                         USE.NAMES = FALSE)
[16:18:45.432]                       do.call(mapply, args = args)
[16:18:45.432]                     }
[16:18:45.432]                   }
[16:18:45.432]                 }, immediateCondition = function(cond) {
[16:18:45.432]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.432]                   sendCondition(cond)
[16:18:45.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.432]                   {
[16:18:45.432]                     inherits <- base::inherits
[16:18:45.432]                     invokeRestart <- base::invokeRestart
[16:18:45.432]                     is.null <- base::is.null
[16:18:45.432]                     muffled <- FALSE
[16:18:45.432]                     if (inherits(cond, "message")) {
[16:18:45.432]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.432]                       if (muffled) 
[16:18:45.432]                         invokeRestart("muffleMessage")
[16:18:45.432]                     }
[16:18:45.432]                     else if (inherits(cond, "warning")) {
[16:18:45.432]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.432]                       if (muffled) 
[16:18:45.432]                         invokeRestart("muffleWarning")
[16:18:45.432]                     }
[16:18:45.432]                     else if (inherits(cond, "condition")) {
[16:18:45.432]                       if (!is.null(pattern)) {
[16:18:45.432]                         computeRestarts <- base::computeRestarts
[16:18:45.432]                         grepl <- base::grepl
[16:18:45.432]                         restarts <- computeRestarts(cond)
[16:18:45.432]                         for (restart in restarts) {
[16:18:45.432]                           name <- restart$name
[16:18:45.432]                           if (is.null(name)) 
[16:18:45.432]                             next
[16:18:45.432]                           if (!grepl(pattern, name)) 
[16:18:45.432]                             next
[16:18:45.432]                           invokeRestart(restart)
[16:18:45.432]                           muffled <- TRUE
[16:18:45.432]                           break
[16:18:45.432]                         }
[16:18:45.432]                       }
[16:18:45.432]                     }
[16:18:45.432]                     invisible(muffled)
[16:18:45.432]                   }
[16:18:45.432]                   muffleCondition(cond)
[16:18:45.432]                 })
[16:18:45.432]             }))
[16:18:45.432]             future::FutureResult(value = ...future.value$value, 
[16:18:45.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.432]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.432]                     ...future.globalenv.names))
[16:18:45.432]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.432]         }, condition = base::local({
[16:18:45.432]             c <- base::c
[16:18:45.432]             inherits <- base::inherits
[16:18:45.432]             invokeRestart <- base::invokeRestart
[16:18:45.432]             length <- base::length
[16:18:45.432]             list <- base::list
[16:18:45.432]             seq.int <- base::seq.int
[16:18:45.432]             signalCondition <- base::signalCondition
[16:18:45.432]             sys.calls <- base::sys.calls
[16:18:45.432]             `[[` <- base::`[[`
[16:18:45.432]             `+` <- base::`+`
[16:18:45.432]             `<<-` <- base::`<<-`
[16:18:45.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.432]                   3L)]
[16:18:45.432]             }
[16:18:45.432]             function(cond) {
[16:18:45.432]                 is_error <- inherits(cond, "error")
[16:18:45.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.432]                   NULL)
[16:18:45.432]                 if (is_error) {
[16:18:45.432]                   sessionInformation <- function() {
[16:18:45.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.432]                       search = base::search(), system = base::Sys.info())
[16:18:45.432]                   }
[16:18:45.432]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.432]                     cond$call), session = sessionInformation(), 
[16:18:45.432]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.432]                   signalCondition(cond)
[16:18:45.432]                 }
[16:18:45.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.432]                 "immediateCondition"))) {
[16:18:45.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.432]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.432]                   if (TRUE && !signal) {
[16:18:45.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.432]                     {
[16:18:45.432]                       inherits <- base::inherits
[16:18:45.432]                       invokeRestart <- base::invokeRestart
[16:18:45.432]                       is.null <- base::is.null
[16:18:45.432]                       muffled <- FALSE
[16:18:45.432]                       if (inherits(cond, "message")) {
[16:18:45.432]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.432]                         if (muffled) 
[16:18:45.432]                           invokeRestart("muffleMessage")
[16:18:45.432]                       }
[16:18:45.432]                       else if (inherits(cond, "warning")) {
[16:18:45.432]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.432]                         if (muffled) 
[16:18:45.432]                           invokeRestart("muffleWarning")
[16:18:45.432]                       }
[16:18:45.432]                       else if (inherits(cond, "condition")) {
[16:18:45.432]                         if (!is.null(pattern)) {
[16:18:45.432]                           computeRestarts <- base::computeRestarts
[16:18:45.432]                           grepl <- base::grepl
[16:18:45.432]                           restarts <- computeRestarts(cond)
[16:18:45.432]                           for (restart in restarts) {
[16:18:45.432]                             name <- restart$name
[16:18:45.432]                             if (is.null(name)) 
[16:18:45.432]                               next
[16:18:45.432]                             if (!grepl(pattern, name)) 
[16:18:45.432]                               next
[16:18:45.432]                             invokeRestart(restart)
[16:18:45.432]                             muffled <- TRUE
[16:18:45.432]                             break
[16:18:45.432]                           }
[16:18:45.432]                         }
[16:18:45.432]                       }
[16:18:45.432]                       invisible(muffled)
[16:18:45.432]                     }
[16:18:45.432]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.432]                   }
[16:18:45.432]                 }
[16:18:45.432]                 else {
[16:18:45.432]                   if (TRUE) {
[16:18:45.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.432]                     {
[16:18:45.432]                       inherits <- base::inherits
[16:18:45.432]                       invokeRestart <- base::invokeRestart
[16:18:45.432]                       is.null <- base::is.null
[16:18:45.432]                       muffled <- FALSE
[16:18:45.432]                       if (inherits(cond, "message")) {
[16:18:45.432]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.432]                         if (muffled) 
[16:18:45.432]                           invokeRestart("muffleMessage")
[16:18:45.432]                       }
[16:18:45.432]                       else if (inherits(cond, "warning")) {
[16:18:45.432]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.432]                         if (muffled) 
[16:18:45.432]                           invokeRestart("muffleWarning")
[16:18:45.432]                       }
[16:18:45.432]                       else if (inherits(cond, "condition")) {
[16:18:45.432]                         if (!is.null(pattern)) {
[16:18:45.432]                           computeRestarts <- base::computeRestarts
[16:18:45.432]                           grepl <- base::grepl
[16:18:45.432]                           restarts <- computeRestarts(cond)
[16:18:45.432]                           for (restart in restarts) {
[16:18:45.432]                             name <- restart$name
[16:18:45.432]                             if (is.null(name)) 
[16:18:45.432]                               next
[16:18:45.432]                             if (!grepl(pattern, name)) 
[16:18:45.432]                               next
[16:18:45.432]                             invokeRestart(restart)
[16:18:45.432]                             muffled <- TRUE
[16:18:45.432]                             break
[16:18:45.432]                           }
[16:18:45.432]                         }
[16:18:45.432]                       }
[16:18:45.432]                       invisible(muffled)
[16:18:45.432]                     }
[16:18:45.432]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.432]                   }
[16:18:45.432]                 }
[16:18:45.432]             }
[16:18:45.432]         }))
[16:18:45.432]     }, error = function(ex) {
[16:18:45.432]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.432]                 ...future.rng), started = ...future.startTime, 
[16:18:45.432]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.432]             version = "1.8"), class = "FutureResult")
[16:18:45.432]     }, finally = {
[16:18:45.432]         if (!identical(...future.workdir, getwd())) 
[16:18:45.432]             setwd(...future.workdir)
[16:18:45.432]         {
[16:18:45.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.432]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.432]             }
[16:18:45.432]             base::options(...future.oldOptions)
[16:18:45.432]             if (.Platform$OS.type == "windows") {
[16:18:45.432]                 old_names <- names(...future.oldEnvVars)
[16:18:45.432]                 envs <- base::Sys.getenv()
[16:18:45.432]                 names <- names(envs)
[16:18:45.432]                 common <- intersect(names, old_names)
[16:18:45.432]                 added <- setdiff(names, old_names)
[16:18:45.432]                 removed <- setdiff(old_names, names)
[16:18:45.432]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.432]                   envs[common]]
[16:18:45.432]                 NAMES <- toupper(changed)
[16:18:45.432]                 args <- list()
[16:18:45.432]                 for (kk in seq_along(NAMES)) {
[16:18:45.432]                   name <- changed[[kk]]
[16:18:45.432]                   NAME <- NAMES[[kk]]
[16:18:45.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.432]                     next
[16:18:45.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.432]                 }
[16:18:45.432]                 NAMES <- toupper(added)
[16:18:45.432]                 for (kk in seq_along(NAMES)) {
[16:18:45.432]                   name <- added[[kk]]
[16:18:45.432]                   NAME <- NAMES[[kk]]
[16:18:45.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.432]                     next
[16:18:45.432]                   args[[name]] <- ""
[16:18:45.432]                 }
[16:18:45.432]                 NAMES <- toupper(removed)
[16:18:45.432]                 for (kk in seq_along(NAMES)) {
[16:18:45.432]                   name <- removed[[kk]]
[16:18:45.432]                   NAME <- NAMES[[kk]]
[16:18:45.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.432]                     next
[16:18:45.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.432]                 }
[16:18:45.432]                 if (length(args) > 0) 
[16:18:45.432]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.432]             }
[16:18:45.432]             else {
[16:18:45.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.432]             }
[16:18:45.432]             {
[16:18:45.432]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.432]                   0L) {
[16:18:45.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.432]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.432]                   base::options(opts)
[16:18:45.432]                 }
[16:18:45.432]                 {
[16:18:45.432]                   {
[16:18:45.432]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.432]                     NULL
[16:18:45.432]                   }
[16:18:45.432]                   options(future.plan = NULL)
[16:18:45.432]                   if (is.na(NA_character_)) 
[16:18:45.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.432]                     .init = FALSE)
[16:18:45.432]                 }
[16:18:45.432]             }
[16:18:45.432]         }
[16:18:45.432]     })
[16:18:45.432]     if (TRUE) {
[16:18:45.432]         base::sink(type = "output", split = FALSE)
[16:18:45.432]         if (TRUE) {
[16:18:45.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.432]         }
[16:18:45.432]         else {
[16:18:45.432]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.432]         }
[16:18:45.432]         base::close(...future.stdout)
[16:18:45.432]         ...future.stdout <- NULL
[16:18:45.432]     }
[16:18:45.432]     ...future.result$conditions <- ...future.conditions
[16:18:45.432]     ...future.result$finished <- base::Sys.time()
[16:18:45.432]     ...future.result
[16:18:45.432] }
[16:18:45.435] Poll #1 (0): usedNodes() = 2, workers = 2
[16:18:45.445] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.445] - Validating connection of MultisessionFuture
[16:18:45.445] - received message: FutureResult
[16:18:45.446] - Received FutureResult
[16:18:45.446] - Erased future from FutureRegistry
[16:18:45.446] result() for ClusterFuture ...
[16:18:45.446] - result already collected: FutureResult
[16:18:45.446] result() for ClusterFuture ... done
[16:18:45.446] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.446] result() for ClusterFuture ...
[16:18:45.446] - result already collected: FutureResult
[16:18:45.446] result() for ClusterFuture ... done
[16:18:45.446] result() for ClusterFuture ...
[16:18:45.447] - result already collected: FutureResult
[16:18:45.447] result() for ClusterFuture ... done
[16:18:45.447] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[16:18:45.447] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[16:18:45.448] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[16:18:45.448] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:45.448] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.448] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[16:18:45.449] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[16:18:45.449] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:45.449] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.449] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:45.450] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.450] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[16:18:45.450] MultisessionFuture started
[16:18:45.450] - Launch lazy future ... done
[16:18:45.450] run() for ‘MultisessionFuture’ ... done
[16:18:45.450] Created future:
[16:18:45.451] MultisessionFuture:
[16:18:45.451] Label: ‘future_mapply-5’
[16:18:45.451] Expression:
[16:18:45.451] {
[16:18:45.451]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.451]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.451]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.451]         on.exit(options(oopts), add = TRUE)
[16:18:45.451]     }
[16:18:45.451]     {
[16:18:45.451]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.451]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.451]         do.call(mapply, args = args)
[16:18:45.451]     }
[16:18:45.451] }
[16:18:45.451] Lazy evaluation: FALSE
[16:18:45.451] Asynchronous evaluation: TRUE
[16:18:45.451] Local evaluation: TRUE
[16:18:45.451] Environment: R_GlobalEnv
[16:18:45.451] Capture standard output: TRUE
[16:18:45.451] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.451] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.451] Packages: <none>
[16:18:45.451] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.451] Resolved: FALSE
[16:18:45.451] Value: <not collected>
[16:18:45.451] Conditions captured: <none>
[16:18:45.451] Early signaling: FALSE
[16:18:45.451] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.451] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.462] Chunk #5 of 5 ... DONE
[16:18:45.462] Launching 5 futures (chunks) ... DONE
[16:18:45.462] Resolving 5 futures (chunks) ...
[16:18:45.462] resolve() on list ...
[16:18:45.462]  recursive: 0
[16:18:45.462]  length: 5
[16:18:45.463] 
[16:18:45.463] Future #1
[16:18:45.463] result() for ClusterFuture ...
[16:18:45.463] - result already collected: FutureResult
[16:18:45.463] result() for ClusterFuture ... done
[16:18:45.463] result() for ClusterFuture ...
[16:18:45.463] - result already collected: FutureResult
[16:18:45.463] result() for ClusterFuture ... done
[16:18:45.463] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:45.463] - nx: 5
[16:18:45.464] - relay: TRUE
[16:18:45.464] - stdout: TRUE
[16:18:45.464] - signal: TRUE
[16:18:45.464] - resignal: FALSE
[16:18:45.464] - force: TRUE
[16:18:45.464] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[16:18:45.464] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[16:18:45.464]  - until=1
[16:18:45.464]  - relaying element #1
[16:18:45.464] result() for ClusterFuture ...
[16:18:45.464] - result already collected: FutureResult
[16:18:45.465] result() for ClusterFuture ... done
[16:18:45.465] result() for ClusterFuture ...
[16:18:45.465] - result already collected: FutureResult
[16:18:45.465] result() for ClusterFuture ... done
[16:18:45.465] result() for ClusterFuture ...
[16:18:45.465] - result already collected: FutureResult
[16:18:45.465] result() for ClusterFuture ... done
[16:18:45.465] result() for ClusterFuture ...
[16:18:45.465] - result already collected: FutureResult
[16:18:45.465] result() for ClusterFuture ... done
[16:18:45.465] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:45.465] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:45.466] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:45.466]  length: 4 (resolved future 1)
[16:18:45.466] Future #2
[16:18:45.466] result() for ClusterFuture ...
[16:18:45.466] - result already collected: FutureResult
[16:18:45.466] result() for ClusterFuture ... done
[16:18:45.466] result() for ClusterFuture ...
[16:18:45.466] - result already collected: FutureResult
[16:18:45.466] result() for ClusterFuture ... done
[16:18:45.466] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:45.467] - nx: 5
[16:18:45.467] - relay: TRUE
[16:18:45.467] - stdout: TRUE
[16:18:45.467] - signal: TRUE
[16:18:45.467] - resignal: FALSE
[16:18:45.467] - force: TRUE
[16:18:45.467] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:45.467] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[16:18:45.467]  - until=2
[16:18:45.467]  - relaying element #2
[16:18:45.467] result() for ClusterFuture ...
[16:18:45.468] - result already collected: FutureResult
[16:18:45.468] result() for ClusterFuture ... done
[16:18:45.468] result() for ClusterFuture ...
[16:18:45.468] - result already collected: FutureResult
[16:18:45.468] result() for ClusterFuture ... done
[16:18:45.468] result() for ClusterFuture ...
[16:18:45.468] - result already collected: FutureResult
[16:18:45.468] result() for ClusterFuture ... done
[16:18:45.468] result() for ClusterFuture ...
[16:18:45.468] - result already collected: FutureResult
[16:18:45.468] result() for ClusterFuture ... done
[16:18:45.469] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:45.469] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:45.469] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:45.469]  length: 3 (resolved future 2)
[16:18:45.469] Future #3
[16:18:45.469] result() for ClusterFuture ...
[16:18:45.469] - result already collected: FutureResult
[16:18:45.469] result() for ClusterFuture ... done
[16:18:45.469] result() for ClusterFuture ...
[16:18:45.469] - result already collected: FutureResult
[16:18:45.469] result() for ClusterFuture ... done
[16:18:45.470] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:18:45.470] - nx: 5
[16:18:45.470] - relay: TRUE
[16:18:45.470] - stdout: TRUE
[16:18:45.470] - signal: TRUE
[16:18:45.470] - resignal: FALSE
[16:18:45.470] - force: TRUE
[16:18:45.470] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:45.470] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[16:18:45.470]  - until=3
[16:18:45.470]  - relaying element #3
[16:18:45.470] result() for ClusterFuture ...
[16:18:45.471] - result already collected: FutureResult
[16:18:45.471] result() for ClusterFuture ... done
[16:18:45.471] result() for ClusterFuture ...
[16:18:45.471] - result already collected: FutureResult
[16:18:45.471] result() for ClusterFuture ... done
[16:18:45.471] result() for ClusterFuture ...
[16:18:45.471] - result already collected: FutureResult
[16:18:45.471] result() for ClusterFuture ... done
[16:18:45.471] result() for ClusterFuture ...
[16:18:45.471] - result already collected: FutureResult
[16:18:45.471] result() for ClusterFuture ... done
[16:18:45.472] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:45.472] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:45.472] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:18:45.472]  length: 2 (resolved future 3)
[16:18:45.472] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.472] - Validating connection of MultisessionFuture
[16:18:45.473] - received message: FutureResult
[16:18:45.473] - Received FutureResult
[16:18:45.473] - Erased future from FutureRegistry
[16:18:45.473] result() for ClusterFuture ...
[16:18:45.473] - result already collected: FutureResult
[16:18:45.473] result() for ClusterFuture ... done
[16:18:45.473] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.473] Future #4
[16:18:45.473] result() for ClusterFuture ...
[16:18:45.473] - result already collected: FutureResult
[16:18:45.473] result() for ClusterFuture ... done
[16:18:45.474] result() for ClusterFuture ...
[16:18:45.474] - result already collected: FutureResult
[16:18:45.474] result() for ClusterFuture ... done
[16:18:45.474] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:18:45.474] - nx: 5
[16:18:45.474] - relay: TRUE
[16:18:45.474] - stdout: TRUE
[16:18:45.474] - signal: TRUE
[16:18:45.474] - resignal: FALSE
[16:18:45.474] - force: TRUE
[16:18:45.474] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:45.475] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[16:18:45.475]  - until=4
[16:18:45.475]  - relaying element #4
[16:18:45.475] result() for ClusterFuture ...
[16:18:45.475] - result already collected: FutureResult
[16:18:45.475] result() for ClusterFuture ... done
[16:18:45.475] result() for ClusterFuture ...
[16:18:45.475] - result already collected: FutureResult
[16:18:45.475] result() for ClusterFuture ... done
[16:18:45.475] result() for ClusterFuture ...
[16:18:45.475] - result already collected: FutureResult
[16:18:45.476] result() for ClusterFuture ... done
[16:18:45.476] result() for ClusterFuture ...
[16:18:45.476] - result already collected: FutureResult
[16:18:45.476] result() for ClusterFuture ... done
[16:18:45.476] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:45.476] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:45.476] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:18:45.476]  length: 1 (resolved future 4)
[16:18:45.497] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.497] - Validating connection of MultisessionFuture
[16:18:45.498] - received message: FutureResult
[16:18:45.498] - Received FutureResult
[16:18:45.498] - Erased future from FutureRegistry
[16:18:45.498] result() for ClusterFuture ...
[16:18:45.498] - result already collected: FutureResult
[16:18:45.498] result() for ClusterFuture ... done
[16:18:45.498] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.498] Future #5
[16:18:45.498] result() for ClusterFuture ...
[16:18:45.498] - result already collected: FutureResult
[16:18:45.499] result() for ClusterFuture ... done
[16:18:45.499] result() for ClusterFuture ...
[16:18:45.499] - result already collected: FutureResult
[16:18:45.499] result() for ClusterFuture ... done
[16:18:45.499] signalConditionsASAP(MultisessionFuture, pos=5) ...
[16:18:45.499] - nx: 5
[16:18:45.499] - relay: TRUE
[16:18:45.499] - stdout: TRUE
[16:18:45.499] - signal: TRUE
[16:18:45.499] - resignal: FALSE
[16:18:45.499] - force: TRUE
[16:18:45.499] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:45.500] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[16:18:45.500]  - until=5
[16:18:45.500]  - relaying element #5
[16:18:45.500] result() for ClusterFuture ...
[16:18:45.500] - result already collected: FutureResult
[16:18:45.500] result() for ClusterFuture ... done
[16:18:45.500] result() for ClusterFuture ...
[16:18:45.500] - result already collected: FutureResult
[16:18:45.500] result() for ClusterFuture ... done
[16:18:45.500] result() for ClusterFuture ...
[16:18:45.501] - result already collected: FutureResult
[16:18:45.501] result() for ClusterFuture ... done
[16:18:45.501] result() for ClusterFuture ...
[16:18:45.501] - result already collected: FutureResult
[16:18:45.501] result() for ClusterFuture ... done
[16:18:45.501] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:45.501] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:45.501] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[16:18:45.501]  length: 0 (resolved future 5)
[16:18:45.501] Relaying remaining futures
[16:18:45.501] signalConditionsASAP(NULL, pos=0) ...
[16:18:45.501] - nx: 5
[16:18:45.502] - relay: TRUE
[16:18:45.502] - stdout: TRUE
[16:18:45.502] - signal: TRUE
[16:18:45.502] - resignal: FALSE
[16:18:45.502] - force: TRUE
[16:18:45.502] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:45.502] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[16:18:45.502] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:45.502] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[16:18:45.502] signalConditionsASAP(NULL, pos=0) ... done
[16:18:45.502] resolve() on list ... DONE
[16:18:45.503] result() for ClusterFuture ...
[16:18:45.503] - result already collected: FutureResult
[16:18:45.505] result() for ClusterFuture ... done
[16:18:45.505] result() for ClusterFuture ...
[16:18:45.505] - result already collected: FutureResult
[16:18:45.505] result() for ClusterFuture ... done
[16:18:45.506] result() for ClusterFuture ...
[16:18:45.506] - result already collected: FutureResult
[16:18:45.506] result() for ClusterFuture ... done
[16:18:45.506] result() for ClusterFuture ...
[16:18:45.506] - result already collected: FutureResult
[16:18:45.506] result() for ClusterFuture ... done
[16:18:45.506] result() for ClusterFuture ...
[16:18:45.506] - result already collected: FutureResult
[16:18:45.506] result() for ClusterFuture ... done
[16:18:45.506] result() for ClusterFuture ...
[16:18:45.506] - result already collected: FutureResult
[16:18:45.507] result() for ClusterFuture ... done
[16:18:45.507] result() for ClusterFuture ...
[16:18:45.507] - result already collected: FutureResult
[16:18:45.507] result() for ClusterFuture ... done
[16:18:45.507] result() for ClusterFuture ...
[16:18:45.507] - result already collected: FutureResult
[16:18:45.507] result() for ClusterFuture ... done
[16:18:45.507] result() for ClusterFuture ...
[16:18:45.507] - result already collected: FutureResult
[16:18:45.507] result() for ClusterFuture ... done
[16:18:45.507] result() for ClusterFuture ...
[16:18:45.508] - result already collected: FutureResult
[16:18:45.508] result() for ClusterFuture ... done
[16:18:45.508]  - Number of value chunks collected: 5
[16:18:45.508] Resolving 5 futures (chunks) ... DONE
[16:18:45.508] Reducing values from 5 chunks ...
[16:18:45.508]  - Number of values collected after concatenation: 5
[16:18:45.508]  - Number of values expected: 5
[16:18:45.508] Reducing values from 5 chunks ... DONE
[16:18:45.508] future_mapply() ... DONE
[16:18:45.509] future_mapply() ...
[16:18:45.512] Number of chunks: 2
[16:18:45.512] getGlobalsAndPackagesXApply() ...
[16:18:45.512]  - future.globals: TRUE
[16:18:45.513] getGlobalsAndPackages() ...
[16:18:45.513] Searching for globals...
[16:18:45.514] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:45.514] Searching for globals ... DONE
[16:18:45.514] Resolving globals: FALSE
[16:18:45.514] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:45.515] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:45.515] - globals: [1] ‘FUN’
[16:18:45.515] 
[16:18:45.515] getGlobalsAndPackages() ... DONE
[16:18:45.515]  - globals found/used: [n=1] ‘FUN’
[16:18:45.515]  - needed namespaces: [n=0] 
[16:18:45.515] Finding globals ... DONE
[16:18:45.516] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:45.516] List of 2
[16:18:45.516]  $ ...future.FUN:function (C, k)  
[16:18:45.516]  $ MoreArgs     : list()
[16:18:45.516]  - attr(*, "where")=List of 2
[16:18:45.516]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:45.516]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:45.516]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:45.516]  - attr(*, "resolved")= logi FALSE
[16:18:45.516]  - attr(*, "total_size")= num NA
[16:18:45.518] Packages to be attached in all futures: [n=0] 
[16:18:45.518] getGlobalsAndPackagesXApply() ... DONE
[16:18:45.518] Number of futures (= number of chunks): 2
[16:18:45.519] Launching 2 futures (chunks) ...
[16:18:45.519] Chunk #1 of 2 ...
[16:18:45.519]  - Finding globals in '...' for chunk #1 ...
[16:18:45.519] getGlobalsAndPackages() ...
[16:18:45.519] Searching for globals...
[16:18:45.519] 
[16:18:45.519] Searching for globals ... DONE
[16:18:45.519] - globals: [0] <none>
[16:18:45.519] getGlobalsAndPackages() ... DONE
[16:18:45.520]    + additional globals found: [n=0] 
[16:18:45.520]    + additional namespaces needed: [n=0] 
[16:18:45.520]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:45.520]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:45.520]  - seeds: <none>
[16:18:45.520]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.520] getGlobalsAndPackages() ...
[16:18:45.520] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.520] Resolving globals: FALSE
[16:18:45.521] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:45.521] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:45.521] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.522] 
[16:18:45.522] getGlobalsAndPackages() ... DONE
[16:18:45.522] run() for ‘Future’ ...
[16:18:45.522] - state: ‘created’
[16:18:45.522] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.535] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.536]   - Field: ‘node’
[16:18:45.536]   - Field: ‘label’
[16:18:45.536]   - Field: ‘local’
[16:18:45.536]   - Field: ‘owner’
[16:18:45.536]   - Field: ‘envir’
[16:18:45.536]   - Field: ‘workers’
[16:18:45.536]   - Field: ‘packages’
[16:18:45.536]   - Field: ‘gc’
[16:18:45.536]   - Field: ‘conditions’
[16:18:45.537]   - Field: ‘persistent’
[16:18:45.537]   - Field: ‘expr’
[16:18:45.537]   - Field: ‘uuid’
[16:18:45.537]   - Field: ‘seed’
[16:18:45.537]   - Field: ‘version’
[16:18:45.537]   - Field: ‘result’
[16:18:45.537]   - Field: ‘asynchronous’
[16:18:45.537]   - Field: ‘calls’
[16:18:45.537]   - Field: ‘globals’
[16:18:45.537]   - Field: ‘stdout’
[16:18:45.537]   - Field: ‘earlySignal’
[16:18:45.537]   - Field: ‘lazy’
[16:18:45.538]   - Field: ‘state’
[16:18:45.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.538] - Launch lazy future ...
[16:18:45.538] Packages needed by the future expression (n = 0): <none>
[16:18:45.538] Packages needed by future strategies (n = 0): <none>
[16:18:45.539] {
[16:18:45.539]     {
[16:18:45.539]         {
[16:18:45.539]             ...future.startTime <- base::Sys.time()
[16:18:45.539]             {
[16:18:45.539]                 {
[16:18:45.539]                   {
[16:18:45.539]                     {
[16:18:45.539]                       base::local({
[16:18:45.539]                         has_future <- base::requireNamespace("future", 
[16:18:45.539]                           quietly = TRUE)
[16:18:45.539]                         if (has_future) {
[16:18:45.539]                           ns <- base::getNamespace("future")
[16:18:45.539]                           version <- ns[[".package"]][["version"]]
[16:18:45.539]                           if (is.null(version)) 
[16:18:45.539]                             version <- utils::packageVersion("future")
[16:18:45.539]                         }
[16:18:45.539]                         else {
[16:18:45.539]                           version <- NULL
[16:18:45.539]                         }
[16:18:45.539]                         if (!has_future || version < "1.8.0") {
[16:18:45.539]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.539]                             "", base::R.version$version.string), 
[16:18:45.539]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.539]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.539]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.539]                               "release", "version")], collapse = " "), 
[16:18:45.539]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.539]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.539]                             info)
[16:18:45.539]                           info <- base::paste(info, collapse = "; ")
[16:18:45.539]                           if (!has_future) {
[16:18:45.539]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.539]                               info)
[16:18:45.539]                           }
[16:18:45.539]                           else {
[16:18:45.539]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.539]                               info, version)
[16:18:45.539]                           }
[16:18:45.539]                           base::stop(msg)
[16:18:45.539]                         }
[16:18:45.539]                       })
[16:18:45.539]                     }
[16:18:45.539]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.539]                     base::options(mc.cores = 1L)
[16:18:45.539]                   }
[16:18:45.539]                   ...future.strategy.old <- future::plan("list")
[16:18:45.539]                   options(future.plan = NULL)
[16:18:45.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.539]                 }
[16:18:45.539]                 ...future.workdir <- getwd()
[16:18:45.539]             }
[16:18:45.539]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.539]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.539]         }
[16:18:45.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.539]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:45.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.539]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.539]             base::names(...future.oldOptions))
[16:18:45.539]     }
[16:18:45.539]     if (FALSE) {
[16:18:45.539]     }
[16:18:45.539]     else {
[16:18:45.539]         if (TRUE) {
[16:18:45.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.539]                 open = "w")
[16:18:45.539]         }
[16:18:45.539]         else {
[16:18:45.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.539]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.539]         }
[16:18:45.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.539]             base::sink(type = "output", split = FALSE)
[16:18:45.539]             base::close(...future.stdout)
[16:18:45.539]         }, add = TRUE)
[16:18:45.539]     }
[16:18:45.539]     ...future.frame <- base::sys.nframe()
[16:18:45.539]     ...future.conditions <- base::list()
[16:18:45.539]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.539]     if (FALSE) {
[16:18:45.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.539]     }
[16:18:45.539]     ...future.result <- base::tryCatch({
[16:18:45.539]         base::withCallingHandlers({
[16:18:45.539]             ...future.value <- base::withVisible(base::local({
[16:18:45.539]                 ...future.makeSendCondition <- base::local({
[16:18:45.539]                   sendCondition <- NULL
[16:18:45.539]                   function(frame = 1L) {
[16:18:45.539]                     if (is.function(sendCondition)) 
[16:18:45.539]                       return(sendCondition)
[16:18:45.539]                     ns <- getNamespace("parallel")
[16:18:45.539]                     if (exists("sendData", mode = "function", 
[16:18:45.539]                       envir = ns)) {
[16:18:45.539]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.539]                         envir = ns)
[16:18:45.539]                       envir <- sys.frame(frame)
[16:18:45.539]                       master <- NULL
[16:18:45.539]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.539]                         !identical(envir, emptyenv())) {
[16:18:45.539]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.539]                           inherits = FALSE)) {
[16:18:45.539]                           master <- get("master", mode = "list", 
[16:18:45.539]                             envir = envir, inherits = FALSE)
[16:18:45.539]                           if (inherits(master, c("SOCKnode", 
[16:18:45.539]                             "SOCK0node"))) {
[16:18:45.539]                             sendCondition <<- function(cond) {
[16:18:45.539]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.539]                                 success = TRUE)
[16:18:45.539]                               parallel_sendData(master, data)
[16:18:45.539]                             }
[16:18:45.539]                             return(sendCondition)
[16:18:45.539]                           }
[16:18:45.539]                         }
[16:18:45.539]                         frame <- frame + 1L
[16:18:45.539]                         envir <- sys.frame(frame)
[16:18:45.539]                       }
[16:18:45.539]                     }
[16:18:45.539]                     sendCondition <<- function(cond) NULL
[16:18:45.539]                   }
[16:18:45.539]                 })
[16:18:45.539]                 withCallingHandlers({
[16:18:45.539]                   {
[16:18:45.539]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.539]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.539]                       ...future.globals.maxSize)) {
[16:18:45.539]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.539]                       on.exit(options(oopts), add = TRUE)
[16:18:45.539]                     }
[16:18:45.539]                     {
[16:18:45.539]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.539]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.539]                         USE.NAMES = FALSE)
[16:18:45.539]                       do.call(mapply, args = args)
[16:18:45.539]                     }
[16:18:45.539]                   }
[16:18:45.539]                 }, immediateCondition = function(cond) {
[16:18:45.539]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.539]                   sendCondition(cond)
[16:18:45.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.539]                   {
[16:18:45.539]                     inherits <- base::inherits
[16:18:45.539]                     invokeRestart <- base::invokeRestart
[16:18:45.539]                     is.null <- base::is.null
[16:18:45.539]                     muffled <- FALSE
[16:18:45.539]                     if (inherits(cond, "message")) {
[16:18:45.539]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.539]                       if (muffled) 
[16:18:45.539]                         invokeRestart("muffleMessage")
[16:18:45.539]                     }
[16:18:45.539]                     else if (inherits(cond, "warning")) {
[16:18:45.539]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.539]                       if (muffled) 
[16:18:45.539]                         invokeRestart("muffleWarning")
[16:18:45.539]                     }
[16:18:45.539]                     else if (inherits(cond, "condition")) {
[16:18:45.539]                       if (!is.null(pattern)) {
[16:18:45.539]                         computeRestarts <- base::computeRestarts
[16:18:45.539]                         grepl <- base::grepl
[16:18:45.539]                         restarts <- computeRestarts(cond)
[16:18:45.539]                         for (restart in restarts) {
[16:18:45.539]                           name <- restart$name
[16:18:45.539]                           if (is.null(name)) 
[16:18:45.539]                             next
[16:18:45.539]                           if (!grepl(pattern, name)) 
[16:18:45.539]                             next
[16:18:45.539]                           invokeRestart(restart)
[16:18:45.539]                           muffled <- TRUE
[16:18:45.539]                           break
[16:18:45.539]                         }
[16:18:45.539]                       }
[16:18:45.539]                     }
[16:18:45.539]                     invisible(muffled)
[16:18:45.539]                   }
[16:18:45.539]                   muffleCondition(cond)
[16:18:45.539]                 })
[16:18:45.539]             }))
[16:18:45.539]             future::FutureResult(value = ...future.value$value, 
[16:18:45.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.539]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.539]                     ...future.globalenv.names))
[16:18:45.539]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.539]         }, condition = base::local({
[16:18:45.539]             c <- base::c
[16:18:45.539]             inherits <- base::inherits
[16:18:45.539]             invokeRestart <- base::invokeRestart
[16:18:45.539]             length <- base::length
[16:18:45.539]             list <- base::list
[16:18:45.539]             seq.int <- base::seq.int
[16:18:45.539]             signalCondition <- base::signalCondition
[16:18:45.539]             sys.calls <- base::sys.calls
[16:18:45.539]             `[[` <- base::`[[`
[16:18:45.539]             `+` <- base::`+`
[16:18:45.539]             `<<-` <- base::`<<-`
[16:18:45.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.539]                   3L)]
[16:18:45.539]             }
[16:18:45.539]             function(cond) {
[16:18:45.539]                 is_error <- inherits(cond, "error")
[16:18:45.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.539]                   NULL)
[16:18:45.539]                 if (is_error) {
[16:18:45.539]                   sessionInformation <- function() {
[16:18:45.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.539]                       search = base::search(), system = base::Sys.info())
[16:18:45.539]                   }
[16:18:45.539]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.539]                     cond$call), session = sessionInformation(), 
[16:18:45.539]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.539]                   signalCondition(cond)
[16:18:45.539]                 }
[16:18:45.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.539]                 "immediateCondition"))) {
[16:18:45.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.539]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.539]                   if (TRUE && !signal) {
[16:18:45.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.539]                     {
[16:18:45.539]                       inherits <- base::inherits
[16:18:45.539]                       invokeRestart <- base::invokeRestart
[16:18:45.539]                       is.null <- base::is.null
[16:18:45.539]                       muffled <- FALSE
[16:18:45.539]                       if (inherits(cond, "message")) {
[16:18:45.539]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.539]                         if (muffled) 
[16:18:45.539]                           invokeRestart("muffleMessage")
[16:18:45.539]                       }
[16:18:45.539]                       else if (inherits(cond, "warning")) {
[16:18:45.539]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.539]                         if (muffled) 
[16:18:45.539]                           invokeRestart("muffleWarning")
[16:18:45.539]                       }
[16:18:45.539]                       else if (inherits(cond, "condition")) {
[16:18:45.539]                         if (!is.null(pattern)) {
[16:18:45.539]                           computeRestarts <- base::computeRestarts
[16:18:45.539]                           grepl <- base::grepl
[16:18:45.539]                           restarts <- computeRestarts(cond)
[16:18:45.539]                           for (restart in restarts) {
[16:18:45.539]                             name <- restart$name
[16:18:45.539]                             if (is.null(name)) 
[16:18:45.539]                               next
[16:18:45.539]                             if (!grepl(pattern, name)) 
[16:18:45.539]                               next
[16:18:45.539]                             invokeRestart(restart)
[16:18:45.539]                             muffled <- TRUE
[16:18:45.539]                             break
[16:18:45.539]                           }
[16:18:45.539]                         }
[16:18:45.539]                       }
[16:18:45.539]                       invisible(muffled)
[16:18:45.539]                     }
[16:18:45.539]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.539]                   }
[16:18:45.539]                 }
[16:18:45.539]                 else {
[16:18:45.539]                   if (TRUE) {
[16:18:45.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.539]                     {
[16:18:45.539]                       inherits <- base::inherits
[16:18:45.539]                       invokeRestart <- base::invokeRestart
[16:18:45.539]                       is.null <- base::is.null
[16:18:45.539]                       muffled <- FALSE
[16:18:45.539]                       if (inherits(cond, "message")) {
[16:18:45.539]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.539]                         if (muffled) 
[16:18:45.539]                           invokeRestart("muffleMessage")
[16:18:45.539]                       }
[16:18:45.539]                       else if (inherits(cond, "warning")) {
[16:18:45.539]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.539]                         if (muffled) 
[16:18:45.539]                           invokeRestart("muffleWarning")
[16:18:45.539]                       }
[16:18:45.539]                       else if (inherits(cond, "condition")) {
[16:18:45.539]                         if (!is.null(pattern)) {
[16:18:45.539]                           computeRestarts <- base::computeRestarts
[16:18:45.539]                           grepl <- base::grepl
[16:18:45.539]                           restarts <- computeRestarts(cond)
[16:18:45.539]                           for (restart in restarts) {
[16:18:45.539]                             name <- restart$name
[16:18:45.539]                             if (is.null(name)) 
[16:18:45.539]                               next
[16:18:45.539]                             if (!grepl(pattern, name)) 
[16:18:45.539]                               next
[16:18:45.539]                             invokeRestart(restart)
[16:18:45.539]                             muffled <- TRUE
[16:18:45.539]                             break
[16:18:45.539]                           }
[16:18:45.539]                         }
[16:18:45.539]                       }
[16:18:45.539]                       invisible(muffled)
[16:18:45.539]                     }
[16:18:45.539]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.539]                   }
[16:18:45.539]                 }
[16:18:45.539]             }
[16:18:45.539]         }))
[16:18:45.539]     }, error = function(ex) {
[16:18:45.539]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.539]                 ...future.rng), started = ...future.startTime, 
[16:18:45.539]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.539]             version = "1.8"), class = "FutureResult")
[16:18:45.539]     }, finally = {
[16:18:45.539]         if (!identical(...future.workdir, getwd())) 
[16:18:45.539]             setwd(...future.workdir)
[16:18:45.539]         {
[16:18:45.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.539]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.539]             }
[16:18:45.539]             base::options(...future.oldOptions)
[16:18:45.539]             if (.Platform$OS.type == "windows") {
[16:18:45.539]                 old_names <- names(...future.oldEnvVars)
[16:18:45.539]                 envs <- base::Sys.getenv()
[16:18:45.539]                 names <- names(envs)
[16:18:45.539]                 common <- intersect(names, old_names)
[16:18:45.539]                 added <- setdiff(names, old_names)
[16:18:45.539]                 removed <- setdiff(old_names, names)
[16:18:45.539]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.539]                   envs[common]]
[16:18:45.539]                 NAMES <- toupper(changed)
[16:18:45.539]                 args <- list()
[16:18:45.539]                 for (kk in seq_along(NAMES)) {
[16:18:45.539]                   name <- changed[[kk]]
[16:18:45.539]                   NAME <- NAMES[[kk]]
[16:18:45.539]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.539]                     next
[16:18:45.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.539]                 }
[16:18:45.539]                 NAMES <- toupper(added)
[16:18:45.539]                 for (kk in seq_along(NAMES)) {
[16:18:45.539]                   name <- added[[kk]]
[16:18:45.539]                   NAME <- NAMES[[kk]]
[16:18:45.539]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.539]                     next
[16:18:45.539]                   args[[name]] <- ""
[16:18:45.539]                 }
[16:18:45.539]                 NAMES <- toupper(removed)
[16:18:45.539]                 for (kk in seq_along(NAMES)) {
[16:18:45.539]                   name <- removed[[kk]]
[16:18:45.539]                   NAME <- NAMES[[kk]]
[16:18:45.539]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.539]                     next
[16:18:45.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.539]                 }
[16:18:45.539]                 if (length(args) > 0) 
[16:18:45.539]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.539]             }
[16:18:45.539]             else {
[16:18:45.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.539]             }
[16:18:45.539]             {
[16:18:45.539]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.539]                   0L) {
[16:18:45.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.539]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.539]                   base::options(opts)
[16:18:45.539]                 }
[16:18:45.539]                 {
[16:18:45.539]                   {
[16:18:45.539]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.539]                     NULL
[16:18:45.539]                   }
[16:18:45.539]                   options(future.plan = NULL)
[16:18:45.539]                   if (is.na(NA_character_)) 
[16:18:45.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.539]                     .init = FALSE)
[16:18:45.539]                 }
[16:18:45.539]             }
[16:18:45.539]         }
[16:18:45.539]     })
[16:18:45.539]     if (TRUE) {
[16:18:45.539]         base::sink(type = "output", split = FALSE)
[16:18:45.539]         if (TRUE) {
[16:18:45.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.539]         }
[16:18:45.539]         else {
[16:18:45.539]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.539]         }
[16:18:45.539]         base::close(...future.stdout)
[16:18:45.539]         ...future.stdout <- NULL
[16:18:45.539]     }
[16:18:45.539]     ...future.result$conditions <- ...future.conditions
[16:18:45.539]     ...future.result$finished <- base::Sys.time()
[16:18:45.539]     ...future.result
[16:18:45.539] }
[16:18:45.541] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[16:18:45.541] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[16:18:45.542] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[16:18:45.542] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:45.542] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.542] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[16:18:45.542] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[16:18:45.543] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:45.543] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.543] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:45.543] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.543] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[16:18:45.544] MultisessionFuture started
[16:18:45.544] - Launch lazy future ... done
[16:18:45.544] run() for ‘MultisessionFuture’ ... done
[16:18:45.544] Created future:
[16:18:45.544] MultisessionFuture:
[16:18:45.544] Label: ‘future_.mapply-1’
[16:18:45.544] Expression:
[16:18:45.544] {
[16:18:45.544]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.544]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.544]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.544]         on.exit(options(oopts), add = TRUE)
[16:18:45.544]     }
[16:18:45.544]     {
[16:18:45.544]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.544]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.544]         do.call(mapply, args = args)
[16:18:45.544]     }
[16:18:45.544] }
[16:18:45.544] Lazy evaluation: FALSE
[16:18:45.544] Asynchronous evaluation: TRUE
[16:18:45.544] Local evaluation: TRUE
[16:18:45.544] Environment: R_GlobalEnv
[16:18:45.544] Capture standard output: TRUE
[16:18:45.544] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.544] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.544] Packages: <none>
[16:18:45.544] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.544] Resolved: FALSE
[16:18:45.544] Value: <not collected>
[16:18:45.544] Conditions captured: <none>
[16:18:45.544] Early signaling: FALSE
[16:18:45.544] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.544] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.555] Chunk #1 of 2 ... DONE
[16:18:45.556] Chunk #2 of 2 ...
[16:18:45.556]  - Finding globals in '...' for chunk #2 ...
[16:18:45.556] getGlobalsAndPackages() ...
[16:18:45.556] Searching for globals...
[16:18:45.556] 
[16:18:45.556] Searching for globals ... DONE
[16:18:45.556] - globals: [0] <none>
[16:18:45.557] getGlobalsAndPackages() ... DONE
[16:18:45.557]    + additional globals found: [n=0] 
[16:18:45.557]    + additional namespaces needed: [n=0] 
[16:18:45.557]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:45.557]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:45.557]  - seeds: <none>
[16:18:45.557]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.557] getGlobalsAndPackages() ...
[16:18:45.557] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.557] Resolving globals: FALSE
[16:18:45.558] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[16:18:45.558] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:45.558] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.559] 
[16:18:45.559] getGlobalsAndPackages() ... DONE
[16:18:45.559] run() for ‘Future’ ...
[16:18:45.559] - state: ‘created’
[16:18:45.559] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.572] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.573]   - Field: ‘node’
[16:18:45.573]   - Field: ‘label’
[16:18:45.573]   - Field: ‘local’
[16:18:45.573]   - Field: ‘owner’
[16:18:45.573]   - Field: ‘envir’
[16:18:45.573]   - Field: ‘workers’
[16:18:45.573]   - Field: ‘packages’
[16:18:45.573]   - Field: ‘gc’
[16:18:45.573]   - Field: ‘conditions’
[16:18:45.573]   - Field: ‘persistent’
[16:18:45.574]   - Field: ‘expr’
[16:18:45.574]   - Field: ‘uuid’
[16:18:45.574]   - Field: ‘seed’
[16:18:45.574]   - Field: ‘version’
[16:18:45.574]   - Field: ‘result’
[16:18:45.574]   - Field: ‘asynchronous’
[16:18:45.574]   - Field: ‘calls’
[16:18:45.574]   - Field: ‘globals’
[16:18:45.574]   - Field: ‘stdout’
[16:18:45.574]   - Field: ‘earlySignal’
[16:18:45.574]   - Field: ‘lazy’
[16:18:45.575]   - Field: ‘state’
[16:18:45.575] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.575] - Launch lazy future ...
[16:18:45.575] Packages needed by the future expression (n = 0): <none>
[16:18:45.575] Packages needed by future strategies (n = 0): <none>
[16:18:45.575] {
[16:18:45.575]     {
[16:18:45.575]         {
[16:18:45.575]             ...future.startTime <- base::Sys.time()
[16:18:45.575]             {
[16:18:45.575]                 {
[16:18:45.575]                   {
[16:18:45.575]                     {
[16:18:45.575]                       base::local({
[16:18:45.575]                         has_future <- base::requireNamespace("future", 
[16:18:45.575]                           quietly = TRUE)
[16:18:45.575]                         if (has_future) {
[16:18:45.575]                           ns <- base::getNamespace("future")
[16:18:45.575]                           version <- ns[[".package"]][["version"]]
[16:18:45.575]                           if (is.null(version)) 
[16:18:45.575]                             version <- utils::packageVersion("future")
[16:18:45.575]                         }
[16:18:45.575]                         else {
[16:18:45.575]                           version <- NULL
[16:18:45.575]                         }
[16:18:45.575]                         if (!has_future || version < "1.8.0") {
[16:18:45.575]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.575]                             "", base::R.version$version.string), 
[16:18:45.575]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.575]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.575]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.575]                               "release", "version")], collapse = " "), 
[16:18:45.575]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.575]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.575]                             info)
[16:18:45.575]                           info <- base::paste(info, collapse = "; ")
[16:18:45.575]                           if (!has_future) {
[16:18:45.575]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.575]                               info)
[16:18:45.575]                           }
[16:18:45.575]                           else {
[16:18:45.575]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.575]                               info, version)
[16:18:45.575]                           }
[16:18:45.575]                           base::stop(msg)
[16:18:45.575]                         }
[16:18:45.575]                       })
[16:18:45.575]                     }
[16:18:45.575]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.575]                     base::options(mc.cores = 1L)
[16:18:45.575]                   }
[16:18:45.575]                   ...future.strategy.old <- future::plan("list")
[16:18:45.575]                   options(future.plan = NULL)
[16:18:45.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.575]                 }
[16:18:45.575]                 ...future.workdir <- getwd()
[16:18:45.575]             }
[16:18:45.575]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.575]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.575]         }
[16:18:45.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.575]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:45.575]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.575]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.575]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.575]             base::names(...future.oldOptions))
[16:18:45.575]     }
[16:18:45.575]     if (FALSE) {
[16:18:45.575]     }
[16:18:45.575]     else {
[16:18:45.575]         if (TRUE) {
[16:18:45.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.575]                 open = "w")
[16:18:45.575]         }
[16:18:45.575]         else {
[16:18:45.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.575]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.575]         }
[16:18:45.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.575]             base::sink(type = "output", split = FALSE)
[16:18:45.575]             base::close(...future.stdout)
[16:18:45.575]         }, add = TRUE)
[16:18:45.575]     }
[16:18:45.575]     ...future.frame <- base::sys.nframe()
[16:18:45.575]     ...future.conditions <- base::list()
[16:18:45.575]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.575]     if (FALSE) {
[16:18:45.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.575]     }
[16:18:45.575]     ...future.result <- base::tryCatch({
[16:18:45.575]         base::withCallingHandlers({
[16:18:45.575]             ...future.value <- base::withVisible(base::local({
[16:18:45.575]                 ...future.makeSendCondition <- base::local({
[16:18:45.575]                   sendCondition <- NULL
[16:18:45.575]                   function(frame = 1L) {
[16:18:45.575]                     if (is.function(sendCondition)) 
[16:18:45.575]                       return(sendCondition)
[16:18:45.575]                     ns <- getNamespace("parallel")
[16:18:45.575]                     if (exists("sendData", mode = "function", 
[16:18:45.575]                       envir = ns)) {
[16:18:45.575]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.575]                         envir = ns)
[16:18:45.575]                       envir <- sys.frame(frame)
[16:18:45.575]                       master <- NULL
[16:18:45.575]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.575]                         !identical(envir, emptyenv())) {
[16:18:45.575]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.575]                           inherits = FALSE)) {
[16:18:45.575]                           master <- get("master", mode = "list", 
[16:18:45.575]                             envir = envir, inherits = FALSE)
[16:18:45.575]                           if (inherits(master, c("SOCKnode", 
[16:18:45.575]                             "SOCK0node"))) {
[16:18:45.575]                             sendCondition <<- function(cond) {
[16:18:45.575]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.575]                                 success = TRUE)
[16:18:45.575]                               parallel_sendData(master, data)
[16:18:45.575]                             }
[16:18:45.575]                             return(sendCondition)
[16:18:45.575]                           }
[16:18:45.575]                         }
[16:18:45.575]                         frame <- frame + 1L
[16:18:45.575]                         envir <- sys.frame(frame)
[16:18:45.575]                       }
[16:18:45.575]                     }
[16:18:45.575]                     sendCondition <<- function(cond) NULL
[16:18:45.575]                   }
[16:18:45.575]                 })
[16:18:45.575]                 withCallingHandlers({
[16:18:45.575]                   {
[16:18:45.575]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.575]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.575]                       ...future.globals.maxSize)) {
[16:18:45.575]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.575]                       on.exit(options(oopts), add = TRUE)
[16:18:45.575]                     }
[16:18:45.575]                     {
[16:18:45.575]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.575]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.575]                         USE.NAMES = FALSE)
[16:18:45.575]                       do.call(mapply, args = args)
[16:18:45.575]                     }
[16:18:45.575]                   }
[16:18:45.575]                 }, immediateCondition = function(cond) {
[16:18:45.575]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.575]                   sendCondition(cond)
[16:18:45.575]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.575]                   {
[16:18:45.575]                     inherits <- base::inherits
[16:18:45.575]                     invokeRestart <- base::invokeRestart
[16:18:45.575]                     is.null <- base::is.null
[16:18:45.575]                     muffled <- FALSE
[16:18:45.575]                     if (inherits(cond, "message")) {
[16:18:45.575]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.575]                       if (muffled) 
[16:18:45.575]                         invokeRestart("muffleMessage")
[16:18:45.575]                     }
[16:18:45.575]                     else if (inherits(cond, "warning")) {
[16:18:45.575]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.575]                       if (muffled) 
[16:18:45.575]                         invokeRestart("muffleWarning")
[16:18:45.575]                     }
[16:18:45.575]                     else if (inherits(cond, "condition")) {
[16:18:45.575]                       if (!is.null(pattern)) {
[16:18:45.575]                         computeRestarts <- base::computeRestarts
[16:18:45.575]                         grepl <- base::grepl
[16:18:45.575]                         restarts <- computeRestarts(cond)
[16:18:45.575]                         for (restart in restarts) {
[16:18:45.575]                           name <- restart$name
[16:18:45.575]                           if (is.null(name)) 
[16:18:45.575]                             next
[16:18:45.575]                           if (!grepl(pattern, name)) 
[16:18:45.575]                             next
[16:18:45.575]                           invokeRestart(restart)
[16:18:45.575]                           muffled <- TRUE
[16:18:45.575]                           break
[16:18:45.575]                         }
[16:18:45.575]                       }
[16:18:45.575]                     }
[16:18:45.575]                     invisible(muffled)
[16:18:45.575]                   }
[16:18:45.575]                   muffleCondition(cond)
[16:18:45.575]                 })
[16:18:45.575]             }))
[16:18:45.575]             future::FutureResult(value = ...future.value$value, 
[16:18:45.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.575]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.575]                     ...future.globalenv.names))
[16:18:45.575]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.575]         }, condition = base::local({
[16:18:45.575]             c <- base::c
[16:18:45.575]             inherits <- base::inherits
[16:18:45.575]             invokeRestart <- base::invokeRestart
[16:18:45.575]             length <- base::length
[16:18:45.575]             list <- base::list
[16:18:45.575]             seq.int <- base::seq.int
[16:18:45.575]             signalCondition <- base::signalCondition
[16:18:45.575]             sys.calls <- base::sys.calls
[16:18:45.575]             `[[` <- base::`[[`
[16:18:45.575]             `+` <- base::`+`
[16:18:45.575]             `<<-` <- base::`<<-`
[16:18:45.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.575]                   3L)]
[16:18:45.575]             }
[16:18:45.575]             function(cond) {
[16:18:45.575]                 is_error <- inherits(cond, "error")
[16:18:45.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.575]                   NULL)
[16:18:45.575]                 if (is_error) {
[16:18:45.575]                   sessionInformation <- function() {
[16:18:45.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.575]                       search = base::search(), system = base::Sys.info())
[16:18:45.575]                   }
[16:18:45.575]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.575]                     cond$call), session = sessionInformation(), 
[16:18:45.575]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.575]                   signalCondition(cond)
[16:18:45.575]                 }
[16:18:45.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.575]                 "immediateCondition"))) {
[16:18:45.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.575]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.575]                   if (TRUE && !signal) {
[16:18:45.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.575]                     {
[16:18:45.575]                       inherits <- base::inherits
[16:18:45.575]                       invokeRestart <- base::invokeRestart
[16:18:45.575]                       is.null <- base::is.null
[16:18:45.575]                       muffled <- FALSE
[16:18:45.575]                       if (inherits(cond, "message")) {
[16:18:45.575]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.575]                         if (muffled) 
[16:18:45.575]                           invokeRestart("muffleMessage")
[16:18:45.575]                       }
[16:18:45.575]                       else if (inherits(cond, "warning")) {
[16:18:45.575]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.575]                         if (muffled) 
[16:18:45.575]                           invokeRestart("muffleWarning")
[16:18:45.575]                       }
[16:18:45.575]                       else if (inherits(cond, "condition")) {
[16:18:45.575]                         if (!is.null(pattern)) {
[16:18:45.575]                           computeRestarts <- base::computeRestarts
[16:18:45.575]                           grepl <- base::grepl
[16:18:45.575]                           restarts <- computeRestarts(cond)
[16:18:45.575]                           for (restart in restarts) {
[16:18:45.575]                             name <- restart$name
[16:18:45.575]                             if (is.null(name)) 
[16:18:45.575]                               next
[16:18:45.575]                             if (!grepl(pattern, name)) 
[16:18:45.575]                               next
[16:18:45.575]                             invokeRestart(restart)
[16:18:45.575]                             muffled <- TRUE
[16:18:45.575]                             break
[16:18:45.575]                           }
[16:18:45.575]                         }
[16:18:45.575]                       }
[16:18:45.575]                       invisible(muffled)
[16:18:45.575]                     }
[16:18:45.575]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.575]                   }
[16:18:45.575]                 }
[16:18:45.575]                 else {
[16:18:45.575]                   if (TRUE) {
[16:18:45.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.575]                     {
[16:18:45.575]                       inherits <- base::inherits
[16:18:45.575]                       invokeRestart <- base::invokeRestart
[16:18:45.575]                       is.null <- base::is.null
[16:18:45.575]                       muffled <- FALSE
[16:18:45.575]                       if (inherits(cond, "message")) {
[16:18:45.575]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.575]                         if (muffled) 
[16:18:45.575]                           invokeRestart("muffleMessage")
[16:18:45.575]                       }
[16:18:45.575]                       else if (inherits(cond, "warning")) {
[16:18:45.575]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.575]                         if (muffled) 
[16:18:45.575]                           invokeRestart("muffleWarning")
[16:18:45.575]                       }
[16:18:45.575]                       else if (inherits(cond, "condition")) {
[16:18:45.575]                         if (!is.null(pattern)) {
[16:18:45.575]                           computeRestarts <- base::computeRestarts
[16:18:45.575]                           grepl <- base::grepl
[16:18:45.575]                           restarts <- computeRestarts(cond)
[16:18:45.575]                           for (restart in restarts) {
[16:18:45.575]                             name <- restart$name
[16:18:45.575]                             if (is.null(name)) 
[16:18:45.575]                               next
[16:18:45.575]                             if (!grepl(pattern, name)) 
[16:18:45.575]                               next
[16:18:45.575]                             invokeRestart(restart)
[16:18:45.575]                             muffled <- TRUE
[16:18:45.575]                             break
[16:18:45.575]                           }
[16:18:45.575]                         }
[16:18:45.575]                       }
[16:18:45.575]                       invisible(muffled)
[16:18:45.575]                     }
[16:18:45.575]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.575]                   }
[16:18:45.575]                 }
[16:18:45.575]             }
[16:18:45.575]         }))
[16:18:45.575]     }, error = function(ex) {
[16:18:45.575]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.575]                 ...future.rng), started = ...future.startTime, 
[16:18:45.575]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.575]             version = "1.8"), class = "FutureResult")
[16:18:45.575]     }, finally = {
[16:18:45.575]         if (!identical(...future.workdir, getwd())) 
[16:18:45.575]             setwd(...future.workdir)
[16:18:45.575]         {
[16:18:45.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.575]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.575]             }
[16:18:45.575]             base::options(...future.oldOptions)
[16:18:45.575]             if (.Platform$OS.type == "windows") {
[16:18:45.575]                 old_names <- names(...future.oldEnvVars)
[16:18:45.575]                 envs <- base::Sys.getenv()
[16:18:45.575]                 names <- names(envs)
[16:18:45.575]                 common <- intersect(names, old_names)
[16:18:45.575]                 added <- setdiff(names, old_names)
[16:18:45.575]                 removed <- setdiff(old_names, names)
[16:18:45.575]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.575]                   envs[common]]
[16:18:45.575]                 NAMES <- toupper(changed)
[16:18:45.575]                 args <- list()
[16:18:45.575]                 for (kk in seq_along(NAMES)) {
[16:18:45.575]                   name <- changed[[kk]]
[16:18:45.575]                   NAME <- NAMES[[kk]]
[16:18:45.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.575]                     next
[16:18:45.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.575]                 }
[16:18:45.575]                 NAMES <- toupper(added)
[16:18:45.575]                 for (kk in seq_along(NAMES)) {
[16:18:45.575]                   name <- added[[kk]]
[16:18:45.575]                   NAME <- NAMES[[kk]]
[16:18:45.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.575]                     next
[16:18:45.575]                   args[[name]] <- ""
[16:18:45.575]                 }
[16:18:45.575]                 NAMES <- toupper(removed)
[16:18:45.575]                 for (kk in seq_along(NAMES)) {
[16:18:45.575]                   name <- removed[[kk]]
[16:18:45.575]                   NAME <- NAMES[[kk]]
[16:18:45.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.575]                     next
[16:18:45.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.575]                 }
[16:18:45.575]                 if (length(args) > 0) 
[16:18:45.575]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.575]             }
[16:18:45.575]             else {
[16:18:45.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.575]             }
[16:18:45.575]             {
[16:18:45.575]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.575]                   0L) {
[16:18:45.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.575]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.575]                   base::options(opts)
[16:18:45.575]                 }
[16:18:45.575]                 {
[16:18:45.575]                   {
[16:18:45.575]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.575]                     NULL
[16:18:45.575]                   }
[16:18:45.575]                   options(future.plan = NULL)
[16:18:45.575]                   if (is.na(NA_character_)) 
[16:18:45.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.575]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.575]                     .init = FALSE)
[16:18:45.575]                 }
[16:18:45.575]             }
[16:18:45.575]         }
[16:18:45.575]     })
[16:18:45.575]     if (TRUE) {
[16:18:45.575]         base::sink(type = "output", split = FALSE)
[16:18:45.575]         if (TRUE) {
[16:18:45.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.575]         }
[16:18:45.575]         else {
[16:18:45.575]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.575]         }
[16:18:45.575]         base::close(...future.stdout)
[16:18:45.575]         ...future.stdout <- NULL
[16:18:45.575]     }
[16:18:45.575]     ...future.result$conditions <- ...future.conditions
[16:18:45.575]     ...future.result$finished <- base::Sys.time()
[16:18:45.575]     ...future.result
[16:18:45.575] }
[16:18:45.578] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[16:18:45.578] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[16:18:45.578] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[16:18:45.579] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:45.579] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.579] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[16:18:45.579] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[16:18:45.580] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:45.580] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.580] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:45.580] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.580] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[16:18:45.581] MultisessionFuture started
[16:18:45.581] - Launch lazy future ... done
[16:18:45.581] run() for ‘MultisessionFuture’ ... done
[16:18:45.581] Created future:
[16:18:45.581] MultisessionFuture:
[16:18:45.581] Label: ‘future_.mapply-2’
[16:18:45.581] Expression:
[16:18:45.581] {
[16:18:45.581]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.581]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.581]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.581]         on.exit(options(oopts), add = TRUE)
[16:18:45.581]     }
[16:18:45.581]     {
[16:18:45.581]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.581]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.581]         do.call(mapply, args = args)
[16:18:45.581]     }
[16:18:45.581] }
[16:18:45.581] Lazy evaluation: FALSE
[16:18:45.581] Asynchronous evaluation: TRUE
[16:18:45.581] Local evaluation: TRUE
[16:18:45.581] Environment: R_GlobalEnv
[16:18:45.581] Capture standard output: TRUE
[16:18:45.581] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.581] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.581] Packages: <none>
[16:18:45.581] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.581] Resolved: FALSE
[16:18:45.581] Value: <not collected>
[16:18:45.581] Conditions captured: <none>
[16:18:45.581] Early signaling: FALSE
[16:18:45.581] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.581] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.593] Chunk #2 of 2 ... DONE
[16:18:45.593] Launching 2 futures (chunks) ... DONE
[16:18:45.593] Resolving 2 futures (chunks) ...
[16:18:45.593] resolve() on list ...
[16:18:45.593]  recursive: 0
[16:18:45.593]  length: 2
[16:18:45.593] 
[16:18:45.594] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.594] - Validating connection of MultisessionFuture
[16:18:45.594] - received message: FutureResult
[16:18:45.594] - Received FutureResult
[16:18:45.594] - Erased future from FutureRegistry
[16:18:45.594] result() for ClusterFuture ...
[16:18:45.594] - result already collected: FutureResult
[16:18:45.594] result() for ClusterFuture ... done
[16:18:45.594] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.595] Future #1
[16:18:45.595] result() for ClusterFuture ...
[16:18:45.595] - result already collected: FutureResult
[16:18:45.595] result() for ClusterFuture ... done
[16:18:45.595] result() for ClusterFuture ...
[16:18:45.595] - result already collected: FutureResult
[16:18:45.595] result() for ClusterFuture ... done
[16:18:45.595] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:45.595] - nx: 2
[16:18:45.595] - relay: TRUE
[16:18:45.595] - stdout: TRUE
[16:18:45.595] - signal: TRUE
[16:18:45.596] - resignal: FALSE
[16:18:45.596] - force: TRUE
[16:18:45.596] - relayed: [n=2] FALSE, FALSE
[16:18:45.596] - queued futures: [n=2] FALSE, FALSE
[16:18:45.596]  - until=1
[16:18:45.596]  - relaying element #1
[16:18:45.596] result() for ClusterFuture ...
[16:18:45.596] - result already collected: FutureResult
[16:18:45.596] result() for ClusterFuture ... done
[16:18:45.596] result() for ClusterFuture ...
[16:18:45.596] - result already collected: FutureResult
[16:18:45.597] result() for ClusterFuture ... done
[16:18:45.597] result() for ClusterFuture ...
[16:18:45.597] - result already collected: FutureResult
[16:18:45.597] result() for ClusterFuture ... done
[16:18:45.597] result() for ClusterFuture ...
[16:18:45.597] - result already collected: FutureResult
[16:18:45.597] result() for ClusterFuture ... done
[16:18:45.597] - relayed: [n=2] TRUE, FALSE
[16:18:45.597] - queued futures: [n=2] TRUE, FALSE
[16:18:45.597] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:45.597]  length: 1 (resolved future 1)
[16:18:45.626] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.626] - Validating connection of MultisessionFuture
[16:18:45.626] - received message: FutureResult
[16:18:45.626] - Received FutureResult
[16:18:45.626] - Erased future from FutureRegistry
[16:18:45.626] result() for ClusterFuture ...
[16:18:45.627] - result already collected: FutureResult
[16:18:45.627] result() for ClusterFuture ... done
[16:18:45.627] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.627] Future #2
[16:18:45.627] result() for ClusterFuture ...
[16:18:45.627] - result already collected: FutureResult
[16:18:45.627] result() for ClusterFuture ... done
[16:18:45.627] result() for ClusterFuture ...
[16:18:45.627] - result already collected: FutureResult
[16:18:45.627] result() for ClusterFuture ... done
[16:18:45.627] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:45.628] - nx: 2
[16:18:45.628] - relay: TRUE
[16:18:45.628] - stdout: TRUE
[16:18:45.628] - signal: TRUE
[16:18:45.628] - resignal: FALSE
[16:18:45.628] - force: TRUE
[16:18:45.628] - relayed: [n=2] TRUE, FALSE
[16:18:45.628] - queued futures: [n=2] TRUE, FALSE
[16:18:45.628]  - until=2
[16:18:45.628]  - relaying element #2
[16:18:45.628] result() for ClusterFuture ...
[16:18:45.628] - result already collected: FutureResult
[16:18:45.629] result() for ClusterFuture ... done
[16:18:45.629] result() for ClusterFuture ...
[16:18:45.629] - result already collected: FutureResult
[16:18:45.629] result() for ClusterFuture ... done
[16:18:45.629] result() for ClusterFuture ...
[16:18:45.629] - result already collected: FutureResult
[16:18:45.629] result() for ClusterFuture ... done
[16:18:45.629] result() for ClusterFuture ...
[16:18:45.629] - result already collected: FutureResult
[16:18:45.629] result() for ClusterFuture ... done
[16:18:45.629] - relayed: [n=2] TRUE, TRUE
[16:18:45.630] - queued futures: [n=2] TRUE, TRUE
[16:18:45.630] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:45.630]  length: 0 (resolved future 2)
[16:18:45.630] Relaying remaining futures
[16:18:45.630] signalConditionsASAP(NULL, pos=0) ...
[16:18:45.630] - nx: 2
[16:18:45.630] - relay: TRUE
[16:18:45.630] - stdout: TRUE
[16:18:45.630] - signal: TRUE
[16:18:45.630] - resignal: FALSE
[16:18:45.630] - force: TRUE
[16:18:45.630] - relayed: [n=2] TRUE, TRUE
[16:18:45.631] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:45.631] - relayed: [n=2] TRUE, TRUE
[16:18:45.631] - queued futures: [n=2] TRUE, TRUE
[16:18:45.631] signalConditionsASAP(NULL, pos=0) ... done
[16:18:45.631] resolve() on list ... DONE
[16:18:45.631] result() for ClusterFuture ...
[16:18:45.631] - result already collected: FutureResult
[16:18:45.631] result() for ClusterFuture ... done
[16:18:45.631] result() for ClusterFuture ...
[16:18:45.631] - result already collected: FutureResult
[16:18:45.631] result() for ClusterFuture ... done
[16:18:45.632] result() for ClusterFuture ...
[16:18:45.632] - result already collected: FutureResult
[16:18:45.632] result() for ClusterFuture ... done
[16:18:45.632] result() for ClusterFuture ...
[16:18:45.632] - result already collected: FutureResult
[16:18:45.632] result() for ClusterFuture ... done
[16:18:45.632]  - Number of value chunks collected: 2
[16:18:45.632] Resolving 2 futures (chunks) ... DONE
[16:18:45.632] Reducing values from 2 chunks ...
[16:18:45.632]  - Number of values collected after concatenation: 5
[16:18:45.633]  - Number of values expected: 5
[16:18:45.633] Reducing values from 2 chunks ... DONE
[16:18:45.633] future_mapply() ... DONE
[16:18:45.633] future_mapply() ...
[16:18:45.636] Number of chunks: 3
[16:18:45.637] Index remapping (attribute 'ordering'): [n = 5] 4, 5, 1, 3, 2
[16:18:45.637] getGlobalsAndPackagesXApply() ...
[16:18:45.637]  - future.globals: TRUE
[16:18:45.637] getGlobalsAndPackages() ...
[16:18:45.637] Searching for globals...
[16:18:45.638] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:45.638] Searching for globals ... DONE
[16:18:45.638] Resolving globals: FALSE
[16:18:45.639] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:45.639] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:45.639] - globals: [1] ‘FUN’
[16:18:45.639] 
[16:18:45.639] getGlobalsAndPackages() ... DONE
[16:18:45.640]  - globals found/used: [n=1] ‘FUN’
[16:18:45.640]  - needed namespaces: [n=0] 
[16:18:45.640] Finding globals ... DONE
[16:18:45.640] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:45.640] List of 2
[16:18:45.640]  $ ...future.FUN:function (C, k)  
[16:18:45.640]  $ MoreArgs     : NULL
[16:18:45.640]  - attr(*, "where")=List of 2
[16:18:45.640]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:45.640]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:45.640]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:45.640]  - attr(*, "resolved")= logi FALSE
[16:18:45.640]  - attr(*, "total_size")= num NA
[16:18:45.642] Packages to be attached in all futures: [n=0] 
[16:18:45.643] getGlobalsAndPackagesXApply() ... DONE
[16:18:45.643] Number of futures (= number of chunks): 3
[16:18:45.643] Launching 3 futures (chunks) ...
[16:18:45.643] Chunk #1 of 3 ...
[16:18:45.643]  - Finding globals in '...' for chunk #1 ...
[16:18:45.643] getGlobalsAndPackages() ...
[16:18:45.643] Searching for globals...
[16:18:45.644] 
[16:18:45.644] Searching for globals ... DONE
[16:18:45.644] - globals: [0] <none>
[16:18:45.644] getGlobalsAndPackages() ... DONE
[16:18:45.644]    + additional globals found: [n=0] 
[16:18:45.644]    + additional namespaces needed: [n=0] 
[16:18:45.644]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:45.644]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:18:45.644]  - seeds: <none>
[16:18:45.644]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.645] getGlobalsAndPackages() ...
[16:18:45.645] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.645] Resolving globals: FALSE
[16:18:45.645] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:45.646] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:45.646] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.646] 
[16:18:45.646] getGlobalsAndPackages() ... DONE
[16:18:45.646] run() for ‘Future’ ...
[16:18:45.646] - state: ‘created’
[16:18:45.647] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.660] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.660] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.660]   - Field: ‘node’
[16:18:45.660]   - Field: ‘label’
[16:18:45.661]   - Field: ‘local’
[16:18:45.661]   - Field: ‘owner’
[16:18:45.661]   - Field: ‘envir’
[16:18:45.661]   - Field: ‘workers’
[16:18:45.661]   - Field: ‘packages’
[16:18:45.661]   - Field: ‘gc’
[16:18:45.661]   - Field: ‘conditions’
[16:18:45.661]   - Field: ‘persistent’
[16:18:45.661]   - Field: ‘expr’
[16:18:45.661]   - Field: ‘uuid’
[16:18:45.661]   - Field: ‘seed’
[16:18:45.662]   - Field: ‘version’
[16:18:45.662]   - Field: ‘result’
[16:18:45.662]   - Field: ‘asynchronous’
[16:18:45.662]   - Field: ‘calls’
[16:18:45.662]   - Field: ‘globals’
[16:18:45.662]   - Field: ‘stdout’
[16:18:45.662]   - Field: ‘earlySignal’
[16:18:45.662]   - Field: ‘lazy’
[16:18:45.662]   - Field: ‘state’
[16:18:45.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.662] - Launch lazy future ...
[16:18:45.663] Packages needed by the future expression (n = 0): <none>
[16:18:45.663] Packages needed by future strategies (n = 0): <none>
[16:18:45.666] {
[16:18:45.666]     {
[16:18:45.666]         {
[16:18:45.666]             ...future.startTime <- base::Sys.time()
[16:18:45.666]             {
[16:18:45.666]                 {
[16:18:45.666]                   {
[16:18:45.666]                     {
[16:18:45.666]                       base::local({
[16:18:45.666]                         has_future <- base::requireNamespace("future", 
[16:18:45.666]                           quietly = TRUE)
[16:18:45.666]                         if (has_future) {
[16:18:45.666]                           ns <- base::getNamespace("future")
[16:18:45.666]                           version <- ns[[".package"]][["version"]]
[16:18:45.666]                           if (is.null(version)) 
[16:18:45.666]                             version <- utils::packageVersion("future")
[16:18:45.666]                         }
[16:18:45.666]                         else {
[16:18:45.666]                           version <- NULL
[16:18:45.666]                         }
[16:18:45.666]                         if (!has_future || version < "1.8.0") {
[16:18:45.666]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.666]                             "", base::R.version$version.string), 
[16:18:45.666]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.666]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.666]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.666]                               "release", "version")], collapse = " "), 
[16:18:45.666]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.666]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.666]                             info)
[16:18:45.666]                           info <- base::paste(info, collapse = "; ")
[16:18:45.666]                           if (!has_future) {
[16:18:45.666]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.666]                               info)
[16:18:45.666]                           }
[16:18:45.666]                           else {
[16:18:45.666]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.666]                               info, version)
[16:18:45.666]                           }
[16:18:45.666]                           base::stop(msg)
[16:18:45.666]                         }
[16:18:45.666]                       })
[16:18:45.666]                     }
[16:18:45.666]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.666]                     base::options(mc.cores = 1L)
[16:18:45.666]                   }
[16:18:45.666]                   ...future.strategy.old <- future::plan("list")
[16:18:45.666]                   options(future.plan = NULL)
[16:18:45.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.666]                 }
[16:18:45.666]                 ...future.workdir <- getwd()
[16:18:45.666]             }
[16:18:45.666]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.666]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.666]         }
[16:18:45.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.666]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:18:45.666]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.666]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.666]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.666]             base::names(...future.oldOptions))
[16:18:45.666]     }
[16:18:45.666]     if (FALSE) {
[16:18:45.666]     }
[16:18:45.666]     else {
[16:18:45.666]         if (TRUE) {
[16:18:45.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.666]                 open = "w")
[16:18:45.666]         }
[16:18:45.666]         else {
[16:18:45.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.666]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.666]         }
[16:18:45.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.666]             base::sink(type = "output", split = FALSE)
[16:18:45.666]             base::close(...future.stdout)
[16:18:45.666]         }, add = TRUE)
[16:18:45.666]     }
[16:18:45.666]     ...future.frame <- base::sys.nframe()
[16:18:45.666]     ...future.conditions <- base::list()
[16:18:45.666]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.666]     if (FALSE) {
[16:18:45.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.666]     }
[16:18:45.666]     ...future.result <- base::tryCatch({
[16:18:45.666]         base::withCallingHandlers({
[16:18:45.666]             ...future.value <- base::withVisible(base::local({
[16:18:45.666]                 ...future.makeSendCondition <- base::local({
[16:18:45.666]                   sendCondition <- NULL
[16:18:45.666]                   function(frame = 1L) {
[16:18:45.666]                     if (is.function(sendCondition)) 
[16:18:45.666]                       return(sendCondition)
[16:18:45.666]                     ns <- getNamespace("parallel")
[16:18:45.666]                     if (exists("sendData", mode = "function", 
[16:18:45.666]                       envir = ns)) {
[16:18:45.666]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.666]                         envir = ns)
[16:18:45.666]                       envir <- sys.frame(frame)
[16:18:45.666]                       master <- NULL
[16:18:45.666]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.666]                         !identical(envir, emptyenv())) {
[16:18:45.666]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.666]                           inherits = FALSE)) {
[16:18:45.666]                           master <- get("master", mode = "list", 
[16:18:45.666]                             envir = envir, inherits = FALSE)
[16:18:45.666]                           if (inherits(master, c("SOCKnode", 
[16:18:45.666]                             "SOCK0node"))) {
[16:18:45.666]                             sendCondition <<- function(cond) {
[16:18:45.666]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.666]                                 success = TRUE)
[16:18:45.666]                               parallel_sendData(master, data)
[16:18:45.666]                             }
[16:18:45.666]                             return(sendCondition)
[16:18:45.666]                           }
[16:18:45.666]                         }
[16:18:45.666]                         frame <- frame + 1L
[16:18:45.666]                         envir <- sys.frame(frame)
[16:18:45.666]                       }
[16:18:45.666]                     }
[16:18:45.666]                     sendCondition <<- function(cond) NULL
[16:18:45.666]                   }
[16:18:45.666]                 })
[16:18:45.666]                 withCallingHandlers({
[16:18:45.666]                   {
[16:18:45.666]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.666]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.666]                       ...future.globals.maxSize)) {
[16:18:45.666]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.666]                       on.exit(options(oopts), add = TRUE)
[16:18:45.666]                     }
[16:18:45.666]                     {
[16:18:45.666]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.666]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.666]                         USE.NAMES = FALSE)
[16:18:45.666]                       do.call(mapply, args = args)
[16:18:45.666]                     }
[16:18:45.666]                   }
[16:18:45.666]                 }, immediateCondition = function(cond) {
[16:18:45.666]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.666]                   sendCondition(cond)
[16:18:45.666]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.666]                   {
[16:18:45.666]                     inherits <- base::inherits
[16:18:45.666]                     invokeRestart <- base::invokeRestart
[16:18:45.666]                     is.null <- base::is.null
[16:18:45.666]                     muffled <- FALSE
[16:18:45.666]                     if (inherits(cond, "message")) {
[16:18:45.666]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.666]                       if (muffled) 
[16:18:45.666]                         invokeRestart("muffleMessage")
[16:18:45.666]                     }
[16:18:45.666]                     else if (inherits(cond, "warning")) {
[16:18:45.666]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.666]                       if (muffled) 
[16:18:45.666]                         invokeRestart("muffleWarning")
[16:18:45.666]                     }
[16:18:45.666]                     else if (inherits(cond, "condition")) {
[16:18:45.666]                       if (!is.null(pattern)) {
[16:18:45.666]                         computeRestarts <- base::computeRestarts
[16:18:45.666]                         grepl <- base::grepl
[16:18:45.666]                         restarts <- computeRestarts(cond)
[16:18:45.666]                         for (restart in restarts) {
[16:18:45.666]                           name <- restart$name
[16:18:45.666]                           if (is.null(name)) 
[16:18:45.666]                             next
[16:18:45.666]                           if (!grepl(pattern, name)) 
[16:18:45.666]                             next
[16:18:45.666]                           invokeRestart(restart)
[16:18:45.666]                           muffled <- TRUE
[16:18:45.666]                           break
[16:18:45.666]                         }
[16:18:45.666]                       }
[16:18:45.666]                     }
[16:18:45.666]                     invisible(muffled)
[16:18:45.666]                   }
[16:18:45.666]                   muffleCondition(cond)
[16:18:45.666]                 })
[16:18:45.666]             }))
[16:18:45.666]             future::FutureResult(value = ...future.value$value, 
[16:18:45.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.666]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.666]                     ...future.globalenv.names))
[16:18:45.666]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.666]         }, condition = base::local({
[16:18:45.666]             c <- base::c
[16:18:45.666]             inherits <- base::inherits
[16:18:45.666]             invokeRestart <- base::invokeRestart
[16:18:45.666]             length <- base::length
[16:18:45.666]             list <- base::list
[16:18:45.666]             seq.int <- base::seq.int
[16:18:45.666]             signalCondition <- base::signalCondition
[16:18:45.666]             sys.calls <- base::sys.calls
[16:18:45.666]             `[[` <- base::`[[`
[16:18:45.666]             `+` <- base::`+`
[16:18:45.666]             `<<-` <- base::`<<-`
[16:18:45.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.666]                   3L)]
[16:18:45.666]             }
[16:18:45.666]             function(cond) {
[16:18:45.666]                 is_error <- inherits(cond, "error")
[16:18:45.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.666]                   NULL)
[16:18:45.666]                 if (is_error) {
[16:18:45.666]                   sessionInformation <- function() {
[16:18:45.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.666]                       search = base::search(), system = base::Sys.info())
[16:18:45.666]                   }
[16:18:45.666]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.666]                     cond$call), session = sessionInformation(), 
[16:18:45.666]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.666]                   signalCondition(cond)
[16:18:45.666]                 }
[16:18:45.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.666]                 "immediateCondition"))) {
[16:18:45.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.666]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.666]                   if (TRUE && !signal) {
[16:18:45.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.666]                     {
[16:18:45.666]                       inherits <- base::inherits
[16:18:45.666]                       invokeRestart <- base::invokeRestart
[16:18:45.666]                       is.null <- base::is.null
[16:18:45.666]                       muffled <- FALSE
[16:18:45.666]                       if (inherits(cond, "message")) {
[16:18:45.666]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.666]                         if (muffled) 
[16:18:45.666]                           invokeRestart("muffleMessage")
[16:18:45.666]                       }
[16:18:45.666]                       else if (inherits(cond, "warning")) {
[16:18:45.666]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.666]                         if (muffled) 
[16:18:45.666]                           invokeRestart("muffleWarning")
[16:18:45.666]                       }
[16:18:45.666]                       else if (inherits(cond, "condition")) {
[16:18:45.666]                         if (!is.null(pattern)) {
[16:18:45.666]                           computeRestarts <- base::computeRestarts
[16:18:45.666]                           grepl <- base::grepl
[16:18:45.666]                           restarts <- computeRestarts(cond)
[16:18:45.666]                           for (restart in restarts) {
[16:18:45.666]                             name <- restart$name
[16:18:45.666]                             if (is.null(name)) 
[16:18:45.666]                               next
[16:18:45.666]                             if (!grepl(pattern, name)) 
[16:18:45.666]                               next
[16:18:45.666]                             invokeRestart(restart)
[16:18:45.666]                             muffled <- TRUE
[16:18:45.666]                             break
[16:18:45.666]                           }
[16:18:45.666]                         }
[16:18:45.666]                       }
[16:18:45.666]                       invisible(muffled)
[16:18:45.666]                     }
[16:18:45.666]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.666]                   }
[16:18:45.666]                 }
[16:18:45.666]                 else {
[16:18:45.666]                   if (TRUE) {
[16:18:45.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.666]                     {
[16:18:45.666]                       inherits <- base::inherits
[16:18:45.666]                       invokeRestart <- base::invokeRestart
[16:18:45.666]                       is.null <- base::is.null
[16:18:45.666]                       muffled <- FALSE
[16:18:45.666]                       if (inherits(cond, "message")) {
[16:18:45.666]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.666]                         if (muffled) 
[16:18:45.666]                           invokeRestart("muffleMessage")
[16:18:45.666]                       }
[16:18:45.666]                       else if (inherits(cond, "warning")) {
[16:18:45.666]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.666]                         if (muffled) 
[16:18:45.666]                           invokeRestart("muffleWarning")
[16:18:45.666]                       }
[16:18:45.666]                       else if (inherits(cond, "condition")) {
[16:18:45.666]                         if (!is.null(pattern)) {
[16:18:45.666]                           computeRestarts <- base::computeRestarts
[16:18:45.666]                           grepl <- base::grepl
[16:18:45.666]                           restarts <- computeRestarts(cond)
[16:18:45.666]                           for (restart in restarts) {
[16:18:45.666]                             name <- restart$name
[16:18:45.666]                             if (is.null(name)) 
[16:18:45.666]                               next
[16:18:45.666]                             if (!grepl(pattern, name)) 
[16:18:45.666]                               next
[16:18:45.666]                             invokeRestart(restart)
[16:18:45.666]                             muffled <- TRUE
[16:18:45.666]                             break
[16:18:45.666]                           }
[16:18:45.666]                         }
[16:18:45.666]                       }
[16:18:45.666]                       invisible(muffled)
[16:18:45.666]                     }
[16:18:45.666]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.666]                   }
[16:18:45.666]                 }
[16:18:45.666]             }
[16:18:45.666]         }))
[16:18:45.666]     }, error = function(ex) {
[16:18:45.666]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.666]                 ...future.rng), started = ...future.startTime, 
[16:18:45.666]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.666]             version = "1.8"), class = "FutureResult")
[16:18:45.666]     }, finally = {
[16:18:45.666]         if (!identical(...future.workdir, getwd())) 
[16:18:45.666]             setwd(...future.workdir)
[16:18:45.666]         {
[16:18:45.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.666]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.666]             }
[16:18:45.666]             base::options(...future.oldOptions)
[16:18:45.666]             if (.Platform$OS.type == "windows") {
[16:18:45.666]                 old_names <- names(...future.oldEnvVars)
[16:18:45.666]                 envs <- base::Sys.getenv()
[16:18:45.666]                 names <- names(envs)
[16:18:45.666]                 common <- intersect(names, old_names)
[16:18:45.666]                 added <- setdiff(names, old_names)
[16:18:45.666]                 removed <- setdiff(old_names, names)
[16:18:45.666]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.666]                   envs[common]]
[16:18:45.666]                 NAMES <- toupper(changed)
[16:18:45.666]                 args <- list()
[16:18:45.666]                 for (kk in seq_along(NAMES)) {
[16:18:45.666]                   name <- changed[[kk]]
[16:18:45.666]                   NAME <- NAMES[[kk]]
[16:18:45.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.666]                     next
[16:18:45.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.666]                 }
[16:18:45.666]                 NAMES <- toupper(added)
[16:18:45.666]                 for (kk in seq_along(NAMES)) {
[16:18:45.666]                   name <- added[[kk]]
[16:18:45.666]                   NAME <- NAMES[[kk]]
[16:18:45.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.666]                     next
[16:18:45.666]                   args[[name]] <- ""
[16:18:45.666]                 }
[16:18:45.666]                 NAMES <- toupper(removed)
[16:18:45.666]                 for (kk in seq_along(NAMES)) {
[16:18:45.666]                   name <- removed[[kk]]
[16:18:45.666]                   NAME <- NAMES[[kk]]
[16:18:45.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.666]                     next
[16:18:45.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.666]                 }
[16:18:45.666]                 if (length(args) > 0) 
[16:18:45.666]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.666]             }
[16:18:45.666]             else {
[16:18:45.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.666]             }
[16:18:45.666]             {
[16:18:45.666]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.666]                   0L) {
[16:18:45.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.666]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.666]                   base::options(opts)
[16:18:45.666]                 }
[16:18:45.666]                 {
[16:18:45.666]                   {
[16:18:45.666]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.666]                     NULL
[16:18:45.666]                   }
[16:18:45.666]                   options(future.plan = NULL)
[16:18:45.666]                   if (is.na(NA_character_)) 
[16:18:45.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.666]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.666]                     .init = FALSE)
[16:18:45.666]                 }
[16:18:45.666]             }
[16:18:45.666]         }
[16:18:45.666]     })
[16:18:45.666]     if (TRUE) {
[16:18:45.666]         base::sink(type = "output", split = FALSE)
[16:18:45.666]         if (TRUE) {
[16:18:45.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.666]         }
[16:18:45.666]         else {
[16:18:45.666]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.666]         }
[16:18:45.666]         base::close(...future.stdout)
[16:18:45.666]         ...future.stdout <- NULL
[16:18:45.666]     }
[16:18:45.666]     ...future.result$conditions <- ...future.conditions
[16:18:45.666]     ...future.result$finished <- base::Sys.time()
[16:18:45.666]     ...future.result
[16:18:45.666] }
[16:18:45.668] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[16:18:45.668] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[16:18:45.669] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[16:18:45.669] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:45.669] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.669] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[16:18:45.670] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[16:18:45.670] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:45.670] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.670] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:45.670] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.670] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[16:18:45.671] MultisessionFuture started
[16:18:45.671] - Launch lazy future ... done
[16:18:45.671] run() for ‘MultisessionFuture’ ... done
[16:18:45.671] Created future:
[16:18:45.671] MultisessionFuture:
[16:18:45.671] Label: ‘future_mapply-1’
[16:18:45.671] Expression:
[16:18:45.671] {
[16:18:45.671]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.671]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.671]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.671]         on.exit(options(oopts), add = TRUE)
[16:18:45.671]     }
[16:18:45.671]     {
[16:18:45.671]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.671]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.671]         do.call(mapply, args = args)
[16:18:45.671]     }
[16:18:45.671] }
[16:18:45.671] Lazy evaluation: FALSE
[16:18:45.671] Asynchronous evaluation: TRUE
[16:18:45.671] Local evaluation: TRUE
[16:18:45.671] Environment: R_GlobalEnv
[16:18:45.671] Capture standard output: TRUE
[16:18:45.671] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.671] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.671] Packages: <none>
[16:18:45.671] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.671] Resolved: FALSE
[16:18:45.671] Value: <not collected>
[16:18:45.671] Conditions captured: <none>
[16:18:45.671] Early signaling: FALSE
[16:18:45.671] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.671] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.683] Chunk #1 of 3 ... DONE
[16:18:45.683] Chunk #2 of 3 ...
[16:18:45.683]  - Finding globals in '...' for chunk #2 ...
[16:18:45.683] getGlobalsAndPackages() ...
[16:18:45.683] Searching for globals...
[16:18:45.683] 
[16:18:45.683] Searching for globals ... DONE
[16:18:45.684] - globals: [0] <none>
[16:18:45.684] getGlobalsAndPackages() ... DONE
[16:18:45.684]    + additional globals found: [n=0] 
[16:18:45.684]    + additional namespaces needed: [n=0] 
[16:18:45.684]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:45.684]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:18:45.684]  - seeds: <none>
[16:18:45.684]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.684] getGlobalsAndPackages() ...
[16:18:45.684] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.685] Resolving globals: FALSE
[16:18:45.685] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[16:18:45.685] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:45.685] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.686] 
[16:18:45.686] getGlobalsAndPackages() ... DONE
[16:18:45.686] run() for ‘Future’ ...
[16:18:45.686] - state: ‘created’
[16:18:45.686] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.699] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.700]   - Field: ‘node’
[16:18:45.700]   - Field: ‘label’
[16:18:45.700]   - Field: ‘local’
[16:18:45.700]   - Field: ‘owner’
[16:18:45.700]   - Field: ‘envir’
[16:18:45.700]   - Field: ‘workers’
[16:18:45.700]   - Field: ‘packages’
[16:18:45.700]   - Field: ‘gc’
[16:18:45.700]   - Field: ‘conditions’
[16:18:45.700]   - Field: ‘persistent’
[16:18:45.701]   - Field: ‘expr’
[16:18:45.701]   - Field: ‘uuid’
[16:18:45.701]   - Field: ‘seed’
[16:18:45.701]   - Field: ‘version’
[16:18:45.701]   - Field: ‘result’
[16:18:45.701]   - Field: ‘asynchronous’
[16:18:45.701]   - Field: ‘calls’
[16:18:45.701]   - Field: ‘globals’
[16:18:45.701]   - Field: ‘stdout’
[16:18:45.701]   - Field: ‘earlySignal’
[16:18:45.701]   - Field: ‘lazy’
[16:18:45.702]   - Field: ‘state’
[16:18:45.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.702] - Launch lazy future ...
[16:18:45.702] Packages needed by the future expression (n = 0): <none>
[16:18:45.702] Packages needed by future strategies (n = 0): <none>
[16:18:45.702] {
[16:18:45.702]     {
[16:18:45.702]         {
[16:18:45.702]             ...future.startTime <- base::Sys.time()
[16:18:45.702]             {
[16:18:45.702]                 {
[16:18:45.702]                   {
[16:18:45.702]                     {
[16:18:45.702]                       base::local({
[16:18:45.702]                         has_future <- base::requireNamespace("future", 
[16:18:45.702]                           quietly = TRUE)
[16:18:45.702]                         if (has_future) {
[16:18:45.702]                           ns <- base::getNamespace("future")
[16:18:45.702]                           version <- ns[[".package"]][["version"]]
[16:18:45.702]                           if (is.null(version)) 
[16:18:45.702]                             version <- utils::packageVersion("future")
[16:18:45.702]                         }
[16:18:45.702]                         else {
[16:18:45.702]                           version <- NULL
[16:18:45.702]                         }
[16:18:45.702]                         if (!has_future || version < "1.8.0") {
[16:18:45.702]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.702]                             "", base::R.version$version.string), 
[16:18:45.702]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.702]                               "release", "version")], collapse = " "), 
[16:18:45.702]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.702]                             info)
[16:18:45.702]                           info <- base::paste(info, collapse = "; ")
[16:18:45.702]                           if (!has_future) {
[16:18:45.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.702]                               info)
[16:18:45.702]                           }
[16:18:45.702]                           else {
[16:18:45.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.702]                               info, version)
[16:18:45.702]                           }
[16:18:45.702]                           base::stop(msg)
[16:18:45.702]                         }
[16:18:45.702]                       })
[16:18:45.702]                     }
[16:18:45.702]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.702]                     base::options(mc.cores = 1L)
[16:18:45.702]                   }
[16:18:45.702]                   ...future.strategy.old <- future::plan("list")
[16:18:45.702]                   options(future.plan = NULL)
[16:18:45.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.702]                 }
[16:18:45.702]                 ...future.workdir <- getwd()
[16:18:45.702]             }
[16:18:45.702]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.702]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.702]         }
[16:18:45.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.702]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:18:45.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.702]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.702]             base::names(...future.oldOptions))
[16:18:45.702]     }
[16:18:45.702]     if (FALSE) {
[16:18:45.702]     }
[16:18:45.702]     else {
[16:18:45.702]         if (TRUE) {
[16:18:45.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.702]                 open = "w")
[16:18:45.702]         }
[16:18:45.702]         else {
[16:18:45.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.702]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.702]         }
[16:18:45.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.702]             base::sink(type = "output", split = FALSE)
[16:18:45.702]             base::close(...future.stdout)
[16:18:45.702]         }, add = TRUE)
[16:18:45.702]     }
[16:18:45.702]     ...future.frame <- base::sys.nframe()
[16:18:45.702]     ...future.conditions <- base::list()
[16:18:45.702]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.702]     if (FALSE) {
[16:18:45.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.702]     }
[16:18:45.702]     ...future.result <- base::tryCatch({
[16:18:45.702]         base::withCallingHandlers({
[16:18:45.702]             ...future.value <- base::withVisible(base::local({
[16:18:45.702]                 ...future.makeSendCondition <- base::local({
[16:18:45.702]                   sendCondition <- NULL
[16:18:45.702]                   function(frame = 1L) {
[16:18:45.702]                     if (is.function(sendCondition)) 
[16:18:45.702]                       return(sendCondition)
[16:18:45.702]                     ns <- getNamespace("parallel")
[16:18:45.702]                     if (exists("sendData", mode = "function", 
[16:18:45.702]                       envir = ns)) {
[16:18:45.702]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.702]                         envir = ns)
[16:18:45.702]                       envir <- sys.frame(frame)
[16:18:45.702]                       master <- NULL
[16:18:45.702]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.702]                         !identical(envir, emptyenv())) {
[16:18:45.702]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.702]                           inherits = FALSE)) {
[16:18:45.702]                           master <- get("master", mode = "list", 
[16:18:45.702]                             envir = envir, inherits = FALSE)
[16:18:45.702]                           if (inherits(master, c("SOCKnode", 
[16:18:45.702]                             "SOCK0node"))) {
[16:18:45.702]                             sendCondition <<- function(cond) {
[16:18:45.702]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.702]                                 success = TRUE)
[16:18:45.702]                               parallel_sendData(master, data)
[16:18:45.702]                             }
[16:18:45.702]                             return(sendCondition)
[16:18:45.702]                           }
[16:18:45.702]                         }
[16:18:45.702]                         frame <- frame + 1L
[16:18:45.702]                         envir <- sys.frame(frame)
[16:18:45.702]                       }
[16:18:45.702]                     }
[16:18:45.702]                     sendCondition <<- function(cond) NULL
[16:18:45.702]                   }
[16:18:45.702]                 })
[16:18:45.702]                 withCallingHandlers({
[16:18:45.702]                   {
[16:18:45.702]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.702]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.702]                       ...future.globals.maxSize)) {
[16:18:45.702]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.702]                       on.exit(options(oopts), add = TRUE)
[16:18:45.702]                     }
[16:18:45.702]                     {
[16:18:45.702]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.702]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.702]                         USE.NAMES = FALSE)
[16:18:45.702]                       do.call(mapply, args = args)
[16:18:45.702]                     }
[16:18:45.702]                   }
[16:18:45.702]                 }, immediateCondition = function(cond) {
[16:18:45.702]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.702]                   sendCondition(cond)
[16:18:45.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.702]                   {
[16:18:45.702]                     inherits <- base::inherits
[16:18:45.702]                     invokeRestart <- base::invokeRestart
[16:18:45.702]                     is.null <- base::is.null
[16:18:45.702]                     muffled <- FALSE
[16:18:45.702]                     if (inherits(cond, "message")) {
[16:18:45.702]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.702]                       if (muffled) 
[16:18:45.702]                         invokeRestart("muffleMessage")
[16:18:45.702]                     }
[16:18:45.702]                     else if (inherits(cond, "warning")) {
[16:18:45.702]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.702]                       if (muffled) 
[16:18:45.702]                         invokeRestart("muffleWarning")
[16:18:45.702]                     }
[16:18:45.702]                     else if (inherits(cond, "condition")) {
[16:18:45.702]                       if (!is.null(pattern)) {
[16:18:45.702]                         computeRestarts <- base::computeRestarts
[16:18:45.702]                         grepl <- base::grepl
[16:18:45.702]                         restarts <- computeRestarts(cond)
[16:18:45.702]                         for (restart in restarts) {
[16:18:45.702]                           name <- restart$name
[16:18:45.702]                           if (is.null(name)) 
[16:18:45.702]                             next
[16:18:45.702]                           if (!grepl(pattern, name)) 
[16:18:45.702]                             next
[16:18:45.702]                           invokeRestart(restart)
[16:18:45.702]                           muffled <- TRUE
[16:18:45.702]                           break
[16:18:45.702]                         }
[16:18:45.702]                       }
[16:18:45.702]                     }
[16:18:45.702]                     invisible(muffled)
[16:18:45.702]                   }
[16:18:45.702]                   muffleCondition(cond)
[16:18:45.702]                 })
[16:18:45.702]             }))
[16:18:45.702]             future::FutureResult(value = ...future.value$value, 
[16:18:45.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.702]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.702]                     ...future.globalenv.names))
[16:18:45.702]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.702]         }, condition = base::local({
[16:18:45.702]             c <- base::c
[16:18:45.702]             inherits <- base::inherits
[16:18:45.702]             invokeRestart <- base::invokeRestart
[16:18:45.702]             length <- base::length
[16:18:45.702]             list <- base::list
[16:18:45.702]             seq.int <- base::seq.int
[16:18:45.702]             signalCondition <- base::signalCondition
[16:18:45.702]             sys.calls <- base::sys.calls
[16:18:45.702]             `[[` <- base::`[[`
[16:18:45.702]             `+` <- base::`+`
[16:18:45.702]             `<<-` <- base::`<<-`
[16:18:45.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.702]                   3L)]
[16:18:45.702]             }
[16:18:45.702]             function(cond) {
[16:18:45.702]                 is_error <- inherits(cond, "error")
[16:18:45.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.702]                   NULL)
[16:18:45.702]                 if (is_error) {
[16:18:45.702]                   sessionInformation <- function() {
[16:18:45.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.702]                       search = base::search(), system = base::Sys.info())
[16:18:45.702]                   }
[16:18:45.702]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.702]                     cond$call), session = sessionInformation(), 
[16:18:45.702]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.702]                   signalCondition(cond)
[16:18:45.702]                 }
[16:18:45.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.702]                 "immediateCondition"))) {
[16:18:45.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.702]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.702]                   if (TRUE && !signal) {
[16:18:45.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.702]                     {
[16:18:45.702]                       inherits <- base::inherits
[16:18:45.702]                       invokeRestart <- base::invokeRestart
[16:18:45.702]                       is.null <- base::is.null
[16:18:45.702]                       muffled <- FALSE
[16:18:45.702]                       if (inherits(cond, "message")) {
[16:18:45.702]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.702]                         if (muffled) 
[16:18:45.702]                           invokeRestart("muffleMessage")
[16:18:45.702]                       }
[16:18:45.702]                       else if (inherits(cond, "warning")) {
[16:18:45.702]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.702]                         if (muffled) 
[16:18:45.702]                           invokeRestart("muffleWarning")
[16:18:45.702]                       }
[16:18:45.702]                       else if (inherits(cond, "condition")) {
[16:18:45.702]                         if (!is.null(pattern)) {
[16:18:45.702]                           computeRestarts <- base::computeRestarts
[16:18:45.702]                           grepl <- base::grepl
[16:18:45.702]                           restarts <- computeRestarts(cond)
[16:18:45.702]                           for (restart in restarts) {
[16:18:45.702]                             name <- restart$name
[16:18:45.702]                             if (is.null(name)) 
[16:18:45.702]                               next
[16:18:45.702]                             if (!grepl(pattern, name)) 
[16:18:45.702]                               next
[16:18:45.702]                             invokeRestart(restart)
[16:18:45.702]                             muffled <- TRUE
[16:18:45.702]                             break
[16:18:45.702]                           }
[16:18:45.702]                         }
[16:18:45.702]                       }
[16:18:45.702]                       invisible(muffled)
[16:18:45.702]                     }
[16:18:45.702]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.702]                   }
[16:18:45.702]                 }
[16:18:45.702]                 else {
[16:18:45.702]                   if (TRUE) {
[16:18:45.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.702]                     {
[16:18:45.702]                       inherits <- base::inherits
[16:18:45.702]                       invokeRestart <- base::invokeRestart
[16:18:45.702]                       is.null <- base::is.null
[16:18:45.702]                       muffled <- FALSE
[16:18:45.702]                       if (inherits(cond, "message")) {
[16:18:45.702]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.702]                         if (muffled) 
[16:18:45.702]                           invokeRestart("muffleMessage")
[16:18:45.702]                       }
[16:18:45.702]                       else if (inherits(cond, "warning")) {
[16:18:45.702]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.702]                         if (muffled) 
[16:18:45.702]                           invokeRestart("muffleWarning")
[16:18:45.702]                       }
[16:18:45.702]                       else if (inherits(cond, "condition")) {
[16:18:45.702]                         if (!is.null(pattern)) {
[16:18:45.702]                           computeRestarts <- base::computeRestarts
[16:18:45.702]                           grepl <- base::grepl
[16:18:45.702]                           restarts <- computeRestarts(cond)
[16:18:45.702]                           for (restart in restarts) {
[16:18:45.702]                             name <- restart$name
[16:18:45.702]                             if (is.null(name)) 
[16:18:45.702]                               next
[16:18:45.702]                             if (!grepl(pattern, name)) 
[16:18:45.702]                               next
[16:18:45.702]                             invokeRestart(restart)
[16:18:45.702]                             muffled <- TRUE
[16:18:45.702]                             break
[16:18:45.702]                           }
[16:18:45.702]                         }
[16:18:45.702]                       }
[16:18:45.702]                       invisible(muffled)
[16:18:45.702]                     }
[16:18:45.702]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.702]                   }
[16:18:45.702]                 }
[16:18:45.702]             }
[16:18:45.702]         }))
[16:18:45.702]     }, error = function(ex) {
[16:18:45.702]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.702]                 ...future.rng), started = ...future.startTime, 
[16:18:45.702]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.702]             version = "1.8"), class = "FutureResult")
[16:18:45.702]     }, finally = {
[16:18:45.702]         if (!identical(...future.workdir, getwd())) 
[16:18:45.702]             setwd(...future.workdir)
[16:18:45.702]         {
[16:18:45.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.702]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.702]             }
[16:18:45.702]             base::options(...future.oldOptions)
[16:18:45.702]             if (.Platform$OS.type == "windows") {
[16:18:45.702]                 old_names <- names(...future.oldEnvVars)
[16:18:45.702]                 envs <- base::Sys.getenv()
[16:18:45.702]                 names <- names(envs)
[16:18:45.702]                 common <- intersect(names, old_names)
[16:18:45.702]                 added <- setdiff(names, old_names)
[16:18:45.702]                 removed <- setdiff(old_names, names)
[16:18:45.702]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.702]                   envs[common]]
[16:18:45.702]                 NAMES <- toupper(changed)
[16:18:45.702]                 args <- list()
[16:18:45.702]                 for (kk in seq_along(NAMES)) {
[16:18:45.702]                   name <- changed[[kk]]
[16:18:45.702]                   NAME <- NAMES[[kk]]
[16:18:45.702]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.702]                     next
[16:18:45.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.702]                 }
[16:18:45.702]                 NAMES <- toupper(added)
[16:18:45.702]                 for (kk in seq_along(NAMES)) {
[16:18:45.702]                   name <- added[[kk]]
[16:18:45.702]                   NAME <- NAMES[[kk]]
[16:18:45.702]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.702]                     next
[16:18:45.702]                   args[[name]] <- ""
[16:18:45.702]                 }
[16:18:45.702]                 NAMES <- toupper(removed)
[16:18:45.702]                 for (kk in seq_along(NAMES)) {
[16:18:45.702]                   name <- removed[[kk]]
[16:18:45.702]                   NAME <- NAMES[[kk]]
[16:18:45.702]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.702]                     next
[16:18:45.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.702]                 }
[16:18:45.702]                 if (length(args) > 0) 
[16:18:45.702]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.702]             }
[16:18:45.702]             else {
[16:18:45.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.702]             }
[16:18:45.702]             {
[16:18:45.702]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.702]                   0L) {
[16:18:45.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.702]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.702]                   base::options(opts)
[16:18:45.702]                 }
[16:18:45.702]                 {
[16:18:45.702]                   {
[16:18:45.702]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.702]                     NULL
[16:18:45.702]                   }
[16:18:45.702]                   options(future.plan = NULL)
[16:18:45.702]                   if (is.na(NA_character_)) 
[16:18:45.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.702]                     .init = FALSE)
[16:18:45.702]                 }
[16:18:45.702]             }
[16:18:45.702]         }
[16:18:45.702]     })
[16:18:45.702]     if (TRUE) {
[16:18:45.702]         base::sink(type = "output", split = FALSE)
[16:18:45.702]         if (TRUE) {
[16:18:45.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.702]         }
[16:18:45.702]         else {
[16:18:45.702]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.702]         }
[16:18:45.702]         base::close(...future.stdout)
[16:18:45.702]         ...future.stdout <- NULL
[16:18:45.702]     }
[16:18:45.702]     ...future.result$conditions <- ...future.conditions
[16:18:45.702]     ...future.result$finished <- base::Sys.time()
[16:18:45.702]     ...future.result
[16:18:45.702] }
[16:18:45.705] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[16:18:45.705] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[16:18:45.706] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[16:18:45.706] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:45.706] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.706] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[16:18:45.706] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[16:18:45.707] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:45.707] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.707] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:45.707] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.707] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[16:18:45.708] MultisessionFuture started
[16:18:45.708] - Launch lazy future ... done
[16:18:45.708] run() for ‘MultisessionFuture’ ... done
[16:18:45.708] Created future:
[16:18:45.708] MultisessionFuture:
[16:18:45.708] Label: ‘future_mapply-2’
[16:18:45.708] Expression:
[16:18:45.708] {
[16:18:45.708]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.708]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.708]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.708]         on.exit(options(oopts), add = TRUE)
[16:18:45.708]     }
[16:18:45.708]     {
[16:18:45.708]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.708]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.708]         do.call(mapply, args = args)
[16:18:45.708]     }
[16:18:45.708] }
[16:18:45.708] Lazy evaluation: FALSE
[16:18:45.708] Asynchronous evaluation: TRUE
[16:18:45.708] Local evaluation: TRUE
[16:18:45.708] Environment: R_GlobalEnv
[16:18:45.708] Capture standard output: TRUE
[16:18:45.708] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.708] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.708] Packages: <none>
[16:18:45.708] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.708] Resolved: FALSE
[16:18:45.708] Value: <not collected>
[16:18:45.708] Conditions captured: <none>
[16:18:45.708] Early signaling: FALSE
[16:18:45.708] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.708] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.720] Chunk #2 of 3 ... DONE
[16:18:45.720] Chunk #3 of 3 ...
[16:18:45.720]  - Finding globals in '...' for chunk #3 ...
[16:18:45.720] getGlobalsAndPackages() ...
[16:18:45.720] Searching for globals...
[16:18:45.720] 
[16:18:45.720] Searching for globals ... DONE
[16:18:45.721] - globals: [0] <none>
[16:18:45.721] getGlobalsAndPackages() ... DONE
[16:18:45.721]    + additional globals found: [n=0] 
[16:18:45.721]    + additional namespaces needed: [n=0] 
[16:18:45.721]  - Finding globals in '...' for chunk #3 ... DONE
[16:18:45.721]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:18:45.721]  - seeds: <none>
[16:18:45.721]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.721] getGlobalsAndPackages() ...
[16:18:45.721] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.722] Resolving globals: FALSE
[16:18:45.722] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:45.722] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:45.723] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.723] 
[16:18:45.723] getGlobalsAndPackages() ... DONE
[16:18:45.723] run() for ‘Future’ ...
[16:18:45.723] - state: ‘created’
[16:18:45.723] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.736] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.737]   - Field: ‘node’
[16:18:45.737]   - Field: ‘label’
[16:18:45.737]   - Field: ‘local’
[16:18:45.737]   - Field: ‘owner’
[16:18:45.737]   - Field: ‘envir’
[16:18:45.737]   - Field: ‘workers’
[16:18:45.737]   - Field: ‘packages’
[16:18:45.737]   - Field: ‘gc’
[16:18:45.737]   - Field: ‘conditions’
[16:18:45.738]   - Field: ‘persistent’
[16:18:45.738]   - Field: ‘expr’
[16:18:45.738]   - Field: ‘uuid’
[16:18:45.738]   - Field: ‘seed’
[16:18:45.738]   - Field: ‘version’
[16:18:45.738]   - Field: ‘result’
[16:18:45.738]   - Field: ‘asynchronous’
[16:18:45.738]   - Field: ‘calls’
[16:18:45.738]   - Field: ‘globals’
[16:18:45.738]   - Field: ‘stdout’
[16:18:45.738]   - Field: ‘earlySignal’
[16:18:45.738]   - Field: ‘lazy’
[16:18:45.739]   - Field: ‘state’
[16:18:45.739] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.739] - Launch lazy future ...
[16:18:45.739] Packages needed by the future expression (n = 0): <none>
[16:18:45.739] Packages needed by future strategies (n = 0): <none>
[16:18:45.740] {
[16:18:45.740]     {
[16:18:45.740]         {
[16:18:45.740]             ...future.startTime <- base::Sys.time()
[16:18:45.740]             {
[16:18:45.740]                 {
[16:18:45.740]                   {
[16:18:45.740]                     {
[16:18:45.740]                       base::local({
[16:18:45.740]                         has_future <- base::requireNamespace("future", 
[16:18:45.740]                           quietly = TRUE)
[16:18:45.740]                         if (has_future) {
[16:18:45.740]                           ns <- base::getNamespace("future")
[16:18:45.740]                           version <- ns[[".package"]][["version"]]
[16:18:45.740]                           if (is.null(version)) 
[16:18:45.740]                             version <- utils::packageVersion("future")
[16:18:45.740]                         }
[16:18:45.740]                         else {
[16:18:45.740]                           version <- NULL
[16:18:45.740]                         }
[16:18:45.740]                         if (!has_future || version < "1.8.0") {
[16:18:45.740]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.740]                             "", base::R.version$version.string), 
[16:18:45.740]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.740]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.740]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.740]                               "release", "version")], collapse = " "), 
[16:18:45.740]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.740]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.740]                             info)
[16:18:45.740]                           info <- base::paste(info, collapse = "; ")
[16:18:45.740]                           if (!has_future) {
[16:18:45.740]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.740]                               info)
[16:18:45.740]                           }
[16:18:45.740]                           else {
[16:18:45.740]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.740]                               info, version)
[16:18:45.740]                           }
[16:18:45.740]                           base::stop(msg)
[16:18:45.740]                         }
[16:18:45.740]                       })
[16:18:45.740]                     }
[16:18:45.740]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.740]                     base::options(mc.cores = 1L)
[16:18:45.740]                   }
[16:18:45.740]                   ...future.strategy.old <- future::plan("list")
[16:18:45.740]                   options(future.plan = NULL)
[16:18:45.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.740]                 }
[16:18:45.740]                 ...future.workdir <- getwd()
[16:18:45.740]             }
[16:18:45.740]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.740]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.740]         }
[16:18:45.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.740]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:18:45.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.740]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.740]             base::names(...future.oldOptions))
[16:18:45.740]     }
[16:18:45.740]     if (FALSE) {
[16:18:45.740]     }
[16:18:45.740]     else {
[16:18:45.740]         if (TRUE) {
[16:18:45.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.740]                 open = "w")
[16:18:45.740]         }
[16:18:45.740]         else {
[16:18:45.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.740]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.740]         }
[16:18:45.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.740]             base::sink(type = "output", split = FALSE)
[16:18:45.740]             base::close(...future.stdout)
[16:18:45.740]         }, add = TRUE)
[16:18:45.740]     }
[16:18:45.740]     ...future.frame <- base::sys.nframe()
[16:18:45.740]     ...future.conditions <- base::list()
[16:18:45.740]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.740]     if (FALSE) {
[16:18:45.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.740]     }
[16:18:45.740]     ...future.result <- base::tryCatch({
[16:18:45.740]         base::withCallingHandlers({
[16:18:45.740]             ...future.value <- base::withVisible(base::local({
[16:18:45.740]                 ...future.makeSendCondition <- base::local({
[16:18:45.740]                   sendCondition <- NULL
[16:18:45.740]                   function(frame = 1L) {
[16:18:45.740]                     if (is.function(sendCondition)) 
[16:18:45.740]                       return(sendCondition)
[16:18:45.740]                     ns <- getNamespace("parallel")
[16:18:45.740]                     if (exists("sendData", mode = "function", 
[16:18:45.740]                       envir = ns)) {
[16:18:45.740]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.740]                         envir = ns)
[16:18:45.740]                       envir <- sys.frame(frame)
[16:18:45.740]                       master <- NULL
[16:18:45.740]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.740]                         !identical(envir, emptyenv())) {
[16:18:45.740]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.740]                           inherits = FALSE)) {
[16:18:45.740]                           master <- get("master", mode = "list", 
[16:18:45.740]                             envir = envir, inherits = FALSE)
[16:18:45.740]                           if (inherits(master, c("SOCKnode", 
[16:18:45.740]                             "SOCK0node"))) {
[16:18:45.740]                             sendCondition <<- function(cond) {
[16:18:45.740]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.740]                                 success = TRUE)
[16:18:45.740]                               parallel_sendData(master, data)
[16:18:45.740]                             }
[16:18:45.740]                             return(sendCondition)
[16:18:45.740]                           }
[16:18:45.740]                         }
[16:18:45.740]                         frame <- frame + 1L
[16:18:45.740]                         envir <- sys.frame(frame)
[16:18:45.740]                       }
[16:18:45.740]                     }
[16:18:45.740]                     sendCondition <<- function(cond) NULL
[16:18:45.740]                   }
[16:18:45.740]                 })
[16:18:45.740]                 withCallingHandlers({
[16:18:45.740]                   {
[16:18:45.740]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.740]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.740]                       ...future.globals.maxSize)) {
[16:18:45.740]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.740]                       on.exit(options(oopts), add = TRUE)
[16:18:45.740]                     }
[16:18:45.740]                     {
[16:18:45.740]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.740]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.740]                         USE.NAMES = FALSE)
[16:18:45.740]                       do.call(mapply, args = args)
[16:18:45.740]                     }
[16:18:45.740]                   }
[16:18:45.740]                 }, immediateCondition = function(cond) {
[16:18:45.740]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.740]                   sendCondition(cond)
[16:18:45.740]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.740]                   {
[16:18:45.740]                     inherits <- base::inherits
[16:18:45.740]                     invokeRestart <- base::invokeRestart
[16:18:45.740]                     is.null <- base::is.null
[16:18:45.740]                     muffled <- FALSE
[16:18:45.740]                     if (inherits(cond, "message")) {
[16:18:45.740]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.740]                       if (muffled) 
[16:18:45.740]                         invokeRestart("muffleMessage")
[16:18:45.740]                     }
[16:18:45.740]                     else if (inherits(cond, "warning")) {
[16:18:45.740]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.740]                       if (muffled) 
[16:18:45.740]                         invokeRestart("muffleWarning")
[16:18:45.740]                     }
[16:18:45.740]                     else if (inherits(cond, "condition")) {
[16:18:45.740]                       if (!is.null(pattern)) {
[16:18:45.740]                         computeRestarts <- base::computeRestarts
[16:18:45.740]                         grepl <- base::grepl
[16:18:45.740]                         restarts <- computeRestarts(cond)
[16:18:45.740]                         for (restart in restarts) {
[16:18:45.740]                           name <- restart$name
[16:18:45.740]                           if (is.null(name)) 
[16:18:45.740]                             next
[16:18:45.740]                           if (!grepl(pattern, name)) 
[16:18:45.740]                             next
[16:18:45.740]                           invokeRestart(restart)
[16:18:45.740]                           muffled <- TRUE
[16:18:45.740]                           break
[16:18:45.740]                         }
[16:18:45.740]                       }
[16:18:45.740]                     }
[16:18:45.740]                     invisible(muffled)
[16:18:45.740]                   }
[16:18:45.740]                   muffleCondition(cond)
[16:18:45.740]                 })
[16:18:45.740]             }))
[16:18:45.740]             future::FutureResult(value = ...future.value$value, 
[16:18:45.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.740]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.740]                     ...future.globalenv.names))
[16:18:45.740]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.740]         }, condition = base::local({
[16:18:45.740]             c <- base::c
[16:18:45.740]             inherits <- base::inherits
[16:18:45.740]             invokeRestart <- base::invokeRestart
[16:18:45.740]             length <- base::length
[16:18:45.740]             list <- base::list
[16:18:45.740]             seq.int <- base::seq.int
[16:18:45.740]             signalCondition <- base::signalCondition
[16:18:45.740]             sys.calls <- base::sys.calls
[16:18:45.740]             `[[` <- base::`[[`
[16:18:45.740]             `+` <- base::`+`
[16:18:45.740]             `<<-` <- base::`<<-`
[16:18:45.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.740]                   3L)]
[16:18:45.740]             }
[16:18:45.740]             function(cond) {
[16:18:45.740]                 is_error <- inherits(cond, "error")
[16:18:45.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.740]                   NULL)
[16:18:45.740]                 if (is_error) {
[16:18:45.740]                   sessionInformation <- function() {
[16:18:45.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.740]                       search = base::search(), system = base::Sys.info())
[16:18:45.740]                   }
[16:18:45.740]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.740]                     cond$call), session = sessionInformation(), 
[16:18:45.740]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.740]                   signalCondition(cond)
[16:18:45.740]                 }
[16:18:45.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.740]                 "immediateCondition"))) {
[16:18:45.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.740]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.740]                   if (TRUE && !signal) {
[16:18:45.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.740]                     {
[16:18:45.740]                       inherits <- base::inherits
[16:18:45.740]                       invokeRestart <- base::invokeRestart
[16:18:45.740]                       is.null <- base::is.null
[16:18:45.740]                       muffled <- FALSE
[16:18:45.740]                       if (inherits(cond, "message")) {
[16:18:45.740]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.740]                         if (muffled) 
[16:18:45.740]                           invokeRestart("muffleMessage")
[16:18:45.740]                       }
[16:18:45.740]                       else if (inherits(cond, "warning")) {
[16:18:45.740]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.740]                         if (muffled) 
[16:18:45.740]                           invokeRestart("muffleWarning")
[16:18:45.740]                       }
[16:18:45.740]                       else if (inherits(cond, "condition")) {
[16:18:45.740]                         if (!is.null(pattern)) {
[16:18:45.740]                           computeRestarts <- base::computeRestarts
[16:18:45.740]                           grepl <- base::grepl
[16:18:45.740]                           restarts <- computeRestarts(cond)
[16:18:45.740]                           for (restart in restarts) {
[16:18:45.740]                             name <- restart$name
[16:18:45.740]                             if (is.null(name)) 
[16:18:45.740]                               next
[16:18:45.740]                             if (!grepl(pattern, name)) 
[16:18:45.740]                               next
[16:18:45.740]                             invokeRestart(restart)
[16:18:45.740]                             muffled <- TRUE
[16:18:45.740]                             break
[16:18:45.740]                           }
[16:18:45.740]                         }
[16:18:45.740]                       }
[16:18:45.740]                       invisible(muffled)
[16:18:45.740]                     }
[16:18:45.740]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.740]                   }
[16:18:45.740]                 }
[16:18:45.740]                 else {
[16:18:45.740]                   if (TRUE) {
[16:18:45.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.740]                     {
[16:18:45.740]                       inherits <- base::inherits
[16:18:45.740]                       invokeRestart <- base::invokeRestart
[16:18:45.740]                       is.null <- base::is.null
[16:18:45.740]                       muffled <- FALSE
[16:18:45.740]                       if (inherits(cond, "message")) {
[16:18:45.740]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.740]                         if (muffled) 
[16:18:45.740]                           invokeRestart("muffleMessage")
[16:18:45.740]                       }
[16:18:45.740]                       else if (inherits(cond, "warning")) {
[16:18:45.740]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.740]                         if (muffled) 
[16:18:45.740]                           invokeRestart("muffleWarning")
[16:18:45.740]                       }
[16:18:45.740]                       else if (inherits(cond, "condition")) {
[16:18:45.740]                         if (!is.null(pattern)) {
[16:18:45.740]                           computeRestarts <- base::computeRestarts
[16:18:45.740]                           grepl <- base::grepl
[16:18:45.740]                           restarts <- computeRestarts(cond)
[16:18:45.740]                           for (restart in restarts) {
[16:18:45.740]                             name <- restart$name
[16:18:45.740]                             if (is.null(name)) 
[16:18:45.740]                               next
[16:18:45.740]                             if (!grepl(pattern, name)) 
[16:18:45.740]                               next
[16:18:45.740]                             invokeRestart(restart)
[16:18:45.740]                             muffled <- TRUE
[16:18:45.740]                             break
[16:18:45.740]                           }
[16:18:45.740]                         }
[16:18:45.740]                       }
[16:18:45.740]                       invisible(muffled)
[16:18:45.740]                     }
[16:18:45.740]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.740]                   }
[16:18:45.740]                 }
[16:18:45.740]             }
[16:18:45.740]         }))
[16:18:45.740]     }, error = function(ex) {
[16:18:45.740]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.740]                 ...future.rng), started = ...future.startTime, 
[16:18:45.740]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.740]             version = "1.8"), class = "FutureResult")
[16:18:45.740]     }, finally = {
[16:18:45.740]         if (!identical(...future.workdir, getwd())) 
[16:18:45.740]             setwd(...future.workdir)
[16:18:45.740]         {
[16:18:45.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.740]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.740]             }
[16:18:45.740]             base::options(...future.oldOptions)
[16:18:45.740]             if (.Platform$OS.type == "windows") {
[16:18:45.740]                 old_names <- names(...future.oldEnvVars)
[16:18:45.740]                 envs <- base::Sys.getenv()
[16:18:45.740]                 names <- names(envs)
[16:18:45.740]                 common <- intersect(names, old_names)
[16:18:45.740]                 added <- setdiff(names, old_names)
[16:18:45.740]                 removed <- setdiff(old_names, names)
[16:18:45.740]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.740]                   envs[common]]
[16:18:45.740]                 NAMES <- toupper(changed)
[16:18:45.740]                 args <- list()
[16:18:45.740]                 for (kk in seq_along(NAMES)) {
[16:18:45.740]                   name <- changed[[kk]]
[16:18:45.740]                   NAME <- NAMES[[kk]]
[16:18:45.740]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.740]                     next
[16:18:45.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.740]                 }
[16:18:45.740]                 NAMES <- toupper(added)
[16:18:45.740]                 for (kk in seq_along(NAMES)) {
[16:18:45.740]                   name <- added[[kk]]
[16:18:45.740]                   NAME <- NAMES[[kk]]
[16:18:45.740]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.740]                     next
[16:18:45.740]                   args[[name]] <- ""
[16:18:45.740]                 }
[16:18:45.740]                 NAMES <- toupper(removed)
[16:18:45.740]                 for (kk in seq_along(NAMES)) {
[16:18:45.740]                   name <- removed[[kk]]
[16:18:45.740]                   NAME <- NAMES[[kk]]
[16:18:45.740]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.740]                     next
[16:18:45.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.740]                 }
[16:18:45.740]                 if (length(args) > 0) 
[16:18:45.740]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.740]             }
[16:18:45.740]             else {
[16:18:45.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.740]             }
[16:18:45.740]             {
[16:18:45.740]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.740]                   0L) {
[16:18:45.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.740]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.740]                   base::options(opts)
[16:18:45.740]                 }
[16:18:45.740]                 {
[16:18:45.740]                   {
[16:18:45.740]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.740]                     NULL
[16:18:45.740]                   }
[16:18:45.740]                   options(future.plan = NULL)
[16:18:45.740]                   if (is.na(NA_character_)) 
[16:18:45.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.740]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.740]                     .init = FALSE)
[16:18:45.740]                 }
[16:18:45.740]             }
[16:18:45.740]         }
[16:18:45.740]     })
[16:18:45.740]     if (TRUE) {
[16:18:45.740]         base::sink(type = "output", split = FALSE)
[16:18:45.740]         if (TRUE) {
[16:18:45.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.740]         }
[16:18:45.740]         else {
[16:18:45.740]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.740]         }
[16:18:45.740]         base::close(...future.stdout)
[16:18:45.740]         ...future.stdout <- NULL
[16:18:45.740]     }
[16:18:45.740]     ...future.result$conditions <- ...future.conditions
[16:18:45.740]     ...future.result$finished <- base::Sys.time()
[16:18:45.740]     ...future.result
[16:18:45.740] }
[16:18:45.742] Poll #1 (0): usedNodes() = 2, workers = 2
[16:18:45.752] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.753] - Validating connection of MultisessionFuture
[16:18:45.753] - received message: FutureResult
[16:18:45.753] - Received FutureResult
[16:18:45.753] - Erased future from FutureRegistry
[16:18:45.753] result() for ClusterFuture ...
[16:18:45.753] - result already collected: FutureResult
[16:18:45.753] result() for ClusterFuture ... done
[16:18:45.753] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.754] result() for ClusterFuture ...
[16:18:45.754] - result already collected: FutureResult
[16:18:45.754] result() for ClusterFuture ... done
[16:18:45.754] result() for ClusterFuture ...
[16:18:45.754] - result already collected: FutureResult
[16:18:45.754] result() for ClusterFuture ... done
[16:18:45.755] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[16:18:45.755] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[16:18:45.755] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[16:18:45.755] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:45.755] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.756] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[16:18:45.756] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[16:18:45.756] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:45.756] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.757] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:45.757] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.757] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[16:18:45.757] MultisessionFuture started
[16:18:45.758] - Launch lazy future ... done
[16:18:45.758] run() for ‘MultisessionFuture’ ... done
[16:18:45.758] Created future:
[16:18:45.758] MultisessionFuture:
[16:18:45.758] Label: ‘future_mapply-3’
[16:18:45.758] Expression:
[16:18:45.758] {
[16:18:45.758]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.758]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.758]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.758]         on.exit(options(oopts), add = TRUE)
[16:18:45.758]     }
[16:18:45.758]     {
[16:18:45.758]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.758]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.758]         do.call(mapply, args = args)
[16:18:45.758]     }
[16:18:45.758] }
[16:18:45.758] Lazy evaluation: FALSE
[16:18:45.758] Asynchronous evaluation: TRUE
[16:18:45.758] Local evaluation: TRUE
[16:18:45.758] Environment: R_GlobalEnv
[16:18:45.758] Capture standard output: TRUE
[16:18:45.758] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.758] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.758] Packages: <none>
[16:18:45.758] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.758] Resolved: FALSE
[16:18:45.758] Value: <not collected>
[16:18:45.758] Conditions captured: <none>
[16:18:45.758] Early signaling: FALSE
[16:18:45.758] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.758] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.769] Chunk #3 of 3 ... DONE
[16:18:45.769] Launching 3 futures (chunks) ... DONE
[16:18:45.769] Resolving 3 futures (chunks) ...
[16:18:45.769] resolve() on list ...
[16:18:45.770]  recursive: 0
[16:18:45.770]  length: 3
[16:18:45.770] 
[16:18:45.770] Future #1
[16:18:45.770] result() for ClusterFuture ...
[16:18:45.770] - result already collected: FutureResult
[16:18:45.770] result() for ClusterFuture ... done
[16:18:45.770] result() for ClusterFuture ...
[16:18:45.770] - result already collected: FutureResult
[16:18:45.770] result() for ClusterFuture ... done
[16:18:45.770] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:45.771] - nx: 3
[16:18:45.771] - relay: TRUE
[16:18:45.771] - stdout: TRUE
[16:18:45.771] - signal: TRUE
[16:18:45.771] - resignal: FALSE
[16:18:45.771] - force: TRUE
[16:18:45.771] - relayed: [n=3] FALSE, FALSE, FALSE
[16:18:45.771] - queued futures: [n=3] FALSE, FALSE, FALSE
[16:18:45.771]  - until=1
[16:18:45.771]  - relaying element #1
[16:18:45.771] result() for ClusterFuture ...
[16:18:45.771] - result already collected: FutureResult
[16:18:45.772] result() for ClusterFuture ... done
[16:18:45.772] result() for ClusterFuture ...
[16:18:45.772] - result already collected: FutureResult
[16:18:45.772] result() for ClusterFuture ... done
[16:18:45.772] result() for ClusterFuture ...
[16:18:45.772] - result already collected: FutureResult
[16:18:45.772] result() for ClusterFuture ... done
[16:18:45.772] result() for ClusterFuture ...
[16:18:45.772] - result already collected: FutureResult
[16:18:45.772] result() for ClusterFuture ... done
[16:18:45.772] - relayed: [n=3] TRUE, FALSE, FALSE
[16:18:45.773] - queued futures: [n=3] TRUE, FALSE, FALSE
[16:18:45.773] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:45.773]  length: 2 (resolved future 1)
[16:18:45.773] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.773] - Validating connection of MultisessionFuture
[16:18:45.773] - received message: FutureResult
[16:18:45.774] - Received FutureResult
[16:18:45.774] - Erased future from FutureRegistry
[16:18:45.774] result() for ClusterFuture ...
[16:18:45.774] - result already collected: FutureResult
[16:18:45.774] result() for ClusterFuture ... done
[16:18:45.774] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.774] Future #2
[16:18:45.774] result() for ClusterFuture ...
[16:18:45.774] - result already collected: FutureResult
[16:18:45.774] result() for ClusterFuture ... done
[16:18:45.774] result() for ClusterFuture ...
[16:18:45.775] - result already collected: FutureResult
[16:18:45.775] result() for ClusterFuture ... done
[16:18:45.775] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:45.775] - nx: 3
[16:18:45.775] - relay: TRUE
[16:18:45.775] - stdout: TRUE
[16:18:45.775] - signal: TRUE
[16:18:45.775] - resignal: FALSE
[16:18:45.775] - force: TRUE
[16:18:45.775] - relayed: [n=3] TRUE, FALSE, FALSE
[16:18:45.775] - queued futures: [n=3] TRUE, FALSE, FALSE
[16:18:45.775]  - until=2
[16:18:45.776]  - relaying element #2
[16:18:45.776] result() for ClusterFuture ...
[16:18:45.776] - result already collected: FutureResult
[16:18:45.776] result() for ClusterFuture ... done
[16:18:45.776] result() for ClusterFuture ...
[16:18:45.776] - result already collected: FutureResult
[16:18:45.776] result() for ClusterFuture ... done
[16:18:45.776] result() for ClusterFuture ...
[16:18:45.776] - result already collected: FutureResult
[16:18:45.776] result() for ClusterFuture ... done
[16:18:45.776] result() for ClusterFuture ...
[16:18:45.777] - result already collected: FutureResult
[16:18:45.777] result() for ClusterFuture ... done
[16:18:45.777] - relayed: [n=3] TRUE, TRUE, FALSE
[16:18:45.777] - queued futures: [n=3] TRUE, TRUE, FALSE
[16:18:45.777] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:45.777]  length: 1 (resolved future 2)
[16:18:45.802] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.802] - Validating connection of MultisessionFuture
[16:18:45.802] - received message: FutureResult
[16:18:45.802] - Received FutureResult
[16:18:45.802] - Erased future from FutureRegistry
[16:18:45.802] result() for ClusterFuture ...
[16:18:45.802] - result already collected: FutureResult
[16:18:45.802] result() for ClusterFuture ... done
[16:18:45.803] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.803] Future #3
[16:18:45.803] result() for ClusterFuture ...
[16:18:45.803] - result already collected: FutureResult
[16:18:45.803] result() for ClusterFuture ... done
[16:18:45.803] result() for ClusterFuture ...
[16:18:45.803] - result already collected: FutureResult
[16:18:45.803] result() for ClusterFuture ... done
[16:18:45.803] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:18:45.803] - nx: 3
[16:18:45.803] - relay: TRUE
[16:18:45.804] - stdout: TRUE
[16:18:45.804] - signal: TRUE
[16:18:45.804] - resignal: FALSE
[16:18:45.804] - force: TRUE
[16:18:45.804] - relayed: [n=3] TRUE, TRUE, FALSE
[16:18:45.804] - queued futures: [n=3] TRUE, TRUE, FALSE
[16:18:45.804]  - until=3
[16:18:45.804]  - relaying element #3
[16:18:45.804] result() for ClusterFuture ...
[16:18:45.804] - result already collected: FutureResult
[16:18:45.804] result() for ClusterFuture ... done
[16:18:45.804] result() for ClusterFuture ...
[16:18:45.805] - result already collected: FutureResult
[16:18:45.805] result() for ClusterFuture ... done
[16:18:45.805] result() for ClusterFuture ...
[16:18:45.805] - result already collected: FutureResult
[16:18:45.805] result() for ClusterFuture ... done
[16:18:45.805] result() for ClusterFuture ...
[16:18:45.805] - result already collected: FutureResult
[16:18:45.805] result() for ClusterFuture ... done
[16:18:45.805] - relayed: [n=3] TRUE, TRUE, TRUE
[16:18:45.805] - queued futures: [n=3] TRUE, TRUE, TRUE
[16:18:45.805] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:18:45.806]  length: 0 (resolved future 3)
[16:18:45.806] Relaying remaining futures
[16:18:45.806] signalConditionsASAP(NULL, pos=0) ...
[16:18:45.806] - nx: 3
[16:18:45.806] - relay: TRUE
[16:18:45.806] - stdout: TRUE
[16:18:45.806] - signal: TRUE
[16:18:45.806] - resignal: FALSE
[16:18:45.806] - force: TRUE
[16:18:45.806] - relayed: [n=3] TRUE, TRUE, TRUE
[16:18:45.806] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[16:18:45.807] - relayed: [n=3] TRUE, TRUE, TRUE
[16:18:45.807] - queued futures: [n=3] TRUE, TRUE, TRUE
[16:18:45.807] signalConditionsASAP(NULL, pos=0) ... done
[16:18:45.807] resolve() on list ... DONE
[16:18:45.807] result() for ClusterFuture ...
[16:18:45.807] - result already collected: FutureResult
[16:18:45.807] result() for ClusterFuture ... done
[16:18:45.807] result() for ClusterFuture ...
[16:18:45.807] - result already collected: FutureResult
[16:18:45.807] result() for ClusterFuture ... done
[16:18:45.807] result() for ClusterFuture ...
[16:18:45.808] - result already collected: FutureResult
[16:18:45.808] result() for ClusterFuture ... done
[16:18:45.808] result() for ClusterFuture ...
[16:18:45.808] - result already collected: FutureResult
[16:18:45.808] result() for ClusterFuture ... done
[16:18:45.808] result() for ClusterFuture ...
[16:18:45.808] - result already collected: FutureResult
[16:18:45.808] result() for ClusterFuture ... done
[16:18:45.808] result() for ClusterFuture ...
[16:18:45.808] - result already collected: FutureResult
[16:18:45.808] result() for ClusterFuture ... done
[16:18:45.809]  - Number of value chunks collected: 3
[16:18:45.809] Resolving 3 futures (chunks) ... DONE
[16:18:45.809] Reducing values from 3 chunks ...
[16:18:45.809]  - Number of values collected after concatenation: 5
[16:18:45.809]  - Number of values expected: 5
[16:18:45.809] Reverse index remapping (attribute 'ordering'): [n = 5] 3, 5, 4, 1, 2
[16:18:45.809] Reducing values from 3 chunks ... DONE
[16:18:45.809] future_mapply() ... DONE
[16:18:45.809] future_mapply() ...
[16:18:45.813] Number of chunks: 2
[16:18:45.813] getGlobalsAndPackagesXApply() ...
[16:18:45.814]  - future.globals: TRUE
[16:18:45.814] getGlobalsAndPackages() ...
[16:18:45.814] Searching for globals...
[16:18:45.815] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:45.815] Searching for globals ... DONE
[16:18:45.815] Resolving globals: FALSE
[16:18:45.816] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:45.816] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:45.816] - globals: [1] ‘FUN’
[16:18:45.816] 
[16:18:45.817] getGlobalsAndPackages() ... DONE
[16:18:45.817]  - globals found/used: [n=1] ‘FUN’
[16:18:45.817]  - needed namespaces: [n=0] 
[16:18:45.817] Finding globals ... DONE
[16:18:45.817] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:45.817] List of 2
[16:18:45.817]  $ ...future.FUN:function (C, k)  
[16:18:45.817]  $ MoreArgs     : list()
[16:18:45.817]  - attr(*, "where")=List of 2
[16:18:45.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:45.817]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:45.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:45.817]  - attr(*, "resolved")= logi FALSE
[16:18:45.817]  - attr(*, "total_size")= num NA
[16:18:45.820] Packages to be attached in all futures: [n=0] 
[16:18:45.820] getGlobalsAndPackagesXApply() ... DONE
[16:18:45.820] Number of futures (= number of chunks): 2
[16:18:45.820] Launching 2 futures (chunks) ...
[16:18:45.820] Chunk #1 of 2 ...
[16:18:45.820]  - Finding globals in '...' for chunk #1 ...
[16:18:45.820] getGlobalsAndPackages() ...
[16:18:45.820] Searching for globals...
[16:18:45.821] 
[16:18:45.821] Searching for globals ... DONE
[16:18:45.821] - globals: [0] <none>
[16:18:45.821] getGlobalsAndPackages() ... DONE
[16:18:45.821]    + additional globals found: [n=0] 
[16:18:45.821]    + additional namespaces needed: [n=0] 
[16:18:45.821]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:45.821]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:45.822]  - seeds: <none>
[16:18:45.822]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.822] getGlobalsAndPackages() ...
[16:18:45.822] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.822] Resolving globals: FALSE
[16:18:45.822] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:45.823] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:45.823] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.823] 
[16:18:45.823] getGlobalsAndPackages() ... DONE
[16:18:45.823] run() for ‘Future’ ...
[16:18:45.824] - state: ‘created’
[16:18:45.824] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.837] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.837] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.838]   - Field: ‘node’
[16:18:45.838]   - Field: ‘label’
[16:18:45.838]   - Field: ‘local’
[16:18:45.838]   - Field: ‘owner’
[16:18:45.838]   - Field: ‘envir’
[16:18:45.838]   - Field: ‘workers’
[16:18:45.838]   - Field: ‘packages’
[16:18:45.838]   - Field: ‘gc’
[16:18:45.838]   - Field: ‘conditions’
[16:18:45.838]   - Field: ‘persistent’
[16:18:45.838]   - Field: ‘expr’
[16:18:45.839]   - Field: ‘uuid’
[16:18:45.839]   - Field: ‘seed’
[16:18:45.839]   - Field: ‘version’
[16:18:45.839]   - Field: ‘result’
[16:18:45.839]   - Field: ‘asynchronous’
[16:18:45.839]   - Field: ‘calls’
[16:18:45.839]   - Field: ‘globals’
[16:18:45.839]   - Field: ‘stdout’
[16:18:45.839]   - Field: ‘earlySignal’
[16:18:45.839]   - Field: ‘lazy’
[16:18:45.839]   - Field: ‘state’
[16:18:45.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.840] - Launch lazy future ...
[16:18:45.840] Packages needed by the future expression (n = 0): <none>
[16:18:45.840] Packages needed by future strategies (n = 0): <none>
[16:18:45.840] {
[16:18:45.840]     {
[16:18:45.840]         {
[16:18:45.840]             ...future.startTime <- base::Sys.time()
[16:18:45.840]             {
[16:18:45.840]                 {
[16:18:45.840]                   {
[16:18:45.840]                     {
[16:18:45.840]                       base::local({
[16:18:45.840]                         has_future <- base::requireNamespace("future", 
[16:18:45.840]                           quietly = TRUE)
[16:18:45.840]                         if (has_future) {
[16:18:45.840]                           ns <- base::getNamespace("future")
[16:18:45.840]                           version <- ns[[".package"]][["version"]]
[16:18:45.840]                           if (is.null(version)) 
[16:18:45.840]                             version <- utils::packageVersion("future")
[16:18:45.840]                         }
[16:18:45.840]                         else {
[16:18:45.840]                           version <- NULL
[16:18:45.840]                         }
[16:18:45.840]                         if (!has_future || version < "1.8.0") {
[16:18:45.840]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.840]                             "", base::R.version$version.string), 
[16:18:45.840]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.840]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.840]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.840]                               "release", "version")], collapse = " "), 
[16:18:45.840]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.840]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.840]                             info)
[16:18:45.840]                           info <- base::paste(info, collapse = "; ")
[16:18:45.840]                           if (!has_future) {
[16:18:45.840]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.840]                               info)
[16:18:45.840]                           }
[16:18:45.840]                           else {
[16:18:45.840]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.840]                               info, version)
[16:18:45.840]                           }
[16:18:45.840]                           base::stop(msg)
[16:18:45.840]                         }
[16:18:45.840]                       })
[16:18:45.840]                     }
[16:18:45.840]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.840]                     base::options(mc.cores = 1L)
[16:18:45.840]                   }
[16:18:45.840]                   ...future.strategy.old <- future::plan("list")
[16:18:45.840]                   options(future.plan = NULL)
[16:18:45.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.840]                 }
[16:18:45.840]                 ...future.workdir <- getwd()
[16:18:45.840]             }
[16:18:45.840]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.840]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.840]         }
[16:18:45.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.840]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:45.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.840]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.840]             base::names(...future.oldOptions))
[16:18:45.840]     }
[16:18:45.840]     if (FALSE) {
[16:18:45.840]     }
[16:18:45.840]     else {
[16:18:45.840]         if (TRUE) {
[16:18:45.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.840]                 open = "w")
[16:18:45.840]         }
[16:18:45.840]         else {
[16:18:45.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.840]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.840]         }
[16:18:45.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.840]             base::sink(type = "output", split = FALSE)
[16:18:45.840]             base::close(...future.stdout)
[16:18:45.840]         }, add = TRUE)
[16:18:45.840]     }
[16:18:45.840]     ...future.frame <- base::sys.nframe()
[16:18:45.840]     ...future.conditions <- base::list()
[16:18:45.840]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.840]     if (FALSE) {
[16:18:45.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.840]     }
[16:18:45.840]     ...future.result <- base::tryCatch({
[16:18:45.840]         base::withCallingHandlers({
[16:18:45.840]             ...future.value <- base::withVisible(base::local({
[16:18:45.840]                 ...future.makeSendCondition <- base::local({
[16:18:45.840]                   sendCondition <- NULL
[16:18:45.840]                   function(frame = 1L) {
[16:18:45.840]                     if (is.function(sendCondition)) 
[16:18:45.840]                       return(sendCondition)
[16:18:45.840]                     ns <- getNamespace("parallel")
[16:18:45.840]                     if (exists("sendData", mode = "function", 
[16:18:45.840]                       envir = ns)) {
[16:18:45.840]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.840]                         envir = ns)
[16:18:45.840]                       envir <- sys.frame(frame)
[16:18:45.840]                       master <- NULL
[16:18:45.840]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.840]                         !identical(envir, emptyenv())) {
[16:18:45.840]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.840]                           inherits = FALSE)) {
[16:18:45.840]                           master <- get("master", mode = "list", 
[16:18:45.840]                             envir = envir, inherits = FALSE)
[16:18:45.840]                           if (inherits(master, c("SOCKnode", 
[16:18:45.840]                             "SOCK0node"))) {
[16:18:45.840]                             sendCondition <<- function(cond) {
[16:18:45.840]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.840]                                 success = TRUE)
[16:18:45.840]                               parallel_sendData(master, data)
[16:18:45.840]                             }
[16:18:45.840]                             return(sendCondition)
[16:18:45.840]                           }
[16:18:45.840]                         }
[16:18:45.840]                         frame <- frame + 1L
[16:18:45.840]                         envir <- sys.frame(frame)
[16:18:45.840]                       }
[16:18:45.840]                     }
[16:18:45.840]                     sendCondition <<- function(cond) NULL
[16:18:45.840]                   }
[16:18:45.840]                 })
[16:18:45.840]                 withCallingHandlers({
[16:18:45.840]                   {
[16:18:45.840]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.840]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.840]                       ...future.globals.maxSize)) {
[16:18:45.840]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.840]                       on.exit(options(oopts), add = TRUE)
[16:18:45.840]                     }
[16:18:45.840]                     {
[16:18:45.840]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.840]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.840]                         USE.NAMES = FALSE)
[16:18:45.840]                       do.call(mapply, args = args)
[16:18:45.840]                     }
[16:18:45.840]                   }
[16:18:45.840]                 }, immediateCondition = function(cond) {
[16:18:45.840]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.840]                   sendCondition(cond)
[16:18:45.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.840]                   {
[16:18:45.840]                     inherits <- base::inherits
[16:18:45.840]                     invokeRestart <- base::invokeRestart
[16:18:45.840]                     is.null <- base::is.null
[16:18:45.840]                     muffled <- FALSE
[16:18:45.840]                     if (inherits(cond, "message")) {
[16:18:45.840]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.840]                       if (muffled) 
[16:18:45.840]                         invokeRestart("muffleMessage")
[16:18:45.840]                     }
[16:18:45.840]                     else if (inherits(cond, "warning")) {
[16:18:45.840]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.840]                       if (muffled) 
[16:18:45.840]                         invokeRestart("muffleWarning")
[16:18:45.840]                     }
[16:18:45.840]                     else if (inherits(cond, "condition")) {
[16:18:45.840]                       if (!is.null(pattern)) {
[16:18:45.840]                         computeRestarts <- base::computeRestarts
[16:18:45.840]                         grepl <- base::grepl
[16:18:45.840]                         restarts <- computeRestarts(cond)
[16:18:45.840]                         for (restart in restarts) {
[16:18:45.840]                           name <- restart$name
[16:18:45.840]                           if (is.null(name)) 
[16:18:45.840]                             next
[16:18:45.840]                           if (!grepl(pattern, name)) 
[16:18:45.840]                             next
[16:18:45.840]                           invokeRestart(restart)
[16:18:45.840]                           muffled <- TRUE
[16:18:45.840]                           break
[16:18:45.840]                         }
[16:18:45.840]                       }
[16:18:45.840]                     }
[16:18:45.840]                     invisible(muffled)
[16:18:45.840]                   }
[16:18:45.840]                   muffleCondition(cond)
[16:18:45.840]                 })
[16:18:45.840]             }))
[16:18:45.840]             future::FutureResult(value = ...future.value$value, 
[16:18:45.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.840]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.840]                     ...future.globalenv.names))
[16:18:45.840]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.840]         }, condition = base::local({
[16:18:45.840]             c <- base::c
[16:18:45.840]             inherits <- base::inherits
[16:18:45.840]             invokeRestart <- base::invokeRestart
[16:18:45.840]             length <- base::length
[16:18:45.840]             list <- base::list
[16:18:45.840]             seq.int <- base::seq.int
[16:18:45.840]             signalCondition <- base::signalCondition
[16:18:45.840]             sys.calls <- base::sys.calls
[16:18:45.840]             `[[` <- base::`[[`
[16:18:45.840]             `+` <- base::`+`
[16:18:45.840]             `<<-` <- base::`<<-`
[16:18:45.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.840]                   3L)]
[16:18:45.840]             }
[16:18:45.840]             function(cond) {
[16:18:45.840]                 is_error <- inherits(cond, "error")
[16:18:45.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.840]                   NULL)
[16:18:45.840]                 if (is_error) {
[16:18:45.840]                   sessionInformation <- function() {
[16:18:45.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.840]                       search = base::search(), system = base::Sys.info())
[16:18:45.840]                   }
[16:18:45.840]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.840]                     cond$call), session = sessionInformation(), 
[16:18:45.840]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.840]                   signalCondition(cond)
[16:18:45.840]                 }
[16:18:45.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.840]                 "immediateCondition"))) {
[16:18:45.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.840]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.840]                   if (TRUE && !signal) {
[16:18:45.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.840]                     {
[16:18:45.840]                       inherits <- base::inherits
[16:18:45.840]                       invokeRestart <- base::invokeRestart
[16:18:45.840]                       is.null <- base::is.null
[16:18:45.840]                       muffled <- FALSE
[16:18:45.840]                       if (inherits(cond, "message")) {
[16:18:45.840]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.840]                         if (muffled) 
[16:18:45.840]                           invokeRestart("muffleMessage")
[16:18:45.840]                       }
[16:18:45.840]                       else if (inherits(cond, "warning")) {
[16:18:45.840]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.840]                         if (muffled) 
[16:18:45.840]                           invokeRestart("muffleWarning")
[16:18:45.840]                       }
[16:18:45.840]                       else if (inherits(cond, "condition")) {
[16:18:45.840]                         if (!is.null(pattern)) {
[16:18:45.840]                           computeRestarts <- base::computeRestarts
[16:18:45.840]                           grepl <- base::grepl
[16:18:45.840]                           restarts <- computeRestarts(cond)
[16:18:45.840]                           for (restart in restarts) {
[16:18:45.840]                             name <- restart$name
[16:18:45.840]                             if (is.null(name)) 
[16:18:45.840]                               next
[16:18:45.840]                             if (!grepl(pattern, name)) 
[16:18:45.840]                               next
[16:18:45.840]                             invokeRestart(restart)
[16:18:45.840]                             muffled <- TRUE
[16:18:45.840]                             break
[16:18:45.840]                           }
[16:18:45.840]                         }
[16:18:45.840]                       }
[16:18:45.840]                       invisible(muffled)
[16:18:45.840]                     }
[16:18:45.840]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.840]                   }
[16:18:45.840]                 }
[16:18:45.840]                 else {
[16:18:45.840]                   if (TRUE) {
[16:18:45.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.840]                     {
[16:18:45.840]                       inherits <- base::inherits
[16:18:45.840]                       invokeRestart <- base::invokeRestart
[16:18:45.840]                       is.null <- base::is.null
[16:18:45.840]                       muffled <- FALSE
[16:18:45.840]                       if (inherits(cond, "message")) {
[16:18:45.840]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.840]                         if (muffled) 
[16:18:45.840]                           invokeRestart("muffleMessage")
[16:18:45.840]                       }
[16:18:45.840]                       else if (inherits(cond, "warning")) {
[16:18:45.840]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.840]                         if (muffled) 
[16:18:45.840]                           invokeRestart("muffleWarning")
[16:18:45.840]                       }
[16:18:45.840]                       else if (inherits(cond, "condition")) {
[16:18:45.840]                         if (!is.null(pattern)) {
[16:18:45.840]                           computeRestarts <- base::computeRestarts
[16:18:45.840]                           grepl <- base::grepl
[16:18:45.840]                           restarts <- computeRestarts(cond)
[16:18:45.840]                           for (restart in restarts) {
[16:18:45.840]                             name <- restart$name
[16:18:45.840]                             if (is.null(name)) 
[16:18:45.840]                               next
[16:18:45.840]                             if (!grepl(pattern, name)) 
[16:18:45.840]                               next
[16:18:45.840]                             invokeRestart(restart)
[16:18:45.840]                             muffled <- TRUE
[16:18:45.840]                             break
[16:18:45.840]                           }
[16:18:45.840]                         }
[16:18:45.840]                       }
[16:18:45.840]                       invisible(muffled)
[16:18:45.840]                     }
[16:18:45.840]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.840]                   }
[16:18:45.840]                 }
[16:18:45.840]             }
[16:18:45.840]         }))
[16:18:45.840]     }, error = function(ex) {
[16:18:45.840]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.840]                 ...future.rng), started = ...future.startTime, 
[16:18:45.840]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.840]             version = "1.8"), class = "FutureResult")
[16:18:45.840]     }, finally = {
[16:18:45.840]         if (!identical(...future.workdir, getwd())) 
[16:18:45.840]             setwd(...future.workdir)
[16:18:45.840]         {
[16:18:45.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.840]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.840]             }
[16:18:45.840]             base::options(...future.oldOptions)
[16:18:45.840]             if (.Platform$OS.type == "windows") {
[16:18:45.840]                 old_names <- names(...future.oldEnvVars)
[16:18:45.840]                 envs <- base::Sys.getenv()
[16:18:45.840]                 names <- names(envs)
[16:18:45.840]                 common <- intersect(names, old_names)
[16:18:45.840]                 added <- setdiff(names, old_names)
[16:18:45.840]                 removed <- setdiff(old_names, names)
[16:18:45.840]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.840]                   envs[common]]
[16:18:45.840]                 NAMES <- toupper(changed)
[16:18:45.840]                 args <- list()
[16:18:45.840]                 for (kk in seq_along(NAMES)) {
[16:18:45.840]                   name <- changed[[kk]]
[16:18:45.840]                   NAME <- NAMES[[kk]]
[16:18:45.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.840]                     next
[16:18:45.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.840]                 }
[16:18:45.840]                 NAMES <- toupper(added)
[16:18:45.840]                 for (kk in seq_along(NAMES)) {
[16:18:45.840]                   name <- added[[kk]]
[16:18:45.840]                   NAME <- NAMES[[kk]]
[16:18:45.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.840]                     next
[16:18:45.840]                   args[[name]] <- ""
[16:18:45.840]                 }
[16:18:45.840]                 NAMES <- toupper(removed)
[16:18:45.840]                 for (kk in seq_along(NAMES)) {
[16:18:45.840]                   name <- removed[[kk]]
[16:18:45.840]                   NAME <- NAMES[[kk]]
[16:18:45.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.840]                     next
[16:18:45.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.840]                 }
[16:18:45.840]                 if (length(args) > 0) 
[16:18:45.840]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.840]             }
[16:18:45.840]             else {
[16:18:45.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.840]             }
[16:18:45.840]             {
[16:18:45.840]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.840]                   0L) {
[16:18:45.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.840]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.840]                   base::options(opts)
[16:18:45.840]                 }
[16:18:45.840]                 {
[16:18:45.840]                   {
[16:18:45.840]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.840]                     NULL
[16:18:45.840]                   }
[16:18:45.840]                   options(future.plan = NULL)
[16:18:45.840]                   if (is.na(NA_character_)) 
[16:18:45.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.840]                     .init = FALSE)
[16:18:45.840]                 }
[16:18:45.840]             }
[16:18:45.840]         }
[16:18:45.840]     })
[16:18:45.840]     if (TRUE) {
[16:18:45.840]         base::sink(type = "output", split = FALSE)
[16:18:45.840]         if (TRUE) {
[16:18:45.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.840]         }
[16:18:45.840]         else {
[16:18:45.840]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.840]         }
[16:18:45.840]         base::close(...future.stdout)
[16:18:45.840]         ...future.stdout <- NULL
[16:18:45.840]     }
[16:18:45.840]     ...future.result$conditions <- ...future.conditions
[16:18:45.840]     ...future.result$finished <- base::Sys.time()
[16:18:45.840]     ...future.result
[16:18:45.840] }
[16:18:45.843] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[16:18:45.846] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[16:18:45.847] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[16:18:45.847] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:45.847] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.847] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[16:18:45.848] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[16:18:45.848] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:45.848] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.848] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:45.849] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.849] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[16:18:45.850] MultisessionFuture started
[16:18:45.850] - Launch lazy future ... done
[16:18:45.850] run() for ‘MultisessionFuture’ ... done
[16:18:45.850] Created future:
[16:18:45.850] MultisessionFuture:
[16:18:45.850] Label: ‘future_.mapply-1’
[16:18:45.850] Expression:
[16:18:45.850] {
[16:18:45.850]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.850]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.850]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.850]         on.exit(options(oopts), add = TRUE)
[16:18:45.850]     }
[16:18:45.850]     {
[16:18:45.850]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.850]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.850]         do.call(mapply, args = args)
[16:18:45.850]     }
[16:18:45.850] }
[16:18:45.850] Lazy evaluation: FALSE
[16:18:45.850] Asynchronous evaluation: TRUE
[16:18:45.850] Local evaluation: TRUE
[16:18:45.850] Environment: R_GlobalEnv
[16:18:45.850] Capture standard output: TRUE
[16:18:45.850] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.850] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.850] Packages: <none>
[16:18:45.850] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.850] Resolved: FALSE
[16:18:45.850] Value: <not collected>
[16:18:45.850] Conditions captured: <none>
[16:18:45.850] Early signaling: FALSE
[16:18:45.850] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.850] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.861] Chunk #1 of 2 ... DONE
[16:18:45.862] Chunk #2 of 2 ...
[16:18:45.862]  - Finding globals in '...' for chunk #2 ...
[16:18:45.862] getGlobalsAndPackages() ...
[16:18:45.862] Searching for globals...
[16:18:45.862] 
[16:18:45.862] Searching for globals ... DONE
[16:18:45.862] - globals: [0] <none>
[16:18:45.862] getGlobalsAndPackages() ... DONE
[16:18:45.862]    + additional globals found: [n=0] 
[16:18:45.863]    + additional namespaces needed: [n=0] 
[16:18:45.863]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:45.863]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:45.863]  - seeds: <none>
[16:18:45.863]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.863] getGlobalsAndPackages() ...
[16:18:45.863] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.863] Resolving globals: FALSE
[16:18:45.864] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[16:18:45.864] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:45.864] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.864] 
[16:18:45.865] getGlobalsAndPackages() ... DONE
[16:18:45.865] run() for ‘Future’ ...
[16:18:45.865] - state: ‘created’
[16:18:45.865] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.878] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.878] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.878]   - Field: ‘node’
[16:18:45.878]   - Field: ‘label’
[16:18:45.878]   - Field: ‘local’
[16:18:45.878]   - Field: ‘owner’
[16:18:45.878]   - Field: ‘envir’
[16:18:45.879]   - Field: ‘workers’
[16:18:45.879]   - Field: ‘packages’
[16:18:45.879]   - Field: ‘gc’
[16:18:45.879]   - Field: ‘conditions’
[16:18:45.879]   - Field: ‘persistent’
[16:18:45.879]   - Field: ‘expr’
[16:18:45.879]   - Field: ‘uuid’
[16:18:45.879]   - Field: ‘seed’
[16:18:45.879]   - Field: ‘version’
[16:18:45.879]   - Field: ‘result’
[16:18:45.879]   - Field: ‘asynchronous’
[16:18:45.880]   - Field: ‘calls’
[16:18:45.880]   - Field: ‘globals’
[16:18:45.880]   - Field: ‘stdout’
[16:18:45.880]   - Field: ‘earlySignal’
[16:18:45.880]   - Field: ‘lazy’
[16:18:45.880]   - Field: ‘state’
[16:18:45.880] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.880] - Launch lazy future ...
[16:18:45.880] Packages needed by the future expression (n = 0): <none>
[16:18:45.881] Packages needed by future strategies (n = 0): <none>
[16:18:45.881] {
[16:18:45.881]     {
[16:18:45.881]         {
[16:18:45.881]             ...future.startTime <- base::Sys.time()
[16:18:45.881]             {
[16:18:45.881]                 {
[16:18:45.881]                   {
[16:18:45.881]                     {
[16:18:45.881]                       base::local({
[16:18:45.881]                         has_future <- base::requireNamespace("future", 
[16:18:45.881]                           quietly = TRUE)
[16:18:45.881]                         if (has_future) {
[16:18:45.881]                           ns <- base::getNamespace("future")
[16:18:45.881]                           version <- ns[[".package"]][["version"]]
[16:18:45.881]                           if (is.null(version)) 
[16:18:45.881]                             version <- utils::packageVersion("future")
[16:18:45.881]                         }
[16:18:45.881]                         else {
[16:18:45.881]                           version <- NULL
[16:18:45.881]                         }
[16:18:45.881]                         if (!has_future || version < "1.8.0") {
[16:18:45.881]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.881]                             "", base::R.version$version.string), 
[16:18:45.881]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.881]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.881]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.881]                               "release", "version")], collapse = " "), 
[16:18:45.881]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.881]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.881]                             info)
[16:18:45.881]                           info <- base::paste(info, collapse = "; ")
[16:18:45.881]                           if (!has_future) {
[16:18:45.881]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.881]                               info)
[16:18:45.881]                           }
[16:18:45.881]                           else {
[16:18:45.881]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.881]                               info, version)
[16:18:45.881]                           }
[16:18:45.881]                           base::stop(msg)
[16:18:45.881]                         }
[16:18:45.881]                       })
[16:18:45.881]                     }
[16:18:45.881]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.881]                     base::options(mc.cores = 1L)
[16:18:45.881]                   }
[16:18:45.881]                   ...future.strategy.old <- future::plan("list")
[16:18:45.881]                   options(future.plan = NULL)
[16:18:45.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.881]                 }
[16:18:45.881]                 ...future.workdir <- getwd()
[16:18:45.881]             }
[16:18:45.881]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.881]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.881]         }
[16:18:45.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.881]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:45.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.881]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.881]             base::names(...future.oldOptions))
[16:18:45.881]     }
[16:18:45.881]     if (FALSE) {
[16:18:45.881]     }
[16:18:45.881]     else {
[16:18:45.881]         if (TRUE) {
[16:18:45.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.881]                 open = "w")
[16:18:45.881]         }
[16:18:45.881]         else {
[16:18:45.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.881]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.881]         }
[16:18:45.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.881]             base::sink(type = "output", split = FALSE)
[16:18:45.881]             base::close(...future.stdout)
[16:18:45.881]         }, add = TRUE)
[16:18:45.881]     }
[16:18:45.881]     ...future.frame <- base::sys.nframe()
[16:18:45.881]     ...future.conditions <- base::list()
[16:18:45.881]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.881]     if (FALSE) {
[16:18:45.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.881]     }
[16:18:45.881]     ...future.result <- base::tryCatch({
[16:18:45.881]         base::withCallingHandlers({
[16:18:45.881]             ...future.value <- base::withVisible(base::local({
[16:18:45.881]                 ...future.makeSendCondition <- base::local({
[16:18:45.881]                   sendCondition <- NULL
[16:18:45.881]                   function(frame = 1L) {
[16:18:45.881]                     if (is.function(sendCondition)) 
[16:18:45.881]                       return(sendCondition)
[16:18:45.881]                     ns <- getNamespace("parallel")
[16:18:45.881]                     if (exists("sendData", mode = "function", 
[16:18:45.881]                       envir = ns)) {
[16:18:45.881]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.881]                         envir = ns)
[16:18:45.881]                       envir <- sys.frame(frame)
[16:18:45.881]                       master <- NULL
[16:18:45.881]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.881]                         !identical(envir, emptyenv())) {
[16:18:45.881]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.881]                           inherits = FALSE)) {
[16:18:45.881]                           master <- get("master", mode = "list", 
[16:18:45.881]                             envir = envir, inherits = FALSE)
[16:18:45.881]                           if (inherits(master, c("SOCKnode", 
[16:18:45.881]                             "SOCK0node"))) {
[16:18:45.881]                             sendCondition <<- function(cond) {
[16:18:45.881]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.881]                                 success = TRUE)
[16:18:45.881]                               parallel_sendData(master, data)
[16:18:45.881]                             }
[16:18:45.881]                             return(sendCondition)
[16:18:45.881]                           }
[16:18:45.881]                         }
[16:18:45.881]                         frame <- frame + 1L
[16:18:45.881]                         envir <- sys.frame(frame)
[16:18:45.881]                       }
[16:18:45.881]                     }
[16:18:45.881]                     sendCondition <<- function(cond) NULL
[16:18:45.881]                   }
[16:18:45.881]                 })
[16:18:45.881]                 withCallingHandlers({
[16:18:45.881]                   {
[16:18:45.881]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.881]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.881]                       ...future.globals.maxSize)) {
[16:18:45.881]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.881]                       on.exit(options(oopts), add = TRUE)
[16:18:45.881]                     }
[16:18:45.881]                     {
[16:18:45.881]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.881]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.881]                         USE.NAMES = FALSE)
[16:18:45.881]                       do.call(mapply, args = args)
[16:18:45.881]                     }
[16:18:45.881]                   }
[16:18:45.881]                 }, immediateCondition = function(cond) {
[16:18:45.881]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.881]                   sendCondition(cond)
[16:18:45.881]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.881]                   {
[16:18:45.881]                     inherits <- base::inherits
[16:18:45.881]                     invokeRestart <- base::invokeRestart
[16:18:45.881]                     is.null <- base::is.null
[16:18:45.881]                     muffled <- FALSE
[16:18:45.881]                     if (inherits(cond, "message")) {
[16:18:45.881]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.881]                       if (muffled) 
[16:18:45.881]                         invokeRestart("muffleMessage")
[16:18:45.881]                     }
[16:18:45.881]                     else if (inherits(cond, "warning")) {
[16:18:45.881]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.881]                       if (muffled) 
[16:18:45.881]                         invokeRestart("muffleWarning")
[16:18:45.881]                     }
[16:18:45.881]                     else if (inherits(cond, "condition")) {
[16:18:45.881]                       if (!is.null(pattern)) {
[16:18:45.881]                         computeRestarts <- base::computeRestarts
[16:18:45.881]                         grepl <- base::grepl
[16:18:45.881]                         restarts <- computeRestarts(cond)
[16:18:45.881]                         for (restart in restarts) {
[16:18:45.881]                           name <- restart$name
[16:18:45.881]                           if (is.null(name)) 
[16:18:45.881]                             next
[16:18:45.881]                           if (!grepl(pattern, name)) 
[16:18:45.881]                             next
[16:18:45.881]                           invokeRestart(restart)
[16:18:45.881]                           muffled <- TRUE
[16:18:45.881]                           break
[16:18:45.881]                         }
[16:18:45.881]                       }
[16:18:45.881]                     }
[16:18:45.881]                     invisible(muffled)
[16:18:45.881]                   }
[16:18:45.881]                   muffleCondition(cond)
[16:18:45.881]                 })
[16:18:45.881]             }))
[16:18:45.881]             future::FutureResult(value = ...future.value$value, 
[16:18:45.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.881]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.881]                     ...future.globalenv.names))
[16:18:45.881]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.881]         }, condition = base::local({
[16:18:45.881]             c <- base::c
[16:18:45.881]             inherits <- base::inherits
[16:18:45.881]             invokeRestart <- base::invokeRestart
[16:18:45.881]             length <- base::length
[16:18:45.881]             list <- base::list
[16:18:45.881]             seq.int <- base::seq.int
[16:18:45.881]             signalCondition <- base::signalCondition
[16:18:45.881]             sys.calls <- base::sys.calls
[16:18:45.881]             `[[` <- base::`[[`
[16:18:45.881]             `+` <- base::`+`
[16:18:45.881]             `<<-` <- base::`<<-`
[16:18:45.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.881]                   3L)]
[16:18:45.881]             }
[16:18:45.881]             function(cond) {
[16:18:45.881]                 is_error <- inherits(cond, "error")
[16:18:45.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.881]                   NULL)
[16:18:45.881]                 if (is_error) {
[16:18:45.881]                   sessionInformation <- function() {
[16:18:45.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.881]                       search = base::search(), system = base::Sys.info())
[16:18:45.881]                   }
[16:18:45.881]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.881]                     cond$call), session = sessionInformation(), 
[16:18:45.881]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.881]                   signalCondition(cond)
[16:18:45.881]                 }
[16:18:45.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.881]                 "immediateCondition"))) {
[16:18:45.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.881]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.881]                   if (TRUE && !signal) {
[16:18:45.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.881]                     {
[16:18:45.881]                       inherits <- base::inherits
[16:18:45.881]                       invokeRestart <- base::invokeRestart
[16:18:45.881]                       is.null <- base::is.null
[16:18:45.881]                       muffled <- FALSE
[16:18:45.881]                       if (inherits(cond, "message")) {
[16:18:45.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.881]                         if (muffled) 
[16:18:45.881]                           invokeRestart("muffleMessage")
[16:18:45.881]                       }
[16:18:45.881]                       else if (inherits(cond, "warning")) {
[16:18:45.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.881]                         if (muffled) 
[16:18:45.881]                           invokeRestart("muffleWarning")
[16:18:45.881]                       }
[16:18:45.881]                       else if (inherits(cond, "condition")) {
[16:18:45.881]                         if (!is.null(pattern)) {
[16:18:45.881]                           computeRestarts <- base::computeRestarts
[16:18:45.881]                           grepl <- base::grepl
[16:18:45.881]                           restarts <- computeRestarts(cond)
[16:18:45.881]                           for (restart in restarts) {
[16:18:45.881]                             name <- restart$name
[16:18:45.881]                             if (is.null(name)) 
[16:18:45.881]                               next
[16:18:45.881]                             if (!grepl(pattern, name)) 
[16:18:45.881]                               next
[16:18:45.881]                             invokeRestart(restart)
[16:18:45.881]                             muffled <- TRUE
[16:18:45.881]                             break
[16:18:45.881]                           }
[16:18:45.881]                         }
[16:18:45.881]                       }
[16:18:45.881]                       invisible(muffled)
[16:18:45.881]                     }
[16:18:45.881]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.881]                   }
[16:18:45.881]                 }
[16:18:45.881]                 else {
[16:18:45.881]                   if (TRUE) {
[16:18:45.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.881]                     {
[16:18:45.881]                       inherits <- base::inherits
[16:18:45.881]                       invokeRestart <- base::invokeRestart
[16:18:45.881]                       is.null <- base::is.null
[16:18:45.881]                       muffled <- FALSE
[16:18:45.881]                       if (inherits(cond, "message")) {
[16:18:45.881]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.881]                         if (muffled) 
[16:18:45.881]                           invokeRestart("muffleMessage")
[16:18:45.881]                       }
[16:18:45.881]                       else if (inherits(cond, "warning")) {
[16:18:45.881]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.881]                         if (muffled) 
[16:18:45.881]                           invokeRestart("muffleWarning")
[16:18:45.881]                       }
[16:18:45.881]                       else if (inherits(cond, "condition")) {
[16:18:45.881]                         if (!is.null(pattern)) {
[16:18:45.881]                           computeRestarts <- base::computeRestarts
[16:18:45.881]                           grepl <- base::grepl
[16:18:45.881]                           restarts <- computeRestarts(cond)
[16:18:45.881]                           for (restart in restarts) {
[16:18:45.881]                             name <- restart$name
[16:18:45.881]                             if (is.null(name)) 
[16:18:45.881]                               next
[16:18:45.881]                             if (!grepl(pattern, name)) 
[16:18:45.881]                               next
[16:18:45.881]                             invokeRestart(restart)
[16:18:45.881]                             muffled <- TRUE
[16:18:45.881]                             break
[16:18:45.881]                           }
[16:18:45.881]                         }
[16:18:45.881]                       }
[16:18:45.881]                       invisible(muffled)
[16:18:45.881]                     }
[16:18:45.881]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.881]                   }
[16:18:45.881]                 }
[16:18:45.881]             }
[16:18:45.881]         }))
[16:18:45.881]     }, error = function(ex) {
[16:18:45.881]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.881]                 ...future.rng), started = ...future.startTime, 
[16:18:45.881]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.881]             version = "1.8"), class = "FutureResult")
[16:18:45.881]     }, finally = {
[16:18:45.881]         if (!identical(...future.workdir, getwd())) 
[16:18:45.881]             setwd(...future.workdir)
[16:18:45.881]         {
[16:18:45.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.881]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.881]             }
[16:18:45.881]             base::options(...future.oldOptions)
[16:18:45.881]             if (.Platform$OS.type == "windows") {
[16:18:45.881]                 old_names <- names(...future.oldEnvVars)
[16:18:45.881]                 envs <- base::Sys.getenv()
[16:18:45.881]                 names <- names(envs)
[16:18:45.881]                 common <- intersect(names, old_names)
[16:18:45.881]                 added <- setdiff(names, old_names)
[16:18:45.881]                 removed <- setdiff(old_names, names)
[16:18:45.881]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.881]                   envs[common]]
[16:18:45.881]                 NAMES <- toupper(changed)
[16:18:45.881]                 args <- list()
[16:18:45.881]                 for (kk in seq_along(NAMES)) {
[16:18:45.881]                   name <- changed[[kk]]
[16:18:45.881]                   NAME <- NAMES[[kk]]
[16:18:45.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.881]                     next
[16:18:45.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.881]                 }
[16:18:45.881]                 NAMES <- toupper(added)
[16:18:45.881]                 for (kk in seq_along(NAMES)) {
[16:18:45.881]                   name <- added[[kk]]
[16:18:45.881]                   NAME <- NAMES[[kk]]
[16:18:45.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.881]                     next
[16:18:45.881]                   args[[name]] <- ""
[16:18:45.881]                 }
[16:18:45.881]                 NAMES <- toupper(removed)
[16:18:45.881]                 for (kk in seq_along(NAMES)) {
[16:18:45.881]                   name <- removed[[kk]]
[16:18:45.881]                   NAME <- NAMES[[kk]]
[16:18:45.881]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.881]                     next
[16:18:45.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.881]                 }
[16:18:45.881]                 if (length(args) > 0) 
[16:18:45.881]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.881]             }
[16:18:45.881]             else {
[16:18:45.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.881]             }
[16:18:45.881]             {
[16:18:45.881]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.881]                   0L) {
[16:18:45.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.881]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.881]                   base::options(opts)
[16:18:45.881]                 }
[16:18:45.881]                 {
[16:18:45.881]                   {
[16:18:45.881]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.881]                     NULL
[16:18:45.881]                   }
[16:18:45.881]                   options(future.plan = NULL)
[16:18:45.881]                   if (is.na(NA_character_)) 
[16:18:45.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.881]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.881]                     .init = FALSE)
[16:18:45.881]                 }
[16:18:45.881]             }
[16:18:45.881]         }
[16:18:45.881]     })
[16:18:45.881]     if (TRUE) {
[16:18:45.881]         base::sink(type = "output", split = FALSE)
[16:18:45.881]         if (TRUE) {
[16:18:45.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.881]         }
[16:18:45.881]         else {
[16:18:45.881]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.881]         }
[16:18:45.881]         base::close(...future.stdout)
[16:18:45.881]         ...future.stdout <- NULL
[16:18:45.881]     }
[16:18:45.881]     ...future.result$conditions <- ...future.conditions
[16:18:45.881]     ...future.result$finished <- base::Sys.time()
[16:18:45.881]     ...future.result
[16:18:45.881] }
[16:18:45.883] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[16:18:45.884] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[16:18:45.884] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[16:18:45.884] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:45.884] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.885] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[16:18:45.885] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[16:18:45.885] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:45.885] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.885] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:45.886] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:45.886] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[16:18:45.886] MultisessionFuture started
[16:18:45.886] - Launch lazy future ... done
[16:18:45.887] run() for ‘MultisessionFuture’ ... done
[16:18:45.887] Created future:
[16:18:45.887] MultisessionFuture:
[16:18:45.887] Label: ‘future_.mapply-2’
[16:18:45.887] Expression:
[16:18:45.887] {
[16:18:45.887]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.887]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.887]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.887]         on.exit(options(oopts), add = TRUE)
[16:18:45.887]     }
[16:18:45.887]     {
[16:18:45.887]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.887]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.887]         do.call(mapply, args = args)
[16:18:45.887]     }
[16:18:45.887] }
[16:18:45.887] Lazy evaluation: FALSE
[16:18:45.887] Asynchronous evaluation: TRUE
[16:18:45.887] Local evaluation: TRUE
[16:18:45.887] Environment: R_GlobalEnv
[16:18:45.887] Capture standard output: TRUE
[16:18:45.887] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.887] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.887] Packages: <none>
[16:18:45.887] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.887] Resolved: FALSE
[16:18:45.887] Value: <not collected>
[16:18:45.887] Conditions captured: <none>
[16:18:45.887] Early signaling: FALSE
[16:18:45.887] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.887] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.898] Chunk #2 of 2 ... DONE
[16:18:45.898] Launching 2 futures (chunks) ... DONE
[16:18:45.898] Resolving 2 futures (chunks) ...
[16:18:45.898] resolve() on list ...
[16:18:45.898]  recursive: 0
[16:18:45.899]  length: 2
[16:18:45.899] 
[16:18:45.899] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.899] - Validating connection of MultisessionFuture
[16:18:45.899] - received message: FutureResult
[16:18:45.899] - Received FutureResult
[16:18:45.900] - Erased future from FutureRegistry
[16:18:45.900] result() for ClusterFuture ...
[16:18:45.900] - result already collected: FutureResult
[16:18:45.900] result() for ClusterFuture ... done
[16:18:45.900] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.900] Future #1
[16:18:45.900] result() for ClusterFuture ...
[16:18:45.900] - result already collected: FutureResult
[16:18:45.900] result() for ClusterFuture ... done
[16:18:45.900] result() for ClusterFuture ...
[16:18:45.900] - result already collected: FutureResult
[16:18:45.901] result() for ClusterFuture ... done
[16:18:45.901] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:45.901] - nx: 2
[16:18:45.901] - relay: TRUE
[16:18:45.901] - stdout: TRUE
[16:18:45.901] - signal: TRUE
[16:18:45.901] - resignal: FALSE
[16:18:45.901] - force: TRUE
[16:18:45.901] - relayed: [n=2] FALSE, FALSE
[16:18:45.901] - queued futures: [n=2] FALSE, FALSE
[16:18:45.901]  - until=1
[16:18:45.902]  - relaying element #1
[16:18:45.902] result() for ClusterFuture ...
[16:18:45.902] - result already collected: FutureResult
[16:18:45.902] result() for ClusterFuture ... done
[16:18:45.902] result() for ClusterFuture ...
[16:18:45.902] - result already collected: FutureResult
[16:18:45.902] result() for ClusterFuture ... done
[16:18:45.902] result() for ClusterFuture ...
[16:18:45.902] - result already collected: FutureResult
[16:18:45.902] result() for ClusterFuture ... done
[16:18:45.902] result() for ClusterFuture ...
[16:18:45.902] - result already collected: FutureResult
[16:18:45.903] result() for ClusterFuture ... done
[16:18:45.903] - relayed: [n=2] TRUE, FALSE
[16:18:45.903] - queued futures: [n=2] TRUE, FALSE
[16:18:45.903] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:45.903]  length: 1 (resolved future 1)
[16:18:45.934] receiveMessageFromWorker() for ClusterFuture ...
[16:18:45.934] - Validating connection of MultisessionFuture
[16:18:45.934] - received message: FutureResult
[16:18:45.934] - Received FutureResult
[16:18:45.934] - Erased future from FutureRegistry
[16:18:45.934] result() for ClusterFuture ...
[16:18:45.934] - result already collected: FutureResult
[16:18:45.935] result() for ClusterFuture ... done
[16:18:45.935] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:45.935] Future #2
[16:18:45.935] result() for ClusterFuture ...
[16:18:45.935] - result already collected: FutureResult
[16:18:45.935] result() for ClusterFuture ... done
[16:18:45.935] result() for ClusterFuture ...
[16:18:45.935] - result already collected: FutureResult
[16:18:45.935] result() for ClusterFuture ... done
[16:18:45.935] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:45.935] - nx: 2
[16:18:45.936] - relay: TRUE
[16:18:45.936] - stdout: TRUE
[16:18:45.936] - signal: TRUE
[16:18:45.936] - resignal: FALSE
[16:18:45.936] - force: TRUE
[16:18:45.936] - relayed: [n=2] TRUE, FALSE
[16:18:45.936] - queued futures: [n=2] TRUE, FALSE
[16:18:45.936]  - until=2
[16:18:45.936]  - relaying element #2
[16:18:45.936] result() for ClusterFuture ...
[16:18:45.936] - result already collected: FutureResult
[16:18:45.936] result() for ClusterFuture ... done
[16:18:45.937] result() for ClusterFuture ...
[16:18:45.937] - result already collected: FutureResult
[16:18:45.937] result() for ClusterFuture ... done
[16:18:45.937] result() for ClusterFuture ...
[16:18:45.937] - result already collected: FutureResult
[16:18:45.937] result() for ClusterFuture ... done
[16:18:45.937] result() for ClusterFuture ...
[16:18:45.937] - result already collected: FutureResult
[16:18:45.937] result() for ClusterFuture ... done
[16:18:45.937] - relayed: [n=2] TRUE, TRUE
[16:18:45.937] - queued futures: [n=2] TRUE, TRUE
[16:18:45.938] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:45.938]  length: 0 (resolved future 2)
[16:18:45.938] Relaying remaining futures
[16:18:45.938] signalConditionsASAP(NULL, pos=0) ...
[16:18:45.938] - nx: 2
[16:18:45.938] - relay: TRUE
[16:18:45.938] - stdout: TRUE
[16:18:45.938] - signal: TRUE
[16:18:45.938] - resignal: FALSE
[16:18:45.938] - force: TRUE
[16:18:45.938] - relayed: [n=2] TRUE, TRUE
[16:18:45.938] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:45.939] - relayed: [n=2] TRUE, TRUE
[16:18:45.939] - queued futures: [n=2] TRUE, TRUE
[16:18:45.939] signalConditionsASAP(NULL, pos=0) ... done
[16:18:45.939] resolve() on list ... DONE
[16:18:45.939] result() for ClusterFuture ...
[16:18:45.939] - result already collected: FutureResult
[16:18:45.939] result() for ClusterFuture ... done
[16:18:45.939] result() for ClusterFuture ...
[16:18:45.939] - result already collected: FutureResult
[16:18:45.939] result() for ClusterFuture ... done
[16:18:45.939] result() for ClusterFuture ...
[16:18:45.940] - result already collected: FutureResult
[16:18:45.940] result() for ClusterFuture ... done
[16:18:45.940] result() for ClusterFuture ...
[16:18:45.940] - result already collected: FutureResult
[16:18:45.940] result() for ClusterFuture ... done
[16:18:45.940]  - Number of value chunks collected: 2
[16:18:45.940] Resolving 2 futures (chunks) ... DONE
[16:18:45.940] Reducing values from 2 chunks ...
[16:18:45.940]  - Number of values collected after concatenation: 5
[16:18:45.940]  - Number of values expected: 5
[16:18:45.940] Reducing values from 2 chunks ... DONE
[16:18:45.941] future_mapply() ... DONE
[16:18:45.941] future_mapply() ...
[16:18:45.944] Number of chunks: 2
[16:18:45.944] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[16:18:45.945] getGlobalsAndPackagesXApply() ...
[16:18:45.945]  - future.globals: TRUE
[16:18:45.945] getGlobalsAndPackages() ...
[16:18:45.945] Searching for globals...
[16:18:45.946] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:45.946] Searching for globals ... DONE
[16:18:45.946] Resolving globals: FALSE
[16:18:45.947] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:45.947] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:45.947] - globals: [1] ‘FUN’
[16:18:45.947] 
[16:18:45.947] getGlobalsAndPackages() ... DONE
[16:18:45.947]  - globals found/used: [n=1] ‘FUN’
[16:18:45.947]  - needed namespaces: [n=0] 
[16:18:45.947] Finding globals ... DONE
[16:18:45.948] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:45.948] List of 2
[16:18:45.948]  $ ...future.FUN:function (C, k)  
[16:18:45.948]  $ MoreArgs     : NULL
[16:18:45.948]  - attr(*, "where")=List of 2
[16:18:45.948]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:45.948]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:45.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:45.948]  - attr(*, "resolved")= logi FALSE
[16:18:45.948]  - attr(*, "total_size")= num NA
[16:18:45.950] Packages to be attached in all futures: [n=0] 
[16:18:45.950] getGlobalsAndPackagesXApply() ... DONE
[16:18:45.951] Number of futures (= number of chunks): 2
[16:18:45.951] Launching 2 futures (chunks) ...
[16:18:45.951] Chunk #1 of 2 ...
[16:18:45.951]  - Finding globals in '...' for chunk #1 ...
[16:18:45.951] getGlobalsAndPackages() ...
[16:18:45.951] Searching for globals...
[16:18:45.951] 
[16:18:45.952] Searching for globals ... DONE
[16:18:45.952] - globals: [0] <none>
[16:18:45.952] getGlobalsAndPackages() ... DONE
[16:18:45.952]    + additional globals found: [n=0] 
[16:18:45.952]    + additional namespaces needed: [n=0] 
[16:18:45.952]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:45.952]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:45.952]  - seeds: <none>
[16:18:45.952]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.952] getGlobalsAndPackages() ...
[16:18:45.952] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.953] Resolving globals: FALSE
[16:18:45.953] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:45.953] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:45.954] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.954] 
[16:18:45.954] getGlobalsAndPackages() ... DONE
[16:18:45.954] run() for ‘Future’ ...
[16:18:45.954] - state: ‘created’
[16:18:45.954] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:45.968] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.968] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:45.968]   - Field: ‘node’
[16:18:45.968]   - Field: ‘label’
[16:18:45.968]   - Field: ‘local’
[16:18:45.968]   - Field: ‘owner’
[16:18:45.968]   - Field: ‘envir’
[16:18:45.968]   - Field: ‘workers’
[16:18:45.968]   - Field: ‘packages’
[16:18:45.968]   - Field: ‘gc’
[16:18:45.969]   - Field: ‘conditions’
[16:18:45.969]   - Field: ‘persistent’
[16:18:45.969]   - Field: ‘expr’
[16:18:45.969]   - Field: ‘uuid’
[16:18:45.969]   - Field: ‘seed’
[16:18:45.969]   - Field: ‘version’
[16:18:45.969]   - Field: ‘result’
[16:18:45.969]   - Field: ‘asynchronous’
[16:18:45.969]   - Field: ‘calls’
[16:18:45.969]   - Field: ‘globals’
[16:18:45.969]   - Field: ‘stdout’
[16:18:45.970]   - Field: ‘earlySignal’
[16:18:45.970]   - Field: ‘lazy’
[16:18:45.970]   - Field: ‘state’
[16:18:45.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:45.970] - Launch lazy future ...
[16:18:45.970] Packages needed by the future expression (n = 0): <none>
[16:18:45.970] Packages needed by future strategies (n = 0): <none>
[16:18:45.971] {
[16:18:45.971]     {
[16:18:45.971]         {
[16:18:45.971]             ...future.startTime <- base::Sys.time()
[16:18:45.971]             {
[16:18:45.971]                 {
[16:18:45.971]                   {
[16:18:45.971]                     {
[16:18:45.971]                       base::local({
[16:18:45.971]                         has_future <- base::requireNamespace("future", 
[16:18:45.971]                           quietly = TRUE)
[16:18:45.971]                         if (has_future) {
[16:18:45.971]                           ns <- base::getNamespace("future")
[16:18:45.971]                           version <- ns[[".package"]][["version"]]
[16:18:45.971]                           if (is.null(version)) 
[16:18:45.971]                             version <- utils::packageVersion("future")
[16:18:45.971]                         }
[16:18:45.971]                         else {
[16:18:45.971]                           version <- NULL
[16:18:45.971]                         }
[16:18:45.971]                         if (!has_future || version < "1.8.0") {
[16:18:45.971]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:45.971]                             "", base::R.version$version.string), 
[16:18:45.971]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:45.971]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:45.971]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:45.971]                               "release", "version")], collapse = " "), 
[16:18:45.971]                             hostname = base::Sys.info()[["nodename"]])
[16:18:45.971]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:45.971]                             info)
[16:18:45.971]                           info <- base::paste(info, collapse = "; ")
[16:18:45.971]                           if (!has_future) {
[16:18:45.971]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:45.971]                               info)
[16:18:45.971]                           }
[16:18:45.971]                           else {
[16:18:45.971]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:45.971]                               info, version)
[16:18:45.971]                           }
[16:18:45.971]                           base::stop(msg)
[16:18:45.971]                         }
[16:18:45.971]                       })
[16:18:45.971]                     }
[16:18:45.971]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:45.971]                     base::options(mc.cores = 1L)
[16:18:45.971]                   }
[16:18:45.971]                   ...future.strategy.old <- future::plan("list")
[16:18:45.971]                   options(future.plan = NULL)
[16:18:45.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:45.971]                 }
[16:18:45.971]                 ...future.workdir <- getwd()
[16:18:45.971]             }
[16:18:45.971]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:45.971]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:45.971]         }
[16:18:45.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:45.971]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:45.971]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:45.971]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:45.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:45.971]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:45.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:45.971]             base::names(...future.oldOptions))
[16:18:45.971]     }
[16:18:45.971]     if (FALSE) {
[16:18:45.971]     }
[16:18:45.971]     else {
[16:18:45.971]         if (TRUE) {
[16:18:45.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:45.971]                 open = "w")
[16:18:45.971]         }
[16:18:45.971]         else {
[16:18:45.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:45.971]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:45.971]         }
[16:18:45.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:45.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:45.971]             base::sink(type = "output", split = FALSE)
[16:18:45.971]             base::close(...future.stdout)
[16:18:45.971]         }, add = TRUE)
[16:18:45.971]     }
[16:18:45.971]     ...future.frame <- base::sys.nframe()
[16:18:45.971]     ...future.conditions <- base::list()
[16:18:45.971]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:45.971]     if (FALSE) {
[16:18:45.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:45.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:45.971]     }
[16:18:45.971]     ...future.result <- base::tryCatch({
[16:18:45.971]         base::withCallingHandlers({
[16:18:45.971]             ...future.value <- base::withVisible(base::local({
[16:18:45.971]                 ...future.makeSendCondition <- base::local({
[16:18:45.971]                   sendCondition <- NULL
[16:18:45.971]                   function(frame = 1L) {
[16:18:45.971]                     if (is.function(sendCondition)) 
[16:18:45.971]                       return(sendCondition)
[16:18:45.971]                     ns <- getNamespace("parallel")
[16:18:45.971]                     if (exists("sendData", mode = "function", 
[16:18:45.971]                       envir = ns)) {
[16:18:45.971]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:45.971]                         envir = ns)
[16:18:45.971]                       envir <- sys.frame(frame)
[16:18:45.971]                       master <- NULL
[16:18:45.971]                       while (!identical(envir, .GlobalEnv) && 
[16:18:45.971]                         !identical(envir, emptyenv())) {
[16:18:45.971]                         if (exists("master", mode = "list", envir = envir, 
[16:18:45.971]                           inherits = FALSE)) {
[16:18:45.971]                           master <- get("master", mode = "list", 
[16:18:45.971]                             envir = envir, inherits = FALSE)
[16:18:45.971]                           if (inherits(master, c("SOCKnode", 
[16:18:45.971]                             "SOCK0node"))) {
[16:18:45.971]                             sendCondition <<- function(cond) {
[16:18:45.971]                               data <- list(type = "VALUE", value = cond, 
[16:18:45.971]                                 success = TRUE)
[16:18:45.971]                               parallel_sendData(master, data)
[16:18:45.971]                             }
[16:18:45.971]                             return(sendCondition)
[16:18:45.971]                           }
[16:18:45.971]                         }
[16:18:45.971]                         frame <- frame + 1L
[16:18:45.971]                         envir <- sys.frame(frame)
[16:18:45.971]                       }
[16:18:45.971]                     }
[16:18:45.971]                     sendCondition <<- function(cond) NULL
[16:18:45.971]                   }
[16:18:45.971]                 })
[16:18:45.971]                 withCallingHandlers({
[16:18:45.971]                   {
[16:18:45.971]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.971]                     if (!identical(...future.globals.maxSize.org, 
[16:18:45.971]                       ...future.globals.maxSize)) {
[16:18:45.971]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.971]                       on.exit(options(oopts), add = TRUE)
[16:18:45.971]                     }
[16:18:45.971]                     {
[16:18:45.971]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.971]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:45.971]                         USE.NAMES = FALSE)
[16:18:45.971]                       do.call(mapply, args = args)
[16:18:45.971]                     }
[16:18:45.971]                   }
[16:18:45.971]                 }, immediateCondition = function(cond) {
[16:18:45.971]                   sendCondition <- ...future.makeSendCondition()
[16:18:45.971]                   sendCondition(cond)
[16:18:45.971]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.971]                   {
[16:18:45.971]                     inherits <- base::inherits
[16:18:45.971]                     invokeRestart <- base::invokeRestart
[16:18:45.971]                     is.null <- base::is.null
[16:18:45.971]                     muffled <- FALSE
[16:18:45.971]                     if (inherits(cond, "message")) {
[16:18:45.971]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:45.971]                       if (muffled) 
[16:18:45.971]                         invokeRestart("muffleMessage")
[16:18:45.971]                     }
[16:18:45.971]                     else if (inherits(cond, "warning")) {
[16:18:45.971]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:45.971]                       if (muffled) 
[16:18:45.971]                         invokeRestart("muffleWarning")
[16:18:45.971]                     }
[16:18:45.971]                     else if (inherits(cond, "condition")) {
[16:18:45.971]                       if (!is.null(pattern)) {
[16:18:45.971]                         computeRestarts <- base::computeRestarts
[16:18:45.971]                         grepl <- base::grepl
[16:18:45.971]                         restarts <- computeRestarts(cond)
[16:18:45.971]                         for (restart in restarts) {
[16:18:45.971]                           name <- restart$name
[16:18:45.971]                           if (is.null(name)) 
[16:18:45.971]                             next
[16:18:45.971]                           if (!grepl(pattern, name)) 
[16:18:45.971]                             next
[16:18:45.971]                           invokeRestart(restart)
[16:18:45.971]                           muffled <- TRUE
[16:18:45.971]                           break
[16:18:45.971]                         }
[16:18:45.971]                       }
[16:18:45.971]                     }
[16:18:45.971]                     invisible(muffled)
[16:18:45.971]                   }
[16:18:45.971]                   muffleCondition(cond)
[16:18:45.971]                 })
[16:18:45.971]             }))
[16:18:45.971]             future::FutureResult(value = ...future.value$value, 
[16:18:45.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.971]                   ...future.rng), globalenv = if (FALSE) 
[16:18:45.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:45.971]                     ...future.globalenv.names))
[16:18:45.971]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:45.971]         }, condition = base::local({
[16:18:45.971]             c <- base::c
[16:18:45.971]             inherits <- base::inherits
[16:18:45.971]             invokeRestart <- base::invokeRestart
[16:18:45.971]             length <- base::length
[16:18:45.971]             list <- base::list
[16:18:45.971]             seq.int <- base::seq.int
[16:18:45.971]             signalCondition <- base::signalCondition
[16:18:45.971]             sys.calls <- base::sys.calls
[16:18:45.971]             `[[` <- base::`[[`
[16:18:45.971]             `+` <- base::`+`
[16:18:45.971]             `<<-` <- base::`<<-`
[16:18:45.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:45.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:45.971]                   3L)]
[16:18:45.971]             }
[16:18:45.971]             function(cond) {
[16:18:45.971]                 is_error <- inherits(cond, "error")
[16:18:45.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:45.971]                   NULL)
[16:18:45.971]                 if (is_error) {
[16:18:45.971]                   sessionInformation <- function() {
[16:18:45.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:45.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:45.971]                       search = base::search(), system = base::Sys.info())
[16:18:45.971]                   }
[16:18:45.971]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:45.971]                     cond$call), session = sessionInformation(), 
[16:18:45.971]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:45.971]                   signalCondition(cond)
[16:18:45.971]                 }
[16:18:45.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:45.971]                 "immediateCondition"))) {
[16:18:45.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:45.971]                   ...future.conditions[[length(...future.conditions) + 
[16:18:45.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:45.971]                   if (TRUE && !signal) {
[16:18:45.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.971]                     {
[16:18:45.971]                       inherits <- base::inherits
[16:18:45.971]                       invokeRestart <- base::invokeRestart
[16:18:45.971]                       is.null <- base::is.null
[16:18:45.971]                       muffled <- FALSE
[16:18:45.971]                       if (inherits(cond, "message")) {
[16:18:45.971]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.971]                         if (muffled) 
[16:18:45.971]                           invokeRestart("muffleMessage")
[16:18:45.971]                       }
[16:18:45.971]                       else if (inherits(cond, "warning")) {
[16:18:45.971]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.971]                         if (muffled) 
[16:18:45.971]                           invokeRestart("muffleWarning")
[16:18:45.971]                       }
[16:18:45.971]                       else if (inherits(cond, "condition")) {
[16:18:45.971]                         if (!is.null(pattern)) {
[16:18:45.971]                           computeRestarts <- base::computeRestarts
[16:18:45.971]                           grepl <- base::grepl
[16:18:45.971]                           restarts <- computeRestarts(cond)
[16:18:45.971]                           for (restart in restarts) {
[16:18:45.971]                             name <- restart$name
[16:18:45.971]                             if (is.null(name)) 
[16:18:45.971]                               next
[16:18:45.971]                             if (!grepl(pattern, name)) 
[16:18:45.971]                               next
[16:18:45.971]                             invokeRestart(restart)
[16:18:45.971]                             muffled <- TRUE
[16:18:45.971]                             break
[16:18:45.971]                           }
[16:18:45.971]                         }
[16:18:45.971]                       }
[16:18:45.971]                       invisible(muffled)
[16:18:45.971]                     }
[16:18:45.971]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.971]                   }
[16:18:45.971]                 }
[16:18:45.971]                 else {
[16:18:45.971]                   if (TRUE) {
[16:18:45.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:45.971]                     {
[16:18:45.971]                       inherits <- base::inherits
[16:18:45.971]                       invokeRestart <- base::invokeRestart
[16:18:45.971]                       is.null <- base::is.null
[16:18:45.971]                       muffled <- FALSE
[16:18:45.971]                       if (inherits(cond, "message")) {
[16:18:45.971]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:45.971]                         if (muffled) 
[16:18:45.971]                           invokeRestart("muffleMessage")
[16:18:45.971]                       }
[16:18:45.971]                       else if (inherits(cond, "warning")) {
[16:18:45.971]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:45.971]                         if (muffled) 
[16:18:45.971]                           invokeRestart("muffleWarning")
[16:18:45.971]                       }
[16:18:45.971]                       else if (inherits(cond, "condition")) {
[16:18:45.971]                         if (!is.null(pattern)) {
[16:18:45.971]                           computeRestarts <- base::computeRestarts
[16:18:45.971]                           grepl <- base::grepl
[16:18:45.971]                           restarts <- computeRestarts(cond)
[16:18:45.971]                           for (restart in restarts) {
[16:18:45.971]                             name <- restart$name
[16:18:45.971]                             if (is.null(name)) 
[16:18:45.971]                               next
[16:18:45.971]                             if (!grepl(pattern, name)) 
[16:18:45.971]                               next
[16:18:45.971]                             invokeRestart(restart)
[16:18:45.971]                             muffled <- TRUE
[16:18:45.971]                             break
[16:18:45.971]                           }
[16:18:45.971]                         }
[16:18:45.971]                       }
[16:18:45.971]                       invisible(muffled)
[16:18:45.971]                     }
[16:18:45.971]                     muffleCondition(cond, pattern = "^muffle")
[16:18:45.971]                   }
[16:18:45.971]                 }
[16:18:45.971]             }
[16:18:45.971]         }))
[16:18:45.971]     }, error = function(ex) {
[16:18:45.971]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:45.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:45.971]                 ...future.rng), started = ...future.startTime, 
[16:18:45.971]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:45.971]             version = "1.8"), class = "FutureResult")
[16:18:45.971]     }, finally = {
[16:18:45.971]         if (!identical(...future.workdir, getwd())) 
[16:18:45.971]             setwd(...future.workdir)
[16:18:45.971]         {
[16:18:45.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:45.971]                 ...future.oldOptions$nwarnings <- NULL
[16:18:45.971]             }
[16:18:45.971]             base::options(...future.oldOptions)
[16:18:45.971]             if (.Platform$OS.type == "windows") {
[16:18:45.971]                 old_names <- names(...future.oldEnvVars)
[16:18:45.971]                 envs <- base::Sys.getenv()
[16:18:45.971]                 names <- names(envs)
[16:18:45.971]                 common <- intersect(names, old_names)
[16:18:45.971]                 added <- setdiff(names, old_names)
[16:18:45.971]                 removed <- setdiff(old_names, names)
[16:18:45.971]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:45.971]                   envs[common]]
[16:18:45.971]                 NAMES <- toupper(changed)
[16:18:45.971]                 args <- list()
[16:18:45.971]                 for (kk in seq_along(NAMES)) {
[16:18:45.971]                   name <- changed[[kk]]
[16:18:45.971]                   NAME <- NAMES[[kk]]
[16:18:45.971]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.971]                     next
[16:18:45.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.971]                 }
[16:18:45.971]                 NAMES <- toupper(added)
[16:18:45.971]                 for (kk in seq_along(NAMES)) {
[16:18:45.971]                   name <- added[[kk]]
[16:18:45.971]                   NAME <- NAMES[[kk]]
[16:18:45.971]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.971]                     next
[16:18:45.971]                   args[[name]] <- ""
[16:18:45.971]                 }
[16:18:45.971]                 NAMES <- toupper(removed)
[16:18:45.971]                 for (kk in seq_along(NAMES)) {
[16:18:45.971]                   name <- removed[[kk]]
[16:18:45.971]                   NAME <- NAMES[[kk]]
[16:18:45.971]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:45.971]                     next
[16:18:45.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:45.971]                 }
[16:18:45.971]                 if (length(args) > 0) 
[16:18:45.971]                   base::do.call(base::Sys.setenv, args = args)
[16:18:45.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:45.971]             }
[16:18:45.971]             else {
[16:18:45.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:45.971]             }
[16:18:45.971]             {
[16:18:45.971]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:45.971]                   0L) {
[16:18:45.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:45.971]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:45.971]                   base::options(opts)
[16:18:45.971]                 }
[16:18:45.971]                 {
[16:18:45.971]                   {
[16:18:45.971]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:45.971]                     NULL
[16:18:45.971]                   }
[16:18:45.971]                   options(future.plan = NULL)
[16:18:45.971]                   if (is.na(NA_character_)) 
[16:18:45.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:45.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:45.971]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:45.971]                     .init = FALSE)
[16:18:45.971]                 }
[16:18:45.971]             }
[16:18:45.971]         }
[16:18:45.971]     })
[16:18:45.971]     if (TRUE) {
[16:18:45.971]         base::sink(type = "output", split = FALSE)
[16:18:45.971]         if (TRUE) {
[16:18:45.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:45.971]         }
[16:18:45.971]         else {
[16:18:45.971]             ...future.result["stdout"] <- base::list(NULL)
[16:18:45.971]         }
[16:18:45.971]         base::close(...future.stdout)
[16:18:45.971]         ...future.stdout <- NULL
[16:18:45.971]     }
[16:18:45.971]     ...future.result$conditions <- ...future.conditions
[16:18:45.971]     ...future.result$finished <- base::Sys.time()
[16:18:45.971]     ...future.result
[16:18:45.971] }
[16:18:45.973] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[16:18:45.973] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[16:18:45.974] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[16:18:45.974] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:45.974] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.974] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[16:18:45.975] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[16:18:45.975] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:45.975] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.975] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:45.975] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:45.976] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[16:18:45.976] MultisessionFuture started
[16:18:45.976] - Launch lazy future ... done
[16:18:45.976] run() for ‘MultisessionFuture’ ... done
[16:18:45.976] Created future:
[16:18:45.976] MultisessionFuture:
[16:18:45.976] Label: ‘future_mapply-1’
[16:18:45.976] Expression:
[16:18:45.976] {
[16:18:45.976]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:45.976]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:45.976]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:45.976]         on.exit(options(oopts), add = TRUE)
[16:18:45.976]     }
[16:18:45.976]     {
[16:18:45.976]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:45.976]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:45.976]         do.call(mapply, args = args)
[16:18:45.976]     }
[16:18:45.976] }
[16:18:45.976] Lazy evaluation: FALSE
[16:18:45.976] Asynchronous evaluation: TRUE
[16:18:45.976] Local evaluation: TRUE
[16:18:45.976] Environment: R_GlobalEnv
[16:18:45.976] Capture standard output: TRUE
[16:18:45.976] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:45.976] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:45.976] Packages: <none>
[16:18:45.976] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:45.976] Resolved: FALSE
[16:18:45.976] Value: <not collected>
[16:18:45.976] Conditions captured: <none>
[16:18:45.976] Early signaling: FALSE
[16:18:45.976] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:45.976] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:45.988] Chunk #1 of 2 ... DONE
[16:18:45.988] Chunk #2 of 2 ...
[16:18:45.988]  - Finding globals in '...' for chunk #2 ...
[16:18:45.988] getGlobalsAndPackages() ...
[16:18:45.988] Searching for globals...
[16:18:45.989] 
[16:18:45.989] Searching for globals ... DONE
[16:18:45.989] - globals: [0] <none>
[16:18:45.989] getGlobalsAndPackages() ... DONE
[16:18:45.989]    + additional globals found: [n=0] 
[16:18:45.989]    + additional namespaces needed: [n=0] 
[16:18:45.989]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:45.989]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:45.989]  - seeds: <none>
[16:18:45.990]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.990] getGlobalsAndPackages() ...
[16:18:45.990] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.990] Resolving globals: FALSE
[16:18:45.990] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[16:18:45.991] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:45.991] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:45.991] 
[16:18:45.991] getGlobalsAndPackages() ... DONE
[16:18:45.991] run() for ‘Future’ ...
[16:18:45.991] - state: ‘created’
[16:18:45.992] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.005] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.005] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.005]   - Field: ‘node’
[16:18:46.005]   - Field: ‘label’
[16:18:46.005]   - Field: ‘local’
[16:18:46.006]   - Field: ‘owner’
[16:18:46.006]   - Field: ‘envir’
[16:18:46.006]   - Field: ‘workers’
[16:18:46.006]   - Field: ‘packages’
[16:18:46.006]   - Field: ‘gc’
[16:18:46.006]   - Field: ‘conditions’
[16:18:46.006]   - Field: ‘persistent’
[16:18:46.006]   - Field: ‘expr’
[16:18:46.006]   - Field: ‘uuid’
[16:18:46.006]   - Field: ‘seed’
[16:18:46.006]   - Field: ‘version’
[16:18:46.007]   - Field: ‘result’
[16:18:46.007]   - Field: ‘asynchronous’
[16:18:46.007]   - Field: ‘calls’
[16:18:46.007]   - Field: ‘globals’
[16:18:46.007]   - Field: ‘stdout’
[16:18:46.007]   - Field: ‘earlySignal’
[16:18:46.007]   - Field: ‘lazy’
[16:18:46.007]   - Field: ‘state’
[16:18:46.007] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.007] - Launch lazy future ...
[16:18:46.008] Packages needed by the future expression (n = 0): <none>
[16:18:46.008] Packages needed by future strategies (n = 0): <none>
[16:18:46.008] {
[16:18:46.008]     {
[16:18:46.008]         {
[16:18:46.008]             ...future.startTime <- base::Sys.time()
[16:18:46.008]             {
[16:18:46.008]                 {
[16:18:46.008]                   {
[16:18:46.008]                     {
[16:18:46.008]                       base::local({
[16:18:46.008]                         has_future <- base::requireNamespace("future", 
[16:18:46.008]                           quietly = TRUE)
[16:18:46.008]                         if (has_future) {
[16:18:46.008]                           ns <- base::getNamespace("future")
[16:18:46.008]                           version <- ns[[".package"]][["version"]]
[16:18:46.008]                           if (is.null(version)) 
[16:18:46.008]                             version <- utils::packageVersion("future")
[16:18:46.008]                         }
[16:18:46.008]                         else {
[16:18:46.008]                           version <- NULL
[16:18:46.008]                         }
[16:18:46.008]                         if (!has_future || version < "1.8.0") {
[16:18:46.008]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.008]                             "", base::R.version$version.string), 
[16:18:46.008]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.008]                               "release", "version")], collapse = " "), 
[16:18:46.008]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.008]                             info)
[16:18:46.008]                           info <- base::paste(info, collapse = "; ")
[16:18:46.008]                           if (!has_future) {
[16:18:46.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.008]                               info)
[16:18:46.008]                           }
[16:18:46.008]                           else {
[16:18:46.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.008]                               info, version)
[16:18:46.008]                           }
[16:18:46.008]                           base::stop(msg)
[16:18:46.008]                         }
[16:18:46.008]                       })
[16:18:46.008]                     }
[16:18:46.008]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.008]                     base::options(mc.cores = 1L)
[16:18:46.008]                   }
[16:18:46.008]                   ...future.strategy.old <- future::plan("list")
[16:18:46.008]                   options(future.plan = NULL)
[16:18:46.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.008]                 }
[16:18:46.008]                 ...future.workdir <- getwd()
[16:18:46.008]             }
[16:18:46.008]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.008]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.008]         }
[16:18:46.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.008]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.008]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.008]             base::names(...future.oldOptions))
[16:18:46.008]     }
[16:18:46.008]     if (FALSE) {
[16:18:46.008]     }
[16:18:46.008]     else {
[16:18:46.008]         if (TRUE) {
[16:18:46.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.008]                 open = "w")
[16:18:46.008]         }
[16:18:46.008]         else {
[16:18:46.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.008]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.008]         }
[16:18:46.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.008]             base::sink(type = "output", split = FALSE)
[16:18:46.008]             base::close(...future.stdout)
[16:18:46.008]         }, add = TRUE)
[16:18:46.008]     }
[16:18:46.008]     ...future.frame <- base::sys.nframe()
[16:18:46.008]     ...future.conditions <- base::list()
[16:18:46.008]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.008]     if (FALSE) {
[16:18:46.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.008]     }
[16:18:46.008]     ...future.result <- base::tryCatch({
[16:18:46.008]         base::withCallingHandlers({
[16:18:46.008]             ...future.value <- base::withVisible(base::local({
[16:18:46.008]                 ...future.makeSendCondition <- base::local({
[16:18:46.008]                   sendCondition <- NULL
[16:18:46.008]                   function(frame = 1L) {
[16:18:46.008]                     if (is.function(sendCondition)) 
[16:18:46.008]                       return(sendCondition)
[16:18:46.008]                     ns <- getNamespace("parallel")
[16:18:46.008]                     if (exists("sendData", mode = "function", 
[16:18:46.008]                       envir = ns)) {
[16:18:46.008]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.008]                         envir = ns)
[16:18:46.008]                       envir <- sys.frame(frame)
[16:18:46.008]                       master <- NULL
[16:18:46.008]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.008]                         !identical(envir, emptyenv())) {
[16:18:46.008]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.008]                           inherits = FALSE)) {
[16:18:46.008]                           master <- get("master", mode = "list", 
[16:18:46.008]                             envir = envir, inherits = FALSE)
[16:18:46.008]                           if (inherits(master, c("SOCKnode", 
[16:18:46.008]                             "SOCK0node"))) {
[16:18:46.008]                             sendCondition <<- function(cond) {
[16:18:46.008]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.008]                                 success = TRUE)
[16:18:46.008]                               parallel_sendData(master, data)
[16:18:46.008]                             }
[16:18:46.008]                             return(sendCondition)
[16:18:46.008]                           }
[16:18:46.008]                         }
[16:18:46.008]                         frame <- frame + 1L
[16:18:46.008]                         envir <- sys.frame(frame)
[16:18:46.008]                       }
[16:18:46.008]                     }
[16:18:46.008]                     sendCondition <<- function(cond) NULL
[16:18:46.008]                   }
[16:18:46.008]                 })
[16:18:46.008]                 withCallingHandlers({
[16:18:46.008]                   {
[16:18:46.008]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.008]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.008]                       ...future.globals.maxSize)) {
[16:18:46.008]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.008]                       on.exit(options(oopts), add = TRUE)
[16:18:46.008]                     }
[16:18:46.008]                     {
[16:18:46.008]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.008]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.008]                         USE.NAMES = FALSE)
[16:18:46.008]                       do.call(mapply, args = args)
[16:18:46.008]                     }
[16:18:46.008]                   }
[16:18:46.008]                 }, immediateCondition = function(cond) {
[16:18:46.008]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.008]                   sendCondition(cond)
[16:18:46.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.008]                   {
[16:18:46.008]                     inherits <- base::inherits
[16:18:46.008]                     invokeRestart <- base::invokeRestart
[16:18:46.008]                     is.null <- base::is.null
[16:18:46.008]                     muffled <- FALSE
[16:18:46.008]                     if (inherits(cond, "message")) {
[16:18:46.008]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.008]                       if (muffled) 
[16:18:46.008]                         invokeRestart("muffleMessage")
[16:18:46.008]                     }
[16:18:46.008]                     else if (inherits(cond, "warning")) {
[16:18:46.008]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.008]                       if (muffled) 
[16:18:46.008]                         invokeRestart("muffleWarning")
[16:18:46.008]                     }
[16:18:46.008]                     else if (inherits(cond, "condition")) {
[16:18:46.008]                       if (!is.null(pattern)) {
[16:18:46.008]                         computeRestarts <- base::computeRestarts
[16:18:46.008]                         grepl <- base::grepl
[16:18:46.008]                         restarts <- computeRestarts(cond)
[16:18:46.008]                         for (restart in restarts) {
[16:18:46.008]                           name <- restart$name
[16:18:46.008]                           if (is.null(name)) 
[16:18:46.008]                             next
[16:18:46.008]                           if (!grepl(pattern, name)) 
[16:18:46.008]                             next
[16:18:46.008]                           invokeRestart(restart)
[16:18:46.008]                           muffled <- TRUE
[16:18:46.008]                           break
[16:18:46.008]                         }
[16:18:46.008]                       }
[16:18:46.008]                     }
[16:18:46.008]                     invisible(muffled)
[16:18:46.008]                   }
[16:18:46.008]                   muffleCondition(cond)
[16:18:46.008]                 })
[16:18:46.008]             }))
[16:18:46.008]             future::FutureResult(value = ...future.value$value, 
[16:18:46.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.008]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.008]                     ...future.globalenv.names))
[16:18:46.008]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.008]         }, condition = base::local({
[16:18:46.008]             c <- base::c
[16:18:46.008]             inherits <- base::inherits
[16:18:46.008]             invokeRestart <- base::invokeRestart
[16:18:46.008]             length <- base::length
[16:18:46.008]             list <- base::list
[16:18:46.008]             seq.int <- base::seq.int
[16:18:46.008]             signalCondition <- base::signalCondition
[16:18:46.008]             sys.calls <- base::sys.calls
[16:18:46.008]             `[[` <- base::`[[`
[16:18:46.008]             `+` <- base::`+`
[16:18:46.008]             `<<-` <- base::`<<-`
[16:18:46.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.008]                   3L)]
[16:18:46.008]             }
[16:18:46.008]             function(cond) {
[16:18:46.008]                 is_error <- inherits(cond, "error")
[16:18:46.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.008]                   NULL)
[16:18:46.008]                 if (is_error) {
[16:18:46.008]                   sessionInformation <- function() {
[16:18:46.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.008]                       search = base::search(), system = base::Sys.info())
[16:18:46.008]                   }
[16:18:46.008]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.008]                     cond$call), session = sessionInformation(), 
[16:18:46.008]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.008]                   signalCondition(cond)
[16:18:46.008]                 }
[16:18:46.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.008]                 "immediateCondition"))) {
[16:18:46.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.008]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.008]                   if (TRUE && !signal) {
[16:18:46.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.008]                     {
[16:18:46.008]                       inherits <- base::inherits
[16:18:46.008]                       invokeRestart <- base::invokeRestart
[16:18:46.008]                       is.null <- base::is.null
[16:18:46.008]                       muffled <- FALSE
[16:18:46.008]                       if (inherits(cond, "message")) {
[16:18:46.008]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.008]                         if (muffled) 
[16:18:46.008]                           invokeRestart("muffleMessage")
[16:18:46.008]                       }
[16:18:46.008]                       else if (inherits(cond, "warning")) {
[16:18:46.008]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.008]                         if (muffled) 
[16:18:46.008]                           invokeRestart("muffleWarning")
[16:18:46.008]                       }
[16:18:46.008]                       else if (inherits(cond, "condition")) {
[16:18:46.008]                         if (!is.null(pattern)) {
[16:18:46.008]                           computeRestarts <- base::computeRestarts
[16:18:46.008]                           grepl <- base::grepl
[16:18:46.008]                           restarts <- computeRestarts(cond)
[16:18:46.008]                           for (restart in restarts) {
[16:18:46.008]                             name <- restart$name
[16:18:46.008]                             if (is.null(name)) 
[16:18:46.008]                               next
[16:18:46.008]                             if (!grepl(pattern, name)) 
[16:18:46.008]                               next
[16:18:46.008]                             invokeRestart(restart)
[16:18:46.008]                             muffled <- TRUE
[16:18:46.008]                             break
[16:18:46.008]                           }
[16:18:46.008]                         }
[16:18:46.008]                       }
[16:18:46.008]                       invisible(muffled)
[16:18:46.008]                     }
[16:18:46.008]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.008]                   }
[16:18:46.008]                 }
[16:18:46.008]                 else {
[16:18:46.008]                   if (TRUE) {
[16:18:46.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.008]                     {
[16:18:46.008]                       inherits <- base::inherits
[16:18:46.008]                       invokeRestart <- base::invokeRestart
[16:18:46.008]                       is.null <- base::is.null
[16:18:46.008]                       muffled <- FALSE
[16:18:46.008]                       if (inherits(cond, "message")) {
[16:18:46.008]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.008]                         if (muffled) 
[16:18:46.008]                           invokeRestart("muffleMessage")
[16:18:46.008]                       }
[16:18:46.008]                       else if (inherits(cond, "warning")) {
[16:18:46.008]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.008]                         if (muffled) 
[16:18:46.008]                           invokeRestart("muffleWarning")
[16:18:46.008]                       }
[16:18:46.008]                       else if (inherits(cond, "condition")) {
[16:18:46.008]                         if (!is.null(pattern)) {
[16:18:46.008]                           computeRestarts <- base::computeRestarts
[16:18:46.008]                           grepl <- base::grepl
[16:18:46.008]                           restarts <- computeRestarts(cond)
[16:18:46.008]                           for (restart in restarts) {
[16:18:46.008]                             name <- restart$name
[16:18:46.008]                             if (is.null(name)) 
[16:18:46.008]                               next
[16:18:46.008]                             if (!grepl(pattern, name)) 
[16:18:46.008]                               next
[16:18:46.008]                             invokeRestart(restart)
[16:18:46.008]                             muffled <- TRUE
[16:18:46.008]                             break
[16:18:46.008]                           }
[16:18:46.008]                         }
[16:18:46.008]                       }
[16:18:46.008]                       invisible(muffled)
[16:18:46.008]                     }
[16:18:46.008]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.008]                   }
[16:18:46.008]                 }
[16:18:46.008]             }
[16:18:46.008]         }))
[16:18:46.008]     }, error = function(ex) {
[16:18:46.008]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.008]                 ...future.rng), started = ...future.startTime, 
[16:18:46.008]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.008]             version = "1.8"), class = "FutureResult")
[16:18:46.008]     }, finally = {
[16:18:46.008]         if (!identical(...future.workdir, getwd())) 
[16:18:46.008]             setwd(...future.workdir)
[16:18:46.008]         {
[16:18:46.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.008]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.008]             }
[16:18:46.008]             base::options(...future.oldOptions)
[16:18:46.008]             if (.Platform$OS.type == "windows") {
[16:18:46.008]                 old_names <- names(...future.oldEnvVars)
[16:18:46.008]                 envs <- base::Sys.getenv()
[16:18:46.008]                 names <- names(envs)
[16:18:46.008]                 common <- intersect(names, old_names)
[16:18:46.008]                 added <- setdiff(names, old_names)
[16:18:46.008]                 removed <- setdiff(old_names, names)
[16:18:46.008]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.008]                   envs[common]]
[16:18:46.008]                 NAMES <- toupper(changed)
[16:18:46.008]                 args <- list()
[16:18:46.008]                 for (kk in seq_along(NAMES)) {
[16:18:46.008]                   name <- changed[[kk]]
[16:18:46.008]                   NAME <- NAMES[[kk]]
[16:18:46.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.008]                     next
[16:18:46.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.008]                 }
[16:18:46.008]                 NAMES <- toupper(added)
[16:18:46.008]                 for (kk in seq_along(NAMES)) {
[16:18:46.008]                   name <- added[[kk]]
[16:18:46.008]                   NAME <- NAMES[[kk]]
[16:18:46.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.008]                     next
[16:18:46.008]                   args[[name]] <- ""
[16:18:46.008]                 }
[16:18:46.008]                 NAMES <- toupper(removed)
[16:18:46.008]                 for (kk in seq_along(NAMES)) {
[16:18:46.008]                   name <- removed[[kk]]
[16:18:46.008]                   NAME <- NAMES[[kk]]
[16:18:46.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.008]                     next
[16:18:46.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.008]                 }
[16:18:46.008]                 if (length(args) > 0) 
[16:18:46.008]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.008]             }
[16:18:46.008]             else {
[16:18:46.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.008]             }
[16:18:46.008]             {
[16:18:46.008]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.008]                   0L) {
[16:18:46.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.008]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.008]                   base::options(opts)
[16:18:46.008]                 }
[16:18:46.008]                 {
[16:18:46.008]                   {
[16:18:46.008]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.008]                     NULL
[16:18:46.008]                   }
[16:18:46.008]                   options(future.plan = NULL)
[16:18:46.008]                   if (is.na(NA_character_)) 
[16:18:46.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.008]                     .init = FALSE)
[16:18:46.008]                 }
[16:18:46.008]             }
[16:18:46.008]         }
[16:18:46.008]     })
[16:18:46.008]     if (TRUE) {
[16:18:46.008]         base::sink(type = "output", split = FALSE)
[16:18:46.008]         if (TRUE) {
[16:18:46.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.008]         }
[16:18:46.008]         else {
[16:18:46.008]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.008]         }
[16:18:46.008]         base::close(...future.stdout)
[16:18:46.008]         ...future.stdout <- NULL
[16:18:46.008]     }
[16:18:46.008]     ...future.result$conditions <- ...future.conditions
[16:18:46.008]     ...future.result$finished <- base::Sys.time()
[16:18:46.008]     ...future.result
[16:18:46.008] }
[16:18:46.011] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[16:18:46.011] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[16:18:46.011] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[16:18:46.011] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:46.012] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.012] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[16:18:46.012] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[16:18:46.012] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:46.013] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.013] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:46.013] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.013] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[16:18:46.014] MultisessionFuture started
[16:18:46.014] - Launch lazy future ... done
[16:18:46.014] run() for ‘MultisessionFuture’ ... done
[16:18:46.014] Created future:
[16:18:46.014] MultisessionFuture:
[16:18:46.014] Label: ‘future_mapply-2’
[16:18:46.014] Expression:
[16:18:46.014] {
[16:18:46.014]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.014]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.014]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.014]         on.exit(options(oopts), add = TRUE)
[16:18:46.014]     }
[16:18:46.014]     {
[16:18:46.014]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.014]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.014]         do.call(mapply, args = args)
[16:18:46.014]     }
[16:18:46.014] }
[16:18:46.014] Lazy evaluation: FALSE
[16:18:46.014] Asynchronous evaluation: TRUE
[16:18:46.014] Local evaluation: TRUE
[16:18:46.014] Environment: R_GlobalEnv
[16:18:46.014] Capture standard output: TRUE
[16:18:46.014] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.014] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.014] Packages: <none>
[16:18:46.014] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:46.014] Resolved: FALSE
[16:18:46.014] Value: <not collected>
[16:18:46.014] Conditions captured: <none>
[16:18:46.014] Early signaling: FALSE
[16:18:46.014] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.014] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.025] Chunk #2 of 2 ... DONE
[16:18:46.025] Launching 2 futures (chunks) ... DONE
[16:18:46.025] Resolving 2 futures (chunks) ...
[16:18:46.026] resolve() on list ...
[16:18:46.026]  recursive: 0
[16:18:46.026]  length: 2
[16:18:46.026] 
[16:18:46.026] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.026] - Validating connection of MultisessionFuture
[16:18:46.027] - received message: FutureResult
[16:18:46.027] - Received FutureResult
[16:18:46.027] - Erased future from FutureRegistry
[16:18:46.027] result() for ClusterFuture ...
[16:18:46.027] - result already collected: FutureResult
[16:18:46.027] result() for ClusterFuture ... done
[16:18:46.027] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.027] Future #1
[16:18:46.027] result() for ClusterFuture ...
[16:18:46.027] - result already collected: FutureResult
[16:18:46.027] result() for ClusterFuture ... done
[16:18:46.028] result() for ClusterFuture ...
[16:18:46.028] - result already collected: FutureResult
[16:18:46.028] result() for ClusterFuture ... done
[16:18:46.028] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:46.028] - nx: 2
[16:18:46.028] - relay: TRUE
[16:18:46.028] - stdout: TRUE
[16:18:46.028] - signal: TRUE
[16:18:46.028] - resignal: FALSE
[16:18:46.031] - force: TRUE
[16:18:46.031] - relayed: [n=2] FALSE, FALSE
[16:18:46.031] - queued futures: [n=2] FALSE, FALSE
[16:18:46.031]  - until=1
[16:18:46.031]  - relaying element #1
[16:18:46.031] result() for ClusterFuture ...
[16:18:46.031] - result already collected: FutureResult
[16:18:46.031] result() for ClusterFuture ... done
[16:18:46.032] result() for ClusterFuture ...
[16:18:46.032] - result already collected: FutureResult
[16:18:46.032] result() for ClusterFuture ... done
[16:18:46.032] result() for ClusterFuture ...
[16:18:46.032] - result already collected: FutureResult
[16:18:46.032] result() for ClusterFuture ... done
[16:18:46.032] result() for ClusterFuture ...
[16:18:46.032] - result already collected: FutureResult
[16:18:46.032] result() for ClusterFuture ... done
[16:18:46.032] - relayed: [n=2] TRUE, FALSE
[16:18:46.033] - queued futures: [n=2] TRUE, FALSE
[16:18:46.033] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:46.033]  length: 1 (resolved future 1)
[16:18:46.058] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.058] - Validating connection of MultisessionFuture
[16:18:46.058] - received message: FutureResult
[16:18:46.058] - Received FutureResult
[16:18:46.058] - Erased future from FutureRegistry
[16:18:46.058] result() for ClusterFuture ...
[16:18:46.058] - result already collected: FutureResult
[16:18:46.059] result() for ClusterFuture ... done
[16:18:46.059] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.059] Future #2
[16:18:46.059] result() for ClusterFuture ...
[16:18:46.059] - result already collected: FutureResult
[16:18:46.059] result() for ClusterFuture ... done
[16:18:46.059] result() for ClusterFuture ...
[16:18:46.059] - result already collected: FutureResult
[16:18:46.059] result() for ClusterFuture ... done
[16:18:46.059] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:46.059] - nx: 2
[16:18:46.060] - relay: TRUE
[16:18:46.060] - stdout: TRUE
[16:18:46.060] - signal: TRUE
[16:18:46.060] - resignal: FALSE
[16:18:46.060] - force: TRUE
[16:18:46.060] - relayed: [n=2] TRUE, FALSE
[16:18:46.060] - queued futures: [n=2] TRUE, FALSE
[16:18:46.060]  - until=2
[16:18:46.060]  - relaying element #2
[16:18:46.060] result() for ClusterFuture ...
[16:18:46.060] - result already collected: FutureResult
[16:18:46.061] result() for ClusterFuture ... done
[16:18:46.061] result() for ClusterFuture ...
[16:18:46.061] - result already collected: FutureResult
[16:18:46.061] result() for ClusterFuture ... done
[16:18:46.061] result() for ClusterFuture ...
[16:18:46.061] - result already collected: FutureResult
[16:18:46.061] result() for ClusterFuture ... done
[16:18:46.061] result() for ClusterFuture ...
[16:18:46.061] - result already collected: FutureResult
[16:18:46.061] result() for ClusterFuture ... done
[16:18:46.061] - relayed: [n=2] TRUE, TRUE
[16:18:46.062] - queued futures: [n=2] TRUE, TRUE
[16:18:46.062] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:46.062]  length: 0 (resolved future 2)
[16:18:46.062] Relaying remaining futures
[16:18:46.062] signalConditionsASAP(NULL, pos=0) ...
[16:18:46.062] - nx: 2
[16:18:46.062] - relay: TRUE
[16:18:46.062] - stdout: TRUE
[16:18:46.062] - signal: TRUE
[16:18:46.062] - resignal: FALSE
[16:18:46.062] - force: TRUE
[16:18:46.062] - relayed: [n=2] TRUE, TRUE
[16:18:46.062] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:46.063] - relayed: [n=2] TRUE, TRUE
[16:18:46.063] - queued futures: [n=2] TRUE, TRUE
[16:18:46.063] signalConditionsASAP(NULL, pos=0) ... done
[16:18:46.063] resolve() on list ... DONE
[16:18:46.063] result() for ClusterFuture ...
[16:18:46.063] - result already collected: FutureResult
[16:18:46.063] result() for ClusterFuture ... done
[16:18:46.063] result() for ClusterFuture ...
[16:18:46.063] - result already collected: FutureResult
[16:18:46.063] result() for ClusterFuture ... done
[16:18:46.063] result() for ClusterFuture ...
[16:18:46.064] - result already collected: FutureResult
[16:18:46.064] result() for ClusterFuture ... done
[16:18:46.064] result() for ClusterFuture ...
[16:18:46.064] - result already collected: FutureResult
[16:18:46.064] result() for ClusterFuture ... done
[16:18:46.064]  - Number of value chunks collected: 2
[16:18:46.064] Resolving 2 futures (chunks) ... DONE
[16:18:46.064] Reducing values from 2 chunks ...
[16:18:46.064]  - Number of values collected after concatenation: 5
[16:18:46.064]  - Number of values expected: 5
[16:18:46.064] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[16:18:46.065] Reducing values from 2 chunks ... DONE
[16:18:46.065] future_mapply() ... DONE
[16:18:46.065] future_mapply() ...
[16:18:46.068] Number of chunks: 2
[16:18:46.068] getGlobalsAndPackagesXApply() ...
[16:18:46.068]  - future.globals: TRUE
[16:18:46.069] getGlobalsAndPackages() ...
[16:18:46.069] Searching for globals...
[16:18:46.070] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[16:18:46.070] Searching for globals ... DONE
[16:18:46.070] Resolving globals: FALSE
[16:18:46.070] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[16:18:46.071] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[16:18:46.071] - globals: [1] ‘FUN’
[16:18:46.071] 
[16:18:46.071] getGlobalsAndPackages() ... DONE
[16:18:46.071]  - globals found/used: [n=1] ‘FUN’
[16:18:46.071]  - needed namespaces: [n=0] 
[16:18:46.071] Finding globals ... DONE
[16:18:46.072] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:46.072] List of 2
[16:18:46.072]  $ ...future.FUN:function (C, k)  
[16:18:46.072]  $ MoreArgs     : list()
[16:18:46.072]  - attr(*, "where")=List of 2
[16:18:46.072]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:46.072]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:46.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:46.072]  - attr(*, "resolved")= logi FALSE
[16:18:46.072]  - attr(*, "total_size")= num NA
[16:18:46.074] Packages to be attached in all futures: [n=0] 
[16:18:46.074] getGlobalsAndPackagesXApply() ... DONE
[16:18:46.074] Number of futures (= number of chunks): 2
[16:18:46.075] Launching 2 futures (chunks) ...
[16:18:46.075] Chunk #1 of 2 ...
[16:18:46.075]  - Finding globals in '...' for chunk #1 ...
[16:18:46.075] getGlobalsAndPackages() ...
[16:18:46.075] Searching for globals...
[16:18:46.075] 
[16:18:46.075] Searching for globals ... DONE
[16:18:46.075] - globals: [0] <none>
[16:18:46.075] getGlobalsAndPackages() ... DONE
[16:18:46.076]    + additional globals found: [n=0] 
[16:18:46.076]    + additional namespaces needed: [n=0] 
[16:18:46.076]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:46.076]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.076]  - seeds: <none>
[16:18:46.076]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.076] getGlobalsAndPackages() ...
[16:18:46.076] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.076] Resolving globals: FALSE
[16:18:46.077] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[16:18:46.077] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:46.077] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.078] 
[16:18:46.078] getGlobalsAndPackages() ... DONE
[16:18:46.078] run() for ‘Future’ ...
[16:18:46.078] - state: ‘created’
[16:18:46.078] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.091] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.091] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.092]   - Field: ‘node’
[16:18:46.092]   - Field: ‘label’
[16:18:46.092]   - Field: ‘local’
[16:18:46.092]   - Field: ‘owner’
[16:18:46.092]   - Field: ‘envir’
[16:18:46.092]   - Field: ‘workers’
[16:18:46.092]   - Field: ‘packages’
[16:18:46.092]   - Field: ‘gc’
[16:18:46.092]   - Field: ‘conditions’
[16:18:46.092]   - Field: ‘persistent’
[16:18:46.093]   - Field: ‘expr’
[16:18:46.093]   - Field: ‘uuid’
[16:18:46.093]   - Field: ‘seed’
[16:18:46.093]   - Field: ‘version’
[16:18:46.093]   - Field: ‘result’
[16:18:46.093]   - Field: ‘asynchronous’
[16:18:46.093]   - Field: ‘calls’
[16:18:46.093]   - Field: ‘globals’
[16:18:46.093]   - Field: ‘stdout’
[16:18:46.093]   - Field: ‘earlySignal’
[16:18:46.093]   - Field: ‘lazy’
[16:18:46.094]   - Field: ‘state’
[16:18:46.094] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.094] - Launch lazy future ...
[16:18:46.094] Packages needed by the future expression (n = 0): <none>
[16:18:46.094] Packages needed by future strategies (n = 0): <none>
[16:18:46.095] {
[16:18:46.095]     {
[16:18:46.095]         {
[16:18:46.095]             ...future.startTime <- base::Sys.time()
[16:18:46.095]             {
[16:18:46.095]                 {
[16:18:46.095]                   {
[16:18:46.095]                     {
[16:18:46.095]                       base::local({
[16:18:46.095]                         has_future <- base::requireNamespace("future", 
[16:18:46.095]                           quietly = TRUE)
[16:18:46.095]                         if (has_future) {
[16:18:46.095]                           ns <- base::getNamespace("future")
[16:18:46.095]                           version <- ns[[".package"]][["version"]]
[16:18:46.095]                           if (is.null(version)) 
[16:18:46.095]                             version <- utils::packageVersion("future")
[16:18:46.095]                         }
[16:18:46.095]                         else {
[16:18:46.095]                           version <- NULL
[16:18:46.095]                         }
[16:18:46.095]                         if (!has_future || version < "1.8.0") {
[16:18:46.095]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.095]                             "", base::R.version$version.string), 
[16:18:46.095]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.095]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.095]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.095]                               "release", "version")], collapse = " "), 
[16:18:46.095]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.095]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.095]                             info)
[16:18:46.095]                           info <- base::paste(info, collapse = "; ")
[16:18:46.095]                           if (!has_future) {
[16:18:46.095]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.095]                               info)
[16:18:46.095]                           }
[16:18:46.095]                           else {
[16:18:46.095]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.095]                               info, version)
[16:18:46.095]                           }
[16:18:46.095]                           base::stop(msg)
[16:18:46.095]                         }
[16:18:46.095]                       })
[16:18:46.095]                     }
[16:18:46.095]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.095]                     base::options(mc.cores = 1L)
[16:18:46.095]                   }
[16:18:46.095]                   ...future.strategy.old <- future::plan("list")
[16:18:46.095]                   options(future.plan = NULL)
[16:18:46.095]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.095]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.095]                 }
[16:18:46.095]                 ...future.workdir <- getwd()
[16:18:46.095]             }
[16:18:46.095]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.095]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.095]         }
[16:18:46.095]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.095]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.095]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.095]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.095]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.095]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.095]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.095]             base::names(...future.oldOptions))
[16:18:46.095]     }
[16:18:46.095]     if (FALSE) {
[16:18:46.095]     }
[16:18:46.095]     else {
[16:18:46.095]         if (TRUE) {
[16:18:46.095]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.095]                 open = "w")
[16:18:46.095]         }
[16:18:46.095]         else {
[16:18:46.095]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.095]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.095]         }
[16:18:46.095]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.095]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.095]             base::sink(type = "output", split = FALSE)
[16:18:46.095]             base::close(...future.stdout)
[16:18:46.095]         }, add = TRUE)
[16:18:46.095]     }
[16:18:46.095]     ...future.frame <- base::sys.nframe()
[16:18:46.095]     ...future.conditions <- base::list()
[16:18:46.095]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.095]     if (FALSE) {
[16:18:46.095]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.095]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.095]     }
[16:18:46.095]     ...future.result <- base::tryCatch({
[16:18:46.095]         base::withCallingHandlers({
[16:18:46.095]             ...future.value <- base::withVisible(base::local({
[16:18:46.095]                 ...future.makeSendCondition <- base::local({
[16:18:46.095]                   sendCondition <- NULL
[16:18:46.095]                   function(frame = 1L) {
[16:18:46.095]                     if (is.function(sendCondition)) 
[16:18:46.095]                       return(sendCondition)
[16:18:46.095]                     ns <- getNamespace("parallel")
[16:18:46.095]                     if (exists("sendData", mode = "function", 
[16:18:46.095]                       envir = ns)) {
[16:18:46.095]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.095]                         envir = ns)
[16:18:46.095]                       envir <- sys.frame(frame)
[16:18:46.095]                       master <- NULL
[16:18:46.095]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.095]                         !identical(envir, emptyenv())) {
[16:18:46.095]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.095]                           inherits = FALSE)) {
[16:18:46.095]                           master <- get("master", mode = "list", 
[16:18:46.095]                             envir = envir, inherits = FALSE)
[16:18:46.095]                           if (inherits(master, c("SOCKnode", 
[16:18:46.095]                             "SOCK0node"))) {
[16:18:46.095]                             sendCondition <<- function(cond) {
[16:18:46.095]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.095]                                 success = TRUE)
[16:18:46.095]                               parallel_sendData(master, data)
[16:18:46.095]                             }
[16:18:46.095]                             return(sendCondition)
[16:18:46.095]                           }
[16:18:46.095]                         }
[16:18:46.095]                         frame <- frame + 1L
[16:18:46.095]                         envir <- sys.frame(frame)
[16:18:46.095]                       }
[16:18:46.095]                     }
[16:18:46.095]                     sendCondition <<- function(cond) NULL
[16:18:46.095]                   }
[16:18:46.095]                 })
[16:18:46.095]                 withCallingHandlers({
[16:18:46.095]                   {
[16:18:46.095]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.095]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.095]                       ...future.globals.maxSize)) {
[16:18:46.095]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.095]                       on.exit(options(oopts), add = TRUE)
[16:18:46.095]                     }
[16:18:46.095]                     {
[16:18:46.095]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.095]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.095]                         USE.NAMES = FALSE)
[16:18:46.095]                       do.call(mapply, args = args)
[16:18:46.095]                     }
[16:18:46.095]                   }
[16:18:46.095]                 }, immediateCondition = function(cond) {
[16:18:46.095]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.095]                   sendCondition(cond)
[16:18:46.095]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.095]                   {
[16:18:46.095]                     inherits <- base::inherits
[16:18:46.095]                     invokeRestart <- base::invokeRestart
[16:18:46.095]                     is.null <- base::is.null
[16:18:46.095]                     muffled <- FALSE
[16:18:46.095]                     if (inherits(cond, "message")) {
[16:18:46.095]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.095]                       if (muffled) 
[16:18:46.095]                         invokeRestart("muffleMessage")
[16:18:46.095]                     }
[16:18:46.095]                     else if (inherits(cond, "warning")) {
[16:18:46.095]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.095]                       if (muffled) 
[16:18:46.095]                         invokeRestart("muffleWarning")
[16:18:46.095]                     }
[16:18:46.095]                     else if (inherits(cond, "condition")) {
[16:18:46.095]                       if (!is.null(pattern)) {
[16:18:46.095]                         computeRestarts <- base::computeRestarts
[16:18:46.095]                         grepl <- base::grepl
[16:18:46.095]                         restarts <- computeRestarts(cond)
[16:18:46.095]                         for (restart in restarts) {
[16:18:46.095]                           name <- restart$name
[16:18:46.095]                           if (is.null(name)) 
[16:18:46.095]                             next
[16:18:46.095]                           if (!grepl(pattern, name)) 
[16:18:46.095]                             next
[16:18:46.095]                           invokeRestart(restart)
[16:18:46.095]                           muffled <- TRUE
[16:18:46.095]                           break
[16:18:46.095]                         }
[16:18:46.095]                       }
[16:18:46.095]                     }
[16:18:46.095]                     invisible(muffled)
[16:18:46.095]                   }
[16:18:46.095]                   muffleCondition(cond)
[16:18:46.095]                 })
[16:18:46.095]             }))
[16:18:46.095]             future::FutureResult(value = ...future.value$value, 
[16:18:46.095]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.095]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.095]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.095]                     ...future.globalenv.names))
[16:18:46.095]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.095]         }, condition = base::local({
[16:18:46.095]             c <- base::c
[16:18:46.095]             inherits <- base::inherits
[16:18:46.095]             invokeRestart <- base::invokeRestart
[16:18:46.095]             length <- base::length
[16:18:46.095]             list <- base::list
[16:18:46.095]             seq.int <- base::seq.int
[16:18:46.095]             signalCondition <- base::signalCondition
[16:18:46.095]             sys.calls <- base::sys.calls
[16:18:46.095]             `[[` <- base::`[[`
[16:18:46.095]             `+` <- base::`+`
[16:18:46.095]             `<<-` <- base::`<<-`
[16:18:46.095]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.095]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.095]                   3L)]
[16:18:46.095]             }
[16:18:46.095]             function(cond) {
[16:18:46.095]                 is_error <- inherits(cond, "error")
[16:18:46.095]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.095]                   NULL)
[16:18:46.095]                 if (is_error) {
[16:18:46.095]                   sessionInformation <- function() {
[16:18:46.095]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.095]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.095]                       search = base::search(), system = base::Sys.info())
[16:18:46.095]                   }
[16:18:46.095]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.095]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.095]                     cond$call), session = sessionInformation(), 
[16:18:46.095]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.095]                   signalCondition(cond)
[16:18:46.095]                 }
[16:18:46.095]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.095]                 "immediateCondition"))) {
[16:18:46.095]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.095]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.095]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.095]                   if (TRUE && !signal) {
[16:18:46.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.095]                     {
[16:18:46.095]                       inherits <- base::inherits
[16:18:46.095]                       invokeRestart <- base::invokeRestart
[16:18:46.095]                       is.null <- base::is.null
[16:18:46.095]                       muffled <- FALSE
[16:18:46.095]                       if (inherits(cond, "message")) {
[16:18:46.095]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.095]                         if (muffled) 
[16:18:46.095]                           invokeRestart("muffleMessage")
[16:18:46.095]                       }
[16:18:46.095]                       else if (inherits(cond, "warning")) {
[16:18:46.095]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.095]                         if (muffled) 
[16:18:46.095]                           invokeRestart("muffleWarning")
[16:18:46.095]                       }
[16:18:46.095]                       else if (inherits(cond, "condition")) {
[16:18:46.095]                         if (!is.null(pattern)) {
[16:18:46.095]                           computeRestarts <- base::computeRestarts
[16:18:46.095]                           grepl <- base::grepl
[16:18:46.095]                           restarts <- computeRestarts(cond)
[16:18:46.095]                           for (restart in restarts) {
[16:18:46.095]                             name <- restart$name
[16:18:46.095]                             if (is.null(name)) 
[16:18:46.095]                               next
[16:18:46.095]                             if (!grepl(pattern, name)) 
[16:18:46.095]                               next
[16:18:46.095]                             invokeRestart(restart)
[16:18:46.095]                             muffled <- TRUE
[16:18:46.095]                             break
[16:18:46.095]                           }
[16:18:46.095]                         }
[16:18:46.095]                       }
[16:18:46.095]                       invisible(muffled)
[16:18:46.095]                     }
[16:18:46.095]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.095]                   }
[16:18:46.095]                 }
[16:18:46.095]                 else {
[16:18:46.095]                   if (TRUE) {
[16:18:46.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.095]                     {
[16:18:46.095]                       inherits <- base::inherits
[16:18:46.095]                       invokeRestart <- base::invokeRestart
[16:18:46.095]                       is.null <- base::is.null
[16:18:46.095]                       muffled <- FALSE
[16:18:46.095]                       if (inherits(cond, "message")) {
[16:18:46.095]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.095]                         if (muffled) 
[16:18:46.095]                           invokeRestart("muffleMessage")
[16:18:46.095]                       }
[16:18:46.095]                       else if (inherits(cond, "warning")) {
[16:18:46.095]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.095]                         if (muffled) 
[16:18:46.095]                           invokeRestart("muffleWarning")
[16:18:46.095]                       }
[16:18:46.095]                       else if (inherits(cond, "condition")) {
[16:18:46.095]                         if (!is.null(pattern)) {
[16:18:46.095]                           computeRestarts <- base::computeRestarts
[16:18:46.095]                           grepl <- base::grepl
[16:18:46.095]                           restarts <- computeRestarts(cond)
[16:18:46.095]                           for (restart in restarts) {
[16:18:46.095]                             name <- restart$name
[16:18:46.095]                             if (is.null(name)) 
[16:18:46.095]                               next
[16:18:46.095]                             if (!grepl(pattern, name)) 
[16:18:46.095]                               next
[16:18:46.095]                             invokeRestart(restart)
[16:18:46.095]                             muffled <- TRUE
[16:18:46.095]                             break
[16:18:46.095]                           }
[16:18:46.095]                         }
[16:18:46.095]                       }
[16:18:46.095]                       invisible(muffled)
[16:18:46.095]                     }
[16:18:46.095]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.095]                   }
[16:18:46.095]                 }
[16:18:46.095]             }
[16:18:46.095]         }))
[16:18:46.095]     }, error = function(ex) {
[16:18:46.095]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.095]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.095]                 ...future.rng), started = ...future.startTime, 
[16:18:46.095]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.095]             version = "1.8"), class = "FutureResult")
[16:18:46.095]     }, finally = {
[16:18:46.095]         if (!identical(...future.workdir, getwd())) 
[16:18:46.095]             setwd(...future.workdir)
[16:18:46.095]         {
[16:18:46.095]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.095]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.095]             }
[16:18:46.095]             base::options(...future.oldOptions)
[16:18:46.095]             if (.Platform$OS.type == "windows") {
[16:18:46.095]                 old_names <- names(...future.oldEnvVars)
[16:18:46.095]                 envs <- base::Sys.getenv()
[16:18:46.095]                 names <- names(envs)
[16:18:46.095]                 common <- intersect(names, old_names)
[16:18:46.095]                 added <- setdiff(names, old_names)
[16:18:46.095]                 removed <- setdiff(old_names, names)
[16:18:46.095]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.095]                   envs[common]]
[16:18:46.095]                 NAMES <- toupper(changed)
[16:18:46.095]                 args <- list()
[16:18:46.095]                 for (kk in seq_along(NAMES)) {
[16:18:46.095]                   name <- changed[[kk]]
[16:18:46.095]                   NAME <- NAMES[[kk]]
[16:18:46.095]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.095]                     next
[16:18:46.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.095]                 }
[16:18:46.095]                 NAMES <- toupper(added)
[16:18:46.095]                 for (kk in seq_along(NAMES)) {
[16:18:46.095]                   name <- added[[kk]]
[16:18:46.095]                   NAME <- NAMES[[kk]]
[16:18:46.095]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.095]                     next
[16:18:46.095]                   args[[name]] <- ""
[16:18:46.095]                 }
[16:18:46.095]                 NAMES <- toupper(removed)
[16:18:46.095]                 for (kk in seq_along(NAMES)) {
[16:18:46.095]                   name <- removed[[kk]]
[16:18:46.095]                   NAME <- NAMES[[kk]]
[16:18:46.095]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.095]                     next
[16:18:46.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.095]                 }
[16:18:46.095]                 if (length(args) > 0) 
[16:18:46.095]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.095]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.095]             }
[16:18:46.095]             else {
[16:18:46.095]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.095]             }
[16:18:46.095]             {
[16:18:46.095]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.095]                   0L) {
[16:18:46.095]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.095]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.095]                   base::options(opts)
[16:18:46.095]                 }
[16:18:46.095]                 {
[16:18:46.095]                   {
[16:18:46.095]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.095]                     NULL
[16:18:46.095]                   }
[16:18:46.095]                   options(future.plan = NULL)
[16:18:46.095]                   if (is.na(NA_character_)) 
[16:18:46.095]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.095]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.095]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.095]                     .init = FALSE)
[16:18:46.095]                 }
[16:18:46.095]             }
[16:18:46.095]         }
[16:18:46.095]     })
[16:18:46.095]     if (TRUE) {
[16:18:46.095]         base::sink(type = "output", split = FALSE)
[16:18:46.095]         if (TRUE) {
[16:18:46.095]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.095]         }
[16:18:46.095]         else {
[16:18:46.095]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.095]         }
[16:18:46.095]         base::close(...future.stdout)
[16:18:46.095]         ...future.stdout <- NULL
[16:18:46.095]     }
[16:18:46.095]     ...future.result$conditions <- ...future.conditions
[16:18:46.095]     ...future.result$finished <- base::Sys.time()
[16:18:46.095]     ...future.result
[16:18:46.095] }
[16:18:46.097] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[16:18:46.097] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[16:18:46.098] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[16:18:46.098] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:46.098] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.098] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[16:18:46.098] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[16:18:46.099] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:46.099] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.099] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:46.099] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.099] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[16:18:46.100] MultisessionFuture started
[16:18:46.100] - Launch lazy future ... done
[16:18:46.100] run() for ‘MultisessionFuture’ ... done
[16:18:46.100] Created future:
[16:18:46.100] MultisessionFuture:
[16:18:46.100] Label: ‘future_.mapply-1’
[16:18:46.100] Expression:
[16:18:46.100] {
[16:18:46.100]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.100]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.100]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.100]         on.exit(options(oopts), add = TRUE)
[16:18:46.100]     }
[16:18:46.100]     {
[16:18:46.100]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.100]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.100]         do.call(mapply, args = args)
[16:18:46.100]     }
[16:18:46.100] }
[16:18:46.100] Lazy evaluation: FALSE
[16:18:46.100] Asynchronous evaluation: TRUE
[16:18:46.100] Local evaluation: TRUE
[16:18:46.100] Environment: R_GlobalEnv
[16:18:46.100] Capture standard output: TRUE
[16:18:46.100] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.100] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.100] Packages: <none>
[16:18:46.100] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:46.100] Resolved: FALSE
[16:18:46.100] Value: <not collected>
[16:18:46.100] Conditions captured: <none>
[16:18:46.100] Early signaling: FALSE
[16:18:46.100] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.100] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.111] Chunk #1 of 2 ... DONE
[16:18:46.112] Chunk #2 of 2 ...
[16:18:46.112]  - Finding globals in '...' for chunk #2 ...
[16:18:46.112] getGlobalsAndPackages() ...
[16:18:46.112] Searching for globals...
[16:18:46.112] 
[16:18:46.112] Searching for globals ... DONE
[16:18:46.113] - globals: [0] <none>
[16:18:46.113] getGlobalsAndPackages() ... DONE
[16:18:46.113]    + additional globals found: [n=0] 
[16:18:46.113]    + additional namespaces needed: [n=0] 
[16:18:46.113]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:46.113]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.113]  - seeds: <none>
[16:18:46.113]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.113] getGlobalsAndPackages() ...
[16:18:46.113] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.114] Resolving globals: FALSE
[16:18:46.114] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[16:18:46.114] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:46.114] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.115] 
[16:18:46.115] getGlobalsAndPackages() ... DONE
[16:18:46.115] run() for ‘Future’ ...
[16:18:46.115] - state: ‘created’
[16:18:46.115] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.129]   - Field: ‘node’
[16:18:46.129]   - Field: ‘label’
[16:18:46.129]   - Field: ‘local’
[16:18:46.129]   - Field: ‘owner’
[16:18:46.129]   - Field: ‘envir’
[16:18:46.129]   - Field: ‘workers’
[16:18:46.129]   - Field: ‘packages’
[16:18:46.129]   - Field: ‘gc’
[16:18:46.130]   - Field: ‘conditions’
[16:18:46.130]   - Field: ‘persistent’
[16:18:46.130]   - Field: ‘expr’
[16:18:46.130]   - Field: ‘uuid’
[16:18:46.130]   - Field: ‘seed’
[16:18:46.130]   - Field: ‘version’
[16:18:46.130]   - Field: ‘result’
[16:18:46.130]   - Field: ‘asynchronous’
[16:18:46.130]   - Field: ‘calls’
[16:18:46.130]   - Field: ‘globals’
[16:18:46.130]   - Field: ‘stdout’
[16:18:46.131]   - Field: ‘earlySignal’
[16:18:46.131]   - Field: ‘lazy’
[16:18:46.131]   - Field: ‘state’
[16:18:46.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.131] - Launch lazy future ...
[16:18:46.131] Packages needed by the future expression (n = 0): <none>
[16:18:46.131] Packages needed by future strategies (n = 0): <none>
[16:18:46.132] {
[16:18:46.132]     {
[16:18:46.132]         {
[16:18:46.132]             ...future.startTime <- base::Sys.time()
[16:18:46.132]             {
[16:18:46.132]                 {
[16:18:46.132]                   {
[16:18:46.132]                     {
[16:18:46.132]                       base::local({
[16:18:46.132]                         has_future <- base::requireNamespace("future", 
[16:18:46.132]                           quietly = TRUE)
[16:18:46.132]                         if (has_future) {
[16:18:46.132]                           ns <- base::getNamespace("future")
[16:18:46.132]                           version <- ns[[".package"]][["version"]]
[16:18:46.132]                           if (is.null(version)) 
[16:18:46.132]                             version <- utils::packageVersion("future")
[16:18:46.132]                         }
[16:18:46.132]                         else {
[16:18:46.132]                           version <- NULL
[16:18:46.132]                         }
[16:18:46.132]                         if (!has_future || version < "1.8.0") {
[16:18:46.132]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.132]                             "", base::R.version$version.string), 
[16:18:46.132]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.132]                               "release", "version")], collapse = " "), 
[16:18:46.132]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.132]                             info)
[16:18:46.132]                           info <- base::paste(info, collapse = "; ")
[16:18:46.132]                           if (!has_future) {
[16:18:46.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.132]                               info)
[16:18:46.132]                           }
[16:18:46.132]                           else {
[16:18:46.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.132]                               info, version)
[16:18:46.132]                           }
[16:18:46.132]                           base::stop(msg)
[16:18:46.132]                         }
[16:18:46.132]                       })
[16:18:46.132]                     }
[16:18:46.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.132]                     base::options(mc.cores = 1L)
[16:18:46.132]                   }
[16:18:46.132]                   ...future.strategy.old <- future::plan("list")
[16:18:46.132]                   options(future.plan = NULL)
[16:18:46.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.132]                 }
[16:18:46.132]                 ...future.workdir <- getwd()
[16:18:46.132]             }
[16:18:46.132]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.132]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.132]         }
[16:18:46.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.132]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.132]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.132]             base::names(...future.oldOptions))
[16:18:46.132]     }
[16:18:46.132]     if (FALSE) {
[16:18:46.132]     }
[16:18:46.132]     else {
[16:18:46.132]         if (TRUE) {
[16:18:46.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.132]                 open = "w")
[16:18:46.132]         }
[16:18:46.132]         else {
[16:18:46.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.132]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.132]         }
[16:18:46.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.132]             base::sink(type = "output", split = FALSE)
[16:18:46.132]             base::close(...future.stdout)
[16:18:46.132]         }, add = TRUE)
[16:18:46.132]     }
[16:18:46.132]     ...future.frame <- base::sys.nframe()
[16:18:46.132]     ...future.conditions <- base::list()
[16:18:46.132]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.132]     if (FALSE) {
[16:18:46.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.132]     }
[16:18:46.132]     ...future.result <- base::tryCatch({
[16:18:46.132]         base::withCallingHandlers({
[16:18:46.132]             ...future.value <- base::withVisible(base::local({
[16:18:46.132]                 ...future.makeSendCondition <- base::local({
[16:18:46.132]                   sendCondition <- NULL
[16:18:46.132]                   function(frame = 1L) {
[16:18:46.132]                     if (is.function(sendCondition)) 
[16:18:46.132]                       return(sendCondition)
[16:18:46.132]                     ns <- getNamespace("parallel")
[16:18:46.132]                     if (exists("sendData", mode = "function", 
[16:18:46.132]                       envir = ns)) {
[16:18:46.132]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.132]                         envir = ns)
[16:18:46.132]                       envir <- sys.frame(frame)
[16:18:46.132]                       master <- NULL
[16:18:46.132]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.132]                         !identical(envir, emptyenv())) {
[16:18:46.132]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.132]                           inherits = FALSE)) {
[16:18:46.132]                           master <- get("master", mode = "list", 
[16:18:46.132]                             envir = envir, inherits = FALSE)
[16:18:46.132]                           if (inherits(master, c("SOCKnode", 
[16:18:46.132]                             "SOCK0node"))) {
[16:18:46.132]                             sendCondition <<- function(cond) {
[16:18:46.132]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.132]                                 success = TRUE)
[16:18:46.132]                               parallel_sendData(master, data)
[16:18:46.132]                             }
[16:18:46.132]                             return(sendCondition)
[16:18:46.132]                           }
[16:18:46.132]                         }
[16:18:46.132]                         frame <- frame + 1L
[16:18:46.132]                         envir <- sys.frame(frame)
[16:18:46.132]                       }
[16:18:46.132]                     }
[16:18:46.132]                     sendCondition <<- function(cond) NULL
[16:18:46.132]                   }
[16:18:46.132]                 })
[16:18:46.132]                 withCallingHandlers({
[16:18:46.132]                   {
[16:18:46.132]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.132]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.132]                       ...future.globals.maxSize)) {
[16:18:46.132]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.132]                       on.exit(options(oopts), add = TRUE)
[16:18:46.132]                     }
[16:18:46.132]                     {
[16:18:46.132]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.132]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.132]                         USE.NAMES = FALSE)
[16:18:46.132]                       do.call(mapply, args = args)
[16:18:46.132]                     }
[16:18:46.132]                   }
[16:18:46.132]                 }, immediateCondition = function(cond) {
[16:18:46.132]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.132]                   sendCondition(cond)
[16:18:46.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.132]                   {
[16:18:46.132]                     inherits <- base::inherits
[16:18:46.132]                     invokeRestart <- base::invokeRestart
[16:18:46.132]                     is.null <- base::is.null
[16:18:46.132]                     muffled <- FALSE
[16:18:46.132]                     if (inherits(cond, "message")) {
[16:18:46.132]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.132]                       if (muffled) 
[16:18:46.132]                         invokeRestart("muffleMessage")
[16:18:46.132]                     }
[16:18:46.132]                     else if (inherits(cond, "warning")) {
[16:18:46.132]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.132]                       if (muffled) 
[16:18:46.132]                         invokeRestart("muffleWarning")
[16:18:46.132]                     }
[16:18:46.132]                     else if (inherits(cond, "condition")) {
[16:18:46.132]                       if (!is.null(pattern)) {
[16:18:46.132]                         computeRestarts <- base::computeRestarts
[16:18:46.132]                         grepl <- base::grepl
[16:18:46.132]                         restarts <- computeRestarts(cond)
[16:18:46.132]                         for (restart in restarts) {
[16:18:46.132]                           name <- restart$name
[16:18:46.132]                           if (is.null(name)) 
[16:18:46.132]                             next
[16:18:46.132]                           if (!grepl(pattern, name)) 
[16:18:46.132]                             next
[16:18:46.132]                           invokeRestart(restart)
[16:18:46.132]                           muffled <- TRUE
[16:18:46.132]                           break
[16:18:46.132]                         }
[16:18:46.132]                       }
[16:18:46.132]                     }
[16:18:46.132]                     invisible(muffled)
[16:18:46.132]                   }
[16:18:46.132]                   muffleCondition(cond)
[16:18:46.132]                 })
[16:18:46.132]             }))
[16:18:46.132]             future::FutureResult(value = ...future.value$value, 
[16:18:46.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.132]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.132]                     ...future.globalenv.names))
[16:18:46.132]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.132]         }, condition = base::local({
[16:18:46.132]             c <- base::c
[16:18:46.132]             inherits <- base::inherits
[16:18:46.132]             invokeRestart <- base::invokeRestart
[16:18:46.132]             length <- base::length
[16:18:46.132]             list <- base::list
[16:18:46.132]             seq.int <- base::seq.int
[16:18:46.132]             signalCondition <- base::signalCondition
[16:18:46.132]             sys.calls <- base::sys.calls
[16:18:46.132]             `[[` <- base::`[[`
[16:18:46.132]             `+` <- base::`+`
[16:18:46.132]             `<<-` <- base::`<<-`
[16:18:46.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.132]                   3L)]
[16:18:46.132]             }
[16:18:46.132]             function(cond) {
[16:18:46.132]                 is_error <- inherits(cond, "error")
[16:18:46.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.132]                   NULL)
[16:18:46.132]                 if (is_error) {
[16:18:46.132]                   sessionInformation <- function() {
[16:18:46.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.132]                       search = base::search(), system = base::Sys.info())
[16:18:46.132]                   }
[16:18:46.132]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.132]                     cond$call), session = sessionInformation(), 
[16:18:46.132]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.132]                   signalCondition(cond)
[16:18:46.132]                 }
[16:18:46.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.132]                 "immediateCondition"))) {
[16:18:46.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.132]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.132]                   if (TRUE && !signal) {
[16:18:46.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.132]                     {
[16:18:46.132]                       inherits <- base::inherits
[16:18:46.132]                       invokeRestart <- base::invokeRestart
[16:18:46.132]                       is.null <- base::is.null
[16:18:46.132]                       muffled <- FALSE
[16:18:46.132]                       if (inherits(cond, "message")) {
[16:18:46.132]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.132]                         if (muffled) 
[16:18:46.132]                           invokeRestart("muffleMessage")
[16:18:46.132]                       }
[16:18:46.132]                       else if (inherits(cond, "warning")) {
[16:18:46.132]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.132]                         if (muffled) 
[16:18:46.132]                           invokeRestart("muffleWarning")
[16:18:46.132]                       }
[16:18:46.132]                       else if (inherits(cond, "condition")) {
[16:18:46.132]                         if (!is.null(pattern)) {
[16:18:46.132]                           computeRestarts <- base::computeRestarts
[16:18:46.132]                           grepl <- base::grepl
[16:18:46.132]                           restarts <- computeRestarts(cond)
[16:18:46.132]                           for (restart in restarts) {
[16:18:46.132]                             name <- restart$name
[16:18:46.132]                             if (is.null(name)) 
[16:18:46.132]                               next
[16:18:46.132]                             if (!grepl(pattern, name)) 
[16:18:46.132]                               next
[16:18:46.132]                             invokeRestart(restart)
[16:18:46.132]                             muffled <- TRUE
[16:18:46.132]                             break
[16:18:46.132]                           }
[16:18:46.132]                         }
[16:18:46.132]                       }
[16:18:46.132]                       invisible(muffled)
[16:18:46.132]                     }
[16:18:46.132]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.132]                   }
[16:18:46.132]                 }
[16:18:46.132]                 else {
[16:18:46.132]                   if (TRUE) {
[16:18:46.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.132]                     {
[16:18:46.132]                       inherits <- base::inherits
[16:18:46.132]                       invokeRestart <- base::invokeRestart
[16:18:46.132]                       is.null <- base::is.null
[16:18:46.132]                       muffled <- FALSE
[16:18:46.132]                       if (inherits(cond, "message")) {
[16:18:46.132]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.132]                         if (muffled) 
[16:18:46.132]                           invokeRestart("muffleMessage")
[16:18:46.132]                       }
[16:18:46.132]                       else if (inherits(cond, "warning")) {
[16:18:46.132]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.132]                         if (muffled) 
[16:18:46.132]                           invokeRestart("muffleWarning")
[16:18:46.132]                       }
[16:18:46.132]                       else if (inherits(cond, "condition")) {
[16:18:46.132]                         if (!is.null(pattern)) {
[16:18:46.132]                           computeRestarts <- base::computeRestarts
[16:18:46.132]                           grepl <- base::grepl
[16:18:46.132]                           restarts <- computeRestarts(cond)
[16:18:46.132]                           for (restart in restarts) {
[16:18:46.132]                             name <- restart$name
[16:18:46.132]                             if (is.null(name)) 
[16:18:46.132]                               next
[16:18:46.132]                             if (!grepl(pattern, name)) 
[16:18:46.132]                               next
[16:18:46.132]                             invokeRestart(restart)
[16:18:46.132]                             muffled <- TRUE
[16:18:46.132]                             break
[16:18:46.132]                           }
[16:18:46.132]                         }
[16:18:46.132]                       }
[16:18:46.132]                       invisible(muffled)
[16:18:46.132]                     }
[16:18:46.132]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.132]                   }
[16:18:46.132]                 }
[16:18:46.132]             }
[16:18:46.132]         }))
[16:18:46.132]     }, error = function(ex) {
[16:18:46.132]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.132]                 ...future.rng), started = ...future.startTime, 
[16:18:46.132]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.132]             version = "1.8"), class = "FutureResult")
[16:18:46.132]     }, finally = {
[16:18:46.132]         if (!identical(...future.workdir, getwd())) 
[16:18:46.132]             setwd(...future.workdir)
[16:18:46.132]         {
[16:18:46.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.132]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.132]             }
[16:18:46.132]             base::options(...future.oldOptions)
[16:18:46.132]             if (.Platform$OS.type == "windows") {
[16:18:46.132]                 old_names <- names(...future.oldEnvVars)
[16:18:46.132]                 envs <- base::Sys.getenv()
[16:18:46.132]                 names <- names(envs)
[16:18:46.132]                 common <- intersect(names, old_names)
[16:18:46.132]                 added <- setdiff(names, old_names)
[16:18:46.132]                 removed <- setdiff(old_names, names)
[16:18:46.132]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.132]                   envs[common]]
[16:18:46.132]                 NAMES <- toupper(changed)
[16:18:46.132]                 args <- list()
[16:18:46.132]                 for (kk in seq_along(NAMES)) {
[16:18:46.132]                   name <- changed[[kk]]
[16:18:46.132]                   NAME <- NAMES[[kk]]
[16:18:46.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.132]                     next
[16:18:46.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.132]                 }
[16:18:46.132]                 NAMES <- toupper(added)
[16:18:46.132]                 for (kk in seq_along(NAMES)) {
[16:18:46.132]                   name <- added[[kk]]
[16:18:46.132]                   NAME <- NAMES[[kk]]
[16:18:46.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.132]                     next
[16:18:46.132]                   args[[name]] <- ""
[16:18:46.132]                 }
[16:18:46.132]                 NAMES <- toupper(removed)
[16:18:46.132]                 for (kk in seq_along(NAMES)) {
[16:18:46.132]                   name <- removed[[kk]]
[16:18:46.132]                   NAME <- NAMES[[kk]]
[16:18:46.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.132]                     next
[16:18:46.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.132]                 }
[16:18:46.132]                 if (length(args) > 0) 
[16:18:46.132]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.132]             }
[16:18:46.132]             else {
[16:18:46.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.132]             }
[16:18:46.132]             {
[16:18:46.132]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.132]                   0L) {
[16:18:46.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.132]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.132]                   base::options(opts)
[16:18:46.132]                 }
[16:18:46.132]                 {
[16:18:46.132]                   {
[16:18:46.132]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.132]                     NULL
[16:18:46.132]                   }
[16:18:46.132]                   options(future.plan = NULL)
[16:18:46.132]                   if (is.na(NA_character_)) 
[16:18:46.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.132]                     .init = FALSE)
[16:18:46.132]                 }
[16:18:46.132]             }
[16:18:46.132]         }
[16:18:46.132]     })
[16:18:46.132]     if (TRUE) {
[16:18:46.132]         base::sink(type = "output", split = FALSE)
[16:18:46.132]         if (TRUE) {
[16:18:46.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.132]         }
[16:18:46.132]         else {
[16:18:46.132]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.132]         }
[16:18:46.132]         base::close(...future.stdout)
[16:18:46.132]         ...future.stdout <- NULL
[16:18:46.132]     }
[16:18:46.132]     ...future.result$conditions <- ...future.conditions
[16:18:46.132]     ...future.result$finished <- base::Sys.time()
[16:18:46.132]     ...future.result
[16:18:46.132] }
[16:18:46.134] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[16:18:46.134] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[16:18:46.135] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[16:18:46.135] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:46.135] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.135] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[16:18:46.136] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[16:18:46.136] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:46.136] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.136] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:46.136] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.137] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[16:18:46.137] MultisessionFuture started
[16:18:46.137] - Launch lazy future ... done
[16:18:46.137] run() for ‘MultisessionFuture’ ... done
[16:18:46.137] Created future:
[16:18:46.137] MultisessionFuture:
[16:18:46.137] Label: ‘future_.mapply-2’
[16:18:46.137] Expression:
[16:18:46.137] {
[16:18:46.137]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.137]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.137]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.137]         on.exit(options(oopts), add = TRUE)
[16:18:46.137]     }
[16:18:46.137]     {
[16:18:46.137]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.137]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.137]         do.call(mapply, args = args)
[16:18:46.137]     }
[16:18:46.137] }
[16:18:46.137] Lazy evaluation: FALSE
[16:18:46.137] Asynchronous evaluation: TRUE
[16:18:46.137] Local evaluation: TRUE
[16:18:46.137] Environment: R_GlobalEnv
[16:18:46.137] Capture standard output: TRUE
[16:18:46.137] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.137] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.137] Packages: <none>
[16:18:46.137] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:46.137] Resolved: FALSE
[16:18:46.137] Value: <not collected>
[16:18:46.137] Conditions captured: <none>
[16:18:46.137] Early signaling: FALSE
[16:18:46.137] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.137] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.149] Chunk #2 of 2 ... DONE
[16:18:46.149] Launching 2 futures (chunks) ... DONE
[16:18:46.149] Resolving 2 futures (chunks) ...
[16:18:46.149] resolve() on list ...
[16:18:46.149]  recursive: 0
[16:18:46.149]  length: 2
[16:18:46.149] 
[16:18:46.150] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.150] - Validating connection of MultisessionFuture
[16:18:46.150] - received message: FutureResult
[16:18:46.150] - Received FutureResult
[16:18:46.150] - Erased future from FutureRegistry
[16:18:46.150] result() for ClusterFuture ...
[16:18:46.150] - result already collected: FutureResult
[16:18:46.151] result() for ClusterFuture ... done
[16:18:46.151] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.151] Future #1
[16:18:46.151] result() for ClusterFuture ...
[16:18:46.151] - result already collected: FutureResult
[16:18:46.151] result() for ClusterFuture ... done
[16:18:46.151] result() for ClusterFuture ...
[16:18:46.151] - result already collected: FutureResult
[16:18:46.151] result() for ClusterFuture ... done
[16:18:46.151] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:46.151] - nx: 2
[16:18:46.152] - relay: TRUE
[16:18:46.152] - stdout: TRUE
[16:18:46.152] - signal: TRUE
[16:18:46.152] - resignal: FALSE
[16:18:46.152] - force: TRUE
[16:18:46.152] - relayed: [n=2] FALSE, FALSE
[16:18:46.152] - queued futures: [n=2] FALSE, FALSE
[16:18:46.152]  - until=1
[16:18:46.152]  - relaying element #1
[16:18:46.152] result() for ClusterFuture ...
[16:18:46.152] - result already collected: FutureResult
[16:18:46.153] result() for ClusterFuture ... done
[16:18:46.153] result() for ClusterFuture ...
[16:18:46.153] - result already collected: FutureResult
[16:18:46.153] result() for ClusterFuture ... done
[16:18:46.153] result() for ClusterFuture ...
[16:18:46.153] - result already collected: FutureResult
[16:18:46.153] result() for ClusterFuture ... done
[16:18:46.153] result() for ClusterFuture ...
[16:18:46.153] - result already collected: FutureResult
[16:18:46.153] result() for ClusterFuture ... done
[16:18:46.153] - relayed: [n=2] TRUE, FALSE
[16:18:46.154] - queued futures: [n=2] TRUE, FALSE
[16:18:46.154] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:46.154]  length: 1 (resolved future 1)
[16:18:46.182] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.182] - Validating connection of MultisessionFuture
[16:18:46.182] - received message: FutureResult
[16:18:46.182] - Received FutureResult
[16:18:46.182] - Erased future from FutureRegistry
[16:18:46.182] result() for ClusterFuture ...
[16:18:46.183] - result already collected: FutureResult
[16:18:46.183] result() for ClusterFuture ... done
[16:18:46.183] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.183] Future #2
[16:18:46.183] result() for ClusterFuture ...
[16:18:46.183] - result already collected: FutureResult
[16:18:46.183] result() for ClusterFuture ... done
[16:18:46.183] result() for ClusterFuture ...
[16:18:46.183] - result already collected: FutureResult
[16:18:46.183] result() for ClusterFuture ... done
[16:18:46.183] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:46.184] - nx: 2
[16:18:46.184] - relay: TRUE
[16:18:46.184] - stdout: TRUE
[16:18:46.184] - signal: TRUE
[16:18:46.184] - resignal: FALSE
[16:18:46.184] - force: TRUE
[16:18:46.184] - relayed: [n=2] TRUE, FALSE
[16:18:46.184] - queued futures: [n=2] TRUE, FALSE
[16:18:46.184]  - until=2
[16:18:46.184]  - relaying element #2
[16:18:46.184] result() for ClusterFuture ...
[16:18:46.185] - result already collected: FutureResult
[16:18:46.185] result() for ClusterFuture ... done
[16:18:46.185] result() for ClusterFuture ...
[16:18:46.185] - result already collected: FutureResult
[16:18:46.185] result() for ClusterFuture ... done
[16:18:46.185] result() for ClusterFuture ...
[16:18:46.185] - result already collected: FutureResult
[16:18:46.185] result() for ClusterFuture ... done
[16:18:46.185] result() for ClusterFuture ...
[16:18:46.185] - result already collected: FutureResult
[16:18:46.185] result() for ClusterFuture ... done
[16:18:46.186] - relayed: [n=2] TRUE, TRUE
[16:18:46.186] - queued futures: [n=2] TRUE, TRUE
[16:18:46.186] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:46.186]  length: 0 (resolved future 2)
[16:18:46.186] Relaying remaining futures
[16:18:46.186] signalConditionsASAP(NULL, pos=0) ...
[16:18:46.186] - nx: 2
[16:18:46.186] - relay: TRUE
[16:18:46.186] - stdout: TRUE
[16:18:46.186] - signal: TRUE
[16:18:46.186] - resignal: FALSE
[16:18:46.186] - force: TRUE
[16:18:46.187] - relayed: [n=2] TRUE, TRUE
[16:18:46.187] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:46.187] - relayed: [n=2] TRUE, TRUE
[16:18:46.187] - queued futures: [n=2] TRUE, TRUE
[16:18:46.187] signalConditionsASAP(NULL, pos=0) ... done
[16:18:46.187] resolve() on list ... DONE
[16:18:46.187] result() for ClusterFuture ...
[16:18:46.187] - result already collected: FutureResult
[16:18:46.187] result() for ClusterFuture ... done
[16:18:46.187] result() for ClusterFuture ...
[16:18:46.187] - result already collected: FutureResult
[16:18:46.188] result() for ClusterFuture ... done
[16:18:46.188] result() for ClusterFuture ...
[16:18:46.188] - result already collected: FutureResult
[16:18:46.188] result() for ClusterFuture ... done
[16:18:46.188] result() for ClusterFuture ...
[16:18:46.188] - result already collected: FutureResult
[16:18:46.188] result() for ClusterFuture ... done
[16:18:46.188]  - Number of value chunks collected: 2
[16:18:46.188] Resolving 2 futures (chunks) ... DONE
[16:18:46.188] Reducing values from 2 chunks ...
[16:18:46.188]  - Number of values collected after concatenation: 5
[16:18:46.189]  - Number of values expected: 5
[16:18:46.189] Reducing values from 2 chunks ... DONE
[16:18:46.189] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[16:18:46.189] future_mapply() ...
[16:18:46.192] Number of chunks: 1
[16:18:46.193] getGlobalsAndPackagesXApply() ...
[16:18:46.193]  - future.globals: TRUE
[16:18:46.193] getGlobalsAndPackages() ...
[16:18:46.193] Searching for globals...
[16:18:46.194] - globals found: [1] ‘FUN’
[16:18:46.194] Searching for globals ... DONE
[16:18:46.194] Resolving globals: FALSE
[16:18:46.194] The total size of the 1 globals is 848 bytes (848 bytes)
[16:18:46.195] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:18:46.195] - globals: [1] ‘FUN’
[16:18:46.195] 
[16:18:46.195] getGlobalsAndPackages() ... DONE
[16:18:46.195]  - globals found/used: [n=1] ‘FUN’
[16:18:46.195]  - needed namespaces: [n=0] 
[16:18:46.195] Finding globals ... DONE
[16:18:46.196] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:46.196] List of 2
[16:18:46.196]  $ ...future.FUN:function (x)  
[16:18:46.196]  $ MoreArgs     : NULL
[16:18:46.196]  - attr(*, "where")=List of 2
[16:18:46.196]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:46.196]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:46.196]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:46.196]  - attr(*, "resolved")= logi FALSE
[16:18:46.196]  - attr(*, "total_size")= num NA
[16:18:46.198] Packages to be attached in all futures: [n=0] 
[16:18:46.198] getGlobalsAndPackagesXApply() ... DONE
[16:18:46.199] Number of futures (= number of chunks): 1
[16:18:46.199] Launching 1 futures (chunks) ...
[16:18:46.199] Chunk #1 of 1 ...
[16:18:46.199]  - Finding globals in '...' for chunk #1 ...
[16:18:46.199] getGlobalsAndPackages() ...
[16:18:46.199] Searching for globals...
[16:18:46.199] 
[16:18:46.199] Searching for globals ... DONE
[16:18:46.200] - globals: [0] <none>
[16:18:46.200] getGlobalsAndPackages() ... DONE
[16:18:46.200]    + additional globals found: [n=0] 
[16:18:46.200]    + additional namespaces needed: [n=0] 
[16:18:46.200]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:46.200]  - seeds: <none>
[16:18:46.200]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.200] getGlobalsAndPackages() ...
[16:18:46.200] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.200] Resolving globals: FALSE
[16:18:46.203] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[16:18:46.204] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:46.204] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.204] 
[16:18:46.204] getGlobalsAndPackages() ... DONE
[16:18:46.204] run() for ‘Future’ ...
[16:18:46.205] - state: ‘created’
[16:18:46.205] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.218] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.218] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.218]   - Field: ‘node’
[16:18:46.218]   - Field: ‘label’
[16:18:46.218]   - Field: ‘local’
[16:18:46.218]   - Field: ‘owner’
[16:18:46.218]   - Field: ‘envir’
[16:18:46.219]   - Field: ‘workers’
[16:18:46.219]   - Field: ‘packages’
[16:18:46.219]   - Field: ‘gc’
[16:18:46.219]   - Field: ‘conditions’
[16:18:46.219]   - Field: ‘persistent’
[16:18:46.219]   - Field: ‘expr’
[16:18:46.219]   - Field: ‘uuid’
[16:18:46.219]   - Field: ‘seed’
[16:18:46.219]   - Field: ‘version’
[16:18:46.219]   - Field: ‘result’
[16:18:46.219]   - Field: ‘asynchronous’
[16:18:46.220]   - Field: ‘calls’
[16:18:46.220]   - Field: ‘globals’
[16:18:46.220]   - Field: ‘stdout’
[16:18:46.220]   - Field: ‘earlySignal’
[16:18:46.220]   - Field: ‘lazy’
[16:18:46.220]   - Field: ‘state’
[16:18:46.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.220] - Launch lazy future ...
[16:18:46.221] Packages needed by the future expression (n = 0): <none>
[16:18:46.221] Packages needed by future strategies (n = 0): <none>
[16:18:46.221] {
[16:18:46.221]     {
[16:18:46.221]         {
[16:18:46.221]             ...future.startTime <- base::Sys.time()
[16:18:46.221]             {
[16:18:46.221]                 {
[16:18:46.221]                   {
[16:18:46.221]                     {
[16:18:46.221]                       base::local({
[16:18:46.221]                         has_future <- base::requireNamespace("future", 
[16:18:46.221]                           quietly = TRUE)
[16:18:46.221]                         if (has_future) {
[16:18:46.221]                           ns <- base::getNamespace("future")
[16:18:46.221]                           version <- ns[[".package"]][["version"]]
[16:18:46.221]                           if (is.null(version)) 
[16:18:46.221]                             version <- utils::packageVersion("future")
[16:18:46.221]                         }
[16:18:46.221]                         else {
[16:18:46.221]                           version <- NULL
[16:18:46.221]                         }
[16:18:46.221]                         if (!has_future || version < "1.8.0") {
[16:18:46.221]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.221]                             "", base::R.version$version.string), 
[16:18:46.221]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.221]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.221]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.221]                               "release", "version")], collapse = " "), 
[16:18:46.221]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.221]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.221]                             info)
[16:18:46.221]                           info <- base::paste(info, collapse = "; ")
[16:18:46.221]                           if (!has_future) {
[16:18:46.221]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.221]                               info)
[16:18:46.221]                           }
[16:18:46.221]                           else {
[16:18:46.221]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.221]                               info, version)
[16:18:46.221]                           }
[16:18:46.221]                           base::stop(msg)
[16:18:46.221]                         }
[16:18:46.221]                       })
[16:18:46.221]                     }
[16:18:46.221]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.221]                     base::options(mc.cores = 1L)
[16:18:46.221]                   }
[16:18:46.221]                   ...future.strategy.old <- future::plan("list")
[16:18:46.221]                   options(future.plan = NULL)
[16:18:46.221]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.221]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.221]                 }
[16:18:46.221]                 ...future.workdir <- getwd()
[16:18:46.221]             }
[16:18:46.221]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.221]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.221]         }
[16:18:46.221]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.221]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:46.221]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.221]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.221]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.221]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.221]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.221]             base::names(...future.oldOptions))
[16:18:46.221]     }
[16:18:46.221]     if (FALSE) {
[16:18:46.221]     }
[16:18:46.221]     else {
[16:18:46.221]         if (TRUE) {
[16:18:46.221]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.221]                 open = "w")
[16:18:46.221]         }
[16:18:46.221]         else {
[16:18:46.221]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.221]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.221]         }
[16:18:46.221]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.221]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.221]             base::sink(type = "output", split = FALSE)
[16:18:46.221]             base::close(...future.stdout)
[16:18:46.221]         }, add = TRUE)
[16:18:46.221]     }
[16:18:46.221]     ...future.frame <- base::sys.nframe()
[16:18:46.221]     ...future.conditions <- base::list()
[16:18:46.221]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.221]     if (FALSE) {
[16:18:46.221]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.221]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.221]     }
[16:18:46.221]     ...future.result <- base::tryCatch({
[16:18:46.221]         base::withCallingHandlers({
[16:18:46.221]             ...future.value <- base::withVisible(base::local({
[16:18:46.221]                 ...future.makeSendCondition <- base::local({
[16:18:46.221]                   sendCondition <- NULL
[16:18:46.221]                   function(frame = 1L) {
[16:18:46.221]                     if (is.function(sendCondition)) 
[16:18:46.221]                       return(sendCondition)
[16:18:46.221]                     ns <- getNamespace("parallel")
[16:18:46.221]                     if (exists("sendData", mode = "function", 
[16:18:46.221]                       envir = ns)) {
[16:18:46.221]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.221]                         envir = ns)
[16:18:46.221]                       envir <- sys.frame(frame)
[16:18:46.221]                       master <- NULL
[16:18:46.221]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.221]                         !identical(envir, emptyenv())) {
[16:18:46.221]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.221]                           inherits = FALSE)) {
[16:18:46.221]                           master <- get("master", mode = "list", 
[16:18:46.221]                             envir = envir, inherits = FALSE)
[16:18:46.221]                           if (inherits(master, c("SOCKnode", 
[16:18:46.221]                             "SOCK0node"))) {
[16:18:46.221]                             sendCondition <<- function(cond) {
[16:18:46.221]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.221]                                 success = TRUE)
[16:18:46.221]                               parallel_sendData(master, data)
[16:18:46.221]                             }
[16:18:46.221]                             return(sendCondition)
[16:18:46.221]                           }
[16:18:46.221]                         }
[16:18:46.221]                         frame <- frame + 1L
[16:18:46.221]                         envir <- sys.frame(frame)
[16:18:46.221]                       }
[16:18:46.221]                     }
[16:18:46.221]                     sendCondition <<- function(cond) NULL
[16:18:46.221]                   }
[16:18:46.221]                 })
[16:18:46.221]                 withCallingHandlers({
[16:18:46.221]                   {
[16:18:46.221]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.221]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.221]                       ...future.globals.maxSize)) {
[16:18:46.221]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.221]                       on.exit(options(oopts), add = TRUE)
[16:18:46.221]                     }
[16:18:46.221]                     {
[16:18:46.221]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.221]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.221]                         USE.NAMES = FALSE)
[16:18:46.221]                       do.call(mapply, args = args)
[16:18:46.221]                     }
[16:18:46.221]                   }
[16:18:46.221]                 }, immediateCondition = function(cond) {
[16:18:46.221]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.221]                   sendCondition(cond)
[16:18:46.221]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.221]                   {
[16:18:46.221]                     inherits <- base::inherits
[16:18:46.221]                     invokeRestart <- base::invokeRestart
[16:18:46.221]                     is.null <- base::is.null
[16:18:46.221]                     muffled <- FALSE
[16:18:46.221]                     if (inherits(cond, "message")) {
[16:18:46.221]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.221]                       if (muffled) 
[16:18:46.221]                         invokeRestart("muffleMessage")
[16:18:46.221]                     }
[16:18:46.221]                     else if (inherits(cond, "warning")) {
[16:18:46.221]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.221]                       if (muffled) 
[16:18:46.221]                         invokeRestart("muffleWarning")
[16:18:46.221]                     }
[16:18:46.221]                     else if (inherits(cond, "condition")) {
[16:18:46.221]                       if (!is.null(pattern)) {
[16:18:46.221]                         computeRestarts <- base::computeRestarts
[16:18:46.221]                         grepl <- base::grepl
[16:18:46.221]                         restarts <- computeRestarts(cond)
[16:18:46.221]                         for (restart in restarts) {
[16:18:46.221]                           name <- restart$name
[16:18:46.221]                           if (is.null(name)) 
[16:18:46.221]                             next
[16:18:46.221]                           if (!grepl(pattern, name)) 
[16:18:46.221]                             next
[16:18:46.221]                           invokeRestart(restart)
[16:18:46.221]                           muffled <- TRUE
[16:18:46.221]                           break
[16:18:46.221]                         }
[16:18:46.221]                       }
[16:18:46.221]                     }
[16:18:46.221]                     invisible(muffled)
[16:18:46.221]                   }
[16:18:46.221]                   muffleCondition(cond)
[16:18:46.221]                 })
[16:18:46.221]             }))
[16:18:46.221]             future::FutureResult(value = ...future.value$value, 
[16:18:46.221]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.221]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.221]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.221]                     ...future.globalenv.names))
[16:18:46.221]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.221]         }, condition = base::local({
[16:18:46.221]             c <- base::c
[16:18:46.221]             inherits <- base::inherits
[16:18:46.221]             invokeRestart <- base::invokeRestart
[16:18:46.221]             length <- base::length
[16:18:46.221]             list <- base::list
[16:18:46.221]             seq.int <- base::seq.int
[16:18:46.221]             signalCondition <- base::signalCondition
[16:18:46.221]             sys.calls <- base::sys.calls
[16:18:46.221]             `[[` <- base::`[[`
[16:18:46.221]             `+` <- base::`+`
[16:18:46.221]             `<<-` <- base::`<<-`
[16:18:46.221]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.221]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.221]                   3L)]
[16:18:46.221]             }
[16:18:46.221]             function(cond) {
[16:18:46.221]                 is_error <- inherits(cond, "error")
[16:18:46.221]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.221]                   NULL)
[16:18:46.221]                 if (is_error) {
[16:18:46.221]                   sessionInformation <- function() {
[16:18:46.221]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.221]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.221]                       search = base::search(), system = base::Sys.info())
[16:18:46.221]                   }
[16:18:46.221]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.221]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.221]                     cond$call), session = sessionInformation(), 
[16:18:46.221]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.221]                   signalCondition(cond)
[16:18:46.221]                 }
[16:18:46.221]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.221]                 "immediateCondition"))) {
[16:18:46.221]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.221]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.221]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.221]                   if (TRUE && !signal) {
[16:18:46.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.221]                     {
[16:18:46.221]                       inherits <- base::inherits
[16:18:46.221]                       invokeRestart <- base::invokeRestart
[16:18:46.221]                       is.null <- base::is.null
[16:18:46.221]                       muffled <- FALSE
[16:18:46.221]                       if (inherits(cond, "message")) {
[16:18:46.221]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.221]                         if (muffled) 
[16:18:46.221]                           invokeRestart("muffleMessage")
[16:18:46.221]                       }
[16:18:46.221]                       else if (inherits(cond, "warning")) {
[16:18:46.221]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.221]                         if (muffled) 
[16:18:46.221]                           invokeRestart("muffleWarning")
[16:18:46.221]                       }
[16:18:46.221]                       else if (inherits(cond, "condition")) {
[16:18:46.221]                         if (!is.null(pattern)) {
[16:18:46.221]                           computeRestarts <- base::computeRestarts
[16:18:46.221]                           grepl <- base::grepl
[16:18:46.221]                           restarts <- computeRestarts(cond)
[16:18:46.221]                           for (restart in restarts) {
[16:18:46.221]                             name <- restart$name
[16:18:46.221]                             if (is.null(name)) 
[16:18:46.221]                               next
[16:18:46.221]                             if (!grepl(pattern, name)) 
[16:18:46.221]                               next
[16:18:46.221]                             invokeRestart(restart)
[16:18:46.221]                             muffled <- TRUE
[16:18:46.221]                             break
[16:18:46.221]                           }
[16:18:46.221]                         }
[16:18:46.221]                       }
[16:18:46.221]                       invisible(muffled)
[16:18:46.221]                     }
[16:18:46.221]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.221]                   }
[16:18:46.221]                 }
[16:18:46.221]                 else {
[16:18:46.221]                   if (TRUE) {
[16:18:46.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.221]                     {
[16:18:46.221]                       inherits <- base::inherits
[16:18:46.221]                       invokeRestart <- base::invokeRestart
[16:18:46.221]                       is.null <- base::is.null
[16:18:46.221]                       muffled <- FALSE
[16:18:46.221]                       if (inherits(cond, "message")) {
[16:18:46.221]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.221]                         if (muffled) 
[16:18:46.221]                           invokeRestart("muffleMessage")
[16:18:46.221]                       }
[16:18:46.221]                       else if (inherits(cond, "warning")) {
[16:18:46.221]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.221]                         if (muffled) 
[16:18:46.221]                           invokeRestart("muffleWarning")
[16:18:46.221]                       }
[16:18:46.221]                       else if (inherits(cond, "condition")) {
[16:18:46.221]                         if (!is.null(pattern)) {
[16:18:46.221]                           computeRestarts <- base::computeRestarts
[16:18:46.221]                           grepl <- base::grepl
[16:18:46.221]                           restarts <- computeRestarts(cond)
[16:18:46.221]                           for (restart in restarts) {
[16:18:46.221]                             name <- restart$name
[16:18:46.221]                             if (is.null(name)) 
[16:18:46.221]                               next
[16:18:46.221]                             if (!grepl(pattern, name)) 
[16:18:46.221]                               next
[16:18:46.221]                             invokeRestart(restart)
[16:18:46.221]                             muffled <- TRUE
[16:18:46.221]                             break
[16:18:46.221]                           }
[16:18:46.221]                         }
[16:18:46.221]                       }
[16:18:46.221]                       invisible(muffled)
[16:18:46.221]                     }
[16:18:46.221]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.221]                   }
[16:18:46.221]                 }
[16:18:46.221]             }
[16:18:46.221]         }))
[16:18:46.221]     }, error = function(ex) {
[16:18:46.221]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.221]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.221]                 ...future.rng), started = ...future.startTime, 
[16:18:46.221]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.221]             version = "1.8"), class = "FutureResult")
[16:18:46.221]     }, finally = {
[16:18:46.221]         if (!identical(...future.workdir, getwd())) 
[16:18:46.221]             setwd(...future.workdir)
[16:18:46.221]         {
[16:18:46.221]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.221]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.221]             }
[16:18:46.221]             base::options(...future.oldOptions)
[16:18:46.221]             if (.Platform$OS.type == "windows") {
[16:18:46.221]                 old_names <- names(...future.oldEnvVars)
[16:18:46.221]                 envs <- base::Sys.getenv()
[16:18:46.221]                 names <- names(envs)
[16:18:46.221]                 common <- intersect(names, old_names)
[16:18:46.221]                 added <- setdiff(names, old_names)
[16:18:46.221]                 removed <- setdiff(old_names, names)
[16:18:46.221]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.221]                   envs[common]]
[16:18:46.221]                 NAMES <- toupper(changed)
[16:18:46.221]                 args <- list()
[16:18:46.221]                 for (kk in seq_along(NAMES)) {
[16:18:46.221]                   name <- changed[[kk]]
[16:18:46.221]                   NAME <- NAMES[[kk]]
[16:18:46.221]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.221]                     next
[16:18:46.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.221]                 }
[16:18:46.221]                 NAMES <- toupper(added)
[16:18:46.221]                 for (kk in seq_along(NAMES)) {
[16:18:46.221]                   name <- added[[kk]]
[16:18:46.221]                   NAME <- NAMES[[kk]]
[16:18:46.221]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.221]                     next
[16:18:46.221]                   args[[name]] <- ""
[16:18:46.221]                 }
[16:18:46.221]                 NAMES <- toupper(removed)
[16:18:46.221]                 for (kk in seq_along(NAMES)) {
[16:18:46.221]                   name <- removed[[kk]]
[16:18:46.221]                   NAME <- NAMES[[kk]]
[16:18:46.221]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.221]                     next
[16:18:46.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.221]                 }
[16:18:46.221]                 if (length(args) > 0) 
[16:18:46.221]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.221]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.221]             }
[16:18:46.221]             else {
[16:18:46.221]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.221]             }
[16:18:46.221]             {
[16:18:46.221]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.221]                   0L) {
[16:18:46.221]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.221]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.221]                   base::options(opts)
[16:18:46.221]                 }
[16:18:46.221]                 {
[16:18:46.221]                   {
[16:18:46.221]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.221]                     NULL
[16:18:46.221]                   }
[16:18:46.221]                   options(future.plan = NULL)
[16:18:46.221]                   if (is.na(NA_character_)) 
[16:18:46.221]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.221]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.221]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.221]                     .init = FALSE)
[16:18:46.221]                 }
[16:18:46.221]             }
[16:18:46.221]         }
[16:18:46.221]     })
[16:18:46.221]     if (TRUE) {
[16:18:46.221]         base::sink(type = "output", split = FALSE)
[16:18:46.221]         if (TRUE) {
[16:18:46.221]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.221]         }
[16:18:46.221]         else {
[16:18:46.221]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.221]         }
[16:18:46.221]         base::close(...future.stdout)
[16:18:46.221]         ...future.stdout <- NULL
[16:18:46.221]     }
[16:18:46.221]     ...future.result$conditions <- ...future.conditions
[16:18:46.221]     ...future.result$finished <- base::Sys.time()
[16:18:46.221]     ...future.result
[16:18:46.221] }
[16:18:46.224] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[16:18:46.224] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:18:46.224] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:18:46.224] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:46.225] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.225] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:18:46.225] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:18:46.225] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:46.225] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.226] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:46.226] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.226] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[16:18:46.226] MultisessionFuture started
[16:18:46.227] - Launch lazy future ... done
[16:18:46.227] run() for ‘MultisessionFuture’ ... done
[16:18:46.227] Created future:
[16:18:46.227] MultisessionFuture:
[16:18:46.227] Label: ‘future_mapply-1’
[16:18:46.227] Expression:
[16:18:46.227] {
[16:18:46.227]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.227]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.227]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.227]         on.exit(options(oopts), add = TRUE)
[16:18:46.227]     }
[16:18:46.227]     {
[16:18:46.227]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.227]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.227]         do.call(mapply, args = args)
[16:18:46.227]     }
[16:18:46.227] }
[16:18:46.227] Lazy evaluation: FALSE
[16:18:46.227] Asynchronous evaluation: TRUE
[16:18:46.227] Local evaluation: TRUE
[16:18:46.227] Environment: R_GlobalEnv
[16:18:46.227] Capture standard output: TRUE
[16:18:46.227] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.227] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.227] Packages: <none>
[16:18:46.227] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:46.227] Resolved: FALSE
[16:18:46.227] Value: <not collected>
[16:18:46.227] Conditions captured: <none>
[16:18:46.227] Early signaling: FALSE
[16:18:46.227] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.227] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.238] Chunk #1 of 1 ... DONE
[16:18:46.238] Launching 1 futures (chunks) ... DONE
[16:18:46.238] Resolving 1 futures (chunks) ...
[16:18:46.238] resolve() on list ...
[16:18:46.239]  recursive: 0
[16:18:46.239]  length: 1
[16:18:46.239] 
[16:18:46.270] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.270] - Validating connection of MultisessionFuture
[16:18:46.270] - received message: FutureResult
[16:18:46.270] - Received FutureResult
[16:18:46.270] - Erased future from FutureRegistry
[16:18:46.270] result() for ClusterFuture ...
[16:18:46.271] - result already collected: FutureResult
[16:18:46.271] result() for ClusterFuture ... done
[16:18:46.271] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.271] Future #1
[16:18:46.271] result() for ClusterFuture ...
[16:18:46.271] - result already collected: FutureResult
[16:18:46.271] result() for ClusterFuture ... done
[16:18:46.271] result() for ClusterFuture ...
[16:18:46.271] - result already collected: FutureResult
[16:18:46.271] result() for ClusterFuture ... done
[16:18:46.271] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:46.272] - nx: 1
[16:18:46.272] - relay: TRUE
[16:18:46.272] - stdout: TRUE
[16:18:46.272] - signal: TRUE
[16:18:46.272] - resignal: FALSE
[16:18:46.272] - force: TRUE
[16:18:46.272] - relayed: [n=1] FALSE
[16:18:46.272] - queued futures: [n=1] FALSE
[16:18:46.272]  - until=1
[16:18:46.272]  - relaying element #1
[16:18:46.272] result() for ClusterFuture ...
[16:18:46.273] - result already collected: FutureResult
[16:18:46.273] result() for ClusterFuture ... done
[16:18:46.273] result() for ClusterFuture ...
[16:18:46.273] - result already collected: FutureResult
[16:18:46.273] result() for ClusterFuture ... done
[16:18:46.273] result() for ClusterFuture ...
[16:18:46.273] - result already collected: FutureResult
[16:18:46.273] result() for ClusterFuture ... done
[16:18:46.273] result() for ClusterFuture ...
[16:18:46.273] - result already collected: FutureResult
[16:18:46.273] result() for ClusterFuture ... done
[16:18:46.273] - relayed: [n=1] TRUE
[16:18:46.274] - queued futures: [n=1] TRUE
[16:18:46.274] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:46.274]  length: 0 (resolved future 1)
[16:18:46.274] Relaying remaining futures
[16:18:46.274] signalConditionsASAP(NULL, pos=0) ...
[16:18:46.274] - nx: 1
[16:18:46.274] - relay: TRUE
[16:18:46.274] - stdout: TRUE
[16:18:46.274] - signal: TRUE
[16:18:46.274] - resignal: FALSE
[16:18:46.274] - force: TRUE
[16:18:46.274] - relayed: [n=1] TRUE
[16:18:46.275] - queued futures: [n=1] TRUE
 - flush all
[16:18:46.275] - relayed: [n=1] TRUE
[16:18:46.275] - queued futures: [n=1] TRUE
[16:18:46.275] signalConditionsASAP(NULL, pos=0) ... done
[16:18:46.275] resolve() on list ... DONE
[16:18:46.275] result() for ClusterFuture ...
[16:18:46.275] - result already collected: FutureResult
[16:18:46.275] result() for ClusterFuture ... done
[16:18:46.275] result() for ClusterFuture ...
[16:18:46.275] - result already collected: FutureResult
[16:18:46.275] result() for ClusterFuture ... done
[16:18:46.276]  - Number of value chunks collected: 1
[16:18:46.276] Resolving 1 futures (chunks) ... DONE
[16:18:46.276] Reducing values from 1 chunks ...
[16:18:46.276]  - Number of values collected after concatenation: 1
[16:18:46.276]  - Number of values expected: 1
[16:18:46.276] Reducing values from 1 chunks ... DONE
[16:18:46.276] future_mapply() ... DONE
[16:18:46.276] future_mapply() ...
[16:18:46.280] Number of chunks: 1
[16:18:46.280] getGlobalsAndPackagesXApply() ...
[16:18:46.280]  - future.globals: TRUE
[16:18:46.280] getGlobalsAndPackages() ...
[16:18:46.280] Searching for globals...
[16:18:46.281] - globals found: [1] ‘FUN’
[16:18:46.281] Searching for globals ... DONE
[16:18:46.282] Resolving globals: FALSE
[16:18:46.282] The total size of the 1 globals is 848 bytes (848 bytes)
[16:18:46.282] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:18:46.282] - globals: [1] ‘FUN’
[16:18:46.282] 
[16:18:46.282] getGlobalsAndPackages() ... DONE
[16:18:46.283]  - globals found/used: [n=1] ‘FUN’
[16:18:46.283]  - needed namespaces: [n=0] 
[16:18:46.283] Finding globals ... DONE
[16:18:46.283] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:46.283] List of 2
[16:18:46.283]  $ ...future.FUN:function (x)  
[16:18:46.283]  $ MoreArgs     : list()
[16:18:46.283]  - attr(*, "where")=List of 2
[16:18:46.283]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:46.283]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:46.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:46.283]  - attr(*, "resolved")= logi FALSE
[16:18:46.283]  - attr(*, "total_size")= num NA
[16:18:46.286] Packages to be attached in all futures: [n=0] 
[16:18:46.286] getGlobalsAndPackagesXApply() ... DONE
[16:18:46.286] Number of futures (= number of chunks): 1
[16:18:46.286] Launching 1 futures (chunks) ...
[16:18:46.286] Chunk #1 of 1 ...
[16:18:46.286]  - Finding globals in '...' for chunk #1 ...
[16:18:46.286] getGlobalsAndPackages() ...
[16:18:46.286] Searching for globals...
[16:18:46.287] 
[16:18:46.287] Searching for globals ... DONE
[16:18:46.287] - globals: [0] <none>
[16:18:46.287] getGlobalsAndPackages() ... DONE
[16:18:46.287]    + additional globals found: [n=0] 
[16:18:46.287]    + additional namespaces needed: [n=0] 
[16:18:46.287]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:46.287]  - seeds: <none>
[16:18:46.287]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.288] getGlobalsAndPackages() ...
[16:18:46.288] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.288] Resolving globals: FALSE
[16:18:46.288] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[16:18:46.289] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[16:18:46.289] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.289] 
[16:18:46.289] getGlobalsAndPackages() ... DONE
[16:18:46.289] run() for ‘Future’ ...
[16:18:46.289] - state: ‘created’
[16:18:46.290] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.303] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.303] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.303]   - Field: ‘node’
[16:18:46.304]   - Field: ‘label’
[16:18:46.304]   - Field: ‘local’
[16:18:46.304]   - Field: ‘owner’
[16:18:46.304]   - Field: ‘envir’
[16:18:46.304]   - Field: ‘workers’
[16:18:46.304]   - Field: ‘packages’
[16:18:46.304]   - Field: ‘gc’
[16:18:46.304]   - Field: ‘conditions’
[16:18:46.304]   - Field: ‘persistent’
[16:18:46.304]   - Field: ‘expr’
[16:18:46.304]   - Field: ‘uuid’
[16:18:46.305]   - Field: ‘seed’
[16:18:46.305]   - Field: ‘version’
[16:18:46.305]   - Field: ‘result’
[16:18:46.305]   - Field: ‘asynchronous’
[16:18:46.305]   - Field: ‘calls’
[16:18:46.305]   - Field: ‘globals’
[16:18:46.305]   - Field: ‘stdout’
[16:18:46.305]   - Field: ‘earlySignal’
[16:18:46.305]   - Field: ‘lazy’
[16:18:46.305]   - Field: ‘state’
[16:18:46.305] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.306] - Launch lazy future ...
[16:18:46.306] Packages needed by the future expression (n = 0): <none>
[16:18:46.306] Packages needed by future strategies (n = 0): <none>
[16:18:46.306] {
[16:18:46.306]     {
[16:18:46.306]         {
[16:18:46.306]             ...future.startTime <- base::Sys.time()
[16:18:46.306]             {
[16:18:46.306]                 {
[16:18:46.306]                   {
[16:18:46.306]                     {
[16:18:46.306]                       base::local({
[16:18:46.306]                         has_future <- base::requireNamespace("future", 
[16:18:46.306]                           quietly = TRUE)
[16:18:46.306]                         if (has_future) {
[16:18:46.306]                           ns <- base::getNamespace("future")
[16:18:46.306]                           version <- ns[[".package"]][["version"]]
[16:18:46.306]                           if (is.null(version)) 
[16:18:46.306]                             version <- utils::packageVersion("future")
[16:18:46.306]                         }
[16:18:46.306]                         else {
[16:18:46.306]                           version <- NULL
[16:18:46.306]                         }
[16:18:46.306]                         if (!has_future || version < "1.8.0") {
[16:18:46.306]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.306]                             "", base::R.version$version.string), 
[16:18:46.306]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.306]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.306]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.306]                               "release", "version")], collapse = " "), 
[16:18:46.306]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.306]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.306]                             info)
[16:18:46.306]                           info <- base::paste(info, collapse = "; ")
[16:18:46.306]                           if (!has_future) {
[16:18:46.306]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.306]                               info)
[16:18:46.306]                           }
[16:18:46.306]                           else {
[16:18:46.306]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.306]                               info, version)
[16:18:46.306]                           }
[16:18:46.306]                           base::stop(msg)
[16:18:46.306]                         }
[16:18:46.306]                       })
[16:18:46.306]                     }
[16:18:46.306]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.306]                     base::options(mc.cores = 1L)
[16:18:46.306]                   }
[16:18:46.306]                   ...future.strategy.old <- future::plan("list")
[16:18:46.306]                   options(future.plan = NULL)
[16:18:46.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.306]                 }
[16:18:46.306]                 ...future.workdir <- getwd()
[16:18:46.306]             }
[16:18:46.306]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.306]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.306]         }
[16:18:46.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.306]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:18:46.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.306]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.306]             base::names(...future.oldOptions))
[16:18:46.306]     }
[16:18:46.306]     if (FALSE) {
[16:18:46.306]     }
[16:18:46.306]     else {
[16:18:46.306]         if (TRUE) {
[16:18:46.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.306]                 open = "w")
[16:18:46.306]         }
[16:18:46.306]         else {
[16:18:46.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.306]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.306]         }
[16:18:46.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.306]             base::sink(type = "output", split = FALSE)
[16:18:46.306]             base::close(...future.stdout)
[16:18:46.306]         }, add = TRUE)
[16:18:46.306]     }
[16:18:46.306]     ...future.frame <- base::sys.nframe()
[16:18:46.306]     ...future.conditions <- base::list()
[16:18:46.306]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.306]     if (FALSE) {
[16:18:46.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.306]     }
[16:18:46.306]     ...future.result <- base::tryCatch({
[16:18:46.306]         base::withCallingHandlers({
[16:18:46.306]             ...future.value <- base::withVisible(base::local({
[16:18:46.306]                 ...future.makeSendCondition <- base::local({
[16:18:46.306]                   sendCondition <- NULL
[16:18:46.306]                   function(frame = 1L) {
[16:18:46.306]                     if (is.function(sendCondition)) 
[16:18:46.306]                       return(sendCondition)
[16:18:46.306]                     ns <- getNamespace("parallel")
[16:18:46.306]                     if (exists("sendData", mode = "function", 
[16:18:46.306]                       envir = ns)) {
[16:18:46.306]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.306]                         envir = ns)
[16:18:46.306]                       envir <- sys.frame(frame)
[16:18:46.306]                       master <- NULL
[16:18:46.306]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.306]                         !identical(envir, emptyenv())) {
[16:18:46.306]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.306]                           inherits = FALSE)) {
[16:18:46.306]                           master <- get("master", mode = "list", 
[16:18:46.306]                             envir = envir, inherits = FALSE)
[16:18:46.306]                           if (inherits(master, c("SOCKnode", 
[16:18:46.306]                             "SOCK0node"))) {
[16:18:46.306]                             sendCondition <<- function(cond) {
[16:18:46.306]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.306]                                 success = TRUE)
[16:18:46.306]                               parallel_sendData(master, data)
[16:18:46.306]                             }
[16:18:46.306]                             return(sendCondition)
[16:18:46.306]                           }
[16:18:46.306]                         }
[16:18:46.306]                         frame <- frame + 1L
[16:18:46.306]                         envir <- sys.frame(frame)
[16:18:46.306]                       }
[16:18:46.306]                     }
[16:18:46.306]                     sendCondition <<- function(cond) NULL
[16:18:46.306]                   }
[16:18:46.306]                 })
[16:18:46.306]                 withCallingHandlers({
[16:18:46.306]                   {
[16:18:46.306]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.306]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.306]                       ...future.globals.maxSize)) {
[16:18:46.306]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.306]                       on.exit(options(oopts), add = TRUE)
[16:18:46.306]                     }
[16:18:46.306]                     {
[16:18:46.306]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.306]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.306]                         USE.NAMES = FALSE)
[16:18:46.306]                       do.call(mapply, args = args)
[16:18:46.306]                     }
[16:18:46.306]                   }
[16:18:46.306]                 }, immediateCondition = function(cond) {
[16:18:46.306]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.306]                   sendCondition(cond)
[16:18:46.306]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.306]                   {
[16:18:46.306]                     inherits <- base::inherits
[16:18:46.306]                     invokeRestart <- base::invokeRestart
[16:18:46.306]                     is.null <- base::is.null
[16:18:46.306]                     muffled <- FALSE
[16:18:46.306]                     if (inherits(cond, "message")) {
[16:18:46.306]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.306]                       if (muffled) 
[16:18:46.306]                         invokeRestart("muffleMessage")
[16:18:46.306]                     }
[16:18:46.306]                     else if (inherits(cond, "warning")) {
[16:18:46.306]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.306]                       if (muffled) 
[16:18:46.306]                         invokeRestart("muffleWarning")
[16:18:46.306]                     }
[16:18:46.306]                     else if (inherits(cond, "condition")) {
[16:18:46.306]                       if (!is.null(pattern)) {
[16:18:46.306]                         computeRestarts <- base::computeRestarts
[16:18:46.306]                         grepl <- base::grepl
[16:18:46.306]                         restarts <- computeRestarts(cond)
[16:18:46.306]                         for (restart in restarts) {
[16:18:46.306]                           name <- restart$name
[16:18:46.306]                           if (is.null(name)) 
[16:18:46.306]                             next
[16:18:46.306]                           if (!grepl(pattern, name)) 
[16:18:46.306]                             next
[16:18:46.306]                           invokeRestart(restart)
[16:18:46.306]                           muffled <- TRUE
[16:18:46.306]                           break
[16:18:46.306]                         }
[16:18:46.306]                       }
[16:18:46.306]                     }
[16:18:46.306]                     invisible(muffled)
[16:18:46.306]                   }
[16:18:46.306]                   muffleCondition(cond)
[16:18:46.306]                 })
[16:18:46.306]             }))
[16:18:46.306]             future::FutureResult(value = ...future.value$value, 
[16:18:46.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.306]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.306]                     ...future.globalenv.names))
[16:18:46.306]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.306]         }, condition = base::local({
[16:18:46.306]             c <- base::c
[16:18:46.306]             inherits <- base::inherits
[16:18:46.306]             invokeRestart <- base::invokeRestart
[16:18:46.306]             length <- base::length
[16:18:46.306]             list <- base::list
[16:18:46.306]             seq.int <- base::seq.int
[16:18:46.306]             signalCondition <- base::signalCondition
[16:18:46.306]             sys.calls <- base::sys.calls
[16:18:46.306]             `[[` <- base::`[[`
[16:18:46.306]             `+` <- base::`+`
[16:18:46.306]             `<<-` <- base::`<<-`
[16:18:46.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.306]                   3L)]
[16:18:46.306]             }
[16:18:46.306]             function(cond) {
[16:18:46.306]                 is_error <- inherits(cond, "error")
[16:18:46.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.306]                   NULL)
[16:18:46.306]                 if (is_error) {
[16:18:46.306]                   sessionInformation <- function() {
[16:18:46.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.306]                       search = base::search(), system = base::Sys.info())
[16:18:46.306]                   }
[16:18:46.306]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.306]                     cond$call), session = sessionInformation(), 
[16:18:46.306]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.306]                   signalCondition(cond)
[16:18:46.306]                 }
[16:18:46.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.306]                 "immediateCondition"))) {
[16:18:46.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.306]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.306]                   if (TRUE && !signal) {
[16:18:46.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.306]                     {
[16:18:46.306]                       inherits <- base::inherits
[16:18:46.306]                       invokeRestart <- base::invokeRestart
[16:18:46.306]                       is.null <- base::is.null
[16:18:46.306]                       muffled <- FALSE
[16:18:46.306]                       if (inherits(cond, "message")) {
[16:18:46.306]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.306]                         if (muffled) 
[16:18:46.306]                           invokeRestart("muffleMessage")
[16:18:46.306]                       }
[16:18:46.306]                       else if (inherits(cond, "warning")) {
[16:18:46.306]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.306]                         if (muffled) 
[16:18:46.306]                           invokeRestart("muffleWarning")
[16:18:46.306]                       }
[16:18:46.306]                       else if (inherits(cond, "condition")) {
[16:18:46.306]                         if (!is.null(pattern)) {
[16:18:46.306]                           computeRestarts <- base::computeRestarts
[16:18:46.306]                           grepl <- base::grepl
[16:18:46.306]                           restarts <- computeRestarts(cond)
[16:18:46.306]                           for (restart in restarts) {
[16:18:46.306]                             name <- restart$name
[16:18:46.306]                             if (is.null(name)) 
[16:18:46.306]                               next
[16:18:46.306]                             if (!grepl(pattern, name)) 
[16:18:46.306]                               next
[16:18:46.306]                             invokeRestart(restart)
[16:18:46.306]                             muffled <- TRUE
[16:18:46.306]                             break
[16:18:46.306]                           }
[16:18:46.306]                         }
[16:18:46.306]                       }
[16:18:46.306]                       invisible(muffled)
[16:18:46.306]                     }
[16:18:46.306]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.306]                   }
[16:18:46.306]                 }
[16:18:46.306]                 else {
[16:18:46.306]                   if (TRUE) {
[16:18:46.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.306]                     {
[16:18:46.306]                       inherits <- base::inherits
[16:18:46.306]                       invokeRestart <- base::invokeRestart
[16:18:46.306]                       is.null <- base::is.null
[16:18:46.306]                       muffled <- FALSE
[16:18:46.306]                       if (inherits(cond, "message")) {
[16:18:46.306]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.306]                         if (muffled) 
[16:18:46.306]                           invokeRestart("muffleMessage")
[16:18:46.306]                       }
[16:18:46.306]                       else if (inherits(cond, "warning")) {
[16:18:46.306]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.306]                         if (muffled) 
[16:18:46.306]                           invokeRestart("muffleWarning")
[16:18:46.306]                       }
[16:18:46.306]                       else if (inherits(cond, "condition")) {
[16:18:46.306]                         if (!is.null(pattern)) {
[16:18:46.306]                           computeRestarts <- base::computeRestarts
[16:18:46.306]                           grepl <- base::grepl
[16:18:46.306]                           restarts <- computeRestarts(cond)
[16:18:46.306]                           for (restart in restarts) {
[16:18:46.306]                             name <- restart$name
[16:18:46.306]                             if (is.null(name)) 
[16:18:46.306]                               next
[16:18:46.306]                             if (!grepl(pattern, name)) 
[16:18:46.306]                               next
[16:18:46.306]                             invokeRestart(restart)
[16:18:46.306]                             muffled <- TRUE
[16:18:46.306]                             break
[16:18:46.306]                           }
[16:18:46.306]                         }
[16:18:46.306]                       }
[16:18:46.306]                       invisible(muffled)
[16:18:46.306]                     }
[16:18:46.306]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.306]                   }
[16:18:46.306]                 }
[16:18:46.306]             }
[16:18:46.306]         }))
[16:18:46.306]     }, error = function(ex) {
[16:18:46.306]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.306]                 ...future.rng), started = ...future.startTime, 
[16:18:46.306]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.306]             version = "1.8"), class = "FutureResult")
[16:18:46.306]     }, finally = {
[16:18:46.306]         if (!identical(...future.workdir, getwd())) 
[16:18:46.306]             setwd(...future.workdir)
[16:18:46.306]         {
[16:18:46.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.306]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.306]             }
[16:18:46.306]             base::options(...future.oldOptions)
[16:18:46.306]             if (.Platform$OS.type == "windows") {
[16:18:46.306]                 old_names <- names(...future.oldEnvVars)
[16:18:46.306]                 envs <- base::Sys.getenv()
[16:18:46.306]                 names <- names(envs)
[16:18:46.306]                 common <- intersect(names, old_names)
[16:18:46.306]                 added <- setdiff(names, old_names)
[16:18:46.306]                 removed <- setdiff(old_names, names)
[16:18:46.306]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.306]                   envs[common]]
[16:18:46.306]                 NAMES <- toupper(changed)
[16:18:46.306]                 args <- list()
[16:18:46.306]                 for (kk in seq_along(NAMES)) {
[16:18:46.306]                   name <- changed[[kk]]
[16:18:46.306]                   NAME <- NAMES[[kk]]
[16:18:46.306]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.306]                     next
[16:18:46.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.306]                 }
[16:18:46.306]                 NAMES <- toupper(added)
[16:18:46.306]                 for (kk in seq_along(NAMES)) {
[16:18:46.306]                   name <- added[[kk]]
[16:18:46.306]                   NAME <- NAMES[[kk]]
[16:18:46.306]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.306]                     next
[16:18:46.306]                   args[[name]] <- ""
[16:18:46.306]                 }
[16:18:46.306]                 NAMES <- toupper(removed)
[16:18:46.306]                 for (kk in seq_along(NAMES)) {
[16:18:46.306]                   name <- removed[[kk]]
[16:18:46.306]                   NAME <- NAMES[[kk]]
[16:18:46.306]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.306]                     next
[16:18:46.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.306]                 }
[16:18:46.306]                 if (length(args) > 0) 
[16:18:46.306]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.306]             }
[16:18:46.306]             else {
[16:18:46.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.306]             }
[16:18:46.306]             {
[16:18:46.306]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.306]                   0L) {
[16:18:46.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.306]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.306]                   base::options(opts)
[16:18:46.306]                 }
[16:18:46.306]                 {
[16:18:46.306]                   {
[16:18:46.306]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.306]                     NULL
[16:18:46.306]                   }
[16:18:46.306]                   options(future.plan = NULL)
[16:18:46.306]                   if (is.na(NA_character_)) 
[16:18:46.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.306]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.306]                     .init = FALSE)
[16:18:46.306]                 }
[16:18:46.306]             }
[16:18:46.306]         }
[16:18:46.306]     })
[16:18:46.306]     if (TRUE) {
[16:18:46.306]         base::sink(type = "output", split = FALSE)
[16:18:46.306]         if (TRUE) {
[16:18:46.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.306]         }
[16:18:46.306]         else {
[16:18:46.306]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.306]         }
[16:18:46.306]         base::close(...future.stdout)
[16:18:46.306]         ...future.stdout <- NULL
[16:18:46.306]     }
[16:18:46.306]     ...future.result$conditions <- ...future.conditions
[16:18:46.306]     ...future.result$finished <- base::Sys.time()
[16:18:46.306]     ...future.result
[16:18:46.306] }
[16:18:46.309] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[16:18:46.309] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:18:46.310] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:18:46.310] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:46.310] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.310] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:18:46.311] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:18:46.311] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:46.311] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.311] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:46.311] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.312] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[16:18:46.312] MultisessionFuture started
[16:18:46.312] - Launch lazy future ... done
[16:18:46.312] run() for ‘MultisessionFuture’ ... done
[16:18:46.312] Created future:
[16:18:46.313] MultisessionFuture:
[16:18:46.313] Label: ‘future_.mapply-1’
[16:18:46.313] Expression:
[16:18:46.313] {
[16:18:46.313]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.313]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.313]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.313]         on.exit(options(oopts), add = TRUE)
[16:18:46.313]     }
[16:18:46.313]     {
[16:18:46.313]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.313]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.313]         do.call(mapply, args = args)
[16:18:46.313]     }
[16:18:46.313] }
[16:18:46.313] Lazy evaluation: FALSE
[16:18:46.313] Asynchronous evaluation: TRUE
[16:18:46.313] Local evaluation: TRUE
[16:18:46.313] Environment: R_GlobalEnv
[16:18:46.313] Capture standard output: TRUE
[16:18:46.313] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.313] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.313] Packages: <none>
[16:18:46.313] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:46.313] Resolved: FALSE
[16:18:46.313] Value: <not collected>
[16:18:46.313] Conditions captured: <none>
[16:18:46.313] Early signaling: FALSE
[16:18:46.313] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.313] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.324] Chunk #1 of 1 ... DONE
[16:18:46.324] Launching 1 futures (chunks) ... DONE
[16:18:46.324] Resolving 1 futures (chunks) ...
[16:18:46.324] resolve() on list ...
[16:18:46.324]  recursive: 0
[16:18:46.325]  length: 1
[16:18:46.325] 
[16:18:46.354] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.354] - Validating connection of MultisessionFuture
[16:18:46.354] - received message: FutureResult
[16:18:46.354] - Received FutureResult
[16:18:46.354] - Erased future from FutureRegistry
[16:18:46.355] result() for ClusterFuture ...
[16:18:46.355] - result already collected: FutureResult
[16:18:46.355] result() for ClusterFuture ... done
[16:18:46.355] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.355] Future #1
[16:18:46.355] result() for ClusterFuture ...
[16:18:46.355] - result already collected: FutureResult
[16:18:46.355] result() for ClusterFuture ... done
[16:18:46.355] result() for ClusterFuture ...
[16:18:46.355] - result already collected: FutureResult
[16:18:46.355] result() for ClusterFuture ... done
[16:18:46.356] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:46.356] - nx: 1
[16:18:46.356] - relay: TRUE
[16:18:46.356] - stdout: TRUE
[16:18:46.356] - signal: TRUE
[16:18:46.356] - resignal: FALSE
[16:18:46.356] - force: TRUE
[16:18:46.356] - relayed: [n=1] FALSE
[16:18:46.356] - queued futures: [n=1] FALSE
[16:18:46.356]  - until=1
[16:18:46.357]  - relaying element #1
[16:18:46.357] result() for ClusterFuture ...
[16:18:46.357] - result already collected: FutureResult
[16:18:46.357] result() for ClusterFuture ... done
[16:18:46.357] result() for ClusterFuture ...
[16:18:46.357] - result already collected: FutureResult
[16:18:46.357] result() for ClusterFuture ... done
[16:18:46.357] result() for ClusterFuture ...
[16:18:46.357] - result already collected: FutureResult
[16:18:46.357] result() for ClusterFuture ... done
[16:18:46.357] result() for ClusterFuture ...
[16:18:46.358] - result already collected: FutureResult
[16:18:46.358] result() for ClusterFuture ... done
[16:18:46.358] - relayed: [n=1] TRUE
[16:18:46.358] - queued futures: [n=1] TRUE
[16:18:46.358] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:46.358]  length: 0 (resolved future 1)
[16:18:46.358] Relaying remaining futures
[16:18:46.358] signalConditionsASAP(NULL, pos=0) ...
[16:18:46.358] - nx: 1
[16:18:46.358] - relay: TRUE
[16:18:46.358] - stdout: TRUE
[16:18:46.359] - signal: TRUE
[16:18:46.359] - resignal: FALSE
[16:18:46.359] - force: TRUE
[16:18:46.359] - relayed: [n=1] TRUE
[16:18:46.359] - queued futures: [n=1] TRUE
 - flush all
[16:18:46.359] - relayed: [n=1] TRUE
[16:18:46.359] - queued futures: [n=1] TRUE
[16:18:46.359] signalConditionsASAP(NULL, pos=0) ... done
[16:18:46.359] resolve() on list ... DONE
[16:18:46.359] result() for ClusterFuture ...
[16:18:46.359] - result already collected: FutureResult
[16:18:46.360] result() for ClusterFuture ... done
[16:18:46.360] result() for ClusterFuture ...
[16:18:46.360] - result already collected: FutureResult
[16:18:46.360] result() for ClusterFuture ... done
[16:18:46.360]  - Number of value chunks collected: 1
[16:18:46.360] Resolving 1 futures (chunks) ... DONE
[16:18:46.360] Reducing values from 1 chunks ...
[16:18:46.360]  - Number of values collected after concatenation: 1
[16:18:46.360]  - Number of values expected: 1
[16:18:46.360] Reducing values from 1 chunks ... DONE
[16:18:46.360] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[16:18:46.361] future_mapply() ...
[16:18:46.365] Number of chunks: 2
[16:18:46.365] getGlobalsAndPackagesXApply() ...
[16:18:46.365]  - future.globals: TRUE
[16:18:46.365] getGlobalsAndPackages() ...
[16:18:46.365] Searching for globals...
[16:18:46.366] - globals found: [1] ‘FUN’
[16:18:46.366] Searching for globals ... DONE
[16:18:46.366] Resolving globals: FALSE
[16:18:46.367] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[16:18:46.367] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[16:18:46.367] - globals: [1] ‘FUN’
[16:18:46.367] 
[16:18:46.367] getGlobalsAndPackages() ... DONE
[16:18:46.367]  - globals found/used: [n=1] ‘FUN’
[16:18:46.367]  - needed namespaces: [n=0] 
[16:18:46.368] Finding globals ... DONE
[16:18:46.368] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:46.368] List of 2
[16:18:46.368]  $ ...future.FUN:function (x, y)  
[16:18:46.368]  $ MoreArgs     :List of 1
[16:18:46.368]   ..$ y: int [1:2] 3 4
[16:18:46.368]  - attr(*, "where")=List of 2
[16:18:46.368]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:46.368]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:46.368]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:46.368]  - attr(*, "resolved")= logi FALSE
[16:18:46.368]  - attr(*, "total_size")= num NA
[16:18:46.371] Packages to be attached in all futures: [n=0] 
[16:18:46.371] getGlobalsAndPackagesXApply() ... DONE
[16:18:46.371] Number of futures (= number of chunks): 2
[16:18:46.371] Launching 2 futures (chunks) ...
[16:18:46.371] Chunk #1 of 2 ...
[16:18:46.371]  - Finding globals in '...' for chunk #1 ...
[16:18:46.372] getGlobalsAndPackages() ...
[16:18:46.372] Searching for globals...
[16:18:46.372] 
[16:18:46.372] Searching for globals ... DONE
[16:18:46.372] - globals: [0] <none>
[16:18:46.372] getGlobalsAndPackages() ... DONE
[16:18:46.372]    + additional globals found: [n=0] 
[16:18:46.372]    + additional namespaces needed: [n=0] 
[16:18:46.372]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:46.373]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.373]  - seeds: <none>
[16:18:46.373]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.373] getGlobalsAndPackages() ...
[16:18:46.373] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.373] Resolving globals: FALSE
[16:18:46.374] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[16:18:46.374] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[16:18:46.374] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.374] 
[16:18:46.374] getGlobalsAndPackages() ... DONE
[16:18:46.375] run() for ‘Future’ ...
[16:18:46.375] - state: ‘created’
[16:18:46.375] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.389] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.389]   - Field: ‘node’
[16:18:46.389]   - Field: ‘label’
[16:18:46.389]   - Field: ‘local’
[16:18:46.389]   - Field: ‘owner’
[16:18:46.390]   - Field: ‘envir’
[16:18:46.390]   - Field: ‘workers’
[16:18:46.390]   - Field: ‘packages’
[16:18:46.390]   - Field: ‘gc’
[16:18:46.390]   - Field: ‘conditions’
[16:18:46.390]   - Field: ‘persistent’
[16:18:46.390]   - Field: ‘expr’
[16:18:46.390]   - Field: ‘uuid’
[16:18:46.390]   - Field: ‘seed’
[16:18:46.390]   - Field: ‘version’
[16:18:46.390]   - Field: ‘result’
[16:18:46.391]   - Field: ‘asynchronous’
[16:18:46.391]   - Field: ‘calls’
[16:18:46.391]   - Field: ‘globals’
[16:18:46.391]   - Field: ‘stdout’
[16:18:46.391]   - Field: ‘earlySignal’
[16:18:46.391]   - Field: ‘lazy’
[16:18:46.391]   - Field: ‘state’
[16:18:46.391] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.391] - Launch lazy future ...
[16:18:46.392] Packages needed by the future expression (n = 0): <none>
[16:18:46.392] Packages needed by future strategies (n = 0): <none>
[16:18:46.392] {
[16:18:46.392]     {
[16:18:46.392]         {
[16:18:46.392]             ...future.startTime <- base::Sys.time()
[16:18:46.392]             {
[16:18:46.392]                 {
[16:18:46.392]                   {
[16:18:46.392]                     {
[16:18:46.392]                       base::local({
[16:18:46.392]                         has_future <- base::requireNamespace("future", 
[16:18:46.392]                           quietly = TRUE)
[16:18:46.392]                         if (has_future) {
[16:18:46.392]                           ns <- base::getNamespace("future")
[16:18:46.392]                           version <- ns[[".package"]][["version"]]
[16:18:46.392]                           if (is.null(version)) 
[16:18:46.392]                             version <- utils::packageVersion("future")
[16:18:46.392]                         }
[16:18:46.392]                         else {
[16:18:46.392]                           version <- NULL
[16:18:46.392]                         }
[16:18:46.392]                         if (!has_future || version < "1.8.0") {
[16:18:46.392]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.392]                             "", base::R.version$version.string), 
[16:18:46.392]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.392]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.392]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.392]                               "release", "version")], collapse = " "), 
[16:18:46.392]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.392]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.392]                             info)
[16:18:46.392]                           info <- base::paste(info, collapse = "; ")
[16:18:46.392]                           if (!has_future) {
[16:18:46.392]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.392]                               info)
[16:18:46.392]                           }
[16:18:46.392]                           else {
[16:18:46.392]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.392]                               info, version)
[16:18:46.392]                           }
[16:18:46.392]                           base::stop(msg)
[16:18:46.392]                         }
[16:18:46.392]                       })
[16:18:46.392]                     }
[16:18:46.392]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.392]                     base::options(mc.cores = 1L)
[16:18:46.392]                   }
[16:18:46.392]                   ...future.strategy.old <- future::plan("list")
[16:18:46.392]                   options(future.plan = NULL)
[16:18:46.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.392]                 }
[16:18:46.392]                 ...future.workdir <- getwd()
[16:18:46.392]             }
[16:18:46.392]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.392]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.392]         }
[16:18:46.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.392]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.392]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.392]             base::names(...future.oldOptions))
[16:18:46.392]     }
[16:18:46.392]     if (FALSE) {
[16:18:46.392]     }
[16:18:46.392]     else {
[16:18:46.392]         if (TRUE) {
[16:18:46.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.392]                 open = "w")
[16:18:46.392]         }
[16:18:46.392]         else {
[16:18:46.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.392]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.392]         }
[16:18:46.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.392]             base::sink(type = "output", split = FALSE)
[16:18:46.392]             base::close(...future.stdout)
[16:18:46.392]         }, add = TRUE)
[16:18:46.392]     }
[16:18:46.392]     ...future.frame <- base::sys.nframe()
[16:18:46.392]     ...future.conditions <- base::list()
[16:18:46.392]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.392]     if (FALSE) {
[16:18:46.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.392]     }
[16:18:46.392]     ...future.result <- base::tryCatch({
[16:18:46.392]         base::withCallingHandlers({
[16:18:46.392]             ...future.value <- base::withVisible(base::local({
[16:18:46.392]                 ...future.makeSendCondition <- base::local({
[16:18:46.392]                   sendCondition <- NULL
[16:18:46.392]                   function(frame = 1L) {
[16:18:46.392]                     if (is.function(sendCondition)) 
[16:18:46.392]                       return(sendCondition)
[16:18:46.392]                     ns <- getNamespace("parallel")
[16:18:46.392]                     if (exists("sendData", mode = "function", 
[16:18:46.392]                       envir = ns)) {
[16:18:46.392]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.392]                         envir = ns)
[16:18:46.392]                       envir <- sys.frame(frame)
[16:18:46.392]                       master <- NULL
[16:18:46.392]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.392]                         !identical(envir, emptyenv())) {
[16:18:46.392]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.392]                           inherits = FALSE)) {
[16:18:46.392]                           master <- get("master", mode = "list", 
[16:18:46.392]                             envir = envir, inherits = FALSE)
[16:18:46.392]                           if (inherits(master, c("SOCKnode", 
[16:18:46.392]                             "SOCK0node"))) {
[16:18:46.392]                             sendCondition <<- function(cond) {
[16:18:46.392]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.392]                                 success = TRUE)
[16:18:46.392]                               parallel_sendData(master, data)
[16:18:46.392]                             }
[16:18:46.392]                             return(sendCondition)
[16:18:46.392]                           }
[16:18:46.392]                         }
[16:18:46.392]                         frame <- frame + 1L
[16:18:46.392]                         envir <- sys.frame(frame)
[16:18:46.392]                       }
[16:18:46.392]                     }
[16:18:46.392]                     sendCondition <<- function(cond) NULL
[16:18:46.392]                   }
[16:18:46.392]                 })
[16:18:46.392]                 withCallingHandlers({
[16:18:46.392]                   {
[16:18:46.392]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.392]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.392]                       ...future.globals.maxSize)) {
[16:18:46.392]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.392]                       on.exit(options(oopts), add = TRUE)
[16:18:46.392]                     }
[16:18:46.392]                     {
[16:18:46.392]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.392]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.392]                         USE.NAMES = FALSE)
[16:18:46.392]                       do.call(mapply, args = args)
[16:18:46.392]                     }
[16:18:46.392]                   }
[16:18:46.392]                 }, immediateCondition = function(cond) {
[16:18:46.392]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.392]                   sendCondition(cond)
[16:18:46.392]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.392]                   {
[16:18:46.392]                     inherits <- base::inherits
[16:18:46.392]                     invokeRestart <- base::invokeRestart
[16:18:46.392]                     is.null <- base::is.null
[16:18:46.392]                     muffled <- FALSE
[16:18:46.392]                     if (inherits(cond, "message")) {
[16:18:46.392]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.392]                       if (muffled) 
[16:18:46.392]                         invokeRestart("muffleMessage")
[16:18:46.392]                     }
[16:18:46.392]                     else if (inherits(cond, "warning")) {
[16:18:46.392]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.392]                       if (muffled) 
[16:18:46.392]                         invokeRestart("muffleWarning")
[16:18:46.392]                     }
[16:18:46.392]                     else if (inherits(cond, "condition")) {
[16:18:46.392]                       if (!is.null(pattern)) {
[16:18:46.392]                         computeRestarts <- base::computeRestarts
[16:18:46.392]                         grepl <- base::grepl
[16:18:46.392]                         restarts <- computeRestarts(cond)
[16:18:46.392]                         for (restart in restarts) {
[16:18:46.392]                           name <- restart$name
[16:18:46.392]                           if (is.null(name)) 
[16:18:46.392]                             next
[16:18:46.392]                           if (!grepl(pattern, name)) 
[16:18:46.392]                             next
[16:18:46.392]                           invokeRestart(restart)
[16:18:46.392]                           muffled <- TRUE
[16:18:46.392]                           break
[16:18:46.392]                         }
[16:18:46.392]                       }
[16:18:46.392]                     }
[16:18:46.392]                     invisible(muffled)
[16:18:46.392]                   }
[16:18:46.392]                   muffleCondition(cond)
[16:18:46.392]                 })
[16:18:46.392]             }))
[16:18:46.392]             future::FutureResult(value = ...future.value$value, 
[16:18:46.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.392]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.392]                     ...future.globalenv.names))
[16:18:46.392]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.392]         }, condition = base::local({
[16:18:46.392]             c <- base::c
[16:18:46.392]             inherits <- base::inherits
[16:18:46.392]             invokeRestart <- base::invokeRestart
[16:18:46.392]             length <- base::length
[16:18:46.392]             list <- base::list
[16:18:46.392]             seq.int <- base::seq.int
[16:18:46.392]             signalCondition <- base::signalCondition
[16:18:46.392]             sys.calls <- base::sys.calls
[16:18:46.392]             `[[` <- base::`[[`
[16:18:46.392]             `+` <- base::`+`
[16:18:46.392]             `<<-` <- base::`<<-`
[16:18:46.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.392]                   3L)]
[16:18:46.392]             }
[16:18:46.392]             function(cond) {
[16:18:46.392]                 is_error <- inherits(cond, "error")
[16:18:46.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.392]                   NULL)
[16:18:46.392]                 if (is_error) {
[16:18:46.392]                   sessionInformation <- function() {
[16:18:46.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.392]                       search = base::search(), system = base::Sys.info())
[16:18:46.392]                   }
[16:18:46.392]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.392]                     cond$call), session = sessionInformation(), 
[16:18:46.392]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.392]                   signalCondition(cond)
[16:18:46.392]                 }
[16:18:46.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.392]                 "immediateCondition"))) {
[16:18:46.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.392]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.392]                   if (TRUE && !signal) {
[16:18:46.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.392]                     {
[16:18:46.392]                       inherits <- base::inherits
[16:18:46.392]                       invokeRestart <- base::invokeRestart
[16:18:46.392]                       is.null <- base::is.null
[16:18:46.392]                       muffled <- FALSE
[16:18:46.392]                       if (inherits(cond, "message")) {
[16:18:46.392]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.392]                         if (muffled) 
[16:18:46.392]                           invokeRestart("muffleMessage")
[16:18:46.392]                       }
[16:18:46.392]                       else if (inherits(cond, "warning")) {
[16:18:46.392]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.392]                         if (muffled) 
[16:18:46.392]                           invokeRestart("muffleWarning")
[16:18:46.392]                       }
[16:18:46.392]                       else if (inherits(cond, "condition")) {
[16:18:46.392]                         if (!is.null(pattern)) {
[16:18:46.392]                           computeRestarts <- base::computeRestarts
[16:18:46.392]                           grepl <- base::grepl
[16:18:46.392]                           restarts <- computeRestarts(cond)
[16:18:46.392]                           for (restart in restarts) {
[16:18:46.392]                             name <- restart$name
[16:18:46.392]                             if (is.null(name)) 
[16:18:46.392]                               next
[16:18:46.392]                             if (!grepl(pattern, name)) 
[16:18:46.392]                               next
[16:18:46.392]                             invokeRestart(restart)
[16:18:46.392]                             muffled <- TRUE
[16:18:46.392]                             break
[16:18:46.392]                           }
[16:18:46.392]                         }
[16:18:46.392]                       }
[16:18:46.392]                       invisible(muffled)
[16:18:46.392]                     }
[16:18:46.392]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.392]                   }
[16:18:46.392]                 }
[16:18:46.392]                 else {
[16:18:46.392]                   if (TRUE) {
[16:18:46.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.392]                     {
[16:18:46.392]                       inherits <- base::inherits
[16:18:46.392]                       invokeRestart <- base::invokeRestart
[16:18:46.392]                       is.null <- base::is.null
[16:18:46.392]                       muffled <- FALSE
[16:18:46.392]                       if (inherits(cond, "message")) {
[16:18:46.392]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.392]                         if (muffled) 
[16:18:46.392]                           invokeRestart("muffleMessage")
[16:18:46.392]                       }
[16:18:46.392]                       else if (inherits(cond, "warning")) {
[16:18:46.392]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.392]                         if (muffled) 
[16:18:46.392]                           invokeRestart("muffleWarning")
[16:18:46.392]                       }
[16:18:46.392]                       else if (inherits(cond, "condition")) {
[16:18:46.392]                         if (!is.null(pattern)) {
[16:18:46.392]                           computeRestarts <- base::computeRestarts
[16:18:46.392]                           grepl <- base::grepl
[16:18:46.392]                           restarts <- computeRestarts(cond)
[16:18:46.392]                           for (restart in restarts) {
[16:18:46.392]                             name <- restart$name
[16:18:46.392]                             if (is.null(name)) 
[16:18:46.392]                               next
[16:18:46.392]                             if (!grepl(pattern, name)) 
[16:18:46.392]                               next
[16:18:46.392]                             invokeRestart(restart)
[16:18:46.392]                             muffled <- TRUE
[16:18:46.392]                             break
[16:18:46.392]                           }
[16:18:46.392]                         }
[16:18:46.392]                       }
[16:18:46.392]                       invisible(muffled)
[16:18:46.392]                     }
[16:18:46.392]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.392]                   }
[16:18:46.392]                 }
[16:18:46.392]             }
[16:18:46.392]         }))
[16:18:46.392]     }, error = function(ex) {
[16:18:46.392]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.392]                 ...future.rng), started = ...future.startTime, 
[16:18:46.392]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.392]             version = "1.8"), class = "FutureResult")
[16:18:46.392]     }, finally = {
[16:18:46.392]         if (!identical(...future.workdir, getwd())) 
[16:18:46.392]             setwd(...future.workdir)
[16:18:46.392]         {
[16:18:46.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.392]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.392]             }
[16:18:46.392]             base::options(...future.oldOptions)
[16:18:46.392]             if (.Platform$OS.type == "windows") {
[16:18:46.392]                 old_names <- names(...future.oldEnvVars)
[16:18:46.392]                 envs <- base::Sys.getenv()
[16:18:46.392]                 names <- names(envs)
[16:18:46.392]                 common <- intersect(names, old_names)
[16:18:46.392]                 added <- setdiff(names, old_names)
[16:18:46.392]                 removed <- setdiff(old_names, names)
[16:18:46.392]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.392]                   envs[common]]
[16:18:46.392]                 NAMES <- toupper(changed)
[16:18:46.392]                 args <- list()
[16:18:46.392]                 for (kk in seq_along(NAMES)) {
[16:18:46.392]                   name <- changed[[kk]]
[16:18:46.392]                   NAME <- NAMES[[kk]]
[16:18:46.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.392]                     next
[16:18:46.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.392]                 }
[16:18:46.392]                 NAMES <- toupper(added)
[16:18:46.392]                 for (kk in seq_along(NAMES)) {
[16:18:46.392]                   name <- added[[kk]]
[16:18:46.392]                   NAME <- NAMES[[kk]]
[16:18:46.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.392]                     next
[16:18:46.392]                   args[[name]] <- ""
[16:18:46.392]                 }
[16:18:46.392]                 NAMES <- toupper(removed)
[16:18:46.392]                 for (kk in seq_along(NAMES)) {
[16:18:46.392]                   name <- removed[[kk]]
[16:18:46.392]                   NAME <- NAMES[[kk]]
[16:18:46.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.392]                     next
[16:18:46.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.392]                 }
[16:18:46.392]                 if (length(args) > 0) 
[16:18:46.392]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.392]             }
[16:18:46.392]             else {
[16:18:46.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.392]             }
[16:18:46.392]             {
[16:18:46.392]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.392]                   0L) {
[16:18:46.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.392]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.392]                   base::options(opts)
[16:18:46.392]                 }
[16:18:46.392]                 {
[16:18:46.392]                   {
[16:18:46.392]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.392]                     NULL
[16:18:46.392]                   }
[16:18:46.392]                   options(future.plan = NULL)
[16:18:46.392]                   if (is.na(NA_character_)) 
[16:18:46.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.392]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.392]                     .init = FALSE)
[16:18:46.392]                 }
[16:18:46.392]             }
[16:18:46.392]         }
[16:18:46.392]     })
[16:18:46.392]     if (TRUE) {
[16:18:46.392]         base::sink(type = "output", split = FALSE)
[16:18:46.392]         if (TRUE) {
[16:18:46.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.392]         }
[16:18:46.392]         else {
[16:18:46.392]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.392]         }
[16:18:46.392]         base::close(...future.stdout)
[16:18:46.392]         ...future.stdout <- NULL
[16:18:46.392]     }
[16:18:46.392]     ...future.result$conditions <- ...future.conditions
[16:18:46.392]     ...future.result$finished <- base::Sys.time()
[16:18:46.392]     ...future.result
[16:18:46.392] }
[16:18:46.395] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[16:18:46.395] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[16:18:46.395] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[16:18:46.395] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[16:18:46.396] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[16:18:46.396] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:18:46.396] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:18:46.396] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:46.397] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.397] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:46.397] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.397] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[16:18:46.400] MultisessionFuture started
[16:18:46.401] - Launch lazy future ... done
[16:18:46.401] run() for ‘MultisessionFuture’ ... done
[16:18:46.401] Created future:
[16:18:46.401] MultisessionFuture:
[16:18:46.401] Label: ‘future_mapply-1’
[16:18:46.401] Expression:
[16:18:46.401] {
[16:18:46.401]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.401]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.401]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.401]         on.exit(options(oopts), add = TRUE)
[16:18:46.401]     }
[16:18:46.401]     {
[16:18:46.401]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.401]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.401]         do.call(mapply, args = args)
[16:18:46.401]     }
[16:18:46.401] }
[16:18:46.401] Lazy evaluation: FALSE
[16:18:46.401] Asynchronous evaluation: TRUE
[16:18:46.401] Local evaluation: TRUE
[16:18:46.401] Environment: R_GlobalEnv
[16:18:46.401] Capture standard output: TRUE
[16:18:46.401] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.401] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.401] Packages: <none>
[16:18:46.401] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:46.401] Resolved: FALSE
[16:18:46.401] Value: <not collected>
[16:18:46.401] Conditions captured: <none>
[16:18:46.401] Early signaling: FALSE
[16:18:46.401] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.401] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.412] Chunk #1 of 2 ... DONE
[16:18:46.412] Chunk #2 of 2 ...
[16:18:46.413]  - Finding globals in '...' for chunk #2 ...
[16:18:46.413] getGlobalsAndPackages() ...
[16:18:46.413] Searching for globals...
[16:18:46.413] 
[16:18:46.413] Searching for globals ... DONE
[16:18:46.413] - globals: [0] <none>
[16:18:46.413] getGlobalsAndPackages() ... DONE
[16:18:46.413]    + additional globals found: [n=0] 
[16:18:46.413]    + additional namespaces needed: [n=0] 
[16:18:46.414]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:46.414]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.414]  - seeds: <none>
[16:18:46.414]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.414] getGlobalsAndPackages() ...
[16:18:46.414] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.414] Resolving globals: FALSE
[16:18:46.415] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[16:18:46.415] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[16:18:46.415] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.415] 
[16:18:46.415] getGlobalsAndPackages() ... DONE
[16:18:46.416] run() for ‘Future’ ...
[16:18:46.416] - state: ‘created’
[16:18:46.416] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.429] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.429]   - Field: ‘node’
[16:18:46.429]   - Field: ‘label’
[16:18:46.429]   - Field: ‘local’
[16:18:46.429]   - Field: ‘owner’
[16:18:46.430]   - Field: ‘envir’
[16:18:46.430]   - Field: ‘workers’
[16:18:46.430]   - Field: ‘packages’
[16:18:46.430]   - Field: ‘gc’
[16:18:46.430]   - Field: ‘conditions’
[16:18:46.430]   - Field: ‘persistent’
[16:18:46.430]   - Field: ‘expr’
[16:18:46.430]   - Field: ‘uuid’
[16:18:46.430]   - Field: ‘seed’
[16:18:46.430]   - Field: ‘version’
[16:18:46.430]   - Field: ‘result’
[16:18:46.431]   - Field: ‘asynchronous’
[16:18:46.431]   - Field: ‘calls’
[16:18:46.431]   - Field: ‘globals’
[16:18:46.431]   - Field: ‘stdout’
[16:18:46.431]   - Field: ‘earlySignal’
[16:18:46.431]   - Field: ‘lazy’
[16:18:46.431]   - Field: ‘state’
[16:18:46.431] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.431] - Launch lazy future ...
[16:18:46.431] Packages needed by the future expression (n = 0): <none>
[16:18:46.432] Packages needed by future strategies (n = 0): <none>
[16:18:46.432] {
[16:18:46.432]     {
[16:18:46.432]         {
[16:18:46.432]             ...future.startTime <- base::Sys.time()
[16:18:46.432]             {
[16:18:46.432]                 {
[16:18:46.432]                   {
[16:18:46.432]                     {
[16:18:46.432]                       base::local({
[16:18:46.432]                         has_future <- base::requireNamespace("future", 
[16:18:46.432]                           quietly = TRUE)
[16:18:46.432]                         if (has_future) {
[16:18:46.432]                           ns <- base::getNamespace("future")
[16:18:46.432]                           version <- ns[[".package"]][["version"]]
[16:18:46.432]                           if (is.null(version)) 
[16:18:46.432]                             version <- utils::packageVersion("future")
[16:18:46.432]                         }
[16:18:46.432]                         else {
[16:18:46.432]                           version <- NULL
[16:18:46.432]                         }
[16:18:46.432]                         if (!has_future || version < "1.8.0") {
[16:18:46.432]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.432]                             "", base::R.version$version.string), 
[16:18:46.432]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.432]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.432]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.432]                               "release", "version")], collapse = " "), 
[16:18:46.432]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.432]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.432]                             info)
[16:18:46.432]                           info <- base::paste(info, collapse = "; ")
[16:18:46.432]                           if (!has_future) {
[16:18:46.432]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.432]                               info)
[16:18:46.432]                           }
[16:18:46.432]                           else {
[16:18:46.432]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.432]                               info, version)
[16:18:46.432]                           }
[16:18:46.432]                           base::stop(msg)
[16:18:46.432]                         }
[16:18:46.432]                       })
[16:18:46.432]                     }
[16:18:46.432]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.432]                     base::options(mc.cores = 1L)
[16:18:46.432]                   }
[16:18:46.432]                   ...future.strategy.old <- future::plan("list")
[16:18:46.432]                   options(future.plan = NULL)
[16:18:46.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.432]                 }
[16:18:46.432]                 ...future.workdir <- getwd()
[16:18:46.432]             }
[16:18:46.432]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.432]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.432]         }
[16:18:46.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.432]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.432]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.432]             base::names(...future.oldOptions))
[16:18:46.432]     }
[16:18:46.432]     if (FALSE) {
[16:18:46.432]     }
[16:18:46.432]     else {
[16:18:46.432]         if (TRUE) {
[16:18:46.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.432]                 open = "w")
[16:18:46.432]         }
[16:18:46.432]         else {
[16:18:46.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.432]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.432]         }
[16:18:46.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.432]             base::sink(type = "output", split = FALSE)
[16:18:46.432]             base::close(...future.stdout)
[16:18:46.432]         }, add = TRUE)
[16:18:46.432]     }
[16:18:46.432]     ...future.frame <- base::sys.nframe()
[16:18:46.432]     ...future.conditions <- base::list()
[16:18:46.432]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.432]     if (FALSE) {
[16:18:46.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.432]     }
[16:18:46.432]     ...future.result <- base::tryCatch({
[16:18:46.432]         base::withCallingHandlers({
[16:18:46.432]             ...future.value <- base::withVisible(base::local({
[16:18:46.432]                 ...future.makeSendCondition <- base::local({
[16:18:46.432]                   sendCondition <- NULL
[16:18:46.432]                   function(frame = 1L) {
[16:18:46.432]                     if (is.function(sendCondition)) 
[16:18:46.432]                       return(sendCondition)
[16:18:46.432]                     ns <- getNamespace("parallel")
[16:18:46.432]                     if (exists("sendData", mode = "function", 
[16:18:46.432]                       envir = ns)) {
[16:18:46.432]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.432]                         envir = ns)
[16:18:46.432]                       envir <- sys.frame(frame)
[16:18:46.432]                       master <- NULL
[16:18:46.432]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.432]                         !identical(envir, emptyenv())) {
[16:18:46.432]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.432]                           inherits = FALSE)) {
[16:18:46.432]                           master <- get("master", mode = "list", 
[16:18:46.432]                             envir = envir, inherits = FALSE)
[16:18:46.432]                           if (inherits(master, c("SOCKnode", 
[16:18:46.432]                             "SOCK0node"))) {
[16:18:46.432]                             sendCondition <<- function(cond) {
[16:18:46.432]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.432]                                 success = TRUE)
[16:18:46.432]                               parallel_sendData(master, data)
[16:18:46.432]                             }
[16:18:46.432]                             return(sendCondition)
[16:18:46.432]                           }
[16:18:46.432]                         }
[16:18:46.432]                         frame <- frame + 1L
[16:18:46.432]                         envir <- sys.frame(frame)
[16:18:46.432]                       }
[16:18:46.432]                     }
[16:18:46.432]                     sendCondition <<- function(cond) NULL
[16:18:46.432]                   }
[16:18:46.432]                 })
[16:18:46.432]                 withCallingHandlers({
[16:18:46.432]                   {
[16:18:46.432]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.432]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.432]                       ...future.globals.maxSize)) {
[16:18:46.432]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.432]                       on.exit(options(oopts), add = TRUE)
[16:18:46.432]                     }
[16:18:46.432]                     {
[16:18:46.432]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.432]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.432]                         USE.NAMES = FALSE)
[16:18:46.432]                       do.call(mapply, args = args)
[16:18:46.432]                     }
[16:18:46.432]                   }
[16:18:46.432]                 }, immediateCondition = function(cond) {
[16:18:46.432]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.432]                   sendCondition(cond)
[16:18:46.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.432]                   {
[16:18:46.432]                     inherits <- base::inherits
[16:18:46.432]                     invokeRestart <- base::invokeRestart
[16:18:46.432]                     is.null <- base::is.null
[16:18:46.432]                     muffled <- FALSE
[16:18:46.432]                     if (inherits(cond, "message")) {
[16:18:46.432]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.432]                       if (muffled) 
[16:18:46.432]                         invokeRestart("muffleMessage")
[16:18:46.432]                     }
[16:18:46.432]                     else if (inherits(cond, "warning")) {
[16:18:46.432]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.432]                       if (muffled) 
[16:18:46.432]                         invokeRestart("muffleWarning")
[16:18:46.432]                     }
[16:18:46.432]                     else if (inherits(cond, "condition")) {
[16:18:46.432]                       if (!is.null(pattern)) {
[16:18:46.432]                         computeRestarts <- base::computeRestarts
[16:18:46.432]                         grepl <- base::grepl
[16:18:46.432]                         restarts <- computeRestarts(cond)
[16:18:46.432]                         for (restart in restarts) {
[16:18:46.432]                           name <- restart$name
[16:18:46.432]                           if (is.null(name)) 
[16:18:46.432]                             next
[16:18:46.432]                           if (!grepl(pattern, name)) 
[16:18:46.432]                             next
[16:18:46.432]                           invokeRestart(restart)
[16:18:46.432]                           muffled <- TRUE
[16:18:46.432]                           break
[16:18:46.432]                         }
[16:18:46.432]                       }
[16:18:46.432]                     }
[16:18:46.432]                     invisible(muffled)
[16:18:46.432]                   }
[16:18:46.432]                   muffleCondition(cond)
[16:18:46.432]                 })
[16:18:46.432]             }))
[16:18:46.432]             future::FutureResult(value = ...future.value$value, 
[16:18:46.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.432]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.432]                     ...future.globalenv.names))
[16:18:46.432]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.432]         }, condition = base::local({
[16:18:46.432]             c <- base::c
[16:18:46.432]             inherits <- base::inherits
[16:18:46.432]             invokeRestart <- base::invokeRestart
[16:18:46.432]             length <- base::length
[16:18:46.432]             list <- base::list
[16:18:46.432]             seq.int <- base::seq.int
[16:18:46.432]             signalCondition <- base::signalCondition
[16:18:46.432]             sys.calls <- base::sys.calls
[16:18:46.432]             `[[` <- base::`[[`
[16:18:46.432]             `+` <- base::`+`
[16:18:46.432]             `<<-` <- base::`<<-`
[16:18:46.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.432]                   3L)]
[16:18:46.432]             }
[16:18:46.432]             function(cond) {
[16:18:46.432]                 is_error <- inherits(cond, "error")
[16:18:46.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.432]                   NULL)
[16:18:46.432]                 if (is_error) {
[16:18:46.432]                   sessionInformation <- function() {
[16:18:46.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.432]                       search = base::search(), system = base::Sys.info())
[16:18:46.432]                   }
[16:18:46.432]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.432]                     cond$call), session = sessionInformation(), 
[16:18:46.432]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.432]                   signalCondition(cond)
[16:18:46.432]                 }
[16:18:46.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.432]                 "immediateCondition"))) {
[16:18:46.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.432]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.432]                   if (TRUE && !signal) {
[16:18:46.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.432]                     {
[16:18:46.432]                       inherits <- base::inherits
[16:18:46.432]                       invokeRestart <- base::invokeRestart
[16:18:46.432]                       is.null <- base::is.null
[16:18:46.432]                       muffled <- FALSE
[16:18:46.432]                       if (inherits(cond, "message")) {
[16:18:46.432]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.432]                         if (muffled) 
[16:18:46.432]                           invokeRestart("muffleMessage")
[16:18:46.432]                       }
[16:18:46.432]                       else if (inherits(cond, "warning")) {
[16:18:46.432]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.432]                         if (muffled) 
[16:18:46.432]                           invokeRestart("muffleWarning")
[16:18:46.432]                       }
[16:18:46.432]                       else if (inherits(cond, "condition")) {
[16:18:46.432]                         if (!is.null(pattern)) {
[16:18:46.432]                           computeRestarts <- base::computeRestarts
[16:18:46.432]                           grepl <- base::grepl
[16:18:46.432]                           restarts <- computeRestarts(cond)
[16:18:46.432]                           for (restart in restarts) {
[16:18:46.432]                             name <- restart$name
[16:18:46.432]                             if (is.null(name)) 
[16:18:46.432]                               next
[16:18:46.432]                             if (!grepl(pattern, name)) 
[16:18:46.432]                               next
[16:18:46.432]                             invokeRestart(restart)
[16:18:46.432]                             muffled <- TRUE
[16:18:46.432]                             break
[16:18:46.432]                           }
[16:18:46.432]                         }
[16:18:46.432]                       }
[16:18:46.432]                       invisible(muffled)
[16:18:46.432]                     }
[16:18:46.432]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.432]                   }
[16:18:46.432]                 }
[16:18:46.432]                 else {
[16:18:46.432]                   if (TRUE) {
[16:18:46.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.432]                     {
[16:18:46.432]                       inherits <- base::inherits
[16:18:46.432]                       invokeRestart <- base::invokeRestart
[16:18:46.432]                       is.null <- base::is.null
[16:18:46.432]                       muffled <- FALSE
[16:18:46.432]                       if (inherits(cond, "message")) {
[16:18:46.432]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.432]                         if (muffled) 
[16:18:46.432]                           invokeRestart("muffleMessage")
[16:18:46.432]                       }
[16:18:46.432]                       else if (inherits(cond, "warning")) {
[16:18:46.432]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.432]                         if (muffled) 
[16:18:46.432]                           invokeRestart("muffleWarning")
[16:18:46.432]                       }
[16:18:46.432]                       else if (inherits(cond, "condition")) {
[16:18:46.432]                         if (!is.null(pattern)) {
[16:18:46.432]                           computeRestarts <- base::computeRestarts
[16:18:46.432]                           grepl <- base::grepl
[16:18:46.432]                           restarts <- computeRestarts(cond)
[16:18:46.432]                           for (restart in restarts) {
[16:18:46.432]                             name <- restart$name
[16:18:46.432]                             if (is.null(name)) 
[16:18:46.432]                               next
[16:18:46.432]                             if (!grepl(pattern, name)) 
[16:18:46.432]                               next
[16:18:46.432]                             invokeRestart(restart)
[16:18:46.432]                             muffled <- TRUE
[16:18:46.432]                             break
[16:18:46.432]                           }
[16:18:46.432]                         }
[16:18:46.432]                       }
[16:18:46.432]                       invisible(muffled)
[16:18:46.432]                     }
[16:18:46.432]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.432]                   }
[16:18:46.432]                 }
[16:18:46.432]             }
[16:18:46.432]         }))
[16:18:46.432]     }, error = function(ex) {
[16:18:46.432]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.432]                 ...future.rng), started = ...future.startTime, 
[16:18:46.432]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.432]             version = "1.8"), class = "FutureResult")
[16:18:46.432]     }, finally = {
[16:18:46.432]         if (!identical(...future.workdir, getwd())) 
[16:18:46.432]             setwd(...future.workdir)
[16:18:46.432]         {
[16:18:46.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.432]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.432]             }
[16:18:46.432]             base::options(...future.oldOptions)
[16:18:46.432]             if (.Platform$OS.type == "windows") {
[16:18:46.432]                 old_names <- names(...future.oldEnvVars)
[16:18:46.432]                 envs <- base::Sys.getenv()
[16:18:46.432]                 names <- names(envs)
[16:18:46.432]                 common <- intersect(names, old_names)
[16:18:46.432]                 added <- setdiff(names, old_names)
[16:18:46.432]                 removed <- setdiff(old_names, names)
[16:18:46.432]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.432]                   envs[common]]
[16:18:46.432]                 NAMES <- toupper(changed)
[16:18:46.432]                 args <- list()
[16:18:46.432]                 for (kk in seq_along(NAMES)) {
[16:18:46.432]                   name <- changed[[kk]]
[16:18:46.432]                   NAME <- NAMES[[kk]]
[16:18:46.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.432]                     next
[16:18:46.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.432]                 }
[16:18:46.432]                 NAMES <- toupper(added)
[16:18:46.432]                 for (kk in seq_along(NAMES)) {
[16:18:46.432]                   name <- added[[kk]]
[16:18:46.432]                   NAME <- NAMES[[kk]]
[16:18:46.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.432]                     next
[16:18:46.432]                   args[[name]] <- ""
[16:18:46.432]                 }
[16:18:46.432]                 NAMES <- toupper(removed)
[16:18:46.432]                 for (kk in seq_along(NAMES)) {
[16:18:46.432]                   name <- removed[[kk]]
[16:18:46.432]                   NAME <- NAMES[[kk]]
[16:18:46.432]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.432]                     next
[16:18:46.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.432]                 }
[16:18:46.432]                 if (length(args) > 0) 
[16:18:46.432]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.432]             }
[16:18:46.432]             else {
[16:18:46.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.432]             }
[16:18:46.432]             {
[16:18:46.432]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.432]                   0L) {
[16:18:46.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.432]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.432]                   base::options(opts)
[16:18:46.432]                 }
[16:18:46.432]                 {
[16:18:46.432]                   {
[16:18:46.432]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.432]                     NULL
[16:18:46.432]                   }
[16:18:46.432]                   options(future.plan = NULL)
[16:18:46.432]                   if (is.na(NA_character_)) 
[16:18:46.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.432]                     .init = FALSE)
[16:18:46.432]                 }
[16:18:46.432]             }
[16:18:46.432]         }
[16:18:46.432]     })
[16:18:46.432]     if (TRUE) {
[16:18:46.432]         base::sink(type = "output", split = FALSE)
[16:18:46.432]         if (TRUE) {
[16:18:46.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.432]         }
[16:18:46.432]         else {
[16:18:46.432]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.432]         }
[16:18:46.432]         base::close(...future.stdout)
[16:18:46.432]         ...future.stdout <- NULL
[16:18:46.432]     }
[16:18:46.432]     ...future.result$conditions <- ...future.conditions
[16:18:46.432]     ...future.result$finished <- base::Sys.time()
[16:18:46.432]     ...future.result
[16:18:46.432] }
[16:18:46.435] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[16:18:46.435] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[16:18:46.435] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[16:18:46.435] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[16:18:46.436] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[16:18:46.436] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:18:46.436] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:18:46.436] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:46.436] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.437] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:46.437] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.437] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[16:18:46.437] MultisessionFuture started
[16:18:46.437] - Launch lazy future ... done
[16:18:46.438] run() for ‘MultisessionFuture’ ... done
[16:18:46.438] Created future:
[16:18:46.438] MultisessionFuture:
[16:18:46.438] Label: ‘future_mapply-2’
[16:18:46.438] Expression:
[16:18:46.438] {
[16:18:46.438]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.438]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.438]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.438]         on.exit(options(oopts), add = TRUE)
[16:18:46.438]     }
[16:18:46.438]     {
[16:18:46.438]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.438]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.438]         do.call(mapply, args = args)
[16:18:46.438]     }
[16:18:46.438] }
[16:18:46.438] Lazy evaluation: FALSE
[16:18:46.438] Asynchronous evaluation: TRUE
[16:18:46.438] Local evaluation: TRUE
[16:18:46.438] Environment: R_GlobalEnv
[16:18:46.438] Capture standard output: TRUE
[16:18:46.438] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.438] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.438] Packages: <none>
[16:18:46.438] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:46.438] Resolved: FALSE
[16:18:46.438] Value: <not collected>
[16:18:46.438] Conditions captured: <none>
[16:18:46.438] Early signaling: FALSE
[16:18:46.438] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.438] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.449] Chunk #2 of 2 ... DONE
[16:18:46.449] Launching 2 futures (chunks) ... DONE
[16:18:46.450] Resolving 2 futures (chunks) ...
[16:18:46.450] resolve() on list ...
[16:18:46.450]  recursive: 0
[16:18:46.450]  length: 2
[16:18:46.450] 
[16:18:46.451] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.451] - Validating connection of MultisessionFuture
[16:18:46.451] - received message: FutureResult
[16:18:46.451] - Received FutureResult
[16:18:46.451] - Erased future from FutureRegistry
[16:18:46.451] result() for ClusterFuture ...
[16:18:46.451] - result already collected: FutureResult
[16:18:46.451] result() for ClusterFuture ... done
[16:18:46.452] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.452] Future #1
[16:18:46.452] result() for ClusterFuture ...
[16:18:46.452] - result already collected: FutureResult
[16:18:46.452] result() for ClusterFuture ... done
[16:18:46.452] result() for ClusterFuture ...
[16:18:46.452] - result already collected: FutureResult
[16:18:46.452] result() for ClusterFuture ... done
[16:18:46.452] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:46.452] - nx: 2
[16:18:46.453] - relay: TRUE
[16:18:46.453] - stdout: TRUE
[16:18:46.453] - signal: TRUE
[16:18:46.453] - resignal: FALSE
[16:18:46.453] - force: TRUE
[16:18:46.453] - relayed: [n=2] FALSE, FALSE
[16:18:46.453] - queued futures: [n=2] FALSE, FALSE
[16:18:46.453]  - until=1
[16:18:46.453]  - relaying element #1
[16:18:46.453] result() for ClusterFuture ...
[16:18:46.453] - result already collected: FutureResult
[16:18:46.453] result() for ClusterFuture ... done
[16:18:46.454] result() for ClusterFuture ...
[16:18:46.454] - result already collected: FutureResult
[16:18:46.454] result() for ClusterFuture ... done
[16:18:46.454] result() for ClusterFuture ...
[16:18:46.454] - result already collected: FutureResult
[16:18:46.454] result() for ClusterFuture ... done
[16:18:46.454] result() for ClusterFuture ...
[16:18:46.454] - result already collected: FutureResult
[16:18:46.454] result() for ClusterFuture ... done
[16:18:46.454] - relayed: [n=2] TRUE, FALSE
[16:18:46.454] - queued futures: [n=2] TRUE, FALSE
[16:18:46.454] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:46.455]  length: 1 (resolved future 1)
[16:18:46.482] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.482] - Validating connection of MultisessionFuture
[16:18:46.482] - received message: FutureResult
[16:18:46.482] - Received FutureResult
[16:18:46.482] - Erased future from FutureRegistry
[16:18:46.482] result() for ClusterFuture ...
[16:18:46.483] - result already collected: FutureResult
[16:18:46.483] result() for ClusterFuture ... done
[16:18:46.483] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.483] Future #2
[16:18:46.483] result() for ClusterFuture ...
[16:18:46.483] - result already collected: FutureResult
[16:18:46.483] result() for ClusterFuture ... done
[16:18:46.483] result() for ClusterFuture ...
[16:18:46.483] - result already collected: FutureResult
[16:18:46.483] result() for ClusterFuture ... done
[16:18:46.483] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:46.483] - nx: 2
[16:18:46.484] - relay: TRUE
[16:18:46.484] - stdout: TRUE
[16:18:46.484] - signal: TRUE
[16:18:46.484] - resignal: FALSE
[16:18:46.484] - force: TRUE
[16:18:46.484] - relayed: [n=2] TRUE, FALSE
[16:18:46.484] - queued futures: [n=2] TRUE, FALSE
[16:18:46.484]  - until=2
[16:18:46.484]  - relaying element #2
[16:18:46.484] result() for ClusterFuture ...
[16:18:46.484] - result already collected: FutureResult
[16:18:46.485] result() for ClusterFuture ... done
[16:18:46.485] result() for ClusterFuture ...
[16:18:46.485] - result already collected: FutureResult
[16:18:46.485] result() for ClusterFuture ... done
[16:18:46.485] result() for ClusterFuture ...
[16:18:46.485] - result already collected: FutureResult
[16:18:46.485] result() for ClusterFuture ... done
[16:18:46.485] result() for ClusterFuture ...
[16:18:46.485] - result already collected: FutureResult
[16:18:46.485] result() for ClusterFuture ... done
[16:18:46.485] - relayed: [n=2] TRUE, TRUE
[16:18:46.486] - queued futures: [n=2] TRUE, TRUE
[16:18:46.486] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:46.486]  length: 0 (resolved future 2)
[16:18:46.486] Relaying remaining futures
[16:18:46.486] signalConditionsASAP(NULL, pos=0) ...
[16:18:46.486] - nx: 2
[16:18:46.486] - relay: TRUE
[16:18:46.486] - stdout: TRUE
[16:18:46.486] - signal: TRUE
[16:18:46.486] - resignal: FALSE
[16:18:46.486] - force: TRUE
[16:18:46.486] - relayed: [n=2] TRUE, TRUE
[16:18:46.487] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:46.487] - relayed: [n=2] TRUE, TRUE
[16:18:46.487] - queued futures: [n=2] TRUE, TRUE
[16:18:46.487] signalConditionsASAP(NULL, pos=0) ... done
[16:18:46.487] resolve() on list ... DONE
[16:18:46.487] result() for ClusterFuture ...
[16:18:46.487] - result already collected: FutureResult
[16:18:46.487] result() for ClusterFuture ... done
[16:18:46.487] result() for ClusterFuture ...
[16:18:46.487] - result already collected: FutureResult
[16:18:46.487] result() for ClusterFuture ... done
[16:18:46.488] result() for ClusterFuture ...
[16:18:46.488] - result already collected: FutureResult
[16:18:46.488] result() for ClusterFuture ... done
[16:18:46.488] result() for ClusterFuture ...
[16:18:46.488] - result already collected: FutureResult
[16:18:46.488] result() for ClusterFuture ... done
[16:18:46.488]  - Number of value chunks collected: 2
[16:18:46.488] Resolving 2 futures (chunks) ... DONE
[16:18:46.488] Reducing values from 2 chunks ...
[16:18:46.488]  - Number of values collected after concatenation: 2
[16:18:46.488]  - Number of values expected: 2
[16:18:46.489] Reducing values from 2 chunks ... DONE
[16:18:46.489] future_mapply() ... DONE
[16:18:46.489] future_mapply() ...
[16:18:46.489] Generating random seeds ...
[16:18:46.489] Generating random seed streams for 2 elements ...
[16:18:46.489] Generating random seed streams for 2 elements ... DONE
[16:18:46.489] Generating random seeds ... DONE
[16:18:46.489] Will set RNG state on exit: 10407, 643755544, 1144007322, 201260855, -2125776156, 1191292852, -861207281
[16:18:46.493] Number of chunks: 2
[16:18:46.493] getGlobalsAndPackagesXApply() ...
[16:18:46.493]  - future.globals: TRUE
[16:18:46.493] getGlobalsAndPackages() ...
[16:18:46.493] Searching for globals...
[16:18:46.494] - globals found: [1] ‘FUN’
[16:18:46.494] Searching for globals ... DONE
[16:18:46.494] Resolving globals: FALSE
[16:18:46.495] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[16:18:46.495] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[16:18:46.495] - globals: [1] ‘FUN’
[16:18:46.495] 
[16:18:46.495] getGlobalsAndPackages() ... DONE
[16:18:46.495]  - globals found/used: [n=1] ‘FUN’
[16:18:46.496]  - needed namespaces: [n=0] 
[16:18:46.496] Finding globals ... DONE
[16:18:46.496] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:46.496] List of 2
[16:18:46.496]  $ ...future.FUN:function (x, y)  
[16:18:46.496]  $ MoreArgs     :List of 1
[16:18:46.496]   ..$ y: int [1:2] 3 4
[16:18:46.496]  - attr(*, "where")=List of 2
[16:18:46.496]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:46.496]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:46.496]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:46.496]  - attr(*, "resolved")= logi FALSE
[16:18:46.496]  - attr(*, "total_size")= num NA
[16:18:46.499] Packages to be attached in all futures: [n=0] 
[16:18:46.499] getGlobalsAndPackagesXApply() ... DONE
[16:18:46.499] Number of futures (= number of chunks): 2
[16:18:46.499] Launching 2 futures (chunks) ...
[16:18:46.499] Chunk #1 of 2 ...
[16:18:46.499]  - Finding globals in '...' for chunk #1 ...
[16:18:46.499] getGlobalsAndPackages() ...
[16:18:46.500] Searching for globals...
[16:18:46.500] 
[16:18:46.500] Searching for globals ... DONE
[16:18:46.500] - globals: [0] <none>
[16:18:46.500] getGlobalsAndPackages() ... DONE
[16:18:46.500]    + additional globals found: [n=0] 
[16:18:46.500]    + additional namespaces needed: [n=0] 
[16:18:46.500]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:46.501]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.501]  - seeds: [1] <seeds>
[16:18:46.501]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.501] getGlobalsAndPackages() ...
[16:18:46.501] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.501] Resolving globals: FALSE
[16:18:46.501] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[16:18:46.502] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[16:18:46.502] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.502] 
[16:18:46.502] getGlobalsAndPackages() ... DONE
[16:18:46.503] run() for ‘Future’ ...
[16:18:46.503] - state: ‘created’
[16:18:46.503] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.516] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.516]   - Field: ‘node’
[16:18:46.517]   - Field: ‘label’
[16:18:46.517]   - Field: ‘local’
[16:18:46.517]   - Field: ‘owner’
[16:18:46.517]   - Field: ‘envir’
[16:18:46.517]   - Field: ‘workers’
[16:18:46.517]   - Field: ‘packages’
[16:18:46.517]   - Field: ‘gc’
[16:18:46.517]   - Field: ‘conditions’
[16:18:46.517]   - Field: ‘persistent’
[16:18:46.517]   - Field: ‘expr’
[16:18:46.518]   - Field: ‘uuid’
[16:18:46.518]   - Field: ‘seed’
[16:18:46.518]   - Field: ‘version’
[16:18:46.518]   - Field: ‘result’
[16:18:46.518]   - Field: ‘asynchronous’
[16:18:46.518]   - Field: ‘calls’
[16:18:46.518]   - Field: ‘globals’
[16:18:46.518]   - Field: ‘stdout’
[16:18:46.518]   - Field: ‘earlySignal’
[16:18:46.518]   - Field: ‘lazy’
[16:18:46.518]   - Field: ‘state’
[16:18:46.519] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.519] - Launch lazy future ...
[16:18:46.519] Packages needed by the future expression (n = 0): <none>
[16:18:46.519] Packages needed by future strategies (n = 0): <none>
[16:18:46.519] {
[16:18:46.519]     {
[16:18:46.519]         {
[16:18:46.519]             ...future.startTime <- base::Sys.time()
[16:18:46.519]             {
[16:18:46.519]                 {
[16:18:46.519]                   {
[16:18:46.519]                     {
[16:18:46.519]                       base::local({
[16:18:46.519]                         has_future <- base::requireNamespace("future", 
[16:18:46.519]                           quietly = TRUE)
[16:18:46.519]                         if (has_future) {
[16:18:46.519]                           ns <- base::getNamespace("future")
[16:18:46.519]                           version <- ns[[".package"]][["version"]]
[16:18:46.519]                           if (is.null(version)) 
[16:18:46.519]                             version <- utils::packageVersion("future")
[16:18:46.519]                         }
[16:18:46.519]                         else {
[16:18:46.519]                           version <- NULL
[16:18:46.519]                         }
[16:18:46.519]                         if (!has_future || version < "1.8.0") {
[16:18:46.519]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.519]                             "", base::R.version$version.string), 
[16:18:46.519]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.519]                               "release", "version")], collapse = " "), 
[16:18:46.519]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.519]                             info)
[16:18:46.519]                           info <- base::paste(info, collapse = "; ")
[16:18:46.519]                           if (!has_future) {
[16:18:46.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.519]                               info)
[16:18:46.519]                           }
[16:18:46.519]                           else {
[16:18:46.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.519]                               info, version)
[16:18:46.519]                           }
[16:18:46.519]                           base::stop(msg)
[16:18:46.519]                         }
[16:18:46.519]                       })
[16:18:46.519]                     }
[16:18:46.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.519]                     base::options(mc.cores = 1L)
[16:18:46.519]                   }
[16:18:46.519]                   ...future.strategy.old <- future::plan("list")
[16:18:46.519]                   options(future.plan = NULL)
[16:18:46.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.519]                 }
[16:18:46.519]                 ...future.workdir <- getwd()
[16:18:46.519]             }
[16:18:46.519]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.519]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.519]         }
[16:18:46.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.519]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.519]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.519]             base::names(...future.oldOptions))
[16:18:46.519]     }
[16:18:46.519]     if (FALSE) {
[16:18:46.519]     }
[16:18:46.519]     else {
[16:18:46.519]         if (TRUE) {
[16:18:46.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.519]                 open = "w")
[16:18:46.519]         }
[16:18:46.519]         else {
[16:18:46.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.519]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.519]         }
[16:18:46.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.519]             base::sink(type = "output", split = FALSE)
[16:18:46.519]             base::close(...future.stdout)
[16:18:46.519]         }, add = TRUE)
[16:18:46.519]     }
[16:18:46.519]     ...future.frame <- base::sys.nframe()
[16:18:46.519]     ...future.conditions <- base::list()
[16:18:46.519]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.519]     if (FALSE) {
[16:18:46.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.519]     }
[16:18:46.519]     ...future.result <- base::tryCatch({
[16:18:46.519]         base::withCallingHandlers({
[16:18:46.519]             ...future.value <- base::withVisible(base::local({
[16:18:46.519]                 ...future.makeSendCondition <- base::local({
[16:18:46.519]                   sendCondition <- NULL
[16:18:46.519]                   function(frame = 1L) {
[16:18:46.519]                     if (is.function(sendCondition)) 
[16:18:46.519]                       return(sendCondition)
[16:18:46.519]                     ns <- getNamespace("parallel")
[16:18:46.519]                     if (exists("sendData", mode = "function", 
[16:18:46.519]                       envir = ns)) {
[16:18:46.519]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.519]                         envir = ns)
[16:18:46.519]                       envir <- sys.frame(frame)
[16:18:46.519]                       master <- NULL
[16:18:46.519]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.519]                         !identical(envir, emptyenv())) {
[16:18:46.519]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.519]                           inherits = FALSE)) {
[16:18:46.519]                           master <- get("master", mode = "list", 
[16:18:46.519]                             envir = envir, inherits = FALSE)
[16:18:46.519]                           if (inherits(master, c("SOCKnode", 
[16:18:46.519]                             "SOCK0node"))) {
[16:18:46.519]                             sendCondition <<- function(cond) {
[16:18:46.519]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.519]                                 success = TRUE)
[16:18:46.519]                               parallel_sendData(master, data)
[16:18:46.519]                             }
[16:18:46.519]                             return(sendCondition)
[16:18:46.519]                           }
[16:18:46.519]                         }
[16:18:46.519]                         frame <- frame + 1L
[16:18:46.519]                         envir <- sys.frame(frame)
[16:18:46.519]                       }
[16:18:46.519]                     }
[16:18:46.519]                     sendCondition <<- function(cond) NULL
[16:18:46.519]                   }
[16:18:46.519]                 })
[16:18:46.519]                 withCallingHandlers({
[16:18:46.519]                   {
[16:18:46.519]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.519]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.519]                       ...future.globals.maxSize)) {
[16:18:46.519]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.519]                       on.exit(options(oopts), add = TRUE)
[16:18:46.519]                     }
[16:18:46.519]                     {
[16:18:46.519]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:46.519]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[16:18:46.519]                           envir = globalenv(), inherits = FALSE)
[16:18:46.519]                         ...future.FUN(...)
[16:18:46.519]                       }
[16:18:46.519]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:46.519]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:46.519]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.519]                         USE.NAMES = FALSE)
[16:18:46.519]                       do.call(mapply, args = args)
[16:18:46.519]                     }
[16:18:46.519]                   }
[16:18:46.519]                 }, immediateCondition = function(cond) {
[16:18:46.519]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.519]                   sendCondition(cond)
[16:18:46.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.519]                   {
[16:18:46.519]                     inherits <- base::inherits
[16:18:46.519]                     invokeRestart <- base::invokeRestart
[16:18:46.519]                     is.null <- base::is.null
[16:18:46.519]                     muffled <- FALSE
[16:18:46.519]                     if (inherits(cond, "message")) {
[16:18:46.519]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.519]                       if (muffled) 
[16:18:46.519]                         invokeRestart("muffleMessage")
[16:18:46.519]                     }
[16:18:46.519]                     else if (inherits(cond, "warning")) {
[16:18:46.519]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.519]                       if (muffled) 
[16:18:46.519]                         invokeRestart("muffleWarning")
[16:18:46.519]                     }
[16:18:46.519]                     else if (inherits(cond, "condition")) {
[16:18:46.519]                       if (!is.null(pattern)) {
[16:18:46.519]                         computeRestarts <- base::computeRestarts
[16:18:46.519]                         grepl <- base::grepl
[16:18:46.519]                         restarts <- computeRestarts(cond)
[16:18:46.519]                         for (restart in restarts) {
[16:18:46.519]                           name <- restart$name
[16:18:46.519]                           if (is.null(name)) 
[16:18:46.519]                             next
[16:18:46.519]                           if (!grepl(pattern, name)) 
[16:18:46.519]                             next
[16:18:46.519]                           invokeRestart(restart)
[16:18:46.519]                           muffled <- TRUE
[16:18:46.519]                           break
[16:18:46.519]                         }
[16:18:46.519]                       }
[16:18:46.519]                     }
[16:18:46.519]                     invisible(muffled)
[16:18:46.519]                   }
[16:18:46.519]                   muffleCondition(cond)
[16:18:46.519]                 })
[16:18:46.519]             }))
[16:18:46.519]             future::FutureResult(value = ...future.value$value, 
[16:18:46.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.519]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.519]                     ...future.globalenv.names))
[16:18:46.519]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.519]         }, condition = base::local({
[16:18:46.519]             c <- base::c
[16:18:46.519]             inherits <- base::inherits
[16:18:46.519]             invokeRestart <- base::invokeRestart
[16:18:46.519]             length <- base::length
[16:18:46.519]             list <- base::list
[16:18:46.519]             seq.int <- base::seq.int
[16:18:46.519]             signalCondition <- base::signalCondition
[16:18:46.519]             sys.calls <- base::sys.calls
[16:18:46.519]             `[[` <- base::`[[`
[16:18:46.519]             `+` <- base::`+`
[16:18:46.519]             `<<-` <- base::`<<-`
[16:18:46.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.519]                   3L)]
[16:18:46.519]             }
[16:18:46.519]             function(cond) {
[16:18:46.519]                 is_error <- inherits(cond, "error")
[16:18:46.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.519]                   NULL)
[16:18:46.519]                 if (is_error) {
[16:18:46.519]                   sessionInformation <- function() {
[16:18:46.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.519]                       search = base::search(), system = base::Sys.info())
[16:18:46.519]                   }
[16:18:46.519]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.519]                     cond$call), session = sessionInformation(), 
[16:18:46.519]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.519]                   signalCondition(cond)
[16:18:46.519]                 }
[16:18:46.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.519]                 "immediateCondition"))) {
[16:18:46.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.519]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.519]                   if (TRUE && !signal) {
[16:18:46.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.519]                     {
[16:18:46.519]                       inherits <- base::inherits
[16:18:46.519]                       invokeRestart <- base::invokeRestart
[16:18:46.519]                       is.null <- base::is.null
[16:18:46.519]                       muffled <- FALSE
[16:18:46.519]                       if (inherits(cond, "message")) {
[16:18:46.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.519]                         if (muffled) 
[16:18:46.519]                           invokeRestart("muffleMessage")
[16:18:46.519]                       }
[16:18:46.519]                       else if (inherits(cond, "warning")) {
[16:18:46.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.519]                         if (muffled) 
[16:18:46.519]                           invokeRestart("muffleWarning")
[16:18:46.519]                       }
[16:18:46.519]                       else if (inherits(cond, "condition")) {
[16:18:46.519]                         if (!is.null(pattern)) {
[16:18:46.519]                           computeRestarts <- base::computeRestarts
[16:18:46.519]                           grepl <- base::grepl
[16:18:46.519]                           restarts <- computeRestarts(cond)
[16:18:46.519]                           for (restart in restarts) {
[16:18:46.519]                             name <- restart$name
[16:18:46.519]                             if (is.null(name)) 
[16:18:46.519]                               next
[16:18:46.519]                             if (!grepl(pattern, name)) 
[16:18:46.519]                               next
[16:18:46.519]                             invokeRestart(restart)
[16:18:46.519]                             muffled <- TRUE
[16:18:46.519]                             break
[16:18:46.519]                           }
[16:18:46.519]                         }
[16:18:46.519]                       }
[16:18:46.519]                       invisible(muffled)
[16:18:46.519]                     }
[16:18:46.519]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.519]                   }
[16:18:46.519]                 }
[16:18:46.519]                 else {
[16:18:46.519]                   if (TRUE) {
[16:18:46.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.519]                     {
[16:18:46.519]                       inherits <- base::inherits
[16:18:46.519]                       invokeRestart <- base::invokeRestart
[16:18:46.519]                       is.null <- base::is.null
[16:18:46.519]                       muffled <- FALSE
[16:18:46.519]                       if (inherits(cond, "message")) {
[16:18:46.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.519]                         if (muffled) 
[16:18:46.519]                           invokeRestart("muffleMessage")
[16:18:46.519]                       }
[16:18:46.519]                       else if (inherits(cond, "warning")) {
[16:18:46.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.519]                         if (muffled) 
[16:18:46.519]                           invokeRestart("muffleWarning")
[16:18:46.519]                       }
[16:18:46.519]                       else if (inherits(cond, "condition")) {
[16:18:46.519]                         if (!is.null(pattern)) {
[16:18:46.519]                           computeRestarts <- base::computeRestarts
[16:18:46.519]                           grepl <- base::grepl
[16:18:46.519]                           restarts <- computeRestarts(cond)
[16:18:46.519]                           for (restart in restarts) {
[16:18:46.519]                             name <- restart$name
[16:18:46.519]                             if (is.null(name)) 
[16:18:46.519]                               next
[16:18:46.519]                             if (!grepl(pattern, name)) 
[16:18:46.519]                               next
[16:18:46.519]                             invokeRestart(restart)
[16:18:46.519]                             muffled <- TRUE
[16:18:46.519]                             break
[16:18:46.519]                           }
[16:18:46.519]                         }
[16:18:46.519]                       }
[16:18:46.519]                       invisible(muffled)
[16:18:46.519]                     }
[16:18:46.519]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.519]                   }
[16:18:46.519]                 }
[16:18:46.519]             }
[16:18:46.519]         }))
[16:18:46.519]     }, error = function(ex) {
[16:18:46.519]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.519]                 ...future.rng), started = ...future.startTime, 
[16:18:46.519]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.519]             version = "1.8"), class = "FutureResult")
[16:18:46.519]     }, finally = {
[16:18:46.519]         if (!identical(...future.workdir, getwd())) 
[16:18:46.519]             setwd(...future.workdir)
[16:18:46.519]         {
[16:18:46.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.519]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.519]             }
[16:18:46.519]             base::options(...future.oldOptions)
[16:18:46.519]             if (.Platform$OS.type == "windows") {
[16:18:46.519]                 old_names <- names(...future.oldEnvVars)
[16:18:46.519]                 envs <- base::Sys.getenv()
[16:18:46.519]                 names <- names(envs)
[16:18:46.519]                 common <- intersect(names, old_names)
[16:18:46.519]                 added <- setdiff(names, old_names)
[16:18:46.519]                 removed <- setdiff(old_names, names)
[16:18:46.519]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.519]                   envs[common]]
[16:18:46.519]                 NAMES <- toupper(changed)
[16:18:46.519]                 args <- list()
[16:18:46.519]                 for (kk in seq_along(NAMES)) {
[16:18:46.519]                   name <- changed[[kk]]
[16:18:46.519]                   NAME <- NAMES[[kk]]
[16:18:46.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.519]                     next
[16:18:46.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.519]                 }
[16:18:46.519]                 NAMES <- toupper(added)
[16:18:46.519]                 for (kk in seq_along(NAMES)) {
[16:18:46.519]                   name <- added[[kk]]
[16:18:46.519]                   NAME <- NAMES[[kk]]
[16:18:46.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.519]                     next
[16:18:46.519]                   args[[name]] <- ""
[16:18:46.519]                 }
[16:18:46.519]                 NAMES <- toupper(removed)
[16:18:46.519]                 for (kk in seq_along(NAMES)) {
[16:18:46.519]                   name <- removed[[kk]]
[16:18:46.519]                   NAME <- NAMES[[kk]]
[16:18:46.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.519]                     next
[16:18:46.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.519]                 }
[16:18:46.519]                 if (length(args) > 0) 
[16:18:46.519]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.519]             }
[16:18:46.519]             else {
[16:18:46.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.519]             }
[16:18:46.519]             {
[16:18:46.519]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.519]                   0L) {
[16:18:46.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.519]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.519]                   base::options(opts)
[16:18:46.519]                 }
[16:18:46.519]                 {
[16:18:46.519]                   {
[16:18:46.519]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.519]                     NULL
[16:18:46.519]                   }
[16:18:46.519]                   options(future.plan = NULL)
[16:18:46.519]                   if (is.na(NA_character_)) 
[16:18:46.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.519]                     .init = FALSE)
[16:18:46.519]                 }
[16:18:46.519]             }
[16:18:46.519]         }
[16:18:46.519]     })
[16:18:46.519]     if (TRUE) {
[16:18:46.519]         base::sink(type = "output", split = FALSE)
[16:18:46.519]         if (TRUE) {
[16:18:46.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.519]         }
[16:18:46.519]         else {
[16:18:46.519]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.519]         }
[16:18:46.519]         base::close(...future.stdout)
[16:18:46.519]         ...future.stdout <- NULL
[16:18:46.519]     }
[16:18:46.519]     ...future.result$conditions <- ...future.conditions
[16:18:46.519]     ...future.result$finished <- base::Sys.time()
[16:18:46.519]     ...future.result
[16:18:46.519] }
[16:18:46.522] Exporting 5 global objects (1.85 KiB) to cluster node #1 ...
[16:18:46.522] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[16:18:46.523] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[16:18:46.523] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[16:18:46.523] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[16:18:46.523] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:18:46.524] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:18:46.524] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[16:18:46.524] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[16:18:46.524] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:46.525] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.525] Exporting 5 global objects (1.85 KiB) to cluster node #1 ... DONE
[16:18:46.525] MultisessionFuture started
[16:18:46.526] - Launch lazy future ... done
[16:18:46.526] run() for ‘MultisessionFuture’ ... done
[16:18:46.526] Created future:
[16:18:46.526] MultisessionFuture:
[16:18:46.526] Label: ‘future_mapply-1’
[16:18:46.526] Expression:
[16:18:46.526] {
[16:18:46.526]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.526]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.526]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.526]         on.exit(options(oopts), add = TRUE)
[16:18:46.526]     }
[16:18:46.526]     {
[16:18:46.526]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:46.526]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[16:18:46.526]                 inherits = FALSE)
[16:18:46.526]             ...future.FUN(...)
[16:18:46.526]         }
[16:18:46.526]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:46.526]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:46.526]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.526]         do.call(mapply, args = args)
[16:18:46.526]     }
[16:18:46.526] }
[16:18:46.526] Lazy evaluation: FALSE
[16:18:46.526] Asynchronous evaluation: TRUE
[16:18:46.526] Local evaluation: TRUE
[16:18:46.526] Environment: R_GlobalEnv
[16:18:46.526] Capture standard output: TRUE
[16:18:46.526] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.526] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.526] Packages: <none>
[16:18:46.526] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:18:46.526] Resolved: FALSE
[16:18:46.526] Value: <not collected>
[16:18:46.526] Conditions captured: <none>
[16:18:46.526] Early signaling: FALSE
[16:18:46.526] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.526] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.537] Chunk #1 of 2 ... DONE
[16:18:46.537] Chunk #2 of 2 ...
[16:18:46.538]  - Finding globals in '...' for chunk #2 ...
[16:18:46.538] getGlobalsAndPackages() ...
[16:18:46.538] Searching for globals...
[16:18:46.538] 
[16:18:46.538] Searching for globals ... DONE
[16:18:46.538] - globals: [0] <none>
[16:18:46.538] getGlobalsAndPackages() ... DONE
[16:18:46.538]    + additional globals found: [n=0] 
[16:18:46.538]    + additional namespaces needed: [n=0] 
[16:18:46.539]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:46.539]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.539]  - seeds: [1] <seeds>
[16:18:46.539]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.539] getGlobalsAndPackages() ...
[16:18:46.539] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.539] Resolving globals: FALSE
[16:18:46.540] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[16:18:46.540] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[16:18:46.540] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.540] 
[16:18:46.540] getGlobalsAndPackages() ... DONE
[16:18:46.541] run() for ‘Future’ ...
[16:18:46.541] - state: ‘created’
[16:18:46.541] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.554] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.555]   - Field: ‘node’
[16:18:46.555]   - Field: ‘label’
[16:18:46.555]   - Field: ‘local’
[16:18:46.555]   - Field: ‘owner’
[16:18:46.555]   - Field: ‘envir’
[16:18:46.555]   - Field: ‘workers’
[16:18:46.555]   - Field: ‘packages’
[16:18:46.555]   - Field: ‘gc’
[16:18:46.555]   - Field: ‘conditions’
[16:18:46.555]   - Field: ‘persistent’
[16:18:46.556]   - Field: ‘expr’
[16:18:46.556]   - Field: ‘uuid’
[16:18:46.556]   - Field: ‘seed’
[16:18:46.556]   - Field: ‘version’
[16:18:46.556]   - Field: ‘result’
[16:18:46.556]   - Field: ‘asynchronous’
[16:18:46.556]   - Field: ‘calls’
[16:18:46.556]   - Field: ‘globals’
[16:18:46.556]   - Field: ‘stdout’
[16:18:46.556]   - Field: ‘earlySignal’
[16:18:46.557]   - Field: ‘lazy’
[16:18:46.557]   - Field: ‘state’
[16:18:46.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.557] - Launch lazy future ...
[16:18:46.557] Packages needed by the future expression (n = 0): <none>
[16:18:46.557] Packages needed by future strategies (n = 0): <none>
[16:18:46.558] {
[16:18:46.558]     {
[16:18:46.558]         {
[16:18:46.558]             ...future.startTime <- base::Sys.time()
[16:18:46.558]             {
[16:18:46.558]                 {
[16:18:46.558]                   {
[16:18:46.558]                     {
[16:18:46.558]                       base::local({
[16:18:46.558]                         has_future <- base::requireNamespace("future", 
[16:18:46.558]                           quietly = TRUE)
[16:18:46.558]                         if (has_future) {
[16:18:46.558]                           ns <- base::getNamespace("future")
[16:18:46.558]                           version <- ns[[".package"]][["version"]]
[16:18:46.558]                           if (is.null(version)) 
[16:18:46.558]                             version <- utils::packageVersion("future")
[16:18:46.558]                         }
[16:18:46.558]                         else {
[16:18:46.558]                           version <- NULL
[16:18:46.558]                         }
[16:18:46.558]                         if (!has_future || version < "1.8.0") {
[16:18:46.558]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.558]                             "", base::R.version$version.string), 
[16:18:46.558]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.558]                               "release", "version")], collapse = " "), 
[16:18:46.558]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.558]                             info)
[16:18:46.558]                           info <- base::paste(info, collapse = "; ")
[16:18:46.558]                           if (!has_future) {
[16:18:46.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.558]                               info)
[16:18:46.558]                           }
[16:18:46.558]                           else {
[16:18:46.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.558]                               info, version)
[16:18:46.558]                           }
[16:18:46.558]                           base::stop(msg)
[16:18:46.558]                         }
[16:18:46.558]                       })
[16:18:46.558]                     }
[16:18:46.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.558]                     base::options(mc.cores = 1L)
[16:18:46.558]                   }
[16:18:46.558]                   ...future.strategy.old <- future::plan("list")
[16:18:46.558]                   options(future.plan = NULL)
[16:18:46.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.558]                 }
[16:18:46.558]                 ...future.workdir <- getwd()
[16:18:46.558]             }
[16:18:46.558]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.558]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.558]         }
[16:18:46.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.558]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.558]             base::names(...future.oldOptions))
[16:18:46.558]     }
[16:18:46.558]     if (FALSE) {
[16:18:46.558]     }
[16:18:46.558]     else {
[16:18:46.558]         if (TRUE) {
[16:18:46.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.558]                 open = "w")
[16:18:46.558]         }
[16:18:46.558]         else {
[16:18:46.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.558]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.558]         }
[16:18:46.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.558]             base::sink(type = "output", split = FALSE)
[16:18:46.558]             base::close(...future.stdout)
[16:18:46.558]         }, add = TRUE)
[16:18:46.558]     }
[16:18:46.558]     ...future.frame <- base::sys.nframe()
[16:18:46.558]     ...future.conditions <- base::list()
[16:18:46.558]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.558]     if (FALSE) {
[16:18:46.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.558]     }
[16:18:46.558]     ...future.result <- base::tryCatch({
[16:18:46.558]         base::withCallingHandlers({
[16:18:46.558]             ...future.value <- base::withVisible(base::local({
[16:18:46.558]                 ...future.makeSendCondition <- base::local({
[16:18:46.558]                   sendCondition <- NULL
[16:18:46.558]                   function(frame = 1L) {
[16:18:46.558]                     if (is.function(sendCondition)) 
[16:18:46.558]                       return(sendCondition)
[16:18:46.558]                     ns <- getNamespace("parallel")
[16:18:46.558]                     if (exists("sendData", mode = "function", 
[16:18:46.558]                       envir = ns)) {
[16:18:46.558]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.558]                         envir = ns)
[16:18:46.558]                       envir <- sys.frame(frame)
[16:18:46.558]                       master <- NULL
[16:18:46.558]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.558]                         !identical(envir, emptyenv())) {
[16:18:46.558]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.558]                           inherits = FALSE)) {
[16:18:46.558]                           master <- get("master", mode = "list", 
[16:18:46.558]                             envir = envir, inherits = FALSE)
[16:18:46.558]                           if (inherits(master, c("SOCKnode", 
[16:18:46.558]                             "SOCK0node"))) {
[16:18:46.558]                             sendCondition <<- function(cond) {
[16:18:46.558]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.558]                                 success = TRUE)
[16:18:46.558]                               parallel_sendData(master, data)
[16:18:46.558]                             }
[16:18:46.558]                             return(sendCondition)
[16:18:46.558]                           }
[16:18:46.558]                         }
[16:18:46.558]                         frame <- frame + 1L
[16:18:46.558]                         envir <- sys.frame(frame)
[16:18:46.558]                       }
[16:18:46.558]                     }
[16:18:46.558]                     sendCondition <<- function(cond) NULL
[16:18:46.558]                   }
[16:18:46.558]                 })
[16:18:46.558]                 withCallingHandlers({
[16:18:46.558]                   {
[16:18:46.558]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.558]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.558]                       ...future.globals.maxSize)) {
[16:18:46.558]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.558]                       on.exit(options(oopts), add = TRUE)
[16:18:46.558]                     }
[16:18:46.558]                     {
[16:18:46.558]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:46.558]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[16:18:46.558]                           envir = globalenv(), inherits = FALSE)
[16:18:46.558]                         ...future.FUN(...)
[16:18:46.558]                       }
[16:18:46.558]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:46.558]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:46.558]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.558]                         USE.NAMES = FALSE)
[16:18:46.558]                       do.call(mapply, args = args)
[16:18:46.558]                     }
[16:18:46.558]                   }
[16:18:46.558]                 }, immediateCondition = function(cond) {
[16:18:46.558]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.558]                   sendCondition(cond)
[16:18:46.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.558]                   {
[16:18:46.558]                     inherits <- base::inherits
[16:18:46.558]                     invokeRestart <- base::invokeRestart
[16:18:46.558]                     is.null <- base::is.null
[16:18:46.558]                     muffled <- FALSE
[16:18:46.558]                     if (inherits(cond, "message")) {
[16:18:46.558]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.558]                       if (muffled) 
[16:18:46.558]                         invokeRestart("muffleMessage")
[16:18:46.558]                     }
[16:18:46.558]                     else if (inherits(cond, "warning")) {
[16:18:46.558]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.558]                       if (muffled) 
[16:18:46.558]                         invokeRestart("muffleWarning")
[16:18:46.558]                     }
[16:18:46.558]                     else if (inherits(cond, "condition")) {
[16:18:46.558]                       if (!is.null(pattern)) {
[16:18:46.558]                         computeRestarts <- base::computeRestarts
[16:18:46.558]                         grepl <- base::grepl
[16:18:46.558]                         restarts <- computeRestarts(cond)
[16:18:46.558]                         for (restart in restarts) {
[16:18:46.558]                           name <- restart$name
[16:18:46.558]                           if (is.null(name)) 
[16:18:46.558]                             next
[16:18:46.558]                           if (!grepl(pattern, name)) 
[16:18:46.558]                             next
[16:18:46.558]                           invokeRestart(restart)
[16:18:46.558]                           muffled <- TRUE
[16:18:46.558]                           break
[16:18:46.558]                         }
[16:18:46.558]                       }
[16:18:46.558]                     }
[16:18:46.558]                     invisible(muffled)
[16:18:46.558]                   }
[16:18:46.558]                   muffleCondition(cond)
[16:18:46.558]                 })
[16:18:46.558]             }))
[16:18:46.558]             future::FutureResult(value = ...future.value$value, 
[16:18:46.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.558]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.558]                     ...future.globalenv.names))
[16:18:46.558]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.558]         }, condition = base::local({
[16:18:46.558]             c <- base::c
[16:18:46.558]             inherits <- base::inherits
[16:18:46.558]             invokeRestart <- base::invokeRestart
[16:18:46.558]             length <- base::length
[16:18:46.558]             list <- base::list
[16:18:46.558]             seq.int <- base::seq.int
[16:18:46.558]             signalCondition <- base::signalCondition
[16:18:46.558]             sys.calls <- base::sys.calls
[16:18:46.558]             `[[` <- base::`[[`
[16:18:46.558]             `+` <- base::`+`
[16:18:46.558]             `<<-` <- base::`<<-`
[16:18:46.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.558]                   3L)]
[16:18:46.558]             }
[16:18:46.558]             function(cond) {
[16:18:46.558]                 is_error <- inherits(cond, "error")
[16:18:46.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.558]                   NULL)
[16:18:46.558]                 if (is_error) {
[16:18:46.558]                   sessionInformation <- function() {
[16:18:46.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.558]                       search = base::search(), system = base::Sys.info())
[16:18:46.558]                   }
[16:18:46.558]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.558]                     cond$call), session = sessionInformation(), 
[16:18:46.558]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.558]                   signalCondition(cond)
[16:18:46.558]                 }
[16:18:46.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.558]                 "immediateCondition"))) {
[16:18:46.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.558]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.558]                   if (TRUE && !signal) {
[16:18:46.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.558]                     {
[16:18:46.558]                       inherits <- base::inherits
[16:18:46.558]                       invokeRestart <- base::invokeRestart
[16:18:46.558]                       is.null <- base::is.null
[16:18:46.558]                       muffled <- FALSE
[16:18:46.558]                       if (inherits(cond, "message")) {
[16:18:46.558]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.558]                         if (muffled) 
[16:18:46.558]                           invokeRestart("muffleMessage")
[16:18:46.558]                       }
[16:18:46.558]                       else if (inherits(cond, "warning")) {
[16:18:46.558]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.558]                         if (muffled) 
[16:18:46.558]                           invokeRestart("muffleWarning")
[16:18:46.558]                       }
[16:18:46.558]                       else if (inherits(cond, "condition")) {
[16:18:46.558]                         if (!is.null(pattern)) {
[16:18:46.558]                           computeRestarts <- base::computeRestarts
[16:18:46.558]                           grepl <- base::grepl
[16:18:46.558]                           restarts <- computeRestarts(cond)
[16:18:46.558]                           for (restart in restarts) {
[16:18:46.558]                             name <- restart$name
[16:18:46.558]                             if (is.null(name)) 
[16:18:46.558]                               next
[16:18:46.558]                             if (!grepl(pattern, name)) 
[16:18:46.558]                               next
[16:18:46.558]                             invokeRestart(restart)
[16:18:46.558]                             muffled <- TRUE
[16:18:46.558]                             break
[16:18:46.558]                           }
[16:18:46.558]                         }
[16:18:46.558]                       }
[16:18:46.558]                       invisible(muffled)
[16:18:46.558]                     }
[16:18:46.558]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.558]                   }
[16:18:46.558]                 }
[16:18:46.558]                 else {
[16:18:46.558]                   if (TRUE) {
[16:18:46.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.558]                     {
[16:18:46.558]                       inherits <- base::inherits
[16:18:46.558]                       invokeRestart <- base::invokeRestart
[16:18:46.558]                       is.null <- base::is.null
[16:18:46.558]                       muffled <- FALSE
[16:18:46.558]                       if (inherits(cond, "message")) {
[16:18:46.558]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.558]                         if (muffled) 
[16:18:46.558]                           invokeRestart("muffleMessage")
[16:18:46.558]                       }
[16:18:46.558]                       else if (inherits(cond, "warning")) {
[16:18:46.558]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.558]                         if (muffled) 
[16:18:46.558]                           invokeRestart("muffleWarning")
[16:18:46.558]                       }
[16:18:46.558]                       else if (inherits(cond, "condition")) {
[16:18:46.558]                         if (!is.null(pattern)) {
[16:18:46.558]                           computeRestarts <- base::computeRestarts
[16:18:46.558]                           grepl <- base::grepl
[16:18:46.558]                           restarts <- computeRestarts(cond)
[16:18:46.558]                           for (restart in restarts) {
[16:18:46.558]                             name <- restart$name
[16:18:46.558]                             if (is.null(name)) 
[16:18:46.558]                               next
[16:18:46.558]                             if (!grepl(pattern, name)) 
[16:18:46.558]                               next
[16:18:46.558]                             invokeRestart(restart)
[16:18:46.558]                             muffled <- TRUE
[16:18:46.558]                             break
[16:18:46.558]                           }
[16:18:46.558]                         }
[16:18:46.558]                       }
[16:18:46.558]                       invisible(muffled)
[16:18:46.558]                     }
[16:18:46.558]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.558]                   }
[16:18:46.558]                 }
[16:18:46.558]             }
[16:18:46.558]         }))
[16:18:46.558]     }, error = function(ex) {
[16:18:46.558]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.558]                 ...future.rng), started = ...future.startTime, 
[16:18:46.558]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.558]             version = "1.8"), class = "FutureResult")
[16:18:46.558]     }, finally = {
[16:18:46.558]         if (!identical(...future.workdir, getwd())) 
[16:18:46.558]             setwd(...future.workdir)
[16:18:46.558]         {
[16:18:46.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.558]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.558]             }
[16:18:46.558]             base::options(...future.oldOptions)
[16:18:46.558]             if (.Platform$OS.type == "windows") {
[16:18:46.558]                 old_names <- names(...future.oldEnvVars)
[16:18:46.558]                 envs <- base::Sys.getenv()
[16:18:46.558]                 names <- names(envs)
[16:18:46.558]                 common <- intersect(names, old_names)
[16:18:46.558]                 added <- setdiff(names, old_names)
[16:18:46.558]                 removed <- setdiff(old_names, names)
[16:18:46.558]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.558]                   envs[common]]
[16:18:46.558]                 NAMES <- toupper(changed)
[16:18:46.558]                 args <- list()
[16:18:46.558]                 for (kk in seq_along(NAMES)) {
[16:18:46.558]                   name <- changed[[kk]]
[16:18:46.558]                   NAME <- NAMES[[kk]]
[16:18:46.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.558]                     next
[16:18:46.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.558]                 }
[16:18:46.558]                 NAMES <- toupper(added)
[16:18:46.558]                 for (kk in seq_along(NAMES)) {
[16:18:46.558]                   name <- added[[kk]]
[16:18:46.558]                   NAME <- NAMES[[kk]]
[16:18:46.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.558]                     next
[16:18:46.558]                   args[[name]] <- ""
[16:18:46.558]                 }
[16:18:46.558]                 NAMES <- toupper(removed)
[16:18:46.558]                 for (kk in seq_along(NAMES)) {
[16:18:46.558]                   name <- removed[[kk]]
[16:18:46.558]                   NAME <- NAMES[[kk]]
[16:18:46.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.558]                     next
[16:18:46.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.558]                 }
[16:18:46.558]                 if (length(args) > 0) 
[16:18:46.558]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.558]             }
[16:18:46.558]             else {
[16:18:46.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.558]             }
[16:18:46.558]             {
[16:18:46.558]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.558]                   0L) {
[16:18:46.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.558]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.558]                   base::options(opts)
[16:18:46.558]                 }
[16:18:46.558]                 {
[16:18:46.558]                   {
[16:18:46.558]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.558]                     NULL
[16:18:46.558]                   }
[16:18:46.558]                   options(future.plan = NULL)
[16:18:46.558]                   if (is.na(NA_character_)) 
[16:18:46.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.558]                     .init = FALSE)
[16:18:46.558]                 }
[16:18:46.558]             }
[16:18:46.558]         }
[16:18:46.558]     })
[16:18:46.558]     if (TRUE) {
[16:18:46.558]         base::sink(type = "output", split = FALSE)
[16:18:46.558]         if (TRUE) {
[16:18:46.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.558]         }
[16:18:46.558]         else {
[16:18:46.558]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.558]         }
[16:18:46.558]         base::close(...future.stdout)
[16:18:46.558]         ...future.stdout <- NULL
[16:18:46.558]     }
[16:18:46.558]     ...future.result$conditions <- ...future.conditions
[16:18:46.558]     ...future.result$finished <- base::Sys.time()
[16:18:46.558]     ...future.result
[16:18:46.558] }
[16:18:46.560] Exporting 5 global objects (1.85 KiB) to cluster node #2 ...
[16:18:46.560] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[16:18:46.561] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[16:18:46.561] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[16:18:46.561] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[16:18:46.561] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:18:46.562] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:18:46.562] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[16:18:46.562] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[16:18:46.562] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:46.562] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.563] Exporting 5 global objects (1.85 KiB) to cluster node #2 ... DONE
[16:18:46.563] MultisessionFuture started
[16:18:46.563] - Launch lazy future ... done
[16:18:46.563] run() for ‘MultisessionFuture’ ... done
[16:18:46.563] Created future:
[16:18:46.563] MultisessionFuture:
[16:18:46.563] Label: ‘future_mapply-2’
[16:18:46.563] Expression:
[16:18:46.563] {
[16:18:46.563]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.563]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.563]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.563]         on.exit(options(oopts), add = TRUE)
[16:18:46.563]     }
[16:18:46.563]     {
[16:18:46.563]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:46.563]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[16:18:46.563]                 inherits = FALSE)
[16:18:46.563]             ...future.FUN(...)
[16:18:46.563]         }
[16:18:46.563]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:46.563]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:46.563]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.563]         do.call(mapply, args = args)
[16:18:46.563]     }
[16:18:46.563] }
[16:18:46.563] Lazy evaluation: FALSE
[16:18:46.563] Asynchronous evaluation: TRUE
[16:18:46.563] Local evaluation: TRUE
[16:18:46.563] Environment: R_GlobalEnv
[16:18:46.563] Capture standard output: TRUE
[16:18:46.563] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.563] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.563] Packages: <none>
[16:18:46.563] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:18:46.563] Resolved: FALSE
[16:18:46.563] Value: <not collected>
[16:18:46.563] Conditions captured: <none>
[16:18:46.563] Early signaling: FALSE
[16:18:46.563] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.563] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.575] Chunk #2 of 2 ... DONE
[16:18:46.575] Launching 2 futures (chunks) ... DONE
[16:18:46.575] Resolving 2 futures (chunks) ...
[16:18:46.575] resolve() on list ...
[16:18:46.575]  recursive: 0
[16:18:46.575]  length: 2
[16:18:46.576] 
[16:18:46.576] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.576] - Validating connection of MultisessionFuture
[16:18:46.576] - received message: FutureResult
[16:18:46.576] - Received FutureResult
[16:18:46.577] - Erased future from FutureRegistry
[16:18:46.577] result() for ClusterFuture ...
[16:18:46.577] - result already collected: FutureResult
[16:18:46.577] result() for ClusterFuture ... done
[16:18:46.577] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.577] Future #1
[16:18:46.577] result() for ClusterFuture ...
[16:18:46.577] - result already collected: FutureResult
[16:18:46.577] result() for ClusterFuture ... done
[16:18:46.577] result() for ClusterFuture ...
[16:18:46.577] - result already collected: FutureResult
[16:18:46.578] result() for ClusterFuture ... done
[16:18:46.578] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:46.578] - nx: 2
[16:18:46.578] - relay: TRUE
[16:18:46.578] - stdout: TRUE
[16:18:46.578] - signal: TRUE
[16:18:46.578] - resignal: FALSE
[16:18:46.578] - force: TRUE
[16:18:46.578] - relayed: [n=2] FALSE, FALSE
[16:18:46.578] - queued futures: [n=2] FALSE, FALSE
[16:18:46.578]  - until=1
[16:18:46.579]  - relaying element #1
[16:18:46.579] result() for ClusterFuture ...
[16:18:46.579] - result already collected: FutureResult
[16:18:46.579] result() for ClusterFuture ... done
[16:18:46.582] result() for ClusterFuture ...
[16:18:46.582] - result already collected: FutureResult
[16:18:46.582] result() for ClusterFuture ... done
[16:18:46.582] result() for ClusterFuture ...
[16:18:46.582] - result already collected: FutureResult
[16:18:46.582] result() for ClusterFuture ... done
[16:18:46.582] result() for ClusterFuture ...
[16:18:46.583] - result already collected: FutureResult
[16:18:46.583] result() for ClusterFuture ... done
[16:18:46.583] - relayed: [n=2] TRUE, FALSE
[16:18:46.583] - queued futures: [n=2] TRUE, FALSE
[16:18:46.583] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:46.583]  length: 1 (resolved future 1)
[16:18:46.606] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.606] - Validating connection of MultisessionFuture
[16:18:46.606] - received message: FutureResult
[16:18:46.606] - Received FutureResult
[16:18:46.606] - Erased future from FutureRegistry
[16:18:46.606] result() for ClusterFuture ...
[16:18:46.606] - result already collected: FutureResult
[16:18:46.607] result() for ClusterFuture ... done
[16:18:46.607] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.607] Future #2
[16:18:46.607] result() for ClusterFuture ...
[16:18:46.607] - result already collected: FutureResult
[16:18:46.607] result() for ClusterFuture ... done
[16:18:46.607] result() for ClusterFuture ...
[16:18:46.607] - result already collected: FutureResult
[16:18:46.607] result() for ClusterFuture ... done
[16:18:46.607] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:46.607] - nx: 2
[16:18:46.608] - relay: TRUE
[16:18:46.608] - stdout: TRUE
[16:18:46.608] - signal: TRUE
[16:18:46.608] - resignal: FALSE
[16:18:46.608] - force: TRUE
[16:18:46.608] - relayed: [n=2] TRUE, FALSE
[16:18:46.608] - queued futures: [n=2] TRUE, FALSE
[16:18:46.608]  - until=2
[16:18:46.608]  - relaying element #2
[16:18:46.608] result() for ClusterFuture ...
[16:18:46.608] - result already collected: FutureResult
[16:18:46.609] result() for ClusterFuture ... done
[16:18:46.609] result() for ClusterFuture ...
[16:18:46.609] - result already collected: FutureResult
[16:18:46.609] result() for ClusterFuture ... done
[16:18:46.609] result() for ClusterFuture ...
[16:18:46.609] - result already collected: FutureResult
[16:18:46.609] result() for ClusterFuture ... done
[16:18:46.609] result() for ClusterFuture ...
[16:18:46.609] - result already collected: FutureResult
[16:18:46.609] result() for ClusterFuture ... done
[16:18:46.609] - relayed: [n=2] TRUE, TRUE
[16:18:46.610] - queued futures: [n=2] TRUE, TRUE
[16:18:46.610] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:46.610]  length: 0 (resolved future 2)
[16:18:46.610] Relaying remaining futures
[16:18:46.610] signalConditionsASAP(NULL, pos=0) ...
[16:18:46.610] - nx: 2
[16:18:46.610] - relay: TRUE
[16:18:46.610] - stdout: TRUE
[16:18:46.610] - signal: TRUE
[16:18:46.610] - resignal: FALSE
[16:18:46.610] - force: TRUE
[16:18:46.610] - relayed: [n=2] TRUE, TRUE
[16:18:46.611] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:46.611] - relayed: [n=2] TRUE, TRUE
[16:18:46.611] - queued futures: [n=2] TRUE, TRUE
[16:18:46.611] signalConditionsASAP(NULL, pos=0) ... done
[16:18:46.611] resolve() on list ... DONE
[16:18:46.611] result() for ClusterFuture ...
[16:18:46.611] - result already collected: FutureResult
[16:18:46.611] result() for ClusterFuture ... done
[16:18:46.611] result() for ClusterFuture ...
[16:18:46.611] - result already collected: FutureResult
[16:18:46.611] result() for ClusterFuture ... done
[16:18:46.612] result() for ClusterFuture ...
[16:18:46.612] - result already collected: FutureResult
[16:18:46.612] result() for ClusterFuture ... done
[16:18:46.612] result() for ClusterFuture ...
[16:18:46.612] - result already collected: FutureResult
[16:18:46.612] result() for ClusterFuture ... done
[16:18:46.612]  - Number of value chunks collected: 2
[16:18:46.612] Resolving 2 futures (chunks) ... DONE
[16:18:46.612] Reducing values from 2 chunks ...
[16:18:46.612]  - Number of values collected after concatenation: 2
[16:18:46.612]  - Number of values expected: 2
[16:18:46.613] Reducing values from 2 chunks ... DONE
[16:18:46.613] future_mapply() ... DONE
[16:18:46.613] future_mapply() ...
[16:18:46.616] Number of chunks: 2
[16:18:46.617] getGlobalsAndPackagesXApply() ...
[16:18:46.617]  - future.globals: TRUE
[16:18:46.617] getGlobalsAndPackages() ...
[16:18:46.617] Searching for globals...
[16:18:46.618] - globals found: [1] ‘FUN’
[16:18:46.618] Searching for globals ... DONE
[16:18:46.618] Resolving globals: FALSE
[16:18:46.618] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[16:18:46.619] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[16:18:46.619] - globals: [1] ‘FUN’
[16:18:46.619] 
[16:18:46.619] getGlobalsAndPackages() ... DONE
[16:18:46.619]  - globals found/used: [n=1] ‘FUN’
[16:18:46.619]  - needed namespaces: [n=0] 
[16:18:46.619] Finding globals ... DONE
[16:18:46.619] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:46.619] List of 2
[16:18:46.619]  $ ...future.FUN:function (x, y)  
[16:18:46.619]  $ MoreArgs     :List of 1
[16:18:46.619]   ..$ y: int [1:2] 3 4
[16:18:46.619]  - attr(*, "where")=List of 2
[16:18:46.619]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:46.619]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:46.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:46.619]  - attr(*, "resolved")= logi FALSE
[16:18:46.619]  - attr(*, "total_size")= num NA
[16:18:46.622] Packages to be attached in all futures: [n=0] 
[16:18:46.622] getGlobalsAndPackagesXApply() ... DONE
[16:18:46.623] Number of futures (= number of chunks): 2
[16:18:46.623] Launching 2 futures (chunks) ...
[16:18:46.623] Chunk #1 of 2 ...
[16:18:46.623]  - Finding globals in '...' for chunk #1 ...
[16:18:46.623] getGlobalsAndPackages() ...
[16:18:46.623] Searching for globals...
[16:18:46.623] 
[16:18:46.623] Searching for globals ... DONE
[16:18:46.624] - globals: [0] <none>
[16:18:46.624] getGlobalsAndPackages() ... DONE
[16:18:46.624]    + additional globals found: [n=0] 
[16:18:46.624]    + additional namespaces needed: [n=0] 
[16:18:46.624]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:46.624]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.624]  - seeds: <none>
[16:18:46.624]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.624] getGlobalsAndPackages() ...
[16:18:46.624] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.625] Resolving globals: FALSE
[16:18:46.625] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[16:18:46.625] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[16:18:46.625] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.626] 
[16:18:46.626] getGlobalsAndPackages() ... DONE
[16:18:46.626] run() for ‘Future’ ...
[16:18:46.626] - state: ‘created’
[16:18:46.626] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.639] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.640]   - Field: ‘node’
[16:18:46.640]   - Field: ‘label’
[16:18:46.640]   - Field: ‘local’
[16:18:46.640]   - Field: ‘owner’
[16:18:46.640]   - Field: ‘envir’
[16:18:46.640]   - Field: ‘workers’
[16:18:46.640]   - Field: ‘packages’
[16:18:46.640]   - Field: ‘gc’
[16:18:46.640]   - Field: ‘conditions’
[16:18:46.641]   - Field: ‘persistent’
[16:18:46.641]   - Field: ‘expr’
[16:18:46.641]   - Field: ‘uuid’
[16:18:46.641]   - Field: ‘seed’
[16:18:46.641]   - Field: ‘version’
[16:18:46.641]   - Field: ‘result’
[16:18:46.641]   - Field: ‘asynchronous’
[16:18:46.641]   - Field: ‘calls’
[16:18:46.641]   - Field: ‘globals’
[16:18:46.641]   - Field: ‘stdout’
[16:18:46.641]   - Field: ‘earlySignal’
[16:18:46.642]   - Field: ‘lazy’
[16:18:46.642]   - Field: ‘state’
[16:18:46.642] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.642] - Launch lazy future ...
[16:18:46.642] Packages needed by the future expression (n = 0): <none>
[16:18:46.642] Packages needed by future strategies (n = 0): <none>
[16:18:46.643] {
[16:18:46.643]     {
[16:18:46.643]         {
[16:18:46.643]             ...future.startTime <- base::Sys.time()
[16:18:46.643]             {
[16:18:46.643]                 {
[16:18:46.643]                   {
[16:18:46.643]                     {
[16:18:46.643]                       base::local({
[16:18:46.643]                         has_future <- base::requireNamespace("future", 
[16:18:46.643]                           quietly = TRUE)
[16:18:46.643]                         if (has_future) {
[16:18:46.643]                           ns <- base::getNamespace("future")
[16:18:46.643]                           version <- ns[[".package"]][["version"]]
[16:18:46.643]                           if (is.null(version)) 
[16:18:46.643]                             version <- utils::packageVersion("future")
[16:18:46.643]                         }
[16:18:46.643]                         else {
[16:18:46.643]                           version <- NULL
[16:18:46.643]                         }
[16:18:46.643]                         if (!has_future || version < "1.8.0") {
[16:18:46.643]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.643]                             "", base::R.version$version.string), 
[16:18:46.643]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.643]                               "release", "version")], collapse = " "), 
[16:18:46.643]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.643]                             info)
[16:18:46.643]                           info <- base::paste(info, collapse = "; ")
[16:18:46.643]                           if (!has_future) {
[16:18:46.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.643]                               info)
[16:18:46.643]                           }
[16:18:46.643]                           else {
[16:18:46.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.643]                               info, version)
[16:18:46.643]                           }
[16:18:46.643]                           base::stop(msg)
[16:18:46.643]                         }
[16:18:46.643]                       })
[16:18:46.643]                     }
[16:18:46.643]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.643]                     base::options(mc.cores = 1L)
[16:18:46.643]                   }
[16:18:46.643]                   ...future.strategy.old <- future::plan("list")
[16:18:46.643]                   options(future.plan = NULL)
[16:18:46.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.643]                 }
[16:18:46.643]                 ...future.workdir <- getwd()
[16:18:46.643]             }
[16:18:46.643]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.643]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.643]         }
[16:18:46.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.643]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.643]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.643]             base::names(...future.oldOptions))
[16:18:46.643]     }
[16:18:46.643]     if (FALSE) {
[16:18:46.643]     }
[16:18:46.643]     else {
[16:18:46.643]         if (TRUE) {
[16:18:46.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.643]                 open = "w")
[16:18:46.643]         }
[16:18:46.643]         else {
[16:18:46.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.643]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.643]         }
[16:18:46.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.643]             base::sink(type = "output", split = FALSE)
[16:18:46.643]             base::close(...future.stdout)
[16:18:46.643]         }, add = TRUE)
[16:18:46.643]     }
[16:18:46.643]     ...future.frame <- base::sys.nframe()
[16:18:46.643]     ...future.conditions <- base::list()
[16:18:46.643]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.643]     if (FALSE) {
[16:18:46.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.643]     }
[16:18:46.643]     ...future.result <- base::tryCatch({
[16:18:46.643]         base::withCallingHandlers({
[16:18:46.643]             ...future.value <- base::withVisible(base::local({
[16:18:46.643]                 ...future.makeSendCondition <- base::local({
[16:18:46.643]                   sendCondition <- NULL
[16:18:46.643]                   function(frame = 1L) {
[16:18:46.643]                     if (is.function(sendCondition)) 
[16:18:46.643]                       return(sendCondition)
[16:18:46.643]                     ns <- getNamespace("parallel")
[16:18:46.643]                     if (exists("sendData", mode = "function", 
[16:18:46.643]                       envir = ns)) {
[16:18:46.643]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.643]                         envir = ns)
[16:18:46.643]                       envir <- sys.frame(frame)
[16:18:46.643]                       master <- NULL
[16:18:46.643]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.643]                         !identical(envir, emptyenv())) {
[16:18:46.643]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.643]                           inherits = FALSE)) {
[16:18:46.643]                           master <- get("master", mode = "list", 
[16:18:46.643]                             envir = envir, inherits = FALSE)
[16:18:46.643]                           if (inherits(master, c("SOCKnode", 
[16:18:46.643]                             "SOCK0node"))) {
[16:18:46.643]                             sendCondition <<- function(cond) {
[16:18:46.643]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.643]                                 success = TRUE)
[16:18:46.643]                               parallel_sendData(master, data)
[16:18:46.643]                             }
[16:18:46.643]                             return(sendCondition)
[16:18:46.643]                           }
[16:18:46.643]                         }
[16:18:46.643]                         frame <- frame + 1L
[16:18:46.643]                         envir <- sys.frame(frame)
[16:18:46.643]                       }
[16:18:46.643]                     }
[16:18:46.643]                     sendCondition <<- function(cond) NULL
[16:18:46.643]                   }
[16:18:46.643]                 })
[16:18:46.643]                 withCallingHandlers({
[16:18:46.643]                   {
[16:18:46.643]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.643]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.643]                       ...future.globals.maxSize)) {
[16:18:46.643]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.643]                       on.exit(options(oopts), add = TRUE)
[16:18:46.643]                     }
[16:18:46.643]                     {
[16:18:46.643]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.643]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.643]                         USE.NAMES = FALSE)
[16:18:46.643]                       do.call(mapply, args = args)
[16:18:46.643]                     }
[16:18:46.643]                   }
[16:18:46.643]                 }, immediateCondition = function(cond) {
[16:18:46.643]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.643]                   sendCondition(cond)
[16:18:46.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.643]                   {
[16:18:46.643]                     inherits <- base::inherits
[16:18:46.643]                     invokeRestart <- base::invokeRestart
[16:18:46.643]                     is.null <- base::is.null
[16:18:46.643]                     muffled <- FALSE
[16:18:46.643]                     if (inherits(cond, "message")) {
[16:18:46.643]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.643]                       if (muffled) 
[16:18:46.643]                         invokeRestart("muffleMessage")
[16:18:46.643]                     }
[16:18:46.643]                     else if (inherits(cond, "warning")) {
[16:18:46.643]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.643]                       if (muffled) 
[16:18:46.643]                         invokeRestart("muffleWarning")
[16:18:46.643]                     }
[16:18:46.643]                     else if (inherits(cond, "condition")) {
[16:18:46.643]                       if (!is.null(pattern)) {
[16:18:46.643]                         computeRestarts <- base::computeRestarts
[16:18:46.643]                         grepl <- base::grepl
[16:18:46.643]                         restarts <- computeRestarts(cond)
[16:18:46.643]                         for (restart in restarts) {
[16:18:46.643]                           name <- restart$name
[16:18:46.643]                           if (is.null(name)) 
[16:18:46.643]                             next
[16:18:46.643]                           if (!grepl(pattern, name)) 
[16:18:46.643]                             next
[16:18:46.643]                           invokeRestart(restart)
[16:18:46.643]                           muffled <- TRUE
[16:18:46.643]                           break
[16:18:46.643]                         }
[16:18:46.643]                       }
[16:18:46.643]                     }
[16:18:46.643]                     invisible(muffled)
[16:18:46.643]                   }
[16:18:46.643]                   muffleCondition(cond)
[16:18:46.643]                 })
[16:18:46.643]             }))
[16:18:46.643]             future::FutureResult(value = ...future.value$value, 
[16:18:46.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.643]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.643]                     ...future.globalenv.names))
[16:18:46.643]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.643]         }, condition = base::local({
[16:18:46.643]             c <- base::c
[16:18:46.643]             inherits <- base::inherits
[16:18:46.643]             invokeRestart <- base::invokeRestart
[16:18:46.643]             length <- base::length
[16:18:46.643]             list <- base::list
[16:18:46.643]             seq.int <- base::seq.int
[16:18:46.643]             signalCondition <- base::signalCondition
[16:18:46.643]             sys.calls <- base::sys.calls
[16:18:46.643]             `[[` <- base::`[[`
[16:18:46.643]             `+` <- base::`+`
[16:18:46.643]             `<<-` <- base::`<<-`
[16:18:46.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.643]                   3L)]
[16:18:46.643]             }
[16:18:46.643]             function(cond) {
[16:18:46.643]                 is_error <- inherits(cond, "error")
[16:18:46.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.643]                   NULL)
[16:18:46.643]                 if (is_error) {
[16:18:46.643]                   sessionInformation <- function() {
[16:18:46.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.643]                       search = base::search(), system = base::Sys.info())
[16:18:46.643]                   }
[16:18:46.643]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.643]                     cond$call), session = sessionInformation(), 
[16:18:46.643]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.643]                   signalCondition(cond)
[16:18:46.643]                 }
[16:18:46.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.643]                 "immediateCondition"))) {
[16:18:46.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.643]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.643]                   if (TRUE && !signal) {
[16:18:46.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.643]                     {
[16:18:46.643]                       inherits <- base::inherits
[16:18:46.643]                       invokeRestart <- base::invokeRestart
[16:18:46.643]                       is.null <- base::is.null
[16:18:46.643]                       muffled <- FALSE
[16:18:46.643]                       if (inherits(cond, "message")) {
[16:18:46.643]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.643]                         if (muffled) 
[16:18:46.643]                           invokeRestart("muffleMessage")
[16:18:46.643]                       }
[16:18:46.643]                       else if (inherits(cond, "warning")) {
[16:18:46.643]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.643]                         if (muffled) 
[16:18:46.643]                           invokeRestart("muffleWarning")
[16:18:46.643]                       }
[16:18:46.643]                       else if (inherits(cond, "condition")) {
[16:18:46.643]                         if (!is.null(pattern)) {
[16:18:46.643]                           computeRestarts <- base::computeRestarts
[16:18:46.643]                           grepl <- base::grepl
[16:18:46.643]                           restarts <- computeRestarts(cond)
[16:18:46.643]                           for (restart in restarts) {
[16:18:46.643]                             name <- restart$name
[16:18:46.643]                             if (is.null(name)) 
[16:18:46.643]                               next
[16:18:46.643]                             if (!grepl(pattern, name)) 
[16:18:46.643]                               next
[16:18:46.643]                             invokeRestart(restart)
[16:18:46.643]                             muffled <- TRUE
[16:18:46.643]                             break
[16:18:46.643]                           }
[16:18:46.643]                         }
[16:18:46.643]                       }
[16:18:46.643]                       invisible(muffled)
[16:18:46.643]                     }
[16:18:46.643]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.643]                   }
[16:18:46.643]                 }
[16:18:46.643]                 else {
[16:18:46.643]                   if (TRUE) {
[16:18:46.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.643]                     {
[16:18:46.643]                       inherits <- base::inherits
[16:18:46.643]                       invokeRestart <- base::invokeRestart
[16:18:46.643]                       is.null <- base::is.null
[16:18:46.643]                       muffled <- FALSE
[16:18:46.643]                       if (inherits(cond, "message")) {
[16:18:46.643]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.643]                         if (muffled) 
[16:18:46.643]                           invokeRestart("muffleMessage")
[16:18:46.643]                       }
[16:18:46.643]                       else if (inherits(cond, "warning")) {
[16:18:46.643]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.643]                         if (muffled) 
[16:18:46.643]                           invokeRestart("muffleWarning")
[16:18:46.643]                       }
[16:18:46.643]                       else if (inherits(cond, "condition")) {
[16:18:46.643]                         if (!is.null(pattern)) {
[16:18:46.643]                           computeRestarts <- base::computeRestarts
[16:18:46.643]                           grepl <- base::grepl
[16:18:46.643]                           restarts <- computeRestarts(cond)
[16:18:46.643]                           for (restart in restarts) {
[16:18:46.643]                             name <- restart$name
[16:18:46.643]                             if (is.null(name)) 
[16:18:46.643]                               next
[16:18:46.643]                             if (!grepl(pattern, name)) 
[16:18:46.643]                               next
[16:18:46.643]                             invokeRestart(restart)
[16:18:46.643]                             muffled <- TRUE
[16:18:46.643]                             break
[16:18:46.643]                           }
[16:18:46.643]                         }
[16:18:46.643]                       }
[16:18:46.643]                       invisible(muffled)
[16:18:46.643]                     }
[16:18:46.643]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.643]                   }
[16:18:46.643]                 }
[16:18:46.643]             }
[16:18:46.643]         }))
[16:18:46.643]     }, error = function(ex) {
[16:18:46.643]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.643]                 ...future.rng), started = ...future.startTime, 
[16:18:46.643]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.643]             version = "1.8"), class = "FutureResult")
[16:18:46.643]     }, finally = {
[16:18:46.643]         if (!identical(...future.workdir, getwd())) 
[16:18:46.643]             setwd(...future.workdir)
[16:18:46.643]         {
[16:18:46.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.643]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.643]             }
[16:18:46.643]             base::options(...future.oldOptions)
[16:18:46.643]             if (.Platform$OS.type == "windows") {
[16:18:46.643]                 old_names <- names(...future.oldEnvVars)
[16:18:46.643]                 envs <- base::Sys.getenv()
[16:18:46.643]                 names <- names(envs)
[16:18:46.643]                 common <- intersect(names, old_names)
[16:18:46.643]                 added <- setdiff(names, old_names)
[16:18:46.643]                 removed <- setdiff(old_names, names)
[16:18:46.643]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.643]                   envs[common]]
[16:18:46.643]                 NAMES <- toupper(changed)
[16:18:46.643]                 args <- list()
[16:18:46.643]                 for (kk in seq_along(NAMES)) {
[16:18:46.643]                   name <- changed[[kk]]
[16:18:46.643]                   NAME <- NAMES[[kk]]
[16:18:46.643]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.643]                     next
[16:18:46.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.643]                 }
[16:18:46.643]                 NAMES <- toupper(added)
[16:18:46.643]                 for (kk in seq_along(NAMES)) {
[16:18:46.643]                   name <- added[[kk]]
[16:18:46.643]                   NAME <- NAMES[[kk]]
[16:18:46.643]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.643]                     next
[16:18:46.643]                   args[[name]] <- ""
[16:18:46.643]                 }
[16:18:46.643]                 NAMES <- toupper(removed)
[16:18:46.643]                 for (kk in seq_along(NAMES)) {
[16:18:46.643]                   name <- removed[[kk]]
[16:18:46.643]                   NAME <- NAMES[[kk]]
[16:18:46.643]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.643]                     next
[16:18:46.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.643]                 }
[16:18:46.643]                 if (length(args) > 0) 
[16:18:46.643]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.643]             }
[16:18:46.643]             else {
[16:18:46.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.643]             }
[16:18:46.643]             {
[16:18:46.643]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.643]                   0L) {
[16:18:46.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.643]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.643]                   base::options(opts)
[16:18:46.643]                 }
[16:18:46.643]                 {
[16:18:46.643]                   {
[16:18:46.643]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.643]                     NULL
[16:18:46.643]                   }
[16:18:46.643]                   options(future.plan = NULL)
[16:18:46.643]                   if (is.na(NA_character_)) 
[16:18:46.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.643]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.643]                     .init = FALSE)
[16:18:46.643]                 }
[16:18:46.643]             }
[16:18:46.643]         }
[16:18:46.643]     })
[16:18:46.643]     if (TRUE) {
[16:18:46.643]         base::sink(type = "output", split = FALSE)
[16:18:46.643]         if (TRUE) {
[16:18:46.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.643]         }
[16:18:46.643]         else {
[16:18:46.643]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.643]         }
[16:18:46.643]         base::close(...future.stdout)
[16:18:46.643]         ...future.stdout <- NULL
[16:18:46.643]     }
[16:18:46.643]     ...future.result$conditions <- ...future.conditions
[16:18:46.643]     ...future.result$finished <- base::Sys.time()
[16:18:46.643]     ...future.result
[16:18:46.643] }
[16:18:46.645] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[16:18:46.645] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[16:18:46.646] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[16:18:46.646] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[16:18:46.646] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[16:18:46.646] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:18:46.646] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:18:46.647] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:46.647] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.647] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:46.647] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.647] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[16:18:46.648] MultisessionFuture started
[16:18:46.648] - Launch lazy future ... done
[16:18:46.648] run() for ‘MultisessionFuture’ ... done
[16:18:46.648] Created future:
[16:18:46.648] MultisessionFuture:
[16:18:46.648] Label: ‘future_.mapply-1’
[16:18:46.648] Expression:
[16:18:46.648] {
[16:18:46.648]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.648]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.648]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.648]         on.exit(options(oopts), add = TRUE)
[16:18:46.648]     }
[16:18:46.648]     {
[16:18:46.648]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.648]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.648]         do.call(mapply, args = args)
[16:18:46.648]     }
[16:18:46.648] }
[16:18:46.648] Lazy evaluation: FALSE
[16:18:46.648] Asynchronous evaluation: TRUE
[16:18:46.648] Local evaluation: TRUE
[16:18:46.648] Environment: R_GlobalEnv
[16:18:46.648] Capture standard output: TRUE
[16:18:46.648] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.648] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.648] Packages: <none>
[16:18:46.648] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:46.648] Resolved: FALSE
[16:18:46.648] Value: <not collected>
[16:18:46.648] Conditions captured: <none>
[16:18:46.648] Early signaling: FALSE
[16:18:46.648] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.648] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.660] Chunk #1 of 2 ... DONE
[16:18:46.660] Chunk #2 of 2 ...
[16:18:46.660]  - Finding globals in '...' for chunk #2 ...
[16:18:46.660] getGlobalsAndPackages() ...
[16:18:46.660] Searching for globals...
[16:18:46.660] 
[16:18:46.660] Searching for globals ... DONE
[16:18:46.661] - globals: [0] <none>
[16:18:46.661] getGlobalsAndPackages() ... DONE
[16:18:46.661]    + additional globals found: [n=0] 
[16:18:46.661]    + additional namespaces needed: [n=0] 
[16:18:46.661]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:46.661]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.661]  - seeds: <none>
[16:18:46.661]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.661] getGlobalsAndPackages() ...
[16:18:46.661] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.662] Resolving globals: FALSE
[16:18:46.662] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[16:18:46.662] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[16:18:46.663] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.663] 
[16:18:46.663] getGlobalsAndPackages() ... DONE
[16:18:46.663] run() for ‘Future’ ...
[16:18:46.663] - state: ‘created’
[16:18:46.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.677] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.677]   - Field: ‘node’
[16:18:46.677]   - Field: ‘label’
[16:18:46.677]   - Field: ‘local’
[16:18:46.677]   - Field: ‘owner’
[16:18:46.677]   - Field: ‘envir’
[16:18:46.677]   - Field: ‘workers’
[16:18:46.678]   - Field: ‘packages’
[16:18:46.678]   - Field: ‘gc’
[16:18:46.678]   - Field: ‘conditions’
[16:18:46.678]   - Field: ‘persistent’
[16:18:46.678]   - Field: ‘expr’
[16:18:46.678]   - Field: ‘uuid’
[16:18:46.678]   - Field: ‘seed’
[16:18:46.678]   - Field: ‘version’
[16:18:46.678]   - Field: ‘result’
[16:18:46.678]   - Field: ‘asynchronous’
[16:18:46.678]   - Field: ‘calls’
[16:18:46.678]   - Field: ‘globals’
[16:18:46.679]   - Field: ‘stdout’
[16:18:46.679]   - Field: ‘earlySignal’
[16:18:46.679]   - Field: ‘lazy’
[16:18:46.679]   - Field: ‘state’
[16:18:46.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.679] - Launch lazy future ...
[16:18:46.679] Packages needed by the future expression (n = 0): <none>
[16:18:46.679] Packages needed by future strategies (n = 0): <none>
[16:18:46.680] {
[16:18:46.680]     {
[16:18:46.680]         {
[16:18:46.680]             ...future.startTime <- base::Sys.time()
[16:18:46.680]             {
[16:18:46.680]                 {
[16:18:46.680]                   {
[16:18:46.680]                     {
[16:18:46.680]                       base::local({
[16:18:46.680]                         has_future <- base::requireNamespace("future", 
[16:18:46.680]                           quietly = TRUE)
[16:18:46.680]                         if (has_future) {
[16:18:46.680]                           ns <- base::getNamespace("future")
[16:18:46.680]                           version <- ns[[".package"]][["version"]]
[16:18:46.680]                           if (is.null(version)) 
[16:18:46.680]                             version <- utils::packageVersion("future")
[16:18:46.680]                         }
[16:18:46.680]                         else {
[16:18:46.680]                           version <- NULL
[16:18:46.680]                         }
[16:18:46.680]                         if (!has_future || version < "1.8.0") {
[16:18:46.680]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.680]                             "", base::R.version$version.string), 
[16:18:46.680]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.680]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.680]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.680]                               "release", "version")], collapse = " "), 
[16:18:46.680]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.680]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.680]                             info)
[16:18:46.680]                           info <- base::paste(info, collapse = "; ")
[16:18:46.680]                           if (!has_future) {
[16:18:46.680]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.680]                               info)
[16:18:46.680]                           }
[16:18:46.680]                           else {
[16:18:46.680]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.680]                               info, version)
[16:18:46.680]                           }
[16:18:46.680]                           base::stop(msg)
[16:18:46.680]                         }
[16:18:46.680]                       })
[16:18:46.680]                     }
[16:18:46.680]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.680]                     base::options(mc.cores = 1L)
[16:18:46.680]                   }
[16:18:46.680]                   ...future.strategy.old <- future::plan("list")
[16:18:46.680]                   options(future.plan = NULL)
[16:18:46.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.680]                 }
[16:18:46.680]                 ...future.workdir <- getwd()
[16:18:46.680]             }
[16:18:46.680]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.680]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.680]         }
[16:18:46.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.680]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.680]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.680]             base::names(...future.oldOptions))
[16:18:46.680]     }
[16:18:46.680]     if (FALSE) {
[16:18:46.680]     }
[16:18:46.680]     else {
[16:18:46.680]         if (TRUE) {
[16:18:46.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.680]                 open = "w")
[16:18:46.680]         }
[16:18:46.680]         else {
[16:18:46.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.680]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.680]         }
[16:18:46.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.680]             base::sink(type = "output", split = FALSE)
[16:18:46.680]             base::close(...future.stdout)
[16:18:46.680]         }, add = TRUE)
[16:18:46.680]     }
[16:18:46.680]     ...future.frame <- base::sys.nframe()
[16:18:46.680]     ...future.conditions <- base::list()
[16:18:46.680]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.680]     if (FALSE) {
[16:18:46.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.680]     }
[16:18:46.680]     ...future.result <- base::tryCatch({
[16:18:46.680]         base::withCallingHandlers({
[16:18:46.680]             ...future.value <- base::withVisible(base::local({
[16:18:46.680]                 ...future.makeSendCondition <- base::local({
[16:18:46.680]                   sendCondition <- NULL
[16:18:46.680]                   function(frame = 1L) {
[16:18:46.680]                     if (is.function(sendCondition)) 
[16:18:46.680]                       return(sendCondition)
[16:18:46.680]                     ns <- getNamespace("parallel")
[16:18:46.680]                     if (exists("sendData", mode = "function", 
[16:18:46.680]                       envir = ns)) {
[16:18:46.680]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.680]                         envir = ns)
[16:18:46.680]                       envir <- sys.frame(frame)
[16:18:46.680]                       master <- NULL
[16:18:46.680]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.680]                         !identical(envir, emptyenv())) {
[16:18:46.680]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.680]                           inherits = FALSE)) {
[16:18:46.680]                           master <- get("master", mode = "list", 
[16:18:46.680]                             envir = envir, inherits = FALSE)
[16:18:46.680]                           if (inherits(master, c("SOCKnode", 
[16:18:46.680]                             "SOCK0node"))) {
[16:18:46.680]                             sendCondition <<- function(cond) {
[16:18:46.680]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.680]                                 success = TRUE)
[16:18:46.680]                               parallel_sendData(master, data)
[16:18:46.680]                             }
[16:18:46.680]                             return(sendCondition)
[16:18:46.680]                           }
[16:18:46.680]                         }
[16:18:46.680]                         frame <- frame + 1L
[16:18:46.680]                         envir <- sys.frame(frame)
[16:18:46.680]                       }
[16:18:46.680]                     }
[16:18:46.680]                     sendCondition <<- function(cond) NULL
[16:18:46.680]                   }
[16:18:46.680]                 })
[16:18:46.680]                 withCallingHandlers({
[16:18:46.680]                   {
[16:18:46.680]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.680]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.680]                       ...future.globals.maxSize)) {
[16:18:46.680]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.680]                       on.exit(options(oopts), add = TRUE)
[16:18:46.680]                     }
[16:18:46.680]                     {
[16:18:46.680]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.680]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.680]                         USE.NAMES = FALSE)
[16:18:46.680]                       do.call(mapply, args = args)
[16:18:46.680]                     }
[16:18:46.680]                   }
[16:18:46.680]                 }, immediateCondition = function(cond) {
[16:18:46.680]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.680]                   sendCondition(cond)
[16:18:46.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.680]                   {
[16:18:46.680]                     inherits <- base::inherits
[16:18:46.680]                     invokeRestart <- base::invokeRestart
[16:18:46.680]                     is.null <- base::is.null
[16:18:46.680]                     muffled <- FALSE
[16:18:46.680]                     if (inherits(cond, "message")) {
[16:18:46.680]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.680]                       if (muffled) 
[16:18:46.680]                         invokeRestart("muffleMessage")
[16:18:46.680]                     }
[16:18:46.680]                     else if (inherits(cond, "warning")) {
[16:18:46.680]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.680]                       if (muffled) 
[16:18:46.680]                         invokeRestart("muffleWarning")
[16:18:46.680]                     }
[16:18:46.680]                     else if (inherits(cond, "condition")) {
[16:18:46.680]                       if (!is.null(pattern)) {
[16:18:46.680]                         computeRestarts <- base::computeRestarts
[16:18:46.680]                         grepl <- base::grepl
[16:18:46.680]                         restarts <- computeRestarts(cond)
[16:18:46.680]                         for (restart in restarts) {
[16:18:46.680]                           name <- restart$name
[16:18:46.680]                           if (is.null(name)) 
[16:18:46.680]                             next
[16:18:46.680]                           if (!grepl(pattern, name)) 
[16:18:46.680]                             next
[16:18:46.680]                           invokeRestart(restart)
[16:18:46.680]                           muffled <- TRUE
[16:18:46.680]                           break
[16:18:46.680]                         }
[16:18:46.680]                       }
[16:18:46.680]                     }
[16:18:46.680]                     invisible(muffled)
[16:18:46.680]                   }
[16:18:46.680]                   muffleCondition(cond)
[16:18:46.680]                 })
[16:18:46.680]             }))
[16:18:46.680]             future::FutureResult(value = ...future.value$value, 
[16:18:46.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.680]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.680]                     ...future.globalenv.names))
[16:18:46.680]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.680]         }, condition = base::local({
[16:18:46.680]             c <- base::c
[16:18:46.680]             inherits <- base::inherits
[16:18:46.680]             invokeRestart <- base::invokeRestart
[16:18:46.680]             length <- base::length
[16:18:46.680]             list <- base::list
[16:18:46.680]             seq.int <- base::seq.int
[16:18:46.680]             signalCondition <- base::signalCondition
[16:18:46.680]             sys.calls <- base::sys.calls
[16:18:46.680]             `[[` <- base::`[[`
[16:18:46.680]             `+` <- base::`+`
[16:18:46.680]             `<<-` <- base::`<<-`
[16:18:46.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.680]                   3L)]
[16:18:46.680]             }
[16:18:46.680]             function(cond) {
[16:18:46.680]                 is_error <- inherits(cond, "error")
[16:18:46.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.680]                   NULL)
[16:18:46.680]                 if (is_error) {
[16:18:46.680]                   sessionInformation <- function() {
[16:18:46.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.680]                       search = base::search(), system = base::Sys.info())
[16:18:46.680]                   }
[16:18:46.680]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.680]                     cond$call), session = sessionInformation(), 
[16:18:46.680]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.680]                   signalCondition(cond)
[16:18:46.680]                 }
[16:18:46.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.680]                 "immediateCondition"))) {
[16:18:46.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.680]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.680]                   if (TRUE && !signal) {
[16:18:46.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.680]                     {
[16:18:46.680]                       inherits <- base::inherits
[16:18:46.680]                       invokeRestart <- base::invokeRestart
[16:18:46.680]                       is.null <- base::is.null
[16:18:46.680]                       muffled <- FALSE
[16:18:46.680]                       if (inherits(cond, "message")) {
[16:18:46.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.680]                         if (muffled) 
[16:18:46.680]                           invokeRestart("muffleMessage")
[16:18:46.680]                       }
[16:18:46.680]                       else if (inherits(cond, "warning")) {
[16:18:46.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.680]                         if (muffled) 
[16:18:46.680]                           invokeRestart("muffleWarning")
[16:18:46.680]                       }
[16:18:46.680]                       else if (inherits(cond, "condition")) {
[16:18:46.680]                         if (!is.null(pattern)) {
[16:18:46.680]                           computeRestarts <- base::computeRestarts
[16:18:46.680]                           grepl <- base::grepl
[16:18:46.680]                           restarts <- computeRestarts(cond)
[16:18:46.680]                           for (restart in restarts) {
[16:18:46.680]                             name <- restart$name
[16:18:46.680]                             if (is.null(name)) 
[16:18:46.680]                               next
[16:18:46.680]                             if (!grepl(pattern, name)) 
[16:18:46.680]                               next
[16:18:46.680]                             invokeRestart(restart)
[16:18:46.680]                             muffled <- TRUE
[16:18:46.680]                             break
[16:18:46.680]                           }
[16:18:46.680]                         }
[16:18:46.680]                       }
[16:18:46.680]                       invisible(muffled)
[16:18:46.680]                     }
[16:18:46.680]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.680]                   }
[16:18:46.680]                 }
[16:18:46.680]                 else {
[16:18:46.680]                   if (TRUE) {
[16:18:46.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.680]                     {
[16:18:46.680]                       inherits <- base::inherits
[16:18:46.680]                       invokeRestart <- base::invokeRestart
[16:18:46.680]                       is.null <- base::is.null
[16:18:46.680]                       muffled <- FALSE
[16:18:46.680]                       if (inherits(cond, "message")) {
[16:18:46.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.680]                         if (muffled) 
[16:18:46.680]                           invokeRestart("muffleMessage")
[16:18:46.680]                       }
[16:18:46.680]                       else if (inherits(cond, "warning")) {
[16:18:46.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.680]                         if (muffled) 
[16:18:46.680]                           invokeRestart("muffleWarning")
[16:18:46.680]                       }
[16:18:46.680]                       else if (inherits(cond, "condition")) {
[16:18:46.680]                         if (!is.null(pattern)) {
[16:18:46.680]                           computeRestarts <- base::computeRestarts
[16:18:46.680]                           grepl <- base::grepl
[16:18:46.680]                           restarts <- computeRestarts(cond)
[16:18:46.680]                           for (restart in restarts) {
[16:18:46.680]                             name <- restart$name
[16:18:46.680]                             if (is.null(name)) 
[16:18:46.680]                               next
[16:18:46.680]                             if (!grepl(pattern, name)) 
[16:18:46.680]                               next
[16:18:46.680]                             invokeRestart(restart)
[16:18:46.680]                             muffled <- TRUE
[16:18:46.680]                             break
[16:18:46.680]                           }
[16:18:46.680]                         }
[16:18:46.680]                       }
[16:18:46.680]                       invisible(muffled)
[16:18:46.680]                     }
[16:18:46.680]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.680]                   }
[16:18:46.680]                 }
[16:18:46.680]             }
[16:18:46.680]         }))
[16:18:46.680]     }, error = function(ex) {
[16:18:46.680]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.680]                 ...future.rng), started = ...future.startTime, 
[16:18:46.680]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.680]             version = "1.8"), class = "FutureResult")
[16:18:46.680]     }, finally = {
[16:18:46.680]         if (!identical(...future.workdir, getwd())) 
[16:18:46.680]             setwd(...future.workdir)
[16:18:46.680]         {
[16:18:46.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.680]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.680]             }
[16:18:46.680]             base::options(...future.oldOptions)
[16:18:46.680]             if (.Platform$OS.type == "windows") {
[16:18:46.680]                 old_names <- names(...future.oldEnvVars)
[16:18:46.680]                 envs <- base::Sys.getenv()
[16:18:46.680]                 names <- names(envs)
[16:18:46.680]                 common <- intersect(names, old_names)
[16:18:46.680]                 added <- setdiff(names, old_names)
[16:18:46.680]                 removed <- setdiff(old_names, names)
[16:18:46.680]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.680]                   envs[common]]
[16:18:46.680]                 NAMES <- toupper(changed)
[16:18:46.680]                 args <- list()
[16:18:46.680]                 for (kk in seq_along(NAMES)) {
[16:18:46.680]                   name <- changed[[kk]]
[16:18:46.680]                   NAME <- NAMES[[kk]]
[16:18:46.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.680]                     next
[16:18:46.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.680]                 }
[16:18:46.680]                 NAMES <- toupper(added)
[16:18:46.680]                 for (kk in seq_along(NAMES)) {
[16:18:46.680]                   name <- added[[kk]]
[16:18:46.680]                   NAME <- NAMES[[kk]]
[16:18:46.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.680]                     next
[16:18:46.680]                   args[[name]] <- ""
[16:18:46.680]                 }
[16:18:46.680]                 NAMES <- toupper(removed)
[16:18:46.680]                 for (kk in seq_along(NAMES)) {
[16:18:46.680]                   name <- removed[[kk]]
[16:18:46.680]                   NAME <- NAMES[[kk]]
[16:18:46.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.680]                     next
[16:18:46.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.680]                 }
[16:18:46.680]                 if (length(args) > 0) 
[16:18:46.680]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.680]             }
[16:18:46.680]             else {
[16:18:46.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.680]             }
[16:18:46.680]             {
[16:18:46.680]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.680]                   0L) {
[16:18:46.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.680]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.680]                   base::options(opts)
[16:18:46.680]                 }
[16:18:46.680]                 {
[16:18:46.680]                   {
[16:18:46.680]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.680]                     NULL
[16:18:46.680]                   }
[16:18:46.680]                   options(future.plan = NULL)
[16:18:46.680]                   if (is.na(NA_character_)) 
[16:18:46.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.680]                     .init = FALSE)
[16:18:46.680]                 }
[16:18:46.680]             }
[16:18:46.680]         }
[16:18:46.680]     })
[16:18:46.680]     if (TRUE) {
[16:18:46.680]         base::sink(type = "output", split = FALSE)
[16:18:46.680]         if (TRUE) {
[16:18:46.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.680]         }
[16:18:46.680]         else {
[16:18:46.680]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.680]         }
[16:18:46.680]         base::close(...future.stdout)
[16:18:46.680]         ...future.stdout <- NULL
[16:18:46.680]     }
[16:18:46.680]     ...future.result$conditions <- ...future.conditions
[16:18:46.680]     ...future.result$finished <- base::Sys.time()
[16:18:46.680]     ...future.result
[16:18:46.680] }
[16:18:46.682] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[16:18:46.683] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[16:18:46.683] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[16:18:46.683] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[16:18:46.683] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[16:18:46.683] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:18:46.684] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:18:46.684] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:46.684] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.684] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:46.685] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.685] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[16:18:46.685] MultisessionFuture started
[16:18:46.685] - Launch lazy future ... done
[16:18:46.685] run() for ‘MultisessionFuture’ ... done
[16:18:46.686] Created future:
[16:18:46.686] MultisessionFuture:
[16:18:46.686] Label: ‘future_.mapply-2’
[16:18:46.686] Expression:
[16:18:46.686] {
[16:18:46.686]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.686]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.686]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.686]         on.exit(options(oopts), add = TRUE)
[16:18:46.686]     }
[16:18:46.686]     {
[16:18:46.686]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.686]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.686]         do.call(mapply, args = args)
[16:18:46.686]     }
[16:18:46.686] }
[16:18:46.686] Lazy evaluation: FALSE
[16:18:46.686] Asynchronous evaluation: TRUE
[16:18:46.686] Local evaluation: TRUE
[16:18:46.686] Environment: R_GlobalEnv
[16:18:46.686] Capture standard output: TRUE
[16:18:46.686] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.686] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.686] Packages: <none>
[16:18:46.686] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:46.686] Resolved: FALSE
[16:18:46.686] Value: <not collected>
[16:18:46.686] Conditions captured: <none>
[16:18:46.686] Early signaling: FALSE
[16:18:46.686] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.686] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.697] Chunk #2 of 2 ... DONE
[16:18:46.697] Launching 2 futures (chunks) ... DONE
[16:18:46.697] Resolving 2 futures (chunks) ...
[16:18:46.697] resolve() on list ...
[16:18:46.697]  recursive: 0
[16:18:46.697]  length: 2
[16:18:46.698] 
[16:18:46.698] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.698] - Validating connection of MultisessionFuture
[16:18:46.698] - received message: FutureResult
[16:18:46.698] - Received FutureResult
[16:18:46.699] - Erased future from FutureRegistry
[16:18:46.699] result() for ClusterFuture ...
[16:18:46.699] - result already collected: FutureResult
[16:18:46.699] result() for ClusterFuture ... done
[16:18:46.699] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.699] Future #1
[16:18:46.699] result() for ClusterFuture ...
[16:18:46.699] - result already collected: FutureResult
[16:18:46.699] result() for ClusterFuture ... done
[16:18:46.699] result() for ClusterFuture ...
[16:18:46.699] - result already collected: FutureResult
[16:18:46.700] result() for ClusterFuture ... done
[16:18:46.700] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:46.700] - nx: 2
[16:18:46.700] - relay: TRUE
[16:18:46.700] - stdout: TRUE
[16:18:46.700] - signal: TRUE
[16:18:46.700] - resignal: FALSE
[16:18:46.700] - force: TRUE
[16:18:46.700] - relayed: [n=2] FALSE, FALSE
[16:18:46.700] - queued futures: [n=2] FALSE, FALSE
[16:18:46.700]  - until=1
[16:18:46.701]  - relaying element #1
[16:18:46.701] result() for ClusterFuture ...
[16:18:46.701] - result already collected: FutureResult
[16:18:46.701] result() for ClusterFuture ... done
[16:18:46.701] result() for ClusterFuture ...
[16:18:46.701] - result already collected: FutureResult
[16:18:46.701] result() for ClusterFuture ... done
[16:18:46.701] result() for ClusterFuture ...
[16:18:46.701] - result already collected: FutureResult
[16:18:46.701] result() for ClusterFuture ... done
[16:18:46.702] result() for ClusterFuture ...
[16:18:46.702] - result already collected: FutureResult
[16:18:46.702] result() for ClusterFuture ... done
[16:18:46.702] - relayed: [n=2] TRUE, FALSE
[16:18:46.702] - queued futures: [n=2] TRUE, FALSE
[16:18:46.702] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:46.702]  length: 1 (resolved future 1)
[16:18:46.730] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.730] - Validating connection of MultisessionFuture
[16:18:46.730] - received message: FutureResult
[16:18:46.730] - Received FutureResult
[16:18:46.730] - Erased future from FutureRegistry
[16:18:46.730] result() for ClusterFuture ...
[16:18:46.731] - result already collected: FutureResult
[16:18:46.731] result() for ClusterFuture ... done
[16:18:46.731] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.731] Future #2
[16:18:46.731] result() for ClusterFuture ...
[16:18:46.731] - result already collected: FutureResult
[16:18:46.731] result() for ClusterFuture ... done
[16:18:46.731] result() for ClusterFuture ...
[16:18:46.731] - result already collected: FutureResult
[16:18:46.731] result() for ClusterFuture ... done
[16:18:46.732] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:46.732] - nx: 2
[16:18:46.732] - relay: TRUE
[16:18:46.732] - stdout: TRUE
[16:18:46.732] - signal: TRUE
[16:18:46.732] - resignal: FALSE
[16:18:46.732] - force: TRUE
[16:18:46.732] - relayed: [n=2] TRUE, FALSE
[16:18:46.732] - queued futures: [n=2] TRUE, FALSE
[16:18:46.732]  - until=2
[16:18:46.732]  - relaying element #2
[16:18:46.733] result() for ClusterFuture ...
[16:18:46.733] - result already collected: FutureResult
[16:18:46.733] result() for ClusterFuture ... done
[16:18:46.733] result() for ClusterFuture ...
[16:18:46.733] - result already collected: FutureResult
[16:18:46.733] result() for ClusterFuture ... done
[16:18:46.733] result() for ClusterFuture ...
[16:18:46.733] - result already collected: FutureResult
[16:18:46.733] result() for ClusterFuture ... done
[16:18:46.733] result() for ClusterFuture ...
[16:18:46.733] - result already collected: FutureResult
[16:18:46.734] result() for ClusterFuture ... done
[16:18:46.734] - relayed: [n=2] TRUE, TRUE
[16:18:46.734] - queued futures: [n=2] TRUE, TRUE
[16:18:46.734] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:46.734]  length: 0 (resolved future 2)
[16:18:46.734] Relaying remaining futures
[16:18:46.734] signalConditionsASAP(NULL, pos=0) ...
[16:18:46.734] - nx: 2
[16:18:46.734] - relay: TRUE
[16:18:46.734] - stdout: TRUE
[16:18:46.735] - signal: TRUE
[16:18:46.735] - resignal: FALSE
[16:18:46.735] - force: TRUE
[16:18:46.735] - relayed: [n=2] TRUE, TRUE
[16:18:46.735] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:46.735] - relayed: [n=2] TRUE, TRUE
[16:18:46.735] - queued futures: [n=2] TRUE, TRUE
[16:18:46.735] signalConditionsASAP(NULL, pos=0) ... done
[16:18:46.735] resolve() on list ... DONE
[16:18:46.735] result() for ClusterFuture ...
[16:18:46.735] - result already collected: FutureResult
[16:18:46.736] result() for ClusterFuture ... done
[16:18:46.736] result() for ClusterFuture ...
[16:18:46.736] - result already collected: FutureResult
[16:18:46.736] result() for ClusterFuture ... done
[16:18:46.736] result() for ClusterFuture ...
[16:18:46.736] - result already collected: FutureResult
[16:18:46.736] result() for ClusterFuture ... done
[16:18:46.736] result() for ClusterFuture ...
[16:18:46.736] - result already collected: FutureResult
[16:18:46.736] result() for ClusterFuture ... done
[16:18:46.736]  - Number of value chunks collected: 2
[16:18:46.737] Resolving 2 futures (chunks) ... DONE
[16:18:46.737] Reducing values from 2 chunks ...
[16:18:46.737]  - Number of values collected after concatenation: 2
[16:18:46.737]  - Number of values expected: 2
[16:18:46.737] Reducing values from 2 chunks ... DONE
[16:18:46.737] future_mapply() ... DONE
- Recycle arguments to same length ...
[16:18:46.737] future_mapply() ...
[16:18:46.741] Number of chunks: 2
[16:18:46.741] getGlobalsAndPackagesXApply() ...
[16:18:46.741]  - future.globals: TRUE
[16:18:46.741] getGlobalsAndPackages() ...
[16:18:46.741] Searching for globals...
[16:18:46.742] - globals found: [1] ‘FUN’
[16:18:46.742] Searching for globals ... DONE
[16:18:46.742] Resolving globals: FALSE
[16:18:46.742] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:46.743] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:46.743] - globals: [1] ‘FUN’
[16:18:46.743] 
[16:18:46.743] getGlobalsAndPackages() ... DONE
[16:18:46.743]  - globals found/used: [n=1] ‘FUN’
[16:18:46.743]  - needed namespaces: [n=0] 
[16:18:46.743] Finding globals ... DONE
[16:18:46.744] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:46.744] List of 2
[16:18:46.744]  $ ...future.FUN:function (x, ...)  
[16:18:46.744]  $ MoreArgs     : NULL
[16:18:46.744]  - attr(*, "where")=List of 2
[16:18:46.744]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:46.744]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:46.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:46.744]  - attr(*, "resolved")= logi FALSE
[16:18:46.744]  - attr(*, "total_size")= num NA
[16:18:46.746] Packages to be attached in all futures: [n=0] 
[16:18:46.746] getGlobalsAndPackagesXApply() ... DONE
[16:18:46.747] Number of futures (= number of chunks): 2
[16:18:46.747] Launching 2 futures (chunks) ...
[16:18:46.747] Chunk #1 of 2 ...
[16:18:46.747]  - Finding globals in '...' for chunk #1 ...
[16:18:46.747] getGlobalsAndPackages() ...
[16:18:46.747] Searching for globals...
[16:18:46.747] 
[16:18:46.748] Searching for globals ... DONE
[16:18:46.748] - globals: [0] <none>
[16:18:46.748] getGlobalsAndPackages() ... DONE
[16:18:46.748]    + additional globals found: [n=0] 
[16:18:46.748]    + additional namespaces needed: [n=0] 
[16:18:46.748]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:46.748]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.748]  - seeds: <none>
[16:18:46.748]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.748] getGlobalsAndPackages() ...
[16:18:46.749] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.749] Resolving globals: FALSE
[16:18:46.749] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:46.752] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:46.753] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.753] 
[16:18:46.753] getGlobalsAndPackages() ... DONE
[16:18:46.753] run() for ‘Future’ ...
[16:18:46.753] - state: ‘created’
[16:18:46.753] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.767] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.767]   - Field: ‘node’
[16:18:46.767]   - Field: ‘label’
[16:18:46.767]   - Field: ‘local’
[16:18:46.767]   - Field: ‘owner’
[16:18:46.767]   - Field: ‘envir’
[16:18:46.768]   - Field: ‘workers’
[16:18:46.768]   - Field: ‘packages’
[16:18:46.768]   - Field: ‘gc’
[16:18:46.768]   - Field: ‘conditions’
[16:18:46.768]   - Field: ‘persistent’
[16:18:46.768]   - Field: ‘expr’
[16:18:46.768]   - Field: ‘uuid’
[16:18:46.768]   - Field: ‘seed’
[16:18:46.768]   - Field: ‘version’
[16:18:46.768]   - Field: ‘result’
[16:18:46.769]   - Field: ‘asynchronous’
[16:18:46.769]   - Field: ‘calls’
[16:18:46.769]   - Field: ‘globals’
[16:18:46.769]   - Field: ‘stdout’
[16:18:46.769]   - Field: ‘earlySignal’
[16:18:46.769]   - Field: ‘lazy’
[16:18:46.769]   - Field: ‘state’
[16:18:46.769] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.769] - Launch lazy future ...
[16:18:46.769] Packages needed by the future expression (n = 0): <none>
[16:18:46.770] Packages needed by future strategies (n = 0): <none>
[16:18:46.770] {
[16:18:46.770]     {
[16:18:46.770]         {
[16:18:46.770]             ...future.startTime <- base::Sys.time()
[16:18:46.770]             {
[16:18:46.770]                 {
[16:18:46.770]                   {
[16:18:46.770]                     {
[16:18:46.770]                       base::local({
[16:18:46.770]                         has_future <- base::requireNamespace("future", 
[16:18:46.770]                           quietly = TRUE)
[16:18:46.770]                         if (has_future) {
[16:18:46.770]                           ns <- base::getNamespace("future")
[16:18:46.770]                           version <- ns[[".package"]][["version"]]
[16:18:46.770]                           if (is.null(version)) 
[16:18:46.770]                             version <- utils::packageVersion("future")
[16:18:46.770]                         }
[16:18:46.770]                         else {
[16:18:46.770]                           version <- NULL
[16:18:46.770]                         }
[16:18:46.770]                         if (!has_future || version < "1.8.0") {
[16:18:46.770]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.770]                             "", base::R.version$version.string), 
[16:18:46.770]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.770]                               "release", "version")], collapse = " "), 
[16:18:46.770]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.770]                             info)
[16:18:46.770]                           info <- base::paste(info, collapse = "; ")
[16:18:46.770]                           if (!has_future) {
[16:18:46.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.770]                               info)
[16:18:46.770]                           }
[16:18:46.770]                           else {
[16:18:46.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.770]                               info, version)
[16:18:46.770]                           }
[16:18:46.770]                           base::stop(msg)
[16:18:46.770]                         }
[16:18:46.770]                       })
[16:18:46.770]                     }
[16:18:46.770]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.770]                     base::options(mc.cores = 1L)
[16:18:46.770]                   }
[16:18:46.770]                   ...future.strategy.old <- future::plan("list")
[16:18:46.770]                   options(future.plan = NULL)
[16:18:46.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.770]                 }
[16:18:46.770]                 ...future.workdir <- getwd()
[16:18:46.770]             }
[16:18:46.770]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.770]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.770]         }
[16:18:46.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.770]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.770]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.770]             base::names(...future.oldOptions))
[16:18:46.770]     }
[16:18:46.770]     if (FALSE) {
[16:18:46.770]     }
[16:18:46.770]     else {
[16:18:46.770]         if (TRUE) {
[16:18:46.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.770]                 open = "w")
[16:18:46.770]         }
[16:18:46.770]         else {
[16:18:46.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.770]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.770]         }
[16:18:46.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.770]             base::sink(type = "output", split = FALSE)
[16:18:46.770]             base::close(...future.stdout)
[16:18:46.770]         }, add = TRUE)
[16:18:46.770]     }
[16:18:46.770]     ...future.frame <- base::sys.nframe()
[16:18:46.770]     ...future.conditions <- base::list()
[16:18:46.770]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.770]     if (FALSE) {
[16:18:46.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.770]     }
[16:18:46.770]     ...future.result <- base::tryCatch({
[16:18:46.770]         base::withCallingHandlers({
[16:18:46.770]             ...future.value <- base::withVisible(base::local({
[16:18:46.770]                 ...future.makeSendCondition <- base::local({
[16:18:46.770]                   sendCondition <- NULL
[16:18:46.770]                   function(frame = 1L) {
[16:18:46.770]                     if (is.function(sendCondition)) 
[16:18:46.770]                       return(sendCondition)
[16:18:46.770]                     ns <- getNamespace("parallel")
[16:18:46.770]                     if (exists("sendData", mode = "function", 
[16:18:46.770]                       envir = ns)) {
[16:18:46.770]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.770]                         envir = ns)
[16:18:46.770]                       envir <- sys.frame(frame)
[16:18:46.770]                       master <- NULL
[16:18:46.770]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.770]                         !identical(envir, emptyenv())) {
[16:18:46.770]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.770]                           inherits = FALSE)) {
[16:18:46.770]                           master <- get("master", mode = "list", 
[16:18:46.770]                             envir = envir, inherits = FALSE)
[16:18:46.770]                           if (inherits(master, c("SOCKnode", 
[16:18:46.770]                             "SOCK0node"))) {
[16:18:46.770]                             sendCondition <<- function(cond) {
[16:18:46.770]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.770]                                 success = TRUE)
[16:18:46.770]                               parallel_sendData(master, data)
[16:18:46.770]                             }
[16:18:46.770]                             return(sendCondition)
[16:18:46.770]                           }
[16:18:46.770]                         }
[16:18:46.770]                         frame <- frame + 1L
[16:18:46.770]                         envir <- sys.frame(frame)
[16:18:46.770]                       }
[16:18:46.770]                     }
[16:18:46.770]                     sendCondition <<- function(cond) NULL
[16:18:46.770]                   }
[16:18:46.770]                 })
[16:18:46.770]                 withCallingHandlers({
[16:18:46.770]                   {
[16:18:46.770]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.770]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.770]                       ...future.globals.maxSize)) {
[16:18:46.770]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.770]                       on.exit(options(oopts), add = TRUE)
[16:18:46.770]                     }
[16:18:46.770]                     {
[16:18:46.770]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.770]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.770]                         USE.NAMES = FALSE)
[16:18:46.770]                       do.call(mapply, args = args)
[16:18:46.770]                     }
[16:18:46.770]                   }
[16:18:46.770]                 }, immediateCondition = function(cond) {
[16:18:46.770]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.770]                   sendCondition(cond)
[16:18:46.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.770]                   {
[16:18:46.770]                     inherits <- base::inherits
[16:18:46.770]                     invokeRestart <- base::invokeRestart
[16:18:46.770]                     is.null <- base::is.null
[16:18:46.770]                     muffled <- FALSE
[16:18:46.770]                     if (inherits(cond, "message")) {
[16:18:46.770]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.770]                       if (muffled) 
[16:18:46.770]                         invokeRestart("muffleMessage")
[16:18:46.770]                     }
[16:18:46.770]                     else if (inherits(cond, "warning")) {
[16:18:46.770]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.770]                       if (muffled) 
[16:18:46.770]                         invokeRestart("muffleWarning")
[16:18:46.770]                     }
[16:18:46.770]                     else if (inherits(cond, "condition")) {
[16:18:46.770]                       if (!is.null(pattern)) {
[16:18:46.770]                         computeRestarts <- base::computeRestarts
[16:18:46.770]                         grepl <- base::grepl
[16:18:46.770]                         restarts <- computeRestarts(cond)
[16:18:46.770]                         for (restart in restarts) {
[16:18:46.770]                           name <- restart$name
[16:18:46.770]                           if (is.null(name)) 
[16:18:46.770]                             next
[16:18:46.770]                           if (!grepl(pattern, name)) 
[16:18:46.770]                             next
[16:18:46.770]                           invokeRestart(restart)
[16:18:46.770]                           muffled <- TRUE
[16:18:46.770]                           break
[16:18:46.770]                         }
[16:18:46.770]                       }
[16:18:46.770]                     }
[16:18:46.770]                     invisible(muffled)
[16:18:46.770]                   }
[16:18:46.770]                   muffleCondition(cond)
[16:18:46.770]                 })
[16:18:46.770]             }))
[16:18:46.770]             future::FutureResult(value = ...future.value$value, 
[16:18:46.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.770]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.770]                     ...future.globalenv.names))
[16:18:46.770]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.770]         }, condition = base::local({
[16:18:46.770]             c <- base::c
[16:18:46.770]             inherits <- base::inherits
[16:18:46.770]             invokeRestart <- base::invokeRestart
[16:18:46.770]             length <- base::length
[16:18:46.770]             list <- base::list
[16:18:46.770]             seq.int <- base::seq.int
[16:18:46.770]             signalCondition <- base::signalCondition
[16:18:46.770]             sys.calls <- base::sys.calls
[16:18:46.770]             `[[` <- base::`[[`
[16:18:46.770]             `+` <- base::`+`
[16:18:46.770]             `<<-` <- base::`<<-`
[16:18:46.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.770]                   3L)]
[16:18:46.770]             }
[16:18:46.770]             function(cond) {
[16:18:46.770]                 is_error <- inherits(cond, "error")
[16:18:46.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.770]                   NULL)
[16:18:46.770]                 if (is_error) {
[16:18:46.770]                   sessionInformation <- function() {
[16:18:46.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.770]                       search = base::search(), system = base::Sys.info())
[16:18:46.770]                   }
[16:18:46.770]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.770]                     cond$call), session = sessionInformation(), 
[16:18:46.770]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.770]                   signalCondition(cond)
[16:18:46.770]                 }
[16:18:46.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.770]                 "immediateCondition"))) {
[16:18:46.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.770]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.770]                   if (TRUE && !signal) {
[16:18:46.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.770]                     {
[16:18:46.770]                       inherits <- base::inherits
[16:18:46.770]                       invokeRestart <- base::invokeRestart
[16:18:46.770]                       is.null <- base::is.null
[16:18:46.770]                       muffled <- FALSE
[16:18:46.770]                       if (inherits(cond, "message")) {
[16:18:46.770]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.770]                         if (muffled) 
[16:18:46.770]                           invokeRestart("muffleMessage")
[16:18:46.770]                       }
[16:18:46.770]                       else if (inherits(cond, "warning")) {
[16:18:46.770]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.770]                         if (muffled) 
[16:18:46.770]                           invokeRestart("muffleWarning")
[16:18:46.770]                       }
[16:18:46.770]                       else if (inherits(cond, "condition")) {
[16:18:46.770]                         if (!is.null(pattern)) {
[16:18:46.770]                           computeRestarts <- base::computeRestarts
[16:18:46.770]                           grepl <- base::grepl
[16:18:46.770]                           restarts <- computeRestarts(cond)
[16:18:46.770]                           for (restart in restarts) {
[16:18:46.770]                             name <- restart$name
[16:18:46.770]                             if (is.null(name)) 
[16:18:46.770]                               next
[16:18:46.770]                             if (!grepl(pattern, name)) 
[16:18:46.770]                               next
[16:18:46.770]                             invokeRestart(restart)
[16:18:46.770]                             muffled <- TRUE
[16:18:46.770]                             break
[16:18:46.770]                           }
[16:18:46.770]                         }
[16:18:46.770]                       }
[16:18:46.770]                       invisible(muffled)
[16:18:46.770]                     }
[16:18:46.770]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.770]                   }
[16:18:46.770]                 }
[16:18:46.770]                 else {
[16:18:46.770]                   if (TRUE) {
[16:18:46.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.770]                     {
[16:18:46.770]                       inherits <- base::inherits
[16:18:46.770]                       invokeRestart <- base::invokeRestart
[16:18:46.770]                       is.null <- base::is.null
[16:18:46.770]                       muffled <- FALSE
[16:18:46.770]                       if (inherits(cond, "message")) {
[16:18:46.770]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.770]                         if (muffled) 
[16:18:46.770]                           invokeRestart("muffleMessage")
[16:18:46.770]                       }
[16:18:46.770]                       else if (inherits(cond, "warning")) {
[16:18:46.770]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.770]                         if (muffled) 
[16:18:46.770]                           invokeRestart("muffleWarning")
[16:18:46.770]                       }
[16:18:46.770]                       else if (inherits(cond, "condition")) {
[16:18:46.770]                         if (!is.null(pattern)) {
[16:18:46.770]                           computeRestarts <- base::computeRestarts
[16:18:46.770]                           grepl <- base::grepl
[16:18:46.770]                           restarts <- computeRestarts(cond)
[16:18:46.770]                           for (restart in restarts) {
[16:18:46.770]                             name <- restart$name
[16:18:46.770]                             if (is.null(name)) 
[16:18:46.770]                               next
[16:18:46.770]                             if (!grepl(pattern, name)) 
[16:18:46.770]                               next
[16:18:46.770]                             invokeRestart(restart)
[16:18:46.770]                             muffled <- TRUE
[16:18:46.770]                             break
[16:18:46.770]                           }
[16:18:46.770]                         }
[16:18:46.770]                       }
[16:18:46.770]                       invisible(muffled)
[16:18:46.770]                     }
[16:18:46.770]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.770]                   }
[16:18:46.770]                 }
[16:18:46.770]             }
[16:18:46.770]         }))
[16:18:46.770]     }, error = function(ex) {
[16:18:46.770]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.770]                 ...future.rng), started = ...future.startTime, 
[16:18:46.770]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.770]             version = "1.8"), class = "FutureResult")
[16:18:46.770]     }, finally = {
[16:18:46.770]         if (!identical(...future.workdir, getwd())) 
[16:18:46.770]             setwd(...future.workdir)
[16:18:46.770]         {
[16:18:46.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.770]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.770]             }
[16:18:46.770]             base::options(...future.oldOptions)
[16:18:46.770]             if (.Platform$OS.type == "windows") {
[16:18:46.770]                 old_names <- names(...future.oldEnvVars)
[16:18:46.770]                 envs <- base::Sys.getenv()
[16:18:46.770]                 names <- names(envs)
[16:18:46.770]                 common <- intersect(names, old_names)
[16:18:46.770]                 added <- setdiff(names, old_names)
[16:18:46.770]                 removed <- setdiff(old_names, names)
[16:18:46.770]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.770]                   envs[common]]
[16:18:46.770]                 NAMES <- toupper(changed)
[16:18:46.770]                 args <- list()
[16:18:46.770]                 for (kk in seq_along(NAMES)) {
[16:18:46.770]                   name <- changed[[kk]]
[16:18:46.770]                   NAME <- NAMES[[kk]]
[16:18:46.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.770]                     next
[16:18:46.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.770]                 }
[16:18:46.770]                 NAMES <- toupper(added)
[16:18:46.770]                 for (kk in seq_along(NAMES)) {
[16:18:46.770]                   name <- added[[kk]]
[16:18:46.770]                   NAME <- NAMES[[kk]]
[16:18:46.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.770]                     next
[16:18:46.770]                   args[[name]] <- ""
[16:18:46.770]                 }
[16:18:46.770]                 NAMES <- toupper(removed)
[16:18:46.770]                 for (kk in seq_along(NAMES)) {
[16:18:46.770]                   name <- removed[[kk]]
[16:18:46.770]                   NAME <- NAMES[[kk]]
[16:18:46.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.770]                     next
[16:18:46.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.770]                 }
[16:18:46.770]                 if (length(args) > 0) 
[16:18:46.770]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.770]             }
[16:18:46.770]             else {
[16:18:46.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.770]             }
[16:18:46.770]             {
[16:18:46.770]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.770]                   0L) {
[16:18:46.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.770]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.770]                   base::options(opts)
[16:18:46.770]                 }
[16:18:46.770]                 {
[16:18:46.770]                   {
[16:18:46.770]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.770]                     NULL
[16:18:46.770]                   }
[16:18:46.770]                   options(future.plan = NULL)
[16:18:46.770]                   if (is.na(NA_character_)) 
[16:18:46.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.770]                     .init = FALSE)
[16:18:46.770]                 }
[16:18:46.770]             }
[16:18:46.770]         }
[16:18:46.770]     })
[16:18:46.770]     if (TRUE) {
[16:18:46.770]         base::sink(type = "output", split = FALSE)
[16:18:46.770]         if (TRUE) {
[16:18:46.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.770]         }
[16:18:46.770]         else {
[16:18:46.770]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.770]         }
[16:18:46.770]         base::close(...future.stdout)
[16:18:46.770]         ...future.stdout <- NULL
[16:18:46.770]     }
[16:18:46.770]     ...future.result$conditions <- ...future.conditions
[16:18:46.770]     ...future.result$finished <- base::Sys.time()
[16:18:46.770]     ...future.result
[16:18:46.770] }
[16:18:46.773] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[16:18:46.773] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[16:18:46.773] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[16:18:46.773] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:46.774] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.774] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[16:18:46.774] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[16:18:46.774] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:46.774] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.775] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:46.775] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.775] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[16:18:46.775] MultisessionFuture started
[16:18:46.776] - Launch lazy future ... done
[16:18:46.776] run() for ‘MultisessionFuture’ ... done
[16:18:46.776] Created future:
[16:18:46.776] MultisessionFuture:
[16:18:46.776] Label: ‘future_mapply-1’
[16:18:46.776] Expression:
[16:18:46.776] {
[16:18:46.776]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.776]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.776]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.776]         on.exit(options(oopts), add = TRUE)
[16:18:46.776]     }
[16:18:46.776]     {
[16:18:46.776]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.776]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.776]         do.call(mapply, args = args)
[16:18:46.776]     }
[16:18:46.776] }
[16:18:46.776] Lazy evaluation: FALSE
[16:18:46.776] Asynchronous evaluation: TRUE
[16:18:46.776] Local evaluation: TRUE
[16:18:46.776] Environment: R_GlobalEnv
[16:18:46.776] Capture standard output: TRUE
[16:18:46.776] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.776] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.776] Packages: <none>
[16:18:46.776] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:46.776] Resolved: FALSE
[16:18:46.776] Value: <not collected>
[16:18:46.776] Conditions captured: <none>
[16:18:46.776] Early signaling: FALSE
[16:18:46.776] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.776] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.787] Chunk #1 of 2 ... DONE
[16:18:46.787] Chunk #2 of 2 ...
[16:18:46.787]  - Finding globals in '...' for chunk #2 ...
[16:18:46.788] getGlobalsAndPackages() ...
[16:18:46.788] Searching for globals...
[16:18:46.788] 
[16:18:46.788] Searching for globals ... DONE
[16:18:46.788] - globals: [0] <none>
[16:18:46.788] getGlobalsAndPackages() ... DONE
[16:18:46.788]    + additional globals found: [n=0] 
[16:18:46.789]    + additional namespaces needed: [n=0] 
[16:18:46.789]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:46.789]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.789]  - seeds: <none>
[16:18:46.789]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.789] getGlobalsAndPackages() ...
[16:18:46.789] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.789] Resolving globals: FALSE
[16:18:46.790] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:46.790] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:46.790] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.790] 
[16:18:46.790] getGlobalsAndPackages() ... DONE
[16:18:46.791] run() for ‘Future’ ...
[16:18:46.791] - state: ‘created’
[16:18:46.791] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.804] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.804] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.804]   - Field: ‘node’
[16:18:46.804]   - Field: ‘label’
[16:18:46.805]   - Field: ‘local’
[16:18:46.805]   - Field: ‘owner’
[16:18:46.805]   - Field: ‘envir’
[16:18:46.805]   - Field: ‘workers’
[16:18:46.805]   - Field: ‘packages’
[16:18:46.805]   - Field: ‘gc’
[16:18:46.805]   - Field: ‘conditions’
[16:18:46.805]   - Field: ‘persistent’
[16:18:46.805]   - Field: ‘expr’
[16:18:46.805]   - Field: ‘uuid’
[16:18:46.805]   - Field: ‘seed’
[16:18:46.806]   - Field: ‘version’
[16:18:46.806]   - Field: ‘result’
[16:18:46.806]   - Field: ‘asynchronous’
[16:18:46.806]   - Field: ‘calls’
[16:18:46.806]   - Field: ‘globals’
[16:18:46.806]   - Field: ‘stdout’
[16:18:46.806]   - Field: ‘earlySignal’
[16:18:46.806]   - Field: ‘lazy’
[16:18:46.806]   - Field: ‘state’
[16:18:46.806] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.806] - Launch lazy future ...
[16:18:46.807] Packages needed by the future expression (n = 0): <none>
[16:18:46.807] Packages needed by future strategies (n = 0): <none>
[16:18:46.807] {
[16:18:46.807]     {
[16:18:46.807]         {
[16:18:46.807]             ...future.startTime <- base::Sys.time()
[16:18:46.807]             {
[16:18:46.807]                 {
[16:18:46.807]                   {
[16:18:46.807]                     {
[16:18:46.807]                       base::local({
[16:18:46.807]                         has_future <- base::requireNamespace("future", 
[16:18:46.807]                           quietly = TRUE)
[16:18:46.807]                         if (has_future) {
[16:18:46.807]                           ns <- base::getNamespace("future")
[16:18:46.807]                           version <- ns[[".package"]][["version"]]
[16:18:46.807]                           if (is.null(version)) 
[16:18:46.807]                             version <- utils::packageVersion("future")
[16:18:46.807]                         }
[16:18:46.807]                         else {
[16:18:46.807]                           version <- NULL
[16:18:46.807]                         }
[16:18:46.807]                         if (!has_future || version < "1.8.0") {
[16:18:46.807]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.807]                             "", base::R.version$version.string), 
[16:18:46.807]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:46.807]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:46.807]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.807]                               "release", "version")], collapse = " "), 
[16:18:46.807]                             hostname = base::Sys.info()[["nodename"]])
[16:18:46.807]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.807]                             info)
[16:18:46.807]                           info <- base::paste(info, collapse = "; ")
[16:18:46.807]                           if (!has_future) {
[16:18:46.807]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.807]                               info)
[16:18:46.807]                           }
[16:18:46.807]                           else {
[16:18:46.807]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.807]                               info, version)
[16:18:46.807]                           }
[16:18:46.807]                           base::stop(msg)
[16:18:46.807]                         }
[16:18:46.807]                       })
[16:18:46.807]                     }
[16:18:46.807]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.807]                     base::options(mc.cores = 1L)
[16:18:46.807]                   }
[16:18:46.807]                   ...future.strategy.old <- future::plan("list")
[16:18:46.807]                   options(future.plan = NULL)
[16:18:46.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.807]                 }
[16:18:46.807]                 ...future.workdir <- getwd()
[16:18:46.807]             }
[16:18:46.807]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.807]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.807]         }
[16:18:46.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.807]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.807]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.807]             base::names(...future.oldOptions))
[16:18:46.807]     }
[16:18:46.807]     if (FALSE) {
[16:18:46.807]     }
[16:18:46.807]     else {
[16:18:46.807]         if (TRUE) {
[16:18:46.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.807]                 open = "w")
[16:18:46.807]         }
[16:18:46.807]         else {
[16:18:46.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.807]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.807]         }
[16:18:46.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.807]             base::sink(type = "output", split = FALSE)
[16:18:46.807]             base::close(...future.stdout)
[16:18:46.807]         }, add = TRUE)
[16:18:46.807]     }
[16:18:46.807]     ...future.frame <- base::sys.nframe()
[16:18:46.807]     ...future.conditions <- base::list()
[16:18:46.807]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.807]     if (FALSE) {
[16:18:46.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.807]     }
[16:18:46.807]     ...future.result <- base::tryCatch({
[16:18:46.807]         base::withCallingHandlers({
[16:18:46.807]             ...future.value <- base::withVisible(base::local({
[16:18:46.807]                 ...future.makeSendCondition <- base::local({
[16:18:46.807]                   sendCondition <- NULL
[16:18:46.807]                   function(frame = 1L) {
[16:18:46.807]                     if (is.function(sendCondition)) 
[16:18:46.807]                       return(sendCondition)
[16:18:46.807]                     ns <- getNamespace("parallel")
[16:18:46.807]                     if (exists("sendData", mode = "function", 
[16:18:46.807]                       envir = ns)) {
[16:18:46.807]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.807]                         envir = ns)
[16:18:46.807]                       envir <- sys.frame(frame)
[16:18:46.807]                       master <- NULL
[16:18:46.807]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.807]                         !identical(envir, emptyenv())) {
[16:18:46.807]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.807]                           inherits = FALSE)) {
[16:18:46.807]                           master <- get("master", mode = "list", 
[16:18:46.807]                             envir = envir, inherits = FALSE)
[16:18:46.807]                           if (inherits(master, c("SOCKnode", 
[16:18:46.807]                             "SOCK0node"))) {
[16:18:46.807]                             sendCondition <<- function(cond) {
[16:18:46.807]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.807]                                 success = TRUE)
[16:18:46.807]                               parallel_sendData(master, data)
[16:18:46.807]                             }
[16:18:46.807]                             return(sendCondition)
[16:18:46.807]                           }
[16:18:46.807]                         }
[16:18:46.807]                         frame <- frame + 1L
[16:18:46.807]                         envir <- sys.frame(frame)
[16:18:46.807]                       }
[16:18:46.807]                     }
[16:18:46.807]                     sendCondition <<- function(cond) NULL
[16:18:46.807]                   }
[16:18:46.807]                 })
[16:18:46.807]                 withCallingHandlers({
[16:18:46.807]                   {
[16:18:46.807]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.807]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.807]                       ...future.globals.maxSize)) {
[16:18:46.807]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.807]                       on.exit(options(oopts), add = TRUE)
[16:18:46.807]                     }
[16:18:46.807]                     {
[16:18:46.807]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.807]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.807]                         USE.NAMES = FALSE)
[16:18:46.807]                       do.call(mapply, args = args)
[16:18:46.807]                     }
[16:18:46.807]                   }
[16:18:46.807]                 }, immediateCondition = function(cond) {
[16:18:46.807]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.807]                   sendCondition(cond)
[16:18:46.807]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.807]                   {
[16:18:46.807]                     inherits <- base::inherits
[16:18:46.807]                     invokeRestart <- base::invokeRestart
[16:18:46.807]                     is.null <- base::is.null
[16:18:46.807]                     muffled <- FALSE
[16:18:46.807]                     if (inherits(cond, "message")) {
[16:18:46.807]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.807]                       if (muffled) 
[16:18:46.807]                         invokeRestart("muffleMessage")
[16:18:46.807]                     }
[16:18:46.807]                     else if (inherits(cond, "warning")) {
[16:18:46.807]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.807]                       if (muffled) 
[16:18:46.807]                         invokeRestart("muffleWarning")
[16:18:46.807]                     }
[16:18:46.807]                     else if (inherits(cond, "condition")) {
[16:18:46.807]                       if (!is.null(pattern)) {
[16:18:46.807]                         computeRestarts <- base::computeRestarts
[16:18:46.807]                         grepl <- base::grepl
[16:18:46.807]                         restarts <- computeRestarts(cond)
[16:18:46.807]                         for (restart in restarts) {
[16:18:46.807]                           name <- restart$name
[16:18:46.807]                           if (is.null(name)) 
[16:18:46.807]                             next
[16:18:46.807]                           if (!grepl(pattern, name)) 
[16:18:46.807]                             next
[16:18:46.807]                           invokeRestart(restart)
[16:18:46.807]                           muffled <- TRUE
[16:18:46.807]                           break
[16:18:46.807]                         }
[16:18:46.807]                       }
[16:18:46.807]                     }
[16:18:46.807]                     invisible(muffled)
[16:18:46.807]                   }
[16:18:46.807]                   muffleCondition(cond)
[16:18:46.807]                 })
[16:18:46.807]             }))
[16:18:46.807]             future::FutureResult(value = ...future.value$value, 
[16:18:46.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.807]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.807]                     ...future.globalenv.names))
[16:18:46.807]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.807]         }, condition = base::local({
[16:18:46.807]             c <- base::c
[16:18:46.807]             inherits <- base::inherits
[16:18:46.807]             invokeRestart <- base::invokeRestart
[16:18:46.807]             length <- base::length
[16:18:46.807]             list <- base::list
[16:18:46.807]             seq.int <- base::seq.int
[16:18:46.807]             signalCondition <- base::signalCondition
[16:18:46.807]             sys.calls <- base::sys.calls
[16:18:46.807]             `[[` <- base::`[[`
[16:18:46.807]             `+` <- base::`+`
[16:18:46.807]             `<<-` <- base::`<<-`
[16:18:46.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.807]                   3L)]
[16:18:46.807]             }
[16:18:46.807]             function(cond) {
[16:18:46.807]                 is_error <- inherits(cond, "error")
[16:18:46.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.807]                   NULL)
[16:18:46.807]                 if (is_error) {
[16:18:46.807]                   sessionInformation <- function() {
[16:18:46.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.807]                       search = base::search(), system = base::Sys.info())
[16:18:46.807]                   }
[16:18:46.807]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.807]                     cond$call), session = sessionInformation(), 
[16:18:46.807]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.807]                   signalCondition(cond)
[16:18:46.807]                 }
[16:18:46.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.807]                 "immediateCondition"))) {
[16:18:46.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.807]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.807]                   if (TRUE && !signal) {
[16:18:46.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.807]                     {
[16:18:46.807]                       inherits <- base::inherits
[16:18:46.807]                       invokeRestart <- base::invokeRestart
[16:18:46.807]                       is.null <- base::is.null
[16:18:46.807]                       muffled <- FALSE
[16:18:46.807]                       if (inherits(cond, "message")) {
[16:18:46.807]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.807]                         if (muffled) 
[16:18:46.807]                           invokeRestart("muffleMessage")
[16:18:46.807]                       }
[16:18:46.807]                       else if (inherits(cond, "warning")) {
[16:18:46.807]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.807]                         if (muffled) 
[16:18:46.807]                           invokeRestart("muffleWarning")
[16:18:46.807]                       }
[16:18:46.807]                       else if (inherits(cond, "condition")) {
[16:18:46.807]                         if (!is.null(pattern)) {
[16:18:46.807]                           computeRestarts <- base::computeRestarts
[16:18:46.807]                           grepl <- base::grepl
[16:18:46.807]                           restarts <- computeRestarts(cond)
[16:18:46.807]                           for (restart in restarts) {
[16:18:46.807]                             name <- restart$name
[16:18:46.807]                             if (is.null(name)) 
[16:18:46.807]                               next
[16:18:46.807]                             if (!grepl(pattern, name)) 
[16:18:46.807]                               next
[16:18:46.807]                             invokeRestart(restart)
[16:18:46.807]                             muffled <- TRUE
[16:18:46.807]                             break
[16:18:46.807]                           }
[16:18:46.807]                         }
[16:18:46.807]                       }
[16:18:46.807]                       invisible(muffled)
[16:18:46.807]                     }
[16:18:46.807]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.807]                   }
[16:18:46.807]                 }
[16:18:46.807]                 else {
[16:18:46.807]                   if (TRUE) {
[16:18:46.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.807]                     {
[16:18:46.807]                       inherits <- base::inherits
[16:18:46.807]                       invokeRestart <- base::invokeRestart
[16:18:46.807]                       is.null <- base::is.null
[16:18:46.807]                       muffled <- FALSE
[16:18:46.807]                       if (inherits(cond, "message")) {
[16:18:46.807]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.807]                         if (muffled) 
[16:18:46.807]                           invokeRestart("muffleMessage")
[16:18:46.807]                       }
[16:18:46.807]                       else if (inherits(cond, "warning")) {
[16:18:46.807]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.807]                         if (muffled) 
[16:18:46.807]                           invokeRestart("muffleWarning")
[16:18:46.807]                       }
[16:18:46.807]                       else if (inherits(cond, "condition")) {
[16:18:46.807]                         if (!is.null(pattern)) {
[16:18:46.807]                           computeRestarts <- base::computeRestarts
[16:18:46.807]                           grepl <- base::grepl
[16:18:46.807]                           restarts <- computeRestarts(cond)
[16:18:46.807]                           for (restart in restarts) {
[16:18:46.807]                             name <- restart$name
[16:18:46.807]                             if (is.null(name)) 
[16:18:46.807]                               next
[16:18:46.807]                             if (!grepl(pattern, name)) 
[16:18:46.807]                               next
[16:18:46.807]                             invokeRestart(restart)
[16:18:46.807]                             muffled <- TRUE
[16:18:46.807]                             break
[16:18:46.807]                           }
[16:18:46.807]                         }
[16:18:46.807]                       }
[16:18:46.807]                       invisible(muffled)
[16:18:46.807]                     }
[16:18:46.807]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.807]                   }
[16:18:46.807]                 }
[16:18:46.807]             }
[16:18:46.807]         }))
[16:18:46.807]     }, error = function(ex) {
[16:18:46.807]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.807]                 ...future.rng), started = ...future.startTime, 
[16:18:46.807]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.807]             version = "1.8"), class = "FutureResult")
[16:18:46.807]     }, finally = {
[16:18:46.807]         if (!identical(...future.workdir, getwd())) 
[16:18:46.807]             setwd(...future.workdir)
[16:18:46.807]         {
[16:18:46.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.807]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.807]             }
[16:18:46.807]             base::options(...future.oldOptions)
[16:18:46.807]             if (.Platform$OS.type == "windows") {
[16:18:46.807]                 old_names <- names(...future.oldEnvVars)
[16:18:46.807]                 envs <- base::Sys.getenv()
[16:18:46.807]                 names <- names(envs)
[16:18:46.807]                 common <- intersect(names, old_names)
[16:18:46.807]                 added <- setdiff(names, old_names)
[16:18:46.807]                 removed <- setdiff(old_names, names)
[16:18:46.807]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.807]                   envs[common]]
[16:18:46.807]                 NAMES <- toupper(changed)
[16:18:46.807]                 args <- list()
[16:18:46.807]                 for (kk in seq_along(NAMES)) {
[16:18:46.807]                   name <- changed[[kk]]
[16:18:46.807]                   NAME <- NAMES[[kk]]
[16:18:46.807]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.807]                     next
[16:18:46.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.807]                 }
[16:18:46.807]                 NAMES <- toupper(added)
[16:18:46.807]                 for (kk in seq_along(NAMES)) {
[16:18:46.807]                   name <- added[[kk]]
[16:18:46.807]                   NAME <- NAMES[[kk]]
[16:18:46.807]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.807]                     next
[16:18:46.807]                   args[[name]] <- ""
[16:18:46.807]                 }
[16:18:46.807]                 NAMES <- toupper(removed)
[16:18:46.807]                 for (kk in seq_along(NAMES)) {
[16:18:46.807]                   name <- removed[[kk]]
[16:18:46.807]                   NAME <- NAMES[[kk]]
[16:18:46.807]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.807]                     next
[16:18:46.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.807]                 }
[16:18:46.807]                 if (length(args) > 0) 
[16:18:46.807]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.807]             }
[16:18:46.807]             else {
[16:18:46.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.807]             }
[16:18:46.807]             {
[16:18:46.807]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.807]                   0L) {
[16:18:46.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.807]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.807]                   base::options(opts)
[16:18:46.807]                 }
[16:18:46.807]                 {
[16:18:46.807]                   {
[16:18:46.807]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.807]                     NULL
[16:18:46.807]                   }
[16:18:46.807]                   options(future.plan = NULL)
[16:18:46.807]                   if (is.na(NA_character_)) 
[16:18:46.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.807]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.807]                     .init = FALSE)
[16:18:46.807]                 }
[16:18:46.807]             }
[16:18:46.807]         }
[16:18:46.807]     })
[16:18:46.807]     if (TRUE) {
[16:18:46.807]         base::sink(type = "output", split = FALSE)
[16:18:46.807]         if (TRUE) {
[16:18:46.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.807]         }
[16:18:46.807]         else {
[16:18:46.807]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.807]         }
[16:18:46.807]         base::close(...future.stdout)
[16:18:46.807]         ...future.stdout <- NULL
[16:18:46.807]     }
[16:18:46.807]     ...future.result$conditions <- ...future.conditions
[16:18:46.807]     ...future.result$finished <- base::Sys.time()
[16:18:46.807]     ...future.result
[16:18:46.807] }
[16:18:46.810] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[16:18:46.810] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[16:18:46.810] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[16:18:46.810] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:46.811] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.811] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[16:18:46.811] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[16:18:46.811] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:46.811] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.812] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:46.812] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.812] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[16:18:46.812] MultisessionFuture started
[16:18:46.813] - Launch lazy future ... done
[16:18:46.813] run() for ‘MultisessionFuture’ ... done
[16:18:46.813] Created future:
[16:18:46.813] MultisessionFuture:
[16:18:46.813] Label: ‘future_mapply-2’
[16:18:46.813] Expression:
[16:18:46.813] {
[16:18:46.813]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.813]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.813]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.813]         on.exit(options(oopts), add = TRUE)
[16:18:46.813]     }
[16:18:46.813]     {
[16:18:46.813]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:46.813]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.813]         do.call(mapply, args = args)
[16:18:46.813]     }
[16:18:46.813] }
[16:18:46.813] Lazy evaluation: FALSE
[16:18:46.813] Asynchronous evaluation: TRUE
[16:18:46.813] Local evaluation: TRUE
[16:18:46.813] Environment: R_GlobalEnv
[16:18:46.813] Capture standard output: TRUE
[16:18:46.813] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.813] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.813] Packages: <none>
[16:18:46.813] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:46.813] Resolved: FALSE
[16:18:46.813] Value: <not collected>
[16:18:46.813] Conditions captured: <none>
[16:18:46.813] Early signaling: FALSE
[16:18:46.813] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.813] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.824] Chunk #2 of 2 ... DONE
[16:18:46.824] Launching 2 futures (chunks) ... DONE
[16:18:46.824] Resolving 2 futures (chunks) ...
[16:18:46.825] resolve() on list ...
[16:18:46.825]  recursive: 0
[16:18:46.825]  length: 2
[16:18:46.825] 
[16:18:46.825] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.826] - Validating connection of MultisessionFuture
[16:18:46.826] - received message: FutureResult
[16:18:46.826] - Received FutureResult
[16:18:46.826] - Erased future from FutureRegistry
[16:18:46.826] result() for ClusterFuture ...
[16:18:46.826] - result already collected: FutureResult
[16:18:46.826] result() for ClusterFuture ... done
[16:18:46.826] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.826] Future #1
[16:18:46.826] result() for ClusterFuture ...
[16:18:46.827] - result already collected: FutureResult
[16:18:46.827] result() for ClusterFuture ... done
[16:18:46.827] result() for ClusterFuture ...
[16:18:46.827] - result already collected: FutureResult
[16:18:46.827] result() for ClusterFuture ... done
[16:18:46.827] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:46.827] - nx: 2
[16:18:46.827] - relay: TRUE
[16:18:46.827] - stdout: TRUE
[16:18:46.827] - signal: TRUE
[16:18:46.827] - resignal: FALSE
[16:18:46.828] - force: TRUE
[16:18:46.828] - relayed: [n=2] FALSE, FALSE
[16:18:46.828] - queued futures: [n=2] FALSE, FALSE
[16:18:46.828]  - until=1
[16:18:46.828]  - relaying element #1
[16:18:46.828] result() for ClusterFuture ...
[16:18:46.828] - result already collected: FutureResult
[16:18:46.828] result() for ClusterFuture ... done
[16:18:46.828] result() for ClusterFuture ...
[16:18:46.828] - result already collected: FutureResult
[16:18:46.828] result() for ClusterFuture ... done
[16:18:46.829] result() for ClusterFuture ...
[16:18:46.829] - result already collected: FutureResult
[16:18:46.829] result() for ClusterFuture ... done
[16:18:46.829] result() for ClusterFuture ...
[16:18:46.829] - result already collected: FutureResult
[16:18:46.829] result() for ClusterFuture ... done
[16:18:46.829] - relayed: [n=2] TRUE, FALSE
[16:18:46.829] - queued futures: [n=2] TRUE, FALSE
[16:18:46.829] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:46.829]  length: 1 (resolved future 1)
[16:18:46.858] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.858] - Validating connection of MultisessionFuture
[16:18:46.858] - received message: FutureResult
[16:18:46.858] - Received FutureResult
[16:18:46.859] - Erased future from FutureRegistry
[16:18:46.859] result() for ClusterFuture ...
[16:18:46.859] - result already collected: FutureResult
[16:18:46.859] result() for ClusterFuture ... done
[16:18:46.859] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.859] Future #2
[16:18:46.859] result() for ClusterFuture ...
[16:18:46.859] - result already collected: FutureResult
[16:18:46.859] result() for ClusterFuture ... done
[16:18:46.859] result() for ClusterFuture ...
[16:18:46.860] - result already collected: FutureResult
[16:18:46.860] result() for ClusterFuture ... done
[16:18:46.860] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:46.860] - nx: 2
[16:18:46.860] - relay: TRUE
[16:18:46.860] - stdout: TRUE
[16:18:46.860] - signal: TRUE
[16:18:46.860] - resignal: FALSE
[16:18:46.860] - force: TRUE
[16:18:46.860] - relayed: [n=2] TRUE, FALSE
[16:18:46.860] - queued futures: [n=2] TRUE, FALSE
[16:18:46.861]  - until=2
[16:18:46.861]  - relaying element #2
[16:18:46.861] result() for ClusterFuture ...
[16:18:46.861] - result already collected: FutureResult
[16:18:46.861] result() for ClusterFuture ... done
[16:18:46.861] result() for ClusterFuture ...
[16:18:46.861] - result already collected: FutureResult
[16:18:46.861] result() for ClusterFuture ... done
[16:18:46.861] result() for ClusterFuture ...
[16:18:46.861] - result already collected: FutureResult
[16:18:46.861] result() for ClusterFuture ... done
[16:18:46.862] result() for ClusterFuture ...
[16:18:46.862] - result already collected: FutureResult
[16:18:46.862] result() for ClusterFuture ... done
[16:18:46.862] - relayed: [n=2] TRUE, TRUE
[16:18:46.862] - queued futures: [n=2] TRUE, TRUE
[16:18:46.862] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:46.862]  length: 0 (resolved future 2)
[16:18:46.862] Relaying remaining futures
[16:18:46.862] signalConditionsASAP(NULL, pos=0) ...
[16:18:46.862] - nx: 2
[16:18:46.862] - relay: TRUE
[16:18:46.863] - stdout: TRUE
[16:18:46.863] - signal: TRUE
[16:18:46.863] - resignal: FALSE
[16:18:46.863] - force: TRUE
[16:18:46.863] - relayed: [n=2] TRUE, TRUE
[16:18:46.863] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:46.863] - relayed: [n=2] TRUE, TRUE
[16:18:46.863] - queued futures: [n=2] TRUE, TRUE
[16:18:46.863] signalConditionsASAP(NULL, pos=0) ... done
[16:18:46.863] resolve() on list ... DONE
[16:18:46.863] result() for ClusterFuture ...
[16:18:46.864] - result already collected: FutureResult
[16:18:46.864] result() for ClusterFuture ... done
[16:18:46.864] result() for ClusterFuture ...
[16:18:46.864] - result already collected: FutureResult
[16:18:46.864] result() for ClusterFuture ... done
[16:18:46.864] result() for ClusterFuture ...
[16:18:46.864] - result already collected: FutureResult
[16:18:46.864] result() for ClusterFuture ... done
[16:18:46.864] result() for ClusterFuture ...
[16:18:46.864] - result already collected: FutureResult
[16:18:46.864] result() for ClusterFuture ... done
[16:18:46.865]  - Number of value chunks collected: 2
[16:18:46.865] Resolving 2 futures (chunks) ... DONE
[16:18:46.865] Reducing values from 2 chunks ...
[16:18:46.865]  - Number of values collected after concatenation: 4
[16:18:46.865]  - Number of values expected: 4
[16:18:46.865] Reducing values from 2 chunks ... DONE
[16:18:46.865] future_mapply() ... DONE
- Parallel RNG ...
[16:18:46.865] future_mapply() ...
[16:18:46.865] Generating random seeds ...
[16:18:46.866] Generating random seed streams for 4 elements ...
[16:18:46.866] Generating random seed streams for 4 elements ... DONE
[16:18:46.866] Generating random seeds ... DONE
[16:18:46.866] Will set RNG state on exit: 10407, 201260855, -1137364148, -669966587, -861207281, -2074260718, -499264908
[16:18:46.870] Number of chunks: 2
[16:18:46.870] getGlobalsAndPackagesXApply() ...
[16:18:46.870]  - future.globals: TRUE
[16:18:46.870] getGlobalsAndPackages() ...
[16:18:46.870] Searching for globals...
[16:18:46.872] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[16:18:46.872] Searching for globals ... DONE
[16:18:46.872] Resolving globals: FALSE
[16:18:46.872] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[16:18:46.873] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[16:18:46.873] - globals: [1] ‘FUN’
[16:18:46.873] - packages: [1] ‘stats’
[16:18:46.873] getGlobalsAndPackages() ... DONE
[16:18:46.873]  - globals found/used: [n=1] ‘FUN’
[16:18:46.873]  - needed namespaces: [n=1] ‘stats’
[16:18:46.873] Finding globals ... DONE
[16:18:46.874] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:46.874] List of 2
[16:18:46.874]  $ ...future.FUN:function (n, min = 0, max = 1)  
[16:18:46.874]  $ MoreArgs     :List of 1
[16:18:46.874]   ..$ min: num 1
[16:18:46.874]  - attr(*, "where")=List of 2
[16:18:46.874]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:46.874]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:46.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:46.874]  - attr(*, "resolved")= logi FALSE
[16:18:46.874]  - attr(*, "total_size")= num NA
[16:18:46.877] Packages to be attached in all futures: [n=1] ‘stats’
[16:18:46.877] getGlobalsAndPackagesXApply() ... DONE
[16:18:46.877] Number of futures (= number of chunks): 2
[16:18:46.877] Launching 2 futures (chunks) ...
[16:18:46.877] Chunk #1 of 2 ...
[16:18:46.877]  - Finding globals in '...' for chunk #1 ...
[16:18:46.877] getGlobalsAndPackages() ...
[16:18:46.877] Searching for globals...
[16:18:46.878] 
[16:18:46.878] Searching for globals ... DONE
[16:18:46.878] - globals: [0] <none>
[16:18:46.878] getGlobalsAndPackages() ... DONE
[16:18:46.878]    + additional globals found: [n=0] 
[16:18:46.878]    + additional namespaces needed: [n=0] 
[16:18:46.878]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:46.878]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.878]  - seeds: [2] <seeds>
[16:18:46.879]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.879] getGlobalsAndPackages() ...
[16:18:46.879] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.879] Resolving globals: FALSE
[16:18:46.879] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[16:18:46.880] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[16:18:46.880] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.880] - packages: [1] ‘stats’
[16:18:46.880] getGlobalsAndPackages() ... DONE
[16:18:46.881] run() for ‘Future’ ...
[16:18:46.881] - state: ‘created’
[16:18:46.881] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.895] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.896]   - Field: ‘node’
[16:18:46.896]   - Field: ‘label’
[16:18:46.896]   - Field: ‘local’
[16:18:46.896]   - Field: ‘owner’
[16:18:46.896]   - Field: ‘envir’
[16:18:46.896]   - Field: ‘workers’
[16:18:46.896]   - Field: ‘packages’
[16:18:46.896]   - Field: ‘gc’
[16:18:46.897]   - Field: ‘conditions’
[16:18:46.897]   - Field: ‘persistent’
[16:18:46.897]   - Field: ‘expr’
[16:18:46.897]   - Field: ‘uuid’
[16:18:46.897]   - Field: ‘seed’
[16:18:46.897]   - Field: ‘version’
[16:18:46.897]   - Field: ‘result’
[16:18:46.897]   - Field: ‘asynchronous’
[16:18:46.897]   - Field: ‘calls’
[16:18:46.897]   - Field: ‘globals’
[16:18:46.897]   - Field: ‘stdout’
[16:18:46.898]   - Field: ‘earlySignal’
[16:18:46.898]   - Field: ‘lazy’
[16:18:46.898]   - Field: ‘state’
[16:18:46.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.898] - Launch lazy future ...
[16:18:46.898] Packages needed by the future expression (n = 1): ‘stats’
[16:18:46.898] Packages needed by future strategies (n = 0): <none>
[16:18:46.899] {
[16:18:46.899]     {
[16:18:46.899]         {
[16:18:46.899]             ...future.startTime <- base::Sys.time()
[16:18:46.899]             {
[16:18:46.899]                 {
[16:18:46.899]                   {
[16:18:46.899]                     {
[16:18:46.899]                       {
[16:18:46.899]                         base::local({
[16:18:46.899]                           has_future <- base::requireNamespace("future", 
[16:18:46.899]                             quietly = TRUE)
[16:18:46.899]                           if (has_future) {
[16:18:46.899]                             ns <- base::getNamespace("future")
[16:18:46.899]                             version <- ns[[".package"]][["version"]]
[16:18:46.899]                             if (is.null(version)) 
[16:18:46.899]                               version <- utils::packageVersion("future")
[16:18:46.899]                           }
[16:18:46.899]                           else {
[16:18:46.899]                             version <- NULL
[16:18:46.899]                           }
[16:18:46.899]                           if (!has_future || version < "1.8.0") {
[16:18:46.899]                             info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.899]                               "", base::R.version$version.string), 
[16:18:46.899]                               platform = base::sprintf("%s (%s-bit)", 
[16:18:46.899]                                 base::R.version$platform, 8 * 
[16:18:46.899]                                   base::.Machine$sizeof.pointer), 
[16:18:46.899]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.899]                                 "release", "version")], collapse = " "), 
[16:18:46.899]                               hostname = base::Sys.info()[["nodename"]])
[16:18:46.899]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.899]                               info)
[16:18:46.899]                             info <- base::paste(info, collapse = "; ")
[16:18:46.899]                             if (!has_future) {
[16:18:46.899]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.899]                                 info)
[16:18:46.899]                             }
[16:18:46.899]                             else {
[16:18:46.899]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.899]                                 info, version)
[16:18:46.899]                             }
[16:18:46.899]                             base::stop(msg)
[16:18:46.899]                           }
[16:18:46.899]                         })
[16:18:46.899]                       }
[16:18:46.899]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.899]                       base::options(mc.cores = 1L)
[16:18:46.899]                     }
[16:18:46.899]                     base::local({
[16:18:46.899]                       for (pkg in "stats") {
[16:18:46.899]                         base::loadNamespace(pkg)
[16:18:46.899]                         base::library(pkg, character.only = TRUE)
[16:18:46.899]                       }
[16:18:46.899]                     })
[16:18:46.899]                   }
[16:18:46.899]                   ...future.strategy.old <- future::plan("list")
[16:18:46.899]                   options(future.plan = NULL)
[16:18:46.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.899]                 }
[16:18:46.899]                 ...future.workdir <- getwd()
[16:18:46.899]             }
[16:18:46.899]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.899]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.899]         }
[16:18:46.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.899]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.899]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.899]             base::names(...future.oldOptions))
[16:18:46.899]     }
[16:18:46.899]     if (FALSE) {
[16:18:46.899]     }
[16:18:46.899]     else {
[16:18:46.899]         if (TRUE) {
[16:18:46.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.899]                 open = "w")
[16:18:46.899]         }
[16:18:46.899]         else {
[16:18:46.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.899]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.899]         }
[16:18:46.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.899]             base::sink(type = "output", split = FALSE)
[16:18:46.899]             base::close(...future.stdout)
[16:18:46.899]         }, add = TRUE)
[16:18:46.899]     }
[16:18:46.899]     ...future.frame <- base::sys.nframe()
[16:18:46.899]     ...future.conditions <- base::list()
[16:18:46.899]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.899]     if (FALSE) {
[16:18:46.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.899]     }
[16:18:46.899]     ...future.result <- base::tryCatch({
[16:18:46.899]         base::withCallingHandlers({
[16:18:46.899]             ...future.value <- base::withVisible(base::local({
[16:18:46.899]                 ...future.makeSendCondition <- base::local({
[16:18:46.899]                   sendCondition <- NULL
[16:18:46.899]                   function(frame = 1L) {
[16:18:46.899]                     if (is.function(sendCondition)) 
[16:18:46.899]                       return(sendCondition)
[16:18:46.899]                     ns <- getNamespace("parallel")
[16:18:46.899]                     if (exists("sendData", mode = "function", 
[16:18:46.899]                       envir = ns)) {
[16:18:46.899]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.899]                         envir = ns)
[16:18:46.899]                       envir <- sys.frame(frame)
[16:18:46.899]                       master <- NULL
[16:18:46.899]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.899]                         !identical(envir, emptyenv())) {
[16:18:46.899]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.899]                           inherits = FALSE)) {
[16:18:46.899]                           master <- get("master", mode = "list", 
[16:18:46.899]                             envir = envir, inherits = FALSE)
[16:18:46.899]                           if (inherits(master, c("SOCKnode", 
[16:18:46.899]                             "SOCK0node"))) {
[16:18:46.899]                             sendCondition <<- function(cond) {
[16:18:46.899]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.899]                                 success = TRUE)
[16:18:46.899]                               parallel_sendData(master, data)
[16:18:46.899]                             }
[16:18:46.899]                             return(sendCondition)
[16:18:46.899]                           }
[16:18:46.899]                         }
[16:18:46.899]                         frame <- frame + 1L
[16:18:46.899]                         envir <- sys.frame(frame)
[16:18:46.899]                       }
[16:18:46.899]                     }
[16:18:46.899]                     sendCondition <<- function(cond) NULL
[16:18:46.899]                   }
[16:18:46.899]                 })
[16:18:46.899]                 withCallingHandlers({
[16:18:46.899]                   {
[16:18:46.899]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.899]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.899]                       ...future.globals.maxSize)) {
[16:18:46.899]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.899]                       on.exit(options(oopts), add = TRUE)
[16:18:46.899]                     }
[16:18:46.899]                     {
[16:18:46.899]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:46.899]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[16:18:46.899]                           envir = globalenv(), inherits = FALSE)
[16:18:46.899]                         ...future.FUN(...)
[16:18:46.899]                       }
[16:18:46.899]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:46.899]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:46.899]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.899]                         USE.NAMES = FALSE)
[16:18:46.899]                       do.call(mapply, args = args)
[16:18:46.899]                     }
[16:18:46.899]                   }
[16:18:46.899]                 }, immediateCondition = function(cond) {
[16:18:46.899]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.899]                   sendCondition(cond)
[16:18:46.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.899]                   {
[16:18:46.899]                     inherits <- base::inherits
[16:18:46.899]                     invokeRestart <- base::invokeRestart
[16:18:46.899]                     is.null <- base::is.null
[16:18:46.899]                     muffled <- FALSE
[16:18:46.899]                     if (inherits(cond, "message")) {
[16:18:46.899]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.899]                       if (muffled) 
[16:18:46.899]                         invokeRestart("muffleMessage")
[16:18:46.899]                     }
[16:18:46.899]                     else if (inherits(cond, "warning")) {
[16:18:46.899]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.899]                       if (muffled) 
[16:18:46.899]                         invokeRestart("muffleWarning")
[16:18:46.899]                     }
[16:18:46.899]                     else if (inherits(cond, "condition")) {
[16:18:46.899]                       if (!is.null(pattern)) {
[16:18:46.899]                         computeRestarts <- base::computeRestarts
[16:18:46.899]                         grepl <- base::grepl
[16:18:46.899]                         restarts <- computeRestarts(cond)
[16:18:46.899]                         for (restart in restarts) {
[16:18:46.899]                           name <- restart$name
[16:18:46.899]                           if (is.null(name)) 
[16:18:46.899]                             next
[16:18:46.899]                           if (!grepl(pattern, name)) 
[16:18:46.899]                             next
[16:18:46.899]                           invokeRestart(restart)
[16:18:46.899]                           muffled <- TRUE
[16:18:46.899]                           break
[16:18:46.899]                         }
[16:18:46.899]                       }
[16:18:46.899]                     }
[16:18:46.899]                     invisible(muffled)
[16:18:46.899]                   }
[16:18:46.899]                   muffleCondition(cond)
[16:18:46.899]                 })
[16:18:46.899]             }))
[16:18:46.899]             future::FutureResult(value = ...future.value$value, 
[16:18:46.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.899]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.899]                     ...future.globalenv.names))
[16:18:46.899]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.899]         }, condition = base::local({
[16:18:46.899]             c <- base::c
[16:18:46.899]             inherits <- base::inherits
[16:18:46.899]             invokeRestart <- base::invokeRestart
[16:18:46.899]             length <- base::length
[16:18:46.899]             list <- base::list
[16:18:46.899]             seq.int <- base::seq.int
[16:18:46.899]             signalCondition <- base::signalCondition
[16:18:46.899]             sys.calls <- base::sys.calls
[16:18:46.899]             `[[` <- base::`[[`
[16:18:46.899]             `+` <- base::`+`
[16:18:46.899]             `<<-` <- base::`<<-`
[16:18:46.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.899]                   3L)]
[16:18:46.899]             }
[16:18:46.899]             function(cond) {
[16:18:46.899]                 is_error <- inherits(cond, "error")
[16:18:46.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.899]                   NULL)
[16:18:46.899]                 if (is_error) {
[16:18:46.899]                   sessionInformation <- function() {
[16:18:46.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.899]                       search = base::search(), system = base::Sys.info())
[16:18:46.899]                   }
[16:18:46.899]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.899]                     cond$call), session = sessionInformation(), 
[16:18:46.899]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.899]                   signalCondition(cond)
[16:18:46.899]                 }
[16:18:46.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.899]                 "immediateCondition"))) {
[16:18:46.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.899]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.899]                   if (TRUE && !signal) {
[16:18:46.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.899]                     {
[16:18:46.899]                       inherits <- base::inherits
[16:18:46.899]                       invokeRestart <- base::invokeRestart
[16:18:46.899]                       is.null <- base::is.null
[16:18:46.899]                       muffled <- FALSE
[16:18:46.899]                       if (inherits(cond, "message")) {
[16:18:46.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.899]                         if (muffled) 
[16:18:46.899]                           invokeRestart("muffleMessage")
[16:18:46.899]                       }
[16:18:46.899]                       else if (inherits(cond, "warning")) {
[16:18:46.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.899]                         if (muffled) 
[16:18:46.899]                           invokeRestart("muffleWarning")
[16:18:46.899]                       }
[16:18:46.899]                       else if (inherits(cond, "condition")) {
[16:18:46.899]                         if (!is.null(pattern)) {
[16:18:46.899]                           computeRestarts <- base::computeRestarts
[16:18:46.899]                           grepl <- base::grepl
[16:18:46.899]                           restarts <- computeRestarts(cond)
[16:18:46.899]                           for (restart in restarts) {
[16:18:46.899]                             name <- restart$name
[16:18:46.899]                             if (is.null(name)) 
[16:18:46.899]                               next
[16:18:46.899]                             if (!grepl(pattern, name)) 
[16:18:46.899]                               next
[16:18:46.899]                             invokeRestart(restart)
[16:18:46.899]                             muffled <- TRUE
[16:18:46.899]                             break
[16:18:46.899]                           }
[16:18:46.899]                         }
[16:18:46.899]                       }
[16:18:46.899]                       invisible(muffled)
[16:18:46.899]                     }
[16:18:46.899]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.899]                   }
[16:18:46.899]                 }
[16:18:46.899]                 else {
[16:18:46.899]                   if (TRUE) {
[16:18:46.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.899]                     {
[16:18:46.899]                       inherits <- base::inherits
[16:18:46.899]                       invokeRestart <- base::invokeRestart
[16:18:46.899]                       is.null <- base::is.null
[16:18:46.899]                       muffled <- FALSE
[16:18:46.899]                       if (inherits(cond, "message")) {
[16:18:46.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.899]                         if (muffled) 
[16:18:46.899]                           invokeRestart("muffleMessage")
[16:18:46.899]                       }
[16:18:46.899]                       else if (inherits(cond, "warning")) {
[16:18:46.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.899]                         if (muffled) 
[16:18:46.899]                           invokeRestart("muffleWarning")
[16:18:46.899]                       }
[16:18:46.899]                       else if (inherits(cond, "condition")) {
[16:18:46.899]                         if (!is.null(pattern)) {
[16:18:46.899]                           computeRestarts <- base::computeRestarts
[16:18:46.899]                           grepl <- base::grepl
[16:18:46.899]                           restarts <- computeRestarts(cond)
[16:18:46.899]                           for (restart in restarts) {
[16:18:46.899]                             name <- restart$name
[16:18:46.899]                             if (is.null(name)) 
[16:18:46.899]                               next
[16:18:46.899]                             if (!grepl(pattern, name)) 
[16:18:46.899]                               next
[16:18:46.899]                             invokeRestart(restart)
[16:18:46.899]                             muffled <- TRUE
[16:18:46.899]                             break
[16:18:46.899]                           }
[16:18:46.899]                         }
[16:18:46.899]                       }
[16:18:46.899]                       invisible(muffled)
[16:18:46.899]                     }
[16:18:46.899]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.899]                   }
[16:18:46.899]                 }
[16:18:46.899]             }
[16:18:46.899]         }))
[16:18:46.899]     }, error = function(ex) {
[16:18:46.899]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.899]                 ...future.rng), started = ...future.startTime, 
[16:18:46.899]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.899]             version = "1.8"), class = "FutureResult")
[16:18:46.899]     }, finally = {
[16:18:46.899]         if (!identical(...future.workdir, getwd())) 
[16:18:46.899]             setwd(...future.workdir)
[16:18:46.899]         {
[16:18:46.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.899]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.899]             }
[16:18:46.899]             base::options(...future.oldOptions)
[16:18:46.899]             if (.Platform$OS.type == "windows") {
[16:18:46.899]                 old_names <- names(...future.oldEnvVars)
[16:18:46.899]                 envs <- base::Sys.getenv()
[16:18:46.899]                 names <- names(envs)
[16:18:46.899]                 common <- intersect(names, old_names)
[16:18:46.899]                 added <- setdiff(names, old_names)
[16:18:46.899]                 removed <- setdiff(old_names, names)
[16:18:46.899]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.899]                   envs[common]]
[16:18:46.899]                 NAMES <- toupper(changed)
[16:18:46.899]                 args <- list()
[16:18:46.899]                 for (kk in seq_along(NAMES)) {
[16:18:46.899]                   name <- changed[[kk]]
[16:18:46.899]                   NAME <- NAMES[[kk]]
[16:18:46.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.899]                     next
[16:18:46.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.899]                 }
[16:18:46.899]                 NAMES <- toupper(added)
[16:18:46.899]                 for (kk in seq_along(NAMES)) {
[16:18:46.899]                   name <- added[[kk]]
[16:18:46.899]                   NAME <- NAMES[[kk]]
[16:18:46.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.899]                     next
[16:18:46.899]                   args[[name]] <- ""
[16:18:46.899]                 }
[16:18:46.899]                 NAMES <- toupper(removed)
[16:18:46.899]                 for (kk in seq_along(NAMES)) {
[16:18:46.899]                   name <- removed[[kk]]
[16:18:46.899]                   NAME <- NAMES[[kk]]
[16:18:46.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.899]                     next
[16:18:46.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.899]                 }
[16:18:46.899]                 if (length(args) > 0) 
[16:18:46.899]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.899]             }
[16:18:46.899]             else {
[16:18:46.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.899]             }
[16:18:46.899]             {
[16:18:46.899]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.899]                   0L) {
[16:18:46.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.899]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.899]                   base::options(opts)
[16:18:46.899]                 }
[16:18:46.899]                 {
[16:18:46.899]                   {
[16:18:46.899]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.899]                     NULL
[16:18:46.899]                   }
[16:18:46.899]                   options(future.plan = NULL)
[16:18:46.899]                   if (is.na(NA_character_)) 
[16:18:46.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.899]                     .init = FALSE)
[16:18:46.899]                 }
[16:18:46.899]             }
[16:18:46.899]         }
[16:18:46.899]     })
[16:18:46.899]     if (TRUE) {
[16:18:46.899]         base::sink(type = "output", split = FALSE)
[16:18:46.899]         if (TRUE) {
[16:18:46.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.899]         }
[16:18:46.899]         else {
[16:18:46.899]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.899]         }
[16:18:46.899]         base::close(...future.stdout)
[16:18:46.899]         ...future.stdout <- NULL
[16:18:46.899]     }
[16:18:46.899]     ...future.result$conditions <- ...future.conditions
[16:18:46.899]     ...future.result$finished <- base::Sys.time()
[16:18:46.899]     ...future.result
[16:18:46.899] }
[16:18:46.902] Exporting 5 global objects (2.47 KiB) to cluster node #1 ...
[16:18:46.902] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ...
[16:18:46.902] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ... DONE
[16:18:46.902] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[16:18:46.903] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[16:18:46.903] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[16:18:46.903] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[16:18:46.903] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ...
[16:18:46.903] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ... DONE
[16:18:46.904] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:46.904] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:46.904] Exporting 5 global objects (2.47 KiB) to cluster node #1 ... DONE
[16:18:46.905] MultisessionFuture started
[16:18:46.905] - Launch lazy future ... done
[16:18:46.905] run() for ‘MultisessionFuture’ ... done
[16:18:46.905] Created future:
[16:18:46.905] MultisessionFuture:
[16:18:46.905] Label: ‘future_mapply-1’
[16:18:46.905] Expression:
[16:18:46.905] {
[16:18:46.905]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.905]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.905]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.905]         on.exit(options(oopts), add = TRUE)
[16:18:46.905]     }
[16:18:46.905]     {
[16:18:46.905]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:46.905]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[16:18:46.905]                 inherits = FALSE)
[16:18:46.905]             ...future.FUN(...)
[16:18:46.905]         }
[16:18:46.905]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:46.905]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:46.905]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.905]         do.call(mapply, args = args)
[16:18:46.905]     }
[16:18:46.905] }
[16:18:46.905] Lazy evaluation: FALSE
[16:18:46.905] Asynchronous evaluation: TRUE
[16:18:46.905] Local evaluation: TRUE
[16:18:46.905] Environment: R_GlobalEnv
[16:18:46.905] Capture standard output: TRUE
[16:18:46.905] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.905] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.905] Packages: 1 packages (‘stats’)
[16:18:46.905] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:18:46.905] Resolved: FALSE
[16:18:46.905] Value: <not collected>
[16:18:46.905] Conditions captured: <none>
[16:18:46.905] Early signaling: FALSE
[16:18:46.905] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.905] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.917] Chunk #1 of 2 ... DONE
[16:18:46.917] Chunk #2 of 2 ...
[16:18:46.917]  - Finding globals in '...' for chunk #2 ...
[16:18:46.917] getGlobalsAndPackages() ...
[16:18:46.917] Searching for globals...
[16:18:46.917] 
[16:18:46.918] Searching for globals ... DONE
[16:18:46.918] - globals: [0] <none>
[16:18:46.918] getGlobalsAndPackages() ... DONE
[16:18:46.918]    + additional globals found: [n=0] 
[16:18:46.918]    + additional namespaces needed: [n=0] 
[16:18:46.918]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:46.918]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:46.918]  - seeds: [2] <seeds>
[16:18:46.918]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.918] getGlobalsAndPackages() ...
[16:18:46.919] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.919] Resolving globals: FALSE
[16:18:46.919] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[16:18:46.920] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[16:18:46.920] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:46.920] - packages: [1] ‘stats’
[16:18:46.920] getGlobalsAndPackages() ... DONE
[16:18:46.920] run() for ‘Future’ ...
[16:18:46.920] - state: ‘created’
[16:18:46.921] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:46.935] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:46.935]   - Field: ‘node’
[16:18:46.935]   - Field: ‘label’
[16:18:46.938]   - Field: ‘local’
[16:18:46.938]   - Field: ‘owner’
[16:18:46.939]   - Field: ‘envir’
[16:18:46.939]   - Field: ‘workers’
[16:18:46.939]   - Field: ‘packages’
[16:18:46.939]   - Field: ‘gc’
[16:18:46.939]   - Field: ‘conditions’
[16:18:46.939]   - Field: ‘persistent’
[16:18:46.939]   - Field: ‘expr’
[16:18:46.939]   - Field: ‘uuid’
[16:18:46.939]   - Field: ‘seed’
[16:18:46.939]   - Field: ‘version’
[16:18:46.939]   - Field: ‘result’
[16:18:46.940]   - Field: ‘asynchronous’
[16:18:46.940]   - Field: ‘calls’
[16:18:46.940]   - Field: ‘globals’
[16:18:46.940]   - Field: ‘stdout’
[16:18:46.940]   - Field: ‘earlySignal’
[16:18:46.940]   - Field: ‘lazy’
[16:18:46.940]   - Field: ‘state’
[16:18:46.940] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:46.940] - Launch lazy future ...
[16:18:46.941] Packages needed by the future expression (n = 1): ‘stats’
[16:18:46.941] Packages needed by future strategies (n = 0): <none>
[16:18:46.941] {
[16:18:46.941]     {
[16:18:46.941]         {
[16:18:46.941]             ...future.startTime <- base::Sys.time()
[16:18:46.941]             {
[16:18:46.941]                 {
[16:18:46.941]                   {
[16:18:46.941]                     {
[16:18:46.941]                       {
[16:18:46.941]                         base::local({
[16:18:46.941]                           has_future <- base::requireNamespace("future", 
[16:18:46.941]                             quietly = TRUE)
[16:18:46.941]                           if (has_future) {
[16:18:46.941]                             ns <- base::getNamespace("future")
[16:18:46.941]                             version <- ns[[".package"]][["version"]]
[16:18:46.941]                             if (is.null(version)) 
[16:18:46.941]                               version <- utils::packageVersion("future")
[16:18:46.941]                           }
[16:18:46.941]                           else {
[16:18:46.941]                             version <- NULL
[16:18:46.941]                           }
[16:18:46.941]                           if (!has_future || version < "1.8.0") {
[16:18:46.941]                             info <- base::c(r_version = base::gsub("R version ", 
[16:18:46.941]                               "", base::R.version$version.string), 
[16:18:46.941]                               platform = base::sprintf("%s (%s-bit)", 
[16:18:46.941]                                 base::R.version$platform, 8 * 
[16:18:46.941]                                   base::.Machine$sizeof.pointer), 
[16:18:46.941]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:46.941]                                 "release", "version")], collapse = " "), 
[16:18:46.941]                               hostname = base::Sys.info()[["nodename"]])
[16:18:46.941]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:18:46.941]                               info)
[16:18:46.941]                             info <- base::paste(info, collapse = "; ")
[16:18:46.941]                             if (!has_future) {
[16:18:46.941]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:46.941]                                 info)
[16:18:46.941]                             }
[16:18:46.941]                             else {
[16:18:46.941]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:46.941]                                 info, version)
[16:18:46.941]                             }
[16:18:46.941]                             base::stop(msg)
[16:18:46.941]                           }
[16:18:46.941]                         })
[16:18:46.941]                       }
[16:18:46.941]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:46.941]                       base::options(mc.cores = 1L)
[16:18:46.941]                     }
[16:18:46.941]                     base::local({
[16:18:46.941]                       for (pkg in "stats") {
[16:18:46.941]                         base::loadNamespace(pkg)
[16:18:46.941]                         base::library(pkg, character.only = TRUE)
[16:18:46.941]                       }
[16:18:46.941]                     })
[16:18:46.941]                   }
[16:18:46.941]                   ...future.strategy.old <- future::plan("list")
[16:18:46.941]                   options(future.plan = NULL)
[16:18:46.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:46.941]                 }
[16:18:46.941]                 ...future.workdir <- getwd()
[16:18:46.941]             }
[16:18:46.941]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:46.941]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:46.941]         }
[16:18:46.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:46.941]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:46.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:46.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:46.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:46.941]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:46.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:46.941]             base::names(...future.oldOptions))
[16:18:46.941]     }
[16:18:46.941]     if (FALSE) {
[16:18:46.941]     }
[16:18:46.941]     else {
[16:18:46.941]         if (TRUE) {
[16:18:46.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:46.941]                 open = "w")
[16:18:46.941]         }
[16:18:46.941]         else {
[16:18:46.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:46.941]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:46.941]         }
[16:18:46.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:46.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:46.941]             base::sink(type = "output", split = FALSE)
[16:18:46.941]             base::close(...future.stdout)
[16:18:46.941]         }, add = TRUE)
[16:18:46.941]     }
[16:18:46.941]     ...future.frame <- base::sys.nframe()
[16:18:46.941]     ...future.conditions <- base::list()
[16:18:46.941]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:46.941]     if (FALSE) {
[16:18:46.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:46.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:46.941]     }
[16:18:46.941]     ...future.result <- base::tryCatch({
[16:18:46.941]         base::withCallingHandlers({
[16:18:46.941]             ...future.value <- base::withVisible(base::local({
[16:18:46.941]                 ...future.makeSendCondition <- base::local({
[16:18:46.941]                   sendCondition <- NULL
[16:18:46.941]                   function(frame = 1L) {
[16:18:46.941]                     if (is.function(sendCondition)) 
[16:18:46.941]                       return(sendCondition)
[16:18:46.941]                     ns <- getNamespace("parallel")
[16:18:46.941]                     if (exists("sendData", mode = "function", 
[16:18:46.941]                       envir = ns)) {
[16:18:46.941]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:46.941]                         envir = ns)
[16:18:46.941]                       envir <- sys.frame(frame)
[16:18:46.941]                       master <- NULL
[16:18:46.941]                       while (!identical(envir, .GlobalEnv) && 
[16:18:46.941]                         !identical(envir, emptyenv())) {
[16:18:46.941]                         if (exists("master", mode = "list", envir = envir, 
[16:18:46.941]                           inherits = FALSE)) {
[16:18:46.941]                           master <- get("master", mode = "list", 
[16:18:46.941]                             envir = envir, inherits = FALSE)
[16:18:46.941]                           if (inherits(master, c("SOCKnode", 
[16:18:46.941]                             "SOCK0node"))) {
[16:18:46.941]                             sendCondition <<- function(cond) {
[16:18:46.941]                               data <- list(type = "VALUE", value = cond, 
[16:18:46.941]                                 success = TRUE)
[16:18:46.941]                               parallel_sendData(master, data)
[16:18:46.941]                             }
[16:18:46.941]                             return(sendCondition)
[16:18:46.941]                           }
[16:18:46.941]                         }
[16:18:46.941]                         frame <- frame + 1L
[16:18:46.941]                         envir <- sys.frame(frame)
[16:18:46.941]                       }
[16:18:46.941]                     }
[16:18:46.941]                     sendCondition <<- function(cond) NULL
[16:18:46.941]                   }
[16:18:46.941]                 })
[16:18:46.941]                 withCallingHandlers({
[16:18:46.941]                   {
[16:18:46.941]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.941]                     if (!identical(...future.globals.maxSize.org, 
[16:18:46.941]                       ...future.globals.maxSize)) {
[16:18:46.941]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.941]                       on.exit(options(oopts), add = TRUE)
[16:18:46.941]                     }
[16:18:46.941]                     {
[16:18:46.941]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:46.941]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[16:18:46.941]                           envir = globalenv(), inherits = FALSE)
[16:18:46.941]                         ...future.FUN(...)
[16:18:46.941]                       }
[16:18:46.941]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:46.941]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:46.941]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:46.941]                         USE.NAMES = FALSE)
[16:18:46.941]                       do.call(mapply, args = args)
[16:18:46.941]                     }
[16:18:46.941]                   }
[16:18:46.941]                 }, immediateCondition = function(cond) {
[16:18:46.941]                   sendCondition <- ...future.makeSendCondition()
[16:18:46.941]                   sendCondition(cond)
[16:18:46.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.941]                   {
[16:18:46.941]                     inherits <- base::inherits
[16:18:46.941]                     invokeRestart <- base::invokeRestart
[16:18:46.941]                     is.null <- base::is.null
[16:18:46.941]                     muffled <- FALSE
[16:18:46.941]                     if (inherits(cond, "message")) {
[16:18:46.941]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:46.941]                       if (muffled) 
[16:18:46.941]                         invokeRestart("muffleMessage")
[16:18:46.941]                     }
[16:18:46.941]                     else if (inherits(cond, "warning")) {
[16:18:46.941]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:46.941]                       if (muffled) 
[16:18:46.941]                         invokeRestart("muffleWarning")
[16:18:46.941]                     }
[16:18:46.941]                     else if (inherits(cond, "condition")) {
[16:18:46.941]                       if (!is.null(pattern)) {
[16:18:46.941]                         computeRestarts <- base::computeRestarts
[16:18:46.941]                         grepl <- base::grepl
[16:18:46.941]                         restarts <- computeRestarts(cond)
[16:18:46.941]                         for (restart in restarts) {
[16:18:46.941]                           name <- restart$name
[16:18:46.941]                           if (is.null(name)) 
[16:18:46.941]                             next
[16:18:46.941]                           if (!grepl(pattern, name)) 
[16:18:46.941]                             next
[16:18:46.941]                           invokeRestart(restart)
[16:18:46.941]                           muffled <- TRUE
[16:18:46.941]                           break
[16:18:46.941]                         }
[16:18:46.941]                       }
[16:18:46.941]                     }
[16:18:46.941]                     invisible(muffled)
[16:18:46.941]                   }
[16:18:46.941]                   muffleCondition(cond)
[16:18:46.941]                 })
[16:18:46.941]             }))
[16:18:46.941]             future::FutureResult(value = ...future.value$value, 
[16:18:46.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.941]                   ...future.rng), globalenv = if (FALSE) 
[16:18:46.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:46.941]                     ...future.globalenv.names))
[16:18:46.941]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:46.941]         }, condition = base::local({
[16:18:46.941]             c <- base::c
[16:18:46.941]             inherits <- base::inherits
[16:18:46.941]             invokeRestart <- base::invokeRestart
[16:18:46.941]             length <- base::length
[16:18:46.941]             list <- base::list
[16:18:46.941]             seq.int <- base::seq.int
[16:18:46.941]             signalCondition <- base::signalCondition
[16:18:46.941]             sys.calls <- base::sys.calls
[16:18:46.941]             `[[` <- base::`[[`
[16:18:46.941]             `+` <- base::`+`
[16:18:46.941]             `<<-` <- base::`<<-`
[16:18:46.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:46.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:46.941]                   3L)]
[16:18:46.941]             }
[16:18:46.941]             function(cond) {
[16:18:46.941]                 is_error <- inherits(cond, "error")
[16:18:46.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:46.941]                   NULL)
[16:18:46.941]                 if (is_error) {
[16:18:46.941]                   sessionInformation <- function() {
[16:18:46.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:46.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:46.941]                       search = base::search(), system = base::Sys.info())
[16:18:46.941]                   }
[16:18:46.941]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:46.941]                     cond$call), session = sessionInformation(), 
[16:18:46.941]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:46.941]                   signalCondition(cond)
[16:18:46.941]                 }
[16:18:46.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:46.941]                 "immediateCondition"))) {
[16:18:46.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:46.941]                   ...future.conditions[[length(...future.conditions) + 
[16:18:46.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:46.941]                   if (TRUE && !signal) {
[16:18:46.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.941]                     {
[16:18:46.941]                       inherits <- base::inherits
[16:18:46.941]                       invokeRestart <- base::invokeRestart
[16:18:46.941]                       is.null <- base::is.null
[16:18:46.941]                       muffled <- FALSE
[16:18:46.941]                       if (inherits(cond, "message")) {
[16:18:46.941]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.941]                         if (muffled) 
[16:18:46.941]                           invokeRestart("muffleMessage")
[16:18:46.941]                       }
[16:18:46.941]                       else if (inherits(cond, "warning")) {
[16:18:46.941]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.941]                         if (muffled) 
[16:18:46.941]                           invokeRestart("muffleWarning")
[16:18:46.941]                       }
[16:18:46.941]                       else if (inherits(cond, "condition")) {
[16:18:46.941]                         if (!is.null(pattern)) {
[16:18:46.941]                           computeRestarts <- base::computeRestarts
[16:18:46.941]                           grepl <- base::grepl
[16:18:46.941]                           restarts <- computeRestarts(cond)
[16:18:46.941]                           for (restart in restarts) {
[16:18:46.941]                             name <- restart$name
[16:18:46.941]                             if (is.null(name)) 
[16:18:46.941]                               next
[16:18:46.941]                             if (!grepl(pattern, name)) 
[16:18:46.941]                               next
[16:18:46.941]                             invokeRestart(restart)
[16:18:46.941]                             muffled <- TRUE
[16:18:46.941]                             break
[16:18:46.941]                           }
[16:18:46.941]                         }
[16:18:46.941]                       }
[16:18:46.941]                       invisible(muffled)
[16:18:46.941]                     }
[16:18:46.941]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.941]                   }
[16:18:46.941]                 }
[16:18:46.941]                 else {
[16:18:46.941]                   if (TRUE) {
[16:18:46.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:46.941]                     {
[16:18:46.941]                       inherits <- base::inherits
[16:18:46.941]                       invokeRestart <- base::invokeRestart
[16:18:46.941]                       is.null <- base::is.null
[16:18:46.941]                       muffled <- FALSE
[16:18:46.941]                       if (inherits(cond, "message")) {
[16:18:46.941]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:46.941]                         if (muffled) 
[16:18:46.941]                           invokeRestart("muffleMessage")
[16:18:46.941]                       }
[16:18:46.941]                       else if (inherits(cond, "warning")) {
[16:18:46.941]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:46.941]                         if (muffled) 
[16:18:46.941]                           invokeRestart("muffleWarning")
[16:18:46.941]                       }
[16:18:46.941]                       else if (inherits(cond, "condition")) {
[16:18:46.941]                         if (!is.null(pattern)) {
[16:18:46.941]                           computeRestarts <- base::computeRestarts
[16:18:46.941]                           grepl <- base::grepl
[16:18:46.941]                           restarts <- computeRestarts(cond)
[16:18:46.941]                           for (restart in restarts) {
[16:18:46.941]                             name <- restart$name
[16:18:46.941]                             if (is.null(name)) 
[16:18:46.941]                               next
[16:18:46.941]                             if (!grepl(pattern, name)) 
[16:18:46.941]                               next
[16:18:46.941]                             invokeRestart(restart)
[16:18:46.941]                             muffled <- TRUE
[16:18:46.941]                             break
[16:18:46.941]                           }
[16:18:46.941]                         }
[16:18:46.941]                       }
[16:18:46.941]                       invisible(muffled)
[16:18:46.941]                     }
[16:18:46.941]                     muffleCondition(cond, pattern = "^muffle")
[16:18:46.941]                   }
[16:18:46.941]                 }
[16:18:46.941]             }
[16:18:46.941]         }))
[16:18:46.941]     }, error = function(ex) {
[16:18:46.941]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:46.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:46.941]                 ...future.rng), started = ...future.startTime, 
[16:18:46.941]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:46.941]             version = "1.8"), class = "FutureResult")
[16:18:46.941]     }, finally = {
[16:18:46.941]         if (!identical(...future.workdir, getwd())) 
[16:18:46.941]             setwd(...future.workdir)
[16:18:46.941]         {
[16:18:46.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:46.941]                 ...future.oldOptions$nwarnings <- NULL
[16:18:46.941]             }
[16:18:46.941]             base::options(...future.oldOptions)
[16:18:46.941]             if (.Platform$OS.type == "windows") {
[16:18:46.941]                 old_names <- names(...future.oldEnvVars)
[16:18:46.941]                 envs <- base::Sys.getenv()
[16:18:46.941]                 names <- names(envs)
[16:18:46.941]                 common <- intersect(names, old_names)
[16:18:46.941]                 added <- setdiff(names, old_names)
[16:18:46.941]                 removed <- setdiff(old_names, names)
[16:18:46.941]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:46.941]                   envs[common]]
[16:18:46.941]                 NAMES <- toupper(changed)
[16:18:46.941]                 args <- list()
[16:18:46.941]                 for (kk in seq_along(NAMES)) {
[16:18:46.941]                   name <- changed[[kk]]
[16:18:46.941]                   NAME <- NAMES[[kk]]
[16:18:46.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.941]                     next
[16:18:46.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.941]                 }
[16:18:46.941]                 NAMES <- toupper(added)
[16:18:46.941]                 for (kk in seq_along(NAMES)) {
[16:18:46.941]                   name <- added[[kk]]
[16:18:46.941]                   NAME <- NAMES[[kk]]
[16:18:46.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.941]                     next
[16:18:46.941]                   args[[name]] <- ""
[16:18:46.941]                 }
[16:18:46.941]                 NAMES <- toupper(removed)
[16:18:46.941]                 for (kk in seq_along(NAMES)) {
[16:18:46.941]                   name <- removed[[kk]]
[16:18:46.941]                   NAME <- NAMES[[kk]]
[16:18:46.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:46.941]                     next
[16:18:46.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:46.941]                 }
[16:18:46.941]                 if (length(args) > 0) 
[16:18:46.941]                   base::do.call(base::Sys.setenv, args = args)
[16:18:46.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:46.941]             }
[16:18:46.941]             else {
[16:18:46.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:46.941]             }
[16:18:46.941]             {
[16:18:46.941]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:46.941]                   0L) {
[16:18:46.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:46.941]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:46.941]                   base::options(opts)
[16:18:46.941]                 }
[16:18:46.941]                 {
[16:18:46.941]                   {
[16:18:46.941]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:46.941]                     NULL
[16:18:46.941]                   }
[16:18:46.941]                   options(future.plan = NULL)
[16:18:46.941]                   if (is.na(NA_character_)) 
[16:18:46.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:46.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:46.941]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:46.941]                     .init = FALSE)
[16:18:46.941]                 }
[16:18:46.941]             }
[16:18:46.941]         }
[16:18:46.941]     })
[16:18:46.941]     if (TRUE) {
[16:18:46.941]         base::sink(type = "output", split = FALSE)
[16:18:46.941]         if (TRUE) {
[16:18:46.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:46.941]         }
[16:18:46.941]         else {
[16:18:46.941]             ...future.result["stdout"] <- base::list(NULL)
[16:18:46.941]         }
[16:18:46.941]         base::close(...future.stdout)
[16:18:46.941]         ...future.stdout <- NULL
[16:18:46.941]     }
[16:18:46.941]     ...future.result$conditions <- ...future.conditions
[16:18:46.941]     ...future.result$finished <- base::Sys.time()
[16:18:46.941]     ...future.result
[16:18:46.941] }
[16:18:46.944] Exporting 5 global objects (2.47 KiB) to cluster node #2 ...
[16:18:46.944] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ...
[16:18:46.944] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ... DONE
[16:18:46.945] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[16:18:46.945] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[16:18:46.945] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[16:18:46.945] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[16:18:46.945] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ...
[16:18:46.946] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ... DONE
[16:18:46.946] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:46.946] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:46.946] Exporting 5 global objects (2.47 KiB) to cluster node #2 ... DONE
[16:18:46.947] MultisessionFuture started
[16:18:46.947] - Launch lazy future ... done
[16:18:46.947] run() for ‘MultisessionFuture’ ... done
[16:18:46.947] Created future:
[16:18:46.947] MultisessionFuture:
[16:18:46.947] Label: ‘future_mapply-2’
[16:18:46.947] Expression:
[16:18:46.947] {
[16:18:46.947]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:46.947]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:46.947]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:46.947]         on.exit(options(oopts), add = TRUE)
[16:18:46.947]     }
[16:18:46.947]     {
[16:18:46.947]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[16:18:46.947]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[16:18:46.947]                 inherits = FALSE)
[16:18:46.947]             ...future.FUN(...)
[16:18:46.947]         }
[16:18:46.947]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[16:18:46.947]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[16:18:46.947]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:46.947]         do.call(mapply, args = args)
[16:18:46.947]     }
[16:18:46.947] }
[16:18:46.947] Lazy evaluation: FALSE
[16:18:46.947] Asynchronous evaluation: TRUE
[16:18:46.947] Local evaluation: TRUE
[16:18:46.947] Environment: R_GlobalEnv
[16:18:46.947] Capture standard output: TRUE
[16:18:46.947] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:46.947] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:46.947] Packages: 1 packages (‘stats’)
[16:18:46.947] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:18:46.947] Resolved: FALSE
[16:18:46.947] Value: <not collected>
[16:18:46.947] Conditions captured: <none>
[16:18:46.947] Early signaling: FALSE
[16:18:46.947] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:46.947] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:46.959] Chunk #2 of 2 ... DONE
[16:18:46.959] Launching 2 futures (chunks) ... DONE
[16:18:46.959] Resolving 2 futures (chunks) ...
[16:18:46.959] resolve() on list ...
[16:18:46.959]  recursive: 0
[16:18:46.959]  length: 2
[16:18:46.959] 
[16:18:46.960] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.960] - Validating connection of MultisessionFuture
[16:18:46.960] - received message: FutureResult
[16:18:46.960] - Received FutureResult
[16:18:46.960] - Erased future from FutureRegistry
[16:18:46.960] result() for ClusterFuture ...
[16:18:46.960] - result already collected: FutureResult
[16:18:46.961] result() for ClusterFuture ... done
[16:18:46.961] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.961] Future #1
[16:18:46.961] result() for ClusterFuture ...
[16:18:46.961] - result already collected: FutureResult
[16:18:46.961] result() for ClusterFuture ... done
[16:18:46.961] result() for ClusterFuture ...
[16:18:46.961] - result already collected: FutureResult
[16:18:46.961] result() for ClusterFuture ... done
[16:18:46.961] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:46.961] - nx: 2
[16:18:46.961] - relay: TRUE
[16:18:46.962] - stdout: TRUE
[16:18:46.962] - signal: TRUE
[16:18:46.962] - resignal: FALSE
[16:18:46.962] - force: TRUE
[16:18:46.962] - relayed: [n=2] FALSE, FALSE
[16:18:46.962] - queued futures: [n=2] FALSE, FALSE
[16:18:46.962]  - until=1
[16:18:46.962]  - relaying element #1
[16:18:46.962] result() for ClusterFuture ...
[16:18:46.962] - result already collected: FutureResult
[16:18:46.962] result() for ClusterFuture ... done
[16:18:46.963] result() for ClusterFuture ...
[16:18:46.963] - result already collected: FutureResult
[16:18:46.963] result() for ClusterFuture ... done
[16:18:46.963] result() for ClusterFuture ...
[16:18:46.963] - result already collected: FutureResult
[16:18:46.963] result() for ClusterFuture ... done
[16:18:46.963] result() for ClusterFuture ...
[16:18:46.963] - result already collected: FutureResult
[16:18:46.963] result() for ClusterFuture ... done
[16:18:46.963] - relayed: [n=2] TRUE, FALSE
[16:18:46.963] - queued futures: [n=2] TRUE, FALSE
[16:18:46.963] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:46.964]  length: 1 (resolved future 1)
[16:18:46.990] receiveMessageFromWorker() for ClusterFuture ...
[16:18:46.990] - Validating connection of MultisessionFuture
[16:18:46.990] - received message: FutureResult
[16:18:46.990] - Received FutureResult
[16:18:46.991] - Erased future from FutureRegistry
[16:18:46.991] result() for ClusterFuture ...
[16:18:46.991] - result already collected: FutureResult
[16:18:46.991] result() for ClusterFuture ... done
[16:18:46.991] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:46.991] Future #2
[16:18:46.991] result() for ClusterFuture ...
[16:18:46.991] - result already collected: FutureResult
[16:18:46.991] result() for ClusterFuture ... done
[16:18:46.991] result() for ClusterFuture ...
[16:18:46.991] - result already collected: FutureResult
[16:18:46.992] result() for ClusterFuture ... done
[16:18:46.992] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:46.992] - nx: 2
[16:18:46.992] - relay: TRUE
[16:18:46.992] - stdout: TRUE
[16:18:46.992] - signal: TRUE
[16:18:46.992] - resignal: FALSE
[16:18:46.992] - force: TRUE
[16:18:46.992] - relayed: [n=2] TRUE, FALSE
[16:18:46.992] - queued futures: [n=2] TRUE, FALSE
[16:18:46.992]  - until=2
[16:18:46.993]  - relaying element #2
[16:18:46.993] result() for ClusterFuture ...
[16:18:46.993] - result already collected: FutureResult
[16:18:46.993] result() for ClusterFuture ... done
[16:18:46.993] result() for ClusterFuture ...
[16:18:46.993] - result already collected: FutureResult
[16:18:46.993] result() for ClusterFuture ... done
[16:18:46.993] result() for ClusterFuture ...
[16:18:46.993] - result already collected: FutureResult
[16:18:46.993] result() for ClusterFuture ... done
[16:18:46.993] result() for ClusterFuture ...
[16:18:46.994] - result already collected: FutureResult
[16:18:46.994] result() for ClusterFuture ... done
[16:18:46.994] - relayed: [n=2] TRUE, TRUE
[16:18:46.994] - queued futures: [n=2] TRUE, TRUE
[16:18:46.994] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:46.994]  length: 0 (resolved future 2)
[16:18:46.994] Relaying remaining futures
[16:18:46.994] signalConditionsASAP(NULL, pos=0) ...
[16:18:46.994] - nx: 2
[16:18:46.994] - relay: TRUE
[16:18:46.994] - stdout: TRUE
[16:18:46.994] - signal: TRUE
[16:18:46.995] - resignal: FALSE
[16:18:46.995] - force: TRUE
[16:18:46.995] - relayed: [n=2] TRUE, TRUE
[16:18:46.995] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:46.995] - relayed: [n=2] TRUE, TRUE
[16:18:46.995] - queued futures: [n=2] TRUE, TRUE
[16:18:46.995] signalConditionsASAP(NULL, pos=0) ... done
[16:18:46.995] resolve() on list ... DONE
[16:18:46.995] result() for ClusterFuture ...
[16:18:46.995] - result already collected: FutureResult
[16:18:46.996] result() for ClusterFuture ... done
[16:18:46.996] result() for ClusterFuture ...
[16:18:46.996] - result already collected: FutureResult
[16:18:46.996] result() for ClusterFuture ... done
[16:18:46.996] result() for ClusterFuture ...
[16:18:46.996] - result already collected: FutureResult
[16:18:46.996] result() for ClusterFuture ... done
[16:18:46.996] result() for ClusterFuture ...
[16:18:46.996] - result already collected: FutureResult
[16:18:46.996] result() for ClusterFuture ... done
[16:18:46.996]  - Number of value chunks collected: 2
[16:18:46.997] Resolving 2 futures (chunks) ... DONE
[16:18:46.997] Reducing values from 2 chunks ...
[16:18:46.997]  - Number of values collected after concatenation: 4
[16:18:46.997]  - Number of values expected: 4
[16:18:46.997] Reducing values from 2 chunks ... DONE
[16:18:46.997] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[16:18:46.998] future_mapply() ...
[16:18:47.001] Number of chunks: 2
[16:18:47.001] getGlobalsAndPackagesXApply() ...
[16:18:47.001]  - future.globals: TRUE
[16:18:47.002] getGlobalsAndPackages() ...
[16:18:47.002] Searching for globals...
[16:18:47.003] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:18:47.003] Searching for globals ... DONE
[16:18:47.003] Resolving globals: FALSE
[16:18:47.003] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[16:18:47.004] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[16:18:47.004] - globals: [1] ‘FUN’
[16:18:47.004] - packages: [1] ‘stats’
[16:18:47.004] getGlobalsAndPackages() ... DONE
[16:18:47.004]  - globals found/used: [n=1] ‘FUN’
[16:18:47.004]  - needed namespaces: [n=1] ‘stats’
[16:18:47.004] Finding globals ... DONE
[16:18:47.005] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:47.005] List of 2
[16:18:47.005]  $ ...future.FUN:function (x, w, ...)  
[16:18:47.005]  $ MoreArgs     : NULL
[16:18:47.005]  - attr(*, "where")=List of 2
[16:18:47.005]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:47.005]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:47.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:47.005]  - attr(*, "resolved")= logi FALSE
[16:18:47.005]  - attr(*, "total_size")= num NA
[16:18:47.007] Packages to be attached in all futures: [n=1] ‘stats’
[16:18:47.007] getGlobalsAndPackagesXApply() ... DONE
[16:18:47.008] Number of futures (= number of chunks): 2
[16:18:47.008] Launching 2 futures (chunks) ...
[16:18:47.008] Chunk #1 of 2 ...
[16:18:47.008]  - Finding globals in '...' for chunk #1 ...
[16:18:47.008] getGlobalsAndPackages() ...
[16:18:47.008] Searching for globals...
[16:18:47.008] 
[16:18:47.009] Searching for globals ... DONE
[16:18:47.009] - globals: [0] <none>
[16:18:47.009] getGlobalsAndPackages() ... DONE
[16:18:47.009]    + additional globals found: [n=0] 
[16:18:47.009]    + additional namespaces needed: [n=0] 
[16:18:47.009]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:47.009]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:47.009]  - seeds: <none>
[16:18:47.009]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.009] getGlobalsAndPackages() ...
[16:18:47.009] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.010] Resolving globals: FALSE
[16:18:47.010] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[16:18:47.010] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:47.011] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.011] - packages: [1] ‘stats’
[16:18:47.011] getGlobalsAndPackages() ... DONE
[16:18:47.011] run() for ‘Future’ ...
[16:18:47.011] - state: ‘created’
[16:18:47.011] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:47.025] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:47.025]   - Field: ‘node’
[16:18:47.025]   - Field: ‘label’
[16:18:47.025]   - Field: ‘local’
[16:18:47.025]   - Field: ‘owner’
[16:18:47.025]   - Field: ‘envir’
[16:18:47.025]   - Field: ‘workers’
[16:18:47.026]   - Field: ‘packages’
[16:18:47.026]   - Field: ‘gc’
[16:18:47.026]   - Field: ‘conditions’
[16:18:47.026]   - Field: ‘persistent’
[16:18:47.026]   - Field: ‘expr’
[16:18:47.026]   - Field: ‘uuid’
[16:18:47.026]   - Field: ‘seed’
[16:18:47.026]   - Field: ‘version’
[16:18:47.026]   - Field: ‘result’
[16:18:47.026]   - Field: ‘asynchronous’
[16:18:47.026]   - Field: ‘calls’
[16:18:47.027]   - Field: ‘globals’
[16:18:47.027]   - Field: ‘stdout’
[16:18:47.027]   - Field: ‘earlySignal’
[16:18:47.027]   - Field: ‘lazy’
[16:18:47.027]   - Field: ‘state’
[16:18:47.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:47.027] - Launch lazy future ...
[16:18:47.027] Packages needed by the future expression (n = 1): ‘stats’
[16:18:47.027] Packages needed by future strategies (n = 0): <none>
[16:18:47.028] {
[16:18:47.028]     {
[16:18:47.028]         {
[16:18:47.028]             ...future.startTime <- base::Sys.time()
[16:18:47.028]             {
[16:18:47.028]                 {
[16:18:47.028]                   {
[16:18:47.028]                     {
[16:18:47.028]                       {
[16:18:47.028]                         base::local({
[16:18:47.028]                           has_future <- base::requireNamespace("future", 
[16:18:47.028]                             quietly = TRUE)
[16:18:47.028]                           if (has_future) {
[16:18:47.028]                             ns <- base::getNamespace("future")
[16:18:47.028]                             version <- ns[[".package"]][["version"]]
[16:18:47.028]                             if (is.null(version)) 
[16:18:47.028]                               version <- utils::packageVersion("future")
[16:18:47.028]                           }
[16:18:47.028]                           else {
[16:18:47.028]                             version <- NULL
[16:18:47.028]                           }
[16:18:47.028]                           if (!has_future || version < "1.8.0") {
[16:18:47.028]                             info <- base::c(r_version = base::gsub("R version ", 
[16:18:47.028]                               "", base::R.version$version.string), 
[16:18:47.028]                               platform = base::sprintf("%s (%s-bit)", 
[16:18:47.028]                                 base::R.version$platform, 8 * 
[16:18:47.028]                                   base::.Machine$sizeof.pointer), 
[16:18:47.028]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:47.028]                                 "release", "version")], collapse = " "), 
[16:18:47.028]                               hostname = base::Sys.info()[["nodename"]])
[16:18:47.028]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:18:47.028]                               info)
[16:18:47.028]                             info <- base::paste(info, collapse = "; ")
[16:18:47.028]                             if (!has_future) {
[16:18:47.028]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:47.028]                                 info)
[16:18:47.028]                             }
[16:18:47.028]                             else {
[16:18:47.028]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:47.028]                                 info, version)
[16:18:47.028]                             }
[16:18:47.028]                             base::stop(msg)
[16:18:47.028]                           }
[16:18:47.028]                         })
[16:18:47.028]                       }
[16:18:47.028]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:47.028]                       base::options(mc.cores = 1L)
[16:18:47.028]                     }
[16:18:47.028]                     base::local({
[16:18:47.028]                       for (pkg in "stats") {
[16:18:47.028]                         base::loadNamespace(pkg)
[16:18:47.028]                         base::library(pkg, character.only = TRUE)
[16:18:47.028]                       }
[16:18:47.028]                     })
[16:18:47.028]                   }
[16:18:47.028]                   ...future.strategy.old <- future::plan("list")
[16:18:47.028]                   options(future.plan = NULL)
[16:18:47.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:47.028]                 }
[16:18:47.028]                 ...future.workdir <- getwd()
[16:18:47.028]             }
[16:18:47.028]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:47.028]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:47.028]         }
[16:18:47.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:47.028]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:47.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:47.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:47.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:47.028]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:47.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:47.028]             base::names(...future.oldOptions))
[16:18:47.028]     }
[16:18:47.028]     if (FALSE) {
[16:18:47.028]     }
[16:18:47.028]     else {
[16:18:47.028]         if (TRUE) {
[16:18:47.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:47.028]                 open = "w")
[16:18:47.028]         }
[16:18:47.028]         else {
[16:18:47.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:47.028]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:47.028]         }
[16:18:47.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:47.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:47.028]             base::sink(type = "output", split = FALSE)
[16:18:47.028]             base::close(...future.stdout)
[16:18:47.028]         }, add = TRUE)
[16:18:47.028]     }
[16:18:47.028]     ...future.frame <- base::sys.nframe()
[16:18:47.028]     ...future.conditions <- base::list()
[16:18:47.028]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:47.028]     if (FALSE) {
[16:18:47.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:47.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:47.028]     }
[16:18:47.028]     ...future.result <- base::tryCatch({
[16:18:47.028]         base::withCallingHandlers({
[16:18:47.028]             ...future.value <- base::withVisible(base::local({
[16:18:47.028]                 ...future.makeSendCondition <- base::local({
[16:18:47.028]                   sendCondition <- NULL
[16:18:47.028]                   function(frame = 1L) {
[16:18:47.028]                     if (is.function(sendCondition)) 
[16:18:47.028]                       return(sendCondition)
[16:18:47.028]                     ns <- getNamespace("parallel")
[16:18:47.028]                     if (exists("sendData", mode = "function", 
[16:18:47.028]                       envir = ns)) {
[16:18:47.028]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:47.028]                         envir = ns)
[16:18:47.028]                       envir <- sys.frame(frame)
[16:18:47.028]                       master <- NULL
[16:18:47.028]                       while (!identical(envir, .GlobalEnv) && 
[16:18:47.028]                         !identical(envir, emptyenv())) {
[16:18:47.028]                         if (exists("master", mode = "list", envir = envir, 
[16:18:47.028]                           inherits = FALSE)) {
[16:18:47.028]                           master <- get("master", mode = "list", 
[16:18:47.028]                             envir = envir, inherits = FALSE)
[16:18:47.028]                           if (inherits(master, c("SOCKnode", 
[16:18:47.028]                             "SOCK0node"))) {
[16:18:47.028]                             sendCondition <<- function(cond) {
[16:18:47.028]                               data <- list(type = "VALUE", value = cond, 
[16:18:47.028]                                 success = TRUE)
[16:18:47.028]                               parallel_sendData(master, data)
[16:18:47.028]                             }
[16:18:47.028]                             return(sendCondition)
[16:18:47.028]                           }
[16:18:47.028]                         }
[16:18:47.028]                         frame <- frame + 1L
[16:18:47.028]                         envir <- sys.frame(frame)
[16:18:47.028]                       }
[16:18:47.028]                     }
[16:18:47.028]                     sendCondition <<- function(cond) NULL
[16:18:47.028]                   }
[16:18:47.028]                 })
[16:18:47.028]                 withCallingHandlers({
[16:18:47.028]                   {
[16:18:47.028]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.028]                     if (!identical(...future.globals.maxSize.org, 
[16:18:47.028]                       ...future.globals.maxSize)) {
[16:18:47.028]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.028]                       on.exit(options(oopts), add = TRUE)
[16:18:47.028]                     }
[16:18:47.028]                     {
[16:18:47.028]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.028]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:47.028]                         USE.NAMES = FALSE)
[16:18:47.028]                       do.call(mapply, args = args)
[16:18:47.028]                     }
[16:18:47.028]                   }
[16:18:47.028]                 }, immediateCondition = function(cond) {
[16:18:47.028]                   sendCondition <- ...future.makeSendCondition()
[16:18:47.028]                   sendCondition(cond)
[16:18:47.028]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.028]                   {
[16:18:47.028]                     inherits <- base::inherits
[16:18:47.028]                     invokeRestart <- base::invokeRestart
[16:18:47.028]                     is.null <- base::is.null
[16:18:47.028]                     muffled <- FALSE
[16:18:47.028]                     if (inherits(cond, "message")) {
[16:18:47.028]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:47.028]                       if (muffled) 
[16:18:47.028]                         invokeRestart("muffleMessage")
[16:18:47.028]                     }
[16:18:47.028]                     else if (inherits(cond, "warning")) {
[16:18:47.028]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:47.028]                       if (muffled) 
[16:18:47.028]                         invokeRestart("muffleWarning")
[16:18:47.028]                     }
[16:18:47.028]                     else if (inherits(cond, "condition")) {
[16:18:47.028]                       if (!is.null(pattern)) {
[16:18:47.028]                         computeRestarts <- base::computeRestarts
[16:18:47.028]                         grepl <- base::grepl
[16:18:47.028]                         restarts <- computeRestarts(cond)
[16:18:47.028]                         for (restart in restarts) {
[16:18:47.028]                           name <- restart$name
[16:18:47.028]                           if (is.null(name)) 
[16:18:47.028]                             next
[16:18:47.028]                           if (!grepl(pattern, name)) 
[16:18:47.028]                             next
[16:18:47.028]                           invokeRestart(restart)
[16:18:47.028]                           muffled <- TRUE
[16:18:47.028]                           break
[16:18:47.028]                         }
[16:18:47.028]                       }
[16:18:47.028]                     }
[16:18:47.028]                     invisible(muffled)
[16:18:47.028]                   }
[16:18:47.028]                   muffleCondition(cond)
[16:18:47.028]                 })
[16:18:47.028]             }))
[16:18:47.028]             future::FutureResult(value = ...future.value$value, 
[16:18:47.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.028]                   ...future.rng), globalenv = if (FALSE) 
[16:18:47.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:47.028]                     ...future.globalenv.names))
[16:18:47.028]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:47.028]         }, condition = base::local({
[16:18:47.028]             c <- base::c
[16:18:47.028]             inherits <- base::inherits
[16:18:47.028]             invokeRestart <- base::invokeRestart
[16:18:47.028]             length <- base::length
[16:18:47.028]             list <- base::list
[16:18:47.028]             seq.int <- base::seq.int
[16:18:47.028]             signalCondition <- base::signalCondition
[16:18:47.028]             sys.calls <- base::sys.calls
[16:18:47.028]             `[[` <- base::`[[`
[16:18:47.028]             `+` <- base::`+`
[16:18:47.028]             `<<-` <- base::`<<-`
[16:18:47.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:47.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:47.028]                   3L)]
[16:18:47.028]             }
[16:18:47.028]             function(cond) {
[16:18:47.028]                 is_error <- inherits(cond, "error")
[16:18:47.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:47.028]                   NULL)
[16:18:47.028]                 if (is_error) {
[16:18:47.028]                   sessionInformation <- function() {
[16:18:47.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:47.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:47.028]                       search = base::search(), system = base::Sys.info())
[16:18:47.028]                   }
[16:18:47.028]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:47.028]                     cond$call), session = sessionInformation(), 
[16:18:47.028]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:47.028]                   signalCondition(cond)
[16:18:47.028]                 }
[16:18:47.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:47.028]                 "immediateCondition"))) {
[16:18:47.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:47.028]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:47.028]                   if (TRUE && !signal) {
[16:18:47.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.028]                     {
[16:18:47.028]                       inherits <- base::inherits
[16:18:47.028]                       invokeRestart <- base::invokeRestart
[16:18:47.028]                       is.null <- base::is.null
[16:18:47.028]                       muffled <- FALSE
[16:18:47.028]                       if (inherits(cond, "message")) {
[16:18:47.028]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.028]                         if (muffled) 
[16:18:47.028]                           invokeRestart("muffleMessage")
[16:18:47.028]                       }
[16:18:47.028]                       else if (inherits(cond, "warning")) {
[16:18:47.028]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.028]                         if (muffled) 
[16:18:47.028]                           invokeRestart("muffleWarning")
[16:18:47.028]                       }
[16:18:47.028]                       else if (inherits(cond, "condition")) {
[16:18:47.028]                         if (!is.null(pattern)) {
[16:18:47.028]                           computeRestarts <- base::computeRestarts
[16:18:47.028]                           grepl <- base::grepl
[16:18:47.028]                           restarts <- computeRestarts(cond)
[16:18:47.028]                           for (restart in restarts) {
[16:18:47.028]                             name <- restart$name
[16:18:47.028]                             if (is.null(name)) 
[16:18:47.028]                               next
[16:18:47.028]                             if (!grepl(pattern, name)) 
[16:18:47.028]                               next
[16:18:47.028]                             invokeRestart(restart)
[16:18:47.028]                             muffled <- TRUE
[16:18:47.028]                             break
[16:18:47.028]                           }
[16:18:47.028]                         }
[16:18:47.028]                       }
[16:18:47.028]                       invisible(muffled)
[16:18:47.028]                     }
[16:18:47.028]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.028]                   }
[16:18:47.028]                 }
[16:18:47.028]                 else {
[16:18:47.028]                   if (TRUE) {
[16:18:47.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.028]                     {
[16:18:47.028]                       inherits <- base::inherits
[16:18:47.028]                       invokeRestart <- base::invokeRestart
[16:18:47.028]                       is.null <- base::is.null
[16:18:47.028]                       muffled <- FALSE
[16:18:47.028]                       if (inherits(cond, "message")) {
[16:18:47.028]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.028]                         if (muffled) 
[16:18:47.028]                           invokeRestart("muffleMessage")
[16:18:47.028]                       }
[16:18:47.028]                       else if (inherits(cond, "warning")) {
[16:18:47.028]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.028]                         if (muffled) 
[16:18:47.028]                           invokeRestart("muffleWarning")
[16:18:47.028]                       }
[16:18:47.028]                       else if (inherits(cond, "condition")) {
[16:18:47.028]                         if (!is.null(pattern)) {
[16:18:47.028]                           computeRestarts <- base::computeRestarts
[16:18:47.028]                           grepl <- base::grepl
[16:18:47.028]                           restarts <- computeRestarts(cond)
[16:18:47.028]                           for (restart in restarts) {
[16:18:47.028]                             name <- restart$name
[16:18:47.028]                             if (is.null(name)) 
[16:18:47.028]                               next
[16:18:47.028]                             if (!grepl(pattern, name)) 
[16:18:47.028]                               next
[16:18:47.028]                             invokeRestart(restart)
[16:18:47.028]                             muffled <- TRUE
[16:18:47.028]                             break
[16:18:47.028]                           }
[16:18:47.028]                         }
[16:18:47.028]                       }
[16:18:47.028]                       invisible(muffled)
[16:18:47.028]                     }
[16:18:47.028]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.028]                   }
[16:18:47.028]                 }
[16:18:47.028]             }
[16:18:47.028]         }))
[16:18:47.028]     }, error = function(ex) {
[16:18:47.028]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:47.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.028]                 ...future.rng), started = ...future.startTime, 
[16:18:47.028]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:47.028]             version = "1.8"), class = "FutureResult")
[16:18:47.028]     }, finally = {
[16:18:47.028]         if (!identical(...future.workdir, getwd())) 
[16:18:47.028]             setwd(...future.workdir)
[16:18:47.028]         {
[16:18:47.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:47.028]                 ...future.oldOptions$nwarnings <- NULL
[16:18:47.028]             }
[16:18:47.028]             base::options(...future.oldOptions)
[16:18:47.028]             if (.Platform$OS.type == "windows") {
[16:18:47.028]                 old_names <- names(...future.oldEnvVars)
[16:18:47.028]                 envs <- base::Sys.getenv()
[16:18:47.028]                 names <- names(envs)
[16:18:47.028]                 common <- intersect(names, old_names)
[16:18:47.028]                 added <- setdiff(names, old_names)
[16:18:47.028]                 removed <- setdiff(old_names, names)
[16:18:47.028]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:47.028]                   envs[common]]
[16:18:47.028]                 NAMES <- toupper(changed)
[16:18:47.028]                 args <- list()
[16:18:47.028]                 for (kk in seq_along(NAMES)) {
[16:18:47.028]                   name <- changed[[kk]]
[16:18:47.028]                   NAME <- NAMES[[kk]]
[16:18:47.028]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.028]                     next
[16:18:47.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.028]                 }
[16:18:47.028]                 NAMES <- toupper(added)
[16:18:47.028]                 for (kk in seq_along(NAMES)) {
[16:18:47.028]                   name <- added[[kk]]
[16:18:47.028]                   NAME <- NAMES[[kk]]
[16:18:47.028]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.028]                     next
[16:18:47.028]                   args[[name]] <- ""
[16:18:47.028]                 }
[16:18:47.028]                 NAMES <- toupper(removed)
[16:18:47.028]                 for (kk in seq_along(NAMES)) {
[16:18:47.028]                   name <- removed[[kk]]
[16:18:47.028]                   NAME <- NAMES[[kk]]
[16:18:47.028]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.028]                     next
[16:18:47.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.028]                 }
[16:18:47.028]                 if (length(args) > 0) 
[16:18:47.028]                   base::do.call(base::Sys.setenv, args = args)
[16:18:47.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:47.028]             }
[16:18:47.028]             else {
[16:18:47.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:47.028]             }
[16:18:47.028]             {
[16:18:47.028]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:47.028]                   0L) {
[16:18:47.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:47.028]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:47.028]                   base::options(opts)
[16:18:47.028]                 }
[16:18:47.028]                 {
[16:18:47.028]                   {
[16:18:47.028]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:47.028]                     NULL
[16:18:47.028]                   }
[16:18:47.028]                   options(future.plan = NULL)
[16:18:47.028]                   if (is.na(NA_character_)) 
[16:18:47.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:47.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:47.028]                     .init = FALSE)
[16:18:47.028]                 }
[16:18:47.028]             }
[16:18:47.028]         }
[16:18:47.028]     })
[16:18:47.028]     if (TRUE) {
[16:18:47.028]         base::sink(type = "output", split = FALSE)
[16:18:47.028]         if (TRUE) {
[16:18:47.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:47.028]         }
[16:18:47.028]         else {
[16:18:47.028]             ...future.result["stdout"] <- base::list(NULL)
[16:18:47.028]         }
[16:18:47.028]         base::close(...future.stdout)
[16:18:47.028]         ...future.stdout <- NULL
[16:18:47.028]     }
[16:18:47.028]     ...future.result$conditions <- ...future.conditions
[16:18:47.028]     ...future.result$finished <- base::Sys.time()
[16:18:47.028]     ...future.result
[16:18:47.028] }
[16:18:47.031] Exporting 5 global objects (2.07 KiB) to cluster node #1 ...
[16:18:47.031] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ...
[16:18:47.031] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ... DONE
[16:18:47.031] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:47.032] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:47.032] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ...
[16:18:47.032] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ... DONE
[16:18:47.032] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:47.033] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:47.033] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:47.033] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:47.033] Exporting 5 global objects (2.07 KiB) to cluster node #1 ... DONE
[16:18:47.034] MultisessionFuture started
[16:18:47.034] - Launch lazy future ... done
[16:18:47.034] run() for ‘MultisessionFuture’ ... done
[16:18:47.034] Created future:
[16:18:47.034] MultisessionFuture:
[16:18:47.034] Label: ‘future_Map-1’
[16:18:47.034] Expression:
[16:18:47.034] {
[16:18:47.034]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.034]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:47.034]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.034]         on.exit(options(oopts), add = TRUE)
[16:18:47.034]     }
[16:18:47.034]     {
[16:18:47.034]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.034]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:47.034]         do.call(mapply, args = args)
[16:18:47.034]     }
[16:18:47.034] }
[16:18:47.034] Lazy evaluation: FALSE
[16:18:47.034] Asynchronous evaluation: TRUE
[16:18:47.034] Local evaluation: TRUE
[16:18:47.034] Environment: R_GlobalEnv
[16:18:47.034] Capture standard output: TRUE
[16:18:47.034] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:47.034] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:47.034] Packages: 1 packages (‘stats’)
[16:18:47.034] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:47.034] Resolved: FALSE
[16:18:47.034] Value: <not collected>
[16:18:47.034] Conditions captured: <none>
[16:18:47.034] Early signaling: FALSE
[16:18:47.034] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:47.034] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.045] Chunk #1 of 2 ... DONE
[16:18:47.046] Chunk #2 of 2 ...
[16:18:47.046]  - Finding globals in '...' for chunk #2 ...
[16:18:47.046] getGlobalsAndPackages() ...
[16:18:47.046] Searching for globals...
[16:18:47.046] 
[16:18:47.046] Searching for globals ... DONE
[16:18:47.046] - globals: [0] <none>
[16:18:47.047] getGlobalsAndPackages() ... DONE
[16:18:47.047]    + additional globals found: [n=0] 
[16:18:47.047]    + additional namespaces needed: [n=0] 
[16:18:47.047]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:47.047]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:47.047]  - seeds: <none>
[16:18:47.047]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.047] getGlobalsAndPackages() ...
[16:18:47.047] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.047] Resolving globals: FALSE
[16:18:47.048] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[16:18:47.048] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:47.049] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.049] - packages: [1] ‘stats’
[16:18:47.049] getGlobalsAndPackages() ... DONE
[16:18:47.049] run() for ‘Future’ ...
[16:18:47.049] - state: ‘created’
[16:18:47.049] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:47.063] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:47.063]   - Field: ‘node’
[16:18:47.064]   - Field: ‘label’
[16:18:47.064]   - Field: ‘local’
[16:18:47.064]   - Field: ‘owner’
[16:18:47.064]   - Field: ‘envir’
[16:18:47.064]   - Field: ‘workers’
[16:18:47.064]   - Field: ‘packages’
[16:18:47.064]   - Field: ‘gc’
[16:18:47.064]   - Field: ‘conditions’
[16:18:47.064]   - Field: ‘persistent’
[16:18:47.064]   - Field: ‘expr’
[16:18:47.064]   - Field: ‘uuid’
[16:18:47.065]   - Field: ‘seed’
[16:18:47.065]   - Field: ‘version’
[16:18:47.065]   - Field: ‘result’
[16:18:47.065]   - Field: ‘asynchronous’
[16:18:47.065]   - Field: ‘calls’
[16:18:47.065]   - Field: ‘globals’
[16:18:47.065]   - Field: ‘stdout’
[16:18:47.065]   - Field: ‘earlySignal’
[16:18:47.065]   - Field: ‘lazy’
[16:18:47.065]   - Field: ‘state’
[16:18:47.066] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:47.066] - Launch lazy future ...
[16:18:47.066] Packages needed by the future expression (n = 1): ‘stats’
[16:18:47.066] Packages needed by future strategies (n = 0): <none>
[16:18:47.067] {
[16:18:47.067]     {
[16:18:47.067]         {
[16:18:47.067]             ...future.startTime <- base::Sys.time()
[16:18:47.067]             {
[16:18:47.067]                 {
[16:18:47.067]                   {
[16:18:47.067]                     {
[16:18:47.067]                       {
[16:18:47.067]                         base::local({
[16:18:47.067]                           has_future <- base::requireNamespace("future", 
[16:18:47.067]                             quietly = TRUE)
[16:18:47.067]                           if (has_future) {
[16:18:47.067]                             ns <- base::getNamespace("future")
[16:18:47.067]                             version <- ns[[".package"]][["version"]]
[16:18:47.067]                             if (is.null(version)) 
[16:18:47.067]                               version <- utils::packageVersion("future")
[16:18:47.067]                           }
[16:18:47.067]                           else {
[16:18:47.067]                             version <- NULL
[16:18:47.067]                           }
[16:18:47.067]                           if (!has_future || version < "1.8.0") {
[16:18:47.067]                             info <- base::c(r_version = base::gsub("R version ", 
[16:18:47.067]                               "", base::R.version$version.string), 
[16:18:47.067]                               platform = base::sprintf("%s (%s-bit)", 
[16:18:47.067]                                 base::R.version$platform, 8 * 
[16:18:47.067]                                   base::.Machine$sizeof.pointer), 
[16:18:47.067]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:47.067]                                 "release", "version")], collapse = " "), 
[16:18:47.067]                               hostname = base::Sys.info()[["nodename"]])
[16:18:47.067]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:18:47.067]                               info)
[16:18:47.067]                             info <- base::paste(info, collapse = "; ")
[16:18:47.067]                             if (!has_future) {
[16:18:47.067]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:47.067]                                 info)
[16:18:47.067]                             }
[16:18:47.067]                             else {
[16:18:47.067]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:47.067]                                 info, version)
[16:18:47.067]                             }
[16:18:47.067]                             base::stop(msg)
[16:18:47.067]                           }
[16:18:47.067]                         })
[16:18:47.067]                       }
[16:18:47.067]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:47.067]                       base::options(mc.cores = 1L)
[16:18:47.067]                     }
[16:18:47.067]                     base::local({
[16:18:47.067]                       for (pkg in "stats") {
[16:18:47.067]                         base::loadNamespace(pkg)
[16:18:47.067]                         base::library(pkg, character.only = TRUE)
[16:18:47.067]                       }
[16:18:47.067]                     })
[16:18:47.067]                   }
[16:18:47.067]                   ...future.strategy.old <- future::plan("list")
[16:18:47.067]                   options(future.plan = NULL)
[16:18:47.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:47.067]                 }
[16:18:47.067]                 ...future.workdir <- getwd()
[16:18:47.067]             }
[16:18:47.067]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:47.067]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:47.067]         }
[16:18:47.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:47.067]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:47.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:47.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:47.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:47.067]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:47.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:47.067]             base::names(...future.oldOptions))
[16:18:47.067]     }
[16:18:47.067]     if (FALSE) {
[16:18:47.067]     }
[16:18:47.067]     else {
[16:18:47.067]         if (TRUE) {
[16:18:47.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:47.067]                 open = "w")
[16:18:47.067]         }
[16:18:47.067]         else {
[16:18:47.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:47.067]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:47.067]         }
[16:18:47.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:47.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:47.067]             base::sink(type = "output", split = FALSE)
[16:18:47.067]             base::close(...future.stdout)
[16:18:47.067]         }, add = TRUE)
[16:18:47.067]     }
[16:18:47.067]     ...future.frame <- base::sys.nframe()
[16:18:47.067]     ...future.conditions <- base::list()
[16:18:47.067]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:47.067]     if (FALSE) {
[16:18:47.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:47.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:47.067]     }
[16:18:47.067]     ...future.result <- base::tryCatch({
[16:18:47.067]         base::withCallingHandlers({
[16:18:47.067]             ...future.value <- base::withVisible(base::local({
[16:18:47.067]                 ...future.makeSendCondition <- base::local({
[16:18:47.067]                   sendCondition <- NULL
[16:18:47.067]                   function(frame = 1L) {
[16:18:47.067]                     if (is.function(sendCondition)) 
[16:18:47.067]                       return(sendCondition)
[16:18:47.067]                     ns <- getNamespace("parallel")
[16:18:47.067]                     if (exists("sendData", mode = "function", 
[16:18:47.067]                       envir = ns)) {
[16:18:47.067]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:47.067]                         envir = ns)
[16:18:47.067]                       envir <- sys.frame(frame)
[16:18:47.067]                       master <- NULL
[16:18:47.067]                       while (!identical(envir, .GlobalEnv) && 
[16:18:47.067]                         !identical(envir, emptyenv())) {
[16:18:47.067]                         if (exists("master", mode = "list", envir = envir, 
[16:18:47.067]                           inherits = FALSE)) {
[16:18:47.067]                           master <- get("master", mode = "list", 
[16:18:47.067]                             envir = envir, inherits = FALSE)
[16:18:47.067]                           if (inherits(master, c("SOCKnode", 
[16:18:47.067]                             "SOCK0node"))) {
[16:18:47.067]                             sendCondition <<- function(cond) {
[16:18:47.067]                               data <- list(type = "VALUE", value = cond, 
[16:18:47.067]                                 success = TRUE)
[16:18:47.067]                               parallel_sendData(master, data)
[16:18:47.067]                             }
[16:18:47.067]                             return(sendCondition)
[16:18:47.067]                           }
[16:18:47.067]                         }
[16:18:47.067]                         frame <- frame + 1L
[16:18:47.067]                         envir <- sys.frame(frame)
[16:18:47.067]                       }
[16:18:47.067]                     }
[16:18:47.067]                     sendCondition <<- function(cond) NULL
[16:18:47.067]                   }
[16:18:47.067]                 })
[16:18:47.067]                 withCallingHandlers({
[16:18:47.067]                   {
[16:18:47.067]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.067]                     if (!identical(...future.globals.maxSize.org, 
[16:18:47.067]                       ...future.globals.maxSize)) {
[16:18:47.067]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.067]                       on.exit(options(oopts), add = TRUE)
[16:18:47.067]                     }
[16:18:47.067]                     {
[16:18:47.067]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.067]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:47.067]                         USE.NAMES = FALSE)
[16:18:47.067]                       do.call(mapply, args = args)
[16:18:47.067]                     }
[16:18:47.067]                   }
[16:18:47.067]                 }, immediateCondition = function(cond) {
[16:18:47.067]                   sendCondition <- ...future.makeSendCondition()
[16:18:47.067]                   sendCondition(cond)
[16:18:47.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.067]                   {
[16:18:47.067]                     inherits <- base::inherits
[16:18:47.067]                     invokeRestart <- base::invokeRestart
[16:18:47.067]                     is.null <- base::is.null
[16:18:47.067]                     muffled <- FALSE
[16:18:47.067]                     if (inherits(cond, "message")) {
[16:18:47.067]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:47.067]                       if (muffled) 
[16:18:47.067]                         invokeRestart("muffleMessage")
[16:18:47.067]                     }
[16:18:47.067]                     else if (inherits(cond, "warning")) {
[16:18:47.067]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:47.067]                       if (muffled) 
[16:18:47.067]                         invokeRestart("muffleWarning")
[16:18:47.067]                     }
[16:18:47.067]                     else if (inherits(cond, "condition")) {
[16:18:47.067]                       if (!is.null(pattern)) {
[16:18:47.067]                         computeRestarts <- base::computeRestarts
[16:18:47.067]                         grepl <- base::grepl
[16:18:47.067]                         restarts <- computeRestarts(cond)
[16:18:47.067]                         for (restart in restarts) {
[16:18:47.067]                           name <- restart$name
[16:18:47.067]                           if (is.null(name)) 
[16:18:47.067]                             next
[16:18:47.067]                           if (!grepl(pattern, name)) 
[16:18:47.067]                             next
[16:18:47.067]                           invokeRestart(restart)
[16:18:47.067]                           muffled <- TRUE
[16:18:47.067]                           break
[16:18:47.067]                         }
[16:18:47.067]                       }
[16:18:47.067]                     }
[16:18:47.067]                     invisible(muffled)
[16:18:47.067]                   }
[16:18:47.067]                   muffleCondition(cond)
[16:18:47.067]                 })
[16:18:47.067]             }))
[16:18:47.067]             future::FutureResult(value = ...future.value$value, 
[16:18:47.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.067]                   ...future.rng), globalenv = if (FALSE) 
[16:18:47.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:47.067]                     ...future.globalenv.names))
[16:18:47.067]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:47.067]         }, condition = base::local({
[16:18:47.067]             c <- base::c
[16:18:47.067]             inherits <- base::inherits
[16:18:47.067]             invokeRestart <- base::invokeRestart
[16:18:47.067]             length <- base::length
[16:18:47.067]             list <- base::list
[16:18:47.067]             seq.int <- base::seq.int
[16:18:47.067]             signalCondition <- base::signalCondition
[16:18:47.067]             sys.calls <- base::sys.calls
[16:18:47.067]             `[[` <- base::`[[`
[16:18:47.067]             `+` <- base::`+`
[16:18:47.067]             `<<-` <- base::`<<-`
[16:18:47.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:47.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:47.067]                   3L)]
[16:18:47.067]             }
[16:18:47.067]             function(cond) {
[16:18:47.067]                 is_error <- inherits(cond, "error")
[16:18:47.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:47.067]                   NULL)
[16:18:47.067]                 if (is_error) {
[16:18:47.067]                   sessionInformation <- function() {
[16:18:47.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:47.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:47.067]                       search = base::search(), system = base::Sys.info())
[16:18:47.067]                   }
[16:18:47.067]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:47.067]                     cond$call), session = sessionInformation(), 
[16:18:47.067]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:47.067]                   signalCondition(cond)
[16:18:47.067]                 }
[16:18:47.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:47.067]                 "immediateCondition"))) {
[16:18:47.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:47.067]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:47.067]                   if (TRUE && !signal) {
[16:18:47.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.067]                     {
[16:18:47.067]                       inherits <- base::inherits
[16:18:47.067]                       invokeRestart <- base::invokeRestart
[16:18:47.067]                       is.null <- base::is.null
[16:18:47.067]                       muffled <- FALSE
[16:18:47.067]                       if (inherits(cond, "message")) {
[16:18:47.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.067]                         if (muffled) 
[16:18:47.067]                           invokeRestart("muffleMessage")
[16:18:47.067]                       }
[16:18:47.067]                       else if (inherits(cond, "warning")) {
[16:18:47.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.067]                         if (muffled) 
[16:18:47.067]                           invokeRestart("muffleWarning")
[16:18:47.067]                       }
[16:18:47.067]                       else if (inherits(cond, "condition")) {
[16:18:47.067]                         if (!is.null(pattern)) {
[16:18:47.067]                           computeRestarts <- base::computeRestarts
[16:18:47.067]                           grepl <- base::grepl
[16:18:47.067]                           restarts <- computeRestarts(cond)
[16:18:47.067]                           for (restart in restarts) {
[16:18:47.067]                             name <- restart$name
[16:18:47.067]                             if (is.null(name)) 
[16:18:47.067]                               next
[16:18:47.067]                             if (!grepl(pattern, name)) 
[16:18:47.067]                               next
[16:18:47.067]                             invokeRestart(restart)
[16:18:47.067]                             muffled <- TRUE
[16:18:47.067]                             break
[16:18:47.067]                           }
[16:18:47.067]                         }
[16:18:47.067]                       }
[16:18:47.067]                       invisible(muffled)
[16:18:47.067]                     }
[16:18:47.067]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.067]                   }
[16:18:47.067]                 }
[16:18:47.067]                 else {
[16:18:47.067]                   if (TRUE) {
[16:18:47.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.067]                     {
[16:18:47.067]                       inherits <- base::inherits
[16:18:47.067]                       invokeRestart <- base::invokeRestart
[16:18:47.067]                       is.null <- base::is.null
[16:18:47.067]                       muffled <- FALSE
[16:18:47.067]                       if (inherits(cond, "message")) {
[16:18:47.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.067]                         if (muffled) 
[16:18:47.067]                           invokeRestart("muffleMessage")
[16:18:47.067]                       }
[16:18:47.067]                       else if (inherits(cond, "warning")) {
[16:18:47.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.067]                         if (muffled) 
[16:18:47.067]                           invokeRestart("muffleWarning")
[16:18:47.067]                       }
[16:18:47.067]                       else if (inherits(cond, "condition")) {
[16:18:47.067]                         if (!is.null(pattern)) {
[16:18:47.067]                           computeRestarts <- base::computeRestarts
[16:18:47.067]                           grepl <- base::grepl
[16:18:47.067]                           restarts <- computeRestarts(cond)
[16:18:47.067]                           for (restart in restarts) {
[16:18:47.067]                             name <- restart$name
[16:18:47.067]                             if (is.null(name)) 
[16:18:47.067]                               next
[16:18:47.067]                             if (!grepl(pattern, name)) 
[16:18:47.067]                               next
[16:18:47.067]                             invokeRestart(restart)
[16:18:47.067]                             muffled <- TRUE
[16:18:47.067]                             break
[16:18:47.067]                           }
[16:18:47.067]                         }
[16:18:47.067]                       }
[16:18:47.067]                       invisible(muffled)
[16:18:47.067]                     }
[16:18:47.067]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.067]                   }
[16:18:47.067]                 }
[16:18:47.067]             }
[16:18:47.067]         }))
[16:18:47.067]     }, error = function(ex) {
[16:18:47.067]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:47.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.067]                 ...future.rng), started = ...future.startTime, 
[16:18:47.067]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:47.067]             version = "1.8"), class = "FutureResult")
[16:18:47.067]     }, finally = {
[16:18:47.067]         if (!identical(...future.workdir, getwd())) 
[16:18:47.067]             setwd(...future.workdir)
[16:18:47.067]         {
[16:18:47.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:47.067]                 ...future.oldOptions$nwarnings <- NULL
[16:18:47.067]             }
[16:18:47.067]             base::options(...future.oldOptions)
[16:18:47.067]             if (.Platform$OS.type == "windows") {
[16:18:47.067]                 old_names <- names(...future.oldEnvVars)
[16:18:47.067]                 envs <- base::Sys.getenv()
[16:18:47.067]                 names <- names(envs)
[16:18:47.067]                 common <- intersect(names, old_names)
[16:18:47.067]                 added <- setdiff(names, old_names)
[16:18:47.067]                 removed <- setdiff(old_names, names)
[16:18:47.067]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:47.067]                   envs[common]]
[16:18:47.067]                 NAMES <- toupper(changed)
[16:18:47.067]                 args <- list()
[16:18:47.067]                 for (kk in seq_along(NAMES)) {
[16:18:47.067]                   name <- changed[[kk]]
[16:18:47.067]                   NAME <- NAMES[[kk]]
[16:18:47.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.067]                     next
[16:18:47.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.067]                 }
[16:18:47.067]                 NAMES <- toupper(added)
[16:18:47.067]                 for (kk in seq_along(NAMES)) {
[16:18:47.067]                   name <- added[[kk]]
[16:18:47.067]                   NAME <- NAMES[[kk]]
[16:18:47.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.067]                     next
[16:18:47.067]                   args[[name]] <- ""
[16:18:47.067]                 }
[16:18:47.067]                 NAMES <- toupper(removed)
[16:18:47.067]                 for (kk in seq_along(NAMES)) {
[16:18:47.067]                   name <- removed[[kk]]
[16:18:47.067]                   NAME <- NAMES[[kk]]
[16:18:47.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.067]                     next
[16:18:47.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.067]                 }
[16:18:47.067]                 if (length(args) > 0) 
[16:18:47.067]                   base::do.call(base::Sys.setenv, args = args)
[16:18:47.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:47.067]             }
[16:18:47.067]             else {
[16:18:47.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:47.067]             }
[16:18:47.067]             {
[16:18:47.067]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:47.067]                   0L) {
[16:18:47.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:47.067]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:47.067]                   base::options(opts)
[16:18:47.067]                 }
[16:18:47.067]                 {
[16:18:47.067]                   {
[16:18:47.067]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:47.067]                     NULL
[16:18:47.067]                   }
[16:18:47.067]                   options(future.plan = NULL)
[16:18:47.067]                   if (is.na(NA_character_)) 
[16:18:47.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:47.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:47.067]                     .init = FALSE)
[16:18:47.067]                 }
[16:18:47.067]             }
[16:18:47.067]         }
[16:18:47.067]     })
[16:18:47.067]     if (TRUE) {
[16:18:47.067]         base::sink(type = "output", split = FALSE)
[16:18:47.067]         if (TRUE) {
[16:18:47.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:47.067]         }
[16:18:47.067]         else {
[16:18:47.067]             ...future.result["stdout"] <- base::list(NULL)
[16:18:47.067]         }
[16:18:47.067]         base::close(...future.stdout)
[16:18:47.067]         ...future.stdout <- NULL
[16:18:47.067]     }
[16:18:47.067]     ...future.result$conditions <- ...future.conditions
[16:18:47.067]     ...future.result$finished <- base::Sys.time()
[16:18:47.067]     ...future.result
[16:18:47.067] }
[16:18:47.069] Exporting 5 global objects (2.41 KiB) to cluster node #2 ...
[16:18:47.070] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ...
[16:18:47.070] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ... DONE
[16:18:47.070] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:47.070] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:47.071] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ...
[16:18:47.071] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ... DONE
[16:18:47.071] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:47.071] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:47.071] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:47.072] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:47.072] Exporting 5 global objects (2.41 KiB) to cluster node #2 ... DONE
[16:18:47.072] MultisessionFuture started
[16:18:47.072] - Launch lazy future ... done
[16:18:47.073] run() for ‘MultisessionFuture’ ... done
[16:18:47.073] Created future:
[16:18:47.073] MultisessionFuture:
[16:18:47.073] Label: ‘future_Map-2’
[16:18:47.073] Expression:
[16:18:47.073] {
[16:18:47.073]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.073]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:47.073]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.073]         on.exit(options(oopts), add = TRUE)
[16:18:47.073]     }
[16:18:47.073]     {
[16:18:47.073]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.073]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:47.073]         do.call(mapply, args = args)
[16:18:47.073]     }
[16:18:47.073] }
[16:18:47.073] Lazy evaluation: FALSE
[16:18:47.073] Asynchronous evaluation: TRUE
[16:18:47.073] Local evaluation: TRUE
[16:18:47.073] Environment: R_GlobalEnv
[16:18:47.073] Capture standard output: TRUE
[16:18:47.073] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:47.073] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:47.073] Packages: 1 packages (‘stats’)
[16:18:47.073] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:47.073] Resolved: FALSE
[16:18:47.073] Value: <not collected>
[16:18:47.073] Conditions captured: <none>
[16:18:47.073] Early signaling: FALSE
[16:18:47.073] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:47.073] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.084] Chunk #2 of 2 ... DONE
[16:18:47.085] Launching 2 futures (chunks) ... DONE
[16:18:47.085] Resolving 2 futures (chunks) ...
[16:18:47.085] resolve() on list ...
[16:18:47.085]  recursive: 0
[16:18:47.085]  length: 2
[16:18:47.085] 
[16:18:47.086] receiveMessageFromWorker() for ClusterFuture ...
[16:18:47.086] - Validating connection of MultisessionFuture
[16:18:47.086] - received message: FutureResult
[16:18:47.086] - Received FutureResult
[16:18:47.086] - Erased future from FutureRegistry
[16:18:47.086] result() for ClusterFuture ...
[16:18:47.086] - result already collected: FutureResult
[16:18:47.086] result() for ClusterFuture ... done
[16:18:47.086] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:47.087] Future #1
[16:18:47.087] result() for ClusterFuture ...
[16:18:47.087] - result already collected: FutureResult
[16:18:47.087] result() for ClusterFuture ... done
[16:18:47.087] result() for ClusterFuture ...
[16:18:47.087] - result already collected: FutureResult
[16:18:47.087] result() for ClusterFuture ... done
[16:18:47.087] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:47.087] - nx: 2
[16:18:47.087] - relay: TRUE
[16:18:47.087] - stdout: TRUE
[16:18:47.088] - signal: TRUE
[16:18:47.088] - resignal: FALSE
[16:18:47.088] - force: TRUE
[16:18:47.088] - relayed: [n=2] FALSE, FALSE
[16:18:47.088] - queued futures: [n=2] FALSE, FALSE
[16:18:47.088]  - until=1
[16:18:47.088]  - relaying element #1
[16:18:47.088] result() for ClusterFuture ...
[16:18:47.088] - result already collected: FutureResult
[16:18:47.088] result() for ClusterFuture ... done
[16:18:47.089] result() for ClusterFuture ...
[16:18:47.089] - result already collected: FutureResult
[16:18:47.089] result() for ClusterFuture ... done
[16:18:47.089] result() for ClusterFuture ...
[16:18:47.089] - result already collected: FutureResult
[16:18:47.089] result() for ClusterFuture ... done
[16:18:47.089] result() for ClusterFuture ...
[16:18:47.089] - result already collected: FutureResult
[16:18:47.089] result() for ClusterFuture ... done
[16:18:47.089] - relayed: [n=2] TRUE, FALSE
[16:18:47.089] - queued futures: [n=2] TRUE, FALSE
[16:18:47.090] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:47.090]  length: 1 (resolved future 1)
[16:18:47.118] receiveMessageFromWorker() for ClusterFuture ...
[16:18:47.118] - Validating connection of MultisessionFuture
[16:18:47.119] - received message: FutureResult
[16:18:47.119] - Received FutureResult
[16:18:47.119] - Erased future from FutureRegistry
[16:18:47.119] result() for ClusterFuture ...
[16:18:47.119] - result already collected: FutureResult
[16:18:47.119] result() for ClusterFuture ... done
[16:18:47.119] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:47.119] Future #2
[16:18:47.119] result() for ClusterFuture ...
[16:18:47.119] - result already collected: FutureResult
[16:18:47.120] result() for ClusterFuture ... done
[16:18:47.120] result() for ClusterFuture ...
[16:18:47.120] - result already collected: FutureResult
[16:18:47.120] result() for ClusterFuture ... done
[16:18:47.120] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:47.120] - nx: 2
[16:18:47.120] - relay: TRUE
[16:18:47.120] - stdout: TRUE
[16:18:47.120] - signal: TRUE
[16:18:47.120] - resignal: FALSE
[16:18:47.121] - force: TRUE
[16:18:47.121] - relayed: [n=2] TRUE, FALSE
[16:18:47.121] - queued futures: [n=2] TRUE, FALSE
[16:18:47.121]  - until=2
[16:18:47.121]  - relaying element #2
[16:18:47.121] result() for ClusterFuture ...
[16:18:47.121] - result already collected: FutureResult
[16:18:47.121] result() for ClusterFuture ... done
[16:18:47.121] result() for ClusterFuture ...
[16:18:47.121] - result already collected: FutureResult
[16:18:47.121] result() for ClusterFuture ... done
[16:18:47.122] result() for ClusterFuture ...
[16:18:47.122] - result already collected: FutureResult
[16:18:47.122] result() for ClusterFuture ... done
[16:18:47.122] result() for ClusterFuture ...
[16:18:47.122] - result already collected: FutureResult
[16:18:47.122] result() for ClusterFuture ... done
[16:18:47.122] - relayed: [n=2] TRUE, TRUE
[16:18:47.122] - queued futures: [n=2] TRUE, TRUE
[16:18:47.122] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:47.122]  length: 0 (resolved future 2)
[16:18:47.123] Relaying remaining futures
[16:18:47.123] signalConditionsASAP(NULL, pos=0) ...
[16:18:47.123] - nx: 2
[16:18:47.123] - relay: TRUE
[16:18:47.123] - stdout: TRUE
[16:18:47.123] - signal: TRUE
[16:18:47.123] - resignal: FALSE
[16:18:47.126] - force: TRUE
[16:18:47.126] - relayed: [n=2] TRUE, TRUE
[16:18:47.127] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:47.127] - relayed: [n=2] TRUE, TRUE
[16:18:47.127] - queued futures: [n=2] TRUE, TRUE
[16:18:47.127] signalConditionsASAP(NULL, pos=0) ... done
[16:18:47.127] resolve() on list ... DONE
[16:18:47.127] result() for ClusterFuture ...
[16:18:47.127] - result already collected: FutureResult
[16:18:47.127] result() for ClusterFuture ... done
[16:18:47.127] result() for ClusterFuture ...
[16:18:47.127] - result already collected: FutureResult
[16:18:47.128] result() for ClusterFuture ... done
[16:18:47.128] result() for ClusterFuture ...
[16:18:47.128] - result already collected: FutureResult
[16:18:47.128] result() for ClusterFuture ... done
[16:18:47.128] result() for ClusterFuture ...
[16:18:47.128] - result already collected: FutureResult
[16:18:47.128] result() for ClusterFuture ... done
[16:18:47.128]  - Number of value chunks collected: 2
[16:18:47.128] Resolving 2 futures (chunks) ... DONE
[16:18:47.128] Reducing values from 2 chunks ...
[16:18:47.128]  - Number of values collected after concatenation: 5
[16:18:47.129]  - Number of values expected: 5
[16:18:47.129] Reducing values from 2 chunks ... DONE
[16:18:47.129] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[16:18:47.131] future_mapply() ...
[16:18:47.135] Number of chunks: 2
[16:18:47.135] getGlobalsAndPackagesXApply() ...
[16:18:47.135]  - future.globals: TRUE
[16:18:47.135] getGlobalsAndPackages() ...
[16:18:47.135] Searching for globals...
[16:18:47.136] - globals found: [1] ‘FUN’
[16:18:47.136] Searching for globals ... DONE
[16:18:47.136] Resolving globals: FALSE
[16:18:47.136] The total size of the 1 globals is 56 bytes (56 bytes)
[16:18:47.137] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[16:18:47.137] - globals: [1] ‘FUN’
[16:18:47.137] 
[16:18:47.137] getGlobalsAndPackages() ... DONE
[16:18:47.137]  - globals found/used: [n=1] ‘FUN’
[16:18:47.137]  - needed namespaces: [n=0] 
[16:18:47.137] Finding globals ... DONE
[16:18:47.137] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:47.137] List of 2
[16:18:47.137]  $ ...future.FUN:function (e1, e2)  
[16:18:47.137]  $ MoreArgs     : NULL
[16:18:47.137]  - attr(*, "where")=List of 2
[16:18:47.137]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:47.137]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:47.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:47.137]  - attr(*, "resolved")= logi FALSE
[16:18:47.137]  - attr(*, "total_size")= num NA
[16:18:47.140] Packages to be attached in all futures: [n=0] 
[16:18:47.140] getGlobalsAndPackagesXApply() ... DONE
[16:18:47.140] Number of futures (= number of chunks): 2
[16:18:47.140] Launching 2 futures (chunks) ...
[16:18:47.141] Chunk #1 of 2 ...
[16:18:47.141]  - Finding globals in '...' for chunk #1 ...
[16:18:47.141] getGlobalsAndPackages() ...
[16:18:47.141] Searching for globals...
[16:18:47.141] 
[16:18:47.141] Searching for globals ... DONE
[16:18:47.141] - globals: [0] <none>
[16:18:47.141] getGlobalsAndPackages() ... DONE
[16:18:47.142]    + additional globals found: [n=0] 
[16:18:47.142]    + additional namespaces needed: [n=0] 
[16:18:47.142]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:47.142]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:47.142]  - seeds: <none>
[16:18:47.142]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.142] getGlobalsAndPackages() ...
[16:18:47.142] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.142] Resolving globals: FALSE
[16:18:47.143] The total size of the 5 globals is 168 bytes (168 bytes)
[16:18:47.143] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:47.143] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.143] 
[16:18:47.144] getGlobalsAndPackages() ... DONE
[16:18:47.144] run() for ‘Future’ ...
[16:18:47.144] - state: ‘created’
[16:18:47.144] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:47.158] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.158] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:47.158]   - Field: ‘node’
[16:18:47.158]   - Field: ‘label’
[16:18:47.158]   - Field: ‘local’
[16:18:47.158]   - Field: ‘owner’
[16:18:47.158]   - Field: ‘envir’
[16:18:47.158]   - Field: ‘workers’
[16:18:47.158]   - Field: ‘packages’
[16:18:47.159]   - Field: ‘gc’
[16:18:47.159]   - Field: ‘conditions’
[16:18:47.159]   - Field: ‘persistent’
[16:18:47.159]   - Field: ‘expr’
[16:18:47.159]   - Field: ‘uuid’
[16:18:47.159]   - Field: ‘seed’
[16:18:47.159]   - Field: ‘version’
[16:18:47.159]   - Field: ‘result’
[16:18:47.159]   - Field: ‘asynchronous’
[16:18:47.159]   - Field: ‘calls’
[16:18:47.159]   - Field: ‘globals’
[16:18:47.160]   - Field: ‘stdout’
[16:18:47.160]   - Field: ‘earlySignal’
[16:18:47.160]   - Field: ‘lazy’
[16:18:47.160]   - Field: ‘state’
[16:18:47.160] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:47.160] - Launch lazy future ...
[16:18:47.160] Packages needed by the future expression (n = 0): <none>
[16:18:47.160] Packages needed by future strategies (n = 0): <none>
[16:18:47.161] {
[16:18:47.161]     {
[16:18:47.161]         {
[16:18:47.161]             ...future.startTime <- base::Sys.time()
[16:18:47.161]             {
[16:18:47.161]                 {
[16:18:47.161]                   {
[16:18:47.161]                     {
[16:18:47.161]                       base::local({
[16:18:47.161]                         has_future <- base::requireNamespace("future", 
[16:18:47.161]                           quietly = TRUE)
[16:18:47.161]                         if (has_future) {
[16:18:47.161]                           ns <- base::getNamespace("future")
[16:18:47.161]                           version <- ns[[".package"]][["version"]]
[16:18:47.161]                           if (is.null(version)) 
[16:18:47.161]                             version <- utils::packageVersion("future")
[16:18:47.161]                         }
[16:18:47.161]                         else {
[16:18:47.161]                           version <- NULL
[16:18:47.161]                         }
[16:18:47.161]                         if (!has_future || version < "1.8.0") {
[16:18:47.161]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:47.161]                             "", base::R.version$version.string), 
[16:18:47.161]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:47.161]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:47.161]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:47.161]                               "release", "version")], collapse = " "), 
[16:18:47.161]                             hostname = base::Sys.info()[["nodename"]])
[16:18:47.161]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:47.161]                             info)
[16:18:47.161]                           info <- base::paste(info, collapse = "; ")
[16:18:47.161]                           if (!has_future) {
[16:18:47.161]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:47.161]                               info)
[16:18:47.161]                           }
[16:18:47.161]                           else {
[16:18:47.161]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:47.161]                               info, version)
[16:18:47.161]                           }
[16:18:47.161]                           base::stop(msg)
[16:18:47.161]                         }
[16:18:47.161]                       })
[16:18:47.161]                     }
[16:18:47.161]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:47.161]                     base::options(mc.cores = 1L)
[16:18:47.161]                   }
[16:18:47.161]                   ...future.strategy.old <- future::plan("list")
[16:18:47.161]                   options(future.plan = NULL)
[16:18:47.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:47.161]                 }
[16:18:47.161]                 ...future.workdir <- getwd()
[16:18:47.161]             }
[16:18:47.161]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:47.161]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:47.161]         }
[16:18:47.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:47.161]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:47.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:47.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:47.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:47.161]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:47.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:47.161]             base::names(...future.oldOptions))
[16:18:47.161]     }
[16:18:47.161]     if (FALSE) {
[16:18:47.161]     }
[16:18:47.161]     else {
[16:18:47.161]         if (TRUE) {
[16:18:47.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:47.161]                 open = "w")
[16:18:47.161]         }
[16:18:47.161]         else {
[16:18:47.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:47.161]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:47.161]         }
[16:18:47.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:47.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:47.161]             base::sink(type = "output", split = FALSE)
[16:18:47.161]             base::close(...future.stdout)
[16:18:47.161]         }, add = TRUE)
[16:18:47.161]     }
[16:18:47.161]     ...future.frame <- base::sys.nframe()
[16:18:47.161]     ...future.conditions <- base::list()
[16:18:47.161]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:47.161]     if (FALSE) {
[16:18:47.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:47.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:47.161]     }
[16:18:47.161]     ...future.result <- base::tryCatch({
[16:18:47.161]         base::withCallingHandlers({
[16:18:47.161]             ...future.value <- base::withVisible(base::local({
[16:18:47.161]                 ...future.makeSendCondition <- base::local({
[16:18:47.161]                   sendCondition <- NULL
[16:18:47.161]                   function(frame = 1L) {
[16:18:47.161]                     if (is.function(sendCondition)) 
[16:18:47.161]                       return(sendCondition)
[16:18:47.161]                     ns <- getNamespace("parallel")
[16:18:47.161]                     if (exists("sendData", mode = "function", 
[16:18:47.161]                       envir = ns)) {
[16:18:47.161]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:47.161]                         envir = ns)
[16:18:47.161]                       envir <- sys.frame(frame)
[16:18:47.161]                       master <- NULL
[16:18:47.161]                       while (!identical(envir, .GlobalEnv) && 
[16:18:47.161]                         !identical(envir, emptyenv())) {
[16:18:47.161]                         if (exists("master", mode = "list", envir = envir, 
[16:18:47.161]                           inherits = FALSE)) {
[16:18:47.161]                           master <- get("master", mode = "list", 
[16:18:47.161]                             envir = envir, inherits = FALSE)
[16:18:47.161]                           if (inherits(master, c("SOCKnode", 
[16:18:47.161]                             "SOCK0node"))) {
[16:18:47.161]                             sendCondition <<- function(cond) {
[16:18:47.161]                               data <- list(type = "VALUE", value = cond, 
[16:18:47.161]                                 success = TRUE)
[16:18:47.161]                               parallel_sendData(master, data)
[16:18:47.161]                             }
[16:18:47.161]                             return(sendCondition)
[16:18:47.161]                           }
[16:18:47.161]                         }
[16:18:47.161]                         frame <- frame + 1L
[16:18:47.161]                         envir <- sys.frame(frame)
[16:18:47.161]                       }
[16:18:47.161]                     }
[16:18:47.161]                     sendCondition <<- function(cond) NULL
[16:18:47.161]                   }
[16:18:47.161]                 })
[16:18:47.161]                 withCallingHandlers({
[16:18:47.161]                   {
[16:18:47.161]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.161]                     if (!identical(...future.globals.maxSize.org, 
[16:18:47.161]                       ...future.globals.maxSize)) {
[16:18:47.161]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.161]                       on.exit(options(oopts), add = TRUE)
[16:18:47.161]                     }
[16:18:47.161]                     {
[16:18:47.161]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.161]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:47.161]                         USE.NAMES = FALSE)
[16:18:47.161]                       do.call(mapply, args = args)
[16:18:47.161]                     }
[16:18:47.161]                   }
[16:18:47.161]                 }, immediateCondition = function(cond) {
[16:18:47.161]                   sendCondition <- ...future.makeSendCondition()
[16:18:47.161]                   sendCondition(cond)
[16:18:47.161]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.161]                   {
[16:18:47.161]                     inherits <- base::inherits
[16:18:47.161]                     invokeRestart <- base::invokeRestart
[16:18:47.161]                     is.null <- base::is.null
[16:18:47.161]                     muffled <- FALSE
[16:18:47.161]                     if (inherits(cond, "message")) {
[16:18:47.161]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:47.161]                       if (muffled) 
[16:18:47.161]                         invokeRestart("muffleMessage")
[16:18:47.161]                     }
[16:18:47.161]                     else if (inherits(cond, "warning")) {
[16:18:47.161]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:47.161]                       if (muffled) 
[16:18:47.161]                         invokeRestart("muffleWarning")
[16:18:47.161]                     }
[16:18:47.161]                     else if (inherits(cond, "condition")) {
[16:18:47.161]                       if (!is.null(pattern)) {
[16:18:47.161]                         computeRestarts <- base::computeRestarts
[16:18:47.161]                         grepl <- base::grepl
[16:18:47.161]                         restarts <- computeRestarts(cond)
[16:18:47.161]                         for (restart in restarts) {
[16:18:47.161]                           name <- restart$name
[16:18:47.161]                           if (is.null(name)) 
[16:18:47.161]                             next
[16:18:47.161]                           if (!grepl(pattern, name)) 
[16:18:47.161]                             next
[16:18:47.161]                           invokeRestart(restart)
[16:18:47.161]                           muffled <- TRUE
[16:18:47.161]                           break
[16:18:47.161]                         }
[16:18:47.161]                       }
[16:18:47.161]                     }
[16:18:47.161]                     invisible(muffled)
[16:18:47.161]                   }
[16:18:47.161]                   muffleCondition(cond)
[16:18:47.161]                 })
[16:18:47.161]             }))
[16:18:47.161]             future::FutureResult(value = ...future.value$value, 
[16:18:47.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.161]                   ...future.rng), globalenv = if (FALSE) 
[16:18:47.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:47.161]                     ...future.globalenv.names))
[16:18:47.161]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:47.161]         }, condition = base::local({
[16:18:47.161]             c <- base::c
[16:18:47.161]             inherits <- base::inherits
[16:18:47.161]             invokeRestart <- base::invokeRestart
[16:18:47.161]             length <- base::length
[16:18:47.161]             list <- base::list
[16:18:47.161]             seq.int <- base::seq.int
[16:18:47.161]             signalCondition <- base::signalCondition
[16:18:47.161]             sys.calls <- base::sys.calls
[16:18:47.161]             `[[` <- base::`[[`
[16:18:47.161]             `+` <- base::`+`
[16:18:47.161]             `<<-` <- base::`<<-`
[16:18:47.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:47.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:47.161]                   3L)]
[16:18:47.161]             }
[16:18:47.161]             function(cond) {
[16:18:47.161]                 is_error <- inherits(cond, "error")
[16:18:47.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:47.161]                   NULL)
[16:18:47.161]                 if (is_error) {
[16:18:47.161]                   sessionInformation <- function() {
[16:18:47.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:47.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:47.161]                       search = base::search(), system = base::Sys.info())
[16:18:47.161]                   }
[16:18:47.161]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:47.161]                     cond$call), session = sessionInformation(), 
[16:18:47.161]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:47.161]                   signalCondition(cond)
[16:18:47.161]                 }
[16:18:47.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:47.161]                 "immediateCondition"))) {
[16:18:47.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:47.161]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:47.161]                   if (TRUE && !signal) {
[16:18:47.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.161]                     {
[16:18:47.161]                       inherits <- base::inherits
[16:18:47.161]                       invokeRestart <- base::invokeRestart
[16:18:47.161]                       is.null <- base::is.null
[16:18:47.161]                       muffled <- FALSE
[16:18:47.161]                       if (inherits(cond, "message")) {
[16:18:47.161]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.161]                         if (muffled) 
[16:18:47.161]                           invokeRestart("muffleMessage")
[16:18:47.161]                       }
[16:18:47.161]                       else if (inherits(cond, "warning")) {
[16:18:47.161]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.161]                         if (muffled) 
[16:18:47.161]                           invokeRestart("muffleWarning")
[16:18:47.161]                       }
[16:18:47.161]                       else if (inherits(cond, "condition")) {
[16:18:47.161]                         if (!is.null(pattern)) {
[16:18:47.161]                           computeRestarts <- base::computeRestarts
[16:18:47.161]                           grepl <- base::grepl
[16:18:47.161]                           restarts <- computeRestarts(cond)
[16:18:47.161]                           for (restart in restarts) {
[16:18:47.161]                             name <- restart$name
[16:18:47.161]                             if (is.null(name)) 
[16:18:47.161]                               next
[16:18:47.161]                             if (!grepl(pattern, name)) 
[16:18:47.161]                               next
[16:18:47.161]                             invokeRestart(restart)
[16:18:47.161]                             muffled <- TRUE
[16:18:47.161]                             break
[16:18:47.161]                           }
[16:18:47.161]                         }
[16:18:47.161]                       }
[16:18:47.161]                       invisible(muffled)
[16:18:47.161]                     }
[16:18:47.161]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.161]                   }
[16:18:47.161]                 }
[16:18:47.161]                 else {
[16:18:47.161]                   if (TRUE) {
[16:18:47.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.161]                     {
[16:18:47.161]                       inherits <- base::inherits
[16:18:47.161]                       invokeRestart <- base::invokeRestart
[16:18:47.161]                       is.null <- base::is.null
[16:18:47.161]                       muffled <- FALSE
[16:18:47.161]                       if (inherits(cond, "message")) {
[16:18:47.161]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.161]                         if (muffled) 
[16:18:47.161]                           invokeRestart("muffleMessage")
[16:18:47.161]                       }
[16:18:47.161]                       else if (inherits(cond, "warning")) {
[16:18:47.161]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.161]                         if (muffled) 
[16:18:47.161]                           invokeRestart("muffleWarning")
[16:18:47.161]                       }
[16:18:47.161]                       else if (inherits(cond, "condition")) {
[16:18:47.161]                         if (!is.null(pattern)) {
[16:18:47.161]                           computeRestarts <- base::computeRestarts
[16:18:47.161]                           grepl <- base::grepl
[16:18:47.161]                           restarts <- computeRestarts(cond)
[16:18:47.161]                           for (restart in restarts) {
[16:18:47.161]                             name <- restart$name
[16:18:47.161]                             if (is.null(name)) 
[16:18:47.161]                               next
[16:18:47.161]                             if (!grepl(pattern, name)) 
[16:18:47.161]                               next
[16:18:47.161]                             invokeRestart(restart)
[16:18:47.161]                             muffled <- TRUE
[16:18:47.161]                             break
[16:18:47.161]                           }
[16:18:47.161]                         }
[16:18:47.161]                       }
[16:18:47.161]                       invisible(muffled)
[16:18:47.161]                     }
[16:18:47.161]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.161]                   }
[16:18:47.161]                 }
[16:18:47.161]             }
[16:18:47.161]         }))
[16:18:47.161]     }, error = function(ex) {
[16:18:47.161]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:47.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.161]                 ...future.rng), started = ...future.startTime, 
[16:18:47.161]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:47.161]             version = "1.8"), class = "FutureResult")
[16:18:47.161]     }, finally = {
[16:18:47.161]         if (!identical(...future.workdir, getwd())) 
[16:18:47.161]             setwd(...future.workdir)
[16:18:47.161]         {
[16:18:47.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:47.161]                 ...future.oldOptions$nwarnings <- NULL
[16:18:47.161]             }
[16:18:47.161]             base::options(...future.oldOptions)
[16:18:47.161]             if (.Platform$OS.type == "windows") {
[16:18:47.161]                 old_names <- names(...future.oldEnvVars)
[16:18:47.161]                 envs <- base::Sys.getenv()
[16:18:47.161]                 names <- names(envs)
[16:18:47.161]                 common <- intersect(names, old_names)
[16:18:47.161]                 added <- setdiff(names, old_names)
[16:18:47.161]                 removed <- setdiff(old_names, names)
[16:18:47.161]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:47.161]                   envs[common]]
[16:18:47.161]                 NAMES <- toupper(changed)
[16:18:47.161]                 args <- list()
[16:18:47.161]                 for (kk in seq_along(NAMES)) {
[16:18:47.161]                   name <- changed[[kk]]
[16:18:47.161]                   NAME <- NAMES[[kk]]
[16:18:47.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.161]                     next
[16:18:47.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.161]                 }
[16:18:47.161]                 NAMES <- toupper(added)
[16:18:47.161]                 for (kk in seq_along(NAMES)) {
[16:18:47.161]                   name <- added[[kk]]
[16:18:47.161]                   NAME <- NAMES[[kk]]
[16:18:47.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.161]                     next
[16:18:47.161]                   args[[name]] <- ""
[16:18:47.161]                 }
[16:18:47.161]                 NAMES <- toupper(removed)
[16:18:47.161]                 for (kk in seq_along(NAMES)) {
[16:18:47.161]                   name <- removed[[kk]]
[16:18:47.161]                   NAME <- NAMES[[kk]]
[16:18:47.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.161]                     next
[16:18:47.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.161]                 }
[16:18:47.161]                 if (length(args) > 0) 
[16:18:47.161]                   base::do.call(base::Sys.setenv, args = args)
[16:18:47.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:47.161]             }
[16:18:47.161]             else {
[16:18:47.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:47.161]             }
[16:18:47.161]             {
[16:18:47.161]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:47.161]                   0L) {
[16:18:47.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:47.161]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:47.161]                   base::options(opts)
[16:18:47.161]                 }
[16:18:47.161]                 {
[16:18:47.161]                   {
[16:18:47.161]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:47.161]                     NULL
[16:18:47.161]                   }
[16:18:47.161]                   options(future.plan = NULL)
[16:18:47.161]                   if (is.na(NA_character_)) 
[16:18:47.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:47.161]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:47.161]                     .init = FALSE)
[16:18:47.161]                 }
[16:18:47.161]             }
[16:18:47.161]         }
[16:18:47.161]     })
[16:18:47.161]     if (TRUE) {
[16:18:47.161]         base::sink(type = "output", split = FALSE)
[16:18:47.161]         if (TRUE) {
[16:18:47.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:47.161]         }
[16:18:47.161]         else {
[16:18:47.161]             ...future.result["stdout"] <- base::list(NULL)
[16:18:47.161]         }
[16:18:47.161]         base::close(...future.stdout)
[16:18:47.161]         ...future.stdout <- NULL
[16:18:47.161]     }
[16:18:47.161]     ...future.result$conditions <- ...future.conditions
[16:18:47.161]     ...future.result$finished <- base::Sys.time()
[16:18:47.161]     ...future.result
[16:18:47.161] }
[16:18:47.164] Exporting 5 global objects (168 bytes) to cluster node #1 ...
[16:18:47.164] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[16:18:47.164] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[16:18:47.164] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:47.165] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:47.165] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:18:47.165] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:18:47.165] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:47.166] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:47.166] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:47.166] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:47.166] Exporting 5 global objects (168 bytes) to cluster node #1 ... DONE
[16:18:47.167] MultisessionFuture started
[16:18:47.167] - Launch lazy future ... done
[16:18:47.167] run() for ‘MultisessionFuture’ ... done
[16:18:47.167] Created future:
[16:18:47.167] MultisessionFuture:
[16:18:47.167] Label: ‘future_Map-1’
[16:18:47.167] Expression:
[16:18:47.167] {
[16:18:47.167]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.167]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:47.167]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.167]         on.exit(options(oopts), add = TRUE)
[16:18:47.167]     }
[16:18:47.167]     {
[16:18:47.167]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.167]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:47.167]         do.call(mapply, args = args)
[16:18:47.167]     }
[16:18:47.167] }
[16:18:47.167] Lazy evaluation: FALSE
[16:18:47.167] Asynchronous evaluation: TRUE
[16:18:47.167] Local evaluation: TRUE
[16:18:47.167] Environment: R_GlobalEnv
[16:18:47.167] Capture standard output: TRUE
[16:18:47.167] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:47.167] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:47.167] Packages: <none>
[16:18:47.167] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:47.167] Resolved: FALSE
[16:18:47.167] Value: <not collected>
[16:18:47.167] Conditions captured: <none>
[16:18:47.167] Early signaling: FALSE
[16:18:47.167] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:47.167] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.178] Chunk #1 of 2 ... DONE
[16:18:47.179] Chunk #2 of 2 ...
[16:18:47.179]  - Finding globals in '...' for chunk #2 ...
[16:18:47.179] getGlobalsAndPackages() ...
[16:18:47.179] Searching for globals...
[16:18:47.179] 
[16:18:47.179] Searching for globals ... DONE
[16:18:47.180] - globals: [0] <none>
[16:18:47.180] getGlobalsAndPackages() ... DONE
[16:18:47.180]    + additional globals found: [n=0] 
[16:18:47.180]    + additional namespaces needed: [n=0] 
[16:18:47.180]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:47.180]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:47.180]  - seeds: <none>
[16:18:47.180]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.180] getGlobalsAndPackages() ...
[16:18:47.180] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.181] Resolving globals: FALSE
[16:18:47.181] The total size of the 5 globals is 280 bytes (280 bytes)
[16:18:47.182] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:47.182] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.182] 
[16:18:47.182] getGlobalsAndPackages() ... DONE
[16:18:47.182] run() for ‘Future’ ...
[16:18:47.183] - state: ‘created’
[16:18:47.183] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:47.198] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.198] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:47.199]   - Field: ‘node’
[16:18:47.199]   - Field: ‘label’
[16:18:47.199]   - Field: ‘local’
[16:18:47.199]   - Field: ‘owner’
[16:18:47.199]   - Field: ‘envir’
[16:18:47.199]   - Field: ‘workers’
[16:18:47.199]   - Field: ‘packages’
[16:18:47.199]   - Field: ‘gc’
[16:18:47.199]   - Field: ‘conditions’
[16:18:47.199]   - Field: ‘persistent’
[16:18:47.200]   - Field: ‘expr’
[16:18:47.200]   - Field: ‘uuid’
[16:18:47.200]   - Field: ‘seed’
[16:18:47.200]   - Field: ‘version’
[16:18:47.200]   - Field: ‘result’
[16:18:47.200]   - Field: ‘asynchronous’
[16:18:47.200]   - Field: ‘calls’
[16:18:47.200]   - Field: ‘globals’
[16:18:47.200]   - Field: ‘stdout’
[16:18:47.200]   - Field: ‘earlySignal’
[16:18:47.200]   - Field: ‘lazy’
[16:18:47.201]   - Field: ‘state’
[16:18:47.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:47.201] - Launch lazy future ...
[16:18:47.201] Packages needed by the future expression (n = 0): <none>
[16:18:47.201] Packages needed by future strategies (n = 0): <none>
[16:18:47.202] {
[16:18:47.202]     {
[16:18:47.202]         {
[16:18:47.202]             ...future.startTime <- base::Sys.time()
[16:18:47.202]             {
[16:18:47.202]                 {
[16:18:47.202]                   {
[16:18:47.202]                     {
[16:18:47.202]                       base::local({
[16:18:47.202]                         has_future <- base::requireNamespace("future", 
[16:18:47.202]                           quietly = TRUE)
[16:18:47.202]                         if (has_future) {
[16:18:47.202]                           ns <- base::getNamespace("future")
[16:18:47.202]                           version <- ns[[".package"]][["version"]]
[16:18:47.202]                           if (is.null(version)) 
[16:18:47.202]                             version <- utils::packageVersion("future")
[16:18:47.202]                         }
[16:18:47.202]                         else {
[16:18:47.202]                           version <- NULL
[16:18:47.202]                         }
[16:18:47.202]                         if (!has_future || version < "1.8.0") {
[16:18:47.202]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:47.202]                             "", base::R.version$version.string), 
[16:18:47.202]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:47.202]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:47.202]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:47.202]                               "release", "version")], collapse = " "), 
[16:18:47.202]                             hostname = base::Sys.info()[["nodename"]])
[16:18:47.202]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:47.202]                             info)
[16:18:47.202]                           info <- base::paste(info, collapse = "; ")
[16:18:47.202]                           if (!has_future) {
[16:18:47.202]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:47.202]                               info)
[16:18:47.202]                           }
[16:18:47.202]                           else {
[16:18:47.202]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:47.202]                               info, version)
[16:18:47.202]                           }
[16:18:47.202]                           base::stop(msg)
[16:18:47.202]                         }
[16:18:47.202]                       })
[16:18:47.202]                     }
[16:18:47.202]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:47.202]                     base::options(mc.cores = 1L)
[16:18:47.202]                   }
[16:18:47.202]                   ...future.strategy.old <- future::plan("list")
[16:18:47.202]                   options(future.plan = NULL)
[16:18:47.202]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.202]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:47.202]                 }
[16:18:47.202]                 ...future.workdir <- getwd()
[16:18:47.202]             }
[16:18:47.202]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:47.202]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:47.202]         }
[16:18:47.202]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:47.202]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:47.202]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:47.202]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:47.202]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:47.202]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:47.202]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:47.202]             base::names(...future.oldOptions))
[16:18:47.202]     }
[16:18:47.202]     if (FALSE) {
[16:18:47.202]     }
[16:18:47.202]     else {
[16:18:47.202]         if (TRUE) {
[16:18:47.202]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:47.202]                 open = "w")
[16:18:47.202]         }
[16:18:47.202]         else {
[16:18:47.202]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:47.202]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:47.202]         }
[16:18:47.202]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:47.202]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:47.202]             base::sink(type = "output", split = FALSE)
[16:18:47.202]             base::close(...future.stdout)
[16:18:47.202]         }, add = TRUE)
[16:18:47.202]     }
[16:18:47.202]     ...future.frame <- base::sys.nframe()
[16:18:47.202]     ...future.conditions <- base::list()
[16:18:47.202]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:47.202]     if (FALSE) {
[16:18:47.202]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:47.202]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:47.202]     }
[16:18:47.202]     ...future.result <- base::tryCatch({
[16:18:47.202]         base::withCallingHandlers({
[16:18:47.202]             ...future.value <- base::withVisible(base::local({
[16:18:47.202]                 ...future.makeSendCondition <- base::local({
[16:18:47.202]                   sendCondition <- NULL
[16:18:47.202]                   function(frame = 1L) {
[16:18:47.202]                     if (is.function(sendCondition)) 
[16:18:47.202]                       return(sendCondition)
[16:18:47.202]                     ns <- getNamespace("parallel")
[16:18:47.202]                     if (exists("sendData", mode = "function", 
[16:18:47.202]                       envir = ns)) {
[16:18:47.202]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:47.202]                         envir = ns)
[16:18:47.202]                       envir <- sys.frame(frame)
[16:18:47.202]                       master <- NULL
[16:18:47.202]                       while (!identical(envir, .GlobalEnv) && 
[16:18:47.202]                         !identical(envir, emptyenv())) {
[16:18:47.202]                         if (exists("master", mode = "list", envir = envir, 
[16:18:47.202]                           inherits = FALSE)) {
[16:18:47.202]                           master <- get("master", mode = "list", 
[16:18:47.202]                             envir = envir, inherits = FALSE)
[16:18:47.202]                           if (inherits(master, c("SOCKnode", 
[16:18:47.202]                             "SOCK0node"))) {
[16:18:47.202]                             sendCondition <<- function(cond) {
[16:18:47.202]                               data <- list(type = "VALUE", value = cond, 
[16:18:47.202]                                 success = TRUE)
[16:18:47.202]                               parallel_sendData(master, data)
[16:18:47.202]                             }
[16:18:47.202]                             return(sendCondition)
[16:18:47.202]                           }
[16:18:47.202]                         }
[16:18:47.202]                         frame <- frame + 1L
[16:18:47.202]                         envir <- sys.frame(frame)
[16:18:47.202]                       }
[16:18:47.202]                     }
[16:18:47.202]                     sendCondition <<- function(cond) NULL
[16:18:47.202]                   }
[16:18:47.202]                 })
[16:18:47.202]                 withCallingHandlers({
[16:18:47.202]                   {
[16:18:47.202]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.202]                     if (!identical(...future.globals.maxSize.org, 
[16:18:47.202]                       ...future.globals.maxSize)) {
[16:18:47.202]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.202]                       on.exit(options(oopts), add = TRUE)
[16:18:47.202]                     }
[16:18:47.202]                     {
[16:18:47.202]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.202]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:47.202]                         USE.NAMES = FALSE)
[16:18:47.202]                       do.call(mapply, args = args)
[16:18:47.202]                     }
[16:18:47.202]                   }
[16:18:47.202]                 }, immediateCondition = function(cond) {
[16:18:47.202]                   sendCondition <- ...future.makeSendCondition()
[16:18:47.202]                   sendCondition(cond)
[16:18:47.202]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.202]                   {
[16:18:47.202]                     inherits <- base::inherits
[16:18:47.202]                     invokeRestart <- base::invokeRestart
[16:18:47.202]                     is.null <- base::is.null
[16:18:47.202]                     muffled <- FALSE
[16:18:47.202]                     if (inherits(cond, "message")) {
[16:18:47.202]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:47.202]                       if (muffled) 
[16:18:47.202]                         invokeRestart("muffleMessage")
[16:18:47.202]                     }
[16:18:47.202]                     else if (inherits(cond, "warning")) {
[16:18:47.202]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:47.202]                       if (muffled) 
[16:18:47.202]                         invokeRestart("muffleWarning")
[16:18:47.202]                     }
[16:18:47.202]                     else if (inherits(cond, "condition")) {
[16:18:47.202]                       if (!is.null(pattern)) {
[16:18:47.202]                         computeRestarts <- base::computeRestarts
[16:18:47.202]                         grepl <- base::grepl
[16:18:47.202]                         restarts <- computeRestarts(cond)
[16:18:47.202]                         for (restart in restarts) {
[16:18:47.202]                           name <- restart$name
[16:18:47.202]                           if (is.null(name)) 
[16:18:47.202]                             next
[16:18:47.202]                           if (!grepl(pattern, name)) 
[16:18:47.202]                             next
[16:18:47.202]                           invokeRestart(restart)
[16:18:47.202]                           muffled <- TRUE
[16:18:47.202]                           break
[16:18:47.202]                         }
[16:18:47.202]                       }
[16:18:47.202]                     }
[16:18:47.202]                     invisible(muffled)
[16:18:47.202]                   }
[16:18:47.202]                   muffleCondition(cond)
[16:18:47.202]                 })
[16:18:47.202]             }))
[16:18:47.202]             future::FutureResult(value = ...future.value$value, 
[16:18:47.202]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.202]                   ...future.rng), globalenv = if (FALSE) 
[16:18:47.202]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:47.202]                     ...future.globalenv.names))
[16:18:47.202]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:47.202]         }, condition = base::local({
[16:18:47.202]             c <- base::c
[16:18:47.202]             inherits <- base::inherits
[16:18:47.202]             invokeRestart <- base::invokeRestart
[16:18:47.202]             length <- base::length
[16:18:47.202]             list <- base::list
[16:18:47.202]             seq.int <- base::seq.int
[16:18:47.202]             signalCondition <- base::signalCondition
[16:18:47.202]             sys.calls <- base::sys.calls
[16:18:47.202]             `[[` <- base::`[[`
[16:18:47.202]             `+` <- base::`+`
[16:18:47.202]             `<<-` <- base::`<<-`
[16:18:47.202]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:47.202]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:47.202]                   3L)]
[16:18:47.202]             }
[16:18:47.202]             function(cond) {
[16:18:47.202]                 is_error <- inherits(cond, "error")
[16:18:47.202]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:47.202]                   NULL)
[16:18:47.202]                 if (is_error) {
[16:18:47.202]                   sessionInformation <- function() {
[16:18:47.202]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:47.202]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:47.202]                       search = base::search(), system = base::Sys.info())
[16:18:47.202]                   }
[16:18:47.202]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.202]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:47.202]                     cond$call), session = sessionInformation(), 
[16:18:47.202]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:47.202]                   signalCondition(cond)
[16:18:47.202]                 }
[16:18:47.202]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:47.202]                 "immediateCondition"))) {
[16:18:47.202]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:47.202]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.202]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:47.202]                   if (TRUE && !signal) {
[16:18:47.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.202]                     {
[16:18:47.202]                       inherits <- base::inherits
[16:18:47.202]                       invokeRestart <- base::invokeRestart
[16:18:47.202]                       is.null <- base::is.null
[16:18:47.202]                       muffled <- FALSE
[16:18:47.202]                       if (inherits(cond, "message")) {
[16:18:47.202]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.202]                         if (muffled) 
[16:18:47.202]                           invokeRestart("muffleMessage")
[16:18:47.202]                       }
[16:18:47.202]                       else if (inherits(cond, "warning")) {
[16:18:47.202]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.202]                         if (muffled) 
[16:18:47.202]                           invokeRestart("muffleWarning")
[16:18:47.202]                       }
[16:18:47.202]                       else if (inherits(cond, "condition")) {
[16:18:47.202]                         if (!is.null(pattern)) {
[16:18:47.202]                           computeRestarts <- base::computeRestarts
[16:18:47.202]                           grepl <- base::grepl
[16:18:47.202]                           restarts <- computeRestarts(cond)
[16:18:47.202]                           for (restart in restarts) {
[16:18:47.202]                             name <- restart$name
[16:18:47.202]                             if (is.null(name)) 
[16:18:47.202]                               next
[16:18:47.202]                             if (!grepl(pattern, name)) 
[16:18:47.202]                               next
[16:18:47.202]                             invokeRestart(restart)
[16:18:47.202]                             muffled <- TRUE
[16:18:47.202]                             break
[16:18:47.202]                           }
[16:18:47.202]                         }
[16:18:47.202]                       }
[16:18:47.202]                       invisible(muffled)
[16:18:47.202]                     }
[16:18:47.202]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.202]                   }
[16:18:47.202]                 }
[16:18:47.202]                 else {
[16:18:47.202]                   if (TRUE) {
[16:18:47.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.202]                     {
[16:18:47.202]                       inherits <- base::inherits
[16:18:47.202]                       invokeRestart <- base::invokeRestart
[16:18:47.202]                       is.null <- base::is.null
[16:18:47.202]                       muffled <- FALSE
[16:18:47.202]                       if (inherits(cond, "message")) {
[16:18:47.202]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.202]                         if (muffled) 
[16:18:47.202]                           invokeRestart("muffleMessage")
[16:18:47.202]                       }
[16:18:47.202]                       else if (inherits(cond, "warning")) {
[16:18:47.202]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.202]                         if (muffled) 
[16:18:47.202]                           invokeRestart("muffleWarning")
[16:18:47.202]                       }
[16:18:47.202]                       else if (inherits(cond, "condition")) {
[16:18:47.202]                         if (!is.null(pattern)) {
[16:18:47.202]                           computeRestarts <- base::computeRestarts
[16:18:47.202]                           grepl <- base::grepl
[16:18:47.202]                           restarts <- computeRestarts(cond)
[16:18:47.202]                           for (restart in restarts) {
[16:18:47.202]                             name <- restart$name
[16:18:47.202]                             if (is.null(name)) 
[16:18:47.202]                               next
[16:18:47.202]                             if (!grepl(pattern, name)) 
[16:18:47.202]                               next
[16:18:47.202]                             invokeRestart(restart)
[16:18:47.202]                             muffled <- TRUE
[16:18:47.202]                             break
[16:18:47.202]                           }
[16:18:47.202]                         }
[16:18:47.202]                       }
[16:18:47.202]                       invisible(muffled)
[16:18:47.202]                     }
[16:18:47.202]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.202]                   }
[16:18:47.202]                 }
[16:18:47.202]             }
[16:18:47.202]         }))
[16:18:47.202]     }, error = function(ex) {
[16:18:47.202]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:47.202]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.202]                 ...future.rng), started = ...future.startTime, 
[16:18:47.202]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:47.202]             version = "1.8"), class = "FutureResult")
[16:18:47.202]     }, finally = {
[16:18:47.202]         if (!identical(...future.workdir, getwd())) 
[16:18:47.202]             setwd(...future.workdir)
[16:18:47.202]         {
[16:18:47.202]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:47.202]                 ...future.oldOptions$nwarnings <- NULL
[16:18:47.202]             }
[16:18:47.202]             base::options(...future.oldOptions)
[16:18:47.202]             if (.Platform$OS.type == "windows") {
[16:18:47.202]                 old_names <- names(...future.oldEnvVars)
[16:18:47.202]                 envs <- base::Sys.getenv()
[16:18:47.202]                 names <- names(envs)
[16:18:47.202]                 common <- intersect(names, old_names)
[16:18:47.202]                 added <- setdiff(names, old_names)
[16:18:47.202]                 removed <- setdiff(old_names, names)
[16:18:47.202]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:47.202]                   envs[common]]
[16:18:47.202]                 NAMES <- toupper(changed)
[16:18:47.202]                 args <- list()
[16:18:47.202]                 for (kk in seq_along(NAMES)) {
[16:18:47.202]                   name <- changed[[kk]]
[16:18:47.202]                   NAME <- NAMES[[kk]]
[16:18:47.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.202]                     next
[16:18:47.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.202]                 }
[16:18:47.202]                 NAMES <- toupper(added)
[16:18:47.202]                 for (kk in seq_along(NAMES)) {
[16:18:47.202]                   name <- added[[kk]]
[16:18:47.202]                   NAME <- NAMES[[kk]]
[16:18:47.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.202]                     next
[16:18:47.202]                   args[[name]] <- ""
[16:18:47.202]                 }
[16:18:47.202]                 NAMES <- toupper(removed)
[16:18:47.202]                 for (kk in seq_along(NAMES)) {
[16:18:47.202]                   name <- removed[[kk]]
[16:18:47.202]                   NAME <- NAMES[[kk]]
[16:18:47.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.202]                     next
[16:18:47.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.202]                 }
[16:18:47.202]                 if (length(args) > 0) 
[16:18:47.202]                   base::do.call(base::Sys.setenv, args = args)
[16:18:47.202]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:47.202]             }
[16:18:47.202]             else {
[16:18:47.202]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:47.202]             }
[16:18:47.202]             {
[16:18:47.202]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:47.202]                   0L) {
[16:18:47.202]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:47.202]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:47.202]                   base::options(opts)
[16:18:47.202]                 }
[16:18:47.202]                 {
[16:18:47.202]                   {
[16:18:47.202]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:47.202]                     NULL
[16:18:47.202]                   }
[16:18:47.202]                   options(future.plan = NULL)
[16:18:47.202]                   if (is.na(NA_character_)) 
[16:18:47.202]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.202]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:47.202]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:47.202]                     .init = FALSE)
[16:18:47.202]                 }
[16:18:47.202]             }
[16:18:47.202]         }
[16:18:47.202]     })
[16:18:47.202]     if (TRUE) {
[16:18:47.202]         base::sink(type = "output", split = FALSE)
[16:18:47.202]         if (TRUE) {
[16:18:47.202]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:47.202]         }
[16:18:47.202]         else {
[16:18:47.202]             ...future.result["stdout"] <- base::list(NULL)
[16:18:47.202]         }
[16:18:47.202]         base::close(...future.stdout)
[16:18:47.202]         ...future.stdout <- NULL
[16:18:47.202]     }
[16:18:47.202]     ...future.result$conditions <- ...future.conditions
[16:18:47.202]     ...future.result$finished <- base::Sys.time()
[16:18:47.202]     ...future.result
[16:18:47.202] }
[16:18:47.204] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[16:18:47.205] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[16:18:47.205] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[16:18:47.205] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:47.205] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:47.206] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[16:18:47.206] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[16:18:47.206] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:47.206] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:47.206] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:47.207] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:47.207] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[16:18:47.207] MultisessionFuture started
[16:18:47.207] - Launch lazy future ... done
[16:18:47.207] run() for ‘MultisessionFuture’ ... done
[16:18:47.208] Created future:
[16:18:47.208] MultisessionFuture:
[16:18:47.208] Label: ‘future_Map-2’
[16:18:47.208] Expression:
[16:18:47.208] {
[16:18:47.208]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.208]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:47.208]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.208]         on.exit(options(oopts), add = TRUE)
[16:18:47.208]     }
[16:18:47.208]     {
[16:18:47.208]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.208]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:47.208]         do.call(mapply, args = args)
[16:18:47.208]     }
[16:18:47.208] }
[16:18:47.208] Lazy evaluation: FALSE
[16:18:47.208] Asynchronous evaluation: TRUE
[16:18:47.208] Local evaluation: TRUE
[16:18:47.208] Environment: R_GlobalEnv
[16:18:47.208] Capture standard output: TRUE
[16:18:47.208] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:47.208] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:47.208] Packages: <none>
[16:18:47.208] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:47.208] Resolved: FALSE
[16:18:47.208] Value: <not collected>
[16:18:47.208] Conditions captured: <none>
[16:18:47.208] Early signaling: FALSE
[16:18:47.208] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:47.208] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.219] Chunk #2 of 2 ... DONE
[16:18:47.219] Launching 2 futures (chunks) ... DONE
[16:18:47.220] Resolving 2 futures (chunks) ...
[16:18:47.220] resolve() on list ...
[16:18:47.220]  recursive: 0
[16:18:47.220]  length: 2
[16:18:47.220] 
[16:18:47.221] receiveMessageFromWorker() for ClusterFuture ...
[16:18:47.221] - Validating connection of MultisessionFuture
[16:18:47.221] - received message: FutureResult
[16:18:47.221] - Received FutureResult
[16:18:47.221] - Erased future from FutureRegistry
[16:18:47.221] result() for ClusterFuture ...
[16:18:47.221] - result already collected: FutureResult
[16:18:47.221] result() for ClusterFuture ... done
[16:18:47.221] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:47.222] Future #1
[16:18:47.222] result() for ClusterFuture ...
[16:18:47.222] - result already collected: FutureResult
[16:18:47.222] result() for ClusterFuture ... done
[16:18:47.222] result() for ClusterFuture ...
[16:18:47.222] - result already collected: FutureResult
[16:18:47.222] result() for ClusterFuture ... done
[16:18:47.222] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:47.222] - nx: 2
[16:18:47.222] - relay: TRUE
[16:18:47.222] - stdout: TRUE
[16:18:47.223] - signal: TRUE
[16:18:47.223] - resignal: FALSE
[16:18:47.223] - force: TRUE
[16:18:47.223] - relayed: [n=2] FALSE, FALSE
[16:18:47.223] - queued futures: [n=2] FALSE, FALSE
[16:18:47.223]  - until=1
[16:18:47.223]  - relaying element #1
[16:18:47.223] result() for ClusterFuture ...
[16:18:47.223] - result already collected: FutureResult
[16:18:47.223] result() for ClusterFuture ... done
[16:18:47.223] result() for ClusterFuture ...
[16:18:47.224] - result already collected: FutureResult
[16:18:47.224] result() for ClusterFuture ... done
[16:18:47.224] result() for ClusterFuture ...
[16:18:47.224] - result already collected: FutureResult
[16:18:47.224] result() for ClusterFuture ... done
[16:18:47.224] result() for ClusterFuture ...
[16:18:47.224] - result already collected: FutureResult
[16:18:47.224] result() for ClusterFuture ... done
[16:18:47.224] - relayed: [n=2] TRUE, FALSE
[16:18:47.224] - queued futures: [n=2] TRUE, FALSE
[16:18:47.225] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:47.225]  length: 1 (resolved future 1)
[16:18:47.250] receiveMessageFromWorker() for ClusterFuture ...
[16:18:47.250] - Validating connection of MultisessionFuture
[16:18:47.250] - received message: FutureResult
[16:18:47.250] - Received FutureResult
[16:18:47.251] - Erased future from FutureRegistry
[16:18:47.251] result() for ClusterFuture ...
[16:18:47.251] - result already collected: FutureResult
[16:18:47.251] result() for ClusterFuture ... done
[16:18:47.251] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:47.251] Future #2
[16:18:47.251] result() for ClusterFuture ...
[16:18:47.251] - result already collected: FutureResult
[16:18:47.251] result() for ClusterFuture ... done
[16:18:47.252] result() for ClusterFuture ...
[16:18:47.252] - result already collected: FutureResult
[16:18:47.252] result() for ClusterFuture ... done
[16:18:47.252] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:47.252] - nx: 2
[16:18:47.252] - relay: TRUE
[16:18:47.252] - stdout: TRUE
[16:18:47.252] - signal: TRUE
[16:18:47.252] - resignal: FALSE
[16:18:47.252] - force: TRUE
[16:18:47.252] - relayed: [n=2] TRUE, FALSE
[16:18:47.253] - queued futures: [n=2] TRUE, FALSE
[16:18:47.253]  - until=2
[16:18:47.253]  - relaying element #2
[16:18:47.253] result() for ClusterFuture ...
[16:18:47.253] - result already collected: FutureResult
[16:18:47.253] result() for ClusterFuture ... done
[16:18:47.253] result() for ClusterFuture ...
[16:18:47.253] - result already collected: FutureResult
[16:18:47.253] result() for ClusterFuture ... done
[16:18:47.253] result() for ClusterFuture ...
[16:18:47.253] - result already collected: FutureResult
[16:18:47.254] result() for ClusterFuture ... done
[16:18:47.254] result() for ClusterFuture ...
[16:18:47.254] - result already collected: FutureResult
[16:18:47.254] result() for ClusterFuture ... done
[16:18:47.254] - relayed: [n=2] TRUE, TRUE
[16:18:47.254] - queued futures: [n=2] TRUE, TRUE
[16:18:47.254] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:47.254]  length: 0 (resolved future 2)
[16:18:47.254] Relaying remaining futures
[16:18:47.254] signalConditionsASAP(NULL, pos=0) ...
[16:18:47.254] - nx: 2
[16:18:47.255] - relay: TRUE
[16:18:47.255] - stdout: TRUE
[16:18:47.255] - signal: TRUE
[16:18:47.255] - resignal: FALSE
[16:18:47.255] - force: TRUE
[16:18:47.255] - relayed: [n=2] TRUE, TRUE
[16:18:47.255] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:47.255] - relayed: [n=2] TRUE, TRUE
[16:18:47.255] - queued futures: [n=2] TRUE, TRUE
[16:18:47.255] signalConditionsASAP(NULL, pos=0) ... done
[16:18:47.255] resolve() on list ... DONE
[16:18:47.256] result() for ClusterFuture ...
[16:18:47.256] - result already collected: FutureResult
[16:18:47.256] result() for ClusterFuture ... done
[16:18:47.256] result() for ClusterFuture ...
[16:18:47.256] - result already collected: FutureResult
[16:18:47.256] result() for ClusterFuture ... done
[16:18:47.256] result() for ClusterFuture ...
[16:18:47.256] - result already collected: FutureResult
[16:18:47.256] result() for ClusterFuture ... done
[16:18:47.256] result() for ClusterFuture ...
[16:18:47.256] - result already collected: FutureResult
[16:18:47.257] result() for ClusterFuture ... done
[16:18:47.257]  - Number of value chunks collected: 2
[16:18:47.257] Resolving 2 futures (chunks) ... DONE
[16:18:47.257] Reducing values from 2 chunks ...
[16:18:47.257]  - Number of values collected after concatenation: 3
[16:18:47.257]  - Number of values expected: 3
[16:18:47.257] Reducing values from 2 chunks ... DONE
[16:18:47.257] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[16:18:47.258] future_mapply() ...
[16:18:47.262] Number of chunks: 2
[16:18:47.262] getGlobalsAndPackagesXApply() ...
[16:18:47.262]  - future.globals: TRUE
[16:18:47.262] getGlobalsAndPackages() ...
[16:18:47.262] Searching for globals...
[16:18:47.263] - globals found: [1] ‘FUN’
[16:18:47.263] Searching for globals ... DONE
[16:18:47.264] Resolving globals: FALSE
[16:18:47.264] The total size of the 1 globals is 848 bytes (848 bytes)
[16:18:47.264] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:18:47.264] - globals: [1] ‘FUN’
[16:18:47.264] 
[16:18:47.265] getGlobalsAndPackages() ... DONE
[16:18:47.265]  - globals found/used: [n=1] ‘FUN’
[16:18:47.265]  - needed namespaces: [n=0] 
[16:18:47.265] Finding globals ... DONE
[16:18:47.265] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:18:47.265] List of 2
[16:18:47.265]  $ ...future.FUN:function (x)  
[16:18:47.265]  $ MoreArgs     : NULL
[16:18:47.265]  - attr(*, "where")=List of 2
[16:18:47.265]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:18:47.265]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:18:47.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:18:47.265]  - attr(*, "resolved")= logi FALSE
[16:18:47.265]  - attr(*, "total_size")= num NA
[16:18:47.268] Packages to be attached in all futures: [n=0] 
[16:18:47.268] getGlobalsAndPackagesXApply() ... DONE
[16:18:47.268] Number of futures (= number of chunks): 2
[16:18:47.268] Launching 2 futures (chunks) ...
[16:18:47.268] Chunk #1 of 2 ...
[16:18:47.268]  - Finding globals in '...' for chunk #1 ...
[16:18:47.268] getGlobalsAndPackages() ...
[16:18:47.269] Searching for globals...
[16:18:47.269] 
[16:18:47.269] Searching for globals ... DONE
[16:18:47.269] - globals: [0] <none>
[16:18:47.269] getGlobalsAndPackages() ... DONE
[16:18:47.269]    + additional globals found: [n=0] 
[16:18:47.269]    + additional namespaces needed: [n=0] 
[16:18:47.269]  - Finding globals in '...' for chunk #1 ... DONE
[16:18:47.269]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:47.270]  - seeds: <none>
[16:18:47.270]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.270] getGlobalsAndPackages() ...
[16:18:47.270] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.270] Resolving globals: FALSE
[16:18:47.270] The total size of the 5 globals is 904 bytes (904 bytes)
[16:18:47.271] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:47.271] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.271] 
[16:18:47.271] getGlobalsAndPackages() ... DONE
[16:18:47.272] run() for ‘Future’ ...
[16:18:47.272] - state: ‘created’
[16:18:47.272] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:47.286] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:47.287]   - Field: ‘node’
[16:18:47.287]   - Field: ‘label’
[16:18:47.287]   - Field: ‘local’
[16:18:47.287]   - Field: ‘owner’
[16:18:47.287]   - Field: ‘envir’
[16:18:47.287]   - Field: ‘workers’
[16:18:47.287]   - Field: ‘packages’
[16:18:47.291]   - Field: ‘gc’
[16:18:47.291]   - Field: ‘conditions’
[16:18:47.291]   - Field: ‘persistent’
[16:18:47.291]   - Field: ‘expr’
[16:18:47.291]   - Field: ‘uuid’
[16:18:47.291]   - Field: ‘seed’
[16:18:47.291]   - Field: ‘version’
[16:18:47.291]   - Field: ‘result’
[16:18:47.291]   - Field: ‘asynchronous’
[16:18:47.292]   - Field: ‘calls’
[16:18:47.292]   - Field: ‘globals’
[16:18:47.292]   - Field: ‘stdout’
[16:18:47.292]   - Field: ‘earlySignal’
[16:18:47.292]   - Field: ‘lazy’
[16:18:47.292]   - Field: ‘state’
[16:18:47.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:47.292] - Launch lazy future ...
[16:18:47.293] Packages needed by the future expression (n = 0): <none>
[16:18:47.293] Packages needed by future strategies (n = 0): <none>
[16:18:47.293] {
[16:18:47.293]     {
[16:18:47.293]         {
[16:18:47.293]             ...future.startTime <- base::Sys.time()
[16:18:47.293]             {
[16:18:47.293]                 {
[16:18:47.293]                   {
[16:18:47.293]                     {
[16:18:47.293]                       base::local({
[16:18:47.293]                         has_future <- base::requireNamespace("future", 
[16:18:47.293]                           quietly = TRUE)
[16:18:47.293]                         if (has_future) {
[16:18:47.293]                           ns <- base::getNamespace("future")
[16:18:47.293]                           version <- ns[[".package"]][["version"]]
[16:18:47.293]                           if (is.null(version)) 
[16:18:47.293]                             version <- utils::packageVersion("future")
[16:18:47.293]                         }
[16:18:47.293]                         else {
[16:18:47.293]                           version <- NULL
[16:18:47.293]                         }
[16:18:47.293]                         if (!has_future || version < "1.8.0") {
[16:18:47.293]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:47.293]                             "", base::R.version$version.string), 
[16:18:47.293]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:47.293]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:47.293]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:47.293]                               "release", "version")], collapse = " "), 
[16:18:47.293]                             hostname = base::Sys.info()[["nodename"]])
[16:18:47.293]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:47.293]                             info)
[16:18:47.293]                           info <- base::paste(info, collapse = "; ")
[16:18:47.293]                           if (!has_future) {
[16:18:47.293]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:47.293]                               info)
[16:18:47.293]                           }
[16:18:47.293]                           else {
[16:18:47.293]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:47.293]                               info, version)
[16:18:47.293]                           }
[16:18:47.293]                           base::stop(msg)
[16:18:47.293]                         }
[16:18:47.293]                       })
[16:18:47.293]                     }
[16:18:47.293]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:47.293]                     base::options(mc.cores = 1L)
[16:18:47.293]                   }
[16:18:47.293]                   ...future.strategy.old <- future::plan("list")
[16:18:47.293]                   options(future.plan = NULL)
[16:18:47.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:47.293]                 }
[16:18:47.293]                 ...future.workdir <- getwd()
[16:18:47.293]             }
[16:18:47.293]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:47.293]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:47.293]         }
[16:18:47.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:47.293]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:47.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:47.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:47.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:47.293]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:47.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:47.293]             base::names(...future.oldOptions))
[16:18:47.293]     }
[16:18:47.293]     if (FALSE) {
[16:18:47.293]     }
[16:18:47.293]     else {
[16:18:47.293]         if (TRUE) {
[16:18:47.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:47.293]                 open = "w")
[16:18:47.293]         }
[16:18:47.293]         else {
[16:18:47.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:47.293]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:47.293]         }
[16:18:47.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:47.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:47.293]             base::sink(type = "output", split = FALSE)
[16:18:47.293]             base::close(...future.stdout)
[16:18:47.293]         }, add = TRUE)
[16:18:47.293]     }
[16:18:47.293]     ...future.frame <- base::sys.nframe()
[16:18:47.293]     ...future.conditions <- base::list()
[16:18:47.293]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:47.293]     if (FALSE) {
[16:18:47.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:47.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:47.293]     }
[16:18:47.293]     ...future.result <- base::tryCatch({
[16:18:47.293]         base::withCallingHandlers({
[16:18:47.293]             ...future.value <- base::withVisible(base::local({
[16:18:47.293]                 ...future.makeSendCondition <- base::local({
[16:18:47.293]                   sendCondition <- NULL
[16:18:47.293]                   function(frame = 1L) {
[16:18:47.293]                     if (is.function(sendCondition)) 
[16:18:47.293]                       return(sendCondition)
[16:18:47.293]                     ns <- getNamespace("parallel")
[16:18:47.293]                     if (exists("sendData", mode = "function", 
[16:18:47.293]                       envir = ns)) {
[16:18:47.293]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:47.293]                         envir = ns)
[16:18:47.293]                       envir <- sys.frame(frame)
[16:18:47.293]                       master <- NULL
[16:18:47.293]                       while (!identical(envir, .GlobalEnv) && 
[16:18:47.293]                         !identical(envir, emptyenv())) {
[16:18:47.293]                         if (exists("master", mode = "list", envir = envir, 
[16:18:47.293]                           inherits = FALSE)) {
[16:18:47.293]                           master <- get("master", mode = "list", 
[16:18:47.293]                             envir = envir, inherits = FALSE)
[16:18:47.293]                           if (inherits(master, c("SOCKnode", 
[16:18:47.293]                             "SOCK0node"))) {
[16:18:47.293]                             sendCondition <<- function(cond) {
[16:18:47.293]                               data <- list(type = "VALUE", value = cond, 
[16:18:47.293]                                 success = TRUE)
[16:18:47.293]                               parallel_sendData(master, data)
[16:18:47.293]                             }
[16:18:47.293]                             return(sendCondition)
[16:18:47.293]                           }
[16:18:47.293]                         }
[16:18:47.293]                         frame <- frame + 1L
[16:18:47.293]                         envir <- sys.frame(frame)
[16:18:47.293]                       }
[16:18:47.293]                     }
[16:18:47.293]                     sendCondition <<- function(cond) NULL
[16:18:47.293]                   }
[16:18:47.293]                 })
[16:18:47.293]                 withCallingHandlers({
[16:18:47.293]                   {
[16:18:47.293]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.293]                     if (!identical(...future.globals.maxSize.org, 
[16:18:47.293]                       ...future.globals.maxSize)) {
[16:18:47.293]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.293]                       on.exit(options(oopts), add = TRUE)
[16:18:47.293]                     }
[16:18:47.293]                     {
[16:18:47.293]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.293]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:47.293]                         USE.NAMES = FALSE)
[16:18:47.293]                       do.call(mapply, args = args)
[16:18:47.293]                     }
[16:18:47.293]                   }
[16:18:47.293]                 }, immediateCondition = function(cond) {
[16:18:47.293]                   sendCondition <- ...future.makeSendCondition()
[16:18:47.293]                   sendCondition(cond)
[16:18:47.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.293]                   {
[16:18:47.293]                     inherits <- base::inherits
[16:18:47.293]                     invokeRestart <- base::invokeRestart
[16:18:47.293]                     is.null <- base::is.null
[16:18:47.293]                     muffled <- FALSE
[16:18:47.293]                     if (inherits(cond, "message")) {
[16:18:47.293]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:47.293]                       if (muffled) 
[16:18:47.293]                         invokeRestart("muffleMessage")
[16:18:47.293]                     }
[16:18:47.293]                     else if (inherits(cond, "warning")) {
[16:18:47.293]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:47.293]                       if (muffled) 
[16:18:47.293]                         invokeRestart("muffleWarning")
[16:18:47.293]                     }
[16:18:47.293]                     else if (inherits(cond, "condition")) {
[16:18:47.293]                       if (!is.null(pattern)) {
[16:18:47.293]                         computeRestarts <- base::computeRestarts
[16:18:47.293]                         grepl <- base::grepl
[16:18:47.293]                         restarts <- computeRestarts(cond)
[16:18:47.293]                         for (restart in restarts) {
[16:18:47.293]                           name <- restart$name
[16:18:47.293]                           if (is.null(name)) 
[16:18:47.293]                             next
[16:18:47.293]                           if (!grepl(pattern, name)) 
[16:18:47.293]                             next
[16:18:47.293]                           invokeRestart(restart)
[16:18:47.293]                           muffled <- TRUE
[16:18:47.293]                           break
[16:18:47.293]                         }
[16:18:47.293]                       }
[16:18:47.293]                     }
[16:18:47.293]                     invisible(muffled)
[16:18:47.293]                   }
[16:18:47.293]                   muffleCondition(cond)
[16:18:47.293]                 })
[16:18:47.293]             }))
[16:18:47.293]             future::FutureResult(value = ...future.value$value, 
[16:18:47.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.293]                   ...future.rng), globalenv = if (FALSE) 
[16:18:47.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:47.293]                     ...future.globalenv.names))
[16:18:47.293]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:47.293]         }, condition = base::local({
[16:18:47.293]             c <- base::c
[16:18:47.293]             inherits <- base::inherits
[16:18:47.293]             invokeRestart <- base::invokeRestart
[16:18:47.293]             length <- base::length
[16:18:47.293]             list <- base::list
[16:18:47.293]             seq.int <- base::seq.int
[16:18:47.293]             signalCondition <- base::signalCondition
[16:18:47.293]             sys.calls <- base::sys.calls
[16:18:47.293]             `[[` <- base::`[[`
[16:18:47.293]             `+` <- base::`+`
[16:18:47.293]             `<<-` <- base::`<<-`
[16:18:47.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:47.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:47.293]                   3L)]
[16:18:47.293]             }
[16:18:47.293]             function(cond) {
[16:18:47.293]                 is_error <- inherits(cond, "error")
[16:18:47.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:47.293]                   NULL)
[16:18:47.293]                 if (is_error) {
[16:18:47.293]                   sessionInformation <- function() {
[16:18:47.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:47.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:47.293]                       search = base::search(), system = base::Sys.info())
[16:18:47.293]                   }
[16:18:47.293]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:47.293]                     cond$call), session = sessionInformation(), 
[16:18:47.293]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:47.293]                   signalCondition(cond)
[16:18:47.293]                 }
[16:18:47.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:47.293]                 "immediateCondition"))) {
[16:18:47.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:47.293]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:47.293]                   if (TRUE && !signal) {
[16:18:47.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.293]                     {
[16:18:47.293]                       inherits <- base::inherits
[16:18:47.293]                       invokeRestart <- base::invokeRestart
[16:18:47.293]                       is.null <- base::is.null
[16:18:47.293]                       muffled <- FALSE
[16:18:47.293]                       if (inherits(cond, "message")) {
[16:18:47.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.293]                         if (muffled) 
[16:18:47.293]                           invokeRestart("muffleMessage")
[16:18:47.293]                       }
[16:18:47.293]                       else if (inherits(cond, "warning")) {
[16:18:47.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.293]                         if (muffled) 
[16:18:47.293]                           invokeRestart("muffleWarning")
[16:18:47.293]                       }
[16:18:47.293]                       else if (inherits(cond, "condition")) {
[16:18:47.293]                         if (!is.null(pattern)) {
[16:18:47.293]                           computeRestarts <- base::computeRestarts
[16:18:47.293]                           grepl <- base::grepl
[16:18:47.293]                           restarts <- computeRestarts(cond)
[16:18:47.293]                           for (restart in restarts) {
[16:18:47.293]                             name <- restart$name
[16:18:47.293]                             if (is.null(name)) 
[16:18:47.293]                               next
[16:18:47.293]                             if (!grepl(pattern, name)) 
[16:18:47.293]                               next
[16:18:47.293]                             invokeRestart(restart)
[16:18:47.293]                             muffled <- TRUE
[16:18:47.293]                             break
[16:18:47.293]                           }
[16:18:47.293]                         }
[16:18:47.293]                       }
[16:18:47.293]                       invisible(muffled)
[16:18:47.293]                     }
[16:18:47.293]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.293]                   }
[16:18:47.293]                 }
[16:18:47.293]                 else {
[16:18:47.293]                   if (TRUE) {
[16:18:47.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.293]                     {
[16:18:47.293]                       inherits <- base::inherits
[16:18:47.293]                       invokeRestart <- base::invokeRestart
[16:18:47.293]                       is.null <- base::is.null
[16:18:47.293]                       muffled <- FALSE
[16:18:47.293]                       if (inherits(cond, "message")) {
[16:18:47.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.293]                         if (muffled) 
[16:18:47.293]                           invokeRestart("muffleMessage")
[16:18:47.293]                       }
[16:18:47.293]                       else if (inherits(cond, "warning")) {
[16:18:47.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.293]                         if (muffled) 
[16:18:47.293]                           invokeRestart("muffleWarning")
[16:18:47.293]                       }
[16:18:47.293]                       else if (inherits(cond, "condition")) {
[16:18:47.293]                         if (!is.null(pattern)) {
[16:18:47.293]                           computeRestarts <- base::computeRestarts
[16:18:47.293]                           grepl <- base::grepl
[16:18:47.293]                           restarts <- computeRestarts(cond)
[16:18:47.293]                           for (restart in restarts) {
[16:18:47.293]                             name <- restart$name
[16:18:47.293]                             if (is.null(name)) 
[16:18:47.293]                               next
[16:18:47.293]                             if (!grepl(pattern, name)) 
[16:18:47.293]                               next
[16:18:47.293]                             invokeRestart(restart)
[16:18:47.293]                             muffled <- TRUE
[16:18:47.293]                             break
[16:18:47.293]                           }
[16:18:47.293]                         }
[16:18:47.293]                       }
[16:18:47.293]                       invisible(muffled)
[16:18:47.293]                     }
[16:18:47.293]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.293]                   }
[16:18:47.293]                 }
[16:18:47.293]             }
[16:18:47.293]         }))
[16:18:47.293]     }, error = function(ex) {
[16:18:47.293]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:47.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.293]                 ...future.rng), started = ...future.startTime, 
[16:18:47.293]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:47.293]             version = "1.8"), class = "FutureResult")
[16:18:47.293]     }, finally = {
[16:18:47.293]         if (!identical(...future.workdir, getwd())) 
[16:18:47.293]             setwd(...future.workdir)
[16:18:47.293]         {
[16:18:47.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:47.293]                 ...future.oldOptions$nwarnings <- NULL
[16:18:47.293]             }
[16:18:47.293]             base::options(...future.oldOptions)
[16:18:47.293]             if (.Platform$OS.type == "windows") {
[16:18:47.293]                 old_names <- names(...future.oldEnvVars)
[16:18:47.293]                 envs <- base::Sys.getenv()
[16:18:47.293]                 names <- names(envs)
[16:18:47.293]                 common <- intersect(names, old_names)
[16:18:47.293]                 added <- setdiff(names, old_names)
[16:18:47.293]                 removed <- setdiff(old_names, names)
[16:18:47.293]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:47.293]                   envs[common]]
[16:18:47.293]                 NAMES <- toupper(changed)
[16:18:47.293]                 args <- list()
[16:18:47.293]                 for (kk in seq_along(NAMES)) {
[16:18:47.293]                   name <- changed[[kk]]
[16:18:47.293]                   NAME <- NAMES[[kk]]
[16:18:47.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.293]                     next
[16:18:47.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.293]                 }
[16:18:47.293]                 NAMES <- toupper(added)
[16:18:47.293]                 for (kk in seq_along(NAMES)) {
[16:18:47.293]                   name <- added[[kk]]
[16:18:47.293]                   NAME <- NAMES[[kk]]
[16:18:47.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.293]                     next
[16:18:47.293]                   args[[name]] <- ""
[16:18:47.293]                 }
[16:18:47.293]                 NAMES <- toupper(removed)
[16:18:47.293]                 for (kk in seq_along(NAMES)) {
[16:18:47.293]                   name <- removed[[kk]]
[16:18:47.293]                   NAME <- NAMES[[kk]]
[16:18:47.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.293]                     next
[16:18:47.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.293]                 }
[16:18:47.293]                 if (length(args) > 0) 
[16:18:47.293]                   base::do.call(base::Sys.setenv, args = args)
[16:18:47.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:47.293]             }
[16:18:47.293]             else {
[16:18:47.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:47.293]             }
[16:18:47.293]             {
[16:18:47.293]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:47.293]                   0L) {
[16:18:47.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:47.293]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:47.293]                   base::options(opts)
[16:18:47.293]                 }
[16:18:47.293]                 {
[16:18:47.293]                   {
[16:18:47.293]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:47.293]                     NULL
[16:18:47.293]                   }
[16:18:47.293]                   options(future.plan = NULL)
[16:18:47.293]                   if (is.na(NA_character_)) 
[16:18:47.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:47.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:47.293]                     .init = FALSE)
[16:18:47.293]                 }
[16:18:47.293]             }
[16:18:47.293]         }
[16:18:47.293]     })
[16:18:47.293]     if (TRUE) {
[16:18:47.293]         base::sink(type = "output", split = FALSE)
[16:18:47.293]         if (TRUE) {
[16:18:47.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:47.293]         }
[16:18:47.293]         else {
[16:18:47.293]             ...future.result["stdout"] <- base::list(NULL)
[16:18:47.293]         }
[16:18:47.293]         base::close(...future.stdout)
[16:18:47.293]         ...future.stdout <- NULL
[16:18:47.293]     }
[16:18:47.293]     ...future.result$conditions <- ...future.conditions
[16:18:47.293]     ...future.result$finished <- base::Sys.time()
[16:18:47.293]     ...future.result
[16:18:47.293] }
[16:18:47.296] Exporting 5 global objects (904 bytes) to cluster node #1 ...
[16:18:47.296] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:18:47.296] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:18:47.297] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:18:47.297] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:18:47.297] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:18:47.297] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:18:47.298] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:18:47.298] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:18:47.298] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:18:47.298] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:18:47.298] Exporting 5 global objects (904 bytes) to cluster node #1 ... DONE
[16:18:47.299] MultisessionFuture started
[16:18:47.299] - Launch lazy future ... done
[16:18:47.299] run() for ‘MultisessionFuture’ ... done
[16:18:47.299] Created future:
[16:18:47.299] MultisessionFuture:
[16:18:47.299] Label: ‘future_mapply-1’
[16:18:47.299] Expression:
[16:18:47.299] {
[16:18:47.299]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.299]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:47.299]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.299]         on.exit(options(oopts), add = TRUE)
[16:18:47.299]     }
[16:18:47.299]     {
[16:18:47.299]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.299]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:47.299]         do.call(mapply, args = args)
[16:18:47.299]     }
[16:18:47.299] }
[16:18:47.299] Lazy evaluation: FALSE
[16:18:47.299] Asynchronous evaluation: TRUE
[16:18:47.299] Local evaluation: TRUE
[16:18:47.299] Environment: R_GlobalEnv
[16:18:47.299] Capture standard output: TRUE
[16:18:47.299] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:47.299] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:47.299] Packages: <none>
[16:18:47.299] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:47.299] Resolved: FALSE
[16:18:47.299] Value: <not collected>
[16:18:47.299] Conditions captured: <none>
[16:18:47.299] Early signaling: FALSE
[16:18:47.299] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:47.299] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.311] Chunk #1 of 2 ... DONE
[16:18:47.311] Chunk #2 of 2 ...
[16:18:47.311]  - Finding globals in '...' for chunk #2 ...
[16:18:47.311] getGlobalsAndPackages() ...
[16:18:47.311] Searching for globals...
[16:18:47.312] 
[16:18:47.312] Searching for globals ... DONE
[16:18:47.312] - globals: [0] <none>
[16:18:47.312] getGlobalsAndPackages() ... DONE
[16:18:47.312]    + additional globals found: [n=0] 
[16:18:47.312]    + additional namespaces needed: [n=0] 
[16:18:47.312]  - Finding globals in '...' for chunk #2 ... DONE
[16:18:47.312]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:18:47.312]  - seeds: <none>
[16:18:47.312]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.313] getGlobalsAndPackages() ...
[16:18:47.313] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.313] Resolving globals: FALSE
[16:18:47.313] The total size of the 5 globals is 904 bytes (904 bytes)
[16:18:47.314] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:18:47.314] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:18:47.314] 
[16:18:47.314] getGlobalsAndPackages() ... DONE
[16:18:47.314] run() for ‘Future’ ...
[16:18:47.314] - state: ‘created’
[16:18:47.315] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:18:47.328] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:18:47.329]   - Field: ‘node’
[16:18:47.329]   - Field: ‘label’
[16:18:47.329]   - Field: ‘local’
[16:18:47.329]   - Field: ‘owner’
[16:18:47.329]   - Field: ‘envir’
[16:18:47.329]   - Field: ‘workers’
[16:18:47.329]   - Field: ‘packages’
[16:18:47.329]   - Field: ‘gc’
[16:18:47.330]   - Field: ‘conditions’
[16:18:47.330]   - Field: ‘persistent’
[16:18:47.330]   - Field: ‘expr’
[16:18:47.330]   - Field: ‘uuid’
[16:18:47.330]   - Field: ‘seed’
[16:18:47.330]   - Field: ‘version’
[16:18:47.330]   - Field: ‘result’
[16:18:47.330]   - Field: ‘asynchronous’
[16:18:47.330]   - Field: ‘calls’
[16:18:47.330]   - Field: ‘globals’
[16:18:47.330]   - Field: ‘stdout’
[16:18:47.331]   - Field: ‘earlySignal’
[16:18:47.331]   - Field: ‘lazy’
[16:18:47.331]   - Field: ‘state’
[16:18:47.331] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:18:47.331] - Launch lazy future ...
[16:18:47.331] Packages needed by the future expression (n = 0): <none>
[16:18:47.331] Packages needed by future strategies (n = 0): <none>
[16:18:47.332] {
[16:18:47.332]     {
[16:18:47.332]         {
[16:18:47.332]             ...future.startTime <- base::Sys.time()
[16:18:47.332]             {
[16:18:47.332]                 {
[16:18:47.332]                   {
[16:18:47.332]                     {
[16:18:47.332]                       base::local({
[16:18:47.332]                         has_future <- base::requireNamespace("future", 
[16:18:47.332]                           quietly = TRUE)
[16:18:47.332]                         if (has_future) {
[16:18:47.332]                           ns <- base::getNamespace("future")
[16:18:47.332]                           version <- ns[[".package"]][["version"]]
[16:18:47.332]                           if (is.null(version)) 
[16:18:47.332]                             version <- utils::packageVersion("future")
[16:18:47.332]                         }
[16:18:47.332]                         else {
[16:18:47.332]                           version <- NULL
[16:18:47.332]                         }
[16:18:47.332]                         if (!has_future || version < "1.8.0") {
[16:18:47.332]                           info <- base::c(r_version = base::gsub("R version ", 
[16:18:47.332]                             "", base::R.version$version.string), 
[16:18:47.332]                             platform = base::sprintf("%s (%s-bit)", 
[16:18:47.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:18:47.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:18:47.332]                               "release", "version")], collapse = " "), 
[16:18:47.332]                             hostname = base::Sys.info()[["nodename"]])
[16:18:47.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:18:47.332]                             info)
[16:18:47.332]                           info <- base::paste(info, collapse = "; ")
[16:18:47.332]                           if (!has_future) {
[16:18:47.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:18:47.332]                               info)
[16:18:47.332]                           }
[16:18:47.332]                           else {
[16:18:47.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:18:47.332]                               info, version)
[16:18:47.332]                           }
[16:18:47.332]                           base::stop(msg)
[16:18:47.332]                         }
[16:18:47.332]                       })
[16:18:47.332]                     }
[16:18:47.332]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:18:47.332]                     base::options(mc.cores = 1L)
[16:18:47.332]                   }
[16:18:47.332]                   ...future.strategy.old <- future::plan("list")
[16:18:47.332]                   options(future.plan = NULL)
[16:18:47.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:18:47.332]                 }
[16:18:47.332]                 ...future.workdir <- getwd()
[16:18:47.332]             }
[16:18:47.332]             ...future.oldOptions <- base::as.list(base::.Options)
[16:18:47.332]             ...future.oldEnvVars <- base::Sys.getenv()
[16:18:47.332]         }
[16:18:47.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:18:47.332]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:18:47.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:18:47.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:18:47.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:18:47.332]             future.stdout.windows.reencode = NULL, width = 80L)
[16:18:47.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:18:47.332]             base::names(...future.oldOptions))
[16:18:47.332]     }
[16:18:47.332]     if (FALSE) {
[16:18:47.332]     }
[16:18:47.332]     else {
[16:18:47.332]         if (TRUE) {
[16:18:47.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:18:47.332]                 open = "w")
[16:18:47.332]         }
[16:18:47.332]         else {
[16:18:47.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:18:47.332]                 windows = "NUL", "/dev/null"), open = "w")
[16:18:47.332]         }
[16:18:47.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:18:47.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:18:47.332]             base::sink(type = "output", split = FALSE)
[16:18:47.332]             base::close(...future.stdout)
[16:18:47.332]         }, add = TRUE)
[16:18:47.332]     }
[16:18:47.332]     ...future.frame <- base::sys.nframe()
[16:18:47.332]     ...future.conditions <- base::list()
[16:18:47.332]     ...future.rng <- base::globalenv()$.Random.seed
[16:18:47.332]     if (FALSE) {
[16:18:47.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:18:47.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:18:47.332]     }
[16:18:47.332]     ...future.result <- base::tryCatch({
[16:18:47.332]         base::withCallingHandlers({
[16:18:47.332]             ...future.value <- base::withVisible(base::local({
[16:18:47.332]                 ...future.makeSendCondition <- base::local({
[16:18:47.332]                   sendCondition <- NULL
[16:18:47.332]                   function(frame = 1L) {
[16:18:47.332]                     if (is.function(sendCondition)) 
[16:18:47.332]                       return(sendCondition)
[16:18:47.332]                     ns <- getNamespace("parallel")
[16:18:47.332]                     if (exists("sendData", mode = "function", 
[16:18:47.332]                       envir = ns)) {
[16:18:47.332]                       parallel_sendData <- get("sendData", mode = "function", 
[16:18:47.332]                         envir = ns)
[16:18:47.332]                       envir <- sys.frame(frame)
[16:18:47.332]                       master <- NULL
[16:18:47.332]                       while (!identical(envir, .GlobalEnv) && 
[16:18:47.332]                         !identical(envir, emptyenv())) {
[16:18:47.332]                         if (exists("master", mode = "list", envir = envir, 
[16:18:47.332]                           inherits = FALSE)) {
[16:18:47.332]                           master <- get("master", mode = "list", 
[16:18:47.332]                             envir = envir, inherits = FALSE)
[16:18:47.332]                           if (inherits(master, c("SOCKnode", 
[16:18:47.332]                             "SOCK0node"))) {
[16:18:47.332]                             sendCondition <<- function(cond) {
[16:18:47.332]                               data <- list(type = "VALUE", value = cond, 
[16:18:47.332]                                 success = TRUE)
[16:18:47.332]                               parallel_sendData(master, data)
[16:18:47.332]                             }
[16:18:47.332]                             return(sendCondition)
[16:18:47.332]                           }
[16:18:47.332]                         }
[16:18:47.332]                         frame <- frame + 1L
[16:18:47.332]                         envir <- sys.frame(frame)
[16:18:47.332]                       }
[16:18:47.332]                     }
[16:18:47.332]                     sendCondition <<- function(cond) NULL
[16:18:47.332]                   }
[16:18:47.332]                 })
[16:18:47.332]                 withCallingHandlers({
[16:18:47.332]                   {
[16:18:47.332]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.332]                     if (!identical(...future.globals.maxSize.org, 
[16:18:47.332]                       ...future.globals.maxSize)) {
[16:18:47.332]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.332]                       on.exit(options(oopts), add = TRUE)
[16:18:47.332]                     }
[16:18:47.332]                     {
[16:18:47.332]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.332]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:18:47.332]                         USE.NAMES = FALSE)
[16:18:47.332]                       do.call(mapply, args = args)
[16:18:47.332]                     }
[16:18:47.332]                   }
[16:18:47.332]                 }, immediateCondition = function(cond) {
[16:18:47.332]                   sendCondition <- ...future.makeSendCondition()
[16:18:47.332]                   sendCondition(cond)
[16:18:47.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.332]                   {
[16:18:47.332]                     inherits <- base::inherits
[16:18:47.332]                     invokeRestart <- base::invokeRestart
[16:18:47.332]                     is.null <- base::is.null
[16:18:47.332]                     muffled <- FALSE
[16:18:47.332]                     if (inherits(cond, "message")) {
[16:18:47.332]                       muffled <- grepl(pattern, "muffleMessage")
[16:18:47.332]                       if (muffled) 
[16:18:47.332]                         invokeRestart("muffleMessage")
[16:18:47.332]                     }
[16:18:47.332]                     else if (inherits(cond, "warning")) {
[16:18:47.332]                       muffled <- grepl(pattern, "muffleWarning")
[16:18:47.332]                       if (muffled) 
[16:18:47.332]                         invokeRestart("muffleWarning")
[16:18:47.332]                     }
[16:18:47.332]                     else if (inherits(cond, "condition")) {
[16:18:47.332]                       if (!is.null(pattern)) {
[16:18:47.332]                         computeRestarts <- base::computeRestarts
[16:18:47.332]                         grepl <- base::grepl
[16:18:47.332]                         restarts <- computeRestarts(cond)
[16:18:47.332]                         for (restart in restarts) {
[16:18:47.332]                           name <- restart$name
[16:18:47.332]                           if (is.null(name)) 
[16:18:47.332]                             next
[16:18:47.332]                           if (!grepl(pattern, name)) 
[16:18:47.332]                             next
[16:18:47.332]                           invokeRestart(restart)
[16:18:47.332]                           muffled <- TRUE
[16:18:47.332]                           break
[16:18:47.332]                         }
[16:18:47.332]                       }
[16:18:47.332]                     }
[16:18:47.332]                     invisible(muffled)
[16:18:47.332]                   }
[16:18:47.332]                   muffleCondition(cond)
[16:18:47.332]                 })
[16:18:47.332]             }))
[16:18:47.332]             future::FutureResult(value = ...future.value$value, 
[16:18:47.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.332]                   ...future.rng), globalenv = if (FALSE) 
[16:18:47.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:18:47.332]                     ...future.globalenv.names))
[16:18:47.332]                 else NULL, started = ...future.startTime, version = "1.8")
[16:18:47.332]         }, condition = base::local({
[16:18:47.332]             c <- base::c
[16:18:47.332]             inherits <- base::inherits
[16:18:47.332]             invokeRestart <- base::invokeRestart
[16:18:47.332]             length <- base::length
[16:18:47.332]             list <- base::list
[16:18:47.332]             seq.int <- base::seq.int
[16:18:47.332]             signalCondition <- base::signalCondition
[16:18:47.332]             sys.calls <- base::sys.calls
[16:18:47.332]             `[[` <- base::`[[`
[16:18:47.332]             `+` <- base::`+`
[16:18:47.332]             `<<-` <- base::`<<-`
[16:18:47.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:18:47.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:18:47.332]                   3L)]
[16:18:47.332]             }
[16:18:47.332]             function(cond) {
[16:18:47.332]                 is_error <- inherits(cond, "error")
[16:18:47.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:18:47.332]                   NULL)
[16:18:47.332]                 if (is_error) {
[16:18:47.332]                   sessionInformation <- function() {
[16:18:47.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:18:47.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:18:47.332]                       search = base::search(), system = base::Sys.info())
[16:18:47.332]                   }
[16:18:47.332]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:18:47.332]                     cond$call), session = sessionInformation(), 
[16:18:47.332]                     timestamp = base::Sys.time(), signaled = 0L)
[16:18:47.332]                   signalCondition(cond)
[16:18:47.332]                 }
[16:18:47.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:18:47.332]                 "immediateCondition"))) {
[16:18:47.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:18:47.332]                   ...future.conditions[[length(...future.conditions) + 
[16:18:47.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:18:47.332]                   if (TRUE && !signal) {
[16:18:47.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.332]                     {
[16:18:47.332]                       inherits <- base::inherits
[16:18:47.332]                       invokeRestart <- base::invokeRestart
[16:18:47.332]                       is.null <- base::is.null
[16:18:47.332]                       muffled <- FALSE
[16:18:47.332]                       if (inherits(cond, "message")) {
[16:18:47.332]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.332]                         if (muffled) 
[16:18:47.332]                           invokeRestart("muffleMessage")
[16:18:47.332]                       }
[16:18:47.332]                       else if (inherits(cond, "warning")) {
[16:18:47.332]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.332]                         if (muffled) 
[16:18:47.332]                           invokeRestart("muffleWarning")
[16:18:47.332]                       }
[16:18:47.332]                       else if (inherits(cond, "condition")) {
[16:18:47.332]                         if (!is.null(pattern)) {
[16:18:47.332]                           computeRestarts <- base::computeRestarts
[16:18:47.332]                           grepl <- base::grepl
[16:18:47.332]                           restarts <- computeRestarts(cond)
[16:18:47.332]                           for (restart in restarts) {
[16:18:47.332]                             name <- restart$name
[16:18:47.332]                             if (is.null(name)) 
[16:18:47.332]                               next
[16:18:47.332]                             if (!grepl(pattern, name)) 
[16:18:47.332]                               next
[16:18:47.332]                             invokeRestart(restart)
[16:18:47.332]                             muffled <- TRUE
[16:18:47.332]                             break
[16:18:47.332]                           }
[16:18:47.332]                         }
[16:18:47.332]                       }
[16:18:47.332]                       invisible(muffled)
[16:18:47.332]                     }
[16:18:47.332]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.332]                   }
[16:18:47.332]                 }
[16:18:47.332]                 else {
[16:18:47.332]                   if (TRUE) {
[16:18:47.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:18:47.332]                     {
[16:18:47.332]                       inherits <- base::inherits
[16:18:47.332]                       invokeRestart <- base::invokeRestart
[16:18:47.332]                       is.null <- base::is.null
[16:18:47.332]                       muffled <- FALSE
[16:18:47.332]                       if (inherits(cond, "message")) {
[16:18:47.332]                         muffled <- grepl(pattern, "muffleMessage")
[16:18:47.332]                         if (muffled) 
[16:18:47.332]                           invokeRestart("muffleMessage")
[16:18:47.332]                       }
[16:18:47.332]                       else if (inherits(cond, "warning")) {
[16:18:47.332]                         muffled <- grepl(pattern, "muffleWarning")
[16:18:47.332]                         if (muffled) 
[16:18:47.332]                           invokeRestart("muffleWarning")
[16:18:47.332]                       }
[16:18:47.332]                       else if (inherits(cond, "condition")) {
[16:18:47.332]                         if (!is.null(pattern)) {
[16:18:47.332]                           computeRestarts <- base::computeRestarts
[16:18:47.332]                           grepl <- base::grepl
[16:18:47.332]                           restarts <- computeRestarts(cond)
[16:18:47.332]                           for (restart in restarts) {
[16:18:47.332]                             name <- restart$name
[16:18:47.332]                             if (is.null(name)) 
[16:18:47.332]                               next
[16:18:47.332]                             if (!grepl(pattern, name)) 
[16:18:47.332]                               next
[16:18:47.332]                             invokeRestart(restart)
[16:18:47.332]                             muffled <- TRUE
[16:18:47.332]                             break
[16:18:47.332]                           }
[16:18:47.332]                         }
[16:18:47.332]                       }
[16:18:47.332]                       invisible(muffled)
[16:18:47.332]                     }
[16:18:47.332]                     muffleCondition(cond, pattern = "^muffle")
[16:18:47.332]                   }
[16:18:47.332]                 }
[16:18:47.332]             }
[16:18:47.332]         }))
[16:18:47.332]     }, error = function(ex) {
[16:18:47.332]         base::structure(base::list(value = NULL, visible = NULL, 
[16:18:47.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:18:47.332]                 ...future.rng), started = ...future.startTime, 
[16:18:47.332]             finished = Sys.time(), session_uuid = NA_character_, 
[16:18:47.332]             version = "1.8"), class = "FutureResult")
[16:18:47.332]     }, finally = {
[16:18:47.332]         if (!identical(...future.workdir, getwd())) 
[16:18:47.332]             setwd(...future.workdir)
[16:18:47.332]         {
[16:18:47.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:18:47.332]                 ...future.oldOptions$nwarnings <- NULL
[16:18:47.332]             }
[16:18:47.332]             base::options(...future.oldOptions)
[16:18:47.332]             if (.Platform$OS.type == "windows") {
[16:18:47.332]                 old_names <- names(...future.oldEnvVars)
[16:18:47.332]                 envs <- base::Sys.getenv()
[16:18:47.332]                 names <- names(envs)
[16:18:47.332]                 common <- intersect(names, old_names)
[16:18:47.332]                 added <- setdiff(names, old_names)
[16:18:47.332]                 removed <- setdiff(old_names, names)
[16:18:47.332]                 changed <- common[...future.oldEnvVars[common] != 
[16:18:47.332]                   envs[common]]
[16:18:47.332]                 NAMES <- toupper(changed)
[16:18:47.332]                 args <- list()
[16:18:47.332]                 for (kk in seq_along(NAMES)) {
[16:18:47.332]                   name <- changed[[kk]]
[16:18:47.332]                   NAME <- NAMES[[kk]]
[16:18:47.332]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.332]                     next
[16:18:47.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.332]                 }
[16:18:47.332]                 NAMES <- toupper(added)
[16:18:47.332]                 for (kk in seq_along(NAMES)) {
[16:18:47.332]                   name <- added[[kk]]
[16:18:47.332]                   NAME <- NAMES[[kk]]
[16:18:47.332]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.332]                     next
[16:18:47.332]                   args[[name]] <- ""
[16:18:47.332]                 }
[16:18:47.332]                 NAMES <- toupper(removed)
[16:18:47.332]                 for (kk in seq_along(NAMES)) {
[16:18:47.332]                   name <- removed[[kk]]
[16:18:47.332]                   NAME <- NAMES[[kk]]
[16:18:47.332]                   if (name != NAME && is.element(NAME, old_names)) 
[16:18:47.332]                     next
[16:18:47.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:18:47.332]                 }
[16:18:47.332]                 if (length(args) > 0) 
[16:18:47.332]                   base::do.call(base::Sys.setenv, args = args)
[16:18:47.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:18:47.332]             }
[16:18:47.332]             else {
[16:18:47.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:18:47.332]             }
[16:18:47.332]             {
[16:18:47.332]                 if (base::length(...future.futureOptionsAdded) > 
[16:18:47.332]                   0L) {
[16:18:47.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:18:47.332]                   base::names(opts) <- ...future.futureOptionsAdded
[16:18:47.332]                   base::options(opts)
[16:18:47.332]                 }
[16:18:47.332]                 {
[16:18:47.332]                   {
[16:18:47.332]                     base::options(mc.cores = ...future.mc.cores.old)
[16:18:47.332]                     NULL
[16:18:47.332]                   }
[16:18:47.332]                   options(future.plan = NULL)
[16:18:47.332]                   if (is.na(NA_character_)) 
[16:18:47.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:18:47.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:18:47.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:18:47.332]                     .init = FALSE)
[16:18:47.332]                 }
[16:18:47.332]             }
[16:18:47.332]         }
[16:18:47.332]     })
[16:18:47.332]     if (TRUE) {
[16:18:47.332]         base::sink(type = "output", split = FALSE)
[16:18:47.332]         if (TRUE) {
[16:18:47.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:18:47.332]         }
[16:18:47.332]         else {
[16:18:47.332]             ...future.result["stdout"] <- base::list(NULL)
[16:18:47.332]         }
[16:18:47.332]         base::close(...future.stdout)
[16:18:47.332]         ...future.stdout <- NULL
[16:18:47.332]     }
[16:18:47.332]     ...future.result$conditions <- ...future.conditions
[16:18:47.332]     ...future.result$finished <- base::Sys.time()
[16:18:47.332]     ...future.result
[16:18:47.332] }
[16:18:47.335] Exporting 5 global objects (904 bytes) to cluster node #2 ...
[16:18:47.335] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:18:47.335] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:18:47.335] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:18:47.336] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:18:47.336] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:18:47.336] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:18:47.336] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:18:47.336] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:18:47.337] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:18:47.337] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:18:47.337] Exporting 5 global objects (904 bytes) to cluster node #2 ... DONE
[16:18:47.338] MultisessionFuture started
[16:18:47.338] - Launch lazy future ... done
[16:18:47.338] run() for ‘MultisessionFuture’ ... done
[16:18:47.338] Created future:
[16:18:47.338] MultisessionFuture:
[16:18:47.338] Label: ‘future_mapply-2’
[16:18:47.338] Expression:
[16:18:47.338] {
[16:18:47.338]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:18:47.338]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:18:47.338]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:18:47.338]         on.exit(options(oopts), add = TRUE)
[16:18:47.338]     }
[16:18:47.338]     {
[16:18:47.338]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:18:47.338]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:18:47.338]         do.call(mapply, args = args)
[16:18:47.338]     }
[16:18:47.338] }
[16:18:47.338] Lazy evaluation: FALSE
[16:18:47.338] Asynchronous evaluation: TRUE
[16:18:47.338] Local evaluation: TRUE
[16:18:47.338] Environment: R_GlobalEnv
[16:18:47.338] Capture standard output: TRUE
[16:18:47.338] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:18:47.338] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:18:47.338] Packages: <none>
[16:18:47.338] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:18:47.338] Resolved: FALSE
[16:18:47.338] Value: <not collected>
[16:18:47.338] Conditions captured: <none>
[16:18:47.338] Early signaling: FALSE
[16:18:47.338] Owner process: affd7992-6f76-41cb-5b76-3b9a25bd5385
[16:18:47.338] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:18:47.349] Chunk #2 of 2 ... DONE
[16:18:47.350] Launching 2 futures (chunks) ... DONE
[16:18:47.350] Resolving 2 futures (chunks) ...
[16:18:47.350] resolve() on list ...
[16:18:47.350]  recursive: 0
[16:18:47.350]  length: 2
[16:18:47.350] 
[16:18:47.350] receiveMessageFromWorker() for ClusterFuture ...
[16:18:47.351] - Validating connection of MultisessionFuture
[16:18:47.351] - received message: FutureResult
[16:18:47.351] - Received FutureResult
[16:18:47.351] - Erased future from FutureRegistry
[16:18:47.351] result() for ClusterFuture ...
[16:18:47.351] - result already collected: FutureResult
[16:18:47.351] result() for ClusterFuture ... done
[16:18:47.351] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:47.351] Future #1
[16:18:47.352] result() for ClusterFuture ...
[16:18:47.352] - result already collected: FutureResult
[16:18:47.352] result() for ClusterFuture ... done
[16:18:47.352] result() for ClusterFuture ...
[16:18:47.352] - result already collected: FutureResult
[16:18:47.352] result() for ClusterFuture ... done
[16:18:47.352] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:18:47.352] - nx: 2
[16:18:47.352] - relay: TRUE
[16:18:47.352] - stdout: TRUE
[16:18:47.353] - signal: TRUE
[16:18:47.353] - resignal: FALSE
[16:18:47.353] - force: TRUE
[16:18:47.353] - relayed: [n=2] FALSE, FALSE
[16:18:47.353] - queued futures: [n=2] FALSE, FALSE
[16:18:47.353]  - until=1
[16:18:47.353]  - relaying element #1
[16:18:47.353] result() for ClusterFuture ...
[16:18:47.353] - result already collected: FutureResult
[16:18:47.353] result() for ClusterFuture ... done
[16:18:47.353] result() for ClusterFuture ...
[16:18:47.353] - result already collected: FutureResult
[16:18:47.354] result() for ClusterFuture ... done
[16:18:47.354] result() for ClusterFuture ...
[16:18:47.354] - result already collected: FutureResult
[16:18:47.354] result() for ClusterFuture ... done
[16:18:47.354] result() for ClusterFuture ...
[16:18:47.354] - result already collected: FutureResult
[16:18:47.354] result() for ClusterFuture ... done
[16:18:47.354] - relayed: [n=2] TRUE, FALSE
[16:18:47.354] - queued futures: [n=2] TRUE, FALSE
[16:18:47.354] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:18:47.354]  length: 1 (resolved future 1)
[16:18:47.382] receiveMessageFromWorker() for ClusterFuture ...
[16:18:47.382] - Validating connection of MultisessionFuture
[16:18:47.382] - received message: FutureResult
[16:18:47.382] - Received FutureResult
[16:18:47.383] - Erased future from FutureRegistry
[16:18:47.383] result() for ClusterFuture ...
[16:18:47.383] - result already collected: FutureResult
[16:18:47.383] result() for ClusterFuture ... done
[16:18:47.383] receiveMessageFromWorker() for ClusterFuture ... done
[16:18:47.383] Future #2
[16:18:47.383] result() for ClusterFuture ...
[16:18:47.383] - result already collected: FutureResult
[16:18:47.383] result() for ClusterFuture ... done
[16:18:47.383] result() for ClusterFuture ...
[16:18:47.384] - result already collected: FutureResult
[16:18:47.384] result() for ClusterFuture ... done
[16:18:47.384] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:18:47.384] - nx: 2
[16:18:47.384] - relay: TRUE
[16:18:47.384] - stdout: TRUE
[16:18:47.384] - signal: TRUE
[16:18:47.384] - resignal: FALSE
[16:18:47.384] - force: TRUE
[16:18:47.384] - relayed: [n=2] TRUE, FALSE
[16:18:47.384] - queued futures: [n=2] TRUE, FALSE
[16:18:47.385]  - until=2
[16:18:47.385]  - relaying element #2
[16:18:47.385] result() for ClusterFuture ...
[16:18:47.385] - result already collected: FutureResult
[16:18:47.385] result() for ClusterFuture ... done
[16:18:47.385] result() for ClusterFuture ...
[16:18:47.385] - result already collected: FutureResult
[16:18:47.385] result() for ClusterFuture ... done
[16:18:47.385] result() for ClusterFuture ...
[16:18:47.385] - result already collected: FutureResult
[16:18:47.385] result() for ClusterFuture ... done
[16:18:47.386] result() for ClusterFuture ...
[16:18:47.386] - result already collected: FutureResult
[16:18:47.386] result() for ClusterFuture ... done
[16:18:47.386] - relayed: [n=2] TRUE, TRUE
[16:18:47.386] - queued futures: [n=2] TRUE, TRUE
[16:18:47.386] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:18:47.386]  length: 0 (resolved future 2)
[16:18:47.386] Relaying remaining futures
[16:18:47.386] signalConditionsASAP(NULL, pos=0) ...
[16:18:47.387] - nx: 2
[16:18:47.387] - relay: TRUE
[16:18:47.387] - stdout: TRUE
[16:18:47.387] - signal: TRUE
[16:18:47.387] - resignal: FALSE
[16:18:47.387] - force: TRUE
[16:18:47.387] - relayed: [n=2] TRUE, TRUE
[16:18:47.387] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:18:47.387] - relayed: [n=2] TRUE, TRUE
[16:18:47.387] - queued futures: [n=2] TRUE, TRUE
[16:18:47.387] signalConditionsASAP(NULL, pos=0) ... done
[16:18:47.387] resolve() on list ... DONE
[16:18:47.388] result() for ClusterFuture ...
[16:18:47.388] - result already collected: FutureResult
[16:18:47.388] result() for ClusterFuture ... done
[16:18:47.388] result() for ClusterFuture ...
[16:18:47.388] - result already collected: FutureResult
[16:18:47.388] result() for ClusterFuture ... done
[16:18:47.388] result() for ClusterFuture ...
[16:18:47.388] - result already collected: FutureResult
[16:18:47.388] result() for ClusterFuture ... done
[16:18:47.388] result() for ClusterFuture ...
[16:18:47.388] - result already collected: FutureResult
[16:18:47.389] result() for ClusterFuture ... done
[16:18:47.389]  - Number of value chunks collected: 2
[16:18:47.389] Resolving 2 futures (chunks) ... DONE
[16:18:47.389] Reducing values from 2 chunks ...
[16:18:47.389]  - Number of values collected after concatenation: 2
[16:18:47.389]  - Number of values expected: 2
[16:18:47.389] Reducing values from 2 chunks ... DONE
[16:18:47.389] future_mapply() ... DONE
[16:18:47.389] plan(): Setting new future strategy stack:
[16:18:47.390] List of future strategies:
[16:18:47.390] 1. sequential:
[16:18:47.390]    - args: function (..., envir = parent.frame())
[16:18:47.390]    - tweaked: FALSE
[16:18:47.390]    - call: plan(sequential)
[16:18:47.390] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("- Empty input [non parallel] ...")
- Empty input [non parallel] ...
> y0 <- mapply(search)
> y1 <- future_mapply(search)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(list, integer(0L))
> y1 <- future_mapply(list, integer(0L))
> stopifnot(identical(y1, y0))
> 
> message("*** future_mapply() - special cases ...")
*** future_mapply() - special cases ...
> 
> X <- list()
> names(X) <- character(0L)
> 
> y <- future_mapply(FUN = identity, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> y <- future_mapply(FUN = identity, X, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> message("*** future_mapply() - special cases ... DONE")
*** future_mapply() - special cases ... DONE
> 
> message("*** future_mapply() ... DONE")
*** future_mapply() ... DONE
> 
> source("incl/end.R")
[16:18:47.392] plan(): Setting new future strategy stack:
[16:18:47.392] List of future strategies:
[16:18:47.392] 1. FutureStrategy:
[16:18:47.392]    - args: function (..., envir = parent.frame())
[16:18:47.392]    - tweaked: FALSE
[16:18:47.392]    - call: future::plan(oplan)
[16:18:47.393] plan(): nbrOfWorkers() = 1
> 
