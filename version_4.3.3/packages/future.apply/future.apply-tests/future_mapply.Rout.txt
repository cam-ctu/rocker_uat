
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:34:33.711] plan(): Setting new future strategy stack:
[13:34:33.711] List of future strategies:
[13:34:33.711] 1. sequential:
[13:34:33.711]    - args: function (..., envir = parent.frame())
[13:34:33.711]    - tweaked: FALSE
[13:34:33.711]    - call: future::plan("sequential")
[13:34:33.724] plan(): nbrOfWorkers() = 1
> 
> message("*** future_mapply() ...")
*** future_mapply() ...
> 
> message("- Parallel RNG truth (for later)...")
- Parallel RNG truth (for later)...
> plan(sequential)
[13:34:33.733] plan(): Setting new future strategy stack:
[13:34:33.733] List of future strategies:
[13:34:33.733] 1. sequential:
[13:34:33.733]    - args: function (..., envir = parent.frame())
[13:34:33.733]    - tweaked: FALSE
[13:34:33.733]    - call: plan(sequential)
[13:34:33.743] plan(): nbrOfWorkers() = 1
> y_rng_0 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                          MoreArgs = list(min = 1), future.seed = 0xBEEF)
[13:34:33.744] future_mapply() ...
[13:34:33.744] Generating random seeds ...
[13:34:33.744] Generating random seed streams for 4 elements ...
[13:34:33.745] Generating random seed streams for 4 elements ... DONE
[13:34:33.745] Generating random seeds ... DONE
[13:34:33.745] Will set RNG state on exit: 10407, 37299922, -878116216, -1429551491, -1019631951, -667060590, -54844326
[13:34:33.745] Number of chunks: 1
[13:34:33.746] getGlobalsAndPackagesXApply() ...
[13:34:33.746]  - future.globals: TRUE
[13:34:33.747] getGlobalsAndPackages() ...
[13:34:33.747] Searching for globals...
[13:34:33.752] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[13:34:33.752] Searching for globals ... DONE
[13:34:33.752] Resolving globals: FALSE
[13:34:33.753] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[13:34:33.754] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[13:34:33.754] - globals: [1] ‘FUN’
[13:34:33.754] - packages: [1] ‘stats’
[13:34:33.754] getGlobalsAndPackages() ... DONE
[13:34:33.754]  - globals found/used: [n=1] ‘FUN’
[13:34:33.754]  - needed namespaces: [n=1] ‘stats’
[13:34:33.755] Finding globals ... DONE
[13:34:33.755] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:33.755] List of 2
[13:34:33.755]  $ ...future.FUN:function (n, min = 0, max = 1)  
[13:34:33.755]  $ MoreArgs     :List of 1
[13:34:33.755]   ..$ min: num 1
[13:34:33.755]  - attr(*, "where")=List of 2
[13:34:33.755]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:33.755]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:33.755]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:33.755]  - attr(*, "resolved")= logi FALSE
[13:34:33.755]  - attr(*, "total_size")= num NA
[13:34:33.762] Packages to be attached in all futures: [n=1] ‘stats’
[13:34:33.762] getGlobalsAndPackagesXApply() ... DONE
[13:34:33.762] Number of futures (= number of chunks): 1
[13:34:33.763] Launching 1 futures (chunks) ...
[13:34:33.763] Chunk #1 of 1 ...
[13:34:33.763]  - Finding globals in '...' for chunk #1 ...
[13:34:33.763] getGlobalsAndPackages() ...
[13:34:33.763] Searching for globals...
[13:34:33.764] 
[13:34:33.764] Searching for globals ... DONE
[13:34:33.764] - globals: [0] <none>
[13:34:33.764] getGlobalsAndPackages() ... DONE
[13:34:33.764]    + additional globals found: [n=0] 
[13:34:33.764]    + additional namespaces needed: [n=0] 
[13:34:33.764]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:33.764]  - seeds: [4] <seeds>
[13:34:33.764]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:33.765] getGlobalsAndPackages() ...
[13:34:33.765] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:33.765] Resolving globals: FALSE
[13:34:33.765] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[13:34:33.766] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[13:34:33.766] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:33.766] - packages: [1] ‘stats’
[13:34:33.766] getGlobalsAndPackages() ... DONE
[13:34:33.767] run() for ‘Future’ ...
[13:34:33.767] - state: ‘created’
[13:34:33.767] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:33.768] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:33.768] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:33.768]   - Field: ‘label’
[13:34:33.768]   - Field: ‘local’
[13:34:33.768]   - Field: ‘owner’
[13:34:33.768]   - Field: ‘envir’
[13:34:33.768]   - Field: ‘packages’
[13:34:33.768]   - Field: ‘gc’
[13:34:33.768]   - Field: ‘conditions’
[13:34:33.768]   - Field: ‘expr’
[13:34:33.768]   - Field: ‘uuid’
[13:34:33.769]   - Field: ‘seed’
[13:34:33.769]   - Field: ‘version’
[13:34:33.769]   - Field: ‘result’
[13:34:33.769]   - Field: ‘asynchronous’
[13:34:33.769]   - Field: ‘calls’
[13:34:33.769]   - Field: ‘globals’
[13:34:33.769]   - Field: ‘stdout’
[13:34:33.769]   - Field: ‘earlySignal’
[13:34:33.769]   - Field: ‘lazy’
[13:34:33.769]   - Field: ‘state’
[13:34:33.769] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:33.770] - Launch lazy future ...
[13:34:33.770] Packages needed by the future expression (n = 1): ‘stats’
[13:34:33.770] Packages needed by future strategies (n = 0): <none>
[13:34:33.771] {
[13:34:33.771]     {
[13:34:33.771]         {
[13:34:33.771]             ...future.startTime <- base::Sys.time()
[13:34:33.771]             {
[13:34:33.771]                 {
[13:34:33.771]                   {
[13:34:33.771]                     {
[13:34:33.771]                       base::local({
[13:34:33.771]                         has_future <- base::requireNamespace("future", 
[13:34:33.771]                           quietly = TRUE)
[13:34:33.771]                         if (has_future) {
[13:34:33.771]                           ns <- base::getNamespace("future")
[13:34:33.771]                           version <- ns[[".package"]][["version"]]
[13:34:33.771]                           if (is.null(version)) 
[13:34:33.771]                             version <- utils::packageVersion("future")
[13:34:33.771]                         }
[13:34:33.771]                         else {
[13:34:33.771]                           version <- NULL
[13:34:33.771]                         }
[13:34:33.771]                         if (!has_future || version < "1.8.0") {
[13:34:33.771]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:33.771]                             "", base::R.version$version.string), 
[13:34:33.771]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:33.771]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:33.771]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:33.771]                               "release", "version")], collapse = " "), 
[13:34:33.771]                             hostname = base::Sys.info()[["nodename"]])
[13:34:33.771]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:33.771]                             info)
[13:34:33.771]                           info <- base::paste(info, collapse = "; ")
[13:34:33.771]                           if (!has_future) {
[13:34:33.771]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:33.771]                               info)
[13:34:33.771]                           }
[13:34:33.771]                           else {
[13:34:33.771]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:33.771]                               info, version)
[13:34:33.771]                           }
[13:34:33.771]                           base::stop(msg)
[13:34:33.771]                         }
[13:34:33.771]                       })
[13:34:33.771]                     }
[13:34:33.771]                     base::local({
[13:34:33.771]                       for (pkg in "stats") {
[13:34:33.771]                         base::loadNamespace(pkg)
[13:34:33.771]                         base::library(pkg, character.only = TRUE)
[13:34:33.771]                       }
[13:34:33.771]                     })
[13:34:33.771]                   }
[13:34:33.771]                   ...future.strategy.old <- future::plan("list")
[13:34:33.771]                   options(future.plan = NULL)
[13:34:33.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:33.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:33.771]                 }
[13:34:33.771]                 ...future.workdir <- getwd()
[13:34:33.771]             }
[13:34:33.771]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:33.771]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:33.771]         }
[13:34:33.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:33.771]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:33.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:33.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:33.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:33.771]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:33.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:33.771]             base::names(...future.oldOptions))
[13:34:33.771]     }
[13:34:33.771]     if (FALSE) {
[13:34:33.771]     }
[13:34:33.771]     else {
[13:34:33.771]         if (TRUE) {
[13:34:33.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:33.771]                 open = "w")
[13:34:33.771]         }
[13:34:33.771]         else {
[13:34:33.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:33.771]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:33.771]         }
[13:34:33.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:33.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:33.771]             base::sink(type = "output", split = FALSE)
[13:34:33.771]             base::close(...future.stdout)
[13:34:33.771]         }, add = TRUE)
[13:34:33.771]     }
[13:34:33.771]     ...future.frame <- base::sys.nframe()
[13:34:33.771]     ...future.conditions <- base::list()
[13:34:33.771]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:33.771]     if (FALSE) {
[13:34:33.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:33.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:33.771]     }
[13:34:33.771]     ...future.result <- base::tryCatch({
[13:34:33.771]         base::withCallingHandlers({
[13:34:33.771]             ...future.value <- base::withVisible(base::local({
[13:34:33.771]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:33.771]                 if (!identical(...future.globals.maxSize.org, 
[13:34:33.771]                   ...future.globals.maxSize)) {
[13:34:33.771]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:33.771]                   on.exit(options(oopts), add = TRUE)
[13:34:33.771]                 }
[13:34:33.771]                 {
[13:34:33.771]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:33.771]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[13:34:33.771]                       envir = globalenv(), inherits = FALSE)
[13:34:33.771]                     ...future.FUN(...)
[13:34:33.771]                   }
[13:34:33.771]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:33.771]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:33.771]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:33.771]                     USE.NAMES = FALSE)
[13:34:33.771]                   do.call(mapply, args = args)
[13:34:33.771]                 }
[13:34:33.771]             }))
[13:34:33.771]             future::FutureResult(value = ...future.value$value, 
[13:34:33.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:33.771]                   ...future.rng), globalenv = if (FALSE) 
[13:34:33.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:33.771]                     ...future.globalenv.names))
[13:34:33.771]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:33.771]         }, condition = base::local({
[13:34:33.771]             c <- base::c
[13:34:33.771]             inherits <- base::inherits
[13:34:33.771]             invokeRestart <- base::invokeRestart
[13:34:33.771]             length <- base::length
[13:34:33.771]             list <- base::list
[13:34:33.771]             seq.int <- base::seq.int
[13:34:33.771]             signalCondition <- base::signalCondition
[13:34:33.771]             sys.calls <- base::sys.calls
[13:34:33.771]             `[[` <- base::`[[`
[13:34:33.771]             `+` <- base::`+`
[13:34:33.771]             `<<-` <- base::`<<-`
[13:34:33.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:33.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:33.771]                   3L)]
[13:34:33.771]             }
[13:34:33.771]             function(cond) {
[13:34:33.771]                 is_error <- inherits(cond, "error")
[13:34:33.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:33.771]                   NULL)
[13:34:33.771]                 if (is_error) {
[13:34:33.771]                   sessionInformation <- function() {
[13:34:33.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:33.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:33.771]                       search = base::search(), system = base::Sys.info())
[13:34:33.771]                   }
[13:34:33.771]                   ...future.conditions[[length(...future.conditions) + 
[13:34:33.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:33.771]                     cond$call), session = sessionInformation(), 
[13:34:33.771]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:33.771]                   signalCondition(cond)
[13:34:33.771]                 }
[13:34:33.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:33.771]                 "immediateCondition"))) {
[13:34:33.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:33.771]                   ...future.conditions[[length(...future.conditions) + 
[13:34:33.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:33.771]                   if (TRUE && !signal) {
[13:34:33.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:33.771]                     {
[13:34:33.771]                       inherits <- base::inherits
[13:34:33.771]                       invokeRestart <- base::invokeRestart
[13:34:33.771]                       is.null <- base::is.null
[13:34:33.771]                       muffled <- FALSE
[13:34:33.771]                       if (inherits(cond, "message")) {
[13:34:33.771]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:33.771]                         if (muffled) 
[13:34:33.771]                           invokeRestart("muffleMessage")
[13:34:33.771]                       }
[13:34:33.771]                       else if (inherits(cond, "warning")) {
[13:34:33.771]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:33.771]                         if (muffled) 
[13:34:33.771]                           invokeRestart("muffleWarning")
[13:34:33.771]                       }
[13:34:33.771]                       else if (inherits(cond, "condition")) {
[13:34:33.771]                         if (!is.null(pattern)) {
[13:34:33.771]                           computeRestarts <- base::computeRestarts
[13:34:33.771]                           grepl <- base::grepl
[13:34:33.771]                           restarts <- computeRestarts(cond)
[13:34:33.771]                           for (restart in restarts) {
[13:34:33.771]                             name <- restart$name
[13:34:33.771]                             if (is.null(name)) 
[13:34:33.771]                               next
[13:34:33.771]                             if (!grepl(pattern, name)) 
[13:34:33.771]                               next
[13:34:33.771]                             invokeRestart(restart)
[13:34:33.771]                             muffled <- TRUE
[13:34:33.771]                             break
[13:34:33.771]                           }
[13:34:33.771]                         }
[13:34:33.771]                       }
[13:34:33.771]                       invisible(muffled)
[13:34:33.771]                     }
[13:34:33.771]                     muffleCondition(cond, pattern = "^muffle")
[13:34:33.771]                   }
[13:34:33.771]                 }
[13:34:33.771]                 else {
[13:34:33.771]                   if (TRUE) {
[13:34:33.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:33.771]                     {
[13:34:33.771]                       inherits <- base::inherits
[13:34:33.771]                       invokeRestart <- base::invokeRestart
[13:34:33.771]                       is.null <- base::is.null
[13:34:33.771]                       muffled <- FALSE
[13:34:33.771]                       if (inherits(cond, "message")) {
[13:34:33.771]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:33.771]                         if (muffled) 
[13:34:33.771]                           invokeRestart("muffleMessage")
[13:34:33.771]                       }
[13:34:33.771]                       else if (inherits(cond, "warning")) {
[13:34:33.771]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:33.771]                         if (muffled) 
[13:34:33.771]                           invokeRestart("muffleWarning")
[13:34:33.771]                       }
[13:34:33.771]                       else if (inherits(cond, "condition")) {
[13:34:33.771]                         if (!is.null(pattern)) {
[13:34:33.771]                           computeRestarts <- base::computeRestarts
[13:34:33.771]                           grepl <- base::grepl
[13:34:33.771]                           restarts <- computeRestarts(cond)
[13:34:33.771]                           for (restart in restarts) {
[13:34:33.771]                             name <- restart$name
[13:34:33.771]                             if (is.null(name)) 
[13:34:33.771]                               next
[13:34:33.771]                             if (!grepl(pattern, name)) 
[13:34:33.771]                               next
[13:34:33.771]                             invokeRestart(restart)
[13:34:33.771]                             muffled <- TRUE
[13:34:33.771]                             break
[13:34:33.771]                           }
[13:34:33.771]                         }
[13:34:33.771]                       }
[13:34:33.771]                       invisible(muffled)
[13:34:33.771]                     }
[13:34:33.771]                     muffleCondition(cond, pattern = "^muffle")
[13:34:33.771]                   }
[13:34:33.771]                 }
[13:34:33.771]             }
[13:34:33.771]         }))
[13:34:33.771]     }, error = function(ex) {
[13:34:33.771]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:33.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:33.771]                 ...future.rng), started = ...future.startTime, 
[13:34:33.771]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:33.771]             version = "1.8"), class = "FutureResult")
[13:34:33.771]     }, finally = {
[13:34:33.771]         if (!identical(...future.workdir, getwd())) 
[13:34:33.771]             setwd(...future.workdir)
[13:34:33.771]         {
[13:34:33.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:33.771]                 ...future.oldOptions$nwarnings <- NULL
[13:34:33.771]             }
[13:34:33.771]             base::options(...future.oldOptions)
[13:34:33.771]             if (.Platform$OS.type == "windows") {
[13:34:33.771]                 old_names <- names(...future.oldEnvVars)
[13:34:33.771]                 envs <- base::Sys.getenv()
[13:34:33.771]                 names <- names(envs)
[13:34:33.771]                 common <- intersect(names, old_names)
[13:34:33.771]                 added <- setdiff(names, old_names)
[13:34:33.771]                 removed <- setdiff(old_names, names)
[13:34:33.771]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:33.771]                   envs[common]]
[13:34:33.771]                 NAMES <- toupper(changed)
[13:34:33.771]                 args <- list()
[13:34:33.771]                 for (kk in seq_along(NAMES)) {
[13:34:33.771]                   name <- changed[[kk]]
[13:34:33.771]                   NAME <- NAMES[[kk]]
[13:34:33.771]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:33.771]                     next
[13:34:33.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:33.771]                 }
[13:34:33.771]                 NAMES <- toupper(added)
[13:34:33.771]                 for (kk in seq_along(NAMES)) {
[13:34:33.771]                   name <- added[[kk]]
[13:34:33.771]                   NAME <- NAMES[[kk]]
[13:34:33.771]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:33.771]                     next
[13:34:33.771]                   args[[name]] <- ""
[13:34:33.771]                 }
[13:34:33.771]                 NAMES <- toupper(removed)
[13:34:33.771]                 for (kk in seq_along(NAMES)) {
[13:34:33.771]                   name <- removed[[kk]]
[13:34:33.771]                   NAME <- NAMES[[kk]]
[13:34:33.771]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:33.771]                     next
[13:34:33.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:33.771]                 }
[13:34:33.771]                 if (length(args) > 0) 
[13:34:33.771]                   base::do.call(base::Sys.setenv, args = args)
[13:34:33.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:33.771]             }
[13:34:33.771]             else {
[13:34:33.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:33.771]             }
[13:34:33.771]             {
[13:34:33.771]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:33.771]                   0L) {
[13:34:33.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:33.771]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:33.771]                   base::options(opts)
[13:34:33.771]                 }
[13:34:33.771]                 {
[13:34:33.771]                   {
[13:34:33.771]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:33.771]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:33.771]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:33.771]                       inherits = FALSE)
[13:34:33.771]                     NULL
[13:34:33.771]                   }
[13:34:33.771]                   options(future.plan = NULL)
[13:34:33.771]                   if (is.na(NA_character_)) 
[13:34:33.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:33.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:33.771]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:33.771]                     .init = FALSE)
[13:34:33.771]                 }
[13:34:33.771]             }
[13:34:33.771]         }
[13:34:33.771]     })
[13:34:33.771]     if (TRUE) {
[13:34:33.771]         base::sink(type = "output", split = FALSE)
[13:34:33.771]         if (TRUE) {
[13:34:33.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:33.771]         }
[13:34:33.771]         else {
[13:34:33.771]             ...future.result["stdout"] <- base::list(NULL)
[13:34:33.771]         }
[13:34:33.771]         base::close(...future.stdout)
[13:34:33.771]         ...future.stdout <- NULL
[13:34:33.771]     }
[13:34:33.771]     ...future.result$conditions <- ...future.conditions
[13:34:33.771]     ...future.result$finished <- base::Sys.time()
[13:34:33.771]     ...future.result
[13:34:33.771] }
[13:34:33.773] assign_globals() ...
[13:34:33.773] List of 5
[13:34:33.773]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[13:34:33.773]  $ MoreArgs                 :List of 1
[13:34:33.773]   ..$ min: num 1
[13:34:33.773]  $ ...future.elements_ii    :List of 2
[13:34:33.773]   ..$ n  :List of 4
[13:34:33.773]   .. ..$ : int 1
[13:34:33.773]   .. ..$ : int 2
[13:34:33.773]   .. ..$ : int 3
[13:34:33.773]   .. ..$ : int 4
[13:34:33.773]   ..$ max:List of 4
[13:34:33.773]   .. ..$ : int 2
[13:34:33.773]   .. ..$ : int 3
[13:34:33.773]   .. ..$ : int 4
[13:34:33.773]   .. ..$ : int 5
[13:34:33.773]  $ ...future.seeds_ii       :List of 4
[13:34:33.773]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[13:34:33.773]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[13:34:33.773]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[13:34:33.773]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[13:34:33.773]  $ ...future.globals.maxSize: NULL
[13:34:33.773]  - attr(*, "where")=List of 5
[13:34:33.773]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:33.773]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:33.773]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:33.773]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:33.773]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:33.773]  - attr(*, "resolved")= logi FALSE
[13:34:33.773]  - attr(*, "total_size")= num 2912
[13:34:33.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:33.773]  - attr(*, "already-done")= logi TRUE
[13:34:33.781] - copied ‘...future.FUN’ to environment
[13:34:33.781] - copied ‘MoreArgs’ to environment
[13:34:33.781] - copied ‘...future.elements_ii’ to environment
[13:34:33.781] - copied ‘...future.seeds_ii’ to environment
[13:34:33.781] - copied ‘...future.globals.maxSize’ to environment
[13:34:33.781] assign_globals() ... done
[13:34:33.782] plan(): Setting new future strategy stack:
[13:34:33.782] List of future strategies:
[13:34:33.782] 1. sequential:
[13:34:33.782]    - args: function (..., envir = parent.frame())
[13:34:33.782]    - tweaked: FALSE
[13:34:33.782]    - call: NULL
[13:34:33.782] plan(): nbrOfWorkers() = 1
[13:34:33.783] plan(): Setting new future strategy stack:
[13:34:33.784] List of future strategies:
[13:34:33.784] 1. sequential:
[13:34:33.784]    - args: function (..., envir = parent.frame())
[13:34:33.784]    - tweaked: FALSE
[13:34:33.784]    - call: plan(sequential)
[13:34:33.784] plan(): nbrOfWorkers() = 1
[13:34:33.784] SequentialFuture started (and completed)
[13:34:33.785] - Launch lazy future ... done
[13:34:33.785] run() for ‘SequentialFuture’ ... done
[13:34:33.785] Created future:
[13:34:33.785] SequentialFuture:
[13:34:33.785] Label: ‘future_mapply-1’
[13:34:33.785] Expression:
[13:34:33.785] {
[13:34:33.785]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:33.785]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:33.785]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:33.785]         on.exit(options(oopts), add = TRUE)
[13:34:33.785]     }
[13:34:33.785]     {
[13:34:33.785]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:33.785]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[13:34:33.785]                 inherits = FALSE)
[13:34:33.785]             ...future.FUN(...)
[13:34:33.785]         }
[13:34:33.785]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:33.785]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:33.785]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:33.785]         do.call(mapply, args = args)
[13:34:33.785]     }
[13:34:33.785] }
[13:34:33.785] Lazy evaluation: FALSE
[13:34:33.785] Asynchronous evaluation: FALSE
[13:34:33.785] Local evaluation: TRUE
[13:34:33.785] Environment: R_GlobalEnv
[13:34:33.785] Capture standard output: TRUE
[13:34:33.785] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:33.785] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:33.785] Packages: 1 packages (‘stats’)
[13:34:33.785] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:34:33.785] Resolved: TRUE
[13:34:33.785] Value: 280 bytes of class ‘list’
[13:34:33.785] Early signaling: FALSE
[13:34:33.785] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:33.785] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:33.786] Chunk #1 of 1 ... DONE
[13:34:33.786] Launching 1 futures (chunks) ... DONE
[13:34:33.786] Resolving 1 futures (chunks) ...
[13:34:33.787] resolve() on list ...
[13:34:33.787]  recursive: 0
[13:34:33.787]  length: 1
[13:34:33.787] 
[13:34:33.787] resolved() for ‘SequentialFuture’ ...
[13:34:33.788] - state: ‘finished’
[13:34:33.788] - run: TRUE
[13:34:33.788] - result: ‘FutureResult’
[13:34:33.788] resolved() for ‘SequentialFuture’ ... done
[13:34:33.788] Future #1
[13:34:33.790] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:33.790] - nx: 1
[13:34:33.790] - relay: TRUE
[13:34:33.790] - stdout: TRUE
[13:34:33.790] - signal: TRUE
[13:34:33.790] - resignal: FALSE
[13:34:33.790] - force: TRUE
[13:34:33.790] - relayed: [n=1] FALSE
[13:34:33.790] - queued futures: [n=1] FALSE
[13:34:33.790]  - until=1
[13:34:33.791]  - relaying element #1
[13:34:33.791] - relayed: [n=1] TRUE
[13:34:33.791] - queued futures: [n=1] TRUE
[13:34:33.791] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:33.791]  length: 0 (resolved future 1)
[13:34:33.791] Relaying remaining futures
[13:34:33.791] signalConditionsASAP(NULL, pos=0) ...
[13:34:33.791] - nx: 1
[13:34:33.791] - relay: TRUE
[13:34:33.792] - stdout: TRUE
[13:34:33.792] - signal: TRUE
[13:34:33.792] - resignal: FALSE
[13:34:33.792] - force: TRUE
[13:34:33.792] - relayed: [n=1] TRUE
[13:34:33.792] - queued futures: [n=1] TRUE
 - flush all
[13:34:33.792] - relayed: [n=1] TRUE
[13:34:33.792] - queued futures: [n=1] TRUE
[13:34:33.792] signalConditionsASAP(NULL, pos=0) ... done
[13:34:33.792] resolve() on list ... DONE
[13:34:33.792]  - Number of value chunks collected: 1
[13:34:33.793] Resolving 1 futures (chunks) ... DONE
[13:34:33.793] Reducing values from 1 chunks ...
[13:34:33.793]  - Number of values collected after concatenation: 4
[13:34:33.793]  - Number of values expected: 4
[13:34:33.793] Reducing values from 1 chunks ... DONE
[13:34:33.793] future_mapply() ... DONE
> print(y_rng_0)
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(mapply) ...")
+   y0 <- mapply(rep, 1:4, 4:1)
+   y1 <- future_mapply(rep, 1:4, 4:1)
+   stopifnot(identical(y1, y0))
+   y2 <- future_mapply("rep", 1:4, 4:1)
+   stopifnot(identical(y2, y0))
+   
+   y0 <- mapply(rep, times = 1:4, x = 4:1)
+   y1 <- future_mapply(rep, times = 1:4, x = 4:1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(function(x, y) seq_len(x) + y,
+                c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                       c(a =  1, b = 2, c = 3),  # names from first
+                       c(A = 10, B = 0, C = -10))
+   stopifnot(identical(y1, y0))
+ 
+   message("- future_.mapply()")
+   dots <- list(c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y2 <- .mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   names(y0) <- NULL  ## .mapply() don't set names
+   stopifnot(all.equal(y2, y0))
+   y3 <- future_.mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   stopifnot(all.equal(y3, y2))
+ 
+   word <- function(C, k) paste(rep.int(C, k), collapse = "")
+   for (chunk.size in list(1L, structure(2L, ordering = "random"), structure(3L, ordering = 5:1))) {
+     y0 <- mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE)
+     y1 <- future_mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE, future.chunk.size = chunk.size)
+     stopifnot(identical(y1, y0))
+ 
+     dots <- list(LETTERS[1:5], 5:1)
+     MoreArgs <- list()
+     y2 <- .mapply(word, dots = dots, MoreArgs = list())
+     names(y0) <- NULL  ## .mapply() don't set names
+     stopifnot(all.equal(y2, y0))
+     y3 <- future_.mapply(word, dots = dots, MoreArgs = list())
+     stopifnot(all.equal(y3, y2))
+   }
+ 
+   message("- Subsetting (Issue #17) ...")
+   X <- as.Date("2018-06-01")
+   y0 <- mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   y1 <- future_mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   stopifnot(identical(y1, y0))
+ 
+   dots <- list(X)
+   y2 <- .mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y2, y0))
+   y3 <- future_.mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y3, y2))
+ 
+   message("- Non-recycling of MoreArgs (Issue #51) ...")
+   y0 <- base::mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4)
+   )
+   y1 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = FALSE
+   )
+   stopifnot(identical(y1, y0))
+   y2 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = TRUE
+   )
+   stopifnot(identical(y2, y0))
+ 
+   dots <- list(x = 1:2)
+   MoreArgs <- list(y = 3:4)
+   y3 <- .mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   y4 <- future_.mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y4, y3))
+ 
+   message("- Recycle arguments to same length ...")
+   y0 <- mapply(rep, 1:4, 2:1)
+   y1 <- future_mapply(rep, 1:4, 2:1)
+   stopifnot(identical(y1, y0))
+ 
+   
+   message("- Parallel RNG ...")
+   y_rng_1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                            MoreArgs = list(min = 1), future.seed = 0xBEEF)
+   print(y_rng_1)
+   stopifnot(all.equal(y_rng_1, y_rng_0))
+ 
+   message("- future_Map() ...")
+   xs <- replicate(5, stats::runif(10), simplify = FALSE)
+   ws <- replicate(5, stats::rpois(10, 5) + 1, simplify = FALSE)
+   y0 <- Map(weighted.mean, xs, ws)
+   y1 <- future_Map(stats::weighted.mean, xs, ws)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_mapply() - 'max-or-0-if' recycling rule ...")
+   ## R (>= 4.2.0): mapply() & Map() follow usual "max-or-0-if" recycling rule
+   ## and keeps returning a named list in the "empty" case.
+   
+   truth <- list()
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(`+`, 1:3, NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(`+`, 1:3, NULL)
+   stopifnot(identical(y, truth))
+   
+   truth <- setNames(list(), character())
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character())
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character()) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character()) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+ 
+   ## Gives an error in R-devel (2021-11-26 r81252)
+   if (getRversion() >= "4.2.0" && FALSE) {
+     y0 <- mapply(paste, c(a = "A"), character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, c(a = "A"), character())
+   stopifnot(identical(y, truth))
+ 
+   ## R (>= 4.2.0): Map() now recycles similar to basic Ops:
+   truth <- as.list(1 + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, 1, 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, 1, 1:3)
+   stopifnot(identical(y, truth))
+   
+   truth <- as.list(numeric() + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, numeric(), 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, numeric(), 1:3)
+   stopifnot(identical(y, truth))
+ 
+   message("- future_mapply(x, ...) where x[[i]] subsets via S3 method ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   `[[.Foo` <- function(x, ...) 0
+   y0 <- mapply(x, FUN = identity)
+   stopifnot(identical(y0, c(a = 0, b = 0)))
+   y1 <- future_mapply(x, FUN = identity)
+   if (getOption("future.apply.chunkWith", "[[") == "[") {
+     stopifnot(identical(y1, unlist(x)))
+   } else {
+     stopifnot(identical(y1, y0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[13:34:33.936] plan(): Setting new future strategy stack:
[13:34:33.936] List of future strategies:
[13:34:33.936] 1. sequential:
[13:34:33.936]    - args: function (..., envir = parent.frame())
[13:34:33.936]    - tweaked: FALSE
[13:34:33.936]    - call: plan(strategy)
[13:34:33.937] plan(): nbrOfWorkers() = 1
- From example(mapply) ...
[13:34:33.937] future_mapply() ...
[13:34:33.937] Number of chunks: 1
[13:34:33.937] getGlobalsAndPackagesXApply() ...
[13:34:33.937]  - future.globals: TRUE
[13:34:33.937] getGlobalsAndPackages() ...
[13:34:33.938] Searching for globals...
[13:34:33.938] - globals found: [1] ‘FUN’
[13:34:33.938] Searching for globals ... DONE
[13:34:33.938] Resolving globals: FALSE
[13:34:33.939] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:33.939] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:33.939] - globals: [1] ‘FUN’
[13:34:33.939] 
[13:34:33.939] getGlobalsAndPackages() ... DONE
[13:34:33.939]  - globals found/used: [n=1] ‘FUN’
[13:34:33.939]  - needed namespaces: [n=0] 
[13:34:33.939] Finding globals ... DONE
[13:34:33.940] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:33.940] List of 2
[13:34:33.940]  $ ...future.FUN:function (x, ...)  
[13:34:33.940]  $ MoreArgs     : NULL
[13:34:33.940]  - attr(*, "where")=List of 2
[13:34:33.940]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:33.940]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:33.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:33.940]  - attr(*, "resolved")= logi FALSE
[13:34:33.940]  - attr(*, "total_size")= num NA
[13:34:33.942] Packages to be attached in all futures: [n=0] 
[13:34:33.942] getGlobalsAndPackagesXApply() ... DONE
[13:34:33.942] Number of futures (= number of chunks): 1
[13:34:33.942] Launching 1 futures (chunks) ...
[13:34:33.942] Chunk #1 of 1 ...
[13:34:33.943]  - Finding globals in '...' for chunk #1 ...
[13:34:33.943] getGlobalsAndPackages() ...
[13:34:33.943] Searching for globals...
[13:34:33.943] 
[13:34:33.943] Searching for globals ... DONE
[13:34:33.943] - globals: [0] <none>
[13:34:33.943] getGlobalsAndPackages() ... DONE
[13:34:33.943]    + additional globals found: [n=0] 
[13:34:33.943]    + additional namespaces needed: [n=0] 
[13:34:33.944]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:33.944]  - seeds: <none>
[13:34:33.944]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:33.944] getGlobalsAndPackages() ...
[13:34:33.944] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:33.944] Resolving globals: FALSE
[13:34:33.944] The total size of the 5 globals is 504 bytes (504 bytes)
[13:34:33.945] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:33.945] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:33.945] 
[13:34:33.945] getGlobalsAndPackages() ... DONE
[13:34:33.945] run() for ‘Future’ ...
[13:34:33.946] - state: ‘created’
[13:34:33.946] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:33.946] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:33.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:33.946]   - Field: ‘label’
[13:34:33.946]   - Field: ‘local’
[13:34:33.946]   - Field: ‘owner’
[13:34:33.946]   - Field: ‘envir’
[13:34:33.946]   - Field: ‘packages’
[13:34:33.947]   - Field: ‘gc’
[13:34:33.947]   - Field: ‘conditions’
[13:34:33.947]   - Field: ‘expr’
[13:34:33.947]   - Field: ‘uuid’
[13:34:33.947]   - Field: ‘seed’
[13:34:33.947]   - Field: ‘version’
[13:34:33.947]   - Field: ‘result’
[13:34:33.947]   - Field: ‘asynchronous’
[13:34:33.947]   - Field: ‘calls’
[13:34:33.947]   - Field: ‘globals’
[13:34:33.947]   - Field: ‘stdout’
[13:34:33.947]   - Field: ‘earlySignal’
[13:34:33.948]   - Field: ‘lazy’
[13:34:33.948]   - Field: ‘state’
[13:34:33.948] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:33.948] - Launch lazy future ...
[13:34:33.948] Packages needed by the future expression (n = 0): <none>
[13:34:33.948] Packages needed by future strategies (n = 0): <none>
[13:34:33.948] {
[13:34:33.948]     {
[13:34:33.948]         {
[13:34:33.948]             ...future.startTime <- base::Sys.time()
[13:34:33.948]             {
[13:34:33.948]                 {
[13:34:33.948]                   {
[13:34:33.948]                     base::local({
[13:34:33.948]                       has_future <- base::requireNamespace("future", 
[13:34:33.948]                         quietly = TRUE)
[13:34:33.948]                       if (has_future) {
[13:34:33.948]                         ns <- base::getNamespace("future")
[13:34:33.948]                         version <- ns[[".package"]][["version"]]
[13:34:33.948]                         if (is.null(version)) 
[13:34:33.948]                           version <- utils::packageVersion("future")
[13:34:33.948]                       }
[13:34:33.948]                       else {
[13:34:33.948]                         version <- NULL
[13:34:33.948]                       }
[13:34:33.948]                       if (!has_future || version < "1.8.0") {
[13:34:33.948]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:33.948]                           "", base::R.version$version.string), 
[13:34:33.948]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:33.948]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:33.948]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:33.948]                             "release", "version")], collapse = " "), 
[13:34:33.948]                           hostname = base::Sys.info()[["nodename"]])
[13:34:33.948]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:33.948]                           info)
[13:34:33.948]                         info <- base::paste(info, collapse = "; ")
[13:34:33.948]                         if (!has_future) {
[13:34:33.948]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:33.948]                             info)
[13:34:33.948]                         }
[13:34:33.948]                         else {
[13:34:33.948]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:33.948]                             info, version)
[13:34:33.948]                         }
[13:34:33.948]                         base::stop(msg)
[13:34:33.948]                       }
[13:34:33.948]                     })
[13:34:33.948]                   }
[13:34:33.948]                   ...future.strategy.old <- future::plan("list")
[13:34:33.948]                   options(future.plan = NULL)
[13:34:33.948]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:33.948]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:33.948]                 }
[13:34:33.948]                 ...future.workdir <- getwd()
[13:34:33.948]             }
[13:34:33.948]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:33.948]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:33.948]         }
[13:34:33.948]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:33.948]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:33.948]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:33.948]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:33.948]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:33.948]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:33.948]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:33.948]             base::names(...future.oldOptions))
[13:34:33.948]     }
[13:34:33.948]     if (FALSE) {
[13:34:33.948]     }
[13:34:33.948]     else {
[13:34:33.948]         if (TRUE) {
[13:34:33.948]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:33.948]                 open = "w")
[13:34:33.948]         }
[13:34:33.948]         else {
[13:34:33.948]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:33.948]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:33.948]         }
[13:34:33.948]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:33.948]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:33.948]             base::sink(type = "output", split = FALSE)
[13:34:33.948]             base::close(...future.stdout)
[13:34:33.948]         }, add = TRUE)
[13:34:33.948]     }
[13:34:33.948]     ...future.frame <- base::sys.nframe()
[13:34:33.948]     ...future.conditions <- base::list()
[13:34:33.948]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:33.948]     if (FALSE) {
[13:34:33.948]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:33.948]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:33.948]     }
[13:34:33.948]     ...future.result <- base::tryCatch({
[13:34:33.948]         base::withCallingHandlers({
[13:34:33.948]             ...future.value <- base::withVisible(base::local({
[13:34:33.948]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:33.948]                 if (!identical(...future.globals.maxSize.org, 
[13:34:33.948]                   ...future.globals.maxSize)) {
[13:34:33.948]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:33.948]                   on.exit(options(oopts), add = TRUE)
[13:34:33.948]                 }
[13:34:33.948]                 {
[13:34:33.948]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:33.948]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:33.948]                     USE.NAMES = FALSE)
[13:34:33.948]                   do.call(mapply, args = args)
[13:34:33.948]                 }
[13:34:33.948]             }))
[13:34:33.948]             future::FutureResult(value = ...future.value$value, 
[13:34:33.948]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:33.948]                   ...future.rng), globalenv = if (FALSE) 
[13:34:33.948]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:33.948]                     ...future.globalenv.names))
[13:34:33.948]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:33.948]         }, condition = base::local({
[13:34:33.948]             c <- base::c
[13:34:33.948]             inherits <- base::inherits
[13:34:33.948]             invokeRestart <- base::invokeRestart
[13:34:33.948]             length <- base::length
[13:34:33.948]             list <- base::list
[13:34:33.948]             seq.int <- base::seq.int
[13:34:33.948]             signalCondition <- base::signalCondition
[13:34:33.948]             sys.calls <- base::sys.calls
[13:34:33.948]             `[[` <- base::`[[`
[13:34:33.948]             `+` <- base::`+`
[13:34:33.948]             `<<-` <- base::`<<-`
[13:34:33.948]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:33.948]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:33.948]                   3L)]
[13:34:33.948]             }
[13:34:33.948]             function(cond) {
[13:34:33.948]                 is_error <- inherits(cond, "error")
[13:34:33.948]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:33.948]                   NULL)
[13:34:33.948]                 if (is_error) {
[13:34:33.948]                   sessionInformation <- function() {
[13:34:33.948]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:33.948]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:33.948]                       search = base::search(), system = base::Sys.info())
[13:34:33.948]                   }
[13:34:33.948]                   ...future.conditions[[length(...future.conditions) + 
[13:34:33.948]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:33.948]                     cond$call), session = sessionInformation(), 
[13:34:33.948]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:33.948]                   signalCondition(cond)
[13:34:33.948]                 }
[13:34:33.948]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:33.948]                 "immediateCondition"))) {
[13:34:33.948]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:33.948]                   ...future.conditions[[length(...future.conditions) + 
[13:34:33.948]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:33.948]                   if (TRUE && !signal) {
[13:34:33.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:33.948]                     {
[13:34:33.948]                       inherits <- base::inherits
[13:34:33.948]                       invokeRestart <- base::invokeRestart
[13:34:33.948]                       is.null <- base::is.null
[13:34:33.948]                       muffled <- FALSE
[13:34:33.948]                       if (inherits(cond, "message")) {
[13:34:33.948]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:33.948]                         if (muffled) 
[13:34:33.948]                           invokeRestart("muffleMessage")
[13:34:33.948]                       }
[13:34:33.948]                       else if (inherits(cond, "warning")) {
[13:34:33.948]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:33.948]                         if (muffled) 
[13:34:33.948]                           invokeRestart("muffleWarning")
[13:34:33.948]                       }
[13:34:33.948]                       else if (inherits(cond, "condition")) {
[13:34:33.948]                         if (!is.null(pattern)) {
[13:34:33.948]                           computeRestarts <- base::computeRestarts
[13:34:33.948]                           grepl <- base::grepl
[13:34:33.948]                           restarts <- computeRestarts(cond)
[13:34:33.948]                           for (restart in restarts) {
[13:34:33.948]                             name <- restart$name
[13:34:33.948]                             if (is.null(name)) 
[13:34:33.948]                               next
[13:34:33.948]                             if (!grepl(pattern, name)) 
[13:34:33.948]                               next
[13:34:33.948]                             invokeRestart(restart)
[13:34:33.948]                             muffled <- TRUE
[13:34:33.948]                             break
[13:34:33.948]                           }
[13:34:33.948]                         }
[13:34:33.948]                       }
[13:34:33.948]                       invisible(muffled)
[13:34:33.948]                     }
[13:34:33.948]                     muffleCondition(cond, pattern = "^muffle")
[13:34:33.948]                   }
[13:34:33.948]                 }
[13:34:33.948]                 else {
[13:34:33.948]                   if (TRUE) {
[13:34:33.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:33.948]                     {
[13:34:33.948]                       inherits <- base::inherits
[13:34:33.948]                       invokeRestart <- base::invokeRestart
[13:34:33.948]                       is.null <- base::is.null
[13:34:33.948]                       muffled <- FALSE
[13:34:33.948]                       if (inherits(cond, "message")) {
[13:34:33.948]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:33.948]                         if (muffled) 
[13:34:33.948]                           invokeRestart("muffleMessage")
[13:34:33.948]                       }
[13:34:33.948]                       else if (inherits(cond, "warning")) {
[13:34:33.948]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:33.948]                         if (muffled) 
[13:34:33.948]                           invokeRestart("muffleWarning")
[13:34:33.948]                       }
[13:34:33.948]                       else if (inherits(cond, "condition")) {
[13:34:33.948]                         if (!is.null(pattern)) {
[13:34:33.948]                           computeRestarts <- base::computeRestarts
[13:34:33.948]                           grepl <- base::grepl
[13:34:33.948]                           restarts <- computeRestarts(cond)
[13:34:33.948]                           for (restart in restarts) {
[13:34:33.948]                             name <- restart$name
[13:34:33.948]                             if (is.null(name)) 
[13:34:33.948]                               next
[13:34:33.948]                             if (!grepl(pattern, name)) 
[13:34:33.948]                               next
[13:34:33.948]                             invokeRestart(restart)
[13:34:33.948]                             muffled <- TRUE
[13:34:33.948]                             break
[13:34:33.948]                           }
[13:34:33.948]                         }
[13:34:33.948]                       }
[13:34:33.948]                       invisible(muffled)
[13:34:33.948]                     }
[13:34:33.948]                     muffleCondition(cond, pattern = "^muffle")
[13:34:33.948]                   }
[13:34:33.948]                 }
[13:34:33.948]             }
[13:34:33.948]         }))
[13:34:33.948]     }, error = function(ex) {
[13:34:33.948]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:33.948]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:33.948]                 ...future.rng), started = ...future.startTime, 
[13:34:33.948]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:33.948]             version = "1.8"), class = "FutureResult")
[13:34:33.948]     }, finally = {
[13:34:33.948]         if (!identical(...future.workdir, getwd())) 
[13:34:33.948]             setwd(...future.workdir)
[13:34:33.948]         {
[13:34:33.948]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:33.948]                 ...future.oldOptions$nwarnings <- NULL
[13:34:33.948]             }
[13:34:33.948]             base::options(...future.oldOptions)
[13:34:33.948]             if (.Platform$OS.type == "windows") {
[13:34:33.948]                 old_names <- names(...future.oldEnvVars)
[13:34:33.948]                 envs <- base::Sys.getenv()
[13:34:33.948]                 names <- names(envs)
[13:34:33.948]                 common <- intersect(names, old_names)
[13:34:33.948]                 added <- setdiff(names, old_names)
[13:34:33.948]                 removed <- setdiff(old_names, names)
[13:34:33.948]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:33.948]                   envs[common]]
[13:34:33.948]                 NAMES <- toupper(changed)
[13:34:33.948]                 args <- list()
[13:34:33.948]                 for (kk in seq_along(NAMES)) {
[13:34:33.948]                   name <- changed[[kk]]
[13:34:33.948]                   NAME <- NAMES[[kk]]
[13:34:33.948]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:33.948]                     next
[13:34:33.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:33.948]                 }
[13:34:33.948]                 NAMES <- toupper(added)
[13:34:33.948]                 for (kk in seq_along(NAMES)) {
[13:34:33.948]                   name <- added[[kk]]
[13:34:33.948]                   NAME <- NAMES[[kk]]
[13:34:33.948]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:33.948]                     next
[13:34:33.948]                   args[[name]] <- ""
[13:34:33.948]                 }
[13:34:33.948]                 NAMES <- toupper(removed)
[13:34:33.948]                 for (kk in seq_along(NAMES)) {
[13:34:33.948]                   name <- removed[[kk]]
[13:34:33.948]                   NAME <- NAMES[[kk]]
[13:34:33.948]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:33.948]                     next
[13:34:33.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:33.948]                 }
[13:34:33.948]                 if (length(args) > 0) 
[13:34:33.948]                   base::do.call(base::Sys.setenv, args = args)
[13:34:33.948]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:33.948]             }
[13:34:33.948]             else {
[13:34:33.948]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:33.948]             }
[13:34:33.948]             {
[13:34:33.948]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:33.948]                   0L) {
[13:34:33.948]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:33.948]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:33.948]                   base::options(opts)
[13:34:33.948]                 }
[13:34:33.948]                 {
[13:34:33.948]                   {
[13:34:33.948]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:33.948]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:33.948]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:33.948]                       inherits = FALSE)
[13:34:33.948]                     NULL
[13:34:33.948]                   }
[13:34:33.948]                   options(future.plan = NULL)
[13:34:33.948]                   if (is.na(NA_character_)) 
[13:34:33.948]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:33.948]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:33.948]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:33.948]                     .init = FALSE)
[13:34:33.948]                 }
[13:34:33.948]             }
[13:34:33.948]         }
[13:34:33.948]     })
[13:34:33.948]     if (TRUE) {
[13:34:33.948]         base::sink(type = "output", split = FALSE)
[13:34:33.948]         if (TRUE) {
[13:34:33.948]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:33.948]         }
[13:34:33.948]         else {
[13:34:33.948]             ...future.result["stdout"] <- base::list(NULL)
[13:34:33.948]         }
[13:34:33.948]         base::close(...future.stdout)
[13:34:33.948]         ...future.stdout <- NULL
[13:34:33.948]     }
[13:34:33.948]     ...future.result$conditions <- ...future.conditions
[13:34:33.948]     ...future.result$finished <- base::Sys.time()
[13:34:33.948]     ...future.result
[13:34:33.948] }
[13:34:33.950] assign_globals() ...
[13:34:33.950] List of 5
[13:34:33.950]  $ ...future.FUN            :function (x, ...)  
[13:34:33.950]  $ MoreArgs                 : NULL
[13:34:33.950]  $ ...future.elements_ii    :List of 2
[13:34:33.950]   ..$ :List of 4
[13:34:33.950]   .. ..$ : int 1
[13:34:33.950]   .. ..$ : int 2
[13:34:33.950]   .. ..$ : int 3
[13:34:33.950]   .. ..$ : int 4
[13:34:33.950]   ..$ :List of 4
[13:34:33.950]   .. ..$ : int 4
[13:34:33.950]   .. ..$ : int 3
[13:34:33.950]   .. ..$ : int 2
[13:34:33.950]   .. ..$ : int 1
[13:34:33.950]  $ ...future.seeds_ii       : NULL
[13:34:33.950]  $ ...future.globals.maxSize: NULL
[13:34:33.950]  - attr(*, "where")=List of 5
[13:34:33.950]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:33.950]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:33.950]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:33.950]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:33.950]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:33.950]  - attr(*, "resolved")= logi FALSE
[13:34:33.950]  - attr(*, "total_size")= num 504
[13:34:33.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:33.950]  - attr(*, "already-done")= logi TRUE
[13:34:33.957] - copied ‘...future.FUN’ to environment
[13:34:33.958] - copied ‘MoreArgs’ to environment
[13:34:33.958] - copied ‘...future.elements_ii’ to environment
[13:34:33.958] - copied ‘...future.seeds_ii’ to environment
[13:34:33.958] - copied ‘...future.globals.maxSize’ to environment
[13:34:33.958] assign_globals() ... done
[13:34:33.958] plan(): Setting new future strategy stack:
[13:34:33.958] List of future strategies:
[13:34:33.958] 1. sequential:
[13:34:33.958]    - args: function (..., envir = parent.frame())
[13:34:33.958]    - tweaked: FALSE
[13:34:33.958]    - call: NULL
[13:34:33.959] plan(): nbrOfWorkers() = 1
[13:34:33.959] plan(): Setting new future strategy stack:
[13:34:33.959] List of future strategies:
[13:34:33.959] 1. sequential:
[13:34:33.959]    - args: function (..., envir = parent.frame())
[13:34:33.959]    - tweaked: FALSE
[13:34:33.959]    - call: plan(strategy)
[13:34:33.960] plan(): nbrOfWorkers() = 1
[13:34:33.960] SequentialFuture started (and completed)
[13:34:33.960] - Launch lazy future ... done
[13:34:33.960] run() for ‘SequentialFuture’ ... done
[13:34:33.960] Created future:
[13:34:33.960] SequentialFuture:
[13:34:33.960] Label: ‘future_mapply-1’
[13:34:33.960] Expression:
[13:34:33.960] {
[13:34:33.960]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:33.960]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:33.960]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:33.960]         on.exit(options(oopts), add = TRUE)
[13:34:33.960]     }
[13:34:33.960]     {
[13:34:33.960]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:33.960]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:33.960]         do.call(mapply, args = args)
[13:34:33.960]     }
[13:34:33.960] }
[13:34:33.960] Lazy evaluation: FALSE
[13:34:33.960] Asynchronous evaluation: FALSE
[13:34:33.960] Local evaluation: TRUE
[13:34:33.960] Environment: R_GlobalEnv
[13:34:33.960] Capture standard output: TRUE
[13:34:33.960] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:33.960] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:33.960] Packages: <none>
[13:34:33.960] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:33.960] Resolved: TRUE
[13:34:33.960] Value: 240 bytes of class ‘list’
[13:34:33.960] Early signaling: FALSE
[13:34:33.960] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:33.960] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:33.961] Chunk #1 of 1 ... DONE
[13:34:33.961] Launching 1 futures (chunks) ... DONE
[13:34:33.961] Resolving 1 futures (chunks) ...
[13:34:33.961] resolve() on list ...
[13:34:33.961]  recursive: 0
[13:34:33.961]  length: 1
[13:34:33.962] 
[13:34:33.962] resolved() for ‘SequentialFuture’ ...
[13:34:33.962] - state: ‘finished’
[13:34:33.962] - run: TRUE
[13:34:33.962] - result: ‘FutureResult’
[13:34:33.962] resolved() for ‘SequentialFuture’ ... done
[13:34:33.962] Future #1
[13:34:33.962] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:33.962] - nx: 1
[13:34:33.962] - relay: TRUE
[13:34:33.962] - stdout: TRUE
[13:34:33.963] - signal: TRUE
[13:34:33.963] - resignal: FALSE
[13:34:33.963] - force: TRUE
[13:34:33.963] - relayed: [n=1] FALSE
[13:34:33.963] - queued futures: [n=1] FALSE
[13:34:33.963]  - until=1
[13:34:33.963]  - relaying element #1
[13:34:33.963] - relayed: [n=1] TRUE
[13:34:33.963] - queued futures: [n=1] TRUE
[13:34:33.963] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:33.963]  length: 0 (resolved future 1)
[13:34:33.964] Relaying remaining futures
[13:34:33.964] signalConditionsASAP(NULL, pos=0) ...
[13:34:33.964] - nx: 1
[13:34:33.964] - relay: TRUE
[13:34:33.964] - stdout: TRUE
[13:34:33.964] - signal: TRUE
[13:34:33.964] - resignal: FALSE
[13:34:33.964] - force: TRUE
[13:34:33.964] - relayed: [n=1] TRUE
[13:34:33.964] - queued futures: [n=1] TRUE
 - flush all
[13:34:33.964] - relayed: [n=1] TRUE
[13:34:33.964] - queued futures: [n=1] TRUE
[13:34:33.965] signalConditionsASAP(NULL, pos=0) ... done
[13:34:33.965] resolve() on list ... DONE
[13:34:33.965]  - Number of value chunks collected: 1
[13:34:33.965] Resolving 1 futures (chunks) ... DONE
[13:34:33.965] Reducing values from 1 chunks ...
[13:34:33.965]  - Number of values collected after concatenation: 4
[13:34:33.965]  - Number of values expected: 4
[13:34:33.965] Reducing values from 1 chunks ... DONE
[13:34:33.965] future_mapply() ... DONE
[13:34:33.965] future_mapply() ...
[13:34:33.965] Number of chunks: 1
[13:34:33.966] getGlobalsAndPackagesXApply() ...
[13:34:33.966]  - future.globals: TRUE
[13:34:33.966] getGlobalsAndPackages() ...
[13:34:33.966] Searching for globals...
[13:34:33.966] - globals found: [1] ‘FUN’
[13:34:33.966] Searching for globals ... DONE
[13:34:33.967] Resolving globals: FALSE
[13:34:33.967] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:33.967] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:33.967] - globals: [1] ‘FUN’
[13:34:33.967] 
[13:34:33.967] getGlobalsAndPackages() ... DONE
[13:34:33.967]  - globals found/used: [n=1] ‘FUN’
[13:34:33.968]  - needed namespaces: [n=0] 
[13:34:33.968] Finding globals ... DONE
[13:34:33.968] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:33.968] List of 2
[13:34:33.968]  $ ...future.FUN:function (x, ...)  
[13:34:33.968]  $ MoreArgs     : NULL
[13:34:33.968]  - attr(*, "where")=List of 2
[13:34:33.968]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:33.968]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:33.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:33.968]  - attr(*, "resolved")= logi FALSE
[13:34:33.968]  - attr(*, "total_size")= num NA
[13:34:33.970] Packages to be attached in all futures: [n=0] 
[13:34:33.970] getGlobalsAndPackagesXApply() ... DONE
[13:34:33.970] Number of futures (= number of chunks): 1
[13:34:33.971] Launching 1 futures (chunks) ...
[13:34:33.971] Chunk #1 of 1 ...
[13:34:33.971]  - Finding globals in '...' for chunk #1 ...
[13:34:33.971] getGlobalsAndPackages() ...
[13:34:33.971] Searching for globals...
[13:34:33.971] 
[13:34:33.971] Searching for globals ... DONE
[13:34:33.971] - globals: [0] <none>
[13:34:33.971] getGlobalsAndPackages() ... DONE
[13:34:33.972]    + additional globals found: [n=0] 
[13:34:33.972]    + additional namespaces needed: [n=0] 
[13:34:33.972]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:33.972]  - seeds: <none>
[13:34:33.972]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:33.972] getGlobalsAndPackages() ...
[13:34:33.972] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:33.972] Resolving globals: FALSE
[13:34:33.973] The total size of the 5 globals is 504 bytes (504 bytes)
[13:34:33.973] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:33.973] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:33.973] 
[13:34:33.973] getGlobalsAndPackages() ... DONE
[13:34:33.974] run() for ‘Future’ ...
[13:34:33.974] - state: ‘created’
[13:34:33.974] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:33.974] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:33.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:33.974]   - Field: ‘label’
[13:34:33.974]   - Field: ‘local’
[13:34:33.974]   - Field: ‘owner’
[13:34:33.975]   - Field: ‘envir’
[13:34:33.975]   - Field: ‘packages’
[13:34:33.975]   - Field: ‘gc’
[13:34:33.975]   - Field: ‘conditions’
[13:34:33.975]   - Field: ‘expr’
[13:34:33.975]   - Field: ‘uuid’
[13:34:33.975]   - Field: ‘seed’
[13:34:33.975]   - Field: ‘version’
[13:34:33.975]   - Field: ‘result’
[13:34:33.975]   - Field: ‘asynchronous’
[13:34:33.975]   - Field: ‘calls’
[13:34:33.975]   - Field: ‘globals’
[13:34:33.976]   - Field: ‘stdout’
[13:34:33.976]   - Field: ‘earlySignal’
[13:34:33.976]   - Field: ‘lazy’
[13:34:33.976]   - Field: ‘state’
[13:34:33.976] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:33.977] - Launch lazy future ...
[13:34:33.977] Packages needed by the future expression (n = 0): <none>
[13:34:33.977] Packages needed by future strategies (n = 0): <none>
[13:34:33.978] {
[13:34:33.978]     {
[13:34:33.978]         {
[13:34:33.978]             ...future.startTime <- base::Sys.time()
[13:34:33.978]             {
[13:34:33.978]                 {
[13:34:33.978]                   {
[13:34:33.978]                     base::local({
[13:34:33.978]                       has_future <- base::requireNamespace("future", 
[13:34:33.978]                         quietly = TRUE)
[13:34:33.978]                       if (has_future) {
[13:34:33.978]                         ns <- base::getNamespace("future")
[13:34:33.978]                         version <- ns[[".package"]][["version"]]
[13:34:33.978]                         if (is.null(version)) 
[13:34:33.978]                           version <- utils::packageVersion("future")
[13:34:33.978]                       }
[13:34:33.978]                       else {
[13:34:33.978]                         version <- NULL
[13:34:33.978]                       }
[13:34:33.978]                       if (!has_future || version < "1.8.0") {
[13:34:33.978]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:33.978]                           "", base::R.version$version.string), 
[13:34:33.978]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:33.978]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:33.978]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:33.978]                             "release", "version")], collapse = " "), 
[13:34:33.978]                           hostname = base::Sys.info()[["nodename"]])
[13:34:33.978]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:33.978]                           info)
[13:34:33.978]                         info <- base::paste(info, collapse = "; ")
[13:34:33.978]                         if (!has_future) {
[13:34:33.978]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:33.978]                             info)
[13:34:33.978]                         }
[13:34:33.978]                         else {
[13:34:33.978]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:33.978]                             info, version)
[13:34:33.978]                         }
[13:34:33.978]                         base::stop(msg)
[13:34:33.978]                       }
[13:34:33.978]                     })
[13:34:33.978]                   }
[13:34:33.978]                   ...future.strategy.old <- future::plan("list")
[13:34:33.978]                   options(future.plan = NULL)
[13:34:33.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:33.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:33.978]                 }
[13:34:33.978]                 ...future.workdir <- getwd()
[13:34:33.978]             }
[13:34:33.978]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:33.978]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:33.978]         }
[13:34:33.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:33.978]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:33.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:33.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:33.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:33.978]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:33.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:33.978]             base::names(...future.oldOptions))
[13:34:33.978]     }
[13:34:33.978]     if (FALSE) {
[13:34:33.978]     }
[13:34:33.978]     else {
[13:34:33.978]         if (TRUE) {
[13:34:33.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:33.978]                 open = "w")
[13:34:33.978]         }
[13:34:33.978]         else {
[13:34:33.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:33.978]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:33.978]         }
[13:34:33.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:33.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:33.978]             base::sink(type = "output", split = FALSE)
[13:34:33.978]             base::close(...future.stdout)
[13:34:33.978]         }, add = TRUE)
[13:34:33.978]     }
[13:34:33.978]     ...future.frame <- base::sys.nframe()
[13:34:33.978]     ...future.conditions <- base::list()
[13:34:33.978]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:33.978]     if (FALSE) {
[13:34:33.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:33.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:33.978]     }
[13:34:33.978]     ...future.result <- base::tryCatch({
[13:34:33.978]         base::withCallingHandlers({
[13:34:33.978]             ...future.value <- base::withVisible(base::local({
[13:34:33.978]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:33.978]                 if (!identical(...future.globals.maxSize.org, 
[13:34:33.978]                   ...future.globals.maxSize)) {
[13:34:33.978]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:33.978]                   on.exit(options(oopts), add = TRUE)
[13:34:33.978]                 }
[13:34:33.978]                 {
[13:34:33.978]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:33.978]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:33.978]                     USE.NAMES = FALSE)
[13:34:33.978]                   do.call(mapply, args = args)
[13:34:33.978]                 }
[13:34:33.978]             }))
[13:34:33.978]             future::FutureResult(value = ...future.value$value, 
[13:34:33.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:33.978]                   ...future.rng), globalenv = if (FALSE) 
[13:34:33.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:33.978]                     ...future.globalenv.names))
[13:34:33.978]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:33.978]         }, condition = base::local({
[13:34:33.978]             c <- base::c
[13:34:33.978]             inherits <- base::inherits
[13:34:33.978]             invokeRestart <- base::invokeRestart
[13:34:33.978]             length <- base::length
[13:34:33.978]             list <- base::list
[13:34:33.978]             seq.int <- base::seq.int
[13:34:33.978]             signalCondition <- base::signalCondition
[13:34:33.978]             sys.calls <- base::sys.calls
[13:34:33.978]             `[[` <- base::`[[`
[13:34:33.978]             `+` <- base::`+`
[13:34:33.978]             `<<-` <- base::`<<-`
[13:34:33.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:33.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:33.978]                   3L)]
[13:34:33.978]             }
[13:34:33.978]             function(cond) {
[13:34:33.978]                 is_error <- inherits(cond, "error")
[13:34:33.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:33.978]                   NULL)
[13:34:33.978]                 if (is_error) {
[13:34:33.978]                   sessionInformation <- function() {
[13:34:33.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:33.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:33.978]                       search = base::search(), system = base::Sys.info())
[13:34:33.978]                   }
[13:34:33.978]                   ...future.conditions[[length(...future.conditions) + 
[13:34:33.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:33.978]                     cond$call), session = sessionInformation(), 
[13:34:33.978]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:33.978]                   signalCondition(cond)
[13:34:33.978]                 }
[13:34:33.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:33.978]                 "immediateCondition"))) {
[13:34:33.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:33.978]                   ...future.conditions[[length(...future.conditions) + 
[13:34:33.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:33.978]                   if (TRUE && !signal) {
[13:34:33.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:33.978]                     {
[13:34:33.978]                       inherits <- base::inherits
[13:34:33.978]                       invokeRestart <- base::invokeRestart
[13:34:33.978]                       is.null <- base::is.null
[13:34:33.978]                       muffled <- FALSE
[13:34:33.978]                       if (inherits(cond, "message")) {
[13:34:33.978]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:33.978]                         if (muffled) 
[13:34:33.978]                           invokeRestart("muffleMessage")
[13:34:33.978]                       }
[13:34:33.978]                       else if (inherits(cond, "warning")) {
[13:34:33.978]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:33.978]                         if (muffled) 
[13:34:33.978]                           invokeRestart("muffleWarning")
[13:34:33.978]                       }
[13:34:33.978]                       else if (inherits(cond, "condition")) {
[13:34:33.978]                         if (!is.null(pattern)) {
[13:34:33.978]                           computeRestarts <- base::computeRestarts
[13:34:33.978]                           grepl <- base::grepl
[13:34:33.978]                           restarts <- computeRestarts(cond)
[13:34:33.978]                           for (restart in restarts) {
[13:34:33.978]                             name <- restart$name
[13:34:33.978]                             if (is.null(name)) 
[13:34:33.978]                               next
[13:34:33.978]                             if (!grepl(pattern, name)) 
[13:34:33.978]                               next
[13:34:33.978]                             invokeRestart(restart)
[13:34:33.978]                             muffled <- TRUE
[13:34:33.978]                             break
[13:34:33.978]                           }
[13:34:33.978]                         }
[13:34:33.978]                       }
[13:34:33.978]                       invisible(muffled)
[13:34:33.978]                     }
[13:34:33.978]                     muffleCondition(cond, pattern = "^muffle")
[13:34:33.978]                   }
[13:34:33.978]                 }
[13:34:33.978]                 else {
[13:34:33.978]                   if (TRUE) {
[13:34:33.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:33.978]                     {
[13:34:33.978]                       inherits <- base::inherits
[13:34:33.978]                       invokeRestart <- base::invokeRestart
[13:34:33.978]                       is.null <- base::is.null
[13:34:33.978]                       muffled <- FALSE
[13:34:33.978]                       if (inherits(cond, "message")) {
[13:34:33.978]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:33.978]                         if (muffled) 
[13:34:33.978]                           invokeRestart("muffleMessage")
[13:34:33.978]                       }
[13:34:33.978]                       else if (inherits(cond, "warning")) {
[13:34:33.978]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:33.978]                         if (muffled) 
[13:34:33.978]                           invokeRestart("muffleWarning")
[13:34:33.978]                       }
[13:34:33.978]                       else if (inherits(cond, "condition")) {
[13:34:33.978]                         if (!is.null(pattern)) {
[13:34:33.978]                           computeRestarts <- base::computeRestarts
[13:34:33.978]                           grepl <- base::grepl
[13:34:33.978]                           restarts <- computeRestarts(cond)
[13:34:33.978]                           for (restart in restarts) {
[13:34:33.978]                             name <- restart$name
[13:34:33.978]                             if (is.null(name)) 
[13:34:33.978]                               next
[13:34:33.978]                             if (!grepl(pattern, name)) 
[13:34:33.978]                               next
[13:34:33.978]                             invokeRestart(restart)
[13:34:33.978]                             muffled <- TRUE
[13:34:33.978]                             break
[13:34:33.978]                           }
[13:34:33.978]                         }
[13:34:33.978]                       }
[13:34:33.978]                       invisible(muffled)
[13:34:33.978]                     }
[13:34:33.978]                     muffleCondition(cond, pattern = "^muffle")
[13:34:33.978]                   }
[13:34:33.978]                 }
[13:34:33.978]             }
[13:34:33.978]         }))
[13:34:33.978]     }, error = function(ex) {
[13:34:33.978]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:33.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:33.978]                 ...future.rng), started = ...future.startTime, 
[13:34:33.978]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:33.978]             version = "1.8"), class = "FutureResult")
[13:34:33.978]     }, finally = {
[13:34:33.978]         if (!identical(...future.workdir, getwd())) 
[13:34:33.978]             setwd(...future.workdir)
[13:34:33.978]         {
[13:34:33.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:33.978]                 ...future.oldOptions$nwarnings <- NULL
[13:34:33.978]             }
[13:34:33.978]             base::options(...future.oldOptions)
[13:34:33.978]             if (.Platform$OS.type == "windows") {
[13:34:33.978]                 old_names <- names(...future.oldEnvVars)
[13:34:33.978]                 envs <- base::Sys.getenv()
[13:34:33.978]                 names <- names(envs)
[13:34:33.978]                 common <- intersect(names, old_names)
[13:34:33.978]                 added <- setdiff(names, old_names)
[13:34:33.978]                 removed <- setdiff(old_names, names)
[13:34:33.978]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:33.978]                   envs[common]]
[13:34:33.978]                 NAMES <- toupper(changed)
[13:34:33.978]                 args <- list()
[13:34:33.978]                 for (kk in seq_along(NAMES)) {
[13:34:33.978]                   name <- changed[[kk]]
[13:34:33.978]                   NAME <- NAMES[[kk]]
[13:34:33.978]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:33.978]                     next
[13:34:33.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:33.978]                 }
[13:34:33.978]                 NAMES <- toupper(added)
[13:34:33.978]                 for (kk in seq_along(NAMES)) {
[13:34:33.978]                   name <- added[[kk]]
[13:34:33.978]                   NAME <- NAMES[[kk]]
[13:34:33.978]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:33.978]                     next
[13:34:33.978]                   args[[name]] <- ""
[13:34:33.978]                 }
[13:34:33.978]                 NAMES <- toupper(removed)
[13:34:33.978]                 for (kk in seq_along(NAMES)) {
[13:34:33.978]                   name <- removed[[kk]]
[13:34:33.978]                   NAME <- NAMES[[kk]]
[13:34:33.978]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:33.978]                     next
[13:34:33.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:33.978]                 }
[13:34:33.978]                 if (length(args) > 0) 
[13:34:33.978]                   base::do.call(base::Sys.setenv, args = args)
[13:34:33.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:33.978]             }
[13:34:33.978]             else {
[13:34:33.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:33.978]             }
[13:34:33.978]             {
[13:34:33.978]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:33.978]                   0L) {
[13:34:33.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:33.978]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:33.978]                   base::options(opts)
[13:34:33.978]                 }
[13:34:33.978]                 {
[13:34:33.978]                   {
[13:34:33.978]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:33.978]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:33.978]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:33.978]                       inherits = FALSE)
[13:34:33.978]                     NULL
[13:34:33.978]                   }
[13:34:33.978]                   options(future.plan = NULL)
[13:34:33.978]                   if (is.na(NA_character_)) 
[13:34:33.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:33.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:33.978]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:33.978]                     .init = FALSE)
[13:34:33.978]                 }
[13:34:33.978]             }
[13:34:33.978]         }
[13:34:33.978]     })
[13:34:33.978]     if (TRUE) {
[13:34:33.978]         base::sink(type = "output", split = FALSE)
[13:34:33.978]         if (TRUE) {
[13:34:33.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:33.978]         }
[13:34:33.978]         else {
[13:34:33.978]             ...future.result["stdout"] <- base::list(NULL)
[13:34:33.978]         }
[13:34:33.978]         base::close(...future.stdout)
[13:34:33.978]         ...future.stdout <- NULL
[13:34:33.978]     }
[13:34:33.978]     ...future.result$conditions <- ...future.conditions
[13:34:33.978]     ...future.result$finished <- base::Sys.time()
[13:34:33.978]     ...future.result
[13:34:33.978] }
[13:34:33.979] assign_globals() ...
[13:34:33.979] List of 5
[13:34:33.979]  $ ...future.FUN            :function (x, ...)  
[13:34:33.979]  $ MoreArgs                 : NULL
[13:34:33.979]  $ ...future.elements_ii    :List of 2
[13:34:33.979]   ..$ :List of 4
[13:34:33.979]   .. ..$ : int 1
[13:34:33.979]   .. ..$ : int 2
[13:34:33.979]   .. ..$ : int 3
[13:34:33.979]   .. ..$ : int 4
[13:34:33.979]   ..$ :List of 4
[13:34:33.979]   .. ..$ : int 4
[13:34:33.979]   .. ..$ : int 3
[13:34:33.979]   .. ..$ : int 2
[13:34:33.979]   .. ..$ : int 1
[13:34:33.979]  $ ...future.seeds_ii       : NULL
[13:34:33.979]  $ ...future.globals.maxSize: NULL
[13:34:33.979]  - attr(*, "where")=List of 5
[13:34:33.979]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:33.979]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:33.979]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:33.979]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:33.979]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:33.979]  - attr(*, "resolved")= logi FALSE
[13:34:33.979]  - attr(*, "total_size")= num 504
[13:34:33.979]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:33.979]  - attr(*, "already-done")= logi TRUE
[13:34:33.985] - copied ‘...future.FUN’ to environment
[13:34:33.986] - copied ‘MoreArgs’ to environment
[13:34:33.986] - copied ‘...future.elements_ii’ to environment
[13:34:33.986] - copied ‘...future.seeds_ii’ to environment
[13:34:33.986] - copied ‘...future.globals.maxSize’ to environment
[13:34:33.986] assign_globals() ... done
[13:34:33.986] plan(): Setting new future strategy stack:
[13:34:33.986] List of future strategies:
[13:34:33.986] 1. sequential:
[13:34:33.986]    - args: function (..., envir = parent.frame())
[13:34:33.986]    - tweaked: FALSE
[13:34:33.986]    - call: NULL
[13:34:33.987] plan(): nbrOfWorkers() = 1
[13:34:33.988] plan(): Setting new future strategy stack:
[13:34:33.988] List of future strategies:
[13:34:33.988] 1. sequential:
[13:34:33.988]    - args: function (..., envir = parent.frame())
[13:34:33.988]    - tweaked: FALSE
[13:34:33.988]    - call: plan(strategy)
[13:34:33.988] plan(): nbrOfWorkers() = 1
[13:34:33.988] SequentialFuture started (and completed)
[13:34:33.988] - Launch lazy future ... done
[13:34:33.988] run() for ‘SequentialFuture’ ... done
[13:34:33.988] Created future:
[13:34:33.989] SequentialFuture:
[13:34:33.989] Label: ‘future_mapply-1’
[13:34:33.989] Expression:
[13:34:33.989] {
[13:34:33.989]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:33.989]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:33.989]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:33.989]         on.exit(options(oopts), add = TRUE)
[13:34:33.989]     }
[13:34:33.989]     {
[13:34:33.989]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:33.989]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:33.989]         do.call(mapply, args = args)
[13:34:33.989]     }
[13:34:33.989] }
[13:34:33.989] Lazy evaluation: FALSE
[13:34:33.989] Asynchronous evaluation: FALSE
[13:34:33.989] Local evaluation: TRUE
[13:34:33.989] Environment: R_GlobalEnv
[13:34:33.989] Capture standard output: TRUE
[13:34:33.989] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:33.989] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:33.989] Packages: <none>
[13:34:33.989] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:33.989] Resolved: TRUE
[13:34:33.989] Value: 240 bytes of class ‘list’
[13:34:33.989] Early signaling: FALSE
[13:34:33.989] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:33.989] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:33.989] Chunk #1 of 1 ... DONE
[13:34:33.989] Launching 1 futures (chunks) ... DONE
[13:34:33.989] Resolving 1 futures (chunks) ...
[13:34:33.990] resolve() on list ...
[13:34:33.990]  recursive: 0
[13:34:33.990]  length: 1
[13:34:33.990] 
[13:34:33.990] resolved() for ‘SequentialFuture’ ...
[13:34:33.990] - state: ‘finished’
[13:34:33.990] - run: TRUE
[13:34:33.990] - result: ‘FutureResult’
[13:34:33.990] resolved() for ‘SequentialFuture’ ... done
[13:34:33.990] Future #1
[13:34:33.991] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:33.991] - nx: 1
[13:34:33.991] - relay: TRUE
[13:34:33.991] - stdout: TRUE
[13:34:33.991] - signal: TRUE
[13:34:33.991] - resignal: FALSE
[13:34:33.991] - force: TRUE
[13:34:33.991] - relayed: [n=1] FALSE
[13:34:33.991] - queued futures: [n=1] FALSE
[13:34:33.991]  - until=1
[13:34:33.991]  - relaying element #1
[13:34:33.992] - relayed: [n=1] TRUE
[13:34:33.992] - queued futures: [n=1] TRUE
[13:34:33.992] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:33.992]  length: 0 (resolved future 1)
[13:34:33.992] Relaying remaining futures
[13:34:33.992] signalConditionsASAP(NULL, pos=0) ...
[13:34:33.992] - nx: 1
[13:34:33.992] - relay: TRUE
[13:34:33.992] - stdout: TRUE
[13:34:33.992] - signal: TRUE
[13:34:33.992] - resignal: FALSE
[13:34:33.992] - force: TRUE
[13:34:33.993] - relayed: [n=1] TRUE
[13:34:33.993] - queued futures: [n=1] TRUE
 - flush all
[13:34:33.993] - relayed: [n=1] TRUE
[13:34:33.993] - queued futures: [n=1] TRUE
[13:34:33.993] signalConditionsASAP(NULL, pos=0) ... done
[13:34:33.993] resolve() on list ... DONE
[13:34:33.993]  - Number of value chunks collected: 1
[13:34:33.993] Resolving 1 futures (chunks) ... DONE
[13:34:33.993] Reducing values from 1 chunks ...
[13:34:33.993]  - Number of values collected after concatenation: 4
[13:34:33.993]  - Number of values expected: 4
[13:34:33.994] Reducing values from 1 chunks ... DONE
[13:34:33.994] future_mapply() ... DONE
[13:34:33.994] future_mapply() ...
[13:34:33.994] Number of chunks: 1
[13:34:33.994] getGlobalsAndPackagesXApply() ...
[13:34:33.994]  - future.globals: TRUE
[13:34:33.994] getGlobalsAndPackages() ...
[13:34:33.994] Searching for globals...
[13:34:33.995] - globals found: [1] ‘FUN’
[13:34:33.995] Searching for globals ... DONE
[13:34:33.995] Resolving globals: FALSE
[13:34:33.995] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:33.996] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:33.996] - globals: [1] ‘FUN’
[13:34:33.996] 
[13:34:33.996] getGlobalsAndPackages() ... DONE
[13:34:33.996]  - globals found/used: [n=1] ‘FUN’
[13:34:33.996]  - needed namespaces: [n=0] 
[13:34:33.996] Finding globals ... DONE
[13:34:33.996] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:33.996] List of 2
[13:34:33.996]  $ ...future.FUN:function (x, ...)  
[13:34:33.996]  $ MoreArgs     : NULL
[13:34:33.996]  - attr(*, "where")=List of 2
[13:34:33.996]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:33.996]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:33.996]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:33.996]  - attr(*, "resolved")= logi FALSE
[13:34:33.996]  - attr(*, "total_size")= num NA
[13:34:33.999] Packages to be attached in all futures: [n=0] 
[13:34:33.999] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.000] Number of futures (= number of chunks): 1
[13:34:34.000] Launching 1 futures (chunks) ...
[13:34:34.000] Chunk #1 of 1 ...
[13:34:34.000]  - Finding globals in '...' for chunk #1 ...
[13:34:34.000] getGlobalsAndPackages() ...
[13:34:34.000] Searching for globals...
[13:34:34.001] 
[13:34:34.001] Searching for globals ... DONE
[13:34:34.001] - globals: [0] <none>
[13:34:34.001] getGlobalsAndPackages() ... DONE
[13:34:34.001]    + additional globals found: [n=0] 
[13:34:34.001]    + additional namespaces needed: [n=0] 
[13:34:34.001]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.001]  - seeds: <none>
[13:34:34.001]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.002] getGlobalsAndPackages() ...
[13:34:34.002] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.002] Resolving globals: FALSE
[13:34:34.002] The total size of the 5 globals is 504 bytes (504 bytes)
[13:34:34.003] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.003] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.003] 
[13:34:34.003] getGlobalsAndPackages() ... DONE
[13:34:34.003] run() for ‘Future’ ...
[13:34:34.003] - state: ‘created’
[13:34:34.003] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.004] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.004] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.004]   - Field: ‘label’
[13:34:34.004]   - Field: ‘local’
[13:34:34.004]   - Field: ‘owner’
[13:34:34.004]   - Field: ‘envir’
[13:34:34.004]   - Field: ‘packages’
[13:34:34.004]   - Field: ‘gc’
[13:34:34.004]   - Field: ‘conditions’
[13:34:34.004]   - Field: ‘expr’
[13:34:34.004]   - Field: ‘uuid’
[13:34:34.005]   - Field: ‘seed’
[13:34:34.005]   - Field: ‘version’
[13:34:34.005]   - Field: ‘result’
[13:34:34.005]   - Field: ‘asynchronous’
[13:34:34.005]   - Field: ‘calls’
[13:34:34.005]   - Field: ‘globals’
[13:34:34.005]   - Field: ‘stdout’
[13:34:34.005]   - Field: ‘earlySignal’
[13:34:34.005]   - Field: ‘lazy’
[13:34:34.005]   - Field: ‘state’
[13:34:34.005] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.006] - Launch lazy future ...
[13:34:34.006] Packages needed by the future expression (n = 0): <none>
[13:34:34.006] Packages needed by future strategies (n = 0): <none>
[13:34:34.006] {
[13:34:34.006]     {
[13:34:34.006]         {
[13:34:34.006]             ...future.startTime <- base::Sys.time()
[13:34:34.006]             {
[13:34:34.006]                 {
[13:34:34.006]                   {
[13:34:34.006]                     base::local({
[13:34:34.006]                       has_future <- base::requireNamespace("future", 
[13:34:34.006]                         quietly = TRUE)
[13:34:34.006]                       if (has_future) {
[13:34:34.006]                         ns <- base::getNamespace("future")
[13:34:34.006]                         version <- ns[[".package"]][["version"]]
[13:34:34.006]                         if (is.null(version)) 
[13:34:34.006]                           version <- utils::packageVersion("future")
[13:34:34.006]                       }
[13:34:34.006]                       else {
[13:34:34.006]                         version <- NULL
[13:34:34.006]                       }
[13:34:34.006]                       if (!has_future || version < "1.8.0") {
[13:34:34.006]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.006]                           "", base::R.version$version.string), 
[13:34:34.006]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.006]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.006]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.006]                             "release", "version")], collapse = " "), 
[13:34:34.006]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.006]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.006]                           info)
[13:34:34.006]                         info <- base::paste(info, collapse = "; ")
[13:34:34.006]                         if (!has_future) {
[13:34:34.006]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.006]                             info)
[13:34:34.006]                         }
[13:34:34.006]                         else {
[13:34:34.006]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.006]                             info, version)
[13:34:34.006]                         }
[13:34:34.006]                         base::stop(msg)
[13:34:34.006]                       }
[13:34:34.006]                     })
[13:34:34.006]                   }
[13:34:34.006]                   ...future.strategy.old <- future::plan("list")
[13:34:34.006]                   options(future.plan = NULL)
[13:34:34.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.006]                 }
[13:34:34.006]                 ...future.workdir <- getwd()
[13:34:34.006]             }
[13:34:34.006]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.006]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.006]         }
[13:34:34.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.006]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.006]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.006]             base::names(...future.oldOptions))
[13:34:34.006]     }
[13:34:34.006]     if (FALSE) {
[13:34:34.006]     }
[13:34:34.006]     else {
[13:34:34.006]         if (TRUE) {
[13:34:34.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.006]                 open = "w")
[13:34:34.006]         }
[13:34:34.006]         else {
[13:34:34.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.006]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.006]         }
[13:34:34.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.006]             base::sink(type = "output", split = FALSE)
[13:34:34.006]             base::close(...future.stdout)
[13:34:34.006]         }, add = TRUE)
[13:34:34.006]     }
[13:34:34.006]     ...future.frame <- base::sys.nframe()
[13:34:34.006]     ...future.conditions <- base::list()
[13:34:34.006]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.006]     if (FALSE) {
[13:34:34.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.006]     }
[13:34:34.006]     ...future.result <- base::tryCatch({
[13:34:34.006]         base::withCallingHandlers({
[13:34:34.006]             ...future.value <- base::withVisible(base::local({
[13:34:34.006]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.006]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.006]                   ...future.globals.maxSize)) {
[13:34:34.006]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.006]                   on.exit(options(oopts), add = TRUE)
[13:34:34.006]                 }
[13:34:34.006]                 {
[13:34:34.006]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.006]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.006]                     USE.NAMES = FALSE)
[13:34:34.006]                   do.call(mapply, args = args)
[13:34:34.006]                 }
[13:34:34.006]             }))
[13:34:34.006]             future::FutureResult(value = ...future.value$value, 
[13:34:34.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.006]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.006]                     ...future.globalenv.names))
[13:34:34.006]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.006]         }, condition = base::local({
[13:34:34.006]             c <- base::c
[13:34:34.006]             inherits <- base::inherits
[13:34:34.006]             invokeRestart <- base::invokeRestart
[13:34:34.006]             length <- base::length
[13:34:34.006]             list <- base::list
[13:34:34.006]             seq.int <- base::seq.int
[13:34:34.006]             signalCondition <- base::signalCondition
[13:34:34.006]             sys.calls <- base::sys.calls
[13:34:34.006]             `[[` <- base::`[[`
[13:34:34.006]             `+` <- base::`+`
[13:34:34.006]             `<<-` <- base::`<<-`
[13:34:34.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.006]                   3L)]
[13:34:34.006]             }
[13:34:34.006]             function(cond) {
[13:34:34.006]                 is_error <- inherits(cond, "error")
[13:34:34.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.006]                   NULL)
[13:34:34.006]                 if (is_error) {
[13:34:34.006]                   sessionInformation <- function() {
[13:34:34.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.006]                       search = base::search(), system = base::Sys.info())
[13:34:34.006]                   }
[13:34:34.006]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.006]                     cond$call), session = sessionInformation(), 
[13:34:34.006]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.006]                   signalCondition(cond)
[13:34:34.006]                 }
[13:34:34.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.006]                 "immediateCondition"))) {
[13:34:34.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.006]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.006]                   if (TRUE && !signal) {
[13:34:34.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.006]                     {
[13:34:34.006]                       inherits <- base::inherits
[13:34:34.006]                       invokeRestart <- base::invokeRestart
[13:34:34.006]                       is.null <- base::is.null
[13:34:34.006]                       muffled <- FALSE
[13:34:34.006]                       if (inherits(cond, "message")) {
[13:34:34.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.006]                         if (muffled) 
[13:34:34.006]                           invokeRestart("muffleMessage")
[13:34:34.006]                       }
[13:34:34.006]                       else if (inherits(cond, "warning")) {
[13:34:34.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.006]                         if (muffled) 
[13:34:34.006]                           invokeRestart("muffleWarning")
[13:34:34.006]                       }
[13:34:34.006]                       else if (inherits(cond, "condition")) {
[13:34:34.006]                         if (!is.null(pattern)) {
[13:34:34.006]                           computeRestarts <- base::computeRestarts
[13:34:34.006]                           grepl <- base::grepl
[13:34:34.006]                           restarts <- computeRestarts(cond)
[13:34:34.006]                           for (restart in restarts) {
[13:34:34.006]                             name <- restart$name
[13:34:34.006]                             if (is.null(name)) 
[13:34:34.006]                               next
[13:34:34.006]                             if (!grepl(pattern, name)) 
[13:34:34.006]                               next
[13:34:34.006]                             invokeRestart(restart)
[13:34:34.006]                             muffled <- TRUE
[13:34:34.006]                             break
[13:34:34.006]                           }
[13:34:34.006]                         }
[13:34:34.006]                       }
[13:34:34.006]                       invisible(muffled)
[13:34:34.006]                     }
[13:34:34.006]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.006]                   }
[13:34:34.006]                 }
[13:34:34.006]                 else {
[13:34:34.006]                   if (TRUE) {
[13:34:34.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.006]                     {
[13:34:34.006]                       inherits <- base::inherits
[13:34:34.006]                       invokeRestart <- base::invokeRestart
[13:34:34.006]                       is.null <- base::is.null
[13:34:34.006]                       muffled <- FALSE
[13:34:34.006]                       if (inherits(cond, "message")) {
[13:34:34.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.006]                         if (muffled) 
[13:34:34.006]                           invokeRestart("muffleMessage")
[13:34:34.006]                       }
[13:34:34.006]                       else if (inherits(cond, "warning")) {
[13:34:34.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.006]                         if (muffled) 
[13:34:34.006]                           invokeRestart("muffleWarning")
[13:34:34.006]                       }
[13:34:34.006]                       else if (inherits(cond, "condition")) {
[13:34:34.006]                         if (!is.null(pattern)) {
[13:34:34.006]                           computeRestarts <- base::computeRestarts
[13:34:34.006]                           grepl <- base::grepl
[13:34:34.006]                           restarts <- computeRestarts(cond)
[13:34:34.006]                           for (restart in restarts) {
[13:34:34.006]                             name <- restart$name
[13:34:34.006]                             if (is.null(name)) 
[13:34:34.006]                               next
[13:34:34.006]                             if (!grepl(pattern, name)) 
[13:34:34.006]                               next
[13:34:34.006]                             invokeRestart(restart)
[13:34:34.006]                             muffled <- TRUE
[13:34:34.006]                             break
[13:34:34.006]                           }
[13:34:34.006]                         }
[13:34:34.006]                       }
[13:34:34.006]                       invisible(muffled)
[13:34:34.006]                     }
[13:34:34.006]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.006]                   }
[13:34:34.006]                 }
[13:34:34.006]             }
[13:34:34.006]         }))
[13:34:34.006]     }, error = function(ex) {
[13:34:34.006]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.006]                 ...future.rng), started = ...future.startTime, 
[13:34:34.006]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.006]             version = "1.8"), class = "FutureResult")
[13:34:34.006]     }, finally = {
[13:34:34.006]         if (!identical(...future.workdir, getwd())) 
[13:34:34.006]             setwd(...future.workdir)
[13:34:34.006]         {
[13:34:34.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.006]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.006]             }
[13:34:34.006]             base::options(...future.oldOptions)
[13:34:34.006]             if (.Platform$OS.type == "windows") {
[13:34:34.006]                 old_names <- names(...future.oldEnvVars)
[13:34:34.006]                 envs <- base::Sys.getenv()
[13:34:34.006]                 names <- names(envs)
[13:34:34.006]                 common <- intersect(names, old_names)
[13:34:34.006]                 added <- setdiff(names, old_names)
[13:34:34.006]                 removed <- setdiff(old_names, names)
[13:34:34.006]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.006]                   envs[common]]
[13:34:34.006]                 NAMES <- toupper(changed)
[13:34:34.006]                 args <- list()
[13:34:34.006]                 for (kk in seq_along(NAMES)) {
[13:34:34.006]                   name <- changed[[kk]]
[13:34:34.006]                   NAME <- NAMES[[kk]]
[13:34:34.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.006]                     next
[13:34:34.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.006]                 }
[13:34:34.006]                 NAMES <- toupper(added)
[13:34:34.006]                 for (kk in seq_along(NAMES)) {
[13:34:34.006]                   name <- added[[kk]]
[13:34:34.006]                   NAME <- NAMES[[kk]]
[13:34:34.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.006]                     next
[13:34:34.006]                   args[[name]] <- ""
[13:34:34.006]                 }
[13:34:34.006]                 NAMES <- toupper(removed)
[13:34:34.006]                 for (kk in seq_along(NAMES)) {
[13:34:34.006]                   name <- removed[[kk]]
[13:34:34.006]                   NAME <- NAMES[[kk]]
[13:34:34.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.006]                     next
[13:34:34.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.006]                 }
[13:34:34.006]                 if (length(args) > 0) 
[13:34:34.006]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.006]             }
[13:34:34.006]             else {
[13:34:34.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.006]             }
[13:34:34.006]             {
[13:34:34.006]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.006]                   0L) {
[13:34:34.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.006]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.006]                   base::options(opts)
[13:34:34.006]                 }
[13:34:34.006]                 {
[13:34:34.006]                   {
[13:34:34.006]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.006]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.006]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.006]                       inherits = FALSE)
[13:34:34.006]                     NULL
[13:34:34.006]                   }
[13:34:34.006]                   options(future.plan = NULL)
[13:34:34.006]                   if (is.na(NA_character_)) 
[13:34:34.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.006]                     .init = FALSE)
[13:34:34.006]                 }
[13:34:34.006]             }
[13:34:34.006]         }
[13:34:34.006]     })
[13:34:34.006]     if (TRUE) {
[13:34:34.006]         base::sink(type = "output", split = FALSE)
[13:34:34.006]         if (TRUE) {
[13:34:34.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.006]         }
[13:34:34.006]         else {
[13:34:34.006]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.006]         }
[13:34:34.006]         base::close(...future.stdout)
[13:34:34.006]         ...future.stdout <- NULL
[13:34:34.006]     }
[13:34:34.006]     ...future.result$conditions <- ...future.conditions
[13:34:34.006]     ...future.result$finished <- base::Sys.time()
[13:34:34.006]     ...future.result
[13:34:34.006] }
[13:34:34.008] assign_globals() ...
[13:34:34.008] List of 5
[13:34:34.008]  $ ...future.FUN            :function (x, ...)  
[13:34:34.008]  $ MoreArgs                 : NULL
[13:34:34.008]  $ ...future.elements_ii    :List of 2
[13:34:34.008]   ..$ times:List of 4
[13:34:34.008]   .. ..$ : int 1
[13:34:34.008]   .. ..$ : int 2
[13:34:34.008]   .. ..$ : int 3
[13:34:34.008]   .. ..$ : int 4
[13:34:34.008]   ..$ x    :List of 4
[13:34:34.008]   .. ..$ : int 4
[13:34:34.008]   .. ..$ : int 3
[13:34:34.008]   .. ..$ : int 2
[13:34:34.008]   .. ..$ : int 1
[13:34:34.008]  $ ...future.seeds_ii       : NULL
[13:34:34.008]  $ ...future.globals.maxSize: NULL
[13:34:34.008]  - attr(*, "where")=List of 5
[13:34:34.008]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.008]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.008]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.008]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.008]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.008]  - attr(*, "resolved")= logi FALSE
[13:34:34.008]  - attr(*, "total_size")= num 504
[13:34:34.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.008]  - attr(*, "already-done")= logi TRUE
[13:34:34.014] - copied ‘...future.FUN’ to environment
[13:34:34.014] - copied ‘MoreArgs’ to environment
[13:34:34.014] - copied ‘...future.elements_ii’ to environment
[13:34:34.014] - copied ‘...future.seeds_ii’ to environment
[13:34:34.014] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.014] assign_globals() ... done
[13:34:34.015] plan(): Setting new future strategy stack:
[13:34:34.015] List of future strategies:
[13:34:34.015] 1. sequential:
[13:34:34.015]    - args: function (..., envir = parent.frame())
[13:34:34.015]    - tweaked: FALSE
[13:34:34.015]    - call: NULL
[13:34:34.015] plan(): nbrOfWorkers() = 1
[13:34:34.016] plan(): Setting new future strategy stack:
[13:34:34.016] List of future strategies:
[13:34:34.016] 1. sequential:
[13:34:34.016]    - args: function (..., envir = parent.frame())
[13:34:34.016]    - tweaked: FALSE
[13:34:34.016]    - call: plan(strategy)
[13:34:34.016] plan(): nbrOfWorkers() = 1
[13:34:34.016] SequentialFuture started (and completed)
[13:34:34.016] - Launch lazy future ... done
[13:34:34.016] run() for ‘SequentialFuture’ ... done
[13:34:34.017] Created future:
[13:34:34.017] SequentialFuture:
[13:34:34.017] Label: ‘future_mapply-1’
[13:34:34.017] Expression:
[13:34:34.017] {
[13:34:34.017]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.017]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.017]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.017]         on.exit(options(oopts), add = TRUE)
[13:34:34.017]     }
[13:34:34.017]     {
[13:34:34.017]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.017]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.017]         do.call(mapply, args = args)
[13:34:34.017]     }
[13:34:34.017] }
[13:34:34.017] Lazy evaluation: FALSE
[13:34:34.017] Asynchronous evaluation: FALSE
[13:34:34.017] Local evaluation: TRUE
[13:34:34.017] Environment: R_GlobalEnv
[13:34:34.017] Capture standard output: TRUE
[13:34:34.017] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.017] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.017] Packages: <none>
[13:34:34.017] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.017] Resolved: TRUE
[13:34:34.017] Value: 240 bytes of class ‘list’
[13:34:34.017] Early signaling: FALSE
[13:34:34.017] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.017] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.017] Chunk #1 of 1 ... DONE
[13:34:34.018] Launching 1 futures (chunks) ... DONE
[13:34:34.018] Resolving 1 futures (chunks) ...
[13:34:34.018] resolve() on list ...
[13:34:34.018]  recursive: 0
[13:34:34.018]  length: 1
[13:34:34.018] 
[13:34:34.018] resolved() for ‘SequentialFuture’ ...
[13:34:34.018] - state: ‘finished’
[13:34:34.018] - run: TRUE
[13:34:34.018] - result: ‘FutureResult’
[13:34:34.018] resolved() for ‘SequentialFuture’ ... done
[13:34:34.019] Future #1
[13:34:34.019] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.019] - nx: 1
[13:34:34.019] - relay: TRUE
[13:34:34.019] - stdout: TRUE
[13:34:34.019] - signal: TRUE
[13:34:34.019] - resignal: FALSE
[13:34:34.019] - force: TRUE
[13:34:34.019] - relayed: [n=1] FALSE
[13:34:34.019] - queued futures: [n=1] FALSE
[13:34:34.019]  - until=1
[13:34:34.019]  - relaying element #1
[13:34:34.020] - relayed: [n=1] TRUE
[13:34:34.020] - queued futures: [n=1] TRUE
[13:34:34.020] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.020]  length: 0 (resolved future 1)
[13:34:34.020] Relaying remaining futures
[13:34:34.020] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.020] - nx: 1
[13:34:34.020] - relay: TRUE
[13:34:34.020] - stdout: TRUE
[13:34:34.020] - signal: TRUE
[13:34:34.020] - resignal: FALSE
[13:34:34.021] - force: TRUE
[13:34:34.021] - relayed: [n=1] TRUE
[13:34:34.021] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.021] - relayed: [n=1] TRUE
[13:34:34.021] - queued futures: [n=1] TRUE
[13:34:34.021] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.021] resolve() on list ... DONE
[13:34:34.021]  - Number of value chunks collected: 1
[13:34:34.022] Resolving 1 futures (chunks) ... DONE
[13:34:34.022] Reducing values from 1 chunks ...
[13:34:34.022]  - Number of values collected after concatenation: 4
[13:34:34.022]  - Number of values expected: 4
[13:34:34.023] Reducing values from 1 chunks ... DONE
[13:34:34.023] future_mapply() ... DONE
[13:34:34.023] future_mapply() ...
[13:34:34.023] Number of chunks: 1
[13:34:34.023] getGlobalsAndPackagesXApply() ...
[13:34:34.023]  - future.globals: TRUE
[13:34:34.023] getGlobalsAndPackages() ...
[13:34:34.023] Searching for globals...
[13:34:34.024] - globals found: [1] ‘FUN’
[13:34:34.024] Searching for globals ... DONE
[13:34:34.024] Resolving globals: FALSE
[13:34:34.024] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:34.025] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:34.025] - globals: [1] ‘FUN’
[13:34:34.025] 
[13:34:34.025] getGlobalsAndPackages() ... DONE
[13:34:34.025]  - globals found/used: [n=1] ‘FUN’
[13:34:34.025]  - needed namespaces: [n=0] 
[13:34:34.025] Finding globals ... DONE
[13:34:34.025] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.025] List of 2
[13:34:34.025]  $ ...future.FUN:function (x, ...)  
[13:34:34.025]  $ MoreArgs     :List of 1
[13:34:34.025]   ..$ x: num 42
[13:34:34.025]  - attr(*, "where")=List of 2
[13:34:34.025]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.025]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.025]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.025]  - attr(*, "resolved")= logi FALSE
[13:34:34.025]  - attr(*, "total_size")= num NA
[13:34:34.028] Packages to be attached in all futures: [n=0] 
[13:34:34.028] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.028] Number of futures (= number of chunks): 1
[13:34:34.028] Launching 1 futures (chunks) ...
[13:34:34.029] Chunk #1 of 1 ...
[13:34:34.029]  - Finding globals in '...' for chunk #1 ...
[13:34:34.029] getGlobalsAndPackages() ...
[13:34:34.029] Searching for globals...
[13:34:34.029] 
[13:34:34.029] Searching for globals ... DONE
[13:34:34.029] - globals: [0] <none>
[13:34:34.029] getGlobalsAndPackages() ... DONE
[13:34:34.029]    + additional globals found: [n=0] 
[13:34:34.030]    + additional namespaces needed: [n=0] 
[13:34:34.030]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.030]  - seeds: <none>
[13:34:34.030]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.030] getGlobalsAndPackages() ...
[13:34:34.030] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.030] Resolving globals: FALSE
[13:34:34.030] The total size of the 5 globals is 336 bytes (336 bytes)
[13:34:34.031] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 336 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[13:34:34.031] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.031] 
[13:34:34.031] getGlobalsAndPackages() ... DONE
[13:34:34.031] run() for ‘Future’ ...
[13:34:34.032] - state: ‘created’
[13:34:34.032] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.032] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.032] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.032]   - Field: ‘label’
[13:34:34.032]   - Field: ‘local’
[13:34:34.032]   - Field: ‘owner’
[13:34:34.032]   - Field: ‘envir’
[13:34:34.032]   - Field: ‘packages’
[13:34:34.033]   - Field: ‘gc’
[13:34:34.033]   - Field: ‘conditions’
[13:34:34.033]   - Field: ‘expr’
[13:34:34.033]   - Field: ‘uuid’
[13:34:34.033]   - Field: ‘seed’
[13:34:34.033]   - Field: ‘version’
[13:34:34.033]   - Field: ‘result’
[13:34:34.033]   - Field: ‘asynchronous’
[13:34:34.033]   - Field: ‘calls’
[13:34:34.033]   - Field: ‘globals’
[13:34:34.033]   - Field: ‘stdout’
[13:34:34.033]   - Field: ‘earlySignal’
[13:34:34.034]   - Field: ‘lazy’
[13:34:34.034]   - Field: ‘state’
[13:34:34.034] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.034] - Launch lazy future ...
[13:34:34.034] Packages needed by the future expression (n = 0): <none>
[13:34:34.034] Packages needed by future strategies (n = 0): <none>
[13:34:34.035] {
[13:34:34.035]     {
[13:34:34.035]         {
[13:34:34.035]             ...future.startTime <- base::Sys.time()
[13:34:34.035]             {
[13:34:34.035]                 {
[13:34:34.035]                   {
[13:34:34.035]                     base::local({
[13:34:34.035]                       has_future <- base::requireNamespace("future", 
[13:34:34.035]                         quietly = TRUE)
[13:34:34.035]                       if (has_future) {
[13:34:34.035]                         ns <- base::getNamespace("future")
[13:34:34.035]                         version <- ns[[".package"]][["version"]]
[13:34:34.035]                         if (is.null(version)) 
[13:34:34.035]                           version <- utils::packageVersion("future")
[13:34:34.035]                       }
[13:34:34.035]                       else {
[13:34:34.035]                         version <- NULL
[13:34:34.035]                       }
[13:34:34.035]                       if (!has_future || version < "1.8.0") {
[13:34:34.035]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.035]                           "", base::R.version$version.string), 
[13:34:34.035]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.035]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.035]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.035]                             "release", "version")], collapse = " "), 
[13:34:34.035]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.035]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.035]                           info)
[13:34:34.035]                         info <- base::paste(info, collapse = "; ")
[13:34:34.035]                         if (!has_future) {
[13:34:34.035]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.035]                             info)
[13:34:34.035]                         }
[13:34:34.035]                         else {
[13:34:34.035]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.035]                             info, version)
[13:34:34.035]                         }
[13:34:34.035]                         base::stop(msg)
[13:34:34.035]                       }
[13:34:34.035]                     })
[13:34:34.035]                   }
[13:34:34.035]                   ...future.strategy.old <- future::plan("list")
[13:34:34.035]                   options(future.plan = NULL)
[13:34:34.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.035]                 }
[13:34:34.035]                 ...future.workdir <- getwd()
[13:34:34.035]             }
[13:34:34.035]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.035]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.035]         }
[13:34:34.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.035]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.035]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.035]             base::names(...future.oldOptions))
[13:34:34.035]     }
[13:34:34.035]     if (FALSE) {
[13:34:34.035]     }
[13:34:34.035]     else {
[13:34:34.035]         if (TRUE) {
[13:34:34.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.035]                 open = "w")
[13:34:34.035]         }
[13:34:34.035]         else {
[13:34:34.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.035]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.035]         }
[13:34:34.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.035]             base::sink(type = "output", split = FALSE)
[13:34:34.035]             base::close(...future.stdout)
[13:34:34.035]         }, add = TRUE)
[13:34:34.035]     }
[13:34:34.035]     ...future.frame <- base::sys.nframe()
[13:34:34.035]     ...future.conditions <- base::list()
[13:34:34.035]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.035]     if (FALSE) {
[13:34:34.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.035]     }
[13:34:34.035]     ...future.result <- base::tryCatch({
[13:34:34.035]         base::withCallingHandlers({
[13:34:34.035]             ...future.value <- base::withVisible(base::local({
[13:34:34.035]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.035]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.035]                   ...future.globals.maxSize)) {
[13:34:34.035]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.035]                   on.exit(options(oopts), add = TRUE)
[13:34:34.035]                 }
[13:34:34.035]                 {
[13:34:34.035]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.035]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.035]                     USE.NAMES = FALSE)
[13:34:34.035]                   do.call(mapply, args = args)
[13:34:34.035]                 }
[13:34:34.035]             }))
[13:34:34.035]             future::FutureResult(value = ...future.value$value, 
[13:34:34.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.035]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.035]                     ...future.globalenv.names))
[13:34:34.035]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.035]         }, condition = base::local({
[13:34:34.035]             c <- base::c
[13:34:34.035]             inherits <- base::inherits
[13:34:34.035]             invokeRestart <- base::invokeRestart
[13:34:34.035]             length <- base::length
[13:34:34.035]             list <- base::list
[13:34:34.035]             seq.int <- base::seq.int
[13:34:34.035]             signalCondition <- base::signalCondition
[13:34:34.035]             sys.calls <- base::sys.calls
[13:34:34.035]             `[[` <- base::`[[`
[13:34:34.035]             `+` <- base::`+`
[13:34:34.035]             `<<-` <- base::`<<-`
[13:34:34.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.035]                   3L)]
[13:34:34.035]             }
[13:34:34.035]             function(cond) {
[13:34:34.035]                 is_error <- inherits(cond, "error")
[13:34:34.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.035]                   NULL)
[13:34:34.035]                 if (is_error) {
[13:34:34.035]                   sessionInformation <- function() {
[13:34:34.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.035]                       search = base::search(), system = base::Sys.info())
[13:34:34.035]                   }
[13:34:34.035]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.035]                     cond$call), session = sessionInformation(), 
[13:34:34.035]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.035]                   signalCondition(cond)
[13:34:34.035]                 }
[13:34:34.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.035]                 "immediateCondition"))) {
[13:34:34.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.035]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.035]                   if (TRUE && !signal) {
[13:34:34.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.035]                     {
[13:34:34.035]                       inherits <- base::inherits
[13:34:34.035]                       invokeRestart <- base::invokeRestart
[13:34:34.035]                       is.null <- base::is.null
[13:34:34.035]                       muffled <- FALSE
[13:34:34.035]                       if (inherits(cond, "message")) {
[13:34:34.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.035]                         if (muffled) 
[13:34:34.035]                           invokeRestart("muffleMessage")
[13:34:34.035]                       }
[13:34:34.035]                       else if (inherits(cond, "warning")) {
[13:34:34.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.035]                         if (muffled) 
[13:34:34.035]                           invokeRestart("muffleWarning")
[13:34:34.035]                       }
[13:34:34.035]                       else if (inherits(cond, "condition")) {
[13:34:34.035]                         if (!is.null(pattern)) {
[13:34:34.035]                           computeRestarts <- base::computeRestarts
[13:34:34.035]                           grepl <- base::grepl
[13:34:34.035]                           restarts <- computeRestarts(cond)
[13:34:34.035]                           for (restart in restarts) {
[13:34:34.035]                             name <- restart$name
[13:34:34.035]                             if (is.null(name)) 
[13:34:34.035]                               next
[13:34:34.035]                             if (!grepl(pattern, name)) 
[13:34:34.035]                               next
[13:34:34.035]                             invokeRestart(restart)
[13:34:34.035]                             muffled <- TRUE
[13:34:34.035]                             break
[13:34:34.035]                           }
[13:34:34.035]                         }
[13:34:34.035]                       }
[13:34:34.035]                       invisible(muffled)
[13:34:34.035]                     }
[13:34:34.035]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.035]                   }
[13:34:34.035]                 }
[13:34:34.035]                 else {
[13:34:34.035]                   if (TRUE) {
[13:34:34.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.035]                     {
[13:34:34.035]                       inherits <- base::inherits
[13:34:34.035]                       invokeRestart <- base::invokeRestart
[13:34:34.035]                       is.null <- base::is.null
[13:34:34.035]                       muffled <- FALSE
[13:34:34.035]                       if (inherits(cond, "message")) {
[13:34:34.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.035]                         if (muffled) 
[13:34:34.035]                           invokeRestart("muffleMessage")
[13:34:34.035]                       }
[13:34:34.035]                       else if (inherits(cond, "warning")) {
[13:34:34.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.035]                         if (muffled) 
[13:34:34.035]                           invokeRestart("muffleWarning")
[13:34:34.035]                       }
[13:34:34.035]                       else if (inherits(cond, "condition")) {
[13:34:34.035]                         if (!is.null(pattern)) {
[13:34:34.035]                           computeRestarts <- base::computeRestarts
[13:34:34.035]                           grepl <- base::grepl
[13:34:34.035]                           restarts <- computeRestarts(cond)
[13:34:34.035]                           for (restart in restarts) {
[13:34:34.035]                             name <- restart$name
[13:34:34.035]                             if (is.null(name)) 
[13:34:34.035]                               next
[13:34:34.035]                             if (!grepl(pattern, name)) 
[13:34:34.035]                               next
[13:34:34.035]                             invokeRestart(restart)
[13:34:34.035]                             muffled <- TRUE
[13:34:34.035]                             break
[13:34:34.035]                           }
[13:34:34.035]                         }
[13:34:34.035]                       }
[13:34:34.035]                       invisible(muffled)
[13:34:34.035]                     }
[13:34:34.035]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.035]                   }
[13:34:34.035]                 }
[13:34:34.035]             }
[13:34:34.035]         }))
[13:34:34.035]     }, error = function(ex) {
[13:34:34.035]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.035]                 ...future.rng), started = ...future.startTime, 
[13:34:34.035]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.035]             version = "1.8"), class = "FutureResult")
[13:34:34.035]     }, finally = {
[13:34:34.035]         if (!identical(...future.workdir, getwd())) 
[13:34:34.035]             setwd(...future.workdir)
[13:34:34.035]         {
[13:34:34.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.035]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.035]             }
[13:34:34.035]             base::options(...future.oldOptions)
[13:34:34.035]             if (.Platform$OS.type == "windows") {
[13:34:34.035]                 old_names <- names(...future.oldEnvVars)
[13:34:34.035]                 envs <- base::Sys.getenv()
[13:34:34.035]                 names <- names(envs)
[13:34:34.035]                 common <- intersect(names, old_names)
[13:34:34.035]                 added <- setdiff(names, old_names)
[13:34:34.035]                 removed <- setdiff(old_names, names)
[13:34:34.035]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.035]                   envs[common]]
[13:34:34.035]                 NAMES <- toupper(changed)
[13:34:34.035]                 args <- list()
[13:34:34.035]                 for (kk in seq_along(NAMES)) {
[13:34:34.035]                   name <- changed[[kk]]
[13:34:34.035]                   NAME <- NAMES[[kk]]
[13:34:34.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.035]                     next
[13:34:34.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.035]                 }
[13:34:34.035]                 NAMES <- toupper(added)
[13:34:34.035]                 for (kk in seq_along(NAMES)) {
[13:34:34.035]                   name <- added[[kk]]
[13:34:34.035]                   NAME <- NAMES[[kk]]
[13:34:34.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.035]                     next
[13:34:34.035]                   args[[name]] <- ""
[13:34:34.035]                 }
[13:34:34.035]                 NAMES <- toupper(removed)
[13:34:34.035]                 for (kk in seq_along(NAMES)) {
[13:34:34.035]                   name <- removed[[kk]]
[13:34:34.035]                   NAME <- NAMES[[kk]]
[13:34:34.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.035]                     next
[13:34:34.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.035]                 }
[13:34:34.035]                 if (length(args) > 0) 
[13:34:34.035]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.035]             }
[13:34:34.035]             else {
[13:34:34.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.035]             }
[13:34:34.035]             {
[13:34:34.035]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.035]                   0L) {
[13:34:34.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.035]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.035]                   base::options(opts)
[13:34:34.035]                 }
[13:34:34.035]                 {
[13:34:34.035]                   {
[13:34:34.035]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.035]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.035]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.035]                       inherits = FALSE)
[13:34:34.035]                     NULL
[13:34:34.035]                   }
[13:34:34.035]                   options(future.plan = NULL)
[13:34:34.035]                   if (is.na(NA_character_)) 
[13:34:34.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.035]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.035]                     .init = FALSE)
[13:34:34.035]                 }
[13:34:34.035]             }
[13:34:34.035]         }
[13:34:34.035]     })
[13:34:34.035]     if (TRUE) {
[13:34:34.035]         base::sink(type = "output", split = FALSE)
[13:34:34.035]         if (TRUE) {
[13:34:34.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.035]         }
[13:34:34.035]         else {
[13:34:34.035]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.035]         }
[13:34:34.035]         base::close(...future.stdout)
[13:34:34.035]         ...future.stdout <- NULL
[13:34:34.035]     }
[13:34:34.035]     ...future.result$conditions <- ...future.conditions
[13:34:34.035]     ...future.result$finished <- base::Sys.time()
[13:34:34.035]     ...future.result
[13:34:34.035] }
[13:34:34.036] assign_globals() ...
[13:34:34.036] List of 5
[13:34:34.036]  $ ...future.FUN            :function (x, ...)  
[13:34:34.036]  $ MoreArgs                 :List of 1
[13:34:34.036]   ..$ x: num 42
[13:34:34.036]  $ ...future.elements_ii    :List of 1
[13:34:34.036]   ..$ times:List of 4
[13:34:34.036]   .. ..$ : int 1
[13:34:34.036]   .. ..$ : int 2
[13:34:34.036]   .. ..$ : int 3
[13:34:34.036]   .. ..$ : int 4
[13:34:34.036]  $ ...future.seeds_ii       : NULL
[13:34:34.036]  $ ...future.globals.maxSize: NULL
[13:34:34.036]  - attr(*, "where")=List of 5
[13:34:34.036]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.036]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.036]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.036]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.036]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.036]  - attr(*, "resolved")= logi FALSE
[13:34:34.036]  - attr(*, "total_size")= num 336
[13:34:34.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.036]  - attr(*, "already-done")= logi TRUE
[13:34:34.041] - copied ‘...future.FUN’ to environment
[13:34:34.042] - copied ‘MoreArgs’ to environment
[13:34:34.042] - copied ‘...future.elements_ii’ to environment
[13:34:34.042] - copied ‘...future.seeds_ii’ to environment
[13:34:34.042] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.042] assign_globals() ... done
[13:34:34.042] plan(): Setting new future strategy stack:
[13:34:34.042] List of future strategies:
[13:34:34.042] 1. sequential:
[13:34:34.042]    - args: function (..., envir = parent.frame())
[13:34:34.042]    - tweaked: FALSE
[13:34:34.042]    - call: NULL
[13:34:34.043] plan(): nbrOfWorkers() = 1
[13:34:34.043] plan(): Setting new future strategy stack:
[13:34:34.043] List of future strategies:
[13:34:34.043] 1. sequential:
[13:34:34.043]    - args: function (..., envir = parent.frame())
[13:34:34.043]    - tweaked: FALSE
[13:34:34.043]    - call: plan(strategy)
[13:34:34.044] plan(): nbrOfWorkers() = 1
[13:34:34.044] SequentialFuture started (and completed)
[13:34:34.045] - Launch lazy future ... done
[13:34:34.045] run() for ‘SequentialFuture’ ... done
[13:34:34.045] Created future:
[13:34:34.045] SequentialFuture:
[13:34:34.045] Label: ‘future_mapply-1’
[13:34:34.045] Expression:
[13:34:34.045] {
[13:34:34.045]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.045]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.045]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.045]         on.exit(options(oopts), add = TRUE)
[13:34:34.045]     }
[13:34:34.045]     {
[13:34:34.045]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.045]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.045]         do.call(mapply, args = args)
[13:34:34.045]     }
[13:34:34.045] }
[13:34:34.045] Lazy evaluation: FALSE
[13:34:34.045] Asynchronous evaluation: FALSE
[13:34:34.045] Local evaluation: TRUE
[13:34:34.045] Environment: R_GlobalEnv
[13:34:34.045] Capture standard output: TRUE
[13:34:34.045] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.045] Globals: 5 objects totaling 336 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.045] Packages: <none>
[13:34:34.045] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.045] Resolved: TRUE
[13:34:34.045] Value: 280 bytes of class ‘list’
[13:34:34.045] Early signaling: FALSE
[13:34:34.045] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.045] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.046] Chunk #1 of 1 ... DONE
[13:34:34.046] Launching 1 futures (chunks) ... DONE
[13:34:34.046] Resolving 1 futures (chunks) ...
[13:34:34.047] resolve() on list ...
[13:34:34.047]  recursive: 0
[13:34:34.047]  length: 1
[13:34:34.047] 
[13:34:34.047] resolved() for ‘SequentialFuture’ ...
[13:34:34.047] - state: ‘finished’
[13:34:34.047] - run: TRUE
[13:34:34.047] - result: ‘FutureResult’
[13:34:34.047] resolved() for ‘SequentialFuture’ ... done
[13:34:34.047] Future #1
[13:34:34.048] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.048] - nx: 1
[13:34:34.048] - relay: TRUE
[13:34:34.048] - stdout: TRUE
[13:34:34.048] - signal: TRUE
[13:34:34.048] - resignal: FALSE
[13:34:34.048] - force: TRUE
[13:34:34.048] - relayed: [n=1] FALSE
[13:34:34.048] - queued futures: [n=1] FALSE
[13:34:34.048]  - until=1
[13:34:34.048]  - relaying element #1
[13:34:34.049] - relayed: [n=1] TRUE
[13:34:34.049] - queued futures: [n=1] TRUE
[13:34:34.049] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.049]  length: 0 (resolved future 1)
[13:34:34.049] Relaying remaining futures
[13:34:34.049] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.049] - nx: 1
[13:34:34.049] - relay: TRUE
[13:34:34.049] - stdout: TRUE
[13:34:34.049] - signal: TRUE
[13:34:34.050] - resignal: FALSE
[13:34:34.050] - force: TRUE
[13:34:34.050] - relayed: [n=1] TRUE
[13:34:34.050] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.050] - relayed: [n=1] TRUE
[13:34:34.050] - queued futures: [n=1] TRUE
[13:34:34.050] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.051] resolve() on list ... DONE
[13:34:34.051]  - Number of value chunks collected: 1
[13:34:34.051] Resolving 1 futures (chunks) ... DONE
[13:34:34.051] Reducing values from 1 chunks ...
[13:34:34.051]  - Number of values collected after concatenation: 4
[13:34:34.051]  - Number of values expected: 4
[13:34:34.051] Reducing values from 1 chunks ... DONE
[13:34:34.051] future_mapply() ... DONE
[13:34:34.052] future_mapply() ...
[13:34:34.052] Number of chunks: 1
[13:34:34.052] getGlobalsAndPackagesXApply() ...
[13:34:34.052]  - future.globals: TRUE
[13:34:34.052] getGlobalsAndPackages() ...
[13:34:34.052] Searching for globals...
[13:34:34.053] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[13:34:34.054] Searching for globals ... DONE
[13:34:34.054] Resolving globals: FALSE
[13:34:34.054] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[13:34:34.054] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[13:34:34.054] - globals: [1] ‘FUN’
[13:34:34.054] 
[13:34:34.055] getGlobalsAndPackages() ... DONE
[13:34:34.055]  - globals found/used: [n=1] ‘FUN’
[13:34:34.055]  - needed namespaces: [n=0] 
[13:34:34.055] Finding globals ... DONE
[13:34:34.055] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.055] List of 2
[13:34:34.055]  $ ...future.FUN:function (x, y)  
[13:34:34.055]  $ MoreArgs     : NULL
[13:34:34.055]  - attr(*, "where")=List of 2
[13:34:34.055]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.055]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.055]  - attr(*, "resolved")= logi FALSE
[13:34:34.055]  - attr(*, "total_size")= num NA
[13:34:34.057] Packages to be attached in all futures: [n=0] 
[13:34:34.057] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.058] Number of futures (= number of chunks): 1
[13:34:34.058] Launching 1 futures (chunks) ...
[13:34:34.058] Chunk #1 of 1 ...
[13:34:34.058]  - Finding globals in '...' for chunk #1 ...
[13:34:34.058] getGlobalsAndPackages() ...
[13:34:34.058] Searching for globals...
[13:34:34.059] 
[13:34:34.059] Searching for globals ... DONE
[13:34:34.059] - globals: [0] <none>
[13:34:34.059] getGlobalsAndPackages() ... DONE
[13:34:34.059]    + additional globals found: [n=0] 
[13:34:34.059]    + additional namespaces needed: [n=0] 
[13:34:34.059]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.059]  - seeds: <none>
[13:34:34.059]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.059] getGlobalsAndPackages() ...
[13:34:34.060] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.060] Resolving globals: FALSE
[13:34:34.060] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[13:34:34.060] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.061] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.061] 
[13:34:34.061] getGlobalsAndPackages() ... DONE
[13:34:34.061] run() for ‘Future’ ...
[13:34:34.061] - state: ‘created’
[13:34:34.061] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.061] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.062]   - Field: ‘label’
[13:34:34.062]   - Field: ‘local’
[13:34:34.062]   - Field: ‘owner’
[13:34:34.062]   - Field: ‘envir’
[13:34:34.062]   - Field: ‘packages’
[13:34:34.062]   - Field: ‘gc’
[13:34:34.062]   - Field: ‘conditions’
[13:34:34.062]   - Field: ‘expr’
[13:34:34.062]   - Field: ‘uuid’
[13:34:34.063]   - Field: ‘seed’
[13:34:34.063]   - Field: ‘version’
[13:34:34.063]   - Field: ‘result’
[13:34:34.063]   - Field: ‘asynchronous’
[13:34:34.063]   - Field: ‘calls’
[13:34:34.063]   - Field: ‘globals’
[13:34:34.063]   - Field: ‘stdout’
[13:34:34.063]   - Field: ‘earlySignal’
[13:34:34.063]   - Field: ‘lazy’
[13:34:34.063]   - Field: ‘state’
[13:34:34.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.063] - Launch lazy future ...
[13:34:34.064] Packages needed by the future expression (n = 0): <none>
[13:34:34.064] Packages needed by future strategies (n = 0): <none>
[13:34:34.064] {
[13:34:34.064]     {
[13:34:34.064]         {
[13:34:34.064]             ...future.startTime <- base::Sys.time()
[13:34:34.064]             {
[13:34:34.064]                 {
[13:34:34.064]                   {
[13:34:34.064]                     base::local({
[13:34:34.064]                       has_future <- base::requireNamespace("future", 
[13:34:34.064]                         quietly = TRUE)
[13:34:34.064]                       if (has_future) {
[13:34:34.064]                         ns <- base::getNamespace("future")
[13:34:34.064]                         version <- ns[[".package"]][["version"]]
[13:34:34.064]                         if (is.null(version)) 
[13:34:34.064]                           version <- utils::packageVersion("future")
[13:34:34.064]                       }
[13:34:34.064]                       else {
[13:34:34.064]                         version <- NULL
[13:34:34.064]                       }
[13:34:34.064]                       if (!has_future || version < "1.8.0") {
[13:34:34.064]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.064]                           "", base::R.version$version.string), 
[13:34:34.064]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.064]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.064]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.064]                             "release", "version")], collapse = " "), 
[13:34:34.064]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.064]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.064]                           info)
[13:34:34.064]                         info <- base::paste(info, collapse = "; ")
[13:34:34.064]                         if (!has_future) {
[13:34:34.064]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.064]                             info)
[13:34:34.064]                         }
[13:34:34.064]                         else {
[13:34:34.064]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.064]                             info, version)
[13:34:34.064]                         }
[13:34:34.064]                         base::stop(msg)
[13:34:34.064]                       }
[13:34:34.064]                     })
[13:34:34.064]                   }
[13:34:34.064]                   ...future.strategy.old <- future::plan("list")
[13:34:34.064]                   options(future.plan = NULL)
[13:34:34.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.064]                 }
[13:34:34.064]                 ...future.workdir <- getwd()
[13:34:34.064]             }
[13:34:34.064]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.064]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.064]         }
[13:34:34.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.064]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.064]             base::names(...future.oldOptions))
[13:34:34.064]     }
[13:34:34.064]     if (FALSE) {
[13:34:34.064]     }
[13:34:34.064]     else {
[13:34:34.064]         if (TRUE) {
[13:34:34.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.064]                 open = "w")
[13:34:34.064]         }
[13:34:34.064]         else {
[13:34:34.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.064]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.064]         }
[13:34:34.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.064]             base::sink(type = "output", split = FALSE)
[13:34:34.064]             base::close(...future.stdout)
[13:34:34.064]         }, add = TRUE)
[13:34:34.064]     }
[13:34:34.064]     ...future.frame <- base::sys.nframe()
[13:34:34.064]     ...future.conditions <- base::list()
[13:34:34.064]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.064]     if (FALSE) {
[13:34:34.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.064]     }
[13:34:34.064]     ...future.result <- base::tryCatch({
[13:34:34.064]         base::withCallingHandlers({
[13:34:34.064]             ...future.value <- base::withVisible(base::local({
[13:34:34.064]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.064]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.064]                   ...future.globals.maxSize)) {
[13:34:34.064]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.064]                   on.exit(options(oopts), add = TRUE)
[13:34:34.064]                 }
[13:34:34.064]                 {
[13:34:34.064]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.064]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.064]                     USE.NAMES = FALSE)
[13:34:34.064]                   do.call(mapply, args = args)
[13:34:34.064]                 }
[13:34:34.064]             }))
[13:34:34.064]             future::FutureResult(value = ...future.value$value, 
[13:34:34.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.064]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.064]                     ...future.globalenv.names))
[13:34:34.064]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.064]         }, condition = base::local({
[13:34:34.064]             c <- base::c
[13:34:34.064]             inherits <- base::inherits
[13:34:34.064]             invokeRestart <- base::invokeRestart
[13:34:34.064]             length <- base::length
[13:34:34.064]             list <- base::list
[13:34:34.064]             seq.int <- base::seq.int
[13:34:34.064]             signalCondition <- base::signalCondition
[13:34:34.064]             sys.calls <- base::sys.calls
[13:34:34.064]             `[[` <- base::`[[`
[13:34:34.064]             `+` <- base::`+`
[13:34:34.064]             `<<-` <- base::`<<-`
[13:34:34.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.064]                   3L)]
[13:34:34.064]             }
[13:34:34.064]             function(cond) {
[13:34:34.064]                 is_error <- inherits(cond, "error")
[13:34:34.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.064]                   NULL)
[13:34:34.064]                 if (is_error) {
[13:34:34.064]                   sessionInformation <- function() {
[13:34:34.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.064]                       search = base::search(), system = base::Sys.info())
[13:34:34.064]                   }
[13:34:34.064]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.064]                     cond$call), session = sessionInformation(), 
[13:34:34.064]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.064]                   signalCondition(cond)
[13:34:34.064]                 }
[13:34:34.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.064]                 "immediateCondition"))) {
[13:34:34.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.064]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.064]                   if (TRUE && !signal) {
[13:34:34.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.064]                     {
[13:34:34.064]                       inherits <- base::inherits
[13:34:34.064]                       invokeRestart <- base::invokeRestart
[13:34:34.064]                       is.null <- base::is.null
[13:34:34.064]                       muffled <- FALSE
[13:34:34.064]                       if (inherits(cond, "message")) {
[13:34:34.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.064]                         if (muffled) 
[13:34:34.064]                           invokeRestart("muffleMessage")
[13:34:34.064]                       }
[13:34:34.064]                       else if (inherits(cond, "warning")) {
[13:34:34.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.064]                         if (muffled) 
[13:34:34.064]                           invokeRestart("muffleWarning")
[13:34:34.064]                       }
[13:34:34.064]                       else if (inherits(cond, "condition")) {
[13:34:34.064]                         if (!is.null(pattern)) {
[13:34:34.064]                           computeRestarts <- base::computeRestarts
[13:34:34.064]                           grepl <- base::grepl
[13:34:34.064]                           restarts <- computeRestarts(cond)
[13:34:34.064]                           for (restart in restarts) {
[13:34:34.064]                             name <- restart$name
[13:34:34.064]                             if (is.null(name)) 
[13:34:34.064]                               next
[13:34:34.064]                             if (!grepl(pattern, name)) 
[13:34:34.064]                               next
[13:34:34.064]                             invokeRestart(restart)
[13:34:34.064]                             muffled <- TRUE
[13:34:34.064]                             break
[13:34:34.064]                           }
[13:34:34.064]                         }
[13:34:34.064]                       }
[13:34:34.064]                       invisible(muffled)
[13:34:34.064]                     }
[13:34:34.064]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.064]                   }
[13:34:34.064]                 }
[13:34:34.064]                 else {
[13:34:34.064]                   if (TRUE) {
[13:34:34.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.064]                     {
[13:34:34.064]                       inherits <- base::inherits
[13:34:34.064]                       invokeRestart <- base::invokeRestart
[13:34:34.064]                       is.null <- base::is.null
[13:34:34.064]                       muffled <- FALSE
[13:34:34.064]                       if (inherits(cond, "message")) {
[13:34:34.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.064]                         if (muffled) 
[13:34:34.064]                           invokeRestart("muffleMessage")
[13:34:34.064]                       }
[13:34:34.064]                       else if (inherits(cond, "warning")) {
[13:34:34.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.064]                         if (muffled) 
[13:34:34.064]                           invokeRestart("muffleWarning")
[13:34:34.064]                       }
[13:34:34.064]                       else if (inherits(cond, "condition")) {
[13:34:34.064]                         if (!is.null(pattern)) {
[13:34:34.064]                           computeRestarts <- base::computeRestarts
[13:34:34.064]                           grepl <- base::grepl
[13:34:34.064]                           restarts <- computeRestarts(cond)
[13:34:34.064]                           for (restart in restarts) {
[13:34:34.064]                             name <- restart$name
[13:34:34.064]                             if (is.null(name)) 
[13:34:34.064]                               next
[13:34:34.064]                             if (!grepl(pattern, name)) 
[13:34:34.064]                               next
[13:34:34.064]                             invokeRestart(restart)
[13:34:34.064]                             muffled <- TRUE
[13:34:34.064]                             break
[13:34:34.064]                           }
[13:34:34.064]                         }
[13:34:34.064]                       }
[13:34:34.064]                       invisible(muffled)
[13:34:34.064]                     }
[13:34:34.064]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.064]                   }
[13:34:34.064]                 }
[13:34:34.064]             }
[13:34:34.064]         }))
[13:34:34.064]     }, error = function(ex) {
[13:34:34.064]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.064]                 ...future.rng), started = ...future.startTime, 
[13:34:34.064]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.064]             version = "1.8"), class = "FutureResult")
[13:34:34.064]     }, finally = {
[13:34:34.064]         if (!identical(...future.workdir, getwd())) 
[13:34:34.064]             setwd(...future.workdir)
[13:34:34.064]         {
[13:34:34.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.064]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.064]             }
[13:34:34.064]             base::options(...future.oldOptions)
[13:34:34.064]             if (.Platform$OS.type == "windows") {
[13:34:34.064]                 old_names <- names(...future.oldEnvVars)
[13:34:34.064]                 envs <- base::Sys.getenv()
[13:34:34.064]                 names <- names(envs)
[13:34:34.064]                 common <- intersect(names, old_names)
[13:34:34.064]                 added <- setdiff(names, old_names)
[13:34:34.064]                 removed <- setdiff(old_names, names)
[13:34:34.064]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.064]                   envs[common]]
[13:34:34.064]                 NAMES <- toupper(changed)
[13:34:34.064]                 args <- list()
[13:34:34.064]                 for (kk in seq_along(NAMES)) {
[13:34:34.064]                   name <- changed[[kk]]
[13:34:34.064]                   NAME <- NAMES[[kk]]
[13:34:34.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.064]                     next
[13:34:34.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.064]                 }
[13:34:34.064]                 NAMES <- toupper(added)
[13:34:34.064]                 for (kk in seq_along(NAMES)) {
[13:34:34.064]                   name <- added[[kk]]
[13:34:34.064]                   NAME <- NAMES[[kk]]
[13:34:34.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.064]                     next
[13:34:34.064]                   args[[name]] <- ""
[13:34:34.064]                 }
[13:34:34.064]                 NAMES <- toupper(removed)
[13:34:34.064]                 for (kk in seq_along(NAMES)) {
[13:34:34.064]                   name <- removed[[kk]]
[13:34:34.064]                   NAME <- NAMES[[kk]]
[13:34:34.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.064]                     next
[13:34:34.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.064]                 }
[13:34:34.064]                 if (length(args) > 0) 
[13:34:34.064]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.064]             }
[13:34:34.064]             else {
[13:34:34.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.064]             }
[13:34:34.064]             {
[13:34:34.064]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.064]                   0L) {
[13:34:34.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.064]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.064]                   base::options(opts)
[13:34:34.064]                 }
[13:34:34.064]                 {
[13:34:34.064]                   {
[13:34:34.064]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.064]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.064]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.064]                       inherits = FALSE)
[13:34:34.064]                     NULL
[13:34:34.064]                   }
[13:34:34.064]                   options(future.plan = NULL)
[13:34:34.064]                   if (is.na(NA_character_)) 
[13:34:34.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.064]                     .init = FALSE)
[13:34:34.064]                 }
[13:34:34.064]             }
[13:34:34.064]         }
[13:34:34.064]     })
[13:34:34.064]     if (TRUE) {
[13:34:34.064]         base::sink(type = "output", split = FALSE)
[13:34:34.064]         if (TRUE) {
[13:34:34.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.064]         }
[13:34:34.064]         else {
[13:34:34.064]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.064]         }
[13:34:34.064]         base::close(...future.stdout)
[13:34:34.064]         ...future.stdout <- NULL
[13:34:34.064]     }
[13:34:34.064]     ...future.result$conditions <- ...future.conditions
[13:34:34.064]     ...future.result$finished <- base::Sys.time()
[13:34:34.064]     ...future.result
[13:34:34.064] }
[13:34:34.066] assign_globals() ...
[13:34:34.066] List of 5
[13:34:34.066]  $ ...future.FUN            :function (x, y)  
[13:34:34.066]  $ MoreArgs                 : NULL
[13:34:34.066]  $ ...future.elements_ii    :List of 2
[13:34:34.066]   ..$ :List of 3
[13:34:34.066]   .. ..$ a: num 1
[13:34:34.066]   .. ..$ b: num 2
[13:34:34.066]   .. ..$ c: num 3
[13:34:34.066]   ..$ :List of 3
[13:34:34.066]   .. ..$ A: num 10
[13:34:34.066]   .. ..$ B: num 0
[13:34:34.066]   .. ..$ C: num -10
[13:34:34.066]  $ ...future.seeds_ii       : NULL
[13:34:34.066]  $ ...future.globals.maxSize: NULL
[13:34:34.066]  - attr(*, "where")=List of 5
[13:34:34.066]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.066]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.066]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.066]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.066]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.066]  - attr(*, "resolved")= logi FALSE
[13:34:34.066]  - attr(*, "total_size")= num 2312
[13:34:34.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.066]  - attr(*, "already-done")= logi TRUE
[13:34:34.074] - reassign environment for ‘...future.FUN’
[13:34:34.074] - copied ‘...future.FUN’ to environment
[13:34:34.074] - copied ‘MoreArgs’ to environment
[13:34:34.075] - copied ‘...future.elements_ii’ to environment
[13:34:34.075] - copied ‘...future.seeds_ii’ to environment
[13:34:34.075] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.075] assign_globals() ... done
[13:34:34.075] plan(): Setting new future strategy stack:
[13:34:34.075] List of future strategies:
[13:34:34.075] 1. sequential:
[13:34:34.075]    - args: function (..., envir = parent.frame())
[13:34:34.075]    - tweaked: FALSE
[13:34:34.075]    - call: NULL
[13:34:34.075] plan(): nbrOfWorkers() = 1
[13:34:34.076] plan(): Setting new future strategy stack:
[13:34:34.076] List of future strategies:
[13:34:34.076] 1. sequential:
[13:34:34.076]    - args: function (..., envir = parent.frame())
[13:34:34.076]    - tweaked: FALSE
[13:34:34.076]    - call: plan(strategy)
[13:34:34.077] plan(): nbrOfWorkers() = 1
[13:34:34.077] SequentialFuture started (and completed)
[13:34:34.077] - Launch lazy future ... done
[13:34:34.077] run() for ‘SequentialFuture’ ... done
[13:34:34.077] Created future:
[13:34:34.077] SequentialFuture:
[13:34:34.077] Label: ‘future_mapply-1’
[13:34:34.077] Expression:
[13:34:34.077] {
[13:34:34.077]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.077]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.077]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.077]         on.exit(options(oopts), add = TRUE)
[13:34:34.077]     }
[13:34:34.077]     {
[13:34:34.077]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.077]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.077]         do.call(mapply, args = args)
[13:34:34.077]     }
[13:34:34.077] }
[13:34:34.077] Lazy evaluation: FALSE
[13:34:34.077] Asynchronous evaluation: FALSE
[13:34:34.077] Local evaluation: TRUE
[13:34:34.077] Environment: R_GlobalEnv
[13:34:34.077] Capture standard output: TRUE
[13:34:34.077] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.077] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.077] Packages: <none>
[13:34:34.077] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.077] Resolved: TRUE
[13:34:34.077] Value: 200 bytes of class ‘list’
[13:34:34.077] Early signaling: FALSE
[13:34:34.077] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.077] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.078] Chunk #1 of 1 ... DONE
[13:34:34.078] Launching 1 futures (chunks) ... DONE
[13:34:34.078] Resolving 1 futures (chunks) ...
[13:34:34.078] resolve() on list ...
[13:34:34.078]  recursive: 0
[13:34:34.078]  length: 1
[13:34:34.079] 
[13:34:34.079] resolved() for ‘SequentialFuture’ ...
[13:34:34.079] - state: ‘finished’
[13:34:34.079] - run: TRUE
[13:34:34.079] - result: ‘FutureResult’
[13:34:34.079] resolved() for ‘SequentialFuture’ ... done
[13:34:34.079] Future #1
[13:34:34.079] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.079] - nx: 1
[13:34:34.079] - relay: TRUE
[13:34:34.079] - stdout: TRUE
[13:34:34.080] - signal: TRUE
[13:34:34.080] - resignal: FALSE
[13:34:34.080] - force: TRUE
[13:34:34.080] - relayed: [n=1] FALSE
[13:34:34.080] - queued futures: [n=1] FALSE
[13:34:34.080]  - until=1
[13:34:34.080]  - relaying element #1
[13:34:34.080] - relayed: [n=1] TRUE
[13:34:34.080] - queued futures: [n=1] TRUE
[13:34:34.080] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.080]  length: 0 (resolved future 1)
[13:34:34.081] Relaying remaining futures
[13:34:34.081] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.081] - nx: 1
[13:34:34.081] - relay: TRUE
[13:34:34.081] - stdout: TRUE
[13:34:34.081] - signal: TRUE
[13:34:34.081] - resignal: FALSE
[13:34:34.081] - force: TRUE
[13:34:34.081] - relayed: [n=1] TRUE
[13:34:34.081] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.081] - relayed: [n=1] TRUE
[13:34:34.081] - queued futures: [n=1] TRUE
[13:34:34.082] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.082] resolve() on list ... DONE
[13:34:34.082]  - Number of value chunks collected: 1
[13:34:34.082] Resolving 1 futures (chunks) ... DONE
[13:34:34.082] Reducing values from 1 chunks ...
[13:34:34.082]  - Number of values collected after concatenation: 3
[13:34:34.082]  - Number of values expected: 3
[13:34:34.082] Reducing values from 1 chunks ... DONE
[13:34:34.082] future_mapply() ... DONE
- future_.mapply()
[13:34:34.083] future_mapply() ...
[13:34:34.083] Number of chunks: 1
[13:34:34.083] getGlobalsAndPackagesXApply() ...
[13:34:34.083]  - future.globals: TRUE
[13:34:34.083] getGlobalsAndPackages() ...
[13:34:34.084] Searching for globals...
[13:34:34.085] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[13:34:34.085] Searching for globals ... DONE
[13:34:34.085] Resolving globals: FALSE
[13:34:34.085] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[13:34:34.085] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[13:34:34.086] - globals: [1] ‘FUN’
[13:34:34.086] 
[13:34:34.086] getGlobalsAndPackages() ... DONE
[13:34:34.086]  - globals found/used: [n=1] ‘FUN’
[13:34:34.086]  - needed namespaces: [n=0] 
[13:34:34.086] Finding globals ... DONE
[13:34:34.086] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.086] List of 2
[13:34:34.086]  $ ...future.FUN:function (x, y)  
[13:34:34.086]  $ MoreArgs     : list()
[13:34:34.086]  - attr(*, "where")=List of 2
[13:34:34.086]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.086]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.086]  - attr(*, "resolved")= logi FALSE
[13:34:34.086]  - attr(*, "total_size")= num NA
[13:34:34.089] Packages to be attached in all futures: [n=0] 
[13:34:34.089] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.089] Number of futures (= number of chunks): 1
[13:34:34.089] Launching 1 futures (chunks) ...
[13:34:34.089] Chunk #1 of 1 ...
[13:34:34.089]  - Finding globals in '...' for chunk #1 ...
[13:34:34.089] getGlobalsAndPackages() ...
[13:34:34.089] Searching for globals...
[13:34:34.090] 
[13:34:34.090] Searching for globals ... DONE
[13:34:34.090] - globals: [0] <none>
[13:34:34.090] getGlobalsAndPackages() ... DONE
[13:34:34.090]    + additional globals found: [n=0] 
[13:34:34.090]    + additional namespaces needed: [n=0] 
[13:34:34.090]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.090]  - seeds: <none>
[13:34:34.090]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.090] getGlobalsAndPackages() ...
[13:34:34.091] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.091] Resolving globals: FALSE
[13:34:34.092] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[13:34:34.092] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:34.093] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.093] 
[13:34:34.093] getGlobalsAndPackages() ... DONE
[13:34:34.093] run() for ‘Future’ ...
[13:34:34.093] - state: ‘created’
[13:34:34.093] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.094] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.094]   - Field: ‘label’
[13:34:34.094]   - Field: ‘local’
[13:34:34.094]   - Field: ‘owner’
[13:34:34.094]   - Field: ‘envir’
[13:34:34.094]   - Field: ‘packages’
[13:34:34.094]   - Field: ‘gc’
[13:34:34.094]   - Field: ‘conditions’
[13:34:34.094]   - Field: ‘expr’
[13:34:34.094]   - Field: ‘uuid’
[13:34:34.095]   - Field: ‘seed’
[13:34:34.095]   - Field: ‘version’
[13:34:34.095]   - Field: ‘result’
[13:34:34.095]   - Field: ‘asynchronous’
[13:34:34.095]   - Field: ‘calls’
[13:34:34.095]   - Field: ‘globals’
[13:34:34.095]   - Field: ‘stdout’
[13:34:34.095]   - Field: ‘earlySignal’
[13:34:34.095]   - Field: ‘lazy’
[13:34:34.095]   - Field: ‘state’
[13:34:34.095] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.095] - Launch lazy future ...
[13:34:34.096] Packages needed by the future expression (n = 0): <none>
[13:34:34.096] Packages needed by future strategies (n = 0): <none>
[13:34:34.096] {
[13:34:34.096]     {
[13:34:34.096]         {
[13:34:34.096]             ...future.startTime <- base::Sys.time()
[13:34:34.096]             {
[13:34:34.096]                 {
[13:34:34.096]                   {
[13:34:34.096]                     base::local({
[13:34:34.096]                       has_future <- base::requireNamespace("future", 
[13:34:34.096]                         quietly = TRUE)
[13:34:34.096]                       if (has_future) {
[13:34:34.096]                         ns <- base::getNamespace("future")
[13:34:34.096]                         version <- ns[[".package"]][["version"]]
[13:34:34.096]                         if (is.null(version)) 
[13:34:34.096]                           version <- utils::packageVersion("future")
[13:34:34.096]                       }
[13:34:34.096]                       else {
[13:34:34.096]                         version <- NULL
[13:34:34.096]                       }
[13:34:34.096]                       if (!has_future || version < "1.8.0") {
[13:34:34.096]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.096]                           "", base::R.version$version.string), 
[13:34:34.096]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.096]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.096]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.096]                             "release", "version")], collapse = " "), 
[13:34:34.096]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.096]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.096]                           info)
[13:34:34.096]                         info <- base::paste(info, collapse = "; ")
[13:34:34.096]                         if (!has_future) {
[13:34:34.096]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.096]                             info)
[13:34:34.096]                         }
[13:34:34.096]                         else {
[13:34:34.096]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.096]                             info, version)
[13:34:34.096]                         }
[13:34:34.096]                         base::stop(msg)
[13:34:34.096]                       }
[13:34:34.096]                     })
[13:34:34.096]                   }
[13:34:34.096]                   ...future.strategy.old <- future::plan("list")
[13:34:34.096]                   options(future.plan = NULL)
[13:34:34.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.096]                 }
[13:34:34.096]                 ...future.workdir <- getwd()
[13:34:34.096]             }
[13:34:34.096]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.096]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.096]         }
[13:34:34.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.096]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.096]             base::names(...future.oldOptions))
[13:34:34.096]     }
[13:34:34.096]     if (FALSE) {
[13:34:34.096]     }
[13:34:34.096]     else {
[13:34:34.096]         if (TRUE) {
[13:34:34.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.096]                 open = "w")
[13:34:34.096]         }
[13:34:34.096]         else {
[13:34:34.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.096]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.096]         }
[13:34:34.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.096]             base::sink(type = "output", split = FALSE)
[13:34:34.096]             base::close(...future.stdout)
[13:34:34.096]         }, add = TRUE)
[13:34:34.096]     }
[13:34:34.096]     ...future.frame <- base::sys.nframe()
[13:34:34.096]     ...future.conditions <- base::list()
[13:34:34.096]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.096]     if (FALSE) {
[13:34:34.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.096]     }
[13:34:34.096]     ...future.result <- base::tryCatch({
[13:34:34.096]         base::withCallingHandlers({
[13:34:34.096]             ...future.value <- base::withVisible(base::local({
[13:34:34.096]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.096]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.096]                   ...future.globals.maxSize)) {
[13:34:34.096]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.096]                   on.exit(options(oopts), add = TRUE)
[13:34:34.096]                 }
[13:34:34.096]                 {
[13:34:34.096]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.096]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.096]                     USE.NAMES = FALSE)
[13:34:34.096]                   do.call(mapply, args = args)
[13:34:34.096]                 }
[13:34:34.096]             }))
[13:34:34.096]             future::FutureResult(value = ...future.value$value, 
[13:34:34.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.096]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.096]                     ...future.globalenv.names))
[13:34:34.096]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.096]         }, condition = base::local({
[13:34:34.096]             c <- base::c
[13:34:34.096]             inherits <- base::inherits
[13:34:34.096]             invokeRestart <- base::invokeRestart
[13:34:34.096]             length <- base::length
[13:34:34.096]             list <- base::list
[13:34:34.096]             seq.int <- base::seq.int
[13:34:34.096]             signalCondition <- base::signalCondition
[13:34:34.096]             sys.calls <- base::sys.calls
[13:34:34.096]             `[[` <- base::`[[`
[13:34:34.096]             `+` <- base::`+`
[13:34:34.096]             `<<-` <- base::`<<-`
[13:34:34.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.096]                   3L)]
[13:34:34.096]             }
[13:34:34.096]             function(cond) {
[13:34:34.096]                 is_error <- inherits(cond, "error")
[13:34:34.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.096]                   NULL)
[13:34:34.096]                 if (is_error) {
[13:34:34.096]                   sessionInformation <- function() {
[13:34:34.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.096]                       search = base::search(), system = base::Sys.info())
[13:34:34.096]                   }
[13:34:34.096]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.096]                     cond$call), session = sessionInformation(), 
[13:34:34.096]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.096]                   signalCondition(cond)
[13:34:34.096]                 }
[13:34:34.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.096]                 "immediateCondition"))) {
[13:34:34.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.096]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.096]                   if (TRUE && !signal) {
[13:34:34.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.096]                     {
[13:34:34.096]                       inherits <- base::inherits
[13:34:34.096]                       invokeRestart <- base::invokeRestart
[13:34:34.096]                       is.null <- base::is.null
[13:34:34.096]                       muffled <- FALSE
[13:34:34.096]                       if (inherits(cond, "message")) {
[13:34:34.096]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.096]                         if (muffled) 
[13:34:34.096]                           invokeRestart("muffleMessage")
[13:34:34.096]                       }
[13:34:34.096]                       else if (inherits(cond, "warning")) {
[13:34:34.096]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.096]                         if (muffled) 
[13:34:34.096]                           invokeRestart("muffleWarning")
[13:34:34.096]                       }
[13:34:34.096]                       else if (inherits(cond, "condition")) {
[13:34:34.096]                         if (!is.null(pattern)) {
[13:34:34.096]                           computeRestarts <- base::computeRestarts
[13:34:34.096]                           grepl <- base::grepl
[13:34:34.096]                           restarts <- computeRestarts(cond)
[13:34:34.096]                           for (restart in restarts) {
[13:34:34.096]                             name <- restart$name
[13:34:34.096]                             if (is.null(name)) 
[13:34:34.096]                               next
[13:34:34.096]                             if (!grepl(pattern, name)) 
[13:34:34.096]                               next
[13:34:34.096]                             invokeRestart(restart)
[13:34:34.096]                             muffled <- TRUE
[13:34:34.096]                             break
[13:34:34.096]                           }
[13:34:34.096]                         }
[13:34:34.096]                       }
[13:34:34.096]                       invisible(muffled)
[13:34:34.096]                     }
[13:34:34.096]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.096]                   }
[13:34:34.096]                 }
[13:34:34.096]                 else {
[13:34:34.096]                   if (TRUE) {
[13:34:34.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.096]                     {
[13:34:34.096]                       inherits <- base::inherits
[13:34:34.096]                       invokeRestart <- base::invokeRestart
[13:34:34.096]                       is.null <- base::is.null
[13:34:34.096]                       muffled <- FALSE
[13:34:34.096]                       if (inherits(cond, "message")) {
[13:34:34.096]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.096]                         if (muffled) 
[13:34:34.096]                           invokeRestart("muffleMessage")
[13:34:34.096]                       }
[13:34:34.096]                       else if (inherits(cond, "warning")) {
[13:34:34.096]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.096]                         if (muffled) 
[13:34:34.096]                           invokeRestart("muffleWarning")
[13:34:34.096]                       }
[13:34:34.096]                       else if (inherits(cond, "condition")) {
[13:34:34.096]                         if (!is.null(pattern)) {
[13:34:34.096]                           computeRestarts <- base::computeRestarts
[13:34:34.096]                           grepl <- base::grepl
[13:34:34.096]                           restarts <- computeRestarts(cond)
[13:34:34.096]                           for (restart in restarts) {
[13:34:34.096]                             name <- restart$name
[13:34:34.096]                             if (is.null(name)) 
[13:34:34.096]                               next
[13:34:34.096]                             if (!grepl(pattern, name)) 
[13:34:34.096]                               next
[13:34:34.096]                             invokeRestart(restart)
[13:34:34.096]                             muffled <- TRUE
[13:34:34.096]                             break
[13:34:34.096]                           }
[13:34:34.096]                         }
[13:34:34.096]                       }
[13:34:34.096]                       invisible(muffled)
[13:34:34.096]                     }
[13:34:34.096]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.096]                   }
[13:34:34.096]                 }
[13:34:34.096]             }
[13:34:34.096]         }))
[13:34:34.096]     }, error = function(ex) {
[13:34:34.096]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.096]                 ...future.rng), started = ...future.startTime, 
[13:34:34.096]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.096]             version = "1.8"), class = "FutureResult")
[13:34:34.096]     }, finally = {
[13:34:34.096]         if (!identical(...future.workdir, getwd())) 
[13:34:34.096]             setwd(...future.workdir)
[13:34:34.096]         {
[13:34:34.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.096]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.096]             }
[13:34:34.096]             base::options(...future.oldOptions)
[13:34:34.096]             if (.Platform$OS.type == "windows") {
[13:34:34.096]                 old_names <- names(...future.oldEnvVars)
[13:34:34.096]                 envs <- base::Sys.getenv()
[13:34:34.096]                 names <- names(envs)
[13:34:34.096]                 common <- intersect(names, old_names)
[13:34:34.096]                 added <- setdiff(names, old_names)
[13:34:34.096]                 removed <- setdiff(old_names, names)
[13:34:34.096]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.096]                   envs[common]]
[13:34:34.096]                 NAMES <- toupper(changed)
[13:34:34.096]                 args <- list()
[13:34:34.096]                 for (kk in seq_along(NAMES)) {
[13:34:34.096]                   name <- changed[[kk]]
[13:34:34.096]                   NAME <- NAMES[[kk]]
[13:34:34.096]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.096]                     next
[13:34:34.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.096]                 }
[13:34:34.096]                 NAMES <- toupper(added)
[13:34:34.096]                 for (kk in seq_along(NAMES)) {
[13:34:34.096]                   name <- added[[kk]]
[13:34:34.096]                   NAME <- NAMES[[kk]]
[13:34:34.096]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.096]                     next
[13:34:34.096]                   args[[name]] <- ""
[13:34:34.096]                 }
[13:34:34.096]                 NAMES <- toupper(removed)
[13:34:34.096]                 for (kk in seq_along(NAMES)) {
[13:34:34.096]                   name <- removed[[kk]]
[13:34:34.096]                   NAME <- NAMES[[kk]]
[13:34:34.096]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.096]                     next
[13:34:34.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.096]                 }
[13:34:34.096]                 if (length(args) > 0) 
[13:34:34.096]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.096]             }
[13:34:34.096]             else {
[13:34:34.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.096]             }
[13:34:34.096]             {
[13:34:34.096]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.096]                   0L) {
[13:34:34.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.096]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.096]                   base::options(opts)
[13:34:34.096]                 }
[13:34:34.096]                 {
[13:34:34.096]                   {
[13:34:34.096]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.096]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.096]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.096]                       inherits = FALSE)
[13:34:34.096]                     NULL
[13:34:34.096]                   }
[13:34:34.096]                   options(future.plan = NULL)
[13:34:34.096]                   if (is.na(NA_character_)) 
[13:34:34.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.096]                     .init = FALSE)
[13:34:34.096]                 }
[13:34:34.096]             }
[13:34:34.096]         }
[13:34:34.096]     })
[13:34:34.096]     if (TRUE) {
[13:34:34.096]         base::sink(type = "output", split = FALSE)
[13:34:34.096]         if (TRUE) {
[13:34:34.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.096]         }
[13:34:34.096]         else {
[13:34:34.096]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.096]         }
[13:34:34.096]         base::close(...future.stdout)
[13:34:34.096]         ...future.stdout <- NULL
[13:34:34.096]     }
[13:34:34.096]     ...future.result$conditions <- ...future.conditions
[13:34:34.096]     ...future.result$finished <- base::Sys.time()
[13:34:34.096]     ...future.result
[13:34:34.096] }
[13:34:34.098] assign_globals() ...
[13:34:34.098] List of 5
[13:34:34.098]  $ ...future.FUN            :function (x, y)  
[13:34:34.098]  $ MoreArgs                 : list()
[13:34:34.098]  $ ...future.elements_ii    :List of 2
[13:34:34.098]   ..$ :List of 3
[13:34:34.098]   .. ..$ a: num 1
[13:34:34.098]   .. ..$ b: num 2
[13:34:34.098]   .. ..$ c: num 3
[13:34:34.098]   ..$ :List of 3
[13:34:34.098]   .. ..$ A: num 10
[13:34:34.098]   .. ..$ B: num 0
[13:34:34.098]   .. ..$ C: num -10
[13:34:34.098]  $ ...future.seeds_ii       : NULL
[13:34:34.098]  $ ...future.globals.maxSize: NULL
[13:34:34.098]  - attr(*, "where")=List of 5
[13:34:34.098]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.098]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.098]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.098]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.098]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.098]  - attr(*, "resolved")= logi FALSE
[13:34:34.098]  - attr(*, "total_size")= num 2312
[13:34:34.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.098]  - attr(*, "already-done")= logi TRUE
[13:34:34.104] - reassign environment for ‘...future.FUN’
[13:34:34.104] - copied ‘...future.FUN’ to environment
[13:34:34.104] - copied ‘MoreArgs’ to environment
[13:34:34.104] - copied ‘...future.elements_ii’ to environment
[13:34:34.104] - copied ‘...future.seeds_ii’ to environment
[13:34:34.104] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.104] assign_globals() ... done
[13:34:34.104] plan(): Setting new future strategy stack:
[13:34:34.104] List of future strategies:
[13:34:34.104] 1. sequential:
[13:34:34.104]    - args: function (..., envir = parent.frame())
[13:34:34.104]    - tweaked: FALSE
[13:34:34.104]    - call: NULL
[13:34:34.105] plan(): nbrOfWorkers() = 1
[13:34:34.105] plan(): Setting new future strategy stack:
[13:34:34.106] List of future strategies:
[13:34:34.106] 1. sequential:
[13:34:34.106]    - args: function (..., envir = parent.frame())
[13:34:34.106]    - tweaked: FALSE
[13:34:34.106]    - call: plan(strategy)
[13:34:34.106] plan(): nbrOfWorkers() = 1
[13:34:34.106] SequentialFuture started (and completed)
[13:34:34.106] - Launch lazy future ... done
[13:34:34.106] run() for ‘SequentialFuture’ ... done
[13:34:34.106] Created future:
[13:34:34.106] SequentialFuture:
[13:34:34.106] Label: ‘future_.mapply-1’
[13:34:34.106] Expression:
[13:34:34.106] {
[13:34:34.106]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.106]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.106]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.106]         on.exit(options(oopts), add = TRUE)
[13:34:34.106]     }
[13:34:34.106]     {
[13:34:34.106]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.106]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.106]         do.call(mapply, args = args)
[13:34:34.106]     }
[13:34:34.106] }
[13:34:34.106] Lazy evaluation: FALSE
[13:34:34.106] Asynchronous evaluation: FALSE
[13:34:34.106] Local evaluation: TRUE
[13:34:34.106] Environment: R_GlobalEnv
[13:34:34.106] Capture standard output: TRUE
[13:34:34.106] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.106] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.106] Packages: <none>
[13:34:34.106] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.106] Resolved: TRUE
[13:34:34.106] Value: 200 bytes of class ‘list’
[13:34:34.106] Early signaling: FALSE
[13:34:34.106] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.106] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.107] Chunk #1 of 1 ... DONE
[13:34:34.107] Launching 1 futures (chunks) ... DONE
[13:34:34.107] Resolving 1 futures (chunks) ...
[13:34:34.108] resolve() on list ...
[13:34:34.108]  recursive: 0
[13:34:34.108]  length: 1
[13:34:34.108] 
[13:34:34.108] resolved() for ‘SequentialFuture’ ...
[13:34:34.108] - state: ‘finished’
[13:34:34.108] - run: TRUE
[13:34:34.108] - result: ‘FutureResult’
[13:34:34.108] resolved() for ‘SequentialFuture’ ... done
[13:34:34.108] Future #1
[13:34:34.108] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.108] - nx: 1
[13:34:34.109] - relay: TRUE
[13:34:34.109] - stdout: TRUE
[13:34:34.109] - signal: TRUE
[13:34:34.109] - resignal: FALSE
[13:34:34.109] - force: TRUE
[13:34:34.109] - relayed: [n=1] FALSE
[13:34:34.109] - queued futures: [n=1] FALSE
[13:34:34.109]  - until=1
[13:34:34.109]  - relaying element #1
[13:34:34.109] - relayed: [n=1] TRUE
[13:34:34.109] - queued futures: [n=1] TRUE
[13:34:34.110] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.110]  length: 0 (resolved future 1)
[13:34:34.110] Relaying remaining futures
[13:34:34.110] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.110] - nx: 1
[13:34:34.110] - relay: TRUE
[13:34:34.110] - stdout: TRUE
[13:34:34.110] - signal: TRUE
[13:34:34.110] - resignal: FALSE
[13:34:34.110] - force: TRUE
[13:34:34.110] - relayed: [n=1] TRUE
[13:34:34.110] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.111] - relayed: [n=1] TRUE
[13:34:34.111] - queued futures: [n=1] TRUE
[13:34:34.111] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.111] resolve() on list ... DONE
[13:34:34.111]  - Number of value chunks collected: 1
[13:34:34.111] Resolving 1 futures (chunks) ... DONE
[13:34:34.111] Reducing values from 1 chunks ...
[13:34:34.111]  - Number of values collected after concatenation: 3
[13:34:34.111]  - Number of values expected: 3
[13:34:34.111] Reducing values from 1 chunks ... DONE
[13:34:34.111] future_mapply() ... DONE
[13:34:34.112] future_mapply() ...
[13:34:34.115] Number of chunks: 5
[13:34:34.115] getGlobalsAndPackagesXApply() ...
[13:34:34.115]  - future.globals: TRUE
[13:34:34.115] getGlobalsAndPackages() ...
[13:34:34.115] Searching for globals...
[13:34:34.116] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:34.116] Searching for globals ... DONE
[13:34:34.116] Resolving globals: FALSE
[13:34:34.117] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:34.117] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:34.117] - globals: [1] ‘FUN’
[13:34:34.117] 
[13:34:34.117] getGlobalsAndPackages() ... DONE
[13:34:34.118]  - globals found/used: [n=1] ‘FUN’
[13:34:34.118]  - needed namespaces: [n=0] 
[13:34:34.118] Finding globals ... DONE
[13:34:34.118] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.118] List of 2
[13:34:34.118]  $ ...future.FUN:function (C, k)  
[13:34:34.118]  $ MoreArgs     : NULL
[13:34:34.118]  - attr(*, "where")=List of 2
[13:34:34.118]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.118]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.118]  - attr(*, "resolved")= logi FALSE
[13:34:34.118]  - attr(*, "total_size")= num NA
[13:34:34.120] Packages to be attached in all futures: [n=0] 
[13:34:34.120] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.121] Number of futures (= number of chunks): 5
[13:34:34.121] Launching 5 futures (chunks) ...
[13:34:34.121] Chunk #1 of 5 ...
[13:34:34.121]  - Finding globals in '...' for chunk #1 ...
[13:34:34.121] getGlobalsAndPackages() ...
[13:34:34.121] Searching for globals...
[13:34:34.122] 
[13:34:34.122] Searching for globals ... DONE
[13:34:34.122] - globals: [0] <none>
[13:34:34.122] getGlobalsAndPackages() ... DONE
[13:34:34.122]    + additional globals found: [n=0] 
[13:34:34.122]    + additional namespaces needed: [n=0] 
[13:34:34.122]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.123]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:34.123]  - seeds: <none>
[13:34:34.123]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.123] getGlobalsAndPackages() ...
[13:34:34.123] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.123] Resolving globals: FALSE
[13:34:34.124] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:34.124] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.124] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.125] 
[13:34:34.125] getGlobalsAndPackages() ... DONE
[13:34:34.125] run() for ‘Future’ ...
[13:34:34.125] - state: ‘created’
[13:34:34.125] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.126] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.126] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.126]   - Field: ‘label’
[13:34:34.126]   - Field: ‘local’
[13:34:34.126]   - Field: ‘owner’
[13:34:34.126]   - Field: ‘envir’
[13:34:34.126]   - Field: ‘packages’
[13:34:34.126]   - Field: ‘gc’
[13:34:34.126]   - Field: ‘conditions’
[13:34:34.126]   - Field: ‘expr’
[13:34:34.127]   - Field: ‘uuid’
[13:34:34.127]   - Field: ‘seed’
[13:34:34.127]   - Field: ‘version’
[13:34:34.127]   - Field: ‘result’
[13:34:34.127]   - Field: ‘asynchronous’
[13:34:34.127]   - Field: ‘calls’
[13:34:34.127]   - Field: ‘globals’
[13:34:34.127]   - Field: ‘stdout’
[13:34:34.127]   - Field: ‘earlySignal’
[13:34:34.127]   - Field: ‘lazy’
[13:34:34.127]   - Field: ‘state’
[13:34:34.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.128] - Launch lazy future ...
[13:34:34.128] Packages needed by the future expression (n = 0): <none>
[13:34:34.128] Packages needed by future strategies (n = 0): <none>
[13:34:34.128] {
[13:34:34.128]     {
[13:34:34.128]         {
[13:34:34.128]             ...future.startTime <- base::Sys.time()
[13:34:34.128]             {
[13:34:34.128]                 {
[13:34:34.128]                   {
[13:34:34.128]                     base::local({
[13:34:34.128]                       has_future <- base::requireNamespace("future", 
[13:34:34.128]                         quietly = TRUE)
[13:34:34.128]                       if (has_future) {
[13:34:34.128]                         ns <- base::getNamespace("future")
[13:34:34.128]                         version <- ns[[".package"]][["version"]]
[13:34:34.128]                         if (is.null(version)) 
[13:34:34.128]                           version <- utils::packageVersion("future")
[13:34:34.128]                       }
[13:34:34.128]                       else {
[13:34:34.128]                         version <- NULL
[13:34:34.128]                       }
[13:34:34.128]                       if (!has_future || version < "1.8.0") {
[13:34:34.128]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.128]                           "", base::R.version$version.string), 
[13:34:34.128]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.128]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.128]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.128]                             "release", "version")], collapse = " "), 
[13:34:34.128]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.128]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.128]                           info)
[13:34:34.128]                         info <- base::paste(info, collapse = "; ")
[13:34:34.128]                         if (!has_future) {
[13:34:34.128]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.128]                             info)
[13:34:34.128]                         }
[13:34:34.128]                         else {
[13:34:34.128]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.128]                             info, version)
[13:34:34.128]                         }
[13:34:34.128]                         base::stop(msg)
[13:34:34.128]                       }
[13:34:34.128]                     })
[13:34:34.128]                   }
[13:34:34.128]                   ...future.strategy.old <- future::plan("list")
[13:34:34.128]                   options(future.plan = NULL)
[13:34:34.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.128]                 }
[13:34:34.128]                 ...future.workdir <- getwd()
[13:34:34.128]             }
[13:34:34.128]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.128]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.128]         }
[13:34:34.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.128]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:34.128]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.128]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.128]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.128]             base::names(...future.oldOptions))
[13:34:34.128]     }
[13:34:34.128]     if (FALSE) {
[13:34:34.128]     }
[13:34:34.128]     else {
[13:34:34.128]         if (TRUE) {
[13:34:34.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.128]                 open = "w")
[13:34:34.128]         }
[13:34:34.128]         else {
[13:34:34.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.128]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.128]         }
[13:34:34.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.128]             base::sink(type = "output", split = FALSE)
[13:34:34.128]             base::close(...future.stdout)
[13:34:34.128]         }, add = TRUE)
[13:34:34.128]     }
[13:34:34.128]     ...future.frame <- base::sys.nframe()
[13:34:34.128]     ...future.conditions <- base::list()
[13:34:34.128]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.128]     if (FALSE) {
[13:34:34.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.128]     }
[13:34:34.128]     ...future.result <- base::tryCatch({
[13:34:34.128]         base::withCallingHandlers({
[13:34:34.128]             ...future.value <- base::withVisible(base::local({
[13:34:34.128]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.128]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.128]                   ...future.globals.maxSize)) {
[13:34:34.128]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.128]                   on.exit(options(oopts), add = TRUE)
[13:34:34.128]                 }
[13:34:34.128]                 {
[13:34:34.128]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.128]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.128]                     USE.NAMES = FALSE)
[13:34:34.128]                   do.call(mapply, args = args)
[13:34:34.128]                 }
[13:34:34.128]             }))
[13:34:34.128]             future::FutureResult(value = ...future.value$value, 
[13:34:34.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.128]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.128]                     ...future.globalenv.names))
[13:34:34.128]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.128]         }, condition = base::local({
[13:34:34.128]             c <- base::c
[13:34:34.128]             inherits <- base::inherits
[13:34:34.128]             invokeRestart <- base::invokeRestart
[13:34:34.128]             length <- base::length
[13:34:34.128]             list <- base::list
[13:34:34.128]             seq.int <- base::seq.int
[13:34:34.128]             signalCondition <- base::signalCondition
[13:34:34.128]             sys.calls <- base::sys.calls
[13:34:34.128]             `[[` <- base::`[[`
[13:34:34.128]             `+` <- base::`+`
[13:34:34.128]             `<<-` <- base::`<<-`
[13:34:34.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.128]                   3L)]
[13:34:34.128]             }
[13:34:34.128]             function(cond) {
[13:34:34.128]                 is_error <- inherits(cond, "error")
[13:34:34.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.128]                   NULL)
[13:34:34.128]                 if (is_error) {
[13:34:34.128]                   sessionInformation <- function() {
[13:34:34.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.128]                       search = base::search(), system = base::Sys.info())
[13:34:34.128]                   }
[13:34:34.128]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.128]                     cond$call), session = sessionInformation(), 
[13:34:34.128]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.128]                   signalCondition(cond)
[13:34:34.128]                 }
[13:34:34.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.128]                 "immediateCondition"))) {
[13:34:34.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.128]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.128]                   if (TRUE && !signal) {
[13:34:34.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.128]                     {
[13:34:34.128]                       inherits <- base::inherits
[13:34:34.128]                       invokeRestart <- base::invokeRestart
[13:34:34.128]                       is.null <- base::is.null
[13:34:34.128]                       muffled <- FALSE
[13:34:34.128]                       if (inherits(cond, "message")) {
[13:34:34.128]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.128]                         if (muffled) 
[13:34:34.128]                           invokeRestart("muffleMessage")
[13:34:34.128]                       }
[13:34:34.128]                       else if (inherits(cond, "warning")) {
[13:34:34.128]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.128]                         if (muffled) 
[13:34:34.128]                           invokeRestart("muffleWarning")
[13:34:34.128]                       }
[13:34:34.128]                       else if (inherits(cond, "condition")) {
[13:34:34.128]                         if (!is.null(pattern)) {
[13:34:34.128]                           computeRestarts <- base::computeRestarts
[13:34:34.128]                           grepl <- base::grepl
[13:34:34.128]                           restarts <- computeRestarts(cond)
[13:34:34.128]                           for (restart in restarts) {
[13:34:34.128]                             name <- restart$name
[13:34:34.128]                             if (is.null(name)) 
[13:34:34.128]                               next
[13:34:34.128]                             if (!grepl(pattern, name)) 
[13:34:34.128]                               next
[13:34:34.128]                             invokeRestart(restart)
[13:34:34.128]                             muffled <- TRUE
[13:34:34.128]                             break
[13:34:34.128]                           }
[13:34:34.128]                         }
[13:34:34.128]                       }
[13:34:34.128]                       invisible(muffled)
[13:34:34.128]                     }
[13:34:34.128]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.128]                   }
[13:34:34.128]                 }
[13:34:34.128]                 else {
[13:34:34.128]                   if (TRUE) {
[13:34:34.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.128]                     {
[13:34:34.128]                       inherits <- base::inherits
[13:34:34.128]                       invokeRestart <- base::invokeRestart
[13:34:34.128]                       is.null <- base::is.null
[13:34:34.128]                       muffled <- FALSE
[13:34:34.128]                       if (inherits(cond, "message")) {
[13:34:34.128]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.128]                         if (muffled) 
[13:34:34.128]                           invokeRestart("muffleMessage")
[13:34:34.128]                       }
[13:34:34.128]                       else if (inherits(cond, "warning")) {
[13:34:34.128]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.128]                         if (muffled) 
[13:34:34.128]                           invokeRestart("muffleWarning")
[13:34:34.128]                       }
[13:34:34.128]                       else if (inherits(cond, "condition")) {
[13:34:34.128]                         if (!is.null(pattern)) {
[13:34:34.128]                           computeRestarts <- base::computeRestarts
[13:34:34.128]                           grepl <- base::grepl
[13:34:34.128]                           restarts <- computeRestarts(cond)
[13:34:34.128]                           for (restart in restarts) {
[13:34:34.128]                             name <- restart$name
[13:34:34.128]                             if (is.null(name)) 
[13:34:34.128]                               next
[13:34:34.128]                             if (!grepl(pattern, name)) 
[13:34:34.128]                               next
[13:34:34.128]                             invokeRestart(restart)
[13:34:34.128]                             muffled <- TRUE
[13:34:34.128]                             break
[13:34:34.128]                           }
[13:34:34.128]                         }
[13:34:34.128]                       }
[13:34:34.128]                       invisible(muffled)
[13:34:34.128]                     }
[13:34:34.128]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.128]                   }
[13:34:34.128]                 }
[13:34:34.128]             }
[13:34:34.128]         }))
[13:34:34.128]     }, error = function(ex) {
[13:34:34.128]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.128]                 ...future.rng), started = ...future.startTime, 
[13:34:34.128]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.128]             version = "1.8"), class = "FutureResult")
[13:34:34.128]     }, finally = {
[13:34:34.128]         if (!identical(...future.workdir, getwd())) 
[13:34:34.128]             setwd(...future.workdir)
[13:34:34.128]         {
[13:34:34.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.128]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.128]             }
[13:34:34.128]             base::options(...future.oldOptions)
[13:34:34.128]             if (.Platform$OS.type == "windows") {
[13:34:34.128]                 old_names <- names(...future.oldEnvVars)
[13:34:34.128]                 envs <- base::Sys.getenv()
[13:34:34.128]                 names <- names(envs)
[13:34:34.128]                 common <- intersect(names, old_names)
[13:34:34.128]                 added <- setdiff(names, old_names)
[13:34:34.128]                 removed <- setdiff(old_names, names)
[13:34:34.128]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.128]                   envs[common]]
[13:34:34.128]                 NAMES <- toupper(changed)
[13:34:34.128]                 args <- list()
[13:34:34.128]                 for (kk in seq_along(NAMES)) {
[13:34:34.128]                   name <- changed[[kk]]
[13:34:34.128]                   NAME <- NAMES[[kk]]
[13:34:34.128]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.128]                     next
[13:34:34.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.128]                 }
[13:34:34.128]                 NAMES <- toupper(added)
[13:34:34.128]                 for (kk in seq_along(NAMES)) {
[13:34:34.128]                   name <- added[[kk]]
[13:34:34.128]                   NAME <- NAMES[[kk]]
[13:34:34.128]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.128]                     next
[13:34:34.128]                   args[[name]] <- ""
[13:34:34.128]                 }
[13:34:34.128]                 NAMES <- toupper(removed)
[13:34:34.128]                 for (kk in seq_along(NAMES)) {
[13:34:34.128]                   name <- removed[[kk]]
[13:34:34.128]                   NAME <- NAMES[[kk]]
[13:34:34.128]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.128]                     next
[13:34:34.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.128]                 }
[13:34:34.128]                 if (length(args) > 0) 
[13:34:34.128]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.128]             }
[13:34:34.128]             else {
[13:34:34.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.128]             }
[13:34:34.128]             {
[13:34:34.128]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.128]                   0L) {
[13:34:34.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.128]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.128]                   base::options(opts)
[13:34:34.128]                 }
[13:34:34.128]                 {
[13:34:34.128]                   {
[13:34:34.128]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.128]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.128]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.128]                       inherits = FALSE)
[13:34:34.128]                     NULL
[13:34:34.128]                   }
[13:34:34.128]                   options(future.plan = NULL)
[13:34:34.128]                   if (is.na(NA_character_)) 
[13:34:34.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.128]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.128]                     .init = FALSE)
[13:34:34.128]                 }
[13:34:34.128]             }
[13:34:34.128]         }
[13:34:34.128]     })
[13:34:34.128]     if (TRUE) {
[13:34:34.128]         base::sink(type = "output", split = FALSE)
[13:34:34.128]         if (TRUE) {
[13:34:34.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.128]         }
[13:34:34.128]         else {
[13:34:34.128]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.128]         }
[13:34:34.128]         base::close(...future.stdout)
[13:34:34.128]         ...future.stdout <- NULL
[13:34:34.128]     }
[13:34:34.128]     ...future.result$conditions <- ...future.conditions
[13:34:34.128]     ...future.result$finished <- base::Sys.time()
[13:34:34.128]     ...future.result
[13:34:34.128] }
[13:34:34.130] assign_globals() ...
[13:34:34.130] List of 5
[13:34:34.130]  $ ...future.FUN            :function (C, k)  
[13:34:34.130]  $ MoreArgs                 : NULL
[13:34:34.130]  $ ...future.elements_ii    :List of 2
[13:34:34.130]   ..$ :List of 1
[13:34:34.130]   .. ..$ : chr "A"
[13:34:34.130]   ..$ :List of 1
[13:34:34.130]   .. ..$ : int 5
[13:34:34.130]  $ ...future.seeds_ii       : NULL
[13:34:34.130]  $ ...future.globals.maxSize: NULL
[13:34:34.130]  - attr(*, "where")=List of 5
[13:34:34.130]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.130]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.130]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.130]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.130]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.130]  - attr(*, "resolved")= logi FALSE
[13:34:34.130]  - attr(*, "total_size")= num 3488
[13:34:34.130]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.130]  - attr(*, "already-done")= logi TRUE
[13:34:34.135] - reassign environment for ‘...future.FUN’
[13:34:34.135] - copied ‘...future.FUN’ to environment
[13:34:34.135] - copied ‘MoreArgs’ to environment
[13:34:34.135] - copied ‘...future.elements_ii’ to environment
[13:34:34.135] - copied ‘...future.seeds_ii’ to environment
[13:34:34.136] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.136] assign_globals() ... done
[13:34:34.136] plan(): Setting new future strategy stack:
[13:34:34.136] List of future strategies:
[13:34:34.136] 1. sequential:
[13:34:34.136]    - args: function (..., envir = parent.frame())
[13:34:34.136]    - tweaked: FALSE
[13:34:34.136]    - call: NULL
[13:34:34.136] plan(): nbrOfWorkers() = 1
[13:34:34.138] plan(): Setting new future strategy stack:
[13:34:34.139] List of future strategies:
[13:34:34.139] 1. sequential:
[13:34:34.139]    - args: function (..., envir = parent.frame())
[13:34:34.139]    - tweaked: FALSE
[13:34:34.139]    - call: plan(strategy)
[13:34:34.139] plan(): nbrOfWorkers() = 1
[13:34:34.139] SequentialFuture started (and completed)
[13:34:34.139] - Launch lazy future ... done
[13:34:34.139] run() for ‘SequentialFuture’ ... done
[13:34:34.139] Created future:
[13:34:34.140] SequentialFuture:
[13:34:34.140] Label: ‘future_mapply-1’
[13:34:34.140] Expression:
[13:34:34.140] {
[13:34:34.140]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.140]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.140]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.140]         on.exit(options(oopts), add = TRUE)
[13:34:34.140]     }
[13:34:34.140]     {
[13:34:34.140]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.140]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.140]         do.call(mapply, args = args)
[13:34:34.140]     }
[13:34:34.140] }
[13:34:34.140] Lazy evaluation: FALSE
[13:34:34.140] Asynchronous evaluation: FALSE
[13:34:34.140] Local evaluation: TRUE
[13:34:34.140] Environment: R_GlobalEnv
[13:34:34.140] Capture standard output: TRUE
[13:34:34.140] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.140] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.140] Packages: <none>
[13:34:34.140] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.140] Resolved: TRUE
[13:34:34.140] Value: 112 bytes of class ‘list’
[13:34:34.140] Early signaling: FALSE
[13:34:34.140] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.140] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.140] Chunk #1 of 5 ... DONE
[13:34:34.141] Chunk #2 of 5 ...
[13:34:34.141]  - Finding globals in '...' for chunk #2 ...
[13:34:34.141] getGlobalsAndPackages() ...
[13:34:34.141] Searching for globals...
[13:34:34.141] 
[13:34:34.141] Searching for globals ... DONE
[13:34:34.141] - globals: [0] <none>
[13:34:34.141] getGlobalsAndPackages() ... DONE
[13:34:34.141]    + additional globals found: [n=0] 
[13:34:34.142]    + additional namespaces needed: [n=0] 
[13:34:34.142]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:34.142]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:34.142]  - seeds: <none>
[13:34:34.142]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.142] getGlobalsAndPackages() ...
[13:34:34.142] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.142] Resolving globals: FALSE
[13:34:34.143] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:34.143] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.143] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.144] 
[13:34:34.144] getGlobalsAndPackages() ... DONE
[13:34:34.144] run() for ‘Future’ ...
[13:34:34.144] - state: ‘created’
[13:34:34.144] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.144] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.144] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.144]   - Field: ‘label’
[13:34:34.145]   - Field: ‘local’
[13:34:34.145]   - Field: ‘owner’
[13:34:34.145]   - Field: ‘envir’
[13:34:34.145]   - Field: ‘packages’
[13:34:34.145]   - Field: ‘gc’
[13:34:34.145]   - Field: ‘conditions’
[13:34:34.145]   - Field: ‘expr’
[13:34:34.145]   - Field: ‘uuid’
[13:34:34.145]   - Field: ‘seed’
[13:34:34.145]   - Field: ‘version’
[13:34:34.146]   - Field: ‘result’
[13:34:34.146]   - Field: ‘asynchronous’
[13:34:34.146]   - Field: ‘calls’
[13:34:34.146]   - Field: ‘globals’
[13:34:34.146]   - Field: ‘stdout’
[13:34:34.146]   - Field: ‘earlySignal’
[13:34:34.146]   - Field: ‘lazy’
[13:34:34.147]   - Field: ‘state’
[13:34:34.147] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.147] - Launch lazy future ...
[13:34:34.147] Packages needed by the future expression (n = 0): <none>
[13:34:34.147] Packages needed by future strategies (n = 0): <none>
[13:34:34.148] {
[13:34:34.148]     {
[13:34:34.148]         {
[13:34:34.148]             ...future.startTime <- base::Sys.time()
[13:34:34.148]             {
[13:34:34.148]                 {
[13:34:34.148]                   {
[13:34:34.148]                     base::local({
[13:34:34.148]                       has_future <- base::requireNamespace("future", 
[13:34:34.148]                         quietly = TRUE)
[13:34:34.148]                       if (has_future) {
[13:34:34.148]                         ns <- base::getNamespace("future")
[13:34:34.148]                         version <- ns[[".package"]][["version"]]
[13:34:34.148]                         if (is.null(version)) 
[13:34:34.148]                           version <- utils::packageVersion("future")
[13:34:34.148]                       }
[13:34:34.148]                       else {
[13:34:34.148]                         version <- NULL
[13:34:34.148]                       }
[13:34:34.148]                       if (!has_future || version < "1.8.0") {
[13:34:34.148]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.148]                           "", base::R.version$version.string), 
[13:34:34.148]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.148]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.148]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.148]                             "release", "version")], collapse = " "), 
[13:34:34.148]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.148]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.148]                           info)
[13:34:34.148]                         info <- base::paste(info, collapse = "; ")
[13:34:34.148]                         if (!has_future) {
[13:34:34.148]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.148]                             info)
[13:34:34.148]                         }
[13:34:34.148]                         else {
[13:34:34.148]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.148]                             info, version)
[13:34:34.148]                         }
[13:34:34.148]                         base::stop(msg)
[13:34:34.148]                       }
[13:34:34.148]                     })
[13:34:34.148]                   }
[13:34:34.148]                   ...future.strategy.old <- future::plan("list")
[13:34:34.148]                   options(future.plan = NULL)
[13:34:34.148]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.148]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.148]                 }
[13:34:34.148]                 ...future.workdir <- getwd()
[13:34:34.148]             }
[13:34:34.148]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.148]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.148]         }
[13:34:34.148]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.148]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:34.148]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.148]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.148]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.148]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.148]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.148]             base::names(...future.oldOptions))
[13:34:34.148]     }
[13:34:34.148]     if (FALSE) {
[13:34:34.148]     }
[13:34:34.148]     else {
[13:34:34.148]         if (TRUE) {
[13:34:34.148]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.148]                 open = "w")
[13:34:34.148]         }
[13:34:34.148]         else {
[13:34:34.148]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.148]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.148]         }
[13:34:34.148]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.148]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.148]             base::sink(type = "output", split = FALSE)
[13:34:34.148]             base::close(...future.stdout)
[13:34:34.148]         }, add = TRUE)
[13:34:34.148]     }
[13:34:34.148]     ...future.frame <- base::sys.nframe()
[13:34:34.148]     ...future.conditions <- base::list()
[13:34:34.148]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.148]     if (FALSE) {
[13:34:34.148]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.148]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.148]     }
[13:34:34.148]     ...future.result <- base::tryCatch({
[13:34:34.148]         base::withCallingHandlers({
[13:34:34.148]             ...future.value <- base::withVisible(base::local({
[13:34:34.148]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.148]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.148]                   ...future.globals.maxSize)) {
[13:34:34.148]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.148]                   on.exit(options(oopts), add = TRUE)
[13:34:34.148]                 }
[13:34:34.148]                 {
[13:34:34.148]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.148]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.148]                     USE.NAMES = FALSE)
[13:34:34.148]                   do.call(mapply, args = args)
[13:34:34.148]                 }
[13:34:34.148]             }))
[13:34:34.148]             future::FutureResult(value = ...future.value$value, 
[13:34:34.148]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.148]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.148]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.148]                     ...future.globalenv.names))
[13:34:34.148]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.148]         }, condition = base::local({
[13:34:34.148]             c <- base::c
[13:34:34.148]             inherits <- base::inherits
[13:34:34.148]             invokeRestart <- base::invokeRestart
[13:34:34.148]             length <- base::length
[13:34:34.148]             list <- base::list
[13:34:34.148]             seq.int <- base::seq.int
[13:34:34.148]             signalCondition <- base::signalCondition
[13:34:34.148]             sys.calls <- base::sys.calls
[13:34:34.148]             `[[` <- base::`[[`
[13:34:34.148]             `+` <- base::`+`
[13:34:34.148]             `<<-` <- base::`<<-`
[13:34:34.148]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.148]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.148]                   3L)]
[13:34:34.148]             }
[13:34:34.148]             function(cond) {
[13:34:34.148]                 is_error <- inherits(cond, "error")
[13:34:34.148]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.148]                   NULL)
[13:34:34.148]                 if (is_error) {
[13:34:34.148]                   sessionInformation <- function() {
[13:34:34.148]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.148]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.148]                       search = base::search(), system = base::Sys.info())
[13:34:34.148]                   }
[13:34:34.148]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.148]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.148]                     cond$call), session = sessionInformation(), 
[13:34:34.148]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.148]                   signalCondition(cond)
[13:34:34.148]                 }
[13:34:34.148]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.148]                 "immediateCondition"))) {
[13:34:34.148]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.148]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.148]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.148]                   if (TRUE && !signal) {
[13:34:34.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.148]                     {
[13:34:34.148]                       inherits <- base::inherits
[13:34:34.148]                       invokeRestart <- base::invokeRestart
[13:34:34.148]                       is.null <- base::is.null
[13:34:34.148]                       muffled <- FALSE
[13:34:34.148]                       if (inherits(cond, "message")) {
[13:34:34.148]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.148]                         if (muffled) 
[13:34:34.148]                           invokeRestart("muffleMessage")
[13:34:34.148]                       }
[13:34:34.148]                       else if (inherits(cond, "warning")) {
[13:34:34.148]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.148]                         if (muffled) 
[13:34:34.148]                           invokeRestart("muffleWarning")
[13:34:34.148]                       }
[13:34:34.148]                       else if (inherits(cond, "condition")) {
[13:34:34.148]                         if (!is.null(pattern)) {
[13:34:34.148]                           computeRestarts <- base::computeRestarts
[13:34:34.148]                           grepl <- base::grepl
[13:34:34.148]                           restarts <- computeRestarts(cond)
[13:34:34.148]                           for (restart in restarts) {
[13:34:34.148]                             name <- restart$name
[13:34:34.148]                             if (is.null(name)) 
[13:34:34.148]                               next
[13:34:34.148]                             if (!grepl(pattern, name)) 
[13:34:34.148]                               next
[13:34:34.148]                             invokeRestart(restart)
[13:34:34.148]                             muffled <- TRUE
[13:34:34.148]                             break
[13:34:34.148]                           }
[13:34:34.148]                         }
[13:34:34.148]                       }
[13:34:34.148]                       invisible(muffled)
[13:34:34.148]                     }
[13:34:34.148]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.148]                   }
[13:34:34.148]                 }
[13:34:34.148]                 else {
[13:34:34.148]                   if (TRUE) {
[13:34:34.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.148]                     {
[13:34:34.148]                       inherits <- base::inherits
[13:34:34.148]                       invokeRestart <- base::invokeRestart
[13:34:34.148]                       is.null <- base::is.null
[13:34:34.148]                       muffled <- FALSE
[13:34:34.148]                       if (inherits(cond, "message")) {
[13:34:34.148]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.148]                         if (muffled) 
[13:34:34.148]                           invokeRestart("muffleMessage")
[13:34:34.148]                       }
[13:34:34.148]                       else if (inherits(cond, "warning")) {
[13:34:34.148]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.148]                         if (muffled) 
[13:34:34.148]                           invokeRestart("muffleWarning")
[13:34:34.148]                       }
[13:34:34.148]                       else if (inherits(cond, "condition")) {
[13:34:34.148]                         if (!is.null(pattern)) {
[13:34:34.148]                           computeRestarts <- base::computeRestarts
[13:34:34.148]                           grepl <- base::grepl
[13:34:34.148]                           restarts <- computeRestarts(cond)
[13:34:34.148]                           for (restart in restarts) {
[13:34:34.148]                             name <- restart$name
[13:34:34.148]                             if (is.null(name)) 
[13:34:34.148]                               next
[13:34:34.148]                             if (!grepl(pattern, name)) 
[13:34:34.148]                               next
[13:34:34.148]                             invokeRestart(restart)
[13:34:34.148]                             muffled <- TRUE
[13:34:34.148]                             break
[13:34:34.148]                           }
[13:34:34.148]                         }
[13:34:34.148]                       }
[13:34:34.148]                       invisible(muffled)
[13:34:34.148]                     }
[13:34:34.148]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.148]                   }
[13:34:34.148]                 }
[13:34:34.148]             }
[13:34:34.148]         }))
[13:34:34.148]     }, error = function(ex) {
[13:34:34.148]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.148]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.148]                 ...future.rng), started = ...future.startTime, 
[13:34:34.148]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.148]             version = "1.8"), class = "FutureResult")
[13:34:34.148]     }, finally = {
[13:34:34.148]         if (!identical(...future.workdir, getwd())) 
[13:34:34.148]             setwd(...future.workdir)
[13:34:34.148]         {
[13:34:34.148]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.148]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.148]             }
[13:34:34.148]             base::options(...future.oldOptions)
[13:34:34.148]             if (.Platform$OS.type == "windows") {
[13:34:34.148]                 old_names <- names(...future.oldEnvVars)
[13:34:34.148]                 envs <- base::Sys.getenv()
[13:34:34.148]                 names <- names(envs)
[13:34:34.148]                 common <- intersect(names, old_names)
[13:34:34.148]                 added <- setdiff(names, old_names)
[13:34:34.148]                 removed <- setdiff(old_names, names)
[13:34:34.148]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.148]                   envs[common]]
[13:34:34.148]                 NAMES <- toupper(changed)
[13:34:34.148]                 args <- list()
[13:34:34.148]                 for (kk in seq_along(NAMES)) {
[13:34:34.148]                   name <- changed[[kk]]
[13:34:34.148]                   NAME <- NAMES[[kk]]
[13:34:34.148]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.148]                     next
[13:34:34.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.148]                 }
[13:34:34.148]                 NAMES <- toupper(added)
[13:34:34.148]                 for (kk in seq_along(NAMES)) {
[13:34:34.148]                   name <- added[[kk]]
[13:34:34.148]                   NAME <- NAMES[[kk]]
[13:34:34.148]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.148]                     next
[13:34:34.148]                   args[[name]] <- ""
[13:34:34.148]                 }
[13:34:34.148]                 NAMES <- toupper(removed)
[13:34:34.148]                 for (kk in seq_along(NAMES)) {
[13:34:34.148]                   name <- removed[[kk]]
[13:34:34.148]                   NAME <- NAMES[[kk]]
[13:34:34.148]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.148]                     next
[13:34:34.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.148]                 }
[13:34:34.148]                 if (length(args) > 0) 
[13:34:34.148]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.148]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.148]             }
[13:34:34.148]             else {
[13:34:34.148]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.148]             }
[13:34:34.148]             {
[13:34:34.148]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.148]                   0L) {
[13:34:34.148]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.148]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.148]                   base::options(opts)
[13:34:34.148]                 }
[13:34:34.148]                 {
[13:34:34.148]                   {
[13:34:34.148]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.148]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.148]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.148]                       inherits = FALSE)
[13:34:34.148]                     NULL
[13:34:34.148]                   }
[13:34:34.148]                   options(future.plan = NULL)
[13:34:34.148]                   if (is.na(NA_character_)) 
[13:34:34.148]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.148]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.148]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.148]                     .init = FALSE)
[13:34:34.148]                 }
[13:34:34.148]             }
[13:34:34.148]         }
[13:34:34.148]     })
[13:34:34.148]     if (TRUE) {
[13:34:34.148]         base::sink(type = "output", split = FALSE)
[13:34:34.148]         if (TRUE) {
[13:34:34.148]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.148]         }
[13:34:34.148]         else {
[13:34:34.148]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.148]         }
[13:34:34.148]         base::close(...future.stdout)
[13:34:34.148]         ...future.stdout <- NULL
[13:34:34.148]     }
[13:34:34.148]     ...future.result$conditions <- ...future.conditions
[13:34:34.148]     ...future.result$finished <- base::Sys.time()
[13:34:34.148]     ...future.result
[13:34:34.148] }
[13:34:34.150] assign_globals() ...
[13:34:34.150] List of 5
[13:34:34.150]  $ ...future.FUN            :function (C, k)  
[13:34:34.150]  $ MoreArgs                 : NULL
[13:34:34.150]  $ ...future.elements_ii    :List of 2
[13:34:34.150]   ..$ :List of 1
[13:34:34.150]   .. ..$ : chr "B"
[13:34:34.150]   ..$ :List of 1
[13:34:34.150]   .. ..$ : int 4
[13:34:34.150]  $ ...future.seeds_ii       : NULL
[13:34:34.150]  $ ...future.globals.maxSize: NULL
[13:34:34.150]  - attr(*, "where")=List of 5
[13:34:34.150]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.150]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.150]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.150]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.150]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.150]  - attr(*, "resolved")= logi FALSE
[13:34:34.150]  - attr(*, "total_size")= num 3488
[13:34:34.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.150]  - attr(*, "already-done")= logi TRUE
[13:34:34.155] - reassign environment for ‘...future.FUN’
[13:34:34.155] - copied ‘...future.FUN’ to environment
[13:34:34.155] - copied ‘MoreArgs’ to environment
[13:34:34.155] - copied ‘...future.elements_ii’ to environment
[13:34:34.155] - copied ‘...future.seeds_ii’ to environment
[13:34:34.155] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.155] assign_globals() ... done
[13:34:34.156] plan(): Setting new future strategy stack:
[13:34:34.156] List of future strategies:
[13:34:34.156] 1. sequential:
[13:34:34.156]    - args: function (..., envir = parent.frame())
[13:34:34.156]    - tweaked: FALSE
[13:34:34.156]    - call: NULL
[13:34:34.156] plan(): nbrOfWorkers() = 1
[13:34:34.157] plan(): Setting new future strategy stack:
[13:34:34.157] List of future strategies:
[13:34:34.157] 1. sequential:
[13:34:34.157]    - args: function (..., envir = parent.frame())
[13:34:34.157]    - tweaked: FALSE
[13:34:34.157]    - call: plan(strategy)
[13:34:34.157] plan(): nbrOfWorkers() = 1
[13:34:34.157] SequentialFuture started (and completed)
[13:34:34.158] - Launch lazy future ... done
[13:34:34.158] run() for ‘SequentialFuture’ ... done
[13:34:34.158] Created future:
[13:34:34.158] SequentialFuture:
[13:34:34.158] Label: ‘future_mapply-2’
[13:34:34.158] Expression:
[13:34:34.158] {
[13:34:34.158]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.158]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.158]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.158]         on.exit(options(oopts), add = TRUE)
[13:34:34.158]     }
[13:34:34.158]     {
[13:34:34.158]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.158]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.158]         do.call(mapply, args = args)
[13:34:34.158]     }
[13:34:34.158] }
[13:34:34.158] Lazy evaluation: FALSE
[13:34:34.158] Asynchronous evaluation: FALSE
[13:34:34.158] Local evaluation: TRUE
[13:34:34.158] Environment: R_GlobalEnv
[13:34:34.158] Capture standard output: TRUE
[13:34:34.158] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.158] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.158] Packages: <none>
[13:34:34.158] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.158] Resolved: TRUE
[13:34:34.158] Value: 112 bytes of class ‘list’
[13:34:34.158] Early signaling: FALSE
[13:34:34.158] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.158] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.159] Chunk #2 of 5 ... DONE
[13:34:34.159] Chunk #3 of 5 ...
[13:34:34.159]  - Finding globals in '...' for chunk #3 ...
[13:34:34.159] getGlobalsAndPackages() ...
[13:34:34.159] Searching for globals...
[13:34:34.160] 
[13:34:34.160] Searching for globals ... DONE
[13:34:34.160] - globals: [0] <none>
[13:34:34.160] getGlobalsAndPackages() ... DONE
[13:34:34.160]    + additional globals found: [n=0] 
[13:34:34.160]    + additional namespaces needed: [n=0] 
[13:34:34.161]  - Finding globals in '...' for chunk #3 ... DONE
[13:34:34.161]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:34.161]  - seeds: <none>
[13:34:34.161]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.161] getGlobalsAndPackages() ...
[13:34:34.161] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.161] Resolving globals: FALSE
[13:34:34.162] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:34.162] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.188] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.188] 
[13:34:34.188] getGlobalsAndPackages() ... DONE
[13:34:34.189] run() for ‘Future’ ...
[13:34:34.189] - state: ‘created’
[13:34:34.189] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.189] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.189] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.189]   - Field: ‘label’
[13:34:34.190]   - Field: ‘local’
[13:34:34.190]   - Field: ‘owner’
[13:34:34.190]   - Field: ‘envir’
[13:34:34.190]   - Field: ‘packages’
[13:34:34.190]   - Field: ‘gc’
[13:34:34.190]   - Field: ‘conditions’
[13:34:34.190]   - Field: ‘expr’
[13:34:34.190]   - Field: ‘uuid’
[13:34:34.191]   - Field: ‘seed’
[13:34:34.191]   - Field: ‘version’
[13:34:34.191]   - Field: ‘result’
[13:34:34.191]   - Field: ‘asynchronous’
[13:34:34.191]   - Field: ‘calls’
[13:34:34.191]   - Field: ‘globals’
[13:34:34.191]   - Field: ‘stdout’
[13:34:34.191]   - Field: ‘earlySignal’
[13:34:34.191]   - Field: ‘lazy’
[13:34:34.191]   - Field: ‘state’
[13:34:34.191] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.192] - Launch lazy future ...
[13:34:34.192] Packages needed by the future expression (n = 0): <none>
[13:34:34.192] Packages needed by future strategies (n = 0): <none>
[13:34:34.192] {
[13:34:34.192]     {
[13:34:34.192]         {
[13:34:34.192]             ...future.startTime <- base::Sys.time()
[13:34:34.192]             {
[13:34:34.192]                 {
[13:34:34.192]                   {
[13:34:34.192]                     base::local({
[13:34:34.192]                       has_future <- base::requireNamespace("future", 
[13:34:34.192]                         quietly = TRUE)
[13:34:34.192]                       if (has_future) {
[13:34:34.192]                         ns <- base::getNamespace("future")
[13:34:34.192]                         version <- ns[[".package"]][["version"]]
[13:34:34.192]                         if (is.null(version)) 
[13:34:34.192]                           version <- utils::packageVersion("future")
[13:34:34.192]                       }
[13:34:34.192]                       else {
[13:34:34.192]                         version <- NULL
[13:34:34.192]                       }
[13:34:34.192]                       if (!has_future || version < "1.8.0") {
[13:34:34.192]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.192]                           "", base::R.version$version.string), 
[13:34:34.192]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.192]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.192]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.192]                             "release", "version")], collapse = " "), 
[13:34:34.192]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.192]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.192]                           info)
[13:34:34.192]                         info <- base::paste(info, collapse = "; ")
[13:34:34.192]                         if (!has_future) {
[13:34:34.192]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.192]                             info)
[13:34:34.192]                         }
[13:34:34.192]                         else {
[13:34:34.192]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.192]                             info, version)
[13:34:34.192]                         }
[13:34:34.192]                         base::stop(msg)
[13:34:34.192]                       }
[13:34:34.192]                     })
[13:34:34.192]                   }
[13:34:34.192]                   ...future.strategy.old <- future::plan("list")
[13:34:34.192]                   options(future.plan = NULL)
[13:34:34.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.192]                 }
[13:34:34.192]                 ...future.workdir <- getwd()
[13:34:34.192]             }
[13:34:34.192]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.192]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.192]         }
[13:34:34.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.192]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:34.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.192]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.192]             base::names(...future.oldOptions))
[13:34:34.192]     }
[13:34:34.192]     if (FALSE) {
[13:34:34.192]     }
[13:34:34.192]     else {
[13:34:34.192]         if (TRUE) {
[13:34:34.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.192]                 open = "w")
[13:34:34.192]         }
[13:34:34.192]         else {
[13:34:34.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.192]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.192]         }
[13:34:34.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.192]             base::sink(type = "output", split = FALSE)
[13:34:34.192]             base::close(...future.stdout)
[13:34:34.192]         }, add = TRUE)
[13:34:34.192]     }
[13:34:34.192]     ...future.frame <- base::sys.nframe()
[13:34:34.192]     ...future.conditions <- base::list()
[13:34:34.192]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.192]     if (FALSE) {
[13:34:34.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.192]     }
[13:34:34.192]     ...future.result <- base::tryCatch({
[13:34:34.192]         base::withCallingHandlers({
[13:34:34.192]             ...future.value <- base::withVisible(base::local({
[13:34:34.192]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.192]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.192]                   ...future.globals.maxSize)) {
[13:34:34.192]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.192]                   on.exit(options(oopts), add = TRUE)
[13:34:34.192]                 }
[13:34:34.192]                 {
[13:34:34.192]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.192]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.192]                     USE.NAMES = FALSE)
[13:34:34.192]                   do.call(mapply, args = args)
[13:34:34.192]                 }
[13:34:34.192]             }))
[13:34:34.192]             future::FutureResult(value = ...future.value$value, 
[13:34:34.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.192]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.192]                     ...future.globalenv.names))
[13:34:34.192]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.192]         }, condition = base::local({
[13:34:34.192]             c <- base::c
[13:34:34.192]             inherits <- base::inherits
[13:34:34.192]             invokeRestart <- base::invokeRestart
[13:34:34.192]             length <- base::length
[13:34:34.192]             list <- base::list
[13:34:34.192]             seq.int <- base::seq.int
[13:34:34.192]             signalCondition <- base::signalCondition
[13:34:34.192]             sys.calls <- base::sys.calls
[13:34:34.192]             `[[` <- base::`[[`
[13:34:34.192]             `+` <- base::`+`
[13:34:34.192]             `<<-` <- base::`<<-`
[13:34:34.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.192]                   3L)]
[13:34:34.192]             }
[13:34:34.192]             function(cond) {
[13:34:34.192]                 is_error <- inherits(cond, "error")
[13:34:34.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.192]                   NULL)
[13:34:34.192]                 if (is_error) {
[13:34:34.192]                   sessionInformation <- function() {
[13:34:34.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.192]                       search = base::search(), system = base::Sys.info())
[13:34:34.192]                   }
[13:34:34.192]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.192]                     cond$call), session = sessionInformation(), 
[13:34:34.192]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.192]                   signalCondition(cond)
[13:34:34.192]                 }
[13:34:34.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.192]                 "immediateCondition"))) {
[13:34:34.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.192]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.192]                   if (TRUE && !signal) {
[13:34:34.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.192]                     {
[13:34:34.192]                       inherits <- base::inherits
[13:34:34.192]                       invokeRestart <- base::invokeRestart
[13:34:34.192]                       is.null <- base::is.null
[13:34:34.192]                       muffled <- FALSE
[13:34:34.192]                       if (inherits(cond, "message")) {
[13:34:34.192]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.192]                         if (muffled) 
[13:34:34.192]                           invokeRestart("muffleMessage")
[13:34:34.192]                       }
[13:34:34.192]                       else if (inherits(cond, "warning")) {
[13:34:34.192]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.192]                         if (muffled) 
[13:34:34.192]                           invokeRestart("muffleWarning")
[13:34:34.192]                       }
[13:34:34.192]                       else if (inherits(cond, "condition")) {
[13:34:34.192]                         if (!is.null(pattern)) {
[13:34:34.192]                           computeRestarts <- base::computeRestarts
[13:34:34.192]                           grepl <- base::grepl
[13:34:34.192]                           restarts <- computeRestarts(cond)
[13:34:34.192]                           for (restart in restarts) {
[13:34:34.192]                             name <- restart$name
[13:34:34.192]                             if (is.null(name)) 
[13:34:34.192]                               next
[13:34:34.192]                             if (!grepl(pattern, name)) 
[13:34:34.192]                               next
[13:34:34.192]                             invokeRestart(restart)
[13:34:34.192]                             muffled <- TRUE
[13:34:34.192]                             break
[13:34:34.192]                           }
[13:34:34.192]                         }
[13:34:34.192]                       }
[13:34:34.192]                       invisible(muffled)
[13:34:34.192]                     }
[13:34:34.192]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.192]                   }
[13:34:34.192]                 }
[13:34:34.192]                 else {
[13:34:34.192]                   if (TRUE) {
[13:34:34.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.192]                     {
[13:34:34.192]                       inherits <- base::inherits
[13:34:34.192]                       invokeRestart <- base::invokeRestart
[13:34:34.192]                       is.null <- base::is.null
[13:34:34.192]                       muffled <- FALSE
[13:34:34.192]                       if (inherits(cond, "message")) {
[13:34:34.192]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.192]                         if (muffled) 
[13:34:34.192]                           invokeRestart("muffleMessage")
[13:34:34.192]                       }
[13:34:34.192]                       else if (inherits(cond, "warning")) {
[13:34:34.192]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.192]                         if (muffled) 
[13:34:34.192]                           invokeRestart("muffleWarning")
[13:34:34.192]                       }
[13:34:34.192]                       else if (inherits(cond, "condition")) {
[13:34:34.192]                         if (!is.null(pattern)) {
[13:34:34.192]                           computeRestarts <- base::computeRestarts
[13:34:34.192]                           grepl <- base::grepl
[13:34:34.192]                           restarts <- computeRestarts(cond)
[13:34:34.192]                           for (restart in restarts) {
[13:34:34.192]                             name <- restart$name
[13:34:34.192]                             if (is.null(name)) 
[13:34:34.192]                               next
[13:34:34.192]                             if (!grepl(pattern, name)) 
[13:34:34.192]                               next
[13:34:34.192]                             invokeRestart(restart)
[13:34:34.192]                             muffled <- TRUE
[13:34:34.192]                             break
[13:34:34.192]                           }
[13:34:34.192]                         }
[13:34:34.192]                       }
[13:34:34.192]                       invisible(muffled)
[13:34:34.192]                     }
[13:34:34.192]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.192]                   }
[13:34:34.192]                 }
[13:34:34.192]             }
[13:34:34.192]         }))
[13:34:34.192]     }, error = function(ex) {
[13:34:34.192]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.192]                 ...future.rng), started = ...future.startTime, 
[13:34:34.192]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.192]             version = "1.8"), class = "FutureResult")
[13:34:34.192]     }, finally = {
[13:34:34.192]         if (!identical(...future.workdir, getwd())) 
[13:34:34.192]             setwd(...future.workdir)
[13:34:34.192]         {
[13:34:34.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.192]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.192]             }
[13:34:34.192]             base::options(...future.oldOptions)
[13:34:34.192]             if (.Platform$OS.type == "windows") {
[13:34:34.192]                 old_names <- names(...future.oldEnvVars)
[13:34:34.192]                 envs <- base::Sys.getenv()
[13:34:34.192]                 names <- names(envs)
[13:34:34.192]                 common <- intersect(names, old_names)
[13:34:34.192]                 added <- setdiff(names, old_names)
[13:34:34.192]                 removed <- setdiff(old_names, names)
[13:34:34.192]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.192]                   envs[common]]
[13:34:34.192]                 NAMES <- toupper(changed)
[13:34:34.192]                 args <- list()
[13:34:34.192]                 for (kk in seq_along(NAMES)) {
[13:34:34.192]                   name <- changed[[kk]]
[13:34:34.192]                   NAME <- NAMES[[kk]]
[13:34:34.192]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.192]                     next
[13:34:34.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.192]                 }
[13:34:34.192]                 NAMES <- toupper(added)
[13:34:34.192]                 for (kk in seq_along(NAMES)) {
[13:34:34.192]                   name <- added[[kk]]
[13:34:34.192]                   NAME <- NAMES[[kk]]
[13:34:34.192]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.192]                     next
[13:34:34.192]                   args[[name]] <- ""
[13:34:34.192]                 }
[13:34:34.192]                 NAMES <- toupper(removed)
[13:34:34.192]                 for (kk in seq_along(NAMES)) {
[13:34:34.192]                   name <- removed[[kk]]
[13:34:34.192]                   NAME <- NAMES[[kk]]
[13:34:34.192]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.192]                     next
[13:34:34.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.192]                 }
[13:34:34.192]                 if (length(args) > 0) 
[13:34:34.192]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.192]             }
[13:34:34.192]             else {
[13:34:34.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.192]             }
[13:34:34.192]             {
[13:34:34.192]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.192]                   0L) {
[13:34:34.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.192]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.192]                   base::options(opts)
[13:34:34.192]                 }
[13:34:34.192]                 {
[13:34:34.192]                   {
[13:34:34.192]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.192]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.192]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.192]                       inherits = FALSE)
[13:34:34.192]                     NULL
[13:34:34.192]                   }
[13:34:34.192]                   options(future.plan = NULL)
[13:34:34.192]                   if (is.na(NA_character_)) 
[13:34:34.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.192]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.192]                     .init = FALSE)
[13:34:34.192]                 }
[13:34:34.192]             }
[13:34:34.192]         }
[13:34:34.192]     })
[13:34:34.192]     if (TRUE) {
[13:34:34.192]         base::sink(type = "output", split = FALSE)
[13:34:34.192]         if (TRUE) {
[13:34:34.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.192]         }
[13:34:34.192]         else {
[13:34:34.192]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.192]         }
[13:34:34.192]         base::close(...future.stdout)
[13:34:34.192]         ...future.stdout <- NULL
[13:34:34.192]     }
[13:34:34.192]     ...future.result$conditions <- ...future.conditions
[13:34:34.192]     ...future.result$finished <- base::Sys.time()
[13:34:34.192]     ...future.result
[13:34:34.192] }
[13:34:34.194] assign_globals() ...
[13:34:34.194] List of 5
[13:34:34.194]  $ ...future.FUN            :function (C, k)  
[13:34:34.194]  $ MoreArgs                 : NULL
[13:34:34.194]  $ ...future.elements_ii    :List of 2
[13:34:34.194]   ..$ :List of 1
[13:34:34.194]   .. ..$ : chr "C"
[13:34:34.194]   ..$ :List of 1
[13:34:34.194]   .. ..$ : int 3
[13:34:34.194]  $ ...future.seeds_ii       : NULL
[13:34:34.194]  $ ...future.globals.maxSize: NULL
[13:34:34.194]  - attr(*, "where")=List of 5
[13:34:34.194]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.194]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.194]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.194]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.194]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.194]  - attr(*, "resolved")= logi FALSE
[13:34:34.194]  - attr(*, "total_size")= num 3488
[13:34:34.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.194]  - attr(*, "already-done")= logi TRUE
[13:34:34.199] - reassign environment for ‘...future.FUN’
[13:34:34.199] - copied ‘...future.FUN’ to environment
[13:34:34.199] - copied ‘MoreArgs’ to environment
[13:34:34.199] - copied ‘...future.elements_ii’ to environment
[13:34:34.199] - copied ‘...future.seeds_ii’ to environment
[13:34:34.199] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.200] assign_globals() ... done
[13:34:34.200] plan(): Setting new future strategy stack:
[13:34:34.200] List of future strategies:
[13:34:34.200] 1. sequential:
[13:34:34.200]    - args: function (..., envir = parent.frame())
[13:34:34.200]    - tweaked: FALSE
[13:34:34.200]    - call: NULL
[13:34:34.200] plan(): nbrOfWorkers() = 1
[13:34:34.201] plan(): Setting new future strategy stack:
[13:34:34.201] List of future strategies:
[13:34:34.201] 1. sequential:
[13:34:34.201]    - args: function (..., envir = parent.frame())
[13:34:34.201]    - tweaked: FALSE
[13:34:34.201]    - call: plan(strategy)
[13:34:34.201] plan(): nbrOfWorkers() = 1
[13:34:34.202] SequentialFuture started (and completed)
[13:34:34.202] - Launch lazy future ... done
[13:34:34.202] run() for ‘SequentialFuture’ ... done
[13:34:34.202] Created future:
[13:34:34.202] SequentialFuture:
[13:34:34.202] Label: ‘future_mapply-3’
[13:34:34.202] Expression:
[13:34:34.202] {
[13:34:34.202]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.202]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.202]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.202]         on.exit(options(oopts), add = TRUE)
[13:34:34.202]     }
[13:34:34.202]     {
[13:34:34.202]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.202]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.202]         do.call(mapply, args = args)
[13:34:34.202]     }
[13:34:34.202] }
[13:34:34.202] Lazy evaluation: FALSE
[13:34:34.202] Asynchronous evaluation: FALSE
[13:34:34.202] Local evaluation: TRUE
[13:34:34.202] Environment: R_GlobalEnv
[13:34:34.202] Capture standard output: TRUE
[13:34:34.202] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.202] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.202] Packages: <none>
[13:34:34.202] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.202] Resolved: TRUE
[13:34:34.202] Value: 112 bytes of class ‘list’
[13:34:34.202] Early signaling: FALSE
[13:34:34.202] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.202] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.203] Chunk #3 of 5 ... DONE
[13:34:34.203] Chunk #4 of 5 ...
[13:34:34.203]  - Finding globals in '...' for chunk #4 ...
[13:34:34.203] getGlobalsAndPackages() ...
[13:34:34.203] Searching for globals...
[13:34:34.204] 
[13:34:34.204] Searching for globals ... DONE
[13:34:34.204] - globals: [0] <none>
[13:34:34.204] getGlobalsAndPackages() ... DONE
[13:34:34.204]    + additional globals found: [n=0] 
[13:34:34.204]    + additional namespaces needed: [n=0] 
[13:34:34.204]  - Finding globals in '...' for chunk #4 ... DONE
[13:34:34.204]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:34.204]  - seeds: <none>
[13:34:34.204]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.204] getGlobalsAndPackages() ...
[13:34:34.205] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.205] Resolving globals: FALSE
[13:34:34.205] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:34.206] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.206] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.206] 
[13:34:34.206] getGlobalsAndPackages() ... DONE
[13:34:34.206] run() for ‘Future’ ...
[13:34:34.206] - state: ‘created’
[13:34:34.206] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.207] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.207] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.207]   - Field: ‘label’
[13:34:34.207]   - Field: ‘local’
[13:34:34.207]   - Field: ‘owner’
[13:34:34.207]   - Field: ‘envir’
[13:34:34.207]   - Field: ‘packages’
[13:34:34.207]   - Field: ‘gc’
[13:34:34.207]   - Field: ‘conditions’
[13:34:34.207]   - Field: ‘expr’
[13:34:34.208]   - Field: ‘uuid’
[13:34:34.208]   - Field: ‘seed’
[13:34:34.208]   - Field: ‘version’
[13:34:34.208]   - Field: ‘result’
[13:34:34.208]   - Field: ‘asynchronous’
[13:34:34.208]   - Field: ‘calls’
[13:34:34.208]   - Field: ‘globals’
[13:34:34.208]   - Field: ‘stdout’
[13:34:34.208]   - Field: ‘earlySignal’
[13:34:34.208]   - Field: ‘lazy’
[13:34:34.208]   - Field: ‘state’
[13:34:34.208] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.209] - Launch lazy future ...
[13:34:34.209] Packages needed by the future expression (n = 0): <none>
[13:34:34.209] Packages needed by future strategies (n = 0): <none>
[13:34:34.209] {
[13:34:34.209]     {
[13:34:34.209]         {
[13:34:34.209]             ...future.startTime <- base::Sys.time()
[13:34:34.209]             {
[13:34:34.209]                 {
[13:34:34.209]                   {
[13:34:34.209]                     base::local({
[13:34:34.209]                       has_future <- base::requireNamespace("future", 
[13:34:34.209]                         quietly = TRUE)
[13:34:34.209]                       if (has_future) {
[13:34:34.209]                         ns <- base::getNamespace("future")
[13:34:34.209]                         version <- ns[[".package"]][["version"]]
[13:34:34.209]                         if (is.null(version)) 
[13:34:34.209]                           version <- utils::packageVersion("future")
[13:34:34.209]                       }
[13:34:34.209]                       else {
[13:34:34.209]                         version <- NULL
[13:34:34.209]                       }
[13:34:34.209]                       if (!has_future || version < "1.8.0") {
[13:34:34.209]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.209]                           "", base::R.version$version.string), 
[13:34:34.209]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.209]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.209]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.209]                             "release", "version")], collapse = " "), 
[13:34:34.209]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.209]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.209]                           info)
[13:34:34.209]                         info <- base::paste(info, collapse = "; ")
[13:34:34.209]                         if (!has_future) {
[13:34:34.209]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.209]                             info)
[13:34:34.209]                         }
[13:34:34.209]                         else {
[13:34:34.209]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.209]                             info, version)
[13:34:34.209]                         }
[13:34:34.209]                         base::stop(msg)
[13:34:34.209]                       }
[13:34:34.209]                     })
[13:34:34.209]                   }
[13:34:34.209]                   ...future.strategy.old <- future::plan("list")
[13:34:34.209]                   options(future.plan = NULL)
[13:34:34.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.209]                 }
[13:34:34.209]                 ...future.workdir <- getwd()
[13:34:34.209]             }
[13:34:34.209]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.209]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.209]         }
[13:34:34.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.209]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:34.209]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.209]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.209]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.209]             base::names(...future.oldOptions))
[13:34:34.209]     }
[13:34:34.209]     if (FALSE) {
[13:34:34.209]     }
[13:34:34.209]     else {
[13:34:34.209]         if (TRUE) {
[13:34:34.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.209]                 open = "w")
[13:34:34.209]         }
[13:34:34.209]         else {
[13:34:34.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.209]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.209]         }
[13:34:34.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.209]             base::sink(type = "output", split = FALSE)
[13:34:34.209]             base::close(...future.stdout)
[13:34:34.209]         }, add = TRUE)
[13:34:34.209]     }
[13:34:34.209]     ...future.frame <- base::sys.nframe()
[13:34:34.209]     ...future.conditions <- base::list()
[13:34:34.209]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.209]     if (FALSE) {
[13:34:34.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.209]     }
[13:34:34.209]     ...future.result <- base::tryCatch({
[13:34:34.209]         base::withCallingHandlers({
[13:34:34.209]             ...future.value <- base::withVisible(base::local({
[13:34:34.209]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.209]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.209]                   ...future.globals.maxSize)) {
[13:34:34.209]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.209]                   on.exit(options(oopts), add = TRUE)
[13:34:34.209]                 }
[13:34:34.209]                 {
[13:34:34.209]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.209]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.209]                     USE.NAMES = FALSE)
[13:34:34.209]                   do.call(mapply, args = args)
[13:34:34.209]                 }
[13:34:34.209]             }))
[13:34:34.209]             future::FutureResult(value = ...future.value$value, 
[13:34:34.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.209]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.209]                     ...future.globalenv.names))
[13:34:34.209]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.209]         }, condition = base::local({
[13:34:34.209]             c <- base::c
[13:34:34.209]             inherits <- base::inherits
[13:34:34.209]             invokeRestart <- base::invokeRestart
[13:34:34.209]             length <- base::length
[13:34:34.209]             list <- base::list
[13:34:34.209]             seq.int <- base::seq.int
[13:34:34.209]             signalCondition <- base::signalCondition
[13:34:34.209]             sys.calls <- base::sys.calls
[13:34:34.209]             `[[` <- base::`[[`
[13:34:34.209]             `+` <- base::`+`
[13:34:34.209]             `<<-` <- base::`<<-`
[13:34:34.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.209]                   3L)]
[13:34:34.209]             }
[13:34:34.209]             function(cond) {
[13:34:34.209]                 is_error <- inherits(cond, "error")
[13:34:34.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.209]                   NULL)
[13:34:34.209]                 if (is_error) {
[13:34:34.209]                   sessionInformation <- function() {
[13:34:34.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.209]                       search = base::search(), system = base::Sys.info())
[13:34:34.209]                   }
[13:34:34.209]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.209]                     cond$call), session = sessionInformation(), 
[13:34:34.209]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.209]                   signalCondition(cond)
[13:34:34.209]                 }
[13:34:34.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.209]                 "immediateCondition"))) {
[13:34:34.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.209]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.209]                   if (TRUE && !signal) {
[13:34:34.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.209]                     {
[13:34:34.209]                       inherits <- base::inherits
[13:34:34.209]                       invokeRestart <- base::invokeRestart
[13:34:34.209]                       is.null <- base::is.null
[13:34:34.209]                       muffled <- FALSE
[13:34:34.209]                       if (inherits(cond, "message")) {
[13:34:34.209]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.209]                         if (muffled) 
[13:34:34.209]                           invokeRestart("muffleMessage")
[13:34:34.209]                       }
[13:34:34.209]                       else if (inherits(cond, "warning")) {
[13:34:34.209]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.209]                         if (muffled) 
[13:34:34.209]                           invokeRestart("muffleWarning")
[13:34:34.209]                       }
[13:34:34.209]                       else if (inherits(cond, "condition")) {
[13:34:34.209]                         if (!is.null(pattern)) {
[13:34:34.209]                           computeRestarts <- base::computeRestarts
[13:34:34.209]                           grepl <- base::grepl
[13:34:34.209]                           restarts <- computeRestarts(cond)
[13:34:34.209]                           for (restart in restarts) {
[13:34:34.209]                             name <- restart$name
[13:34:34.209]                             if (is.null(name)) 
[13:34:34.209]                               next
[13:34:34.209]                             if (!grepl(pattern, name)) 
[13:34:34.209]                               next
[13:34:34.209]                             invokeRestart(restart)
[13:34:34.209]                             muffled <- TRUE
[13:34:34.209]                             break
[13:34:34.209]                           }
[13:34:34.209]                         }
[13:34:34.209]                       }
[13:34:34.209]                       invisible(muffled)
[13:34:34.209]                     }
[13:34:34.209]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.209]                   }
[13:34:34.209]                 }
[13:34:34.209]                 else {
[13:34:34.209]                   if (TRUE) {
[13:34:34.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.209]                     {
[13:34:34.209]                       inherits <- base::inherits
[13:34:34.209]                       invokeRestart <- base::invokeRestart
[13:34:34.209]                       is.null <- base::is.null
[13:34:34.209]                       muffled <- FALSE
[13:34:34.209]                       if (inherits(cond, "message")) {
[13:34:34.209]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.209]                         if (muffled) 
[13:34:34.209]                           invokeRestart("muffleMessage")
[13:34:34.209]                       }
[13:34:34.209]                       else if (inherits(cond, "warning")) {
[13:34:34.209]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.209]                         if (muffled) 
[13:34:34.209]                           invokeRestart("muffleWarning")
[13:34:34.209]                       }
[13:34:34.209]                       else if (inherits(cond, "condition")) {
[13:34:34.209]                         if (!is.null(pattern)) {
[13:34:34.209]                           computeRestarts <- base::computeRestarts
[13:34:34.209]                           grepl <- base::grepl
[13:34:34.209]                           restarts <- computeRestarts(cond)
[13:34:34.209]                           for (restart in restarts) {
[13:34:34.209]                             name <- restart$name
[13:34:34.209]                             if (is.null(name)) 
[13:34:34.209]                               next
[13:34:34.209]                             if (!grepl(pattern, name)) 
[13:34:34.209]                               next
[13:34:34.209]                             invokeRestart(restart)
[13:34:34.209]                             muffled <- TRUE
[13:34:34.209]                             break
[13:34:34.209]                           }
[13:34:34.209]                         }
[13:34:34.209]                       }
[13:34:34.209]                       invisible(muffled)
[13:34:34.209]                     }
[13:34:34.209]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.209]                   }
[13:34:34.209]                 }
[13:34:34.209]             }
[13:34:34.209]         }))
[13:34:34.209]     }, error = function(ex) {
[13:34:34.209]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.209]                 ...future.rng), started = ...future.startTime, 
[13:34:34.209]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.209]             version = "1.8"), class = "FutureResult")
[13:34:34.209]     }, finally = {
[13:34:34.209]         if (!identical(...future.workdir, getwd())) 
[13:34:34.209]             setwd(...future.workdir)
[13:34:34.209]         {
[13:34:34.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.209]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.209]             }
[13:34:34.209]             base::options(...future.oldOptions)
[13:34:34.209]             if (.Platform$OS.type == "windows") {
[13:34:34.209]                 old_names <- names(...future.oldEnvVars)
[13:34:34.209]                 envs <- base::Sys.getenv()
[13:34:34.209]                 names <- names(envs)
[13:34:34.209]                 common <- intersect(names, old_names)
[13:34:34.209]                 added <- setdiff(names, old_names)
[13:34:34.209]                 removed <- setdiff(old_names, names)
[13:34:34.209]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.209]                   envs[common]]
[13:34:34.209]                 NAMES <- toupper(changed)
[13:34:34.209]                 args <- list()
[13:34:34.209]                 for (kk in seq_along(NAMES)) {
[13:34:34.209]                   name <- changed[[kk]]
[13:34:34.209]                   NAME <- NAMES[[kk]]
[13:34:34.209]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.209]                     next
[13:34:34.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.209]                 }
[13:34:34.209]                 NAMES <- toupper(added)
[13:34:34.209]                 for (kk in seq_along(NAMES)) {
[13:34:34.209]                   name <- added[[kk]]
[13:34:34.209]                   NAME <- NAMES[[kk]]
[13:34:34.209]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.209]                     next
[13:34:34.209]                   args[[name]] <- ""
[13:34:34.209]                 }
[13:34:34.209]                 NAMES <- toupper(removed)
[13:34:34.209]                 for (kk in seq_along(NAMES)) {
[13:34:34.209]                   name <- removed[[kk]]
[13:34:34.209]                   NAME <- NAMES[[kk]]
[13:34:34.209]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.209]                     next
[13:34:34.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.209]                 }
[13:34:34.209]                 if (length(args) > 0) 
[13:34:34.209]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.209]             }
[13:34:34.209]             else {
[13:34:34.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.209]             }
[13:34:34.209]             {
[13:34:34.209]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.209]                   0L) {
[13:34:34.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.209]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.209]                   base::options(opts)
[13:34:34.209]                 }
[13:34:34.209]                 {
[13:34:34.209]                   {
[13:34:34.209]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.209]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.209]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.209]                       inherits = FALSE)
[13:34:34.209]                     NULL
[13:34:34.209]                   }
[13:34:34.209]                   options(future.plan = NULL)
[13:34:34.209]                   if (is.na(NA_character_)) 
[13:34:34.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.209]                     .init = FALSE)
[13:34:34.209]                 }
[13:34:34.209]             }
[13:34:34.209]         }
[13:34:34.209]     })
[13:34:34.209]     if (TRUE) {
[13:34:34.209]         base::sink(type = "output", split = FALSE)
[13:34:34.209]         if (TRUE) {
[13:34:34.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.209]         }
[13:34:34.209]         else {
[13:34:34.209]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.209]         }
[13:34:34.209]         base::close(...future.stdout)
[13:34:34.209]         ...future.stdout <- NULL
[13:34:34.209]     }
[13:34:34.209]     ...future.result$conditions <- ...future.conditions
[13:34:34.209]     ...future.result$finished <- base::Sys.time()
[13:34:34.209]     ...future.result
[13:34:34.209] }
[13:34:34.211] assign_globals() ...
[13:34:34.211] List of 5
[13:34:34.211]  $ ...future.FUN            :function (C, k)  
[13:34:34.211]  $ MoreArgs                 : NULL
[13:34:34.211]  $ ...future.elements_ii    :List of 2
[13:34:34.211]   ..$ :List of 1
[13:34:34.211]   .. ..$ : chr "D"
[13:34:34.211]   ..$ :List of 1
[13:34:34.211]   .. ..$ : int 2
[13:34:34.211]  $ ...future.seeds_ii       : NULL
[13:34:34.211]  $ ...future.globals.maxSize: NULL
[13:34:34.211]  - attr(*, "where")=List of 5
[13:34:34.211]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.211]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.211]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.211]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.211]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.211]  - attr(*, "resolved")= logi FALSE
[13:34:34.211]  - attr(*, "total_size")= num 3488
[13:34:34.211]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.211]  - attr(*, "already-done")= logi TRUE
[13:34:34.217] - reassign environment for ‘...future.FUN’
[13:34:34.217] - copied ‘...future.FUN’ to environment
[13:34:34.217] - copied ‘MoreArgs’ to environment
[13:34:34.217] - copied ‘...future.elements_ii’ to environment
[13:34:34.217] - copied ‘...future.seeds_ii’ to environment
[13:34:34.217] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.217] assign_globals() ... done
[13:34:34.217] plan(): Setting new future strategy stack:
[13:34:34.218] List of future strategies:
[13:34:34.218] 1. sequential:
[13:34:34.218]    - args: function (..., envir = parent.frame())
[13:34:34.218]    - tweaked: FALSE
[13:34:34.218]    - call: NULL
[13:34:34.218] plan(): nbrOfWorkers() = 1
[13:34:34.219] plan(): Setting new future strategy stack:
[13:34:34.219] List of future strategies:
[13:34:34.219] 1. sequential:
[13:34:34.219]    - args: function (..., envir = parent.frame())
[13:34:34.219]    - tweaked: FALSE
[13:34:34.219]    - call: plan(strategy)
[13:34:34.219] plan(): nbrOfWorkers() = 1
[13:34:34.219] SequentialFuture started (and completed)
[13:34:34.219] - Launch lazy future ... done
[13:34:34.219] run() for ‘SequentialFuture’ ... done
[13:34:34.219] Created future:
[13:34:34.220] SequentialFuture:
[13:34:34.220] Label: ‘future_mapply-4’
[13:34:34.220] Expression:
[13:34:34.220] {
[13:34:34.220]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.220]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.220]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.220]         on.exit(options(oopts), add = TRUE)
[13:34:34.220]     }
[13:34:34.220]     {
[13:34:34.220]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.220]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.220]         do.call(mapply, args = args)
[13:34:34.220]     }
[13:34:34.220] }
[13:34:34.220] Lazy evaluation: FALSE
[13:34:34.220] Asynchronous evaluation: FALSE
[13:34:34.220] Local evaluation: TRUE
[13:34:34.220] Environment: R_GlobalEnv
[13:34:34.220] Capture standard output: TRUE
[13:34:34.220] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.220] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.220] Packages: <none>
[13:34:34.220] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.220] Resolved: TRUE
[13:34:34.220] Value: 112 bytes of class ‘list’
[13:34:34.220] Early signaling: FALSE
[13:34:34.220] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.220] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.220] Chunk #4 of 5 ... DONE
[13:34:34.220] Chunk #5 of 5 ...
[13:34:34.221]  - Finding globals in '...' for chunk #5 ...
[13:34:34.221] getGlobalsAndPackages() ...
[13:34:34.221] Searching for globals...
[13:34:34.221] 
[13:34:34.221] Searching for globals ... DONE
[13:34:34.221] - globals: [0] <none>
[13:34:34.221] getGlobalsAndPackages() ... DONE
[13:34:34.221]    + additional globals found: [n=0] 
[13:34:34.221]    + additional namespaces needed: [n=0] 
[13:34:34.222]  - Finding globals in '...' for chunk #5 ... DONE
[13:34:34.222]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:34.222]  - seeds: <none>
[13:34:34.222]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.222] getGlobalsAndPackages() ...
[13:34:34.222] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.222] Resolving globals: FALSE
[13:34:34.223] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:34.223] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.223] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.223] 
[13:34:34.223] getGlobalsAndPackages() ... DONE
[13:34:34.223] run() for ‘Future’ ...
[13:34:34.224] - state: ‘created’
[13:34:34.224] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.224] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.224]   - Field: ‘label’
[13:34:34.224]   - Field: ‘local’
[13:34:34.224]   - Field: ‘owner’
[13:34:34.224]   - Field: ‘envir’
[13:34:34.225]   - Field: ‘packages’
[13:34:34.225]   - Field: ‘gc’
[13:34:34.225]   - Field: ‘conditions’
[13:34:34.225]   - Field: ‘expr’
[13:34:34.225]   - Field: ‘uuid’
[13:34:34.225]   - Field: ‘seed’
[13:34:34.225]   - Field: ‘version’
[13:34:34.225]   - Field: ‘result’
[13:34:34.225]   - Field: ‘asynchronous’
[13:34:34.225]   - Field: ‘calls’
[13:34:34.225]   - Field: ‘globals’
[13:34:34.225]   - Field: ‘stdout’
[13:34:34.226]   - Field: ‘earlySignal’
[13:34:34.226]   - Field: ‘lazy’
[13:34:34.226]   - Field: ‘state’
[13:34:34.226] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.226] - Launch lazy future ...
[13:34:34.226] Packages needed by the future expression (n = 0): <none>
[13:34:34.226] Packages needed by future strategies (n = 0): <none>
[13:34:34.227] {
[13:34:34.227]     {
[13:34:34.227]         {
[13:34:34.227]             ...future.startTime <- base::Sys.time()
[13:34:34.227]             {
[13:34:34.227]                 {
[13:34:34.227]                   {
[13:34:34.227]                     base::local({
[13:34:34.227]                       has_future <- base::requireNamespace("future", 
[13:34:34.227]                         quietly = TRUE)
[13:34:34.227]                       if (has_future) {
[13:34:34.227]                         ns <- base::getNamespace("future")
[13:34:34.227]                         version <- ns[[".package"]][["version"]]
[13:34:34.227]                         if (is.null(version)) 
[13:34:34.227]                           version <- utils::packageVersion("future")
[13:34:34.227]                       }
[13:34:34.227]                       else {
[13:34:34.227]                         version <- NULL
[13:34:34.227]                       }
[13:34:34.227]                       if (!has_future || version < "1.8.0") {
[13:34:34.227]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.227]                           "", base::R.version$version.string), 
[13:34:34.227]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.227]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.227]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.227]                             "release", "version")], collapse = " "), 
[13:34:34.227]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.227]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.227]                           info)
[13:34:34.227]                         info <- base::paste(info, collapse = "; ")
[13:34:34.227]                         if (!has_future) {
[13:34:34.227]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.227]                             info)
[13:34:34.227]                         }
[13:34:34.227]                         else {
[13:34:34.227]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.227]                             info, version)
[13:34:34.227]                         }
[13:34:34.227]                         base::stop(msg)
[13:34:34.227]                       }
[13:34:34.227]                     })
[13:34:34.227]                   }
[13:34:34.227]                   ...future.strategy.old <- future::plan("list")
[13:34:34.227]                   options(future.plan = NULL)
[13:34:34.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.227]                 }
[13:34:34.227]                 ...future.workdir <- getwd()
[13:34:34.227]             }
[13:34:34.227]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.227]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.227]         }
[13:34:34.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.227]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:34.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.227]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.227]             base::names(...future.oldOptions))
[13:34:34.227]     }
[13:34:34.227]     if (FALSE) {
[13:34:34.227]     }
[13:34:34.227]     else {
[13:34:34.227]         if (TRUE) {
[13:34:34.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.227]                 open = "w")
[13:34:34.227]         }
[13:34:34.227]         else {
[13:34:34.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.227]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.227]         }
[13:34:34.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.227]             base::sink(type = "output", split = FALSE)
[13:34:34.227]             base::close(...future.stdout)
[13:34:34.227]         }, add = TRUE)
[13:34:34.227]     }
[13:34:34.227]     ...future.frame <- base::sys.nframe()
[13:34:34.227]     ...future.conditions <- base::list()
[13:34:34.227]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.227]     if (FALSE) {
[13:34:34.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.227]     }
[13:34:34.227]     ...future.result <- base::tryCatch({
[13:34:34.227]         base::withCallingHandlers({
[13:34:34.227]             ...future.value <- base::withVisible(base::local({
[13:34:34.227]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.227]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.227]                   ...future.globals.maxSize)) {
[13:34:34.227]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.227]                   on.exit(options(oopts), add = TRUE)
[13:34:34.227]                 }
[13:34:34.227]                 {
[13:34:34.227]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.227]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.227]                     USE.NAMES = FALSE)
[13:34:34.227]                   do.call(mapply, args = args)
[13:34:34.227]                 }
[13:34:34.227]             }))
[13:34:34.227]             future::FutureResult(value = ...future.value$value, 
[13:34:34.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.227]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.227]                     ...future.globalenv.names))
[13:34:34.227]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.227]         }, condition = base::local({
[13:34:34.227]             c <- base::c
[13:34:34.227]             inherits <- base::inherits
[13:34:34.227]             invokeRestart <- base::invokeRestart
[13:34:34.227]             length <- base::length
[13:34:34.227]             list <- base::list
[13:34:34.227]             seq.int <- base::seq.int
[13:34:34.227]             signalCondition <- base::signalCondition
[13:34:34.227]             sys.calls <- base::sys.calls
[13:34:34.227]             `[[` <- base::`[[`
[13:34:34.227]             `+` <- base::`+`
[13:34:34.227]             `<<-` <- base::`<<-`
[13:34:34.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.227]                   3L)]
[13:34:34.227]             }
[13:34:34.227]             function(cond) {
[13:34:34.227]                 is_error <- inherits(cond, "error")
[13:34:34.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.227]                   NULL)
[13:34:34.227]                 if (is_error) {
[13:34:34.227]                   sessionInformation <- function() {
[13:34:34.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.227]                       search = base::search(), system = base::Sys.info())
[13:34:34.227]                   }
[13:34:34.227]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.227]                     cond$call), session = sessionInformation(), 
[13:34:34.227]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.227]                   signalCondition(cond)
[13:34:34.227]                 }
[13:34:34.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.227]                 "immediateCondition"))) {
[13:34:34.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.227]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.227]                   if (TRUE && !signal) {
[13:34:34.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.227]                     {
[13:34:34.227]                       inherits <- base::inherits
[13:34:34.227]                       invokeRestart <- base::invokeRestart
[13:34:34.227]                       is.null <- base::is.null
[13:34:34.227]                       muffled <- FALSE
[13:34:34.227]                       if (inherits(cond, "message")) {
[13:34:34.227]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.227]                         if (muffled) 
[13:34:34.227]                           invokeRestart("muffleMessage")
[13:34:34.227]                       }
[13:34:34.227]                       else if (inherits(cond, "warning")) {
[13:34:34.227]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.227]                         if (muffled) 
[13:34:34.227]                           invokeRestart("muffleWarning")
[13:34:34.227]                       }
[13:34:34.227]                       else if (inherits(cond, "condition")) {
[13:34:34.227]                         if (!is.null(pattern)) {
[13:34:34.227]                           computeRestarts <- base::computeRestarts
[13:34:34.227]                           grepl <- base::grepl
[13:34:34.227]                           restarts <- computeRestarts(cond)
[13:34:34.227]                           for (restart in restarts) {
[13:34:34.227]                             name <- restart$name
[13:34:34.227]                             if (is.null(name)) 
[13:34:34.227]                               next
[13:34:34.227]                             if (!grepl(pattern, name)) 
[13:34:34.227]                               next
[13:34:34.227]                             invokeRestart(restart)
[13:34:34.227]                             muffled <- TRUE
[13:34:34.227]                             break
[13:34:34.227]                           }
[13:34:34.227]                         }
[13:34:34.227]                       }
[13:34:34.227]                       invisible(muffled)
[13:34:34.227]                     }
[13:34:34.227]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.227]                   }
[13:34:34.227]                 }
[13:34:34.227]                 else {
[13:34:34.227]                   if (TRUE) {
[13:34:34.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.227]                     {
[13:34:34.227]                       inherits <- base::inherits
[13:34:34.227]                       invokeRestart <- base::invokeRestart
[13:34:34.227]                       is.null <- base::is.null
[13:34:34.227]                       muffled <- FALSE
[13:34:34.227]                       if (inherits(cond, "message")) {
[13:34:34.227]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.227]                         if (muffled) 
[13:34:34.227]                           invokeRestart("muffleMessage")
[13:34:34.227]                       }
[13:34:34.227]                       else if (inherits(cond, "warning")) {
[13:34:34.227]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.227]                         if (muffled) 
[13:34:34.227]                           invokeRestart("muffleWarning")
[13:34:34.227]                       }
[13:34:34.227]                       else if (inherits(cond, "condition")) {
[13:34:34.227]                         if (!is.null(pattern)) {
[13:34:34.227]                           computeRestarts <- base::computeRestarts
[13:34:34.227]                           grepl <- base::grepl
[13:34:34.227]                           restarts <- computeRestarts(cond)
[13:34:34.227]                           for (restart in restarts) {
[13:34:34.227]                             name <- restart$name
[13:34:34.227]                             if (is.null(name)) 
[13:34:34.227]                               next
[13:34:34.227]                             if (!grepl(pattern, name)) 
[13:34:34.227]                               next
[13:34:34.227]                             invokeRestart(restart)
[13:34:34.227]                             muffled <- TRUE
[13:34:34.227]                             break
[13:34:34.227]                           }
[13:34:34.227]                         }
[13:34:34.227]                       }
[13:34:34.227]                       invisible(muffled)
[13:34:34.227]                     }
[13:34:34.227]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.227]                   }
[13:34:34.227]                 }
[13:34:34.227]             }
[13:34:34.227]         }))
[13:34:34.227]     }, error = function(ex) {
[13:34:34.227]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.227]                 ...future.rng), started = ...future.startTime, 
[13:34:34.227]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.227]             version = "1.8"), class = "FutureResult")
[13:34:34.227]     }, finally = {
[13:34:34.227]         if (!identical(...future.workdir, getwd())) 
[13:34:34.227]             setwd(...future.workdir)
[13:34:34.227]         {
[13:34:34.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.227]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.227]             }
[13:34:34.227]             base::options(...future.oldOptions)
[13:34:34.227]             if (.Platform$OS.type == "windows") {
[13:34:34.227]                 old_names <- names(...future.oldEnvVars)
[13:34:34.227]                 envs <- base::Sys.getenv()
[13:34:34.227]                 names <- names(envs)
[13:34:34.227]                 common <- intersect(names, old_names)
[13:34:34.227]                 added <- setdiff(names, old_names)
[13:34:34.227]                 removed <- setdiff(old_names, names)
[13:34:34.227]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.227]                   envs[common]]
[13:34:34.227]                 NAMES <- toupper(changed)
[13:34:34.227]                 args <- list()
[13:34:34.227]                 for (kk in seq_along(NAMES)) {
[13:34:34.227]                   name <- changed[[kk]]
[13:34:34.227]                   NAME <- NAMES[[kk]]
[13:34:34.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.227]                     next
[13:34:34.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.227]                 }
[13:34:34.227]                 NAMES <- toupper(added)
[13:34:34.227]                 for (kk in seq_along(NAMES)) {
[13:34:34.227]                   name <- added[[kk]]
[13:34:34.227]                   NAME <- NAMES[[kk]]
[13:34:34.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.227]                     next
[13:34:34.227]                   args[[name]] <- ""
[13:34:34.227]                 }
[13:34:34.227]                 NAMES <- toupper(removed)
[13:34:34.227]                 for (kk in seq_along(NAMES)) {
[13:34:34.227]                   name <- removed[[kk]]
[13:34:34.227]                   NAME <- NAMES[[kk]]
[13:34:34.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.227]                     next
[13:34:34.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.227]                 }
[13:34:34.227]                 if (length(args) > 0) 
[13:34:34.227]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.227]             }
[13:34:34.227]             else {
[13:34:34.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.227]             }
[13:34:34.227]             {
[13:34:34.227]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.227]                   0L) {
[13:34:34.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.227]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.227]                   base::options(opts)
[13:34:34.227]                 }
[13:34:34.227]                 {
[13:34:34.227]                   {
[13:34:34.227]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.227]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.227]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.227]                       inherits = FALSE)
[13:34:34.227]                     NULL
[13:34:34.227]                   }
[13:34:34.227]                   options(future.plan = NULL)
[13:34:34.227]                   if (is.na(NA_character_)) 
[13:34:34.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.227]                     .init = FALSE)
[13:34:34.227]                 }
[13:34:34.227]             }
[13:34:34.227]         }
[13:34:34.227]     })
[13:34:34.227]     if (TRUE) {
[13:34:34.227]         base::sink(type = "output", split = FALSE)
[13:34:34.227]         if (TRUE) {
[13:34:34.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.227]         }
[13:34:34.227]         else {
[13:34:34.227]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.227]         }
[13:34:34.227]         base::close(...future.stdout)
[13:34:34.227]         ...future.stdout <- NULL
[13:34:34.227]     }
[13:34:34.227]     ...future.result$conditions <- ...future.conditions
[13:34:34.227]     ...future.result$finished <- base::Sys.time()
[13:34:34.227]     ...future.result
[13:34:34.227] }
[13:34:34.228] assign_globals() ...
[13:34:34.228] List of 5
[13:34:34.228]  $ ...future.FUN            :function (C, k)  
[13:34:34.228]  $ MoreArgs                 : NULL
[13:34:34.228]  $ ...future.elements_ii    :List of 2
[13:34:34.228]   ..$ :List of 1
[13:34:34.228]   .. ..$ : chr "E"
[13:34:34.228]   ..$ :List of 1
[13:34:34.228]   .. ..$ : int 1
[13:34:34.228]  $ ...future.seeds_ii       : NULL
[13:34:34.228]  $ ...future.globals.maxSize: NULL
[13:34:34.228]  - attr(*, "where")=List of 5
[13:34:34.228]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.228]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.228]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.228]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.228]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.228]  - attr(*, "resolved")= logi FALSE
[13:34:34.228]  - attr(*, "total_size")= num 3488
[13:34:34.228]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.228]  - attr(*, "already-done")= logi TRUE
[13:34:34.233] - reassign environment for ‘...future.FUN’
[13:34:34.233] - copied ‘...future.FUN’ to environment
[13:34:34.233] - copied ‘MoreArgs’ to environment
[13:34:34.233] - copied ‘...future.elements_ii’ to environment
[13:34:34.233] - copied ‘...future.seeds_ii’ to environment
[13:34:34.233] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.233] assign_globals() ... done
[13:34:34.234] plan(): Setting new future strategy stack:
[13:34:34.234] List of future strategies:
[13:34:34.234] 1. sequential:
[13:34:34.234]    - args: function (..., envir = parent.frame())
[13:34:34.234]    - tweaked: FALSE
[13:34:34.234]    - call: NULL
[13:34:34.234] plan(): nbrOfWorkers() = 1
[13:34:34.235] plan(): Setting new future strategy stack:
[13:34:34.235] List of future strategies:
[13:34:34.235] 1. sequential:
[13:34:34.235]    - args: function (..., envir = parent.frame())
[13:34:34.235]    - tweaked: FALSE
[13:34:34.235]    - call: plan(strategy)
[13:34:34.235] plan(): nbrOfWorkers() = 1
[13:34:34.235] SequentialFuture started (and completed)
[13:34:34.235] - Launch lazy future ... done
[13:34:34.235] run() for ‘SequentialFuture’ ... done
[13:34:34.235] Created future:
[13:34:34.236] SequentialFuture:
[13:34:34.236] Label: ‘future_mapply-5’
[13:34:34.236] Expression:
[13:34:34.236] {
[13:34:34.236]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.236]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.236]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.236]         on.exit(options(oopts), add = TRUE)
[13:34:34.236]     }
[13:34:34.236]     {
[13:34:34.236]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.236]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.236]         do.call(mapply, args = args)
[13:34:34.236]     }
[13:34:34.236] }
[13:34:34.236] Lazy evaluation: FALSE
[13:34:34.236] Asynchronous evaluation: FALSE
[13:34:34.236] Local evaluation: TRUE
[13:34:34.236] Environment: R_GlobalEnv
[13:34:34.236] Capture standard output: TRUE
[13:34:34.236] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.236] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.236] Packages: <none>
[13:34:34.236] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.236] Resolved: TRUE
[13:34:34.236] Value: 112 bytes of class ‘list’
[13:34:34.236] Early signaling: FALSE
[13:34:34.236] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.236] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.236] Chunk #5 of 5 ... DONE
[13:34:34.236] Launching 5 futures (chunks) ... DONE
[13:34:34.237] Resolving 5 futures (chunks) ...
[13:34:34.237] resolve() on list ...
[13:34:34.237]  recursive: 0
[13:34:34.237]  length: 5
[13:34:34.237] 
[13:34:34.237] resolved() for ‘SequentialFuture’ ...
[13:34:34.238] - state: ‘finished’
[13:34:34.238] - run: TRUE
[13:34:34.238] - result: ‘FutureResult’
[13:34:34.238] resolved() for ‘SequentialFuture’ ... done
[13:34:34.238] Future #1
[13:34:34.238] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.238] - nx: 5
[13:34:34.238] - relay: TRUE
[13:34:34.239] - stdout: TRUE
[13:34:34.239] - signal: TRUE
[13:34:34.239] - resignal: FALSE
[13:34:34.239] - force: TRUE
[13:34:34.239] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[13:34:34.239] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[13:34:34.239]  - until=1
[13:34:34.239]  - relaying element #1
[13:34:34.239] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:34.239] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:34.240] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.240]  length: 4 (resolved future 1)
[13:34:34.240] resolved() for ‘SequentialFuture’ ...
[13:34:34.240] - state: ‘finished’
[13:34:34.240] - run: TRUE
[13:34:34.240] - result: ‘FutureResult’
[13:34:34.240] resolved() for ‘SequentialFuture’ ... done
[13:34:34.240] Future #2
[13:34:34.240] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:34:34.240] - nx: 5
[13:34:34.240] - relay: TRUE
[13:34:34.241] - stdout: TRUE
[13:34:34.241] - signal: TRUE
[13:34:34.241] - resignal: FALSE
[13:34:34.241] - force: TRUE
[13:34:34.241] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:34.241] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:34.241]  - until=2
[13:34:34.241]  - relaying element #2
[13:34:34.241] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:34.241] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:34.241] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:34:34.242]  length: 3 (resolved future 2)
[13:34:34.242] resolved() for ‘SequentialFuture’ ...
[13:34:34.242] - state: ‘finished’
[13:34:34.242] - run: TRUE
[13:34:34.242] - result: ‘FutureResult’
[13:34:34.242] resolved() for ‘SequentialFuture’ ... done
[13:34:34.242] Future #3
[13:34:34.242] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:34:34.242] - nx: 5
[13:34:34.242] - relay: TRUE
[13:34:34.242] - stdout: TRUE
[13:34:34.243] - signal: TRUE
[13:34:34.243] - resignal: FALSE
[13:34:34.243] - force: TRUE
[13:34:34.243] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:34.243] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:34.243]  - until=3
[13:34:34.243]  - relaying element #3
[13:34:34.243] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:34.243] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:34.243] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:34:34.243]  length: 2 (resolved future 3)
[13:34:34.244] resolved() for ‘SequentialFuture’ ...
[13:34:34.244] - state: ‘finished’
[13:34:34.244] - run: TRUE
[13:34:34.244] - result: ‘FutureResult’
[13:34:34.244] resolved() for ‘SequentialFuture’ ... done
[13:34:34.244] Future #4
[13:34:34.244] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:34:34.244] - nx: 5
[13:34:34.244] - relay: TRUE
[13:34:34.244] - stdout: TRUE
[13:34:34.244] - signal: TRUE
[13:34:34.244] - resignal: FALSE
[13:34:34.245] - force: TRUE
[13:34:34.245] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:34.245] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:34.245]  - until=4
[13:34:34.245]  - relaying element #4
[13:34:34.245] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:34.245] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:34.245] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:34:34.245]  length: 1 (resolved future 4)
[13:34:34.245] resolved() for ‘SequentialFuture’ ...
[13:34:34.245] - state: ‘finished’
[13:34:34.246] - run: TRUE
[13:34:34.246] - result: ‘FutureResult’
[13:34:34.246] resolved() for ‘SequentialFuture’ ... done
[13:34:34.246] Future #5
[13:34:34.246] signalConditionsASAP(SequentialFuture, pos=5) ...
[13:34:34.246] - nx: 5
[13:34:34.246] - relay: TRUE
[13:34:34.246] - stdout: TRUE
[13:34:34.246] - signal: TRUE
[13:34:34.246] - resignal: FALSE
[13:34:34.246] - force: TRUE
[13:34:34.246] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:34.247] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:34.247]  - until=5
[13:34:34.247]  - relaying element #5
[13:34:34.247] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:34.247] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:34.247] signalConditionsASAP(SequentialFuture, pos=5) ... done
[13:34:34.247]  length: 0 (resolved future 5)
[13:34:34.247] Relaying remaining futures
[13:34:34.247] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.247] - nx: 5
[13:34:34.247] - relay: TRUE
[13:34:34.248] - stdout: TRUE
[13:34:34.248] - signal: TRUE
[13:34:34.248] - resignal: FALSE
[13:34:34.248] - force: TRUE
[13:34:34.248] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:34.248] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[13:34:34.248] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:34.248] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:34.248] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.248] resolve() on list ... DONE
[13:34:34.249]  - Number of value chunks collected: 5
[13:34:34.249] Resolving 5 futures (chunks) ... DONE
[13:34:34.249] Reducing values from 5 chunks ...
[13:34:34.249]  - Number of values collected after concatenation: 5
[13:34:34.249]  - Number of values expected: 5
[13:34:34.249] Reducing values from 5 chunks ... DONE
[13:34:34.249] future_mapply() ... DONE
[13:34:34.249] future_mapply() ...
[13:34:34.250] Number of chunks: 1
[13:34:34.250] getGlobalsAndPackagesXApply() ...
[13:34:34.250]  - future.globals: TRUE
[13:34:34.250] getGlobalsAndPackages() ...
[13:34:34.250] Searching for globals...
[13:34:34.251] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:34.251] Searching for globals ... DONE
[13:34:34.251] Resolving globals: FALSE
[13:34:34.252] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:34.252] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:34.252] - globals: [1] ‘FUN’
[13:34:34.252] 
[13:34:34.252] getGlobalsAndPackages() ... DONE
[13:34:34.252]  - globals found/used: [n=1] ‘FUN’
[13:34:34.252]  - needed namespaces: [n=0] 
[13:34:34.252] Finding globals ... DONE
[13:34:34.253] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.253] List of 2
[13:34:34.253]  $ ...future.FUN:function (C, k)  
[13:34:34.253]  $ MoreArgs     : list()
[13:34:34.253]  - attr(*, "where")=List of 2
[13:34:34.253]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.253]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.253]  - attr(*, "resolved")= logi FALSE
[13:34:34.253]  - attr(*, "total_size")= num NA
[13:34:34.255] Packages to be attached in all futures: [n=0] 
[13:34:34.255] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.255] Number of futures (= number of chunks): 1
[13:34:34.255] Launching 1 futures (chunks) ...
[13:34:34.255] Chunk #1 of 1 ...
[13:34:34.256]  - Finding globals in '...' for chunk #1 ...
[13:34:34.256] getGlobalsAndPackages() ...
[13:34:34.256] Searching for globals...
[13:34:34.256] 
[13:34:34.256] Searching for globals ... DONE
[13:34:34.256] - globals: [0] <none>
[13:34:34.256] getGlobalsAndPackages() ... DONE
[13:34:34.256]    + additional globals found: [n=0] 
[13:34:34.256]    + additional namespaces needed: [n=0] 
[13:34:34.257]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.257]  - seeds: <none>
[13:34:34.257]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.257] getGlobalsAndPackages() ...
[13:34:34.257] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.257] Resolving globals: FALSE
[13:34:34.257] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[13:34:34.258] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:34.258] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.258] 
[13:34:34.259] getGlobalsAndPackages() ... DONE
[13:34:34.259] run() for ‘Future’ ...
[13:34:34.259] - state: ‘created’
[13:34:34.259] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.260] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.260] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.260]   - Field: ‘label’
[13:34:34.260]   - Field: ‘local’
[13:34:34.260]   - Field: ‘owner’
[13:34:34.260]   - Field: ‘envir’
[13:34:34.260]   - Field: ‘packages’
[13:34:34.260]   - Field: ‘gc’
[13:34:34.260]   - Field: ‘conditions’
[13:34:34.260]   - Field: ‘expr’
[13:34:34.260]   - Field: ‘uuid’
[13:34:34.261]   - Field: ‘seed’
[13:34:34.261]   - Field: ‘version’
[13:34:34.261]   - Field: ‘result’
[13:34:34.261]   - Field: ‘asynchronous’
[13:34:34.261]   - Field: ‘calls’
[13:34:34.261]   - Field: ‘globals’
[13:34:34.261]   - Field: ‘stdout’
[13:34:34.261]   - Field: ‘earlySignal’
[13:34:34.261]   - Field: ‘lazy’
[13:34:34.261]   - Field: ‘state’
[13:34:34.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.262] - Launch lazy future ...
[13:34:34.262] Packages needed by the future expression (n = 0): <none>
[13:34:34.262] Packages needed by future strategies (n = 0): <none>
[13:34:34.262] {
[13:34:34.262]     {
[13:34:34.262]         {
[13:34:34.262]             ...future.startTime <- base::Sys.time()
[13:34:34.262]             {
[13:34:34.262]                 {
[13:34:34.262]                   {
[13:34:34.262]                     base::local({
[13:34:34.262]                       has_future <- base::requireNamespace("future", 
[13:34:34.262]                         quietly = TRUE)
[13:34:34.262]                       if (has_future) {
[13:34:34.262]                         ns <- base::getNamespace("future")
[13:34:34.262]                         version <- ns[[".package"]][["version"]]
[13:34:34.262]                         if (is.null(version)) 
[13:34:34.262]                           version <- utils::packageVersion("future")
[13:34:34.262]                       }
[13:34:34.262]                       else {
[13:34:34.262]                         version <- NULL
[13:34:34.262]                       }
[13:34:34.262]                       if (!has_future || version < "1.8.0") {
[13:34:34.262]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.262]                           "", base::R.version$version.string), 
[13:34:34.262]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.262]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.262]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.262]                             "release", "version")], collapse = " "), 
[13:34:34.262]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.262]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.262]                           info)
[13:34:34.262]                         info <- base::paste(info, collapse = "; ")
[13:34:34.262]                         if (!has_future) {
[13:34:34.262]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.262]                             info)
[13:34:34.262]                         }
[13:34:34.262]                         else {
[13:34:34.262]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.262]                             info, version)
[13:34:34.262]                         }
[13:34:34.262]                         base::stop(msg)
[13:34:34.262]                       }
[13:34:34.262]                     })
[13:34:34.262]                   }
[13:34:34.262]                   ...future.strategy.old <- future::plan("list")
[13:34:34.262]                   options(future.plan = NULL)
[13:34:34.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.262]                 }
[13:34:34.262]                 ...future.workdir <- getwd()
[13:34:34.262]             }
[13:34:34.262]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.262]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.262]         }
[13:34:34.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.262]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.262]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.262]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.262]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.262]             base::names(...future.oldOptions))
[13:34:34.262]     }
[13:34:34.262]     if (FALSE) {
[13:34:34.262]     }
[13:34:34.262]     else {
[13:34:34.262]         if (TRUE) {
[13:34:34.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.262]                 open = "w")
[13:34:34.262]         }
[13:34:34.262]         else {
[13:34:34.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.262]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.262]         }
[13:34:34.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.262]             base::sink(type = "output", split = FALSE)
[13:34:34.262]             base::close(...future.stdout)
[13:34:34.262]         }, add = TRUE)
[13:34:34.262]     }
[13:34:34.262]     ...future.frame <- base::sys.nframe()
[13:34:34.262]     ...future.conditions <- base::list()
[13:34:34.262]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.262]     if (FALSE) {
[13:34:34.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.262]     }
[13:34:34.262]     ...future.result <- base::tryCatch({
[13:34:34.262]         base::withCallingHandlers({
[13:34:34.262]             ...future.value <- base::withVisible(base::local({
[13:34:34.262]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.262]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.262]                   ...future.globals.maxSize)) {
[13:34:34.262]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.262]                   on.exit(options(oopts), add = TRUE)
[13:34:34.262]                 }
[13:34:34.262]                 {
[13:34:34.262]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.262]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.262]                     USE.NAMES = FALSE)
[13:34:34.262]                   do.call(mapply, args = args)
[13:34:34.262]                 }
[13:34:34.262]             }))
[13:34:34.262]             future::FutureResult(value = ...future.value$value, 
[13:34:34.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.262]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.262]                     ...future.globalenv.names))
[13:34:34.262]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.262]         }, condition = base::local({
[13:34:34.262]             c <- base::c
[13:34:34.262]             inherits <- base::inherits
[13:34:34.262]             invokeRestart <- base::invokeRestart
[13:34:34.262]             length <- base::length
[13:34:34.262]             list <- base::list
[13:34:34.262]             seq.int <- base::seq.int
[13:34:34.262]             signalCondition <- base::signalCondition
[13:34:34.262]             sys.calls <- base::sys.calls
[13:34:34.262]             `[[` <- base::`[[`
[13:34:34.262]             `+` <- base::`+`
[13:34:34.262]             `<<-` <- base::`<<-`
[13:34:34.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.262]                   3L)]
[13:34:34.262]             }
[13:34:34.262]             function(cond) {
[13:34:34.262]                 is_error <- inherits(cond, "error")
[13:34:34.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.262]                   NULL)
[13:34:34.262]                 if (is_error) {
[13:34:34.262]                   sessionInformation <- function() {
[13:34:34.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.262]                       search = base::search(), system = base::Sys.info())
[13:34:34.262]                   }
[13:34:34.262]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.262]                     cond$call), session = sessionInformation(), 
[13:34:34.262]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.262]                   signalCondition(cond)
[13:34:34.262]                 }
[13:34:34.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.262]                 "immediateCondition"))) {
[13:34:34.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.262]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.262]                   if (TRUE && !signal) {
[13:34:34.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.262]                     {
[13:34:34.262]                       inherits <- base::inherits
[13:34:34.262]                       invokeRestart <- base::invokeRestart
[13:34:34.262]                       is.null <- base::is.null
[13:34:34.262]                       muffled <- FALSE
[13:34:34.262]                       if (inherits(cond, "message")) {
[13:34:34.262]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.262]                         if (muffled) 
[13:34:34.262]                           invokeRestart("muffleMessage")
[13:34:34.262]                       }
[13:34:34.262]                       else if (inherits(cond, "warning")) {
[13:34:34.262]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.262]                         if (muffled) 
[13:34:34.262]                           invokeRestart("muffleWarning")
[13:34:34.262]                       }
[13:34:34.262]                       else if (inherits(cond, "condition")) {
[13:34:34.262]                         if (!is.null(pattern)) {
[13:34:34.262]                           computeRestarts <- base::computeRestarts
[13:34:34.262]                           grepl <- base::grepl
[13:34:34.262]                           restarts <- computeRestarts(cond)
[13:34:34.262]                           for (restart in restarts) {
[13:34:34.262]                             name <- restart$name
[13:34:34.262]                             if (is.null(name)) 
[13:34:34.262]                               next
[13:34:34.262]                             if (!grepl(pattern, name)) 
[13:34:34.262]                               next
[13:34:34.262]                             invokeRestart(restart)
[13:34:34.262]                             muffled <- TRUE
[13:34:34.262]                             break
[13:34:34.262]                           }
[13:34:34.262]                         }
[13:34:34.262]                       }
[13:34:34.262]                       invisible(muffled)
[13:34:34.262]                     }
[13:34:34.262]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.262]                   }
[13:34:34.262]                 }
[13:34:34.262]                 else {
[13:34:34.262]                   if (TRUE) {
[13:34:34.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.262]                     {
[13:34:34.262]                       inherits <- base::inherits
[13:34:34.262]                       invokeRestart <- base::invokeRestart
[13:34:34.262]                       is.null <- base::is.null
[13:34:34.262]                       muffled <- FALSE
[13:34:34.262]                       if (inherits(cond, "message")) {
[13:34:34.262]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.262]                         if (muffled) 
[13:34:34.262]                           invokeRestart("muffleMessage")
[13:34:34.262]                       }
[13:34:34.262]                       else if (inherits(cond, "warning")) {
[13:34:34.262]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.262]                         if (muffled) 
[13:34:34.262]                           invokeRestart("muffleWarning")
[13:34:34.262]                       }
[13:34:34.262]                       else if (inherits(cond, "condition")) {
[13:34:34.262]                         if (!is.null(pattern)) {
[13:34:34.262]                           computeRestarts <- base::computeRestarts
[13:34:34.262]                           grepl <- base::grepl
[13:34:34.262]                           restarts <- computeRestarts(cond)
[13:34:34.262]                           for (restart in restarts) {
[13:34:34.262]                             name <- restart$name
[13:34:34.262]                             if (is.null(name)) 
[13:34:34.262]                               next
[13:34:34.262]                             if (!grepl(pattern, name)) 
[13:34:34.262]                               next
[13:34:34.262]                             invokeRestart(restart)
[13:34:34.262]                             muffled <- TRUE
[13:34:34.262]                             break
[13:34:34.262]                           }
[13:34:34.262]                         }
[13:34:34.262]                       }
[13:34:34.262]                       invisible(muffled)
[13:34:34.262]                     }
[13:34:34.262]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.262]                   }
[13:34:34.262]                 }
[13:34:34.262]             }
[13:34:34.262]         }))
[13:34:34.262]     }, error = function(ex) {
[13:34:34.262]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.262]                 ...future.rng), started = ...future.startTime, 
[13:34:34.262]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.262]             version = "1.8"), class = "FutureResult")
[13:34:34.262]     }, finally = {
[13:34:34.262]         if (!identical(...future.workdir, getwd())) 
[13:34:34.262]             setwd(...future.workdir)
[13:34:34.262]         {
[13:34:34.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.262]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.262]             }
[13:34:34.262]             base::options(...future.oldOptions)
[13:34:34.262]             if (.Platform$OS.type == "windows") {
[13:34:34.262]                 old_names <- names(...future.oldEnvVars)
[13:34:34.262]                 envs <- base::Sys.getenv()
[13:34:34.262]                 names <- names(envs)
[13:34:34.262]                 common <- intersect(names, old_names)
[13:34:34.262]                 added <- setdiff(names, old_names)
[13:34:34.262]                 removed <- setdiff(old_names, names)
[13:34:34.262]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.262]                   envs[common]]
[13:34:34.262]                 NAMES <- toupper(changed)
[13:34:34.262]                 args <- list()
[13:34:34.262]                 for (kk in seq_along(NAMES)) {
[13:34:34.262]                   name <- changed[[kk]]
[13:34:34.262]                   NAME <- NAMES[[kk]]
[13:34:34.262]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.262]                     next
[13:34:34.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.262]                 }
[13:34:34.262]                 NAMES <- toupper(added)
[13:34:34.262]                 for (kk in seq_along(NAMES)) {
[13:34:34.262]                   name <- added[[kk]]
[13:34:34.262]                   NAME <- NAMES[[kk]]
[13:34:34.262]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.262]                     next
[13:34:34.262]                   args[[name]] <- ""
[13:34:34.262]                 }
[13:34:34.262]                 NAMES <- toupper(removed)
[13:34:34.262]                 for (kk in seq_along(NAMES)) {
[13:34:34.262]                   name <- removed[[kk]]
[13:34:34.262]                   NAME <- NAMES[[kk]]
[13:34:34.262]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.262]                     next
[13:34:34.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.262]                 }
[13:34:34.262]                 if (length(args) > 0) 
[13:34:34.262]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.262]             }
[13:34:34.262]             else {
[13:34:34.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.262]             }
[13:34:34.262]             {
[13:34:34.262]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.262]                   0L) {
[13:34:34.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.262]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.262]                   base::options(opts)
[13:34:34.262]                 }
[13:34:34.262]                 {
[13:34:34.262]                   {
[13:34:34.262]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.262]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.262]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.262]                       inherits = FALSE)
[13:34:34.262]                     NULL
[13:34:34.262]                   }
[13:34:34.262]                   options(future.plan = NULL)
[13:34:34.262]                   if (is.na(NA_character_)) 
[13:34:34.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.262]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.262]                     .init = FALSE)
[13:34:34.262]                 }
[13:34:34.262]             }
[13:34:34.262]         }
[13:34:34.262]     })
[13:34:34.262]     if (TRUE) {
[13:34:34.262]         base::sink(type = "output", split = FALSE)
[13:34:34.262]         if (TRUE) {
[13:34:34.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.262]         }
[13:34:34.262]         else {
[13:34:34.262]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.262]         }
[13:34:34.262]         base::close(...future.stdout)
[13:34:34.262]         ...future.stdout <- NULL
[13:34:34.262]     }
[13:34:34.262]     ...future.result$conditions <- ...future.conditions
[13:34:34.262]     ...future.result$finished <- base::Sys.time()
[13:34:34.262]     ...future.result
[13:34:34.262] }
[13:34:34.264] assign_globals() ...
[13:34:34.264] List of 5
[13:34:34.264]  $ ...future.FUN            :function (C, k)  
[13:34:34.264]  $ MoreArgs                 : list()
[13:34:34.264]  $ ...future.elements_ii    :List of 2
[13:34:34.264]   ..$ :List of 5
[13:34:34.264]   .. ..$ : chr "A"
[13:34:34.264]   .. ..$ : chr "B"
[13:34:34.264]   .. ..$ : chr "C"
[13:34:34.264]   .. ..$ : chr "D"
[13:34:34.264]   .. ..$ : chr "E"
[13:34:34.264]   ..$ :List of 5
[13:34:34.264]   .. ..$ : int 5
[13:34:34.264]   .. ..$ : int 4
[13:34:34.264]   .. ..$ : int 3
[13:34:34.264]   .. ..$ : int 2
[13:34:34.264]   .. ..$ : int 1
[13:34:34.264]  $ ...future.seeds_ii       : NULL
[13:34:34.264]  $ ...future.globals.maxSize: NULL
[13:34:34.264]  - attr(*, "where")=List of 5
[13:34:34.264]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.264]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.264]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.264]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.264]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.264]  - attr(*, "resolved")= logi FALSE
[13:34:34.264]  - attr(*, "total_size")= num 4160
[13:34:34.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.264]  - attr(*, "already-done")= logi TRUE
[13:34:34.270] - reassign environment for ‘...future.FUN’
[13:34:34.270] - copied ‘...future.FUN’ to environment
[13:34:34.270] - copied ‘MoreArgs’ to environment
[13:34:34.270] - copied ‘...future.elements_ii’ to environment
[13:34:34.271] - copied ‘...future.seeds_ii’ to environment
[13:34:34.271] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.271] assign_globals() ... done
[13:34:34.271] plan(): Setting new future strategy stack:
[13:34:34.271] List of future strategies:
[13:34:34.271] 1. sequential:
[13:34:34.271]    - args: function (..., envir = parent.frame())
[13:34:34.271]    - tweaked: FALSE
[13:34:34.271]    - call: NULL
[13:34:34.271] plan(): nbrOfWorkers() = 1
[13:34:34.272] plan(): Setting new future strategy stack:
[13:34:34.272] List of future strategies:
[13:34:34.272] 1. sequential:
[13:34:34.272]    - args: function (..., envir = parent.frame())
[13:34:34.272]    - tweaked: FALSE
[13:34:34.272]    - call: plan(strategy)
[13:34:34.272] plan(): nbrOfWorkers() = 1
[13:34:34.273] SequentialFuture started (and completed)
[13:34:34.273] - Launch lazy future ... done
[13:34:34.273] run() for ‘SequentialFuture’ ... done
[13:34:34.273] Created future:
[13:34:34.273] SequentialFuture:
[13:34:34.273] Label: ‘future_.mapply-1’
[13:34:34.273] Expression:
[13:34:34.273] {
[13:34:34.273]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.273]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.273]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.273]         on.exit(options(oopts), add = TRUE)
[13:34:34.273]     }
[13:34:34.273]     {
[13:34:34.273]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.273]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.273]         do.call(mapply, args = args)
[13:34:34.273]     }
[13:34:34.273] }
[13:34:34.273] Lazy evaluation: FALSE
[13:34:34.273] Asynchronous evaluation: FALSE
[13:34:34.273] Local evaluation: TRUE
[13:34:34.273] Environment: R_GlobalEnv
[13:34:34.273] Capture standard output: TRUE
[13:34:34.273] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.273] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.273] Packages: <none>
[13:34:34.273] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.273] Resolved: TRUE
[13:34:34.273] Value: 560 bytes of class ‘list’
[13:34:34.273] Early signaling: FALSE
[13:34:34.273] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.273] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.274] Chunk #1 of 1 ... DONE
[13:34:34.274] Launching 1 futures (chunks) ... DONE
[13:34:34.274] Resolving 1 futures (chunks) ...
[13:34:34.274] resolve() on list ...
[13:34:34.274]  recursive: 0
[13:34:34.274]  length: 1
[13:34:34.274] 
[13:34:34.274] resolved() for ‘SequentialFuture’ ...
[13:34:34.275] - state: ‘finished’
[13:34:34.275] - run: TRUE
[13:34:34.275] - result: ‘FutureResult’
[13:34:34.275] resolved() for ‘SequentialFuture’ ... done
[13:34:34.275] Future #1
[13:34:34.275] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.275] - nx: 1
[13:34:34.275] - relay: TRUE
[13:34:34.275] - stdout: TRUE
[13:34:34.275] - signal: TRUE
[13:34:34.275] - resignal: FALSE
[13:34:34.275] - force: TRUE
[13:34:34.276] - relayed: [n=1] FALSE
[13:34:34.276] - queued futures: [n=1] FALSE
[13:34:34.276]  - until=1
[13:34:34.276]  - relaying element #1
[13:34:34.276] - relayed: [n=1] TRUE
[13:34:34.276] - queued futures: [n=1] TRUE
[13:34:34.276] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.276]  length: 0 (resolved future 1)
[13:34:34.276] Relaying remaining futures
[13:34:34.276] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.276] - nx: 1
[13:34:34.277] - relay: TRUE
[13:34:34.277] - stdout: TRUE
[13:34:34.277] - signal: TRUE
[13:34:34.277] - resignal: FALSE
[13:34:34.277] - force: TRUE
[13:34:34.277] - relayed: [n=1] TRUE
[13:34:34.277] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.277] - relayed: [n=1] TRUE
[13:34:34.277] - queued futures: [n=1] TRUE
[13:34:34.277] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.277] resolve() on list ... DONE
[13:34:34.277]  - Number of value chunks collected: 1
[13:34:34.278] Resolving 1 futures (chunks) ... DONE
[13:34:34.278] Reducing values from 1 chunks ...
[13:34:34.278]  - Number of values collected after concatenation: 5
[13:34:34.278]  - Number of values expected: 5
[13:34:34.278] Reducing values from 1 chunks ... DONE
[13:34:34.278] future_mapply() ... DONE
[13:34:34.278] future_mapply() ...
[13:34:34.279] Number of chunks: 3
[13:34:34.279] Index remapping (attribute 'ordering'): [n = 5] 4, 5, 3, 2, 1
[13:34:34.279] getGlobalsAndPackagesXApply() ...
[13:34:34.279]  - future.globals: TRUE
[13:34:34.279] getGlobalsAndPackages() ...
[13:34:34.279] Searching for globals...
[13:34:34.281] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:34.281] Searching for globals ... DONE
[13:34:34.281] Resolving globals: FALSE
[13:34:34.281] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:34.282] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:34.282] - globals: [1] ‘FUN’
[13:34:34.282] 
[13:34:34.282] getGlobalsAndPackages() ... DONE
[13:34:34.282]  - globals found/used: [n=1] ‘FUN’
[13:34:34.282]  - needed namespaces: [n=0] 
[13:34:34.282] Finding globals ... DONE
[13:34:34.282] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.283] List of 2
[13:34:34.283]  $ ...future.FUN:function (C, k)  
[13:34:34.283]  $ MoreArgs     : NULL
[13:34:34.283]  - attr(*, "where")=List of 2
[13:34:34.283]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.283]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.283]  - attr(*, "resolved")= logi FALSE
[13:34:34.283]  - attr(*, "total_size")= num NA
[13:34:34.285] Packages to be attached in all futures: [n=0] 
[13:34:34.285] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.285] Number of futures (= number of chunks): 3
[13:34:34.285] Launching 3 futures (chunks) ...
[13:34:34.285] Chunk #1 of 3 ...
[13:34:34.285]  - Finding globals in '...' for chunk #1 ...
[13:34:34.285] getGlobalsAndPackages() ...
[13:34:34.285] Searching for globals...
[13:34:34.286] 
[13:34:34.286] Searching for globals ... DONE
[13:34:34.286] - globals: [0] <none>
[13:34:34.286] getGlobalsAndPackages() ... DONE
[13:34:34.286]    + additional globals found: [n=0] 
[13:34:34.286]    + additional namespaces needed: [n=0] 
[13:34:34.286]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.286]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:34:34.287]  - seeds: <none>
[13:34:34.287]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.287] getGlobalsAndPackages() ...
[13:34:34.287] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.287] Resolving globals: FALSE
[13:34:34.287] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:34.288] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.288] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.288] 
[13:34:34.288] getGlobalsAndPackages() ... DONE
[13:34:34.288] run() for ‘Future’ ...
[13:34:34.288] - state: ‘created’
[13:34:34.288] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.289] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.289] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.289]   - Field: ‘label’
[13:34:34.289]   - Field: ‘local’
[13:34:34.289]   - Field: ‘owner’
[13:34:34.289]   - Field: ‘envir’
[13:34:34.289]   - Field: ‘packages’
[13:34:34.289]   - Field: ‘gc’
[13:34:34.289]   - Field: ‘conditions’
[13:34:34.289]   - Field: ‘expr’
[13:34:34.290]   - Field: ‘uuid’
[13:34:34.290]   - Field: ‘seed’
[13:34:34.290]   - Field: ‘version’
[13:34:34.290]   - Field: ‘result’
[13:34:34.290]   - Field: ‘asynchronous’
[13:34:34.290]   - Field: ‘calls’
[13:34:34.290]   - Field: ‘globals’
[13:34:34.290]   - Field: ‘stdout’
[13:34:34.290]   - Field: ‘earlySignal’
[13:34:34.290]   - Field: ‘lazy’
[13:34:34.290]   - Field: ‘state’
[13:34:34.291] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.291] - Launch lazy future ...
[13:34:34.291] Packages needed by the future expression (n = 0): <none>
[13:34:34.291] Packages needed by future strategies (n = 0): <none>
[13:34:34.291] {
[13:34:34.291]     {
[13:34:34.291]         {
[13:34:34.291]             ...future.startTime <- base::Sys.time()
[13:34:34.291]             {
[13:34:34.291]                 {
[13:34:34.291]                   {
[13:34:34.291]                     base::local({
[13:34:34.291]                       has_future <- base::requireNamespace("future", 
[13:34:34.291]                         quietly = TRUE)
[13:34:34.291]                       if (has_future) {
[13:34:34.291]                         ns <- base::getNamespace("future")
[13:34:34.291]                         version <- ns[[".package"]][["version"]]
[13:34:34.291]                         if (is.null(version)) 
[13:34:34.291]                           version <- utils::packageVersion("future")
[13:34:34.291]                       }
[13:34:34.291]                       else {
[13:34:34.291]                         version <- NULL
[13:34:34.291]                       }
[13:34:34.291]                       if (!has_future || version < "1.8.0") {
[13:34:34.291]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.291]                           "", base::R.version$version.string), 
[13:34:34.291]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.291]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.291]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.291]                             "release", "version")], collapse = " "), 
[13:34:34.291]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.291]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.291]                           info)
[13:34:34.291]                         info <- base::paste(info, collapse = "; ")
[13:34:34.291]                         if (!has_future) {
[13:34:34.291]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.291]                             info)
[13:34:34.291]                         }
[13:34:34.291]                         else {
[13:34:34.291]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.291]                             info, version)
[13:34:34.291]                         }
[13:34:34.291]                         base::stop(msg)
[13:34:34.291]                       }
[13:34:34.291]                     })
[13:34:34.291]                   }
[13:34:34.291]                   ...future.strategy.old <- future::plan("list")
[13:34:34.291]                   options(future.plan = NULL)
[13:34:34.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.291]                 }
[13:34:34.291]                 ...future.workdir <- getwd()
[13:34:34.291]             }
[13:34:34.291]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.291]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.291]         }
[13:34:34.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.291]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:34:34.291]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.291]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.291]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.291]             base::names(...future.oldOptions))
[13:34:34.291]     }
[13:34:34.291]     if (FALSE) {
[13:34:34.291]     }
[13:34:34.291]     else {
[13:34:34.291]         if (TRUE) {
[13:34:34.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.291]                 open = "w")
[13:34:34.291]         }
[13:34:34.291]         else {
[13:34:34.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.291]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.291]         }
[13:34:34.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.291]             base::sink(type = "output", split = FALSE)
[13:34:34.291]             base::close(...future.stdout)
[13:34:34.291]         }, add = TRUE)
[13:34:34.291]     }
[13:34:34.291]     ...future.frame <- base::sys.nframe()
[13:34:34.291]     ...future.conditions <- base::list()
[13:34:34.291]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.291]     if (FALSE) {
[13:34:34.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.291]     }
[13:34:34.291]     ...future.result <- base::tryCatch({
[13:34:34.291]         base::withCallingHandlers({
[13:34:34.291]             ...future.value <- base::withVisible(base::local({
[13:34:34.291]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.291]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.291]                   ...future.globals.maxSize)) {
[13:34:34.291]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.291]                   on.exit(options(oopts), add = TRUE)
[13:34:34.291]                 }
[13:34:34.291]                 {
[13:34:34.291]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.291]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.291]                     USE.NAMES = FALSE)
[13:34:34.291]                   do.call(mapply, args = args)
[13:34:34.291]                 }
[13:34:34.291]             }))
[13:34:34.291]             future::FutureResult(value = ...future.value$value, 
[13:34:34.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.291]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.291]                     ...future.globalenv.names))
[13:34:34.291]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.291]         }, condition = base::local({
[13:34:34.291]             c <- base::c
[13:34:34.291]             inherits <- base::inherits
[13:34:34.291]             invokeRestart <- base::invokeRestart
[13:34:34.291]             length <- base::length
[13:34:34.291]             list <- base::list
[13:34:34.291]             seq.int <- base::seq.int
[13:34:34.291]             signalCondition <- base::signalCondition
[13:34:34.291]             sys.calls <- base::sys.calls
[13:34:34.291]             `[[` <- base::`[[`
[13:34:34.291]             `+` <- base::`+`
[13:34:34.291]             `<<-` <- base::`<<-`
[13:34:34.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.291]                   3L)]
[13:34:34.291]             }
[13:34:34.291]             function(cond) {
[13:34:34.291]                 is_error <- inherits(cond, "error")
[13:34:34.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.291]                   NULL)
[13:34:34.291]                 if (is_error) {
[13:34:34.291]                   sessionInformation <- function() {
[13:34:34.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.291]                       search = base::search(), system = base::Sys.info())
[13:34:34.291]                   }
[13:34:34.291]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.291]                     cond$call), session = sessionInformation(), 
[13:34:34.291]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.291]                   signalCondition(cond)
[13:34:34.291]                 }
[13:34:34.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.291]                 "immediateCondition"))) {
[13:34:34.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.291]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.291]                   if (TRUE && !signal) {
[13:34:34.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.291]                     {
[13:34:34.291]                       inherits <- base::inherits
[13:34:34.291]                       invokeRestart <- base::invokeRestart
[13:34:34.291]                       is.null <- base::is.null
[13:34:34.291]                       muffled <- FALSE
[13:34:34.291]                       if (inherits(cond, "message")) {
[13:34:34.291]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.291]                         if (muffled) 
[13:34:34.291]                           invokeRestart("muffleMessage")
[13:34:34.291]                       }
[13:34:34.291]                       else if (inherits(cond, "warning")) {
[13:34:34.291]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.291]                         if (muffled) 
[13:34:34.291]                           invokeRestart("muffleWarning")
[13:34:34.291]                       }
[13:34:34.291]                       else if (inherits(cond, "condition")) {
[13:34:34.291]                         if (!is.null(pattern)) {
[13:34:34.291]                           computeRestarts <- base::computeRestarts
[13:34:34.291]                           grepl <- base::grepl
[13:34:34.291]                           restarts <- computeRestarts(cond)
[13:34:34.291]                           for (restart in restarts) {
[13:34:34.291]                             name <- restart$name
[13:34:34.291]                             if (is.null(name)) 
[13:34:34.291]                               next
[13:34:34.291]                             if (!grepl(pattern, name)) 
[13:34:34.291]                               next
[13:34:34.291]                             invokeRestart(restart)
[13:34:34.291]                             muffled <- TRUE
[13:34:34.291]                             break
[13:34:34.291]                           }
[13:34:34.291]                         }
[13:34:34.291]                       }
[13:34:34.291]                       invisible(muffled)
[13:34:34.291]                     }
[13:34:34.291]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.291]                   }
[13:34:34.291]                 }
[13:34:34.291]                 else {
[13:34:34.291]                   if (TRUE) {
[13:34:34.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.291]                     {
[13:34:34.291]                       inherits <- base::inherits
[13:34:34.291]                       invokeRestart <- base::invokeRestart
[13:34:34.291]                       is.null <- base::is.null
[13:34:34.291]                       muffled <- FALSE
[13:34:34.291]                       if (inherits(cond, "message")) {
[13:34:34.291]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.291]                         if (muffled) 
[13:34:34.291]                           invokeRestart("muffleMessage")
[13:34:34.291]                       }
[13:34:34.291]                       else if (inherits(cond, "warning")) {
[13:34:34.291]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.291]                         if (muffled) 
[13:34:34.291]                           invokeRestart("muffleWarning")
[13:34:34.291]                       }
[13:34:34.291]                       else if (inherits(cond, "condition")) {
[13:34:34.291]                         if (!is.null(pattern)) {
[13:34:34.291]                           computeRestarts <- base::computeRestarts
[13:34:34.291]                           grepl <- base::grepl
[13:34:34.291]                           restarts <- computeRestarts(cond)
[13:34:34.291]                           for (restart in restarts) {
[13:34:34.291]                             name <- restart$name
[13:34:34.291]                             if (is.null(name)) 
[13:34:34.291]                               next
[13:34:34.291]                             if (!grepl(pattern, name)) 
[13:34:34.291]                               next
[13:34:34.291]                             invokeRestart(restart)
[13:34:34.291]                             muffled <- TRUE
[13:34:34.291]                             break
[13:34:34.291]                           }
[13:34:34.291]                         }
[13:34:34.291]                       }
[13:34:34.291]                       invisible(muffled)
[13:34:34.291]                     }
[13:34:34.291]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.291]                   }
[13:34:34.291]                 }
[13:34:34.291]             }
[13:34:34.291]         }))
[13:34:34.291]     }, error = function(ex) {
[13:34:34.291]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.291]                 ...future.rng), started = ...future.startTime, 
[13:34:34.291]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.291]             version = "1.8"), class = "FutureResult")
[13:34:34.291]     }, finally = {
[13:34:34.291]         if (!identical(...future.workdir, getwd())) 
[13:34:34.291]             setwd(...future.workdir)
[13:34:34.291]         {
[13:34:34.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.291]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.291]             }
[13:34:34.291]             base::options(...future.oldOptions)
[13:34:34.291]             if (.Platform$OS.type == "windows") {
[13:34:34.291]                 old_names <- names(...future.oldEnvVars)
[13:34:34.291]                 envs <- base::Sys.getenv()
[13:34:34.291]                 names <- names(envs)
[13:34:34.291]                 common <- intersect(names, old_names)
[13:34:34.291]                 added <- setdiff(names, old_names)
[13:34:34.291]                 removed <- setdiff(old_names, names)
[13:34:34.291]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.291]                   envs[common]]
[13:34:34.291]                 NAMES <- toupper(changed)
[13:34:34.291]                 args <- list()
[13:34:34.291]                 for (kk in seq_along(NAMES)) {
[13:34:34.291]                   name <- changed[[kk]]
[13:34:34.291]                   NAME <- NAMES[[kk]]
[13:34:34.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.291]                     next
[13:34:34.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.291]                 }
[13:34:34.291]                 NAMES <- toupper(added)
[13:34:34.291]                 for (kk in seq_along(NAMES)) {
[13:34:34.291]                   name <- added[[kk]]
[13:34:34.291]                   NAME <- NAMES[[kk]]
[13:34:34.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.291]                     next
[13:34:34.291]                   args[[name]] <- ""
[13:34:34.291]                 }
[13:34:34.291]                 NAMES <- toupper(removed)
[13:34:34.291]                 for (kk in seq_along(NAMES)) {
[13:34:34.291]                   name <- removed[[kk]]
[13:34:34.291]                   NAME <- NAMES[[kk]]
[13:34:34.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.291]                     next
[13:34:34.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.291]                 }
[13:34:34.291]                 if (length(args) > 0) 
[13:34:34.291]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.291]             }
[13:34:34.291]             else {
[13:34:34.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.291]             }
[13:34:34.291]             {
[13:34:34.291]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.291]                   0L) {
[13:34:34.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.291]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.291]                   base::options(opts)
[13:34:34.291]                 }
[13:34:34.291]                 {
[13:34:34.291]                   {
[13:34:34.291]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.291]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.291]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.291]                       inherits = FALSE)
[13:34:34.291]                     NULL
[13:34:34.291]                   }
[13:34:34.291]                   options(future.plan = NULL)
[13:34:34.291]                   if (is.na(NA_character_)) 
[13:34:34.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.291]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.291]                     .init = FALSE)
[13:34:34.291]                 }
[13:34:34.291]             }
[13:34:34.291]         }
[13:34:34.291]     })
[13:34:34.291]     if (TRUE) {
[13:34:34.291]         base::sink(type = "output", split = FALSE)
[13:34:34.291]         if (TRUE) {
[13:34:34.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.291]         }
[13:34:34.291]         else {
[13:34:34.291]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.291]         }
[13:34:34.291]         base::close(...future.stdout)
[13:34:34.291]         ...future.stdout <- NULL
[13:34:34.291]     }
[13:34:34.291]     ...future.result$conditions <- ...future.conditions
[13:34:34.291]     ...future.result$finished <- base::Sys.time()
[13:34:34.291]     ...future.result
[13:34:34.291] }
[13:34:34.293] assign_globals() ...
[13:34:34.293] List of 5
[13:34:34.293]  $ ...future.FUN            :function (C, k)  
[13:34:34.293]  $ MoreArgs                 : NULL
[13:34:34.293]  $ ...future.elements_ii    :List of 2
[13:34:34.293]   ..$ :List of 2
[13:34:34.293]   .. ..$ : chr "D"
[13:34:34.293]   .. ..$ : chr "E"
[13:34:34.293]   ..$ :List of 2
[13:34:34.293]   .. ..$ : int 2
[13:34:34.293]   .. ..$ : int 1
[13:34:34.293]  $ ...future.seeds_ii       : NULL
[13:34:34.293]  $ ...future.globals.maxSize: NULL
[13:34:34.293]  - attr(*, "where")=List of 5
[13:34:34.293]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.293]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.293]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.293]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.293]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.293]  - attr(*, "resolved")= logi FALSE
[13:34:34.293]  - attr(*, "total_size")= num 3656
[13:34:34.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.293]  - attr(*, "already-done")= logi TRUE
[13:34:34.299] - reassign environment for ‘...future.FUN’
[13:34:34.299] - copied ‘...future.FUN’ to environment
[13:34:34.299] - copied ‘MoreArgs’ to environment
[13:34:34.299] - copied ‘...future.elements_ii’ to environment
[13:34:34.299] - copied ‘...future.seeds_ii’ to environment
[13:34:34.299] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.300] assign_globals() ... done
[13:34:34.300] plan(): Setting new future strategy stack:
[13:34:34.300] List of future strategies:
[13:34:34.300] 1. sequential:
[13:34:34.300]    - args: function (..., envir = parent.frame())
[13:34:34.300]    - tweaked: FALSE
[13:34:34.300]    - call: NULL
[13:34:34.300] plan(): nbrOfWorkers() = 1
[13:34:34.301] plan(): Setting new future strategy stack:
[13:34:34.301] List of future strategies:
[13:34:34.301] 1. sequential:
[13:34:34.301]    - args: function (..., envir = parent.frame())
[13:34:34.301]    - tweaked: FALSE
[13:34:34.301]    - call: plan(strategy)
[13:34:34.301] plan(): nbrOfWorkers() = 1
[13:34:34.301] SequentialFuture started (and completed)
[13:34:34.302] - Launch lazy future ... done
[13:34:34.302] run() for ‘SequentialFuture’ ... done
[13:34:34.302] Created future:
[13:34:34.302] SequentialFuture:
[13:34:34.302] Label: ‘future_mapply-1’
[13:34:34.302] Expression:
[13:34:34.302] {
[13:34:34.302]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.302]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.302]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.302]         on.exit(options(oopts), add = TRUE)
[13:34:34.302]     }
[13:34:34.302]     {
[13:34:34.302]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.302]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.302]         do.call(mapply, args = args)
[13:34:34.302]     }
[13:34:34.302] }
[13:34:34.302] Lazy evaluation: FALSE
[13:34:34.302] Asynchronous evaluation: FALSE
[13:34:34.302] Local evaluation: TRUE
[13:34:34.302] Environment: R_GlobalEnv
[13:34:34.302] Capture standard output: TRUE
[13:34:34.302] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.302] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.302] Packages: <none>
[13:34:34.302] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.302] Resolved: TRUE
[13:34:34.302] Value: 224 bytes of class ‘list’
[13:34:34.302] Early signaling: FALSE
[13:34:34.302] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.302] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.303] Chunk #1 of 3 ... DONE
[13:34:34.303] Chunk #2 of 3 ...
[13:34:34.303]  - Finding globals in '...' for chunk #2 ...
[13:34:34.303] getGlobalsAndPackages() ...
[13:34:34.303] Searching for globals...
[13:34:34.303] 
[13:34:34.304] Searching for globals ... DONE
[13:34:34.304] - globals: [0] <none>
[13:34:34.305] getGlobalsAndPackages() ... DONE
[13:34:34.305]    + additional globals found: [n=0] 
[13:34:34.305]    + additional namespaces needed: [n=0] 
[13:34:34.305]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:34.305]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:34:34.305]  - seeds: <none>
[13:34:34.305]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.305] getGlobalsAndPackages() ...
[13:34:34.305] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.305] Resolving globals: FALSE
[13:34:34.306] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:34.306] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.306] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.306] 
[13:34:34.307] getGlobalsAndPackages() ... DONE
[13:34:34.307] run() for ‘Future’ ...
[13:34:34.307] - state: ‘created’
[13:34:34.307] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.307] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.307] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.307]   - Field: ‘label’
[13:34:34.308]   - Field: ‘local’
[13:34:34.308]   - Field: ‘owner’
[13:34:34.308]   - Field: ‘envir’
[13:34:34.308]   - Field: ‘packages’
[13:34:34.308]   - Field: ‘gc’
[13:34:34.308]   - Field: ‘conditions’
[13:34:34.308]   - Field: ‘expr’
[13:34:34.308]   - Field: ‘uuid’
[13:34:34.308]   - Field: ‘seed’
[13:34:34.308]   - Field: ‘version’
[13:34:34.308]   - Field: ‘result’
[13:34:34.309]   - Field: ‘asynchronous’
[13:34:34.309]   - Field: ‘calls’
[13:34:34.309]   - Field: ‘globals’
[13:34:34.309]   - Field: ‘stdout’
[13:34:34.309]   - Field: ‘earlySignal’
[13:34:34.309]   - Field: ‘lazy’
[13:34:34.309]   - Field: ‘state’
[13:34:34.309] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.309] - Launch lazy future ...
[13:34:34.309] Packages needed by the future expression (n = 0): <none>
[13:34:34.309] Packages needed by future strategies (n = 0): <none>
[13:34:34.310] {
[13:34:34.310]     {
[13:34:34.310]         {
[13:34:34.310]             ...future.startTime <- base::Sys.time()
[13:34:34.310]             {
[13:34:34.310]                 {
[13:34:34.310]                   {
[13:34:34.310]                     base::local({
[13:34:34.310]                       has_future <- base::requireNamespace("future", 
[13:34:34.310]                         quietly = TRUE)
[13:34:34.310]                       if (has_future) {
[13:34:34.310]                         ns <- base::getNamespace("future")
[13:34:34.310]                         version <- ns[[".package"]][["version"]]
[13:34:34.310]                         if (is.null(version)) 
[13:34:34.310]                           version <- utils::packageVersion("future")
[13:34:34.310]                       }
[13:34:34.310]                       else {
[13:34:34.310]                         version <- NULL
[13:34:34.310]                       }
[13:34:34.310]                       if (!has_future || version < "1.8.0") {
[13:34:34.310]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.310]                           "", base::R.version$version.string), 
[13:34:34.310]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.310]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.310]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.310]                             "release", "version")], collapse = " "), 
[13:34:34.310]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.310]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.310]                           info)
[13:34:34.310]                         info <- base::paste(info, collapse = "; ")
[13:34:34.310]                         if (!has_future) {
[13:34:34.310]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.310]                             info)
[13:34:34.310]                         }
[13:34:34.310]                         else {
[13:34:34.310]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.310]                             info, version)
[13:34:34.310]                         }
[13:34:34.310]                         base::stop(msg)
[13:34:34.310]                       }
[13:34:34.310]                     })
[13:34:34.310]                   }
[13:34:34.310]                   ...future.strategy.old <- future::plan("list")
[13:34:34.310]                   options(future.plan = NULL)
[13:34:34.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.310]                 }
[13:34:34.310]                 ...future.workdir <- getwd()
[13:34:34.310]             }
[13:34:34.310]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.310]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.310]         }
[13:34:34.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.310]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:34:34.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.310]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.310]             base::names(...future.oldOptions))
[13:34:34.310]     }
[13:34:34.310]     if (FALSE) {
[13:34:34.310]     }
[13:34:34.310]     else {
[13:34:34.310]         if (TRUE) {
[13:34:34.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.310]                 open = "w")
[13:34:34.310]         }
[13:34:34.310]         else {
[13:34:34.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.310]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.310]         }
[13:34:34.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.310]             base::sink(type = "output", split = FALSE)
[13:34:34.310]             base::close(...future.stdout)
[13:34:34.310]         }, add = TRUE)
[13:34:34.310]     }
[13:34:34.310]     ...future.frame <- base::sys.nframe()
[13:34:34.310]     ...future.conditions <- base::list()
[13:34:34.310]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.310]     if (FALSE) {
[13:34:34.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.310]     }
[13:34:34.310]     ...future.result <- base::tryCatch({
[13:34:34.310]         base::withCallingHandlers({
[13:34:34.310]             ...future.value <- base::withVisible(base::local({
[13:34:34.310]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.310]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.310]                   ...future.globals.maxSize)) {
[13:34:34.310]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.310]                   on.exit(options(oopts), add = TRUE)
[13:34:34.310]                 }
[13:34:34.310]                 {
[13:34:34.310]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.310]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.310]                     USE.NAMES = FALSE)
[13:34:34.310]                   do.call(mapply, args = args)
[13:34:34.310]                 }
[13:34:34.310]             }))
[13:34:34.310]             future::FutureResult(value = ...future.value$value, 
[13:34:34.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.310]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.310]                     ...future.globalenv.names))
[13:34:34.310]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.310]         }, condition = base::local({
[13:34:34.310]             c <- base::c
[13:34:34.310]             inherits <- base::inherits
[13:34:34.310]             invokeRestart <- base::invokeRestart
[13:34:34.310]             length <- base::length
[13:34:34.310]             list <- base::list
[13:34:34.310]             seq.int <- base::seq.int
[13:34:34.310]             signalCondition <- base::signalCondition
[13:34:34.310]             sys.calls <- base::sys.calls
[13:34:34.310]             `[[` <- base::`[[`
[13:34:34.310]             `+` <- base::`+`
[13:34:34.310]             `<<-` <- base::`<<-`
[13:34:34.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.310]                   3L)]
[13:34:34.310]             }
[13:34:34.310]             function(cond) {
[13:34:34.310]                 is_error <- inherits(cond, "error")
[13:34:34.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.310]                   NULL)
[13:34:34.310]                 if (is_error) {
[13:34:34.310]                   sessionInformation <- function() {
[13:34:34.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.310]                       search = base::search(), system = base::Sys.info())
[13:34:34.310]                   }
[13:34:34.310]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.310]                     cond$call), session = sessionInformation(), 
[13:34:34.310]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.310]                   signalCondition(cond)
[13:34:34.310]                 }
[13:34:34.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.310]                 "immediateCondition"))) {
[13:34:34.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.310]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.310]                   if (TRUE && !signal) {
[13:34:34.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.310]                     {
[13:34:34.310]                       inherits <- base::inherits
[13:34:34.310]                       invokeRestart <- base::invokeRestart
[13:34:34.310]                       is.null <- base::is.null
[13:34:34.310]                       muffled <- FALSE
[13:34:34.310]                       if (inherits(cond, "message")) {
[13:34:34.310]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.310]                         if (muffled) 
[13:34:34.310]                           invokeRestart("muffleMessage")
[13:34:34.310]                       }
[13:34:34.310]                       else if (inherits(cond, "warning")) {
[13:34:34.310]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.310]                         if (muffled) 
[13:34:34.310]                           invokeRestart("muffleWarning")
[13:34:34.310]                       }
[13:34:34.310]                       else if (inherits(cond, "condition")) {
[13:34:34.310]                         if (!is.null(pattern)) {
[13:34:34.310]                           computeRestarts <- base::computeRestarts
[13:34:34.310]                           grepl <- base::grepl
[13:34:34.310]                           restarts <- computeRestarts(cond)
[13:34:34.310]                           for (restart in restarts) {
[13:34:34.310]                             name <- restart$name
[13:34:34.310]                             if (is.null(name)) 
[13:34:34.310]                               next
[13:34:34.310]                             if (!grepl(pattern, name)) 
[13:34:34.310]                               next
[13:34:34.310]                             invokeRestart(restart)
[13:34:34.310]                             muffled <- TRUE
[13:34:34.310]                             break
[13:34:34.310]                           }
[13:34:34.310]                         }
[13:34:34.310]                       }
[13:34:34.310]                       invisible(muffled)
[13:34:34.310]                     }
[13:34:34.310]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.310]                   }
[13:34:34.310]                 }
[13:34:34.310]                 else {
[13:34:34.310]                   if (TRUE) {
[13:34:34.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.310]                     {
[13:34:34.310]                       inherits <- base::inherits
[13:34:34.310]                       invokeRestart <- base::invokeRestart
[13:34:34.310]                       is.null <- base::is.null
[13:34:34.310]                       muffled <- FALSE
[13:34:34.310]                       if (inherits(cond, "message")) {
[13:34:34.310]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.310]                         if (muffled) 
[13:34:34.310]                           invokeRestart("muffleMessage")
[13:34:34.310]                       }
[13:34:34.310]                       else if (inherits(cond, "warning")) {
[13:34:34.310]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.310]                         if (muffled) 
[13:34:34.310]                           invokeRestart("muffleWarning")
[13:34:34.310]                       }
[13:34:34.310]                       else if (inherits(cond, "condition")) {
[13:34:34.310]                         if (!is.null(pattern)) {
[13:34:34.310]                           computeRestarts <- base::computeRestarts
[13:34:34.310]                           grepl <- base::grepl
[13:34:34.310]                           restarts <- computeRestarts(cond)
[13:34:34.310]                           for (restart in restarts) {
[13:34:34.310]                             name <- restart$name
[13:34:34.310]                             if (is.null(name)) 
[13:34:34.310]                               next
[13:34:34.310]                             if (!grepl(pattern, name)) 
[13:34:34.310]                               next
[13:34:34.310]                             invokeRestart(restart)
[13:34:34.310]                             muffled <- TRUE
[13:34:34.310]                             break
[13:34:34.310]                           }
[13:34:34.310]                         }
[13:34:34.310]                       }
[13:34:34.310]                       invisible(muffled)
[13:34:34.310]                     }
[13:34:34.310]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.310]                   }
[13:34:34.310]                 }
[13:34:34.310]             }
[13:34:34.310]         }))
[13:34:34.310]     }, error = function(ex) {
[13:34:34.310]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.310]                 ...future.rng), started = ...future.startTime, 
[13:34:34.310]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.310]             version = "1.8"), class = "FutureResult")
[13:34:34.310]     }, finally = {
[13:34:34.310]         if (!identical(...future.workdir, getwd())) 
[13:34:34.310]             setwd(...future.workdir)
[13:34:34.310]         {
[13:34:34.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.310]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.310]             }
[13:34:34.310]             base::options(...future.oldOptions)
[13:34:34.310]             if (.Platform$OS.type == "windows") {
[13:34:34.310]                 old_names <- names(...future.oldEnvVars)
[13:34:34.310]                 envs <- base::Sys.getenv()
[13:34:34.310]                 names <- names(envs)
[13:34:34.310]                 common <- intersect(names, old_names)
[13:34:34.310]                 added <- setdiff(names, old_names)
[13:34:34.310]                 removed <- setdiff(old_names, names)
[13:34:34.310]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.310]                   envs[common]]
[13:34:34.310]                 NAMES <- toupper(changed)
[13:34:34.310]                 args <- list()
[13:34:34.310]                 for (kk in seq_along(NAMES)) {
[13:34:34.310]                   name <- changed[[kk]]
[13:34:34.310]                   NAME <- NAMES[[kk]]
[13:34:34.310]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.310]                     next
[13:34:34.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.310]                 }
[13:34:34.310]                 NAMES <- toupper(added)
[13:34:34.310]                 for (kk in seq_along(NAMES)) {
[13:34:34.310]                   name <- added[[kk]]
[13:34:34.310]                   NAME <- NAMES[[kk]]
[13:34:34.310]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.310]                     next
[13:34:34.310]                   args[[name]] <- ""
[13:34:34.310]                 }
[13:34:34.310]                 NAMES <- toupper(removed)
[13:34:34.310]                 for (kk in seq_along(NAMES)) {
[13:34:34.310]                   name <- removed[[kk]]
[13:34:34.310]                   NAME <- NAMES[[kk]]
[13:34:34.310]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.310]                     next
[13:34:34.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.310]                 }
[13:34:34.310]                 if (length(args) > 0) 
[13:34:34.310]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.310]             }
[13:34:34.310]             else {
[13:34:34.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.310]             }
[13:34:34.310]             {
[13:34:34.310]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.310]                   0L) {
[13:34:34.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.310]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.310]                   base::options(opts)
[13:34:34.310]                 }
[13:34:34.310]                 {
[13:34:34.310]                   {
[13:34:34.310]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.310]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.310]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.310]                       inherits = FALSE)
[13:34:34.310]                     NULL
[13:34:34.310]                   }
[13:34:34.310]                   options(future.plan = NULL)
[13:34:34.310]                   if (is.na(NA_character_)) 
[13:34:34.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.310]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.310]                     .init = FALSE)
[13:34:34.310]                 }
[13:34:34.310]             }
[13:34:34.310]         }
[13:34:34.310]     })
[13:34:34.310]     if (TRUE) {
[13:34:34.310]         base::sink(type = "output", split = FALSE)
[13:34:34.310]         if (TRUE) {
[13:34:34.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.310]         }
[13:34:34.310]         else {
[13:34:34.310]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.310]         }
[13:34:34.310]         base::close(...future.stdout)
[13:34:34.310]         ...future.stdout <- NULL
[13:34:34.310]     }
[13:34:34.310]     ...future.result$conditions <- ...future.conditions
[13:34:34.310]     ...future.result$finished <- base::Sys.time()
[13:34:34.310]     ...future.result
[13:34:34.310] }
[13:34:34.311] assign_globals() ...
[13:34:34.312] List of 5
[13:34:34.312]  $ ...future.FUN            :function (C, k)  
[13:34:34.312]  $ MoreArgs                 : NULL
[13:34:34.312]  $ ...future.elements_ii    :List of 2
[13:34:34.312]   ..$ :List of 1
[13:34:34.312]   .. ..$ : chr "C"
[13:34:34.312]   ..$ :List of 1
[13:34:34.312]   .. ..$ : int 3
[13:34:34.312]  $ ...future.seeds_ii       : NULL
[13:34:34.312]  $ ...future.globals.maxSize: NULL
[13:34:34.312]  - attr(*, "where")=List of 5
[13:34:34.312]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.312]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.312]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.312]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.312]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.312]  - attr(*, "resolved")= logi FALSE
[13:34:34.312]  - attr(*, "total_size")= num 3488
[13:34:34.312]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.312]  - attr(*, "already-done")= logi TRUE
[13:34:34.316] - reassign environment for ‘...future.FUN’
[13:34:34.316] - copied ‘...future.FUN’ to environment
[13:34:34.316] - copied ‘MoreArgs’ to environment
[13:34:34.316] - copied ‘...future.elements_ii’ to environment
[13:34:34.316] - copied ‘...future.seeds_ii’ to environment
[13:34:34.317] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.317] assign_globals() ... done
[13:34:34.317] plan(): Setting new future strategy stack:
[13:34:34.317] List of future strategies:
[13:34:34.317] 1. sequential:
[13:34:34.317]    - args: function (..., envir = parent.frame())
[13:34:34.317]    - tweaked: FALSE
[13:34:34.317]    - call: NULL
[13:34:34.317] plan(): nbrOfWorkers() = 1
[13:34:34.318] plan(): Setting new future strategy stack:
[13:34:34.318] List of future strategies:
[13:34:34.318] 1. sequential:
[13:34:34.318]    - args: function (..., envir = parent.frame())
[13:34:34.318]    - tweaked: FALSE
[13:34:34.318]    - call: plan(strategy)
[13:34:34.318] plan(): nbrOfWorkers() = 1
[13:34:34.318] SequentialFuture started (and completed)
[13:34:34.319] - Launch lazy future ... done
[13:34:34.319] run() for ‘SequentialFuture’ ... done
[13:34:34.319] Created future:
[13:34:34.319] SequentialFuture:
[13:34:34.319] Label: ‘future_mapply-2’
[13:34:34.319] Expression:
[13:34:34.319] {
[13:34:34.319]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.319]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.319]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.319]         on.exit(options(oopts), add = TRUE)
[13:34:34.319]     }
[13:34:34.319]     {
[13:34:34.319]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.319]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.319]         do.call(mapply, args = args)
[13:34:34.319]     }
[13:34:34.319] }
[13:34:34.319] Lazy evaluation: FALSE
[13:34:34.319] Asynchronous evaluation: FALSE
[13:34:34.319] Local evaluation: TRUE
[13:34:34.319] Environment: R_GlobalEnv
[13:34:34.319] Capture standard output: TRUE
[13:34:34.319] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.319] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.319] Packages: <none>
[13:34:34.319] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.319] Resolved: TRUE
[13:34:34.319] Value: 112 bytes of class ‘list’
[13:34:34.319] Early signaling: FALSE
[13:34:34.319] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.319] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.320] Chunk #2 of 3 ... DONE
[13:34:34.320] Chunk #3 of 3 ...
[13:34:34.320]  - Finding globals in '...' for chunk #3 ...
[13:34:34.320] getGlobalsAndPackages() ...
[13:34:34.320] Searching for globals...
[13:34:34.320] 
[13:34:34.320] Searching for globals ... DONE
[13:34:34.320] - globals: [0] <none>
[13:34:34.321] getGlobalsAndPackages() ... DONE
[13:34:34.321]    + additional globals found: [n=0] 
[13:34:34.321]    + additional namespaces needed: [n=0] 
[13:34:34.321]  - Finding globals in '...' for chunk #3 ... DONE
[13:34:34.321]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:34:34.321]  - seeds: <none>
[13:34:34.321]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.321] getGlobalsAndPackages() ...
[13:34:34.321] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.321] Resolving globals: FALSE
[13:34:34.322] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:34.322] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.322] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.322] 
[13:34:34.322] getGlobalsAndPackages() ... DONE
[13:34:34.323] run() for ‘Future’ ...
[13:34:34.323] - state: ‘created’
[13:34:34.323] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.323] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.323] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.323]   - Field: ‘label’
[13:34:34.323]   - Field: ‘local’
[13:34:34.324]   - Field: ‘owner’
[13:34:34.324]   - Field: ‘envir’
[13:34:34.324]   - Field: ‘packages’
[13:34:34.324]   - Field: ‘gc’
[13:34:34.324]   - Field: ‘conditions’
[13:34:34.324]   - Field: ‘expr’
[13:34:34.324]   - Field: ‘uuid’
[13:34:34.324]   - Field: ‘seed’
[13:34:34.324]   - Field: ‘version’
[13:34:34.324]   - Field: ‘result’
[13:34:34.324]   - Field: ‘asynchronous’
[13:34:34.325]   - Field: ‘calls’
[13:34:34.325]   - Field: ‘globals’
[13:34:34.325]   - Field: ‘stdout’
[13:34:34.325]   - Field: ‘earlySignal’
[13:34:34.325]   - Field: ‘lazy’
[13:34:34.325]   - Field: ‘state’
[13:34:34.325] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.325] - Launch lazy future ...
[13:34:34.325] Packages needed by the future expression (n = 0): <none>
[13:34:34.325] Packages needed by future strategies (n = 0): <none>
[13:34:34.326] {
[13:34:34.326]     {
[13:34:34.326]         {
[13:34:34.326]             ...future.startTime <- base::Sys.time()
[13:34:34.326]             {
[13:34:34.326]                 {
[13:34:34.326]                   {
[13:34:34.326]                     base::local({
[13:34:34.326]                       has_future <- base::requireNamespace("future", 
[13:34:34.326]                         quietly = TRUE)
[13:34:34.326]                       if (has_future) {
[13:34:34.326]                         ns <- base::getNamespace("future")
[13:34:34.326]                         version <- ns[[".package"]][["version"]]
[13:34:34.326]                         if (is.null(version)) 
[13:34:34.326]                           version <- utils::packageVersion("future")
[13:34:34.326]                       }
[13:34:34.326]                       else {
[13:34:34.326]                         version <- NULL
[13:34:34.326]                       }
[13:34:34.326]                       if (!has_future || version < "1.8.0") {
[13:34:34.326]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.326]                           "", base::R.version$version.string), 
[13:34:34.326]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.326]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.326]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.326]                             "release", "version")], collapse = " "), 
[13:34:34.326]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.326]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.326]                           info)
[13:34:34.326]                         info <- base::paste(info, collapse = "; ")
[13:34:34.326]                         if (!has_future) {
[13:34:34.326]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.326]                             info)
[13:34:34.326]                         }
[13:34:34.326]                         else {
[13:34:34.326]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.326]                             info, version)
[13:34:34.326]                         }
[13:34:34.326]                         base::stop(msg)
[13:34:34.326]                       }
[13:34:34.326]                     })
[13:34:34.326]                   }
[13:34:34.326]                   ...future.strategy.old <- future::plan("list")
[13:34:34.326]                   options(future.plan = NULL)
[13:34:34.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.326]                 }
[13:34:34.326]                 ...future.workdir <- getwd()
[13:34:34.326]             }
[13:34:34.326]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.326]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.326]         }
[13:34:34.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.326]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:34:34.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.326]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.326]             base::names(...future.oldOptions))
[13:34:34.326]     }
[13:34:34.326]     if (FALSE) {
[13:34:34.326]     }
[13:34:34.326]     else {
[13:34:34.326]         if (TRUE) {
[13:34:34.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.326]                 open = "w")
[13:34:34.326]         }
[13:34:34.326]         else {
[13:34:34.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.326]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.326]         }
[13:34:34.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.326]             base::sink(type = "output", split = FALSE)
[13:34:34.326]             base::close(...future.stdout)
[13:34:34.326]         }, add = TRUE)
[13:34:34.326]     }
[13:34:34.326]     ...future.frame <- base::sys.nframe()
[13:34:34.326]     ...future.conditions <- base::list()
[13:34:34.326]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.326]     if (FALSE) {
[13:34:34.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.326]     }
[13:34:34.326]     ...future.result <- base::tryCatch({
[13:34:34.326]         base::withCallingHandlers({
[13:34:34.326]             ...future.value <- base::withVisible(base::local({
[13:34:34.326]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.326]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.326]                   ...future.globals.maxSize)) {
[13:34:34.326]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.326]                   on.exit(options(oopts), add = TRUE)
[13:34:34.326]                 }
[13:34:34.326]                 {
[13:34:34.326]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.326]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.326]                     USE.NAMES = FALSE)
[13:34:34.326]                   do.call(mapply, args = args)
[13:34:34.326]                 }
[13:34:34.326]             }))
[13:34:34.326]             future::FutureResult(value = ...future.value$value, 
[13:34:34.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.326]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.326]                     ...future.globalenv.names))
[13:34:34.326]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.326]         }, condition = base::local({
[13:34:34.326]             c <- base::c
[13:34:34.326]             inherits <- base::inherits
[13:34:34.326]             invokeRestart <- base::invokeRestart
[13:34:34.326]             length <- base::length
[13:34:34.326]             list <- base::list
[13:34:34.326]             seq.int <- base::seq.int
[13:34:34.326]             signalCondition <- base::signalCondition
[13:34:34.326]             sys.calls <- base::sys.calls
[13:34:34.326]             `[[` <- base::`[[`
[13:34:34.326]             `+` <- base::`+`
[13:34:34.326]             `<<-` <- base::`<<-`
[13:34:34.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.326]                   3L)]
[13:34:34.326]             }
[13:34:34.326]             function(cond) {
[13:34:34.326]                 is_error <- inherits(cond, "error")
[13:34:34.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.326]                   NULL)
[13:34:34.326]                 if (is_error) {
[13:34:34.326]                   sessionInformation <- function() {
[13:34:34.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.326]                       search = base::search(), system = base::Sys.info())
[13:34:34.326]                   }
[13:34:34.326]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.326]                     cond$call), session = sessionInformation(), 
[13:34:34.326]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.326]                   signalCondition(cond)
[13:34:34.326]                 }
[13:34:34.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.326]                 "immediateCondition"))) {
[13:34:34.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.326]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.326]                   if (TRUE && !signal) {
[13:34:34.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.326]                     {
[13:34:34.326]                       inherits <- base::inherits
[13:34:34.326]                       invokeRestart <- base::invokeRestart
[13:34:34.326]                       is.null <- base::is.null
[13:34:34.326]                       muffled <- FALSE
[13:34:34.326]                       if (inherits(cond, "message")) {
[13:34:34.326]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.326]                         if (muffled) 
[13:34:34.326]                           invokeRestart("muffleMessage")
[13:34:34.326]                       }
[13:34:34.326]                       else if (inherits(cond, "warning")) {
[13:34:34.326]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.326]                         if (muffled) 
[13:34:34.326]                           invokeRestart("muffleWarning")
[13:34:34.326]                       }
[13:34:34.326]                       else if (inherits(cond, "condition")) {
[13:34:34.326]                         if (!is.null(pattern)) {
[13:34:34.326]                           computeRestarts <- base::computeRestarts
[13:34:34.326]                           grepl <- base::grepl
[13:34:34.326]                           restarts <- computeRestarts(cond)
[13:34:34.326]                           for (restart in restarts) {
[13:34:34.326]                             name <- restart$name
[13:34:34.326]                             if (is.null(name)) 
[13:34:34.326]                               next
[13:34:34.326]                             if (!grepl(pattern, name)) 
[13:34:34.326]                               next
[13:34:34.326]                             invokeRestart(restart)
[13:34:34.326]                             muffled <- TRUE
[13:34:34.326]                             break
[13:34:34.326]                           }
[13:34:34.326]                         }
[13:34:34.326]                       }
[13:34:34.326]                       invisible(muffled)
[13:34:34.326]                     }
[13:34:34.326]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.326]                   }
[13:34:34.326]                 }
[13:34:34.326]                 else {
[13:34:34.326]                   if (TRUE) {
[13:34:34.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.326]                     {
[13:34:34.326]                       inherits <- base::inherits
[13:34:34.326]                       invokeRestart <- base::invokeRestart
[13:34:34.326]                       is.null <- base::is.null
[13:34:34.326]                       muffled <- FALSE
[13:34:34.326]                       if (inherits(cond, "message")) {
[13:34:34.326]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.326]                         if (muffled) 
[13:34:34.326]                           invokeRestart("muffleMessage")
[13:34:34.326]                       }
[13:34:34.326]                       else if (inherits(cond, "warning")) {
[13:34:34.326]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.326]                         if (muffled) 
[13:34:34.326]                           invokeRestart("muffleWarning")
[13:34:34.326]                       }
[13:34:34.326]                       else if (inherits(cond, "condition")) {
[13:34:34.326]                         if (!is.null(pattern)) {
[13:34:34.326]                           computeRestarts <- base::computeRestarts
[13:34:34.326]                           grepl <- base::grepl
[13:34:34.326]                           restarts <- computeRestarts(cond)
[13:34:34.326]                           for (restart in restarts) {
[13:34:34.326]                             name <- restart$name
[13:34:34.326]                             if (is.null(name)) 
[13:34:34.326]                               next
[13:34:34.326]                             if (!grepl(pattern, name)) 
[13:34:34.326]                               next
[13:34:34.326]                             invokeRestart(restart)
[13:34:34.326]                             muffled <- TRUE
[13:34:34.326]                             break
[13:34:34.326]                           }
[13:34:34.326]                         }
[13:34:34.326]                       }
[13:34:34.326]                       invisible(muffled)
[13:34:34.326]                     }
[13:34:34.326]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.326]                   }
[13:34:34.326]                 }
[13:34:34.326]             }
[13:34:34.326]         }))
[13:34:34.326]     }, error = function(ex) {
[13:34:34.326]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.326]                 ...future.rng), started = ...future.startTime, 
[13:34:34.326]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.326]             version = "1.8"), class = "FutureResult")
[13:34:34.326]     }, finally = {
[13:34:34.326]         if (!identical(...future.workdir, getwd())) 
[13:34:34.326]             setwd(...future.workdir)
[13:34:34.326]         {
[13:34:34.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.326]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.326]             }
[13:34:34.326]             base::options(...future.oldOptions)
[13:34:34.326]             if (.Platform$OS.type == "windows") {
[13:34:34.326]                 old_names <- names(...future.oldEnvVars)
[13:34:34.326]                 envs <- base::Sys.getenv()
[13:34:34.326]                 names <- names(envs)
[13:34:34.326]                 common <- intersect(names, old_names)
[13:34:34.326]                 added <- setdiff(names, old_names)
[13:34:34.326]                 removed <- setdiff(old_names, names)
[13:34:34.326]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.326]                   envs[common]]
[13:34:34.326]                 NAMES <- toupper(changed)
[13:34:34.326]                 args <- list()
[13:34:34.326]                 for (kk in seq_along(NAMES)) {
[13:34:34.326]                   name <- changed[[kk]]
[13:34:34.326]                   NAME <- NAMES[[kk]]
[13:34:34.326]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.326]                     next
[13:34:34.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.326]                 }
[13:34:34.326]                 NAMES <- toupper(added)
[13:34:34.326]                 for (kk in seq_along(NAMES)) {
[13:34:34.326]                   name <- added[[kk]]
[13:34:34.326]                   NAME <- NAMES[[kk]]
[13:34:34.326]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.326]                     next
[13:34:34.326]                   args[[name]] <- ""
[13:34:34.326]                 }
[13:34:34.326]                 NAMES <- toupper(removed)
[13:34:34.326]                 for (kk in seq_along(NAMES)) {
[13:34:34.326]                   name <- removed[[kk]]
[13:34:34.326]                   NAME <- NAMES[[kk]]
[13:34:34.326]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.326]                     next
[13:34:34.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.326]                 }
[13:34:34.326]                 if (length(args) > 0) 
[13:34:34.326]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.326]             }
[13:34:34.326]             else {
[13:34:34.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.326]             }
[13:34:34.326]             {
[13:34:34.326]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.326]                   0L) {
[13:34:34.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.326]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.326]                   base::options(opts)
[13:34:34.326]                 }
[13:34:34.326]                 {
[13:34:34.326]                   {
[13:34:34.326]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.326]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.326]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.326]                       inherits = FALSE)
[13:34:34.326]                     NULL
[13:34:34.326]                   }
[13:34:34.326]                   options(future.plan = NULL)
[13:34:34.326]                   if (is.na(NA_character_)) 
[13:34:34.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.326]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.326]                     .init = FALSE)
[13:34:34.326]                 }
[13:34:34.326]             }
[13:34:34.326]         }
[13:34:34.326]     })
[13:34:34.326]     if (TRUE) {
[13:34:34.326]         base::sink(type = "output", split = FALSE)
[13:34:34.326]         if (TRUE) {
[13:34:34.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.326]         }
[13:34:34.326]         else {
[13:34:34.326]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.326]         }
[13:34:34.326]         base::close(...future.stdout)
[13:34:34.326]         ...future.stdout <- NULL
[13:34:34.326]     }
[13:34:34.326]     ...future.result$conditions <- ...future.conditions
[13:34:34.326]     ...future.result$finished <- base::Sys.time()
[13:34:34.326]     ...future.result
[13:34:34.326] }
[13:34:34.327] assign_globals() ...
[13:34:34.327] List of 5
[13:34:34.327]  $ ...future.FUN            :function (C, k)  
[13:34:34.327]  $ MoreArgs                 : NULL
[13:34:34.327]  $ ...future.elements_ii    :List of 2
[13:34:34.327]   ..$ :List of 2
[13:34:34.327]   .. ..$ : chr "B"
[13:34:34.327]   .. ..$ : chr "A"
[13:34:34.327]   ..$ :List of 2
[13:34:34.327]   .. ..$ : int 4
[13:34:34.327]   .. ..$ : int 5
[13:34:34.327]  $ ...future.seeds_ii       : NULL
[13:34:34.327]  $ ...future.globals.maxSize: NULL
[13:34:34.327]  - attr(*, "where")=List of 5
[13:34:34.327]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.327]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.327]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.327]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.327]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.327]  - attr(*, "resolved")= logi FALSE
[13:34:34.327]  - attr(*, "total_size")= num 3656
[13:34:34.327]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.327]  - attr(*, "already-done")= logi TRUE
[13:34:34.333] - reassign environment for ‘...future.FUN’
[13:34:34.334] - copied ‘...future.FUN’ to environment
[13:34:34.334] - copied ‘MoreArgs’ to environment
[13:34:34.334] - copied ‘...future.elements_ii’ to environment
[13:34:34.334] - copied ‘...future.seeds_ii’ to environment
[13:34:34.334] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.334] assign_globals() ... done
[13:34:34.334] plan(): Setting new future strategy stack:
[13:34:34.334] List of future strategies:
[13:34:34.334] 1. sequential:
[13:34:34.334]    - args: function (..., envir = parent.frame())
[13:34:34.334]    - tweaked: FALSE
[13:34:34.334]    - call: NULL
[13:34:34.335] plan(): nbrOfWorkers() = 1
[13:34:34.335] plan(): Setting new future strategy stack:
[13:34:34.335] List of future strategies:
[13:34:34.335] 1. sequential:
[13:34:34.335]    - args: function (..., envir = parent.frame())
[13:34:34.335]    - tweaked: FALSE
[13:34:34.335]    - call: plan(strategy)
[13:34:34.336] plan(): nbrOfWorkers() = 1
[13:34:34.336] SequentialFuture started (and completed)
[13:34:34.336] - Launch lazy future ... done
[13:34:34.336] run() for ‘SequentialFuture’ ... done
[13:34:34.336] Created future:
[13:34:34.336] SequentialFuture:
[13:34:34.336] Label: ‘future_mapply-3’
[13:34:34.336] Expression:
[13:34:34.336] {
[13:34:34.336]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.336]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.336]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.336]         on.exit(options(oopts), add = TRUE)
[13:34:34.336]     }
[13:34:34.336]     {
[13:34:34.336]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.336]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.336]         do.call(mapply, args = args)
[13:34:34.336]     }
[13:34:34.336] }
[13:34:34.336] Lazy evaluation: FALSE
[13:34:34.336] Asynchronous evaluation: FALSE
[13:34:34.336] Local evaluation: TRUE
[13:34:34.336] Environment: R_GlobalEnv
[13:34:34.336] Capture standard output: TRUE
[13:34:34.336] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.336] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.336] Packages: <none>
[13:34:34.336] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.336] Resolved: TRUE
[13:34:34.336] Value: 224 bytes of class ‘list’
[13:34:34.336] Early signaling: FALSE
[13:34:34.336] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.336] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.337] Chunk #3 of 3 ... DONE
[13:34:34.337] Launching 3 futures (chunks) ... DONE
[13:34:34.337] Resolving 3 futures (chunks) ...
[13:34:34.337] resolve() on list ...
[13:34:34.338]  recursive: 0
[13:34:34.338]  length: 3
[13:34:34.338] 
[13:34:34.338] resolved() for ‘SequentialFuture’ ...
[13:34:34.338] - state: ‘finished’
[13:34:34.338] - run: TRUE
[13:34:34.338] - result: ‘FutureResult’
[13:34:34.338] resolved() for ‘SequentialFuture’ ... done
[13:34:34.338] Future #1
[13:34:34.338] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.339] - nx: 3
[13:34:34.339] - relay: TRUE
[13:34:34.339] - stdout: TRUE
[13:34:34.339] - signal: TRUE
[13:34:34.339] - resignal: FALSE
[13:34:34.339] - force: TRUE
[13:34:34.339] - relayed: [n=3] FALSE, FALSE, FALSE
[13:34:34.339] - queued futures: [n=3] FALSE, FALSE, FALSE
[13:34:34.339]  - until=1
[13:34:34.339]  - relaying element #1
[13:34:34.339] - relayed: [n=3] TRUE, FALSE, FALSE
[13:34:34.340] - queued futures: [n=3] TRUE, FALSE, FALSE
[13:34:34.340] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.340]  length: 2 (resolved future 1)
[13:34:34.340] resolved() for ‘SequentialFuture’ ...
[13:34:34.340] - state: ‘finished’
[13:34:34.340] - run: TRUE
[13:34:34.340] - result: ‘FutureResult’
[13:34:34.340] resolved() for ‘SequentialFuture’ ... done
[13:34:34.340] Future #2
[13:34:34.340] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:34:34.341] - nx: 3
[13:34:34.341] - relay: TRUE
[13:34:34.341] - stdout: TRUE
[13:34:34.341] - signal: TRUE
[13:34:34.341] - resignal: FALSE
[13:34:34.341] - force: TRUE
[13:34:34.341] - relayed: [n=3] TRUE, FALSE, FALSE
[13:34:34.341] - queued futures: [n=3] TRUE, FALSE, FALSE
[13:34:34.341]  - until=2
[13:34:34.341]  - relaying element #2
[13:34:34.341] - relayed: [n=3] TRUE, TRUE, FALSE
[13:34:34.342] - queued futures: [n=3] TRUE, TRUE, FALSE
[13:34:34.342] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:34:34.342]  length: 1 (resolved future 2)
[13:34:34.342] resolved() for ‘SequentialFuture’ ...
[13:34:34.342] - state: ‘finished’
[13:34:34.342] - run: TRUE
[13:34:34.342] - result: ‘FutureResult’
[13:34:34.342] resolved() for ‘SequentialFuture’ ... done
[13:34:34.342] Future #3
[13:34:34.342] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:34:34.343] - nx: 3
[13:34:34.343] - relay: TRUE
[13:34:34.343] - stdout: TRUE
[13:34:34.343] - signal: TRUE
[13:34:34.343] - resignal: FALSE
[13:34:34.343] - force: TRUE
[13:34:34.343] - relayed: [n=3] TRUE, TRUE, FALSE
[13:34:34.343] - queued futures: [n=3] TRUE, TRUE, FALSE
[13:34:34.343]  - until=3
[13:34:34.343]  - relaying element #3
[13:34:34.343] - relayed: [n=3] TRUE, TRUE, TRUE
[13:34:34.343] - queued futures: [n=3] TRUE, TRUE, TRUE
[13:34:34.344] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:34:34.344]  length: 0 (resolved future 3)
[13:34:34.344] Relaying remaining futures
[13:34:34.344] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.344] - nx: 3
[13:34:34.344] - relay: TRUE
[13:34:34.344] - stdout: TRUE
[13:34:34.344] - signal: TRUE
[13:34:34.344] - resignal: FALSE
[13:34:34.344] - force: TRUE
[13:34:34.344] - relayed: [n=3] TRUE, TRUE, TRUE
[13:34:34.344] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[13:34:34.345] - relayed: [n=3] TRUE, TRUE, TRUE
[13:34:34.345] - queued futures: [n=3] TRUE, TRUE, TRUE
[13:34:34.345] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.345] resolve() on list ... DONE
[13:34:34.345]  - Number of value chunks collected: 3
[13:34:34.345] Resolving 3 futures (chunks) ... DONE
[13:34:34.345] Reducing values from 3 chunks ...
[13:34:34.345]  - Number of values collected after concatenation: 5
[13:34:34.345]  - Number of values expected: 5
[13:34:34.345] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 1, 2
[13:34:34.346] Reducing values from 3 chunks ... DONE
[13:34:34.346] future_mapply() ... DONE
[13:34:34.346] future_mapply() ...
[13:34:34.346] Number of chunks: 1
[13:34:34.346] getGlobalsAndPackagesXApply() ...
[13:34:34.346]  - future.globals: TRUE
[13:34:34.346] getGlobalsAndPackages() ...
[13:34:34.346] Searching for globals...
[13:34:34.348] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:34.348] Searching for globals ... DONE
[13:34:34.348] Resolving globals: FALSE
[13:34:34.348] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:34.349] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:34.349] - globals: [1] ‘FUN’
[13:34:34.349] 
[13:34:34.350] getGlobalsAndPackages() ... DONE
[13:34:34.350]  - globals found/used: [n=1] ‘FUN’
[13:34:34.350]  - needed namespaces: [n=0] 
[13:34:34.350] Finding globals ... DONE
[13:34:34.351] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.351] List of 2
[13:34:34.351]  $ ...future.FUN:function (C, k)  
[13:34:34.351]  $ MoreArgs     : list()
[13:34:34.351]  - attr(*, "where")=List of 2
[13:34:34.351]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.351]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.351]  - attr(*, "resolved")= logi FALSE
[13:34:34.351]  - attr(*, "total_size")= num NA
[13:34:34.353] Packages to be attached in all futures: [n=0] 
[13:34:34.353] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.354] Number of futures (= number of chunks): 1
[13:34:34.354] Launching 1 futures (chunks) ...
[13:34:34.354] Chunk #1 of 1 ...
[13:34:34.354]  - Finding globals in '...' for chunk #1 ...
[13:34:34.354] getGlobalsAndPackages() ...
[13:34:34.354] Searching for globals...
[13:34:34.354] 
[13:34:34.355] Searching for globals ... DONE
[13:34:34.355] - globals: [0] <none>
[13:34:34.355] getGlobalsAndPackages() ... DONE
[13:34:34.355]    + additional globals found: [n=0] 
[13:34:34.355]    + additional namespaces needed: [n=0] 
[13:34:34.355]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.355]  - seeds: <none>
[13:34:34.355]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.355] getGlobalsAndPackages() ...
[13:34:34.355] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.355] Resolving globals: FALSE
[13:34:34.356] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[13:34:34.356] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:34.356] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.357] 
[13:34:34.357] getGlobalsAndPackages() ... DONE
[13:34:34.357] run() for ‘Future’ ...
[13:34:34.357] - state: ‘created’
[13:34:34.357] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.357] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.358]   - Field: ‘label’
[13:34:34.358]   - Field: ‘local’
[13:34:34.358]   - Field: ‘owner’
[13:34:34.358]   - Field: ‘envir’
[13:34:34.358]   - Field: ‘packages’
[13:34:34.358]   - Field: ‘gc’
[13:34:34.358]   - Field: ‘conditions’
[13:34:34.358]   - Field: ‘expr’
[13:34:34.358]   - Field: ‘uuid’
[13:34:34.358]   - Field: ‘seed’
[13:34:34.359]   - Field: ‘version’
[13:34:34.359]   - Field: ‘result’
[13:34:34.359]   - Field: ‘asynchronous’
[13:34:34.359]   - Field: ‘calls’
[13:34:34.359]   - Field: ‘globals’
[13:34:34.359]   - Field: ‘stdout’
[13:34:34.359]   - Field: ‘earlySignal’
[13:34:34.359]   - Field: ‘lazy’
[13:34:34.359]   - Field: ‘state’
[13:34:34.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.359] - Launch lazy future ...
[13:34:34.360] Packages needed by the future expression (n = 0): <none>
[13:34:34.360] Packages needed by future strategies (n = 0): <none>
[13:34:34.360] {
[13:34:34.360]     {
[13:34:34.360]         {
[13:34:34.360]             ...future.startTime <- base::Sys.time()
[13:34:34.360]             {
[13:34:34.360]                 {
[13:34:34.360]                   {
[13:34:34.360]                     base::local({
[13:34:34.360]                       has_future <- base::requireNamespace("future", 
[13:34:34.360]                         quietly = TRUE)
[13:34:34.360]                       if (has_future) {
[13:34:34.360]                         ns <- base::getNamespace("future")
[13:34:34.360]                         version <- ns[[".package"]][["version"]]
[13:34:34.360]                         if (is.null(version)) 
[13:34:34.360]                           version <- utils::packageVersion("future")
[13:34:34.360]                       }
[13:34:34.360]                       else {
[13:34:34.360]                         version <- NULL
[13:34:34.360]                       }
[13:34:34.360]                       if (!has_future || version < "1.8.0") {
[13:34:34.360]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.360]                           "", base::R.version$version.string), 
[13:34:34.360]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.360]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.360]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.360]                             "release", "version")], collapse = " "), 
[13:34:34.360]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.360]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.360]                           info)
[13:34:34.360]                         info <- base::paste(info, collapse = "; ")
[13:34:34.360]                         if (!has_future) {
[13:34:34.360]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.360]                             info)
[13:34:34.360]                         }
[13:34:34.360]                         else {
[13:34:34.360]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.360]                             info, version)
[13:34:34.360]                         }
[13:34:34.360]                         base::stop(msg)
[13:34:34.360]                       }
[13:34:34.360]                     })
[13:34:34.360]                   }
[13:34:34.360]                   ...future.strategy.old <- future::plan("list")
[13:34:34.360]                   options(future.plan = NULL)
[13:34:34.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.360]                 }
[13:34:34.360]                 ...future.workdir <- getwd()
[13:34:34.360]             }
[13:34:34.360]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.360]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.360]         }
[13:34:34.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.360]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.360]             base::names(...future.oldOptions))
[13:34:34.360]     }
[13:34:34.360]     if (FALSE) {
[13:34:34.360]     }
[13:34:34.360]     else {
[13:34:34.360]         if (TRUE) {
[13:34:34.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.360]                 open = "w")
[13:34:34.360]         }
[13:34:34.360]         else {
[13:34:34.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.360]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.360]         }
[13:34:34.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.360]             base::sink(type = "output", split = FALSE)
[13:34:34.360]             base::close(...future.stdout)
[13:34:34.360]         }, add = TRUE)
[13:34:34.360]     }
[13:34:34.360]     ...future.frame <- base::sys.nframe()
[13:34:34.360]     ...future.conditions <- base::list()
[13:34:34.360]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.360]     if (FALSE) {
[13:34:34.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.360]     }
[13:34:34.360]     ...future.result <- base::tryCatch({
[13:34:34.360]         base::withCallingHandlers({
[13:34:34.360]             ...future.value <- base::withVisible(base::local({
[13:34:34.360]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.360]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.360]                   ...future.globals.maxSize)) {
[13:34:34.360]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.360]                   on.exit(options(oopts), add = TRUE)
[13:34:34.360]                 }
[13:34:34.360]                 {
[13:34:34.360]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.360]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.360]                     USE.NAMES = FALSE)
[13:34:34.360]                   do.call(mapply, args = args)
[13:34:34.360]                 }
[13:34:34.360]             }))
[13:34:34.360]             future::FutureResult(value = ...future.value$value, 
[13:34:34.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.360]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.360]                     ...future.globalenv.names))
[13:34:34.360]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.360]         }, condition = base::local({
[13:34:34.360]             c <- base::c
[13:34:34.360]             inherits <- base::inherits
[13:34:34.360]             invokeRestart <- base::invokeRestart
[13:34:34.360]             length <- base::length
[13:34:34.360]             list <- base::list
[13:34:34.360]             seq.int <- base::seq.int
[13:34:34.360]             signalCondition <- base::signalCondition
[13:34:34.360]             sys.calls <- base::sys.calls
[13:34:34.360]             `[[` <- base::`[[`
[13:34:34.360]             `+` <- base::`+`
[13:34:34.360]             `<<-` <- base::`<<-`
[13:34:34.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.360]                   3L)]
[13:34:34.360]             }
[13:34:34.360]             function(cond) {
[13:34:34.360]                 is_error <- inherits(cond, "error")
[13:34:34.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.360]                   NULL)
[13:34:34.360]                 if (is_error) {
[13:34:34.360]                   sessionInformation <- function() {
[13:34:34.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.360]                       search = base::search(), system = base::Sys.info())
[13:34:34.360]                   }
[13:34:34.360]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.360]                     cond$call), session = sessionInformation(), 
[13:34:34.360]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.360]                   signalCondition(cond)
[13:34:34.360]                 }
[13:34:34.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.360]                 "immediateCondition"))) {
[13:34:34.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.360]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.360]                   if (TRUE && !signal) {
[13:34:34.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.360]                     {
[13:34:34.360]                       inherits <- base::inherits
[13:34:34.360]                       invokeRestart <- base::invokeRestart
[13:34:34.360]                       is.null <- base::is.null
[13:34:34.360]                       muffled <- FALSE
[13:34:34.360]                       if (inherits(cond, "message")) {
[13:34:34.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.360]                         if (muffled) 
[13:34:34.360]                           invokeRestart("muffleMessage")
[13:34:34.360]                       }
[13:34:34.360]                       else if (inherits(cond, "warning")) {
[13:34:34.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.360]                         if (muffled) 
[13:34:34.360]                           invokeRestart("muffleWarning")
[13:34:34.360]                       }
[13:34:34.360]                       else if (inherits(cond, "condition")) {
[13:34:34.360]                         if (!is.null(pattern)) {
[13:34:34.360]                           computeRestarts <- base::computeRestarts
[13:34:34.360]                           grepl <- base::grepl
[13:34:34.360]                           restarts <- computeRestarts(cond)
[13:34:34.360]                           for (restart in restarts) {
[13:34:34.360]                             name <- restart$name
[13:34:34.360]                             if (is.null(name)) 
[13:34:34.360]                               next
[13:34:34.360]                             if (!grepl(pattern, name)) 
[13:34:34.360]                               next
[13:34:34.360]                             invokeRestart(restart)
[13:34:34.360]                             muffled <- TRUE
[13:34:34.360]                             break
[13:34:34.360]                           }
[13:34:34.360]                         }
[13:34:34.360]                       }
[13:34:34.360]                       invisible(muffled)
[13:34:34.360]                     }
[13:34:34.360]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.360]                   }
[13:34:34.360]                 }
[13:34:34.360]                 else {
[13:34:34.360]                   if (TRUE) {
[13:34:34.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.360]                     {
[13:34:34.360]                       inherits <- base::inherits
[13:34:34.360]                       invokeRestart <- base::invokeRestart
[13:34:34.360]                       is.null <- base::is.null
[13:34:34.360]                       muffled <- FALSE
[13:34:34.360]                       if (inherits(cond, "message")) {
[13:34:34.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.360]                         if (muffled) 
[13:34:34.360]                           invokeRestart("muffleMessage")
[13:34:34.360]                       }
[13:34:34.360]                       else if (inherits(cond, "warning")) {
[13:34:34.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.360]                         if (muffled) 
[13:34:34.360]                           invokeRestart("muffleWarning")
[13:34:34.360]                       }
[13:34:34.360]                       else if (inherits(cond, "condition")) {
[13:34:34.360]                         if (!is.null(pattern)) {
[13:34:34.360]                           computeRestarts <- base::computeRestarts
[13:34:34.360]                           grepl <- base::grepl
[13:34:34.360]                           restarts <- computeRestarts(cond)
[13:34:34.360]                           for (restart in restarts) {
[13:34:34.360]                             name <- restart$name
[13:34:34.360]                             if (is.null(name)) 
[13:34:34.360]                               next
[13:34:34.360]                             if (!grepl(pattern, name)) 
[13:34:34.360]                               next
[13:34:34.360]                             invokeRestart(restart)
[13:34:34.360]                             muffled <- TRUE
[13:34:34.360]                             break
[13:34:34.360]                           }
[13:34:34.360]                         }
[13:34:34.360]                       }
[13:34:34.360]                       invisible(muffled)
[13:34:34.360]                     }
[13:34:34.360]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.360]                   }
[13:34:34.360]                 }
[13:34:34.360]             }
[13:34:34.360]         }))
[13:34:34.360]     }, error = function(ex) {
[13:34:34.360]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.360]                 ...future.rng), started = ...future.startTime, 
[13:34:34.360]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.360]             version = "1.8"), class = "FutureResult")
[13:34:34.360]     }, finally = {
[13:34:34.360]         if (!identical(...future.workdir, getwd())) 
[13:34:34.360]             setwd(...future.workdir)
[13:34:34.360]         {
[13:34:34.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.360]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.360]             }
[13:34:34.360]             base::options(...future.oldOptions)
[13:34:34.360]             if (.Platform$OS.type == "windows") {
[13:34:34.360]                 old_names <- names(...future.oldEnvVars)
[13:34:34.360]                 envs <- base::Sys.getenv()
[13:34:34.360]                 names <- names(envs)
[13:34:34.360]                 common <- intersect(names, old_names)
[13:34:34.360]                 added <- setdiff(names, old_names)
[13:34:34.360]                 removed <- setdiff(old_names, names)
[13:34:34.360]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.360]                   envs[common]]
[13:34:34.360]                 NAMES <- toupper(changed)
[13:34:34.360]                 args <- list()
[13:34:34.360]                 for (kk in seq_along(NAMES)) {
[13:34:34.360]                   name <- changed[[kk]]
[13:34:34.360]                   NAME <- NAMES[[kk]]
[13:34:34.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.360]                     next
[13:34:34.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.360]                 }
[13:34:34.360]                 NAMES <- toupper(added)
[13:34:34.360]                 for (kk in seq_along(NAMES)) {
[13:34:34.360]                   name <- added[[kk]]
[13:34:34.360]                   NAME <- NAMES[[kk]]
[13:34:34.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.360]                     next
[13:34:34.360]                   args[[name]] <- ""
[13:34:34.360]                 }
[13:34:34.360]                 NAMES <- toupper(removed)
[13:34:34.360]                 for (kk in seq_along(NAMES)) {
[13:34:34.360]                   name <- removed[[kk]]
[13:34:34.360]                   NAME <- NAMES[[kk]]
[13:34:34.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.360]                     next
[13:34:34.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.360]                 }
[13:34:34.360]                 if (length(args) > 0) 
[13:34:34.360]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.360]             }
[13:34:34.360]             else {
[13:34:34.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.360]             }
[13:34:34.360]             {
[13:34:34.360]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.360]                   0L) {
[13:34:34.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.360]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.360]                   base::options(opts)
[13:34:34.360]                 }
[13:34:34.360]                 {
[13:34:34.360]                   {
[13:34:34.360]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.360]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.360]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.360]                       inherits = FALSE)
[13:34:34.360]                     NULL
[13:34:34.360]                   }
[13:34:34.360]                   options(future.plan = NULL)
[13:34:34.360]                   if (is.na(NA_character_)) 
[13:34:34.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.360]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.360]                     .init = FALSE)
[13:34:34.360]                 }
[13:34:34.360]             }
[13:34:34.360]         }
[13:34:34.360]     })
[13:34:34.360]     if (TRUE) {
[13:34:34.360]         base::sink(type = "output", split = FALSE)
[13:34:34.360]         if (TRUE) {
[13:34:34.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.360]         }
[13:34:34.360]         else {
[13:34:34.360]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.360]         }
[13:34:34.360]         base::close(...future.stdout)
[13:34:34.360]         ...future.stdout <- NULL
[13:34:34.360]     }
[13:34:34.360]     ...future.result$conditions <- ...future.conditions
[13:34:34.360]     ...future.result$finished <- base::Sys.time()
[13:34:34.360]     ...future.result
[13:34:34.360] }
[13:34:34.362] assign_globals() ...
[13:34:34.362] List of 5
[13:34:34.362]  $ ...future.FUN            :function (C, k)  
[13:34:34.362]  $ MoreArgs                 : list()
[13:34:34.362]  $ ...future.elements_ii    :List of 2
[13:34:34.362]   ..$ :List of 5
[13:34:34.362]   .. ..$ : chr "A"
[13:34:34.362]   .. ..$ : chr "B"
[13:34:34.362]   .. ..$ : chr "C"
[13:34:34.362]   .. ..$ : chr "D"
[13:34:34.362]   .. ..$ : chr "E"
[13:34:34.362]   ..$ :List of 5
[13:34:34.362]   .. ..$ : int 5
[13:34:34.362]   .. ..$ : int 4
[13:34:34.362]   .. ..$ : int 3
[13:34:34.362]   .. ..$ : int 2
[13:34:34.362]   .. ..$ : int 1
[13:34:34.362]  $ ...future.seeds_ii       : NULL
[13:34:34.362]  $ ...future.globals.maxSize: NULL
[13:34:34.362]  - attr(*, "where")=List of 5
[13:34:34.362]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.362]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.362]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.362]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.362]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.362]  - attr(*, "resolved")= logi FALSE
[13:34:34.362]  - attr(*, "total_size")= num 4160
[13:34:34.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.362]  - attr(*, "already-done")= logi TRUE
[13:34:34.368] - reassign environment for ‘...future.FUN’
[13:34:34.368] - copied ‘...future.FUN’ to environment
[13:34:34.368] - copied ‘MoreArgs’ to environment
[13:34:34.369] - copied ‘...future.elements_ii’ to environment
[13:34:34.369] - copied ‘...future.seeds_ii’ to environment
[13:34:34.369] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.369] assign_globals() ... done
[13:34:34.369] plan(): Setting new future strategy stack:
[13:34:34.369] List of future strategies:
[13:34:34.369] 1. sequential:
[13:34:34.369]    - args: function (..., envir = parent.frame())
[13:34:34.369]    - tweaked: FALSE
[13:34:34.369]    - call: NULL
[13:34:34.369] plan(): nbrOfWorkers() = 1
[13:34:34.370] plan(): Setting new future strategy stack:
[13:34:34.370] List of future strategies:
[13:34:34.370] 1. sequential:
[13:34:34.370]    - args: function (..., envir = parent.frame())
[13:34:34.370]    - tweaked: FALSE
[13:34:34.370]    - call: plan(strategy)
[13:34:34.371] plan(): nbrOfWorkers() = 1
[13:34:34.371] SequentialFuture started (and completed)
[13:34:34.371] - Launch lazy future ... done
[13:34:34.371] run() for ‘SequentialFuture’ ... done
[13:34:34.371] Created future:
[13:34:34.371] SequentialFuture:
[13:34:34.371] Label: ‘future_.mapply-1’
[13:34:34.371] Expression:
[13:34:34.371] {
[13:34:34.371]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.371]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.371]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.371]         on.exit(options(oopts), add = TRUE)
[13:34:34.371]     }
[13:34:34.371]     {
[13:34:34.371]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.371]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.371]         do.call(mapply, args = args)
[13:34:34.371]     }
[13:34:34.371] }
[13:34:34.371] Lazy evaluation: FALSE
[13:34:34.371] Asynchronous evaluation: FALSE
[13:34:34.371] Local evaluation: TRUE
[13:34:34.371] Environment: R_GlobalEnv
[13:34:34.371] Capture standard output: TRUE
[13:34:34.371] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.371] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.371] Packages: <none>
[13:34:34.371] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.371] Resolved: TRUE
[13:34:34.371] Value: 560 bytes of class ‘list’
[13:34:34.371] Early signaling: FALSE
[13:34:34.371] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.371] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.373] Chunk #1 of 1 ... DONE
[13:34:34.373] Launching 1 futures (chunks) ... DONE
[13:34:34.373] Resolving 1 futures (chunks) ...
[13:34:34.373] resolve() on list ...
[13:34:34.373]  recursive: 0
[13:34:34.373]  length: 1
[13:34:34.373] 
[13:34:34.374] resolved() for ‘SequentialFuture’ ...
[13:34:34.374] - state: ‘finished’
[13:34:34.374] - run: TRUE
[13:34:34.374] - result: ‘FutureResult’
[13:34:34.374] resolved() for ‘SequentialFuture’ ... done
[13:34:34.374] Future #1
[13:34:34.374] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.374] - nx: 1
[13:34:34.374] - relay: TRUE
[13:34:34.374] - stdout: TRUE
[13:34:34.375] - signal: TRUE
[13:34:34.375] - resignal: FALSE
[13:34:34.375] - force: TRUE
[13:34:34.375] - relayed: [n=1] FALSE
[13:34:34.375] - queued futures: [n=1] FALSE
[13:34:34.375]  - until=1
[13:34:34.375]  - relaying element #1
[13:34:34.375] - relayed: [n=1] TRUE
[13:34:34.375] - queued futures: [n=1] TRUE
[13:34:34.375] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.375]  length: 0 (resolved future 1)
[13:34:34.376] Relaying remaining futures
[13:34:34.376] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.376] - nx: 1
[13:34:34.376] - relay: TRUE
[13:34:34.376] - stdout: TRUE
[13:34:34.376] - signal: TRUE
[13:34:34.376] - resignal: FALSE
[13:34:34.376] - force: TRUE
[13:34:34.376] - relayed: [n=1] TRUE
[13:34:34.376] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.376] - relayed: [n=1] TRUE
[13:34:34.376] - queued futures: [n=1] TRUE
[13:34:34.377] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.377] resolve() on list ... DONE
[13:34:34.377]  - Number of value chunks collected: 1
[13:34:34.377] Resolving 1 futures (chunks) ... DONE
[13:34:34.377] Reducing values from 1 chunks ...
[13:34:34.377]  - Number of values collected after concatenation: 5
[13:34:34.377]  - Number of values expected: 5
[13:34:34.377] Reducing values from 1 chunks ... DONE
[13:34:34.377] future_mapply() ... DONE
[13:34:34.377] future_mapply() ...
[13:34:34.378] Number of chunks: 2
[13:34:34.378] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[13:34:34.378] getGlobalsAndPackagesXApply() ...
[13:34:34.378]  - future.globals: TRUE
[13:34:34.378] getGlobalsAndPackages() ...
[13:34:34.378] Searching for globals...
[13:34:34.379] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:34.380] Searching for globals ... DONE
[13:34:34.380] Resolving globals: FALSE
[13:34:34.380] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:34.380] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:34.380] - globals: [1] ‘FUN’
[13:34:34.380] 
[13:34:34.381] getGlobalsAndPackages() ... DONE
[13:34:34.381]  - globals found/used: [n=1] ‘FUN’
[13:34:34.381]  - needed namespaces: [n=0] 
[13:34:34.381] Finding globals ... DONE
[13:34:34.381] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.381] List of 2
[13:34:34.381]  $ ...future.FUN:function (C, k)  
[13:34:34.381]  $ MoreArgs     : NULL
[13:34:34.381]  - attr(*, "where")=List of 2
[13:34:34.381]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.381]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.381]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.381]  - attr(*, "resolved")= logi FALSE
[13:34:34.381]  - attr(*, "total_size")= num NA
[13:34:34.383] Packages to be attached in all futures: [n=0] 
[13:34:34.383] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.384] Number of futures (= number of chunks): 2
[13:34:34.384] Launching 2 futures (chunks) ...
[13:34:34.384] Chunk #1 of 2 ...
[13:34:34.384]  - Finding globals in '...' for chunk #1 ...
[13:34:34.384] getGlobalsAndPackages() ...
[13:34:34.384] Searching for globals...
[13:34:34.384] 
[13:34:34.385] Searching for globals ... DONE
[13:34:34.385] - globals: [0] <none>
[13:34:34.385] getGlobalsAndPackages() ... DONE
[13:34:34.385]    + additional globals found: [n=0] 
[13:34:34.385]    + additional namespaces needed: [n=0] 
[13:34:34.385]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.385]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:34.385]  - seeds: <none>
[13:34:34.385]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.385] getGlobalsAndPackages() ...
[13:34:34.385] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.386] Resolving globals: FALSE
[13:34:34.386] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:34.386] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.386] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.387] 
[13:34:34.387] getGlobalsAndPackages() ... DONE
[13:34:34.387] run() for ‘Future’ ...
[13:34:34.387] - state: ‘created’
[13:34:34.387] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.387] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.387] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.388]   - Field: ‘label’
[13:34:34.388]   - Field: ‘local’
[13:34:34.388]   - Field: ‘owner’
[13:34:34.388]   - Field: ‘envir’
[13:34:34.388]   - Field: ‘packages’
[13:34:34.388]   - Field: ‘gc’
[13:34:34.388]   - Field: ‘conditions’
[13:34:34.388]   - Field: ‘expr’
[13:34:34.388]   - Field: ‘uuid’
[13:34:34.388]   - Field: ‘seed’
[13:34:34.388]   - Field: ‘version’
[13:34:34.388]   - Field: ‘result’
[13:34:34.389]   - Field: ‘asynchronous’
[13:34:34.389]   - Field: ‘calls’
[13:34:34.389]   - Field: ‘globals’
[13:34:34.389]   - Field: ‘stdout’
[13:34:34.389]   - Field: ‘earlySignal’
[13:34:34.389]   - Field: ‘lazy’
[13:34:34.389]   - Field: ‘state’
[13:34:34.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.389] - Launch lazy future ...
[13:34:34.389] Packages needed by the future expression (n = 0): <none>
[13:34:34.390] Packages needed by future strategies (n = 0): <none>
[13:34:34.390] {
[13:34:34.390]     {
[13:34:34.390]         {
[13:34:34.390]             ...future.startTime <- base::Sys.time()
[13:34:34.390]             {
[13:34:34.390]                 {
[13:34:34.390]                   {
[13:34:34.390]                     base::local({
[13:34:34.390]                       has_future <- base::requireNamespace("future", 
[13:34:34.390]                         quietly = TRUE)
[13:34:34.390]                       if (has_future) {
[13:34:34.390]                         ns <- base::getNamespace("future")
[13:34:34.390]                         version <- ns[[".package"]][["version"]]
[13:34:34.390]                         if (is.null(version)) 
[13:34:34.390]                           version <- utils::packageVersion("future")
[13:34:34.390]                       }
[13:34:34.390]                       else {
[13:34:34.390]                         version <- NULL
[13:34:34.390]                       }
[13:34:34.390]                       if (!has_future || version < "1.8.0") {
[13:34:34.390]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.390]                           "", base::R.version$version.string), 
[13:34:34.390]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.390]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.390]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.390]                             "release", "version")], collapse = " "), 
[13:34:34.390]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.390]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.390]                           info)
[13:34:34.390]                         info <- base::paste(info, collapse = "; ")
[13:34:34.390]                         if (!has_future) {
[13:34:34.390]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.390]                             info)
[13:34:34.390]                         }
[13:34:34.390]                         else {
[13:34:34.390]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.390]                             info, version)
[13:34:34.390]                         }
[13:34:34.390]                         base::stop(msg)
[13:34:34.390]                       }
[13:34:34.390]                     })
[13:34:34.390]                   }
[13:34:34.390]                   ...future.strategy.old <- future::plan("list")
[13:34:34.390]                   options(future.plan = NULL)
[13:34:34.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.390]                 }
[13:34:34.390]                 ...future.workdir <- getwd()
[13:34:34.390]             }
[13:34:34.390]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.390]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.390]         }
[13:34:34.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.390]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:34.390]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.390]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.390]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.390]             base::names(...future.oldOptions))
[13:34:34.390]     }
[13:34:34.390]     if (FALSE) {
[13:34:34.390]     }
[13:34:34.390]     else {
[13:34:34.390]         if (TRUE) {
[13:34:34.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.390]                 open = "w")
[13:34:34.390]         }
[13:34:34.390]         else {
[13:34:34.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.390]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.390]         }
[13:34:34.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.390]             base::sink(type = "output", split = FALSE)
[13:34:34.390]             base::close(...future.stdout)
[13:34:34.390]         }, add = TRUE)
[13:34:34.390]     }
[13:34:34.390]     ...future.frame <- base::sys.nframe()
[13:34:34.390]     ...future.conditions <- base::list()
[13:34:34.390]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.390]     if (FALSE) {
[13:34:34.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.390]     }
[13:34:34.390]     ...future.result <- base::tryCatch({
[13:34:34.390]         base::withCallingHandlers({
[13:34:34.390]             ...future.value <- base::withVisible(base::local({
[13:34:34.390]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.390]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.390]                   ...future.globals.maxSize)) {
[13:34:34.390]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.390]                   on.exit(options(oopts), add = TRUE)
[13:34:34.390]                 }
[13:34:34.390]                 {
[13:34:34.390]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.390]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.390]                     USE.NAMES = FALSE)
[13:34:34.390]                   do.call(mapply, args = args)
[13:34:34.390]                 }
[13:34:34.390]             }))
[13:34:34.390]             future::FutureResult(value = ...future.value$value, 
[13:34:34.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.390]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.390]                     ...future.globalenv.names))
[13:34:34.390]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.390]         }, condition = base::local({
[13:34:34.390]             c <- base::c
[13:34:34.390]             inherits <- base::inherits
[13:34:34.390]             invokeRestart <- base::invokeRestart
[13:34:34.390]             length <- base::length
[13:34:34.390]             list <- base::list
[13:34:34.390]             seq.int <- base::seq.int
[13:34:34.390]             signalCondition <- base::signalCondition
[13:34:34.390]             sys.calls <- base::sys.calls
[13:34:34.390]             `[[` <- base::`[[`
[13:34:34.390]             `+` <- base::`+`
[13:34:34.390]             `<<-` <- base::`<<-`
[13:34:34.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.390]                   3L)]
[13:34:34.390]             }
[13:34:34.390]             function(cond) {
[13:34:34.390]                 is_error <- inherits(cond, "error")
[13:34:34.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.390]                   NULL)
[13:34:34.390]                 if (is_error) {
[13:34:34.390]                   sessionInformation <- function() {
[13:34:34.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.390]                       search = base::search(), system = base::Sys.info())
[13:34:34.390]                   }
[13:34:34.390]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.390]                     cond$call), session = sessionInformation(), 
[13:34:34.390]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.390]                   signalCondition(cond)
[13:34:34.390]                 }
[13:34:34.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.390]                 "immediateCondition"))) {
[13:34:34.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.390]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.390]                   if (TRUE && !signal) {
[13:34:34.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.390]                     {
[13:34:34.390]                       inherits <- base::inherits
[13:34:34.390]                       invokeRestart <- base::invokeRestart
[13:34:34.390]                       is.null <- base::is.null
[13:34:34.390]                       muffled <- FALSE
[13:34:34.390]                       if (inherits(cond, "message")) {
[13:34:34.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.390]                         if (muffled) 
[13:34:34.390]                           invokeRestart("muffleMessage")
[13:34:34.390]                       }
[13:34:34.390]                       else if (inherits(cond, "warning")) {
[13:34:34.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.390]                         if (muffled) 
[13:34:34.390]                           invokeRestart("muffleWarning")
[13:34:34.390]                       }
[13:34:34.390]                       else if (inherits(cond, "condition")) {
[13:34:34.390]                         if (!is.null(pattern)) {
[13:34:34.390]                           computeRestarts <- base::computeRestarts
[13:34:34.390]                           grepl <- base::grepl
[13:34:34.390]                           restarts <- computeRestarts(cond)
[13:34:34.390]                           for (restart in restarts) {
[13:34:34.390]                             name <- restart$name
[13:34:34.390]                             if (is.null(name)) 
[13:34:34.390]                               next
[13:34:34.390]                             if (!grepl(pattern, name)) 
[13:34:34.390]                               next
[13:34:34.390]                             invokeRestart(restart)
[13:34:34.390]                             muffled <- TRUE
[13:34:34.390]                             break
[13:34:34.390]                           }
[13:34:34.390]                         }
[13:34:34.390]                       }
[13:34:34.390]                       invisible(muffled)
[13:34:34.390]                     }
[13:34:34.390]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.390]                   }
[13:34:34.390]                 }
[13:34:34.390]                 else {
[13:34:34.390]                   if (TRUE) {
[13:34:34.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.390]                     {
[13:34:34.390]                       inherits <- base::inherits
[13:34:34.390]                       invokeRestart <- base::invokeRestart
[13:34:34.390]                       is.null <- base::is.null
[13:34:34.390]                       muffled <- FALSE
[13:34:34.390]                       if (inherits(cond, "message")) {
[13:34:34.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.390]                         if (muffled) 
[13:34:34.390]                           invokeRestart("muffleMessage")
[13:34:34.390]                       }
[13:34:34.390]                       else if (inherits(cond, "warning")) {
[13:34:34.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.390]                         if (muffled) 
[13:34:34.390]                           invokeRestart("muffleWarning")
[13:34:34.390]                       }
[13:34:34.390]                       else if (inherits(cond, "condition")) {
[13:34:34.390]                         if (!is.null(pattern)) {
[13:34:34.390]                           computeRestarts <- base::computeRestarts
[13:34:34.390]                           grepl <- base::grepl
[13:34:34.390]                           restarts <- computeRestarts(cond)
[13:34:34.390]                           for (restart in restarts) {
[13:34:34.390]                             name <- restart$name
[13:34:34.390]                             if (is.null(name)) 
[13:34:34.390]                               next
[13:34:34.390]                             if (!grepl(pattern, name)) 
[13:34:34.390]                               next
[13:34:34.390]                             invokeRestart(restart)
[13:34:34.390]                             muffled <- TRUE
[13:34:34.390]                             break
[13:34:34.390]                           }
[13:34:34.390]                         }
[13:34:34.390]                       }
[13:34:34.390]                       invisible(muffled)
[13:34:34.390]                     }
[13:34:34.390]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.390]                   }
[13:34:34.390]                 }
[13:34:34.390]             }
[13:34:34.390]         }))
[13:34:34.390]     }, error = function(ex) {
[13:34:34.390]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.390]                 ...future.rng), started = ...future.startTime, 
[13:34:34.390]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.390]             version = "1.8"), class = "FutureResult")
[13:34:34.390]     }, finally = {
[13:34:34.390]         if (!identical(...future.workdir, getwd())) 
[13:34:34.390]             setwd(...future.workdir)
[13:34:34.390]         {
[13:34:34.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.390]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.390]             }
[13:34:34.390]             base::options(...future.oldOptions)
[13:34:34.390]             if (.Platform$OS.type == "windows") {
[13:34:34.390]                 old_names <- names(...future.oldEnvVars)
[13:34:34.390]                 envs <- base::Sys.getenv()
[13:34:34.390]                 names <- names(envs)
[13:34:34.390]                 common <- intersect(names, old_names)
[13:34:34.390]                 added <- setdiff(names, old_names)
[13:34:34.390]                 removed <- setdiff(old_names, names)
[13:34:34.390]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.390]                   envs[common]]
[13:34:34.390]                 NAMES <- toupper(changed)
[13:34:34.390]                 args <- list()
[13:34:34.390]                 for (kk in seq_along(NAMES)) {
[13:34:34.390]                   name <- changed[[kk]]
[13:34:34.390]                   NAME <- NAMES[[kk]]
[13:34:34.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.390]                     next
[13:34:34.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.390]                 }
[13:34:34.390]                 NAMES <- toupper(added)
[13:34:34.390]                 for (kk in seq_along(NAMES)) {
[13:34:34.390]                   name <- added[[kk]]
[13:34:34.390]                   NAME <- NAMES[[kk]]
[13:34:34.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.390]                     next
[13:34:34.390]                   args[[name]] <- ""
[13:34:34.390]                 }
[13:34:34.390]                 NAMES <- toupper(removed)
[13:34:34.390]                 for (kk in seq_along(NAMES)) {
[13:34:34.390]                   name <- removed[[kk]]
[13:34:34.390]                   NAME <- NAMES[[kk]]
[13:34:34.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.390]                     next
[13:34:34.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.390]                 }
[13:34:34.390]                 if (length(args) > 0) 
[13:34:34.390]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.390]             }
[13:34:34.390]             else {
[13:34:34.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.390]             }
[13:34:34.390]             {
[13:34:34.390]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.390]                   0L) {
[13:34:34.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.390]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.390]                   base::options(opts)
[13:34:34.390]                 }
[13:34:34.390]                 {
[13:34:34.390]                   {
[13:34:34.390]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.390]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.390]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.390]                       inherits = FALSE)
[13:34:34.390]                     NULL
[13:34:34.390]                   }
[13:34:34.390]                   options(future.plan = NULL)
[13:34:34.390]                   if (is.na(NA_character_)) 
[13:34:34.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.390]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.390]                     .init = FALSE)
[13:34:34.390]                 }
[13:34:34.390]             }
[13:34:34.390]         }
[13:34:34.390]     })
[13:34:34.390]     if (TRUE) {
[13:34:34.390]         base::sink(type = "output", split = FALSE)
[13:34:34.390]         if (TRUE) {
[13:34:34.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.390]         }
[13:34:34.390]         else {
[13:34:34.390]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.390]         }
[13:34:34.390]         base::close(...future.stdout)
[13:34:34.390]         ...future.stdout <- NULL
[13:34:34.390]     }
[13:34:34.390]     ...future.result$conditions <- ...future.conditions
[13:34:34.390]     ...future.result$finished <- base::Sys.time()
[13:34:34.390]     ...future.result
[13:34:34.390] }
[13:34:34.391] assign_globals() ...
[13:34:34.392] List of 5
[13:34:34.392]  $ ...future.FUN            :function (C, k)  
[13:34:34.392]  $ MoreArgs                 : NULL
[13:34:34.392]  $ ...future.elements_ii    :List of 2
[13:34:34.392]   ..$ :List of 2
[13:34:34.392]   .. ..$ : chr "E"
[13:34:34.392]   .. ..$ : chr "D"
[13:34:34.392]   ..$ :List of 2
[13:34:34.392]   .. ..$ : int 1
[13:34:34.392]   .. ..$ : int 2
[13:34:34.392]  $ ...future.seeds_ii       : NULL
[13:34:34.392]  $ ...future.globals.maxSize: NULL
[13:34:34.392]  - attr(*, "where")=List of 5
[13:34:34.392]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.392]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.392]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.392]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.392]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.392]  - attr(*, "resolved")= logi FALSE
[13:34:34.392]  - attr(*, "total_size")= num 3656
[13:34:34.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.392]  - attr(*, "already-done")= logi TRUE
[13:34:34.398] - reassign environment for ‘...future.FUN’
[13:34:34.398] - copied ‘...future.FUN’ to environment
[13:34:34.398] - copied ‘MoreArgs’ to environment
[13:34:34.398] - copied ‘...future.elements_ii’ to environment
[13:34:34.398] - copied ‘...future.seeds_ii’ to environment
[13:34:34.398] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.398] assign_globals() ... done
[13:34:34.399] plan(): Setting new future strategy stack:
[13:34:34.399] List of future strategies:
[13:34:34.399] 1. sequential:
[13:34:34.399]    - args: function (..., envir = parent.frame())
[13:34:34.399]    - tweaked: FALSE
[13:34:34.399]    - call: NULL
[13:34:34.399] plan(): nbrOfWorkers() = 1
[13:34:34.400] plan(): Setting new future strategy stack:
[13:34:34.400] List of future strategies:
[13:34:34.400] 1. sequential:
[13:34:34.400]    - args: function (..., envir = parent.frame())
[13:34:34.400]    - tweaked: FALSE
[13:34:34.400]    - call: plan(strategy)
[13:34:34.400] plan(): nbrOfWorkers() = 1
[13:34:34.400] SequentialFuture started (and completed)
[13:34:34.400] - Launch lazy future ... done
[13:34:34.400] run() for ‘SequentialFuture’ ... done
[13:34:34.401] Created future:
[13:34:34.401] SequentialFuture:
[13:34:34.401] Label: ‘future_mapply-1’
[13:34:34.401] Expression:
[13:34:34.401] {
[13:34:34.401]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.401]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.401]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.401]         on.exit(options(oopts), add = TRUE)
[13:34:34.401]     }
[13:34:34.401]     {
[13:34:34.401]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.401]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.401]         do.call(mapply, args = args)
[13:34:34.401]     }
[13:34:34.401] }
[13:34:34.401] Lazy evaluation: FALSE
[13:34:34.401] Asynchronous evaluation: FALSE
[13:34:34.401] Local evaluation: TRUE
[13:34:34.401] Environment: R_GlobalEnv
[13:34:34.401] Capture standard output: TRUE
[13:34:34.401] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.401] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.401] Packages: <none>
[13:34:34.401] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.401] Resolved: TRUE
[13:34:34.401] Value: 224 bytes of class ‘list’
[13:34:34.401] Early signaling: FALSE
[13:34:34.401] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.401] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.401] Chunk #1 of 2 ... DONE
[13:34:34.401] Chunk #2 of 2 ...
[13:34:34.402]  - Finding globals in '...' for chunk #2 ...
[13:34:34.402] getGlobalsAndPackages() ...
[13:34:34.402] Searching for globals...
[13:34:34.402] 
[13:34:34.402] Searching for globals ... DONE
[13:34:34.402] - globals: [0] <none>
[13:34:34.402] getGlobalsAndPackages() ... DONE
[13:34:34.402]    + additional globals found: [n=0] 
[13:34:34.403]    + additional namespaces needed: [n=0] 
[13:34:34.403]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:34.403]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:34.403]  - seeds: <none>
[13:34:34.403]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.403] getGlobalsAndPackages() ...
[13:34:34.403] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.403] Resolving globals: FALSE
[13:34:34.404] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[13:34:34.404] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.404] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.404] 
[13:34:34.404] getGlobalsAndPackages() ... DONE
[13:34:34.405] run() for ‘Future’ ...
[13:34:34.405] - state: ‘created’
[13:34:34.405] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.405] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.405] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.405]   - Field: ‘label’
[13:34:34.405]   - Field: ‘local’
[13:34:34.405]   - Field: ‘owner’
[13:34:34.405]   - Field: ‘envir’
[13:34:34.406]   - Field: ‘packages’
[13:34:34.406]   - Field: ‘gc’
[13:34:34.406]   - Field: ‘conditions’
[13:34:34.406]   - Field: ‘expr’
[13:34:34.406]   - Field: ‘uuid’
[13:34:34.406]   - Field: ‘seed’
[13:34:34.406]   - Field: ‘version’
[13:34:34.406]   - Field: ‘result’
[13:34:34.406]   - Field: ‘asynchronous’
[13:34:34.406]   - Field: ‘calls’
[13:34:34.406]   - Field: ‘globals’
[13:34:34.406]   - Field: ‘stdout’
[13:34:34.407]   - Field: ‘earlySignal’
[13:34:34.407]   - Field: ‘lazy’
[13:34:34.407]   - Field: ‘state’
[13:34:34.407] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.407] - Launch lazy future ...
[13:34:34.407] Packages needed by the future expression (n = 0): <none>
[13:34:34.407] Packages needed by future strategies (n = 0): <none>
[13:34:34.408] {
[13:34:34.408]     {
[13:34:34.408]         {
[13:34:34.408]             ...future.startTime <- base::Sys.time()
[13:34:34.408]             {
[13:34:34.408]                 {
[13:34:34.408]                   {
[13:34:34.408]                     base::local({
[13:34:34.408]                       has_future <- base::requireNamespace("future", 
[13:34:34.408]                         quietly = TRUE)
[13:34:34.408]                       if (has_future) {
[13:34:34.408]                         ns <- base::getNamespace("future")
[13:34:34.408]                         version <- ns[[".package"]][["version"]]
[13:34:34.408]                         if (is.null(version)) 
[13:34:34.408]                           version <- utils::packageVersion("future")
[13:34:34.408]                       }
[13:34:34.408]                       else {
[13:34:34.408]                         version <- NULL
[13:34:34.408]                       }
[13:34:34.408]                       if (!has_future || version < "1.8.0") {
[13:34:34.408]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.408]                           "", base::R.version$version.string), 
[13:34:34.408]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.408]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.408]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.408]                             "release", "version")], collapse = " "), 
[13:34:34.408]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.408]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.408]                           info)
[13:34:34.408]                         info <- base::paste(info, collapse = "; ")
[13:34:34.408]                         if (!has_future) {
[13:34:34.408]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.408]                             info)
[13:34:34.408]                         }
[13:34:34.408]                         else {
[13:34:34.408]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.408]                             info, version)
[13:34:34.408]                         }
[13:34:34.408]                         base::stop(msg)
[13:34:34.408]                       }
[13:34:34.408]                     })
[13:34:34.408]                   }
[13:34:34.408]                   ...future.strategy.old <- future::plan("list")
[13:34:34.408]                   options(future.plan = NULL)
[13:34:34.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.408]                 }
[13:34:34.408]                 ...future.workdir <- getwd()
[13:34:34.408]             }
[13:34:34.408]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.408]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.408]         }
[13:34:34.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.408]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:34.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.408]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.408]             base::names(...future.oldOptions))
[13:34:34.408]     }
[13:34:34.408]     if (FALSE) {
[13:34:34.408]     }
[13:34:34.408]     else {
[13:34:34.408]         if (TRUE) {
[13:34:34.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.408]                 open = "w")
[13:34:34.408]         }
[13:34:34.408]         else {
[13:34:34.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.408]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.408]         }
[13:34:34.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.408]             base::sink(type = "output", split = FALSE)
[13:34:34.408]             base::close(...future.stdout)
[13:34:34.408]         }, add = TRUE)
[13:34:34.408]     }
[13:34:34.408]     ...future.frame <- base::sys.nframe()
[13:34:34.408]     ...future.conditions <- base::list()
[13:34:34.408]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.408]     if (FALSE) {
[13:34:34.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.408]     }
[13:34:34.408]     ...future.result <- base::tryCatch({
[13:34:34.408]         base::withCallingHandlers({
[13:34:34.408]             ...future.value <- base::withVisible(base::local({
[13:34:34.408]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.408]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.408]                   ...future.globals.maxSize)) {
[13:34:34.408]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.408]                   on.exit(options(oopts), add = TRUE)
[13:34:34.408]                 }
[13:34:34.408]                 {
[13:34:34.408]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.408]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.408]                     USE.NAMES = FALSE)
[13:34:34.408]                   do.call(mapply, args = args)
[13:34:34.408]                 }
[13:34:34.408]             }))
[13:34:34.408]             future::FutureResult(value = ...future.value$value, 
[13:34:34.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.408]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.408]                     ...future.globalenv.names))
[13:34:34.408]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.408]         }, condition = base::local({
[13:34:34.408]             c <- base::c
[13:34:34.408]             inherits <- base::inherits
[13:34:34.408]             invokeRestart <- base::invokeRestart
[13:34:34.408]             length <- base::length
[13:34:34.408]             list <- base::list
[13:34:34.408]             seq.int <- base::seq.int
[13:34:34.408]             signalCondition <- base::signalCondition
[13:34:34.408]             sys.calls <- base::sys.calls
[13:34:34.408]             `[[` <- base::`[[`
[13:34:34.408]             `+` <- base::`+`
[13:34:34.408]             `<<-` <- base::`<<-`
[13:34:34.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.408]                   3L)]
[13:34:34.408]             }
[13:34:34.408]             function(cond) {
[13:34:34.408]                 is_error <- inherits(cond, "error")
[13:34:34.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.408]                   NULL)
[13:34:34.408]                 if (is_error) {
[13:34:34.408]                   sessionInformation <- function() {
[13:34:34.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.408]                       search = base::search(), system = base::Sys.info())
[13:34:34.408]                   }
[13:34:34.408]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.408]                     cond$call), session = sessionInformation(), 
[13:34:34.408]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.408]                   signalCondition(cond)
[13:34:34.408]                 }
[13:34:34.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.408]                 "immediateCondition"))) {
[13:34:34.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.408]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.408]                   if (TRUE && !signal) {
[13:34:34.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.408]                     {
[13:34:34.408]                       inherits <- base::inherits
[13:34:34.408]                       invokeRestart <- base::invokeRestart
[13:34:34.408]                       is.null <- base::is.null
[13:34:34.408]                       muffled <- FALSE
[13:34:34.408]                       if (inherits(cond, "message")) {
[13:34:34.408]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.408]                         if (muffled) 
[13:34:34.408]                           invokeRestart("muffleMessage")
[13:34:34.408]                       }
[13:34:34.408]                       else if (inherits(cond, "warning")) {
[13:34:34.408]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.408]                         if (muffled) 
[13:34:34.408]                           invokeRestart("muffleWarning")
[13:34:34.408]                       }
[13:34:34.408]                       else if (inherits(cond, "condition")) {
[13:34:34.408]                         if (!is.null(pattern)) {
[13:34:34.408]                           computeRestarts <- base::computeRestarts
[13:34:34.408]                           grepl <- base::grepl
[13:34:34.408]                           restarts <- computeRestarts(cond)
[13:34:34.408]                           for (restart in restarts) {
[13:34:34.408]                             name <- restart$name
[13:34:34.408]                             if (is.null(name)) 
[13:34:34.408]                               next
[13:34:34.408]                             if (!grepl(pattern, name)) 
[13:34:34.408]                               next
[13:34:34.408]                             invokeRestart(restart)
[13:34:34.408]                             muffled <- TRUE
[13:34:34.408]                             break
[13:34:34.408]                           }
[13:34:34.408]                         }
[13:34:34.408]                       }
[13:34:34.408]                       invisible(muffled)
[13:34:34.408]                     }
[13:34:34.408]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.408]                   }
[13:34:34.408]                 }
[13:34:34.408]                 else {
[13:34:34.408]                   if (TRUE) {
[13:34:34.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.408]                     {
[13:34:34.408]                       inherits <- base::inherits
[13:34:34.408]                       invokeRestart <- base::invokeRestart
[13:34:34.408]                       is.null <- base::is.null
[13:34:34.408]                       muffled <- FALSE
[13:34:34.408]                       if (inherits(cond, "message")) {
[13:34:34.408]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.408]                         if (muffled) 
[13:34:34.408]                           invokeRestart("muffleMessage")
[13:34:34.408]                       }
[13:34:34.408]                       else if (inherits(cond, "warning")) {
[13:34:34.408]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.408]                         if (muffled) 
[13:34:34.408]                           invokeRestart("muffleWarning")
[13:34:34.408]                       }
[13:34:34.408]                       else if (inherits(cond, "condition")) {
[13:34:34.408]                         if (!is.null(pattern)) {
[13:34:34.408]                           computeRestarts <- base::computeRestarts
[13:34:34.408]                           grepl <- base::grepl
[13:34:34.408]                           restarts <- computeRestarts(cond)
[13:34:34.408]                           for (restart in restarts) {
[13:34:34.408]                             name <- restart$name
[13:34:34.408]                             if (is.null(name)) 
[13:34:34.408]                               next
[13:34:34.408]                             if (!grepl(pattern, name)) 
[13:34:34.408]                               next
[13:34:34.408]                             invokeRestart(restart)
[13:34:34.408]                             muffled <- TRUE
[13:34:34.408]                             break
[13:34:34.408]                           }
[13:34:34.408]                         }
[13:34:34.408]                       }
[13:34:34.408]                       invisible(muffled)
[13:34:34.408]                     }
[13:34:34.408]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.408]                   }
[13:34:34.408]                 }
[13:34:34.408]             }
[13:34:34.408]         }))
[13:34:34.408]     }, error = function(ex) {
[13:34:34.408]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.408]                 ...future.rng), started = ...future.startTime, 
[13:34:34.408]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.408]             version = "1.8"), class = "FutureResult")
[13:34:34.408]     }, finally = {
[13:34:34.408]         if (!identical(...future.workdir, getwd())) 
[13:34:34.408]             setwd(...future.workdir)
[13:34:34.408]         {
[13:34:34.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.408]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.408]             }
[13:34:34.408]             base::options(...future.oldOptions)
[13:34:34.408]             if (.Platform$OS.type == "windows") {
[13:34:34.408]                 old_names <- names(...future.oldEnvVars)
[13:34:34.408]                 envs <- base::Sys.getenv()
[13:34:34.408]                 names <- names(envs)
[13:34:34.408]                 common <- intersect(names, old_names)
[13:34:34.408]                 added <- setdiff(names, old_names)
[13:34:34.408]                 removed <- setdiff(old_names, names)
[13:34:34.408]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.408]                   envs[common]]
[13:34:34.408]                 NAMES <- toupper(changed)
[13:34:34.408]                 args <- list()
[13:34:34.408]                 for (kk in seq_along(NAMES)) {
[13:34:34.408]                   name <- changed[[kk]]
[13:34:34.408]                   NAME <- NAMES[[kk]]
[13:34:34.408]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.408]                     next
[13:34:34.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.408]                 }
[13:34:34.408]                 NAMES <- toupper(added)
[13:34:34.408]                 for (kk in seq_along(NAMES)) {
[13:34:34.408]                   name <- added[[kk]]
[13:34:34.408]                   NAME <- NAMES[[kk]]
[13:34:34.408]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.408]                     next
[13:34:34.408]                   args[[name]] <- ""
[13:34:34.408]                 }
[13:34:34.408]                 NAMES <- toupper(removed)
[13:34:34.408]                 for (kk in seq_along(NAMES)) {
[13:34:34.408]                   name <- removed[[kk]]
[13:34:34.408]                   NAME <- NAMES[[kk]]
[13:34:34.408]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.408]                     next
[13:34:34.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.408]                 }
[13:34:34.408]                 if (length(args) > 0) 
[13:34:34.408]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.408]             }
[13:34:34.408]             else {
[13:34:34.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.408]             }
[13:34:34.408]             {
[13:34:34.408]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.408]                   0L) {
[13:34:34.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.408]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.408]                   base::options(opts)
[13:34:34.408]                 }
[13:34:34.408]                 {
[13:34:34.408]                   {
[13:34:34.408]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.408]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.408]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.408]                       inherits = FALSE)
[13:34:34.408]                     NULL
[13:34:34.408]                   }
[13:34:34.408]                   options(future.plan = NULL)
[13:34:34.408]                   if (is.na(NA_character_)) 
[13:34:34.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.408]                     .init = FALSE)
[13:34:34.408]                 }
[13:34:34.408]             }
[13:34:34.408]         }
[13:34:34.408]     })
[13:34:34.408]     if (TRUE) {
[13:34:34.408]         base::sink(type = "output", split = FALSE)
[13:34:34.408]         if (TRUE) {
[13:34:34.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.408]         }
[13:34:34.408]         else {
[13:34:34.408]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.408]         }
[13:34:34.408]         base::close(...future.stdout)
[13:34:34.408]         ...future.stdout <- NULL
[13:34:34.408]     }
[13:34:34.408]     ...future.result$conditions <- ...future.conditions
[13:34:34.408]     ...future.result$finished <- base::Sys.time()
[13:34:34.408]     ...future.result
[13:34:34.408] }
[13:34:34.409] assign_globals() ...
[13:34:34.409] List of 5
[13:34:34.409]  $ ...future.FUN            :function (C, k)  
[13:34:34.409]  $ MoreArgs                 : NULL
[13:34:34.409]  $ ...future.elements_ii    :List of 2
[13:34:34.409]   ..$ :List of 3
[13:34:34.409]   .. ..$ : chr "C"
[13:34:34.409]   .. ..$ : chr "B"
[13:34:34.409]   .. ..$ : chr "A"
[13:34:34.409]   ..$ :List of 3
[13:34:34.409]   .. ..$ : int 3
[13:34:34.409]   .. ..$ : int 4
[13:34:34.409]   .. ..$ : int 5
[13:34:34.409]  $ ...future.seeds_ii       : NULL
[13:34:34.409]  $ ...future.globals.maxSize: NULL
[13:34:34.409]  - attr(*, "where")=List of 5
[13:34:34.409]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.409]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.409]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.409]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.409]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.409]  - attr(*, "resolved")= logi FALSE
[13:34:34.409]  - attr(*, "total_size")= num 3824
[13:34:34.409]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.409]  - attr(*, "already-done")= logi TRUE
[13:34:34.415] - reassign environment for ‘...future.FUN’
[13:34:34.415] - copied ‘...future.FUN’ to environment
[13:34:34.415] - copied ‘MoreArgs’ to environment
[13:34:34.415] - copied ‘...future.elements_ii’ to environment
[13:34:34.415] - copied ‘...future.seeds_ii’ to environment
[13:34:34.415] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.415] assign_globals() ... done
[13:34:34.415] plan(): Setting new future strategy stack:
[13:34:34.415] List of future strategies:
[13:34:34.415] 1. sequential:
[13:34:34.415]    - args: function (..., envir = parent.frame())
[13:34:34.415]    - tweaked: FALSE
[13:34:34.415]    - call: NULL
[13:34:34.417] plan(): nbrOfWorkers() = 1
[13:34:34.417] plan(): Setting new future strategy stack:
[13:34:34.418] List of future strategies:
[13:34:34.418] 1. sequential:
[13:34:34.418]    - args: function (..., envir = parent.frame())
[13:34:34.418]    - tweaked: FALSE
[13:34:34.418]    - call: plan(strategy)
[13:34:34.418] plan(): nbrOfWorkers() = 1
[13:34:34.418] SequentialFuture started (and completed)
[13:34:34.418] - Launch lazy future ... done
[13:34:34.418] run() for ‘SequentialFuture’ ... done
[13:34:34.418] Created future:
[13:34:34.418] SequentialFuture:
[13:34:34.418] Label: ‘future_mapply-2’
[13:34:34.418] Expression:
[13:34:34.418] {
[13:34:34.418]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.418]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.418]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.418]         on.exit(options(oopts), add = TRUE)
[13:34:34.418]     }
[13:34:34.418]     {
[13:34:34.418]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.418]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.418]         do.call(mapply, args = args)
[13:34:34.418]     }
[13:34:34.418] }
[13:34:34.418] Lazy evaluation: FALSE
[13:34:34.418] Asynchronous evaluation: FALSE
[13:34:34.418] Local evaluation: TRUE
[13:34:34.418] Environment: R_GlobalEnv
[13:34:34.418] Capture standard output: TRUE
[13:34:34.418] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.418] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.418] Packages: <none>
[13:34:34.418] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.418] Resolved: TRUE
[13:34:34.418] Value: 336 bytes of class ‘list’
[13:34:34.418] Early signaling: FALSE
[13:34:34.418] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.418] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.419] Chunk #2 of 2 ... DONE
[13:34:34.419] Launching 2 futures (chunks) ... DONE
[13:34:34.419] Resolving 2 futures (chunks) ...
[13:34:34.419] resolve() on list ...
[13:34:34.420]  recursive: 0
[13:34:34.420]  length: 2
[13:34:34.420] 
[13:34:34.420] resolved() for ‘SequentialFuture’ ...
[13:34:34.420] - state: ‘finished’
[13:34:34.420] - run: TRUE
[13:34:34.420] - result: ‘FutureResult’
[13:34:34.420] resolved() for ‘SequentialFuture’ ... done
[13:34:34.420] Future #1
[13:34:34.420] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.420] - nx: 2
[13:34:34.421] - relay: TRUE
[13:34:34.421] - stdout: TRUE
[13:34:34.421] - signal: TRUE
[13:34:34.421] - resignal: FALSE
[13:34:34.421] - force: TRUE
[13:34:34.421] - relayed: [n=2] FALSE, FALSE
[13:34:34.421] - queued futures: [n=2] FALSE, FALSE
[13:34:34.421]  - until=1
[13:34:34.421]  - relaying element #1
[13:34:34.421] - relayed: [n=2] TRUE, FALSE
[13:34:34.421] - queued futures: [n=2] TRUE, FALSE
[13:34:34.422] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.422]  length: 1 (resolved future 1)
[13:34:34.422] resolved() for ‘SequentialFuture’ ...
[13:34:34.422] - state: ‘finished’
[13:34:34.422] - run: TRUE
[13:34:34.422] - result: ‘FutureResult’
[13:34:34.422] resolved() for ‘SequentialFuture’ ... done
[13:34:34.422] Future #2
[13:34:34.422] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:34:34.422] - nx: 2
[13:34:34.422] - relay: TRUE
[13:34:34.423] - stdout: TRUE
[13:34:34.423] - signal: TRUE
[13:34:34.423] - resignal: FALSE
[13:34:34.423] - force: TRUE
[13:34:34.423] - relayed: [n=2] TRUE, FALSE
[13:34:34.423] - queued futures: [n=2] TRUE, FALSE
[13:34:34.423]  - until=2
[13:34:34.423]  - relaying element #2
[13:34:34.423] - relayed: [n=2] TRUE, TRUE
[13:34:34.423] - queued futures: [n=2] TRUE, TRUE
[13:34:34.423] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:34:34.424]  length: 0 (resolved future 2)
[13:34:34.424] Relaying remaining futures
[13:34:34.424] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.424] - nx: 2
[13:34:34.424] - relay: TRUE
[13:34:34.424] - stdout: TRUE
[13:34:34.424] - signal: TRUE
[13:34:34.424] - resignal: FALSE
[13:34:34.424] - force: TRUE
[13:34:34.424] - relayed: [n=2] TRUE, TRUE
[13:34:34.424] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:34.424] - relayed: [n=2] TRUE, TRUE
[13:34:34.425] - queued futures: [n=2] TRUE, TRUE
[13:34:34.425] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.425] resolve() on list ... DONE
[13:34:34.425]  - Number of value chunks collected: 2
[13:34:34.425] Resolving 2 futures (chunks) ... DONE
[13:34:34.425] Reducing values from 2 chunks ...
[13:34:34.425]  - Number of values collected after concatenation: 5
[13:34:34.425]  - Number of values expected: 5
[13:34:34.425] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[13:34:34.425] Reducing values from 2 chunks ... DONE
[13:34:34.425] future_mapply() ... DONE
[13:34:34.426] future_mapply() ...
[13:34:34.426] Number of chunks: 1
[13:34:34.426] getGlobalsAndPackagesXApply() ...
[13:34:34.426]  - future.globals: TRUE
[13:34:34.426] getGlobalsAndPackages() ...
[13:34:34.426] Searching for globals...
[13:34:34.427] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:34.427] Searching for globals ... DONE
[13:34:34.428] Resolving globals: FALSE
[13:34:34.428] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:34.428] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:34.428] - globals: [1] ‘FUN’
[13:34:34.428] 
[13:34:34.428] getGlobalsAndPackages() ... DONE
[13:34:34.428]  - globals found/used: [n=1] ‘FUN’
[13:34:34.429]  - needed namespaces: [n=0] 
[13:34:34.429] Finding globals ... DONE
[13:34:34.429] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.429] List of 2
[13:34:34.429]  $ ...future.FUN:function (C, k)  
[13:34:34.429]  $ MoreArgs     : list()
[13:34:34.429]  - attr(*, "where")=List of 2
[13:34:34.429]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.429]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.429]  - attr(*, "resolved")= logi FALSE
[13:34:34.429]  - attr(*, "total_size")= num NA
[13:34:34.431] Packages to be attached in all futures: [n=0] 
[13:34:34.431] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.431] Number of futures (= number of chunks): 1
[13:34:34.431] Launching 1 futures (chunks) ...
[13:34:34.432] Chunk #1 of 1 ...
[13:34:34.432]  - Finding globals in '...' for chunk #1 ...
[13:34:34.432] getGlobalsAndPackages() ...
[13:34:34.432] Searching for globals...
[13:34:34.432] 
[13:34:34.432] Searching for globals ... DONE
[13:34:34.432] - globals: [0] <none>
[13:34:34.432] getGlobalsAndPackages() ... DONE
[13:34:34.432]    + additional globals found: [n=0] 
[13:34:34.433]    + additional namespaces needed: [n=0] 
[13:34:34.433]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.433]  - seeds: <none>
[13:34:34.433]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.433] getGlobalsAndPackages() ...
[13:34:34.433] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.433] Resolving globals: FALSE
[13:34:34.434] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[13:34:34.434] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:34.434] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.434] 
[13:34:34.434] getGlobalsAndPackages() ... DONE
[13:34:34.435] run() for ‘Future’ ...
[13:34:34.435] - state: ‘created’
[13:34:34.435] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.435] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.435] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.435]   - Field: ‘label’
[13:34:34.435]   - Field: ‘local’
[13:34:34.435]   - Field: ‘owner’
[13:34:34.436]   - Field: ‘envir’
[13:34:34.436]   - Field: ‘packages’
[13:34:34.436]   - Field: ‘gc’
[13:34:34.436]   - Field: ‘conditions’
[13:34:34.436]   - Field: ‘expr’
[13:34:34.436]   - Field: ‘uuid’
[13:34:34.436]   - Field: ‘seed’
[13:34:34.436]   - Field: ‘version’
[13:34:34.436]   - Field: ‘result’
[13:34:34.437]   - Field: ‘asynchronous’
[13:34:34.437]   - Field: ‘calls’
[13:34:34.437]   - Field: ‘globals’
[13:34:34.437]   - Field: ‘stdout’
[13:34:34.437]   - Field: ‘earlySignal’
[13:34:34.438]   - Field: ‘lazy’
[13:34:34.438]   - Field: ‘state’
[13:34:34.438] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.438] - Launch lazy future ...
[13:34:34.438] Packages needed by the future expression (n = 0): <none>
[13:34:34.438] Packages needed by future strategies (n = 0): <none>
[13:34:34.438] {
[13:34:34.438]     {
[13:34:34.438]         {
[13:34:34.438]             ...future.startTime <- base::Sys.time()
[13:34:34.438]             {
[13:34:34.438]                 {
[13:34:34.438]                   {
[13:34:34.438]                     base::local({
[13:34:34.438]                       has_future <- base::requireNamespace("future", 
[13:34:34.438]                         quietly = TRUE)
[13:34:34.438]                       if (has_future) {
[13:34:34.438]                         ns <- base::getNamespace("future")
[13:34:34.438]                         version <- ns[[".package"]][["version"]]
[13:34:34.438]                         if (is.null(version)) 
[13:34:34.438]                           version <- utils::packageVersion("future")
[13:34:34.438]                       }
[13:34:34.438]                       else {
[13:34:34.438]                         version <- NULL
[13:34:34.438]                       }
[13:34:34.438]                       if (!has_future || version < "1.8.0") {
[13:34:34.438]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.438]                           "", base::R.version$version.string), 
[13:34:34.438]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.438]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.438]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.438]                             "release", "version")], collapse = " "), 
[13:34:34.438]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.438]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.438]                           info)
[13:34:34.438]                         info <- base::paste(info, collapse = "; ")
[13:34:34.438]                         if (!has_future) {
[13:34:34.438]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.438]                             info)
[13:34:34.438]                         }
[13:34:34.438]                         else {
[13:34:34.438]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.438]                             info, version)
[13:34:34.438]                         }
[13:34:34.438]                         base::stop(msg)
[13:34:34.438]                       }
[13:34:34.438]                     })
[13:34:34.438]                   }
[13:34:34.438]                   ...future.strategy.old <- future::plan("list")
[13:34:34.438]                   options(future.plan = NULL)
[13:34:34.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.438]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.438]                 }
[13:34:34.438]                 ...future.workdir <- getwd()
[13:34:34.438]             }
[13:34:34.438]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.438]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.438]         }
[13:34:34.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.438]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.438]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.438]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.438]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.438]             base::names(...future.oldOptions))
[13:34:34.438]     }
[13:34:34.438]     if (FALSE) {
[13:34:34.438]     }
[13:34:34.438]     else {
[13:34:34.438]         if (TRUE) {
[13:34:34.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.438]                 open = "w")
[13:34:34.438]         }
[13:34:34.438]         else {
[13:34:34.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.438]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.438]         }
[13:34:34.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.438]             base::sink(type = "output", split = FALSE)
[13:34:34.438]             base::close(...future.stdout)
[13:34:34.438]         }, add = TRUE)
[13:34:34.438]     }
[13:34:34.438]     ...future.frame <- base::sys.nframe()
[13:34:34.438]     ...future.conditions <- base::list()
[13:34:34.438]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.438]     if (FALSE) {
[13:34:34.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.438]     }
[13:34:34.438]     ...future.result <- base::tryCatch({
[13:34:34.438]         base::withCallingHandlers({
[13:34:34.438]             ...future.value <- base::withVisible(base::local({
[13:34:34.438]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.438]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.438]                   ...future.globals.maxSize)) {
[13:34:34.438]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.438]                   on.exit(options(oopts), add = TRUE)
[13:34:34.438]                 }
[13:34:34.438]                 {
[13:34:34.438]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.438]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.438]                     USE.NAMES = FALSE)
[13:34:34.438]                   do.call(mapply, args = args)
[13:34:34.438]                 }
[13:34:34.438]             }))
[13:34:34.438]             future::FutureResult(value = ...future.value$value, 
[13:34:34.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.438]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.438]                     ...future.globalenv.names))
[13:34:34.438]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.438]         }, condition = base::local({
[13:34:34.438]             c <- base::c
[13:34:34.438]             inherits <- base::inherits
[13:34:34.438]             invokeRestart <- base::invokeRestart
[13:34:34.438]             length <- base::length
[13:34:34.438]             list <- base::list
[13:34:34.438]             seq.int <- base::seq.int
[13:34:34.438]             signalCondition <- base::signalCondition
[13:34:34.438]             sys.calls <- base::sys.calls
[13:34:34.438]             `[[` <- base::`[[`
[13:34:34.438]             `+` <- base::`+`
[13:34:34.438]             `<<-` <- base::`<<-`
[13:34:34.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.438]                   3L)]
[13:34:34.438]             }
[13:34:34.438]             function(cond) {
[13:34:34.438]                 is_error <- inherits(cond, "error")
[13:34:34.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.438]                   NULL)
[13:34:34.438]                 if (is_error) {
[13:34:34.438]                   sessionInformation <- function() {
[13:34:34.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.438]                       search = base::search(), system = base::Sys.info())
[13:34:34.438]                   }
[13:34:34.438]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.438]                     cond$call), session = sessionInformation(), 
[13:34:34.438]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.438]                   signalCondition(cond)
[13:34:34.438]                 }
[13:34:34.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.438]                 "immediateCondition"))) {
[13:34:34.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.438]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.438]                   if (TRUE && !signal) {
[13:34:34.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.438]                     {
[13:34:34.438]                       inherits <- base::inherits
[13:34:34.438]                       invokeRestart <- base::invokeRestart
[13:34:34.438]                       is.null <- base::is.null
[13:34:34.438]                       muffled <- FALSE
[13:34:34.438]                       if (inherits(cond, "message")) {
[13:34:34.438]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.438]                         if (muffled) 
[13:34:34.438]                           invokeRestart("muffleMessage")
[13:34:34.438]                       }
[13:34:34.438]                       else if (inherits(cond, "warning")) {
[13:34:34.438]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.438]                         if (muffled) 
[13:34:34.438]                           invokeRestart("muffleWarning")
[13:34:34.438]                       }
[13:34:34.438]                       else if (inherits(cond, "condition")) {
[13:34:34.438]                         if (!is.null(pattern)) {
[13:34:34.438]                           computeRestarts <- base::computeRestarts
[13:34:34.438]                           grepl <- base::grepl
[13:34:34.438]                           restarts <- computeRestarts(cond)
[13:34:34.438]                           for (restart in restarts) {
[13:34:34.438]                             name <- restart$name
[13:34:34.438]                             if (is.null(name)) 
[13:34:34.438]                               next
[13:34:34.438]                             if (!grepl(pattern, name)) 
[13:34:34.438]                               next
[13:34:34.438]                             invokeRestart(restart)
[13:34:34.438]                             muffled <- TRUE
[13:34:34.438]                             break
[13:34:34.438]                           }
[13:34:34.438]                         }
[13:34:34.438]                       }
[13:34:34.438]                       invisible(muffled)
[13:34:34.438]                     }
[13:34:34.438]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.438]                   }
[13:34:34.438]                 }
[13:34:34.438]                 else {
[13:34:34.438]                   if (TRUE) {
[13:34:34.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.438]                     {
[13:34:34.438]                       inherits <- base::inherits
[13:34:34.438]                       invokeRestart <- base::invokeRestart
[13:34:34.438]                       is.null <- base::is.null
[13:34:34.438]                       muffled <- FALSE
[13:34:34.438]                       if (inherits(cond, "message")) {
[13:34:34.438]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.438]                         if (muffled) 
[13:34:34.438]                           invokeRestart("muffleMessage")
[13:34:34.438]                       }
[13:34:34.438]                       else if (inherits(cond, "warning")) {
[13:34:34.438]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.438]                         if (muffled) 
[13:34:34.438]                           invokeRestart("muffleWarning")
[13:34:34.438]                       }
[13:34:34.438]                       else if (inherits(cond, "condition")) {
[13:34:34.438]                         if (!is.null(pattern)) {
[13:34:34.438]                           computeRestarts <- base::computeRestarts
[13:34:34.438]                           grepl <- base::grepl
[13:34:34.438]                           restarts <- computeRestarts(cond)
[13:34:34.438]                           for (restart in restarts) {
[13:34:34.438]                             name <- restart$name
[13:34:34.438]                             if (is.null(name)) 
[13:34:34.438]                               next
[13:34:34.438]                             if (!grepl(pattern, name)) 
[13:34:34.438]                               next
[13:34:34.438]                             invokeRestart(restart)
[13:34:34.438]                             muffled <- TRUE
[13:34:34.438]                             break
[13:34:34.438]                           }
[13:34:34.438]                         }
[13:34:34.438]                       }
[13:34:34.438]                       invisible(muffled)
[13:34:34.438]                     }
[13:34:34.438]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.438]                   }
[13:34:34.438]                 }
[13:34:34.438]             }
[13:34:34.438]         }))
[13:34:34.438]     }, error = function(ex) {
[13:34:34.438]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.438]                 ...future.rng), started = ...future.startTime, 
[13:34:34.438]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.438]             version = "1.8"), class = "FutureResult")
[13:34:34.438]     }, finally = {
[13:34:34.438]         if (!identical(...future.workdir, getwd())) 
[13:34:34.438]             setwd(...future.workdir)
[13:34:34.438]         {
[13:34:34.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.438]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.438]             }
[13:34:34.438]             base::options(...future.oldOptions)
[13:34:34.438]             if (.Platform$OS.type == "windows") {
[13:34:34.438]                 old_names <- names(...future.oldEnvVars)
[13:34:34.438]                 envs <- base::Sys.getenv()
[13:34:34.438]                 names <- names(envs)
[13:34:34.438]                 common <- intersect(names, old_names)
[13:34:34.438]                 added <- setdiff(names, old_names)
[13:34:34.438]                 removed <- setdiff(old_names, names)
[13:34:34.438]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.438]                   envs[common]]
[13:34:34.438]                 NAMES <- toupper(changed)
[13:34:34.438]                 args <- list()
[13:34:34.438]                 for (kk in seq_along(NAMES)) {
[13:34:34.438]                   name <- changed[[kk]]
[13:34:34.438]                   NAME <- NAMES[[kk]]
[13:34:34.438]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.438]                     next
[13:34:34.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.438]                 }
[13:34:34.438]                 NAMES <- toupper(added)
[13:34:34.438]                 for (kk in seq_along(NAMES)) {
[13:34:34.438]                   name <- added[[kk]]
[13:34:34.438]                   NAME <- NAMES[[kk]]
[13:34:34.438]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.438]                     next
[13:34:34.438]                   args[[name]] <- ""
[13:34:34.438]                 }
[13:34:34.438]                 NAMES <- toupper(removed)
[13:34:34.438]                 for (kk in seq_along(NAMES)) {
[13:34:34.438]                   name <- removed[[kk]]
[13:34:34.438]                   NAME <- NAMES[[kk]]
[13:34:34.438]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.438]                     next
[13:34:34.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.438]                 }
[13:34:34.438]                 if (length(args) > 0) 
[13:34:34.438]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.438]             }
[13:34:34.438]             else {
[13:34:34.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.438]             }
[13:34:34.438]             {
[13:34:34.438]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.438]                   0L) {
[13:34:34.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.438]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.438]                   base::options(opts)
[13:34:34.438]                 }
[13:34:34.438]                 {
[13:34:34.438]                   {
[13:34:34.438]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.438]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.438]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.438]                       inherits = FALSE)
[13:34:34.438]                     NULL
[13:34:34.438]                   }
[13:34:34.438]                   options(future.plan = NULL)
[13:34:34.438]                   if (is.na(NA_character_)) 
[13:34:34.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.438]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.438]                     .init = FALSE)
[13:34:34.438]                 }
[13:34:34.438]             }
[13:34:34.438]         }
[13:34:34.438]     })
[13:34:34.438]     if (TRUE) {
[13:34:34.438]         base::sink(type = "output", split = FALSE)
[13:34:34.438]         if (TRUE) {
[13:34:34.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.438]         }
[13:34:34.438]         else {
[13:34:34.438]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.438]         }
[13:34:34.438]         base::close(...future.stdout)
[13:34:34.438]         ...future.stdout <- NULL
[13:34:34.438]     }
[13:34:34.438]     ...future.result$conditions <- ...future.conditions
[13:34:34.438]     ...future.result$finished <- base::Sys.time()
[13:34:34.438]     ...future.result
[13:34:34.438] }
[13:34:34.440] assign_globals() ...
[13:34:34.440] List of 5
[13:34:34.440]  $ ...future.FUN            :function (C, k)  
[13:34:34.440]  $ MoreArgs                 : list()
[13:34:34.440]  $ ...future.elements_ii    :List of 2
[13:34:34.440]   ..$ :List of 5
[13:34:34.440]   .. ..$ : chr "A"
[13:34:34.440]   .. ..$ : chr "B"
[13:34:34.440]   .. ..$ : chr "C"
[13:34:34.440]   .. ..$ : chr "D"
[13:34:34.440]   .. ..$ : chr "E"
[13:34:34.440]   ..$ :List of 5
[13:34:34.440]   .. ..$ : int 5
[13:34:34.440]   .. ..$ : int 4
[13:34:34.440]   .. ..$ : int 3
[13:34:34.440]   .. ..$ : int 2
[13:34:34.440]   .. ..$ : int 1
[13:34:34.440]  $ ...future.seeds_ii       : NULL
[13:34:34.440]  $ ...future.globals.maxSize: NULL
[13:34:34.440]  - attr(*, "where")=List of 5
[13:34:34.440]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.440]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.440]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.440]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.440]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.440]  - attr(*, "resolved")= logi FALSE
[13:34:34.440]  - attr(*, "total_size")= num 4160
[13:34:34.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.440]  - attr(*, "already-done")= logi TRUE
[13:34:34.447] - reassign environment for ‘...future.FUN’
[13:34:34.447] - copied ‘...future.FUN’ to environment
[13:34:34.447] - copied ‘MoreArgs’ to environment
[13:34:34.447] - copied ‘...future.elements_ii’ to environment
[13:34:34.447] - copied ‘...future.seeds_ii’ to environment
[13:34:34.447] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.447] assign_globals() ... done
[13:34:34.447] plan(): Setting new future strategy stack:
[13:34:34.447] List of future strategies:
[13:34:34.447] 1. sequential:
[13:34:34.447]    - args: function (..., envir = parent.frame())
[13:34:34.447]    - tweaked: FALSE
[13:34:34.447]    - call: NULL
[13:34:34.448] plan(): nbrOfWorkers() = 1
[13:34:34.448] plan(): Setting new future strategy stack:
[13:34:34.449] List of future strategies:
[13:34:34.449] 1. sequential:
[13:34:34.449]    - args: function (..., envir = parent.frame())
[13:34:34.449]    - tweaked: FALSE
[13:34:34.449]    - call: plan(strategy)
[13:34:34.449] plan(): nbrOfWorkers() = 1
[13:34:34.449] SequentialFuture started (and completed)
[13:34:34.449] - Launch lazy future ... done
[13:34:34.449] run() for ‘SequentialFuture’ ... done
[13:34:34.449] Created future:
[13:34:34.449] SequentialFuture:
[13:34:34.449] Label: ‘future_.mapply-1’
[13:34:34.449] Expression:
[13:34:34.449] {
[13:34:34.449]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.449]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.449]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.449]         on.exit(options(oopts), add = TRUE)
[13:34:34.449]     }
[13:34:34.449]     {
[13:34:34.449]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.449]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.449]         do.call(mapply, args = args)
[13:34:34.449]     }
[13:34:34.449] }
[13:34:34.449] Lazy evaluation: FALSE
[13:34:34.449] Asynchronous evaluation: FALSE
[13:34:34.449] Local evaluation: TRUE
[13:34:34.449] Environment: R_GlobalEnv
[13:34:34.449] Capture standard output: TRUE
[13:34:34.449] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.449] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.449] Packages: <none>
[13:34:34.449] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.449] Resolved: TRUE
[13:34:34.449] Value: 560 bytes of class ‘list’
[13:34:34.449] Early signaling: FALSE
[13:34:34.449] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.449] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.450] Chunk #1 of 1 ... DONE
[13:34:34.450] Launching 1 futures (chunks) ... DONE
[13:34:34.450] Resolving 1 futures (chunks) ...
[13:34:34.451] resolve() on list ...
[13:34:34.451]  recursive: 0
[13:34:34.451]  length: 1
[13:34:34.451] 
[13:34:34.451] resolved() for ‘SequentialFuture’ ...
[13:34:34.451] - state: ‘finished’
[13:34:34.451] - run: TRUE
[13:34:34.451] - result: ‘FutureResult’
[13:34:34.451] resolved() for ‘SequentialFuture’ ... done
[13:34:34.451] Future #1
[13:34:34.451] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.452] - nx: 1
[13:34:34.452] - relay: TRUE
[13:34:34.452] - stdout: TRUE
[13:34:34.452] - signal: TRUE
[13:34:34.452] - resignal: FALSE
[13:34:34.452] - force: TRUE
[13:34:34.452] - relayed: [n=1] FALSE
[13:34:34.452] - queued futures: [n=1] FALSE
[13:34:34.452]  - until=1
[13:34:34.452]  - relaying element #1
[13:34:34.452] - relayed: [n=1] TRUE
[13:34:34.453] - queued futures: [n=1] TRUE
[13:34:34.453] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.453]  length: 0 (resolved future 1)
[13:34:34.453] Relaying remaining futures
[13:34:34.453] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.453] - nx: 1
[13:34:34.453] - relay: TRUE
[13:34:34.453] - stdout: TRUE
[13:34:34.453] - signal: TRUE
[13:34:34.453] - resignal: FALSE
[13:34:34.453] - force: TRUE
[13:34:34.453] - relayed: [n=1] TRUE
[13:34:34.453] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.454] - relayed: [n=1] TRUE
[13:34:34.454] - queued futures: [n=1] TRUE
[13:34:34.454] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.454] resolve() on list ... DONE
[13:34:34.454]  - Number of value chunks collected: 1
[13:34:34.454] Resolving 1 futures (chunks) ... DONE
[13:34:34.454] Reducing values from 1 chunks ...
[13:34:34.454]  - Number of values collected after concatenation: 5
[13:34:34.454]  - Number of values expected: 5
[13:34:34.454] Reducing values from 1 chunks ... DONE
[13:34:34.454] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[13:34:34.455] future_mapply() ...
[13:34:34.455] Number of chunks: 1
[13:34:34.455] getGlobalsAndPackagesXApply() ...
[13:34:34.455]  - future.globals: TRUE
[13:34:34.455] getGlobalsAndPackages() ...
[13:34:34.456] Searching for globals...
[13:34:34.456] - globals found: [1] ‘FUN’
[13:34:34.457] Searching for globals ... DONE
[13:34:34.457] Resolving globals: FALSE
[13:34:34.457] The total size of the 1 globals is 848 bytes (848 bytes)
[13:34:34.457] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:34:34.457] - globals: [1] ‘FUN’
[13:34:34.457] 
[13:34:34.457] getGlobalsAndPackages() ... DONE
[13:34:34.458]  - globals found/used: [n=1] ‘FUN’
[13:34:34.459]  - needed namespaces: [n=0] 
[13:34:34.459] Finding globals ... DONE
[13:34:34.459] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.459] List of 2
[13:34:34.459]  $ ...future.FUN:function (x)  
[13:34:34.459]  $ MoreArgs     : NULL
[13:34:34.459]  - attr(*, "where")=List of 2
[13:34:34.459]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.459]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.459]  - attr(*, "resolved")= logi FALSE
[13:34:34.459]  - attr(*, "total_size")= num NA
[13:34:34.461] Packages to be attached in all futures: [n=0] 
[13:34:34.461] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.461] Number of futures (= number of chunks): 1
[13:34:34.462] Launching 1 futures (chunks) ...
[13:34:34.462] Chunk #1 of 1 ...
[13:34:34.462]  - Finding globals in '...' for chunk #1 ...
[13:34:34.462] getGlobalsAndPackages() ...
[13:34:34.462] Searching for globals...
[13:34:34.462] 
[13:34:34.462] Searching for globals ... DONE
[13:34:34.462] - globals: [0] <none>
[13:34:34.463] getGlobalsAndPackages() ... DONE
[13:34:34.463]    + additional globals found: [n=0] 
[13:34:34.463]    + additional namespaces needed: [n=0] 
[13:34:34.463]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.463]  - seeds: <none>
[13:34:34.463]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.463] getGlobalsAndPackages() ...
[13:34:34.463] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.463] Resolving globals: FALSE
[13:34:34.464] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[13:34:34.464] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.464] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.464] 
[13:34:34.464] getGlobalsAndPackages() ... DONE
[13:34:34.465] run() for ‘Future’ ...
[13:34:34.465] - state: ‘created’
[13:34:34.465] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.465] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.465]   - Field: ‘label’
[13:34:34.465]   - Field: ‘local’
[13:34:34.465]   - Field: ‘owner’
[13:34:34.465]   - Field: ‘envir’
[13:34:34.466]   - Field: ‘packages’
[13:34:34.466]   - Field: ‘gc’
[13:34:34.466]   - Field: ‘conditions’
[13:34:34.466]   - Field: ‘expr’
[13:34:34.466]   - Field: ‘uuid’
[13:34:34.466]   - Field: ‘seed’
[13:34:34.466]   - Field: ‘version’
[13:34:34.466]   - Field: ‘result’
[13:34:34.466]   - Field: ‘asynchronous’
[13:34:34.466]   - Field: ‘calls’
[13:34:34.466]   - Field: ‘globals’
[13:34:34.467]   - Field: ‘stdout’
[13:34:34.467]   - Field: ‘earlySignal’
[13:34:34.467]   - Field: ‘lazy’
[13:34:34.467]   - Field: ‘state’
[13:34:34.467] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.467] - Launch lazy future ...
[13:34:34.467] Packages needed by the future expression (n = 0): <none>
[13:34:34.467] Packages needed by future strategies (n = 0): <none>
[13:34:34.468] {
[13:34:34.468]     {
[13:34:34.468]         {
[13:34:34.468]             ...future.startTime <- base::Sys.time()
[13:34:34.468]             {
[13:34:34.468]                 {
[13:34:34.468]                   {
[13:34:34.468]                     base::local({
[13:34:34.468]                       has_future <- base::requireNamespace("future", 
[13:34:34.468]                         quietly = TRUE)
[13:34:34.468]                       if (has_future) {
[13:34:34.468]                         ns <- base::getNamespace("future")
[13:34:34.468]                         version <- ns[[".package"]][["version"]]
[13:34:34.468]                         if (is.null(version)) 
[13:34:34.468]                           version <- utils::packageVersion("future")
[13:34:34.468]                       }
[13:34:34.468]                       else {
[13:34:34.468]                         version <- NULL
[13:34:34.468]                       }
[13:34:34.468]                       if (!has_future || version < "1.8.0") {
[13:34:34.468]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.468]                           "", base::R.version$version.string), 
[13:34:34.468]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.468]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.468]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.468]                             "release", "version")], collapse = " "), 
[13:34:34.468]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.468]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.468]                           info)
[13:34:34.468]                         info <- base::paste(info, collapse = "; ")
[13:34:34.468]                         if (!has_future) {
[13:34:34.468]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.468]                             info)
[13:34:34.468]                         }
[13:34:34.468]                         else {
[13:34:34.468]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.468]                             info, version)
[13:34:34.468]                         }
[13:34:34.468]                         base::stop(msg)
[13:34:34.468]                       }
[13:34:34.468]                     })
[13:34:34.468]                   }
[13:34:34.468]                   ...future.strategy.old <- future::plan("list")
[13:34:34.468]                   options(future.plan = NULL)
[13:34:34.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.468]                 }
[13:34:34.468]                 ...future.workdir <- getwd()
[13:34:34.468]             }
[13:34:34.468]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.468]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.468]         }
[13:34:34.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.468]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.468]             base::names(...future.oldOptions))
[13:34:34.468]     }
[13:34:34.468]     if (FALSE) {
[13:34:34.468]     }
[13:34:34.468]     else {
[13:34:34.468]         if (TRUE) {
[13:34:34.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.468]                 open = "w")
[13:34:34.468]         }
[13:34:34.468]         else {
[13:34:34.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.468]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.468]         }
[13:34:34.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.468]             base::sink(type = "output", split = FALSE)
[13:34:34.468]             base::close(...future.stdout)
[13:34:34.468]         }, add = TRUE)
[13:34:34.468]     }
[13:34:34.468]     ...future.frame <- base::sys.nframe()
[13:34:34.468]     ...future.conditions <- base::list()
[13:34:34.468]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.468]     if (FALSE) {
[13:34:34.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.468]     }
[13:34:34.468]     ...future.result <- base::tryCatch({
[13:34:34.468]         base::withCallingHandlers({
[13:34:34.468]             ...future.value <- base::withVisible(base::local({
[13:34:34.468]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.468]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.468]                   ...future.globals.maxSize)) {
[13:34:34.468]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.468]                   on.exit(options(oopts), add = TRUE)
[13:34:34.468]                 }
[13:34:34.468]                 {
[13:34:34.468]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.468]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.468]                     USE.NAMES = FALSE)
[13:34:34.468]                   do.call(mapply, args = args)
[13:34:34.468]                 }
[13:34:34.468]             }))
[13:34:34.468]             future::FutureResult(value = ...future.value$value, 
[13:34:34.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.468]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.468]                     ...future.globalenv.names))
[13:34:34.468]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.468]         }, condition = base::local({
[13:34:34.468]             c <- base::c
[13:34:34.468]             inherits <- base::inherits
[13:34:34.468]             invokeRestart <- base::invokeRestart
[13:34:34.468]             length <- base::length
[13:34:34.468]             list <- base::list
[13:34:34.468]             seq.int <- base::seq.int
[13:34:34.468]             signalCondition <- base::signalCondition
[13:34:34.468]             sys.calls <- base::sys.calls
[13:34:34.468]             `[[` <- base::`[[`
[13:34:34.468]             `+` <- base::`+`
[13:34:34.468]             `<<-` <- base::`<<-`
[13:34:34.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.468]                   3L)]
[13:34:34.468]             }
[13:34:34.468]             function(cond) {
[13:34:34.468]                 is_error <- inherits(cond, "error")
[13:34:34.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.468]                   NULL)
[13:34:34.468]                 if (is_error) {
[13:34:34.468]                   sessionInformation <- function() {
[13:34:34.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.468]                       search = base::search(), system = base::Sys.info())
[13:34:34.468]                   }
[13:34:34.468]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.468]                     cond$call), session = sessionInformation(), 
[13:34:34.468]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.468]                   signalCondition(cond)
[13:34:34.468]                 }
[13:34:34.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.468]                 "immediateCondition"))) {
[13:34:34.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.468]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.468]                   if (TRUE && !signal) {
[13:34:34.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.468]                     {
[13:34:34.468]                       inherits <- base::inherits
[13:34:34.468]                       invokeRestart <- base::invokeRestart
[13:34:34.468]                       is.null <- base::is.null
[13:34:34.468]                       muffled <- FALSE
[13:34:34.468]                       if (inherits(cond, "message")) {
[13:34:34.468]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.468]                         if (muffled) 
[13:34:34.468]                           invokeRestart("muffleMessage")
[13:34:34.468]                       }
[13:34:34.468]                       else if (inherits(cond, "warning")) {
[13:34:34.468]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.468]                         if (muffled) 
[13:34:34.468]                           invokeRestart("muffleWarning")
[13:34:34.468]                       }
[13:34:34.468]                       else if (inherits(cond, "condition")) {
[13:34:34.468]                         if (!is.null(pattern)) {
[13:34:34.468]                           computeRestarts <- base::computeRestarts
[13:34:34.468]                           grepl <- base::grepl
[13:34:34.468]                           restarts <- computeRestarts(cond)
[13:34:34.468]                           for (restart in restarts) {
[13:34:34.468]                             name <- restart$name
[13:34:34.468]                             if (is.null(name)) 
[13:34:34.468]                               next
[13:34:34.468]                             if (!grepl(pattern, name)) 
[13:34:34.468]                               next
[13:34:34.468]                             invokeRestart(restart)
[13:34:34.468]                             muffled <- TRUE
[13:34:34.468]                             break
[13:34:34.468]                           }
[13:34:34.468]                         }
[13:34:34.468]                       }
[13:34:34.468]                       invisible(muffled)
[13:34:34.468]                     }
[13:34:34.468]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.468]                   }
[13:34:34.468]                 }
[13:34:34.468]                 else {
[13:34:34.468]                   if (TRUE) {
[13:34:34.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.468]                     {
[13:34:34.468]                       inherits <- base::inherits
[13:34:34.468]                       invokeRestart <- base::invokeRestart
[13:34:34.468]                       is.null <- base::is.null
[13:34:34.468]                       muffled <- FALSE
[13:34:34.468]                       if (inherits(cond, "message")) {
[13:34:34.468]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.468]                         if (muffled) 
[13:34:34.468]                           invokeRestart("muffleMessage")
[13:34:34.468]                       }
[13:34:34.468]                       else if (inherits(cond, "warning")) {
[13:34:34.468]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.468]                         if (muffled) 
[13:34:34.468]                           invokeRestart("muffleWarning")
[13:34:34.468]                       }
[13:34:34.468]                       else if (inherits(cond, "condition")) {
[13:34:34.468]                         if (!is.null(pattern)) {
[13:34:34.468]                           computeRestarts <- base::computeRestarts
[13:34:34.468]                           grepl <- base::grepl
[13:34:34.468]                           restarts <- computeRestarts(cond)
[13:34:34.468]                           for (restart in restarts) {
[13:34:34.468]                             name <- restart$name
[13:34:34.468]                             if (is.null(name)) 
[13:34:34.468]                               next
[13:34:34.468]                             if (!grepl(pattern, name)) 
[13:34:34.468]                               next
[13:34:34.468]                             invokeRestart(restart)
[13:34:34.468]                             muffled <- TRUE
[13:34:34.468]                             break
[13:34:34.468]                           }
[13:34:34.468]                         }
[13:34:34.468]                       }
[13:34:34.468]                       invisible(muffled)
[13:34:34.468]                     }
[13:34:34.468]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.468]                   }
[13:34:34.468]                 }
[13:34:34.468]             }
[13:34:34.468]         }))
[13:34:34.468]     }, error = function(ex) {
[13:34:34.468]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.468]                 ...future.rng), started = ...future.startTime, 
[13:34:34.468]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.468]             version = "1.8"), class = "FutureResult")
[13:34:34.468]     }, finally = {
[13:34:34.468]         if (!identical(...future.workdir, getwd())) 
[13:34:34.468]             setwd(...future.workdir)
[13:34:34.468]         {
[13:34:34.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.468]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.468]             }
[13:34:34.468]             base::options(...future.oldOptions)
[13:34:34.468]             if (.Platform$OS.type == "windows") {
[13:34:34.468]                 old_names <- names(...future.oldEnvVars)
[13:34:34.468]                 envs <- base::Sys.getenv()
[13:34:34.468]                 names <- names(envs)
[13:34:34.468]                 common <- intersect(names, old_names)
[13:34:34.468]                 added <- setdiff(names, old_names)
[13:34:34.468]                 removed <- setdiff(old_names, names)
[13:34:34.468]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.468]                   envs[common]]
[13:34:34.468]                 NAMES <- toupper(changed)
[13:34:34.468]                 args <- list()
[13:34:34.468]                 for (kk in seq_along(NAMES)) {
[13:34:34.468]                   name <- changed[[kk]]
[13:34:34.468]                   NAME <- NAMES[[kk]]
[13:34:34.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.468]                     next
[13:34:34.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.468]                 }
[13:34:34.468]                 NAMES <- toupper(added)
[13:34:34.468]                 for (kk in seq_along(NAMES)) {
[13:34:34.468]                   name <- added[[kk]]
[13:34:34.468]                   NAME <- NAMES[[kk]]
[13:34:34.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.468]                     next
[13:34:34.468]                   args[[name]] <- ""
[13:34:34.468]                 }
[13:34:34.468]                 NAMES <- toupper(removed)
[13:34:34.468]                 for (kk in seq_along(NAMES)) {
[13:34:34.468]                   name <- removed[[kk]]
[13:34:34.468]                   NAME <- NAMES[[kk]]
[13:34:34.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.468]                     next
[13:34:34.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.468]                 }
[13:34:34.468]                 if (length(args) > 0) 
[13:34:34.468]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.468]             }
[13:34:34.468]             else {
[13:34:34.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.468]             }
[13:34:34.468]             {
[13:34:34.468]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.468]                   0L) {
[13:34:34.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.468]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.468]                   base::options(opts)
[13:34:34.468]                 }
[13:34:34.468]                 {
[13:34:34.468]                   {
[13:34:34.468]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.468]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.468]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.468]                       inherits = FALSE)
[13:34:34.468]                     NULL
[13:34:34.468]                   }
[13:34:34.468]                   options(future.plan = NULL)
[13:34:34.468]                   if (is.na(NA_character_)) 
[13:34:34.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.468]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.468]                     .init = FALSE)
[13:34:34.468]                 }
[13:34:34.468]             }
[13:34:34.468]         }
[13:34:34.468]     })
[13:34:34.468]     if (TRUE) {
[13:34:34.468]         base::sink(type = "output", split = FALSE)
[13:34:34.468]         if (TRUE) {
[13:34:34.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.468]         }
[13:34:34.468]         else {
[13:34:34.468]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.468]         }
[13:34:34.468]         base::close(...future.stdout)
[13:34:34.468]         ...future.stdout <- NULL
[13:34:34.468]     }
[13:34:34.468]     ...future.result$conditions <- ...future.conditions
[13:34:34.468]     ...future.result$finished <- base::Sys.time()
[13:34:34.468]     ...future.result
[13:34:34.468] }
[13:34:34.469] assign_globals() ...
[13:34:34.469] List of 5
[13:34:34.469]  $ ...future.FUN            :function (x)  
[13:34:34.469]  $ MoreArgs                 : NULL
[13:34:34.469]  $ ...future.elements_ii    :List of 1
[13:34:34.469]   ..$ :List of 1
[13:34:34.469]   .. ..$ : Date[1:1], format: "2018-06-01"
[13:34:34.469]  $ ...future.seeds_ii       : NULL
[13:34:34.469]  $ ...future.globals.maxSize: NULL
[13:34:34.469]  - attr(*, "where")=List of 5
[13:34:34.469]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.469]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.469]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.469]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.469]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.469]  - attr(*, "resolved")= logi FALSE
[13:34:34.469]  - attr(*, "total_size")= num 1128
[13:34:34.469]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.469]  - attr(*, "already-done")= logi TRUE
[13:34:34.474] - copied ‘...future.FUN’ to environment
[13:34:34.474] - copied ‘MoreArgs’ to environment
[13:34:34.474] - copied ‘...future.elements_ii’ to environment
[13:34:34.474] - copied ‘...future.seeds_ii’ to environment
[13:34:34.474] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.474] assign_globals() ... done
[13:34:34.474] plan(): Setting new future strategy stack:
[13:34:34.474] List of future strategies:
[13:34:34.474] 1. sequential:
[13:34:34.474]    - args: function (..., envir = parent.frame())
[13:34:34.474]    - tweaked: FALSE
[13:34:34.474]    - call: NULL
[13:34:34.475] plan(): nbrOfWorkers() = 1
[13:34:34.475] plan(): Setting new future strategy stack:
[13:34:34.475] List of future strategies:
[13:34:34.475] 1. sequential:
[13:34:34.475]    - args: function (..., envir = parent.frame())
[13:34:34.475]    - tweaked: FALSE
[13:34:34.475]    - call: plan(strategy)
[13:34:34.476] plan(): nbrOfWorkers() = 1
[13:34:34.476] SequentialFuture started (and completed)
[13:34:34.476] - Launch lazy future ... done
[13:34:34.476] run() for ‘SequentialFuture’ ... done
[13:34:34.476] Created future:
[13:34:34.476] SequentialFuture:
[13:34:34.476] Label: ‘future_mapply-1’
[13:34:34.476] Expression:
[13:34:34.476] {
[13:34:34.476]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.476]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.476]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.476]         on.exit(options(oopts), add = TRUE)
[13:34:34.476]     }
[13:34:34.476]     {
[13:34:34.476]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.476]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.476]         do.call(mapply, args = args)
[13:34:34.476]     }
[13:34:34.476] }
[13:34:34.476] Lazy evaluation: FALSE
[13:34:34.476] Asynchronous evaluation: FALSE
[13:34:34.476] Local evaluation: TRUE
[13:34:34.476] Environment: R_GlobalEnv
[13:34:34.476] Capture standard output: TRUE
[13:34:34.476] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.476] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.476] Packages: <none>
[13:34:34.476] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.476] Resolved: TRUE
[13:34:34.476] Value: 280 bytes of class ‘list’
[13:34:34.476] Early signaling: FALSE
[13:34:34.476] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.476] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.477] Chunk #1 of 1 ... DONE
[13:34:34.477] Launching 1 futures (chunks) ... DONE
[13:34:34.477] Resolving 1 futures (chunks) ...
[13:34:34.477] resolve() on list ...
[13:34:34.477]  recursive: 0
[13:34:34.477]  length: 1
[13:34:34.478] 
[13:34:34.478] resolved() for ‘SequentialFuture’ ...
[13:34:34.478] - state: ‘finished’
[13:34:34.478] - run: TRUE
[13:34:34.478] - result: ‘FutureResult’
[13:34:34.478] resolved() for ‘SequentialFuture’ ... done
[13:34:34.478] Future #1
[13:34:34.478] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.478] - nx: 1
[13:34:34.478] - relay: TRUE
[13:34:34.478] - stdout: TRUE
[13:34:34.479] - signal: TRUE
[13:34:34.479] - resignal: FALSE
[13:34:34.479] - force: TRUE
[13:34:34.479] - relayed: [n=1] FALSE
[13:34:34.479] - queued futures: [n=1] FALSE
[13:34:34.479]  - until=1
[13:34:34.479]  - relaying element #1
[13:34:34.480] - relayed: [n=1] TRUE
[13:34:34.480] - queued futures: [n=1] TRUE
[13:34:34.480] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.480]  length: 0 (resolved future 1)
[13:34:34.480] Relaying remaining futures
[13:34:34.480] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.481] - nx: 1
[13:34:34.481] - relay: TRUE
[13:34:34.481] - stdout: TRUE
[13:34:34.481] - signal: TRUE
[13:34:34.481] - resignal: FALSE
[13:34:34.481] - force: TRUE
[13:34:34.481] - relayed: [n=1] TRUE
[13:34:34.481] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.481] - relayed: [n=1] TRUE
[13:34:34.481] - queued futures: [n=1] TRUE
[13:34:34.481] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.481] resolve() on list ... DONE
[13:34:34.482]  - Number of value chunks collected: 1
[13:34:34.482] Resolving 1 futures (chunks) ... DONE
[13:34:34.482] Reducing values from 1 chunks ...
[13:34:34.482]  - Number of values collected after concatenation: 1
[13:34:34.482]  - Number of values expected: 1
[13:34:34.482] Reducing values from 1 chunks ... DONE
[13:34:34.482] future_mapply() ... DONE
[13:34:34.482] future_mapply() ...
[13:34:34.482] Number of chunks: 1
[13:34:34.483] getGlobalsAndPackagesXApply() ...
[13:34:34.483]  - future.globals: TRUE
[13:34:34.483] getGlobalsAndPackages() ...
[13:34:34.483] Searching for globals...
[13:34:34.484] - globals found: [1] ‘FUN’
[13:34:34.484] Searching for globals ... DONE
[13:34:34.484] Resolving globals: FALSE
[13:34:34.484] The total size of the 1 globals is 848 bytes (848 bytes)
[13:34:34.484] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:34:34.484] - globals: [1] ‘FUN’
[13:34:34.485] 
[13:34:34.485] getGlobalsAndPackages() ... DONE
[13:34:34.485]  - globals found/used: [n=1] ‘FUN’
[13:34:34.485]  - needed namespaces: [n=0] 
[13:34:34.485] Finding globals ... DONE
[13:34:34.485] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.485] List of 2
[13:34:34.485]  $ ...future.FUN:function (x)  
[13:34:34.485]  $ MoreArgs     : list()
[13:34:34.485]  - attr(*, "where")=List of 2
[13:34:34.485]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.485]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.485]  - attr(*, "resolved")= logi FALSE
[13:34:34.485]  - attr(*, "total_size")= num NA
[13:34:34.487] Packages to be attached in all futures: [n=0] 
[13:34:34.487] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.488] Number of futures (= number of chunks): 1
[13:34:34.488] Launching 1 futures (chunks) ...
[13:34:34.488] Chunk #1 of 1 ...
[13:34:34.488]  - Finding globals in '...' for chunk #1 ...
[13:34:34.488] getGlobalsAndPackages() ...
[13:34:34.488] Searching for globals...
[13:34:34.488] 
[13:34:34.489] Searching for globals ... DONE
[13:34:34.489] - globals: [0] <none>
[13:34:34.489] getGlobalsAndPackages() ... DONE
[13:34:34.489]    + additional globals found: [n=0] 
[13:34:34.489]    + additional namespaces needed: [n=0] 
[13:34:34.489]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.489]  - seeds: <none>
[13:34:34.489]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.489] getGlobalsAndPackages() ...
[13:34:34.489] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.489] Resolving globals: FALSE
[13:34:34.490] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[13:34:34.490] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:34.490] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.490] 
[13:34:34.491] getGlobalsAndPackages() ... DONE
[13:34:34.491] run() for ‘Future’ ...
[13:34:34.491] - state: ‘created’
[13:34:34.491] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.491] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.491] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.491]   - Field: ‘label’
[13:34:34.491]   - Field: ‘local’
[13:34:34.492]   - Field: ‘owner’
[13:34:34.492]   - Field: ‘envir’
[13:34:34.492]   - Field: ‘packages’
[13:34:34.492]   - Field: ‘gc’
[13:34:34.492]   - Field: ‘conditions’
[13:34:34.492]   - Field: ‘expr’
[13:34:34.492]   - Field: ‘uuid’
[13:34:34.492]   - Field: ‘seed’
[13:34:34.492]   - Field: ‘version’
[13:34:34.492]   - Field: ‘result’
[13:34:34.492]   - Field: ‘asynchronous’
[13:34:34.493]   - Field: ‘calls’
[13:34:34.493]   - Field: ‘globals’
[13:34:34.493]   - Field: ‘stdout’
[13:34:34.493]   - Field: ‘earlySignal’
[13:34:34.493]   - Field: ‘lazy’
[13:34:34.493]   - Field: ‘state’
[13:34:34.493] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.493] - Launch lazy future ...
[13:34:34.493] Packages needed by the future expression (n = 0): <none>
[13:34:34.493] Packages needed by future strategies (n = 0): <none>
[13:34:34.494] {
[13:34:34.494]     {
[13:34:34.494]         {
[13:34:34.494]             ...future.startTime <- base::Sys.time()
[13:34:34.494]             {
[13:34:34.494]                 {
[13:34:34.494]                   {
[13:34:34.494]                     base::local({
[13:34:34.494]                       has_future <- base::requireNamespace("future", 
[13:34:34.494]                         quietly = TRUE)
[13:34:34.494]                       if (has_future) {
[13:34:34.494]                         ns <- base::getNamespace("future")
[13:34:34.494]                         version <- ns[[".package"]][["version"]]
[13:34:34.494]                         if (is.null(version)) 
[13:34:34.494]                           version <- utils::packageVersion("future")
[13:34:34.494]                       }
[13:34:34.494]                       else {
[13:34:34.494]                         version <- NULL
[13:34:34.494]                       }
[13:34:34.494]                       if (!has_future || version < "1.8.0") {
[13:34:34.494]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.494]                           "", base::R.version$version.string), 
[13:34:34.494]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.494]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.494]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.494]                             "release", "version")], collapse = " "), 
[13:34:34.494]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.494]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.494]                           info)
[13:34:34.494]                         info <- base::paste(info, collapse = "; ")
[13:34:34.494]                         if (!has_future) {
[13:34:34.494]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.494]                             info)
[13:34:34.494]                         }
[13:34:34.494]                         else {
[13:34:34.494]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.494]                             info, version)
[13:34:34.494]                         }
[13:34:34.494]                         base::stop(msg)
[13:34:34.494]                       }
[13:34:34.494]                     })
[13:34:34.494]                   }
[13:34:34.494]                   ...future.strategy.old <- future::plan("list")
[13:34:34.494]                   options(future.plan = NULL)
[13:34:34.494]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.494]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.494]                 }
[13:34:34.494]                 ...future.workdir <- getwd()
[13:34:34.494]             }
[13:34:34.494]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.494]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.494]         }
[13:34:34.494]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.494]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.494]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.494]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.494]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.494]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.494]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.494]             base::names(...future.oldOptions))
[13:34:34.494]     }
[13:34:34.494]     if (FALSE) {
[13:34:34.494]     }
[13:34:34.494]     else {
[13:34:34.494]         if (TRUE) {
[13:34:34.494]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.494]                 open = "w")
[13:34:34.494]         }
[13:34:34.494]         else {
[13:34:34.494]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.494]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.494]         }
[13:34:34.494]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.494]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.494]             base::sink(type = "output", split = FALSE)
[13:34:34.494]             base::close(...future.stdout)
[13:34:34.494]         }, add = TRUE)
[13:34:34.494]     }
[13:34:34.494]     ...future.frame <- base::sys.nframe()
[13:34:34.494]     ...future.conditions <- base::list()
[13:34:34.494]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.494]     if (FALSE) {
[13:34:34.494]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.494]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.494]     }
[13:34:34.494]     ...future.result <- base::tryCatch({
[13:34:34.494]         base::withCallingHandlers({
[13:34:34.494]             ...future.value <- base::withVisible(base::local({
[13:34:34.494]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.494]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.494]                   ...future.globals.maxSize)) {
[13:34:34.494]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.494]                   on.exit(options(oopts), add = TRUE)
[13:34:34.494]                 }
[13:34:34.494]                 {
[13:34:34.494]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.494]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.494]                     USE.NAMES = FALSE)
[13:34:34.494]                   do.call(mapply, args = args)
[13:34:34.494]                 }
[13:34:34.494]             }))
[13:34:34.494]             future::FutureResult(value = ...future.value$value, 
[13:34:34.494]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.494]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.494]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.494]                     ...future.globalenv.names))
[13:34:34.494]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.494]         }, condition = base::local({
[13:34:34.494]             c <- base::c
[13:34:34.494]             inherits <- base::inherits
[13:34:34.494]             invokeRestart <- base::invokeRestart
[13:34:34.494]             length <- base::length
[13:34:34.494]             list <- base::list
[13:34:34.494]             seq.int <- base::seq.int
[13:34:34.494]             signalCondition <- base::signalCondition
[13:34:34.494]             sys.calls <- base::sys.calls
[13:34:34.494]             `[[` <- base::`[[`
[13:34:34.494]             `+` <- base::`+`
[13:34:34.494]             `<<-` <- base::`<<-`
[13:34:34.494]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.494]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.494]                   3L)]
[13:34:34.494]             }
[13:34:34.494]             function(cond) {
[13:34:34.494]                 is_error <- inherits(cond, "error")
[13:34:34.494]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.494]                   NULL)
[13:34:34.494]                 if (is_error) {
[13:34:34.494]                   sessionInformation <- function() {
[13:34:34.494]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.494]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.494]                       search = base::search(), system = base::Sys.info())
[13:34:34.494]                   }
[13:34:34.494]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.494]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.494]                     cond$call), session = sessionInformation(), 
[13:34:34.494]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.494]                   signalCondition(cond)
[13:34:34.494]                 }
[13:34:34.494]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.494]                 "immediateCondition"))) {
[13:34:34.494]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.494]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.494]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.494]                   if (TRUE && !signal) {
[13:34:34.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.494]                     {
[13:34:34.494]                       inherits <- base::inherits
[13:34:34.494]                       invokeRestart <- base::invokeRestart
[13:34:34.494]                       is.null <- base::is.null
[13:34:34.494]                       muffled <- FALSE
[13:34:34.494]                       if (inherits(cond, "message")) {
[13:34:34.494]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.494]                         if (muffled) 
[13:34:34.494]                           invokeRestart("muffleMessage")
[13:34:34.494]                       }
[13:34:34.494]                       else if (inherits(cond, "warning")) {
[13:34:34.494]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.494]                         if (muffled) 
[13:34:34.494]                           invokeRestart("muffleWarning")
[13:34:34.494]                       }
[13:34:34.494]                       else if (inherits(cond, "condition")) {
[13:34:34.494]                         if (!is.null(pattern)) {
[13:34:34.494]                           computeRestarts <- base::computeRestarts
[13:34:34.494]                           grepl <- base::grepl
[13:34:34.494]                           restarts <- computeRestarts(cond)
[13:34:34.494]                           for (restart in restarts) {
[13:34:34.494]                             name <- restart$name
[13:34:34.494]                             if (is.null(name)) 
[13:34:34.494]                               next
[13:34:34.494]                             if (!grepl(pattern, name)) 
[13:34:34.494]                               next
[13:34:34.494]                             invokeRestart(restart)
[13:34:34.494]                             muffled <- TRUE
[13:34:34.494]                             break
[13:34:34.494]                           }
[13:34:34.494]                         }
[13:34:34.494]                       }
[13:34:34.494]                       invisible(muffled)
[13:34:34.494]                     }
[13:34:34.494]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.494]                   }
[13:34:34.494]                 }
[13:34:34.494]                 else {
[13:34:34.494]                   if (TRUE) {
[13:34:34.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.494]                     {
[13:34:34.494]                       inherits <- base::inherits
[13:34:34.494]                       invokeRestart <- base::invokeRestart
[13:34:34.494]                       is.null <- base::is.null
[13:34:34.494]                       muffled <- FALSE
[13:34:34.494]                       if (inherits(cond, "message")) {
[13:34:34.494]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.494]                         if (muffled) 
[13:34:34.494]                           invokeRestart("muffleMessage")
[13:34:34.494]                       }
[13:34:34.494]                       else if (inherits(cond, "warning")) {
[13:34:34.494]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.494]                         if (muffled) 
[13:34:34.494]                           invokeRestart("muffleWarning")
[13:34:34.494]                       }
[13:34:34.494]                       else if (inherits(cond, "condition")) {
[13:34:34.494]                         if (!is.null(pattern)) {
[13:34:34.494]                           computeRestarts <- base::computeRestarts
[13:34:34.494]                           grepl <- base::grepl
[13:34:34.494]                           restarts <- computeRestarts(cond)
[13:34:34.494]                           for (restart in restarts) {
[13:34:34.494]                             name <- restart$name
[13:34:34.494]                             if (is.null(name)) 
[13:34:34.494]                               next
[13:34:34.494]                             if (!grepl(pattern, name)) 
[13:34:34.494]                               next
[13:34:34.494]                             invokeRestart(restart)
[13:34:34.494]                             muffled <- TRUE
[13:34:34.494]                             break
[13:34:34.494]                           }
[13:34:34.494]                         }
[13:34:34.494]                       }
[13:34:34.494]                       invisible(muffled)
[13:34:34.494]                     }
[13:34:34.494]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.494]                   }
[13:34:34.494]                 }
[13:34:34.494]             }
[13:34:34.494]         }))
[13:34:34.494]     }, error = function(ex) {
[13:34:34.494]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.494]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.494]                 ...future.rng), started = ...future.startTime, 
[13:34:34.494]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.494]             version = "1.8"), class = "FutureResult")
[13:34:34.494]     }, finally = {
[13:34:34.494]         if (!identical(...future.workdir, getwd())) 
[13:34:34.494]             setwd(...future.workdir)
[13:34:34.494]         {
[13:34:34.494]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.494]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.494]             }
[13:34:34.494]             base::options(...future.oldOptions)
[13:34:34.494]             if (.Platform$OS.type == "windows") {
[13:34:34.494]                 old_names <- names(...future.oldEnvVars)
[13:34:34.494]                 envs <- base::Sys.getenv()
[13:34:34.494]                 names <- names(envs)
[13:34:34.494]                 common <- intersect(names, old_names)
[13:34:34.494]                 added <- setdiff(names, old_names)
[13:34:34.494]                 removed <- setdiff(old_names, names)
[13:34:34.494]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.494]                   envs[common]]
[13:34:34.494]                 NAMES <- toupper(changed)
[13:34:34.494]                 args <- list()
[13:34:34.494]                 for (kk in seq_along(NAMES)) {
[13:34:34.494]                   name <- changed[[kk]]
[13:34:34.494]                   NAME <- NAMES[[kk]]
[13:34:34.494]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.494]                     next
[13:34:34.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.494]                 }
[13:34:34.494]                 NAMES <- toupper(added)
[13:34:34.494]                 for (kk in seq_along(NAMES)) {
[13:34:34.494]                   name <- added[[kk]]
[13:34:34.494]                   NAME <- NAMES[[kk]]
[13:34:34.494]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.494]                     next
[13:34:34.494]                   args[[name]] <- ""
[13:34:34.494]                 }
[13:34:34.494]                 NAMES <- toupper(removed)
[13:34:34.494]                 for (kk in seq_along(NAMES)) {
[13:34:34.494]                   name <- removed[[kk]]
[13:34:34.494]                   NAME <- NAMES[[kk]]
[13:34:34.494]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.494]                     next
[13:34:34.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.494]                 }
[13:34:34.494]                 if (length(args) > 0) 
[13:34:34.494]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.494]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.494]             }
[13:34:34.494]             else {
[13:34:34.494]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.494]             }
[13:34:34.494]             {
[13:34:34.494]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.494]                   0L) {
[13:34:34.494]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.494]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.494]                   base::options(opts)
[13:34:34.494]                 }
[13:34:34.494]                 {
[13:34:34.494]                   {
[13:34:34.494]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.494]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.494]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.494]                       inherits = FALSE)
[13:34:34.494]                     NULL
[13:34:34.494]                   }
[13:34:34.494]                   options(future.plan = NULL)
[13:34:34.494]                   if (is.na(NA_character_)) 
[13:34:34.494]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.494]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.494]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.494]                     .init = FALSE)
[13:34:34.494]                 }
[13:34:34.494]             }
[13:34:34.494]         }
[13:34:34.494]     })
[13:34:34.494]     if (TRUE) {
[13:34:34.494]         base::sink(type = "output", split = FALSE)
[13:34:34.494]         if (TRUE) {
[13:34:34.494]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.494]         }
[13:34:34.494]         else {
[13:34:34.494]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.494]         }
[13:34:34.494]         base::close(...future.stdout)
[13:34:34.494]         ...future.stdout <- NULL
[13:34:34.494]     }
[13:34:34.494]     ...future.result$conditions <- ...future.conditions
[13:34:34.494]     ...future.result$finished <- base::Sys.time()
[13:34:34.494]     ...future.result
[13:34:34.494] }
[13:34:34.495] assign_globals() ...
[13:34:34.495] List of 5
[13:34:34.495]  $ ...future.FUN            :function (x)  
[13:34:34.495]  $ MoreArgs                 : list()
[13:34:34.495]  $ ...future.elements_ii    :List of 1
[13:34:34.495]   ..$ :List of 1
[13:34:34.495]   .. ..$ : Date[1:1], format: "2018-06-01"
[13:34:34.495]  $ ...future.seeds_ii       : NULL
[13:34:34.495]  $ ...future.globals.maxSize: NULL
[13:34:34.495]  - attr(*, "where")=List of 5
[13:34:34.495]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.495]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.495]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.495]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.495]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.495]  - attr(*, "resolved")= logi FALSE
[13:34:34.495]  - attr(*, "total_size")= num 1128
[13:34:34.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.495]  - attr(*, "already-done")= logi TRUE
[13:34:34.500] - copied ‘...future.FUN’ to environment
[13:34:34.500] - copied ‘MoreArgs’ to environment
[13:34:34.500] - copied ‘...future.elements_ii’ to environment
[13:34:34.500] - copied ‘...future.seeds_ii’ to environment
[13:34:34.501] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.501] assign_globals() ... done
[13:34:34.501] plan(): Setting new future strategy stack:
[13:34:34.501] List of future strategies:
[13:34:34.501] 1. sequential:
[13:34:34.501]    - args: function (..., envir = parent.frame())
[13:34:34.501]    - tweaked: FALSE
[13:34:34.501]    - call: NULL
[13:34:34.502] plan(): nbrOfWorkers() = 1
[13:34:34.502] plan(): Setting new future strategy stack:
[13:34:34.503] List of future strategies:
[13:34:34.503] 1. sequential:
[13:34:34.503]    - args: function (..., envir = parent.frame())
[13:34:34.503]    - tweaked: FALSE
[13:34:34.503]    - call: plan(strategy)
[13:34:34.503] plan(): nbrOfWorkers() = 1
[13:34:34.503] SequentialFuture started (and completed)
[13:34:34.503] - Launch lazy future ... done
[13:34:34.503] run() for ‘SequentialFuture’ ... done
[13:34:34.503] Created future:
[13:34:34.503] SequentialFuture:
[13:34:34.503] Label: ‘future_.mapply-1’
[13:34:34.503] Expression:
[13:34:34.503] {
[13:34:34.503]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.503]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.503]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.503]         on.exit(options(oopts), add = TRUE)
[13:34:34.503]     }
[13:34:34.503]     {
[13:34:34.503]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.503]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.503]         do.call(mapply, args = args)
[13:34:34.503]     }
[13:34:34.503] }
[13:34:34.503] Lazy evaluation: FALSE
[13:34:34.503] Asynchronous evaluation: FALSE
[13:34:34.503] Local evaluation: TRUE
[13:34:34.503] Environment: R_GlobalEnv
[13:34:34.503] Capture standard output: TRUE
[13:34:34.503] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.503] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.503] Packages: <none>
[13:34:34.503] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.503] Resolved: TRUE
[13:34:34.503] Value: 280 bytes of class ‘list’
[13:34:34.503] Early signaling: FALSE
[13:34:34.503] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.503] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.504] Chunk #1 of 1 ... DONE
[13:34:34.504] Launching 1 futures (chunks) ... DONE
[13:34:34.504] Resolving 1 futures (chunks) ...
[13:34:34.504] resolve() on list ...
[13:34:34.505]  recursive: 0
[13:34:34.505]  length: 1
[13:34:34.505] 
[13:34:34.505] resolved() for ‘SequentialFuture’ ...
[13:34:34.505] - state: ‘finished’
[13:34:34.505] - run: TRUE
[13:34:34.505] - result: ‘FutureResult’
[13:34:34.505] resolved() for ‘SequentialFuture’ ... done
[13:34:34.505] Future #1
[13:34:34.505] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.506] - nx: 1
[13:34:34.506] - relay: TRUE
[13:34:34.506] - stdout: TRUE
[13:34:34.506] - signal: TRUE
[13:34:34.506] - resignal: FALSE
[13:34:34.506] - force: TRUE
[13:34:34.506] - relayed: [n=1] FALSE
[13:34:34.506] - queued futures: [n=1] FALSE
[13:34:34.506]  - until=1
[13:34:34.506]  - relaying element #1
[13:34:34.506] - relayed: [n=1] TRUE
[13:34:34.507] - queued futures: [n=1] TRUE
[13:34:34.507] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.507]  length: 0 (resolved future 1)
[13:34:34.507] Relaying remaining futures
[13:34:34.507] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.507] - nx: 1
[13:34:34.507] - relay: TRUE
[13:34:34.507] - stdout: TRUE
[13:34:34.507] - signal: TRUE
[13:34:34.507] - resignal: FALSE
[13:34:34.507] - force: TRUE
[13:34:34.507] - relayed: [n=1] TRUE
[13:34:34.507] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.508] - relayed: [n=1] TRUE
[13:34:34.508] - queued futures: [n=1] TRUE
[13:34:34.508] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.508] resolve() on list ... DONE
[13:34:34.508]  - Number of value chunks collected: 1
[13:34:34.508] Resolving 1 futures (chunks) ... DONE
[13:34:34.508] Reducing values from 1 chunks ...
[13:34:34.508]  - Number of values collected after concatenation: 1
[13:34:34.508]  - Number of values expected: 1
[13:34:34.508] Reducing values from 1 chunks ... DONE
[13:34:34.509] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[13:34:34.509] future_mapply() ...
[13:34:34.509] Number of chunks: 1
[13:34:34.509] getGlobalsAndPackagesXApply() ...
[13:34:34.509]  - future.globals: TRUE
[13:34:34.509] getGlobalsAndPackages() ...
[13:34:34.509] Searching for globals...
[13:34:34.510] - globals found: [1] ‘FUN’
[13:34:34.510] Searching for globals ... DONE
[13:34:34.510] Resolving globals: FALSE
[13:34:34.511] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[13:34:34.511] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[13:34:34.511] - globals: [1] ‘FUN’
[13:34:34.511] 
[13:34:34.511] getGlobalsAndPackages() ... DONE
[13:34:34.511]  - globals found/used: [n=1] ‘FUN’
[13:34:34.511]  - needed namespaces: [n=0] 
[13:34:34.511] Finding globals ... DONE
[13:34:34.512] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.512] List of 2
[13:34:34.512]  $ ...future.FUN:function (x, y)  
[13:34:34.512]  $ MoreArgs     :List of 1
[13:34:34.512]   ..$ y: int [1:2] 3 4
[13:34:34.512]  - attr(*, "where")=List of 2
[13:34:34.512]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.512]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.512]  - attr(*, "resolved")= logi FALSE
[13:34:34.512]  - attr(*, "total_size")= num NA
[13:34:34.514] Packages to be attached in all futures: [n=0] 
[13:34:34.514] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.515] Number of futures (= number of chunks): 1
[13:34:34.515] Launching 1 futures (chunks) ...
[13:34:34.515] Chunk #1 of 1 ...
[13:34:34.515]  - Finding globals in '...' for chunk #1 ...
[13:34:34.515] getGlobalsAndPackages() ...
[13:34:34.515] Searching for globals...
[13:34:34.515] 
[13:34:34.515] Searching for globals ... DONE
[13:34:34.515] - globals: [0] <none>
[13:34:34.516] getGlobalsAndPackages() ... DONE
[13:34:34.516]    + additional globals found: [n=0] 
[13:34:34.516]    + additional namespaces needed: [n=0] 
[13:34:34.516]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.516]  - seeds: <none>
[13:34:34.516]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.516] getGlobalsAndPackages() ...
[13:34:34.516] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.516] Resolving globals: FALSE
[13:34:34.517] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[13:34:34.517] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[13:34:34.517] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.517] 
[13:34:34.517] getGlobalsAndPackages() ... DONE
[13:34:34.518] run() for ‘Future’ ...
[13:34:34.518] - state: ‘created’
[13:34:34.518] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.518] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.518] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.518]   - Field: ‘label’
[13:34:34.518]   - Field: ‘local’
[13:34:34.518]   - Field: ‘owner’
[13:34:34.519]   - Field: ‘envir’
[13:34:34.519]   - Field: ‘packages’
[13:34:34.519]   - Field: ‘gc’
[13:34:34.519]   - Field: ‘conditions’
[13:34:34.519]   - Field: ‘expr’
[13:34:34.519]   - Field: ‘uuid’
[13:34:34.519]   - Field: ‘seed’
[13:34:34.519]   - Field: ‘version’
[13:34:34.519]   - Field: ‘result’
[13:34:34.519]   - Field: ‘asynchronous’
[13:34:34.519]   - Field: ‘calls’
[13:34:34.520]   - Field: ‘globals’
[13:34:34.520]   - Field: ‘stdout’
[13:34:34.520]   - Field: ‘earlySignal’
[13:34:34.520]   - Field: ‘lazy’
[13:34:34.520]   - Field: ‘state’
[13:34:34.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.520] - Launch lazy future ...
[13:34:34.520] Packages needed by the future expression (n = 0): <none>
[13:34:34.520] Packages needed by future strategies (n = 0): <none>
[13:34:34.522] {
[13:34:34.522]     {
[13:34:34.522]         {
[13:34:34.522]             ...future.startTime <- base::Sys.time()
[13:34:34.522]             {
[13:34:34.522]                 {
[13:34:34.522]                   {
[13:34:34.522]                     base::local({
[13:34:34.522]                       has_future <- base::requireNamespace("future", 
[13:34:34.522]                         quietly = TRUE)
[13:34:34.522]                       if (has_future) {
[13:34:34.522]                         ns <- base::getNamespace("future")
[13:34:34.522]                         version <- ns[[".package"]][["version"]]
[13:34:34.522]                         if (is.null(version)) 
[13:34:34.522]                           version <- utils::packageVersion("future")
[13:34:34.522]                       }
[13:34:34.522]                       else {
[13:34:34.522]                         version <- NULL
[13:34:34.522]                       }
[13:34:34.522]                       if (!has_future || version < "1.8.0") {
[13:34:34.522]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.522]                           "", base::R.version$version.string), 
[13:34:34.522]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.522]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.522]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.522]                             "release", "version")], collapse = " "), 
[13:34:34.522]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.522]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.522]                           info)
[13:34:34.522]                         info <- base::paste(info, collapse = "; ")
[13:34:34.522]                         if (!has_future) {
[13:34:34.522]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.522]                             info)
[13:34:34.522]                         }
[13:34:34.522]                         else {
[13:34:34.522]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.522]                             info, version)
[13:34:34.522]                         }
[13:34:34.522]                         base::stop(msg)
[13:34:34.522]                       }
[13:34:34.522]                     })
[13:34:34.522]                   }
[13:34:34.522]                   ...future.strategy.old <- future::plan("list")
[13:34:34.522]                   options(future.plan = NULL)
[13:34:34.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.522]                 }
[13:34:34.522]                 ...future.workdir <- getwd()
[13:34:34.522]             }
[13:34:34.522]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.522]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.522]         }
[13:34:34.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.522]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.522]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.522]             base::names(...future.oldOptions))
[13:34:34.522]     }
[13:34:34.522]     if (FALSE) {
[13:34:34.522]     }
[13:34:34.522]     else {
[13:34:34.522]         if (TRUE) {
[13:34:34.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.522]                 open = "w")
[13:34:34.522]         }
[13:34:34.522]         else {
[13:34:34.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.522]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.522]         }
[13:34:34.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.522]             base::sink(type = "output", split = FALSE)
[13:34:34.522]             base::close(...future.stdout)
[13:34:34.522]         }, add = TRUE)
[13:34:34.522]     }
[13:34:34.522]     ...future.frame <- base::sys.nframe()
[13:34:34.522]     ...future.conditions <- base::list()
[13:34:34.522]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.522]     if (FALSE) {
[13:34:34.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.522]     }
[13:34:34.522]     ...future.result <- base::tryCatch({
[13:34:34.522]         base::withCallingHandlers({
[13:34:34.522]             ...future.value <- base::withVisible(base::local({
[13:34:34.522]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.522]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.522]                   ...future.globals.maxSize)) {
[13:34:34.522]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.522]                   on.exit(options(oopts), add = TRUE)
[13:34:34.522]                 }
[13:34:34.522]                 {
[13:34:34.522]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.522]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.522]                     USE.NAMES = FALSE)
[13:34:34.522]                   do.call(mapply, args = args)
[13:34:34.522]                 }
[13:34:34.522]             }))
[13:34:34.522]             future::FutureResult(value = ...future.value$value, 
[13:34:34.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.522]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.522]                     ...future.globalenv.names))
[13:34:34.522]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.522]         }, condition = base::local({
[13:34:34.522]             c <- base::c
[13:34:34.522]             inherits <- base::inherits
[13:34:34.522]             invokeRestart <- base::invokeRestart
[13:34:34.522]             length <- base::length
[13:34:34.522]             list <- base::list
[13:34:34.522]             seq.int <- base::seq.int
[13:34:34.522]             signalCondition <- base::signalCondition
[13:34:34.522]             sys.calls <- base::sys.calls
[13:34:34.522]             `[[` <- base::`[[`
[13:34:34.522]             `+` <- base::`+`
[13:34:34.522]             `<<-` <- base::`<<-`
[13:34:34.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.522]                   3L)]
[13:34:34.522]             }
[13:34:34.522]             function(cond) {
[13:34:34.522]                 is_error <- inherits(cond, "error")
[13:34:34.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.522]                   NULL)
[13:34:34.522]                 if (is_error) {
[13:34:34.522]                   sessionInformation <- function() {
[13:34:34.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.522]                       search = base::search(), system = base::Sys.info())
[13:34:34.522]                   }
[13:34:34.522]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.522]                     cond$call), session = sessionInformation(), 
[13:34:34.522]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.522]                   signalCondition(cond)
[13:34:34.522]                 }
[13:34:34.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.522]                 "immediateCondition"))) {
[13:34:34.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.522]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.522]                   if (TRUE && !signal) {
[13:34:34.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.522]                     {
[13:34:34.522]                       inherits <- base::inherits
[13:34:34.522]                       invokeRestart <- base::invokeRestart
[13:34:34.522]                       is.null <- base::is.null
[13:34:34.522]                       muffled <- FALSE
[13:34:34.522]                       if (inherits(cond, "message")) {
[13:34:34.522]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.522]                         if (muffled) 
[13:34:34.522]                           invokeRestart("muffleMessage")
[13:34:34.522]                       }
[13:34:34.522]                       else if (inherits(cond, "warning")) {
[13:34:34.522]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.522]                         if (muffled) 
[13:34:34.522]                           invokeRestart("muffleWarning")
[13:34:34.522]                       }
[13:34:34.522]                       else if (inherits(cond, "condition")) {
[13:34:34.522]                         if (!is.null(pattern)) {
[13:34:34.522]                           computeRestarts <- base::computeRestarts
[13:34:34.522]                           grepl <- base::grepl
[13:34:34.522]                           restarts <- computeRestarts(cond)
[13:34:34.522]                           for (restart in restarts) {
[13:34:34.522]                             name <- restart$name
[13:34:34.522]                             if (is.null(name)) 
[13:34:34.522]                               next
[13:34:34.522]                             if (!grepl(pattern, name)) 
[13:34:34.522]                               next
[13:34:34.522]                             invokeRestart(restart)
[13:34:34.522]                             muffled <- TRUE
[13:34:34.522]                             break
[13:34:34.522]                           }
[13:34:34.522]                         }
[13:34:34.522]                       }
[13:34:34.522]                       invisible(muffled)
[13:34:34.522]                     }
[13:34:34.522]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.522]                   }
[13:34:34.522]                 }
[13:34:34.522]                 else {
[13:34:34.522]                   if (TRUE) {
[13:34:34.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.522]                     {
[13:34:34.522]                       inherits <- base::inherits
[13:34:34.522]                       invokeRestart <- base::invokeRestart
[13:34:34.522]                       is.null <- base::is.null
[13:34:34.522]                       muffled <- FALSE
[13:34:34.522]                       if (inherits(cond, "message")) {
[13:34:34.522]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.522]                         if (muffled) 
[13:34:34.522]                           invokeRestart("muffleMessage")
[13:34:34.522]                       }
[13:34:34.522]                       else if (inherits(cond, "warning")) {
[13:34:34.522]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.522]                         if (muffled) 
[13:34:34.522]                           invokeRestart("muffleWarning")
[13:34:34.522]                       }
[13:34:34.522]                       else if (inherits(cond, "condition")) {
[13:34:34.522]                         if (!is.null(pattern)) {
[13:34:34.522]                           computeRestarts <- base::computeRestarts
[13:34:34.522]                           grepl <- base::grepl
[13:34:34.522]                           restarts <- computeRestarts(cond)
[13:34:34.522]                           for (restart in restarts) {
[13:34:34.522]                             name <- restart$name
[13:34:34.522]                             if (is.null(name)) 
[13:34:34.522]                               next
[13:34:34.522]                             if (!grepl(pattern, name)) 
[13:34:34.522]                               next
[13:34:34.522]                             invokeRestart(restart)
[13:34:34.522]                             muffled <- TRUE
[13:34:34.522]                             break
[13:34:34.522]                           }
[13:34:34.522]                         }
[13:34:34.522]                       }
[13:34:34.522]                       invisible(muffled)
[13:34:34.522]                     }
[13:34:34.522]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.522]                   }
[13:34:34.522]                 }
[13:34:34.522]             }
[13:34:34.522]         }))
[13:34:34.522]     }, error = function(ex) {
[13:34:34.522]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.522]                 ...future.rng), started = ...future.startTime, 
[13:34:34.522]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.522]             version = "1.8"), class = "FutureResult")
[13:34:34.522]     }, finally = {
[13:34:34.522]         if (!identical(...future.workdir, getwd())) 
[13:34:34.522]             setwd(...future.workdir)
[13:34:34.522]         {
[13:34:34.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.522]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.522]             }
[13:34:34.522]             base::options(...future.oldOptions)
[13:34:34.522]             if (.Platform$OS.type == "windows") {
[13:34:34.522]                 old_names <- names(...future.oldEnvVars)
[13:34:34.522]                 envs <- base::Sys.getenv()
[13:34:34.522]                 names <- names(envs)
[13:34:34.522]                 common <- intersect(names, old_names)
[13:34:34.522]                 added <- setdiff(names, old_names)
[13:34:34.522]                 removed <- setdiff(old_names, names)
[13:34:34.522]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.522]                   envs[common]]
[13:34:34.522]                 NAMES <- toupper(changed)
[13:34:34.522]                 args <- list()
[13:34:34.522]                 for (kk in seq_along(NAMES)) {
[13:34:34.522]                   name <- changed[[kk]]
[13:34:34.522]                   NAME <- NAMES[[kk]]
[13:34:34.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.522]                     next
[13:34:34.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.522]                 }
[13:34:34.522]                 NAMES <- toupper(added)
[13:34:34.522]                 for (kk in seq_along(NAMES)) {
[13:34:34.522]                   name <- added[[kk]]
[13:34:34.522]                   NAME <- NAMES[[kk]]
[13:34:34.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.522]                     next
[13:34:34.522]                   args[[name]] <- ""
[13:34:34.522]                 }
[13:34:34.522]                 NAMES <- toupper(removed)
[13:34:34.522]                 for (kk in seq_along(NAMES)) {
[13:34:34.522]                   name <- removed[[kk]]
[13:34:34.522]                   NAME <- NAMES[[kk]]
[13:34:34.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.522]                     next
[13:34:34.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.522]                 }
[13:34:34.522]                 if (length(args) > 0) 
[13:34:34.522]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.522]             }
[13:34:34.522]             else {
[13:34:34.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.522]             }
[13:34:34.522]             {
[13:34:34.522]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.522]                   0L) {
[13:34:34.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.522]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.522]                   base::options(opts)
[13:34:34.522]                 }
[13:34:34.522]                 {
[13:34:34.522]                   {
[13:34:34.522]                     base::assign(".Random.seed", c(10407L, 37299922L, 
[13:34:34.522]                     -878116216L, -1429551491L, -1019631951L, 
[13:34:34.522]                     -667060590L, -54844326L), envir = base::globalenv(), 
[13:34:34.522]                       inherits = FALSE)
[13:34:34.522]                     NULL
[13:34:34.522]                   }
[13:34:34.522]                   options(future.plan = NULL)
[13:34:34.522]                   if (is.na(NA_character_)) 
[13:34:34.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.522]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.522]                     .init = FALSE)
[13:34:34.522]                 }
[13:34:34.522]             }
[13:34:34.522]         }
[13:34:34.522]     })
[13:34:34.522]     if (TRUE) {
[13:34:34.522]         base::sink(type = "output", split = FALSE)
[13:34:34.522]         if (TRUE) {
[13:34:34.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.522]         }
[13:34:34.522]         else {
[13:34:34.522]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.522]         }
[13:34:34.522]         base::close(...future.stdout)
[13:34:34.522]         ...future.stdout <- NULL
[13:34:34.522]     }
[13:34:34.522]     ...future.result$conditions <- ...future.conditions
[13:34:34.522]     ...future.result$finished <- base::Sys.time()
[13:34:34.522]     ...future.result
[13:34:34.522] }
[13:34:34.523] assign_globals() ...
[13:34:34.523] List of 5
[13:34:34.523]  $ ...future.FUN            :function (x, y)  
[13:34:34.523]  $ MoreArgs                 :List of 1
[13:34:34.523]   ..$ y: int [1:2] 3 4
[13:34:34.523]  $ ...future.elements_ii    :List of 1
[13:34:34.523]   ..$ x:List of 2
[13:34:34.523]   .. ..$ : int 1
[13:34:34.523]   .. ..$ : int 2
[13:34:34.523]  $ ...future.seeds_ii       : NULL
[13:34:34.523]  $ ...future.globals.maxSize: NULL
[13:34:34.523]  - attr(*, "where")=List of 5
[13:34:34.523]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.523]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.523]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.523]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.523]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.523]  - attr(*, "resolved")= logi FALSE
[13:34:34.523]  - attr(*, "total_size")= num 1872
[13:34:34.523]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.523]  - attr(*, "already-done")= logi TRUE
[13:34:34.528] - reassign environment for ‘...future.FUN’
[13:34:34.528] - copied ‘...future.FUN’ to environment
[13:34:34.528] - copied ‘MoreArgs’ to environment
[13:34:34.528] - copied ‘...future.elements_ii’ to environment
[13:34:34.529] - copied ‘...future.seeds_ii’ to environment
[13:34:34.529] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.529] assign_globals() ... done
[13:34:34.529] plan(): Setting new future strategy stack:
[13:34:34.529] List of future strategies:
[13:34:34.529] 1. sequential:
[13:34:34.529]    - args: function (..., envir = parent.frame())
[13:34:34.529]    - tweaked: FALSE
[13:34:34.529]    - call: NULL
[13:34:34.529] plan(): nbrOfWorkers() = 1
[13:34:34.530] plan(): Setting new future strategy stack:
[13:34:34.530] List of future strategies:
[13:34:34.530] 1. sequential:
[13:34:34.530]    - args: function (..., envir = parent.frame())
[13:34:34.530]    - tweaked: FALSE
[13:34:34.530]    - call: plan(strategy)
[13:34:34.530] plan(): nbrOfWorkers() = 1
[13:34:34.531] SequentialFuture started (and completed)
[13:34:34.531] - Launch lazy future ... done
[13:34:34.531] run() for ‘SequentialFuture’ ... done
[13:34:34.531] Created future:
[13:34:34.531] SequentialFuture:
[13:34:34.531] Label: ‘future_mapply-1’
[13:34:34.531] Expression:
[13:34:34.531] {
[13:34:34.531]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.531]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.531]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.531]         on.exit(options(oopts), add = TRUE)
[13:34:34.531]     }
[13:34:34.531]     {
[13:34:34.531]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.531]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.531]         do.call(mapply, args = args)
[13:34:34.531]     }
[13:34:34.531] }
[13:34:34.531] Lazy evaluation: FALSE
[13:34:34.531] Asynchronous evaluation: FALSE
[13:34:34.531] Local evaluation: TRUE
[13:34:34.531] Environment: R_GlobalEnv
[13:34:34.531] Capture standard output: TRUE
[13:34:34.531] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.531] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.531] Packages: <none>
[13:34:34.531] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.531] Resolved: TRUE
[13:34:34.531] Value: 112 bytes of class ‘list’
[13:34:34.531] Early signaling: FALSE
[13:34:34.531] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.531] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.532] Chunk #1 of 1 ... DONE
[13:34:34.532] Launching 1 futures (chunks) ... DONE
[13:34:34.532] Resolving 1 futures (chunks) ...
[13:34:34.532] resolve() on list ...
[13:34:34.532]  recursive: 0
[13:34:34.532]  length: 1
[13:34:34.532] 
[13:34:34.532] resolved() for ‘SequentialFuture’ ...
[13:34:34.532] - state: ‘finished’
[13:34:34.533] - run: TRUE
[13:34:34.533] - result: ‘FutureResult’
[13:34:34.533] resolved() for ‘SequentialFuture’ ... done
[13:34:34.533] Future #1
[13:34:34.533] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.533] - nx: 1
[13:34:34.533] - relay: TRUE
[13:34:34.533] - stdout: TRUE
[13:34:34.533] - signal: TRUE
[13:34:34.533] - resignal: FALSE
[13:34:34.533] - force: TRUE
[13:34:34.533] - relayed: [n=1] FALSE
[13:34:34.534] - queued futures: [n=1] FALSE
[13:34:34.534]  - until=1
[13:34:34.534]  - relaying element #1
[13:34:34.534] - relayed: [n=1] TRUE
[13:34:34.534] - queued futures: [n=1] TRUE
[13:34:34.534] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.534]  length: 0 (resolved future 1)
[13:34:34.534] Relaying remaining futures
[13:34:34.534] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.534] - nx: 1
[13:34:34.534] - relay: TRUE
[13:34:34.535] - stdout: TRUE
[13:34:34.535] - signal: TRUE
[13:34:34.535] - resignal: FALSE
[13:34:34.535] - force: TRUE
[13:34:34.535] - relayed: [n=1] TRUE
[13:34:34.535] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.535] - relayed: [n=1] TRUE
[13:34:34.535] - queued futures: [n=1] TRUE
[13:34:34.535] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.535] resolve() on list ... DONE
[13:34:34.535]  - Number of value chunks collected: 1
[13:34:34.536] Resolving 1 futures (chunks) ... DONE
[13:34:34.536] Reducing values from 1 chunks ...
[13:34:34.536]  - Number of values collected after concatenation: 2
[13:34:34.536]  - Number of values expected: 2
[13:34:34.536] Reducing values from 1 chunks ... DONE
[13:34:34.536] future_mapply() ... DONE
[13:34:34.536] future_mapply() ...
[13:34:34.536] Generating random seeds ...
[13:34:34.536] Generating random seed streams for 2 elements ...
[13:34:34.536] Generating random seed streams for 2 elements ... DONE
[13:34:34.536] Generating random seeds ... DONE
[13:34:34.537] Will set RNG state on exit: 10407, -1429551491, -62887963, -259804394, -54844326, -550334127, 123229225
[13:34:34.537] Number of chunks: 1
[13:34:34.537] getGlobalsAndPackagesXApply() ...
[13:34:34.537]  - future.globals: TRUE
[13:34:34.537] getGlobalsAndPackages() ...
[13:34:34.537] Searching for globals...
[13:34:34.538] - globals found: [1] ‘FUN’
[13:34:34.538] Searching for globals ... DONE
[13:34:34.538] Resolving globals: FALSE
[13:34:34.538] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[13:34:34.539] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[13:34:34.539] - globals: [1] ‘FUN’
[13:34:34.539] 
[13:34:34.539] getGlobalsAndPackages() ... DONE
[13:34:34.539]  - globals found/used: [n=1] ‘FUN’
[13:34:34.539]  - needed namespaces: [n=0] 
[13:34:34.539] Finding globals ... DONE
[13:34:34.539] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.539] List of 2
[13:34:34.539]  $ ...future.FUN:function (x, y)  
[13:34:34.539]  $ MoreArgs     :List of 1
[13:34:34.539]   ..$ y: int [1:2] 3 4
[13:34:34.539]  - attr(*, "where")=List of 2
[13:34:34.539]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.539]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.539]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.539]  - attr(*, "resolved")= logi FALSE
[13:34:34.539]  - attr(*, "total_size")= num NA
[13:34:34.543] Packages to be attached in all futures: [n=0] 
[13:34:34.543] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.543] Number of futures (= number of chunks): 1
[13:34:34.543] Launching 1 futures (chunks) ...
[13:34:34.543] Chunk #1 of 1 ...
[13:34:34.544]  - Finding globals in '...' for chunk #1 ...
[13:34:34.544] getGlobalsAndPackages() ...
[13:34:34.544] Searching for globals...
[13:34:34.544] 
[13:34:34.544] Searching for globals ... DONE
[13:34:34.544] - globals: [0] <none>
[13:34:34.544] getGlobalsAndPackages() ... DONE
[13:34:34.544]    + additional globals found: [n=0] 
[13:34:34.544]    + additional namespaces needed: [n=0] 
[13:34:34.544]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.545]  - seeds: [2] <seeds>
[13:34:34.545]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.545] getGlobalsAndPackages() ...
[13:34:34.545] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.545] Resolving globals: FALSE
[13:34:34.545] The total size of the 5 globals is 1.98 KiB (2032 bytes)
[13:34:34.546] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (160 bytes of class ‘list’) and ‘...future.elements_ii’ (112 bytes of class ‘list’)
[13:34:34.546] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.546] 
[13:34:34.546] getGlobalsAndPackages() ... DONE
[13:34:34.546] run() for ‘Future’ ...
[13:34:34.546] - state: ‘created’
[13:34:34.547] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.547] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.547] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.547]   - Field: ‘label’
[13:34:34.547]   - Field: ‘local’
[13:34:34.547]   - Field: ‘owner’
[13:34:34.547]   - Field: ‘envir’
[13:34:34.547]   - Field: ‘packages’
[13:34:34.547]   - Field: ‘gc’
[13:34:34.548]   - Field: ‘conditions’
[13:34:34.548]   - Field: ‘expr’
[13:34:34.548]   - Field: ‘uuid’
[13:34:34.548]   - Field: ‘seed’
[13:34:34.548]   - Field: ‘version’
[13:34:34.548]   - Field: ‘result’
[13:34:34.548]   - Field: ‘asynchronous’
[13:34:34.548]   - Field: ‘calls’
[13:34:34.548]   - Field: ‘globals’
[13:34:34.548]   - Field: ‘stdout’
[13:34:34.548]   - Field: ‘earlySignal’
[13:34:34.549]   - Field: ‘lazy’
[13:34:34.549]   - Field: ‘state’
[13:34:34.549] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.549] - Launch lazy future ...
[13:34:34.549] Packages needed by the future expression (n = 0): <none>
[13:34:34.549] Packages needed by future strategies (n = 0): <none>
[13:34:34.549] {
[13:34:34.549]     {
[13:34:34.549]         {
[13:34:34.549]             ...future.startTime <- base::Sys.time()
[13:34:34.549]             {
[13:34:34.549]                 {
[13:34:34.549]                   {
[13:34:34.549]                     base::local({
[13:34:34.549]                       has_future <- base::requireNamespace("future", 
[13:34:34.549]                         quietly = TRUE)
[13:34:34.549]                       if (has_future) {
[13:34:34.549]                         ns <- base::getNamespace("future")
[13:34:34.549]                         version <- ns[[".package"]][["version"]]
[13:34:34.549]                         if (is.null(version)) 
[13:34:34.549]                           version <- utils::packageVersion("future")
[13:34:34.549]                       }
[13:34:34.549]                       else {
[13:34:34.549]                         version <- NULL
[13:34:34.549]                       }
[13:34:34.549]                       if (!has_future || version < "1.8.0") {
[13:34:34.549]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.549]                           "", base::R.version$version.string), 
[13:34:34.549]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.549]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.549]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.549]                             "release", "version")], collapse = " "), 
[13:34:34.549]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.549]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.549]                           info)
[13:34:34.549]                         info <- base::paste(info, collapse = "; ")
[13:34:34.549]                         if (!has_future) {
[13:34:34.549]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.549]                             info)
[13:34:34.549]                         }
[13:34:34.549]                         else {
[13:34:34.549]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.549]                             info, version)
[13:34:34.549]                         }
[13:34:34.549]                         base::stop(msg)
[13:34:34.549]                       }
[13:34:34.549]                     })
[13:34:34.549]                   }
[13:34:34.549]                   ...future.strategy.old <- future::plan("list")
[13:34:34.549]                   options(future.plan = NULL)
[13:34:34.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.549]                 }
[13:34:34.549]                 ...future.workdir <- getwd()
[13:34:34.549]             }
[13:34:34.549]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.549]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.549]         }
[13:34:34.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.549]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.549]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.549]             base::names(...future.oldOptions))
[13:34:34.549]     }
[13:34:34.549]     if (FALSE) {
[13:34:34.549]     }
[13:34:34.549]     else {
[13:34:34.549]         if (TRUE) {
[13:34:34.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.549]                 open = "w")
[13:34:34.549]         }
[13:34:34.549]         else {
[13:34:34.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.549]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.549]         }
[13:34:34.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.549]             base::sink(type = "output", split = FALSE)
[13:34:34.549]             base::close(...future.stdout)
[13:34:34.549]         }, add = TRUE)
[13:34:34.549]     }
[13:34:34.549]     ...future.frame <- base::sys.nframe()
[13:34:34.549]     ...future.conditions <- base::list()
[13:34:34.549]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.549]     if (FALSE) {
[13:34:34.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.549]     }
[13:34:34.549]     ...future.result <- base::tryCatch({
[13:34:34.549]         base::withCallingHandlers({
[13:34:34.549]             ...future.value <- base::withVisible(base::local({
[13:34:34.549]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.549]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.549]                   ...future.globals.maxSize)) {
[13:34:34.549]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.549]                   on.exit(options(oopts), add = TRUE)
[13:34:34.549]                 }
[13:34:34.549]                 {
[13:34:34.549]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:34.549]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[13:34:34.549]                       envir = globalenv(), inherits = FALSE)
[13:34:34.549]                     ...future.FUN(...)
[13:34:34.549]                   }
[13:34:34.549]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:34.549]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:34.549]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.549]                     USE.NAMES = FALSE)
[13:34:34.549]                   do.call(mapply, args = args)
[13:34:34.549]                 }
[13:34:34.549]             }))
[13:34:34.549]             future::FutureResult(value = ...future.value$value, 
[13:34:34.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.549]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.549]                     ...future.globalenv.names))
[13:34:34.549]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.549]         }, condition = base::local({
[13:34:34.549]             c <- base::c
[13:34:34.549]             inherits <- base::inherits
[13:34:34.549]             invokeRestart <- base::invokeRestart
[13:34:34.549]             length <- base::length
[13:34:34.549]             list <- base::list
[13:34:34.549]             seq.int <- base::seq.int
[13:34:34.549]             signalCondition <- base::signalCondition
[13:34:34.549]             sys.calls <- base::sys.calls
[13:34:34.549]             `[[` <- base::`[[`
[13:34:34.549]             `+` <- base::`+`
[13:34:34.549]             `<<-` <- base::`<<-`
[13:34:34.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.549]                   3L)]
[13:34:34.549]             }
[13:34:34.549]             function(cond) {
[13:34:34.549]                 is_error <- inherits(cond, "error")
[13:34:34.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.549]                   NULL)
[13:34:34.549]                 if (is_error) {
[13:34:34.549]                   sessionInformation <- function() {
[13:34:34.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.549]                       search = base::search(), system = base::Sys.info())
[13:34:34.549]                   }
[13:34:34.549]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.549]                     cond$call), session = sessionInformation(), 
[13:34:34.549]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.549]                   signalCondition(cond)
[13:34:34.549]                 }
[13:34:34.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.549]                 "immediateCondition"))) {
[13:34:34.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.549]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.549]                   if (TRUE && !signal) {
[13:34:34.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.549]                     {
[13:34:34.549]                       inherits <- base::inherits
[13:34:34.549]                       invokeRestart <- base::invokeRestart
[13:34:34.549]                       is.null <- base::is.null
[13:34:34.549]                       muffled <- FALSE
[13:34:34.549]                       if (inherits(cond, "message")) {
[13:34:34.549]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.549]                         if (muffled) 
[13:34:34.549]                           invokeRestart("muffleMessage")
[13:34:34.549]                       }
[13:34:34.549]                       else if (inherits(cond, "warning")) {
[13:34:34.549]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.549]                         if (muffled) 
[13:34:34.549]                           invokeRestart("muffleWarning")
[13:34:34.549]                       }
[13:34:34.549]                       else if (inherits(cond, "condition")) {
[13:34:34.549]                         if (!is.null(pattern)) {
[13:34:34.549]                           computeRestarts <- base::computeRestarts
[13:34:34.549]                           grepl <- base::grepl
[13:34:34.549]                           restarts <- computeRestarts(cond)
[13:34:34.549]                           for (restart in restarts) {
[13:34:34.549]                             name <- restart$name
[13:34:34.549]                             if (is.null(name)) 
[13:34:34.549]                               next
[13:34:34.549]                             if (!grepl(pattern, name)) 
[13:34:34.549]                               next
[13:34:34.549]                             invokeRestart(restart)
[13:34:34.549]                             muffled <- TRUE
[13:34:34.549]                             break
[13:34:34.549]                           }
[13:34:34.549]                         }
[13:34:34.549]                       }
[13:34:34.549]                       invisible(muffled)
[13:34:34.549]                     }
[13:34:34.549]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.549]                   }
[13:34:34.549]                 }
[13:34:34.549]                 else {
[13:34:34.549]                   if (TRUE) {
[13:34:34.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.549]                     {
[13:34:34.549]                       inherits <- base::inherits
[13:34:34.549]                       invokeRestart <- base::invokeRestart
[13:34:34.549]                       is.null <- base::is.null
[13:34:34.549]                       muffled <- FALSE
[13:34:34.549]                       if (inherits(cond, "message")) {
[13:34:34.549]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.549]                         if (muffled) 
[13:34:34.549]                           invokeRestart("muffleMessage")
[13:34:34.549]                       }
[13:34:34.549]                       else if (inherits(cond, "warning")) {
[13:34:34.549]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.549]                         if (muffled) 
[13:34:34.549]                           invokeRestart("muffleWarning")
[13:34:34.549]                       }
[13:34:34.549]                       else if (inherits(cond, "condition")) {
[13:34:34.549]                         if (!is.null(pattern)) {
[13:34:34.549]                           computeRestarts <- base::computeRestarts
[13:34:34.549]                           grepl <- base::grepl
[13:34:34.549]                           restarts <- computeRestarts(cond)
[13:34:34.549]                           for (restart in restarts) {
[13:34:34.549]                             name <- restart$name
[13:34:34.549]                             if (is.null(name)) 
[13:34:34.549]                               next
[13:34:34.549]                             if (!grepl(pattern, name)) 
[13:34:34.549]                               next
[13:34:34.549]                             invokeRestart(restart)
[13:34:34.549]                             muffled <- TRUE
[13:34:34.549]                             break
[13:34:34.549]                           }
[13:34:34.549]                         }
[13:34:34.549]                       }
[13:34:34.549]                       invisible(muffled)
[13:34:34.549]                     }
[13:34:34.549]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.549]                   }
[13:34:34.549]                 }
[13:34:34.549]             }
[13:34:34.549]         }))
[13:34:34.549]     }, error = function(ex) {
[13:34:34.549]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.549]                 ...future.rng), started = ...future.startTime, 
[13:34:34.549]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.549]             version = "1.8"), class = "FutureResult")
[13:34:34.549]     }, finally = {
[13:34:34.549]         if (!identical(...future.workdir, getwd())) 
[13:34:34.549]             setwd(...future.workdir)
[13:34:34.549]         {
[13:34:34.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.549]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.549]             }
[13:34:34.549]             base::options(...future.oldOptions)
[13:34:34.549]             if (.Platform$OS.type == "windows") {
[13:34:34.549]                 old_names <- names(...future.oldEnvVars)
[13:34:34.549]                 envs <- base::Sys.getenv()
[13:34:34.549]                 names <- names(envs)
[13:34:34.549]                 common <- intersect(names, old_names)
[13:34:34.549]                 added <- setdiff(names, old_names)
[13:34:34.549]                 removed <- setdiff(old_names, names)
[13:34:34.549]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.549]                   envs[common]]
[13:34:34.549]                 NAMES <- toupper(changed)
[13:34:34.549]                 args <- list()
[13:34:34.549]                 for (kk in seq_along(NAMES)) {
[13:34:34.549]                   name <- changed[[kk]]
[13:34:34.549]                   NAME <- NAMES[[kk]]
[13:34:34.549]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.549]                     next
[13:34:34.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.549]                 }
[13:34:34.549]                 NAMES <- toupper(added)
[13:34:34.549]                 for (kk in seq_along(NAMES)) {
[13:34:34.549]                   name <- added[[kk]]
[13:34:34.549]                   NAME <- NAMES[[kk]]
[13:34:34.549]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.549]                     next
[13:34:34.549]                   args[[name]] <- ""
[13:34:34.549]                 }
[13:34:34.549]                 NAMES <- toupper(removed)
[13:34:34.549]                 for (kk in seq_along(NAMES)) {
[13:34:34.549]                   name <- removed[[kk]]
[13:34:34.549]                   NAME <- NAMES[[kk]]
[13:34:34.549]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.549]                     next
[13:34:34.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.549]                 }
[13:34:34.549]                 if (length(args) > 0) 
[13:34:34.549]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.549]             }
[13:34:34.549]             else {
[13:34:34.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.549]             }
[13:34:34.549]             {
[13:34:34.549]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.549]                   0L) {
[13:34:34.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.549]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.549]                   base::options(opts)
[13:34:34.549]                 }
[13:34:34.549]                 {
[13:34:34.549]                   {
[13:34:34.549]                     base::assign(".Random.seed", c(10407L, -1429551491L, 
[13:34:34.549]                     -62887963L, -259804394L, -54844326L, -550334127L, 
[13:34:34.549]                     123229225L), envir = base::globalenv(), inherits = FALSE)
[13:34:34.549]                     NULL
[13:34:34.549]                   }
[13:34:34.549]                   options(future.plan = NULL)
[13:34:34.549]                   if (is.na(NA_character_)) 
[13:34:34.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.549]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.549]                     .init = FALSE)
[13:34:34.549]                 }
[13:34:34.549]             }
[13:34:34.549]         }
[13:34:34.549]     })
[13:34:34.549]     if (TRUE) {
[13:34:34.549]         base::sink(type = "output", split = FALSE)
[13:34:34.549]         if (TRUE) {
[13:34:34.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.549]         }
[13:34:34.549]         else {
[13:34:34.549]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.549]         }
[13:34:34.549]         base::close(...future.stdout)
[13:34:34.549]         ...future.stdout <- NULL
[13:34:34.549]     }
[13:34:34.549]     ...future.result$conditions <- ...future.conditions
[13:34:34.549]     ...future.result$finished <- base::Sys.time()
[13:34:34.549]     ...future.result
[13:34:34.549] }
[13:34:34.551] assign_globals() ...
[13:34:34.551] List of 5
[13:34:34.551]  $ ...future.FUN            :function (x, y)  
[13:34:34.551]  $ MoreArgs                 :List of 1
[13:34:34.551]   ..$ y: int [1:2] 3 4
[13:34:34.551]  $ ...future.elements_ii    :List of 1
[13:34:34.551]   ..$ x:List of 2
[13:34:34.551]   .. ..$ : int 1
[13:34:34.551]   .. ..$ : int 2
[13:34:34.551]  $ ...future.seeds_ii       :List of 2
[13:34:34.551]   ..$ : int [1:7] 10407 -1313291004 2129487204 -344679654 1499251996 1801297802 1656987369
[13:34:34.551]   ..$ : int [1:7] 10407 2135973824 1564573503 -1734848048 -309699922 -2129118240 -1136270902
[13:34:34.551]  $ ...future.globals.maxSize: NULL
[13:34:34.551]  - attr(*, "where")=List of 5
[13:34:34.551]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.551]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.551]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.551]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.551]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.551]  - attr(*, "resolved")= logi FALSE
[13:34:34.551]  - attr(*, "total_size")= num 2032
[13:34:34.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.551]  - attr(*, "already-done")= logi TRUE
[13:34:34.556] - reassign environment for ‘...future.FUN’
[13:34:34.556] - copied ‘...future.FUN’ to environment
[13:34:34.557] - copied ‘MoreArgs’ to environment
[13:34:34.557] - copied ‘...future.elements_ii’ to environment
[13:34:34.557] - copied ‘...future.seeds_ii’ to environment
[13:34:34.557] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.557] assign_globals() ... done
[13:34:34.557] plan(): Setting new future strategy stack:
[13:34:34.557] List of future strategies:
[13:34:34.557] 1. sequential:
[13:34:34.557]    - args: function (..., envir = parent.frame())
[13:34:34.557]    - tweaked: FALSE
[13:34:34.557]    - call: NULL
[13:34:34.557] plan(): nbrOfWorkers() = 1
[13:34:34.558] plan(): Setting new future strategy stack:
[13:34:34.558] List of future strategies:
[13:34:34.558] 1. sequential:
[13:34:34.558]    - args: function (..., envir = parent.frame())
[13:34:34.558]    - tweaked: FALSE
[13:34:34.558]    - call: plan(strategy)
[13:34:34.559] plan(): nbrOfWorkers() = 1
[13:34:34.559] SequentialFuture started (and completed)
[13:34:34.559] - Launch lazy future ... done
[13:34:34.559] run() for ‘SequentialFuture’ ... done
[13:34:34.559] Created future:
[13:34:34.559] SequentialFuture:
[13:34:34.559] Label: ‘future_mapply-1’
[13:34:34.559] Expression:
[13:34:34.559] {
[13:34:34.559]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.559]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.559]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.559]         on.exit(options(oopts), add = TRUE)
[13:34:34.559]     }
[13:34:34.559]     {
[13:34:34.559]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:34.559]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[13:34:34.559]                 inherits = FALSE)
[13:34:34.559]             ...future.FUN(...)
[13:34:34.559]         }
[13:34:34.559]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:34.559]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:34.559]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.559]         do.call(mapply, args = args)
[13:34:34.559]     }
[13:34:34.559] }
[13:34:34.559] Lazy evaluation: FALSE
[13:34:34.559] Asynchronous evaluation: FALSE
[13:34:34.559] Local evaluation: TRUE
[13:34:34.559] Environment: R_GlobalEnv
[13:34:34.559] Capture standard output: TRUE
[13:34:34.559] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.559] Globals: 5 objects totaling 1.98 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.559] Packages: <none>
[13:34:34.559] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:34:34.559] Resolved: TRUE
[13:34:34.559] Value: 112 bytes of class ‘list’
[13:34:34.559] Early signaling: FALSE
[13:34:34.559] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.559] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.560] Chunk #1 of 1 ... DONE
[13:34:34.560] Launching 1 futures (chunks) ... DONE
[13:34:34.560] Resolving 1 futures (chunks) ...
[13:34:34.560] resolve() on list ...
[13:34:34.560]  recursive: 0
[13:34:34.560]  length: 1
[13:34:34.560] 
[13:34:34.561] resolved() for ‘SequentialFuture’ ...
[13:34:34.561] - state: ‘finished’
[13:34:34.561] - run: TRUE
[13:34:34.561] - result: ‘FutureResult’
[13:34:34.561] resolved() for ‘SequentialFuture’ ... done
[13:34:34.561] Future #1
[13:34:34.561] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.561] - nx: 1
[13:34:34.561] - relay: TRUE
[13:34:34.561] - stdout: TRUE
[13:34:34.561] - signal: TRUE
[13:34:34.562] - resignal: FALSE
[13:34:34.562] - force: TRUE
[13:34:34.562] - relayed: [n=1] FALSE
[13:34:34.562] - queued futures: [n=1] FALSE
[13:34:34.562]  - until=1
[13:34:34.562]  - relaying element #1
[13:34:34.562] - relayed: [n=1] TRUE
[13:34:34.562] - queued futures: [n=1] TRUE
[13:34:34.563] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.563]  length: 0 (resolved future 1)
[13:34:34.563] Relaying remaining futures
[13:34:34.563] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.564] - nx: 1
[13:34:34.564] - relay: TRUE
[13:34:34.564] - stdout: TRUE
[13:34:34.564] - signal: TRUE
[13:34:34.564] - resignal: FALSE
[13:34:34.564] - force: TRUE
[13:34:34.564] - relayed: [n=1] TRUE
[13:34:34.564] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.564] - relayed: [n=1] TRUE
[13:34:34.564] - queued futures: [n=1] TRUE
[13:34:34.564] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.565] resolve() on list ... DONE
[13:34:34.565]  - Number of value chunks collected: 1
[13:34:34.565] Resolving 1 futures (chunks) ... DONE
[13:34:34.565] Reducing values from 1 chunks ...
[13:34:34.565]  - Number of values collected after concatenation: 2
[13:34:34.565]  - Number of values expected: 2
[13:34:34.565] Reducing values from 1 chunks ... DONE
[13:34:34.565] future_mapply() ... DONE
[13:34:34.565] future_mapply() ...
[13:34:34.565] Number of chunks: 1
[13:34:34.566] getGlobalsAndPackagesXApply() ...
[13:34:34.566]  - future.globals: TRUE
[13:34:34.566] getGlobalsAndPackages() ...
[13:34:34.566] Searching for globals...
[13:34:34.567] - globals found: [1] ‘FUN’
[13:34:34.567] Searching for globals ... DONE
[13:34:34.567] Resolving globals: FALSE
[13:34:34.567] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[13:34:34.567] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[13:34:34.568] - globals: [1] ‘FUN’
[13:34:34.568] 
[13:34:34.568] getGlobalsAndPackages() ... DONE
[13:34:34.568]  - globals found/used: [n=1] ‘FUN’
[13:34:34.568]  - needed namespaces: [n=0] 
[13:34:34.568] Finding globals ... DONE
[13:34:34.568] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.568] List of 2
[13:34:34.568]  $ ...future.FUN:function (x, y)  
[13:34:34.568]  $ MoreArgs     :List of 1
[13:34:34.568]   ..$ y: int [1:2] 3 4
[13:34:34.568]  - attr(*, "where")=List of 2
[13:34:34.568]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.568]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.568]  - attr(*, "resolved")= logi FALSE
[13:34:34.568]  - attr(*, "total_size")= num NA
[13:34:34.571] Packages to be attached in all futures: [n=0] 
[13:34:34.571] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.571] Number of futures (= number of chunks): 1
[13:34:34.571] Launching 1 futures (chunks) ...
[13:34:34.571] Chunk #1 of 1 ...
[13:34:34.571]  - Finding globals in '...' for chunk #1 ...
[13:34:34.571] getGlobalsAndPackages() ...
[13:34:34.572] Searching for globals...
[13:34:34.572] 
[13:34:34.572] Searching for globals ... DONE
[13:34:34.572] - globals: [0] <none>
[13:34:34.572] getGlobalsAndPackages() ... DONE
[13:34:34.572]    + additional globals found: [n=0] 
[13:34:34.572]    + additional namespaces needed: [n=0] 
[13:34:34.572]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.572]  - seeds: <none>
[13:34:34.572]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.573] getGlobalsAndPackages() ...
[13:34:34.573] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.573] Resolving globals: FALSE
[13:34:34.573] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[13:34:34.574] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[13:34:34.574] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.574] 
[13:34:34.574] getGlobalsAndPackages() ... DONE
[13:34:34.574] run() for ‘Future’ ...
[13:34:34.574] - state: ‘created’
[13:34:34.574] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.575] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.575] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.575]   - Field: ‘label’
[13:34:34.575]   - Field: ‘local’
[13:34:34.575]   - Field: ‘owner’
[13:34:34.575]   - Field: ‘envir’
[13:34:34.575]   - Field: ‘packages’
[13:34:34.575]   - Field: ‘gc’
[13:34:34.575]   - Field: ‘conditions’
[13:34:34.575]   - Field: ‘expr’
[13:34:34.575]   - Field: ‘uuid’
[13:34:34.576]   - Field: ‘seed’
[13:34:34.576]   - Field: ‘version’
[13:34:34.576]   - Field: ‘result’
[13:34:34.576]   - Field: ‘asynchronous’
[13:34:34.576]   - Field: ‘calls’
[13:34:34.576]   - Field: ‘globals’
[13:34:34.576]   - Field: ‘stdout’
[13:34:34.576]   - Field: ‘earlySignal’
[13:34:34.576]   - Field: ‘lazy’
[13:34:34.576]   - Field: ‘state’
[13:34:34.576] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.576] - Launch lazy future ...
[13:34:34.577] Packages needed by the future expression (n = 0): <none>
[13:34:34.577] Packages needed by future strategies (n = 0): <none>
[13:34:34.577] {
[13:34:34.577]     {
[13:34:34.577]         {
[13:34:34.577]             ...future.startTime <- base::Sys.time()
[13:34:34.577]             {
[13:34:34.577]                 {
[13:34:34.577]                   {
[13:34:34.577]                     base::local({
[13:34:34.577]                       has_future <- base::requireNamespace("future", 
[13:34:34.577]                         quietly = TRUE)
[13:34:34.577]                       if (has_future) {
[13:34:34.577]                         ns <- base::getNamespace("future")
[13:34:34.577]                         version <- ns[[".package"]][["version"]]
[13:34:34.577]                         if (is.null(version)) 
[13:34:34.577]                           version <- utils::packageVersion("future")
[13:34:34.577]                       }
[13:34:34.577]                       else {
[13:34:34.577]                         version <- NULL
[13:34:34.577]                       }
[13:34:34.577]                       if (!has_future || version < "1.8.0") {
[13:34:34.577]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.577]                           "", base::R.version$version.string), 
[13:34:34.577]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.577]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.577]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.577]                             "release", "version")], collapse = " "), 
[13:34:34.577]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.577]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.577]                           info)
[13:34:34.577]                         info <- base::paste(info, collapse = "; ")
[13:34:34.577]                         if (!has_future) {
[13:34:34.577]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.577]                             info)
[13:34:34.577]                         }
[13:34:34.577]                         else {
[13:34:34.577]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.577]                             info, version)
[13:34:34.577]                         }
[13:34:34.577]                         base::stop(msg)
[13:34:34.577]                       }
[13:34:34.577]                     })
[13:34:34.577]                   }
[13:34:34.577]                   ...future.strategy.old <- future::plan("list")
[13:34:34.577]                   options(future.plan = NULL)
[13:34:34.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.577]                 }
[13:34:34.577]                 ...future.workdir <- getwd()
[13:34:34.577]             }
[13:34:34.577]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.577]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.577]         }
[13:34:34.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.577]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.577]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.577]             base::names(...future.oldOptions))
[13:34:34.577]     }
[13:34:34.577]     if (FALSE) {
[13:34:34.577]     }
[13:34:34.577]     else {
[13:34:34.577]         if (TRUE) {
[13:34:34.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.577]                 open = "w")
[13:34:34.577]         }
[13:34:34.577]         else {
[13:34:34.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.577]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.577]         }
[13:34:34.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.577]             base::sink(type = "output", split = FALSE)
[13:34:34.577]             base::close(...future.stdout)
[13:34:34.577]         }, add = TRUE)
[13:34:34.577]     }
[13:34:34.577]     ...future.frame <- base::sys.nframe()
[13:34:34.577]     ...future.conditions <- base::list()
[13:34:34.577]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.577]     if (FALSE) {
[13:34:34.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.577]     }
[13:34:34.577]     ...future.result <- base::tryCatch({
[13:34:34.577]         base::withCallingHandlers({
[13:34:34.577]             ...future.value <- base::withVisible(base::local({
[13:34:34.577]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.577]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.577]                   ...future.globals.maxSize)) {
[13:34:34.577]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.577]                   on.exit(options(oopts), add = TRUE)
[13:34:34.577]                 }
[13:34:34.577]                 {
[13:34:34.577]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.577]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.577]                     USE.NAMES = FALSE)
[13:34:34.577]                   do.call(mapply, args = args)
[13:34:34.577]                 }
[13:34:34.577]             }))
[13:34:34.577]             future::FutureResult(value = ...future.value$value, 
[13:34:34.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.577]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.577]                     ...future.globalenv.names))
[13:34:34.577]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.577]         }, condition = base::local({
[13:34:34.577]             c <- base::c
[13:34:34.577]             inherits <- base::inherits
[13:34:34.577]             invokeRestart <- base::invokeRestart
[13:34:34.577]             length <- base::length
[13:34:34.577]             list <- base::list
[13:34:34.577]             seq.int <- base::seq.int
[13:34:34.577]             signalCondition <- base::signalCondition
[13:34:34.577]             sys.calls <- base::sys.calls
[13:34:34.577]             `[[` <- base::`[[`
[13:34:34.577]             `+` <- base::`+`
[13:34:34.577]             `<<-` <- base::`<<-`
[13:34:34.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.577]                   3L)]
[13:34:34.577]             }
[13:34:34.577]             function(cond) {
[13:34:34.577]                 is_error <- inherits(cond, "error")
[13:34:34.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.577]                   NULL)
[13:34:34.577]                 if (is_error) {
[13:34:34.577]                   sessionInformation <- function() {
[13:34:34.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.577]                       search = base::search(), system = base::Sys.info())
[13:34:34.577]                   }
[13:34:34.577]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.577]                     cond$call), session = sessionInformation(), 
[13:34:34.577]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.577]                   signalCondition(cond)
[13:34:34.577]                 }
[13:34:34.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.577]                 "immediateCondition"))) {
[13:34:34.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.577]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.577]                   if (TRUE && !signal) {
[13:34:34.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.577]                     {
[13:34:34.577]                       inherits <- base::inherits
[13:34:34.577]                       invokeRestart <- base::invokeRestart
[13:34:34.577]                       is.null <- base::is.null
[13:34:34.577]                       muffled <- FALSE
[13:34:34.577]                       if (inherits(cond, "message")) {
[13:34:34.577]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.577]                         if (muffled) 
[13:34:34.577]                           invokeRestart("muffleMessage")
[13:34:34.577]                       }
[13:34:34.577]                       else if (inherits(cond, "warning")) {
[13:34:34.577]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.577]                         if (muffled) 
[13:34:34.577]                           invokeRestart("muffleWarning")
[13:34:34.577]                       }
[13:34:34.577]                       else if (inherits(cond, "condition")) {
[13:34:34.577]                         if (!is.null(pattern)) {
[13:34:34.577]                           computeRestarts <- base::computeRestarts
[13:34:34.577]                           grepl <- base::grepl
[13:34:34.577]                           restarts <- computeRestarts(cond)
[13:34:34.577]                           for (restart in restarts) {
[13:34:34.577]                             name <- restart$name
[13:34:34.577]                             if (is.null(name)) 
[13:34:34.577]                               next
[13:34:34.577]                             if (!grepl(pattern, name)) 
[13:34:34.577]                               next
[13:34:34.577]                             invokeRestart(restart)
[13:34:34.577]                             muffled <- TRUE
[13:34:34.577]                             break
[13:34:34.577]                           }
[13:34:34.577]                         }
[13:34:34.577]                       }
[13:34:34.577]                       invisible(muffled)
[13:34:34.577]                     }
[13:34:34.577]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.577]                   }
[13:34:34.577]                 }
[13:34:34.577]                 else {
[13:34:34.577]                   if (TRUE) {
[13:34:34.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.577]                     {
[13:34:34.577]                       inherits <- base::inherits
[13:34:34.577]                       invokeRestart <- base::invokeRestart
[13:34:34.577]                       is.null <- base::is.null
[13:34:34.577]                       muffled <- FALSE
[13:34:34.577]                       if (inherits(cond, "message")) {
[13:34:34.577]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.577]                         if (muffled) 
[13:34:34.577]                           invokeRestart("muffleMessage")
[13:34:34.577]                       }
[13:34:34.577]                       else if (inherits(cond, "warning")) {
[13:34:34.577]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.577]                         if (muffled) 
[13:34:34.577]                           invokeRestart("muffleWarning")
[13:34:34.577]                       }
[13:34:34.577]                       else if (inherits(cond, "condition")) {
[13:34:34.577]                         if (!is.null(pattern)) {
[13:34:34.577]                           computeRestarts <- base::computeRestarts
[13:34:34.577]                           grepl <- base::grepl
[13:34:34.577]                           restarts <- computeRestarts(cond)
[13:34:34.577]                           for (restart in restarts) {
[13:34:34.577]                             name <- restart$name
[13:34:34.577]                             if (is.null(name)) 
[13:34:34.577]                               next
[13:34:34.577]                             if (!grepl(pattern, name)) 
[13:34:34.577]                               next
[13:34:34.577]                             invokeRestart(restart)
[13:34:34.577]                             muffled <- TRUE
[13:34:34.577]                             break
[13:34:34.577]                           }
[13:34:34.577]                         }
[13:34:34.577]                       }
[13:34:34.577]                       invisible(muffled)
[13:34:34.577]                     }
[13:34:34.577]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.577]                   }
[13:34:34.577]                 }
[13:34:34.577]             }
[13:34:34.577]         }))
[13:34:34.577]     }, error = function(ex) {
[13:34:34.577]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.577]                 ...future.rng), started = ...future.startTime, 
[13:34:34.577]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.577]             version = "1.8"), class = "FutureResult")
[13:34:34.577]     }, finally = {
[13:34:34.577]         if (!identical(...future.workdir, getwd())) 
[13:34:34.577]             setwd(...future.workdir)
[13:34:34.577]         {
[13:34:34.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.577]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.577]             }
[13:34:34.577]             base::options(...future.oldOptions)
[13:34:34.577]             if (.Platform$OS.type == "windows") {
[13:34:34.577]                 old_names <- names(...future.oldEnvVars)
[13:34:34.577]                 envs <- base::Sys.getenv()
[13:34:34.577]                 names <- names(envs)
[13:34:34.577]                 common <- intersect(names, old_names)
[13:34:34.577]                 added <- setdiff(names, old_names)
[13:34:34.577]                 removed <- setdiff(old_names, names)
[13:34:34.577]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.577]                   envs[common]]
[13:34:34.577]                 NAMES <- toupper(changed)
[13:34:34.577]                 args <- list()
[13:34:34.577]                 for (kk in seq_along(NAMES)) {
[13:34:34.577]                   name <- changed[[kk]]
[13:34:34.577]                   NAME <- NAMES[[kk]]
[13:34:34.577]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.577]                     next
[13:34:34.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.577]                 }
[13:34:34.577]                 NAMES <- toupper(added)
[13:34:34.577]                 for (kk in seq_along(NAMES)) {
[13:34:34.577]                   name <- added[[kk]]
[13:34:34.577]                   NAME <- NAMES[[kk]]
[13:34:34.577]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.577]                     next
[13:34:34.577]                   args[[name]] <- ""
[13:34:34.577]                 }
[13:34:34.577]                 NAMES <- toupper(removed)
[13:34:34.577]                 for (kk in seq_along(NAMES)) {
[13:34:34.577]                   name <- removed[[kk]]
[13:34:34.577]                   NAME <- NAMES[[kk]]
[13:34:34.577]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.577]                     next
[13:34:34.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.577]                 }
[13:34:34.577]                 if (length(args) > 0) 
[13:34:34.577]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.577]             }
[13:34:34.577]             else {
[13:34:34.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.577]             }
[13:34:34.577]             {
[13:34:34.577]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.577]                   0L) {
[13:34:34.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.577]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.577]                   base::options(opts)
[13:34:34.577]                 }
[13:34:34.577]                 {
[13:34:34.577]                   {
[13:34:34.577]                     base::assign(".Random.seed", c(10407L, -1429551491L, 
[13:34:34.577]                     -62887963L, -259804394L, -54844326L, -550334127L, 
[13:34:34.577]                     123229225L), envir = base::globalenv(), inherits = FALSE)
[13:34:34.577]                     NULL
[13:34:34.577]                   }
[13:34:34.577]                   options(future.plan = NULL)
[13:34:34.577]                   if (is.na(NA_character_)) 
[13:34:34.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.577]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.577]                     .init = FALSE)
[13:34:34.577]                 }
[13:34:34.577]             }
[13:34:34.577]         }
[13:34:34.577]     })
[13:34:34.577]     if (TRUE) {
[13:34:34.577]         base::sink(type = "output", split = FALSE)
[13:34:34.577]         if (TRUE) {
[13:34:34.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.577]         }
[13:34:34.577]         else {
[13:34:34.577]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.577]         }
[13:34:34.577]         base::close(...future.stdout)
[13:34:34.577]         ...future.stdout <- NULL
[13:34:34.577]     }
[13:34:34.577]     ...future.result$conditions <- ...future.conditions
[13:34:34.577]     ...future.result$finished <- base::Sys.time()
[13:34:34.577]     ...future.result
[13:34:34.577] }
[13:34:34.579] assign_globals() ...
[13:34:34.579] List of 5
[13:34:34.579]  $ ...future.FUN            :function (x, y)  
[13:34:34.579]  $ MoreArgs                 :List of 1
[13:34:34.579]   ..$ y: int [1:2] 3 4
[13:34:34.579]  $ ...future.elements_ii    :List of 1
[13:34:34.579]   ..$ x:List of 2
[13:34:34.579]   .. ..$ : int 1
[13:34:34.579]   .. ..$ : int 2
[13:34:34.579]  $ ...future.seeds_ii       : NULL
[13:34:34.579]  $ ...future.globals.maxSize: NULL
[13:34:34.579]  - attr(*, "where")=List of 5
[13:34:34.579]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.579]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.579]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.579]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.579]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.579]  - attr(*, "resolved")= logi FALSE
[13:34:34.579]  - attr(*, "total_size")= num 1872
[13:34:34.579]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.579]  - attr(*, "already-done")= logi TRUE
[13:34:34.584] - reassign environment for ‘...future.FUN’
[13:34:34.585] - copied ‘...future.FUN’ to environment
[13:34:34.585] - copied ‘MoreArgs’ to environment
[13:34:34.585] - copied ‘...future.elements_ii’ to environment
[13:34:34.585] - copied ‘...future.seeds_ii’ to environment
[13:34:34.585] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.585] assign_globals() ... done
[13:34:34.585] plan(): Setting new future strategy stack:
[13:34:34.585] List of future strategies:
[13:34:34.585] 1. sequential:
[13:34:34.585]    - args: function (..., envir = parent.frame())
[13:34:34.585]    - tweaked: FALSE
[13:34:34.585]    - call: NULL
[13:34:34.586] plan(): nbrOfWorkers() = 1
[13:34:34.586] plan(): Setting new future strategy stack:
[13:34:34.586] List of future strategies:
[13:34:34.586] 1. sequential:
[13:34:34.586]    - args: function (..., envir = parent.frame())
[13:34:34.586]    - tweaked: FALSE
[13:34:34.586]    - call: plan(strategy)
[13:34:34.587] plan(): nbrOfWorkers() = 1
[13:34:34.587] SequentialFuture started (and completed)
[13:34:34.587] - Launch lazy future ... done
[13:34:34.587] run() for ‘SequentialFuture’ ... done
[13:34:34.587] Created future:
[13:34:34.587] SequentialFuture:
[13:34:34.587] Label: ‘future_.mapply-1’
[13:34:34.587] Expression:
[13:34:34.587] {
[13:34:34.587]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.587]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.587]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.587]         on.exit(options(oopts), add = TRUE)
[13:34:34.587]     }
[13:34:34.587]     {
[13:34:34.587]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.587]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.587]         do.call(mapply, args = args)
[13:34:34.587]     }
[13:34:34.587] }
[13:34:34.587] Lazy evaluation: FALSE
[13:34:34.587] Asynchronous evaluation: FALSE
[13:34:34.587] Local evaluation: TRUE
[13:34:34.587] Environment: R_GlobalEnv
[13:34:34.587] Capture standard output: TRUE
[13:34:34.587] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.587] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.587] Packages: <none>
[13:34:34.587] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.587] Resolved: TRUE
[13:34:34.587] Value: 112 bytes of class ‘list’
[13:34:34.587] Early signaling: FALSE
[13:34:34.587] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.587] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.588] Chunk #1 of 1 ... DONE
[13:34:34.588] Launching 1 futures (chunks) ... DONE
[13:34:34.588] Resolving 1 futures (chunks) ...
[13:34:34.588] resolve() on list ...
[13:34:34.588]  recursive: 0
[13:34:34.589]  length: 1
[13:34:34.589] 
[13:34:34.589] resolved() for ‘SequentialFuture’ ...
[13:34:34.589] - state: ‘finished’
[13:34:34.589] - run: TRUE
[13:34:34.589] - result: ‘FutureResult’
[13:34:34.589] resolved() for ‘SequentialFuture’ ... done
[13:34:34.589] Future #1
[13:34:34.589] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.589] - nx: 1
[13:34:34.589] - relay: TRUE
[13:34:34.590] - stdout: TRUE
[13:34:34.590] - signal: TRUE
[13:34:34.590] - resignal: FALSE
[13:34:34.590] - force: TRUE
[13:34:34.590] - relayed: [n=1] FALSE
[13:34:34.590] - queued futures: [n=1] FALSE
[13:34:34.590]  - until=1
[13:34:34.590]  - relaying element #1
[13:34:34.590] - relayed: [n=1] TRUE
[13:34:34.590] - queued futures: [n=1] TRUE
[13:34:34.590] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.591]  length: 0 (resolved future 1)
[13:34:34.591] Relaying remaining futures
[13:34:34.591] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.591] - nx: 1
[13:34:34.591] - relay: TRUE
[13:34:34.591] - stdout: TRUE
[13:34:34.591] - signal: TRUE
[13:34:34.591] - resignal: FALSE
[13:34:34.591] - force: TRUE
[13:34:34.591] - relayed: [n=1] TRUE
[13:34:34.591] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.591] - relayed: [n=1] TRUE
[13:34:34.592] - queued futures: [n=1] TRUE
[13:34:34.592] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.592] resolve() on list ... DONE
[13:34:34.592]  - Number of value chunks collected: 1
[13:34:34.592] Resolving 1 futures (chunks) ... DONE
[13:34:34.592] Reducing values from 1 chunks ...
[13:34:34.592]  - Number of values collected after concatenation: 2
[13:34:34.592]  - Number of values expected: 2
[13:34:34.592] Reducing values from 1 chunks ... DONE
[13:34:34.592] future_mapply() ... DONE
- Recycle arguments to same length ...
[13:34:34.593] future_mapply() ...
[13:34:34.593] Number of chunks: 1
[13:34:34.593] getGlobalsAndPackagesXApply() ...
[13:34:34.593]  - future.globals: TRUE
[13:34:34.593] getGlobalsAndPackages() ...
[13:34:34.593] Searching for globals...
[13:34:34.594] - globals found: [1] ‘FUN’
[13:34:34.594] Searching for globals ... DONE
[13:34:34.594] Resolving globals: FALSE
[13:34:34.594] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:34.594] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:34.594] - globals: [1] ‘FUN’
[13:34:34.595] 
[13:34:34.595] getGlobalsAndPackages() ... DONE
[13:34:34.595]  - globals found/used: [n=1] ‘FUN’
[13:34:34.595]  - needed namespaces: [n=0] 
[13:34:34.595] Finding globals ... DONE
[13:34:34.595] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.595] List of 2
[13:34:34.595]  $ ...future.FUN:function (x, ...)  
[13:34:34.595]  $ MoreArgs     : NULL
[13:34:34.595]  - attr(*, "where")=List of 2
[13:34:34.595]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.595]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.595]  - attr(*, "resolved")= logi FALSE
[13:34:34.595]  - attr(*, "total_size")= num NA
[13:34:34.598] Packages to be attached in all futures: [n=0] 
[13:34:34.598] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.598] Number of futures (= number of chunks): 1
[13:34:34.598] Launching 1 futures (chunks) ...
[13:34:34.598] Chunk #1 of 1 ...
[13:34:34.598]  - Finding globals in '...' for chunk #1 ...
[13:34:34.598] getGlobalsAndPackages() ...
[13:34:34.598] Searching for globals...
[13:34:34.599] 
[13:34:34.599] Searching for globals ... DONE
[13:34:34.599] - globals: [0] <none>
[13:34:34.599] getGlobalsAndPackages() ... DONE
[13:34:34.599]    + additional globals found: [n=0] 
[13:34:34.599]    + additional namespaces needed: [n=0] 
[13:34:34.599]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.599]  - seeds: <none>
[13:34:34.599]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.600] getGlobalsAndPackages() ...
[13:34:34.600] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.600] Resolving globals: FALSE
[13:34:34.600] The total size of the 5 globals is 504 bytes (504 bytes)
[13:34:34.601] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.601] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.601] 
[13:34:34.601] getGlobalsAndPackages() ... DONE
[13:34:34.601] run() for ‘Future’ ...
[13:34:34.601] - state: ‘created’
[13:34:34.601] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.602] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.602] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.602]   - Field: ‘label’
[13:34:34.602]   - Field: ‘local’
[13:34:34.602]   - Field: ‘owner’
[13:34:34.602]   - Field: ‘envir’
[13:34:34.602]   - Field: ‘packages’
[13:34:34.602]   - Field: ‘gc’
[13:34:34.602]   - Field: ‘conditions’
[13:34:34.603]   - Field: ‘expr’
[13:34:34.603]   - Field: ‘uuid’
[13:34:34.603]   - Field: ‘seed’
[13:34:34.604]   - Field: ‘version’
[13:34:34.605]   - Field: ‘result’
[13:34:34.605]   - Field: ‘asynchronous’
[13:34:34.605]   - Field: ‘calls’
[13:34:34.605]   - Field: ‘globals’
[13:34:34.605]   - Field: ‘stdout’
[13:34:34.605]   - Field: ‘earlySignal’
[13:34:34.605]   - Field: ‘lazy’
[13:34:34.605]   - Field: ‘state’
[13:34:34.605] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.606] - Launch lazy future ...
[13:34:34.606] Packages needed by the future expression (n = 0): <none>
[13:34:34.606] Packages needed by future strategies (n = 0): <none>
[13:34:34.606] {
[13:34:34.606]     {
[13:34:34.606]         {
[13:34:34.606]             ...future.startTime <- base::Sys.time()
[13:34:34.606]             {
[13:34:34.606]                 {
[13:34:34.606]                   {
[13:34:34.606]                     base::local({
[13:34:34.606]                       has_future <- base::requireNamespace("future", 
[13:34:34.606]                         quietly = TRUE)
[13:34:34.606]                       if (has_future) {
[13:34:34.606]                         ns <- base::getNamespace("future")
[13:34:34.606]                         version <- ns[[".package"]][["version"]]
[13:34:34.606]                         if (is.null(version)) 
[13:34:34.606]                           version <- utils::packageVersion("future")
[13:34:34.606]                       }
[13:34:34.606]                       else {
[13:34:34.606]                         version <- NULL
[13:34:34.606]                       }
[13:34:34.606]                       if (!has_future || version < "1.8.0") {
[13:34:34.606]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.606]                           "", base::R.version$version.string), 
[13:34:34.606]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.606]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.606]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.606]                             "release", "version")], collapse = " "), 
[13:34:34.606]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.606]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.606]                           info)
[13:34:34.606]                         info <- base::paste(info, collapse = "; ")
[13:34:34.606]                         if (!has_future) {
[13:34:34.606]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.606]                             info)
[13:34:34.606]                         }
[13:34:34.606]                         else {
[13:34:34.606]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.606]                             info, version)
[13:34:34.606]                         }
[13:34:34.606]                         base::stop(msg)
[13:34:34.606]                       }
[13:34:34.606]                     })
[13:34:34.606]                   }
[13:34:34.606]                   ...future.strategy.old <- future::plan("list")
[13:34:34.606]                   options(future.plan = NULL)
[13:34:34.606]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.606]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.606]                 }
[13:34:34.606]                 ...future.workdir <- getwd()
[13:34:34.606]             }
[13:34:34.606]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.606]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.606]         }
[13:34:34.606]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.606]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.606]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.606]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.606]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.606]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.606]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.606]             base::names(...future.oldOptions))
[13:34:34.606]     }
[13:34:34.606]     if (FALSE) {
[13:34:34.606]     }
[13:34:34.606]     else {
[13:34:34.606]         if (TRUE) {
[13:34:34.606]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.606]                 open = "w")
[13:34:34.606]         }
[13:34:34.606]         else {
[13:34:34.606]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.606]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.606]         }
[13:34:34.606]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.606]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.606]             base::sink(type = "output", split = FALSE)
[13:34:34.606]             base::close(...future.stdout)
[13:34:34.606]         }, add = TRUE)
[13:34:34.606]     }
[13:34:34.606]     ...future.frame <- base::sys.nframe()
[13:34:34.606]     ...future.conditions <- base::list()
[13:34:34.606]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.606]     if (FALSE) {
[13:34:34.606]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.606]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.606]     }
[13:34:34.606]     ...future.result <- base::tryCatch({
[13:34:34.606]         base::withCallingHandlers({
[13:34:34.606]             ...future.value <- base::withVisible(base::local({
[13:34:34.606]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.606]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.606]                   ...future.globals.maxSize)) {
[13:34:34.606]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.606]                   on.exit(options(oopts), add = TRUE)
[13:34:34.606]                 }
[13:34:34.606]                 {
[13:34:34.606]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.606]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.606]                     USE.NAMES = FALSE)
[13:34:34.606]                   do.call(mapply, args = args)
[13:34:34.606]                 }
[13:34:34.606]             }))
[13:34:34.606]             future::FutureResult(value = ...future.value$value, 
[13:34:34.606]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.606]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.606]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.606]                     ...future.globalenv.names))
[13:34:34.606]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.606]         }, condition = base::local({
[13:34:34.606]             c <- base::c
[13:34:34.606]             inherits <- base::inherits
[13:34:34.606]             invokeRestart <- base::invokeRestart
[13:34:34.606]             length <- base::length
[13:34:34.606]             list <- base::list
[13:34:34.606]             seq.int <- base::seq.int
[13:34:34.606]             signalCondition <- base::signalCondition
[13:34:34.606]             sys.calls <- base::sys.calls
[13:34:34.606]             `[[` <- base::`[[`
[13:34:34.606]             `+` <- base::`+`
[13:34:34.606]             `<<-` <- base::`<<-`
[13:34:34.606]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.606]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.606]                   3L)]
[13:34:34.606]             }
[13:34:34.606]             function(cond) {
[13:34:34.606]                 is_error <- inherits(cond, "error")
[13:34:34.606]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.606]                   NULL)
[13:34:34.606]                 if (is_error) {
[13:34:34.606]                   sessionInformation <- function() {
[13:34:34.606]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.606]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.606]                       search = base::search(), system = base::Sys.info())
[13:34:34.606]                   }
[13:34:34.606]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.606]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.606]                     cond$call), session = sessionInformation(), 
[13:34:34.606]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.606]                   signalCondition(cond)
[13:34:34.606]                 }
[13:34:34.606]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.606]                 "immediateCondition"))) {
[13:34:34.606]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.606]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.606]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.606]                   if (TRUE && !signal) {
[13:34:34.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.606]                     {
[13:34:34.606]                       inherits <- base::inherits
[13:34:34.606]                       invokeRestart <- base::invokeRestart
[13:34:34.606]                       is.null <- base::is.null
[13:34:34.606]                       muffled <- FALSE
[13:34:34.606]                       if (inherits(cond, "message")) {
[13:34:34.606]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.606]                         if (muffled) 
[13:34:34.606]                           invokeRestart("muffleMessage")
[13:34:34.606]                       }
[13:34:34.606]                       else if (inherits(cond, "warning")) {
[13:34:34.606]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.606]                         if (muffled) 
[13:34:34.606]                           invokeRestart("muffleWarning")
[13:34:34.606]                       }
[13:34:34.606]                       else if (inherits(cond, "condition")) {
[13:34:34.606]                         if (!is.null(pattern)) {
[13:34:34.606]                           computeRestarts <- base::computeRestarts
[13:34:34.606]                           grepl <- base::grepl
[13:34:34.606]                           restarts <- computeRestarts(cond)
[13:34:34.606]                           for (restart in restarts) {
[13:34:34.606]                             name <- restart$name
[13:34:34.606]                             if (is.null(name)) 
[13:34:34.606]                               next
[13:34:34.606]                             if (!grepl(pattern, name)) 
[13:34:34.606]                               next
[13:34:34.606]                             invokeRestart(restart)
[13:34:34.606]                             muffled <- TRUE
[13:34:34.606]                             break
[13:34:34.606]                           }
[13:34:34.606]                         }
[13:34:34.606]                       }
[13:34:34.606]                       invisible(muffled)
[13:34:34.606]                     }
[13:34:34.606]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.606]                   }
[13:34:34.606]                 }
[13:34:34.606]                 else {
[13:34:34.606]                   if (TRUE) {
[13:34:34.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.606]                     {
[13:34:34.606]                       inherits <- base::inherits
[13:34:34.606]                       invokeRestart <- base::invokeRestart
[13:34:34.606]                       is.null <- base::is.null
[13:34:34.606]                       muffled <- FALSE
[13:34:34.606]                       if (inherits(cond, "message")) {
[13:34:34.606]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.606]                         if (muffled) 
[13:34:34.606]                           invokeRestart("muffleMessage")
[13:34:34.606]                       }
[13:34:34.606]                       else if (inherits(cond, "warning")) {
[13:34:34.606]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.606]                         if (muffled) 
[13:34:34.606]                           invokeRestart("muffleWarning")
[13:34:34.606]                       }
[13:34:34.606]                       else if (inherits(cond, "condition")) {
[13:34:34.606]                         if (!is.null(pattern)) {
[13:34:34.606]                           computeRestarts <- base::computeRestarts
[13:34:34.606]                           grepl <- base::grepl
[13:34:34.606]                           restarts <- computeRestarts(cond)
[13:34:34.606]                           for (restart in restarts) {
[13:34:34.606]                             name <- restart$name
[13:34:34.606]                             if (is.null(name)) 
[13:34:34.606]                               next
[13:34:34.606]                             if (!grepl(pattern, name)) 
[13:34:34.606]                               next
[13:34:34.606]                             invokeRestart(restart)
[13:34:34.606]                             muffled <- TRUE
[13:34:34.606]                             break
[13:34:34.606]                           }
[13:34:34.606]                         }
[13:34:34.606]                       }
[13:34:34.606]                       invisible(muffled)
[13:34:34.606]                     }
[13:34:34.606]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.606]                   }
[13:34:34.606]                 }
[13:34:34.606]             }
[13:34:34.606]         }))
[13:34:34.606]     }, error = function(ex) {
[13:34:34.606]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.606]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.606]                 ...future.rng), started = ...future.startTime, 
[13:34:34.606]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.606]             version = "1.8"), class = "FutureResult")
[13:34:34.606]     }, finally = {
[13:34:34.606]         if (!identical(...future.workdir, getwd())) 
[13:34:34.606]             setwd(...future.workdir)
[13:34:34.606]         {
[13:34:34.606]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.606]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.606]             }
[13:34:34.606]             base::options(...future.oldOptions)
[13:34:34.606]             if (.Platform$OS.type == "windows") {
[13:34:34.606]                 old_names <- names(...future.oldEnvVars)
[13:34:34.606]                 envs <- base::Sys.getenv()
[13:34:34.606]                 names <- names(envs)
[13:34:34.606]                 common <- intersect(names, old_names)
[13:34:34.606]                 added <- setdiff(names, old_names)
[13:34:34.606]                 removed <- setdiff(old_names, names)
[13:34:34.606]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.606]                   envs[common]]
[13:34:34.606]                 NAMES <- toupper(changed)
[13:34:34.606]                 args <- list()
[13:34:34.606]                 for (kk in seq_along(NAMES)) {
[13:34:34.606]                   name <- changed[[kk]]
[13:34:34.606]                   NAME <- NAMES[[kk]]
[13:34:34.606]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.606]                     next
[13:34:34.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.606]                 }
[13:34:34.606]                 NAMES <- toupper(added)
[13:34:34.606]                 for (kk in seq_along(NAMES)) {
[13:34:34.606]                   name <- added[[kk]]
[13:34:34.606]                   NAME <- NAMES[[kk]]
[13:34:34.606]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.606]                     next
[13:34:34.606]                   args[[name]] <- ""
[13:34:34.606]                 }
[13:34:34.606]                 NAMES <- toupper(removed)
[13:34:34.606]                 for (kk in seq_along(NAMES)) {
[13:34:34.606]                   name <- removed[[kk]]
[13:34:34.606]                   NAME <- NAMES[[kk]]
[13:34:34.606]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.606]                     next
[13:34:34.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.606]                 }
[13:34:34.606]                 if (length(args) > 0) 
[13:34:34.606]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.606]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.606]             }
[13:34:34.606]             else {
[13:34:34.606]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.606]             }
[13:34:34.606]             {
[13:34:34.606]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.606]                   0L) {
[13:34:34.606]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.606]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.606]                   base::options(opts)
[13:34:34.606]                 }
[13:34:34.606]                 {
[13:34:34.606]                   {
[13:34:34.606]                     base::assign(".Random.seed", c(10407L, -1429551491L, 
[13:34:34.606]                     -62887963L, -259804394L, -54844326L, -550334127L, 
[13:34:34.606]                     123229225L), envir = base::globalenv(), inherits = FALSE)
[13:34:34.606]                     NULL
[13:34:34.606]                   }
[13:34:34.606]                   options(future.plan = NULL)
[13:34:34.606]                   if (is.na(NA_character_)) 
[13:34:34.606]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.606]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.606]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.606]                     .init = FALSE)
[13:34:34.606]                 }
[13:34:34.606]             }
[13:34:34.606]         }
[13:34:34.606]     })
[13:34:34.606]     if (TRUE) {
[13:34:34.606]         base::sink(type = "output", split = FALSE)
[13:34:34.606]         if (TRUE) {
[13:34:34.606]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.606]         }
[13:34:34.606]         else {
[13:34:34.606]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.606]         }
[13:34:34.606]         base::close(...future.stdout)
[13:34:34.606]         ...future.stdout <- NULL
[13:34:34.606]     }
[13:34:34.606]     ...future.result$conditions <- ...future.conditions
[13:34:34.606]     ...future.result$finished <- base::Sys.time()
[13:34:34.606]     ...future.result
[13:34:34.606] }
[13:34:34.608] assign_globals() ...
[13:34:34.608] List of 5
[13:34:34.608]  $ ...future.FUN            :function (x, ...)  
[13:34:34.608]  $ MoreArgs                 : NULL
[13:34:34.608]  $ ...future.elements_ii    :List of 2
[13:34:34.608]   ..$ :List of 4
[13:34:34.608]   .. ..$ : int 1
[13:34:34.608]   .. ..$ : int 2
[13:34:34.608]   .. ..$ : int 3
[13:34:34.608]   .. ..$ : int 4
[13:34:34.608]   ..$ :List of 4
[13:34:34.608]   .. ..$ : int 2
[13:34:34.608]   .. ..$ : int 1
[13:34:34.608]   .. ..$ : int 2
[13:34:34.608]   .. ..$ : int 1
[13:34:34.608]  $ ...future.seeds_ii       : NULL
[13:34:34.608]  $ ...future.globals.maxSize: NULL
[13:34:34.608]  - attr(*, "where")=List of 5
[13:34:34.608]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.608]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.608]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.608]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.608]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.608]  - attr(*, "resolved")= logi FALSE
[13:34:34.608]  - attr(*, "total_size")= num 504
[13:34:34.608]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.608]  - attr(*, "already-done")= logi TRUE
[13:34:34.615] - copied ‘...future.FUN’ to environment
[13:34:34.615] - copied ‘MoreArgs’ to environment
[13:34:34.615] - copied ‘...future.elements_ii’ to environment
[13:34:34.615] - copied ‘...future.seeds_ii’ to environment
[13:34:34.615] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.615] assign_globals() ... done
[13:34:34.615] plan(): Setting new future strategy stack:
[13:34:34.616] List of future strategies:
[13:34:34.616] 1. sequential:
[13:34:34.616]    - args: function (..., envir = parent.frame())
[13:34:34.616]    - tweaked: FALSE
[13:34:34.616]    - call: NULL
[13:34:34.616] plan(): nbrOfWorkers() = 1
[13:34:34.617] plan(): Setting new future strategy stack:
[13:34:34.617] List of future strategies:
[13:34:34.617] 1. sequential:
[13:34:34.617]    - args: function (..., envir = parent.frame())
[13:34:34.617]    - tweaked: FALSE
[13:34:34.617]    - call: plan(strategy)
[13:34:34.617] plan(): nbrOfWorkers() = 1
[13:34:34.617] SequentialFuture started (and completed)
[13:34:34.617] - Launch lazy future ... done
[13:34:34.617] run() for ‘SequentialFuture’ ... done
[13:34:34.618] Created future:
[13:34:34.618] SequentialFuture:
[13:34:34.618] Label: ‘future_mapply-1’
[13:34:34.618] Expression:
[13:34:34.618] {
[13:34:34.618]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.618]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.618]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.618]         on.exit(options(oopts), add = TRUE)
[13:34:34.618]     }
[13:34:34.618]     {
[13:34:34.618]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.618]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.618]         do.call(mapply, args = args)
[13:34:34.618]     }
[13:34:34.618] }
[13:34:34.618] Lazy evaluation: FALSE
[13:34:34.618] Asynchronous evaluation: FALSE
[13:34:34.618] Local evaluation: TRUE
[13:34:34.618] Environment: R_GlobalEnv
[13:34:34.618] Capture standard output: TRUE
[13:34:34.618] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.618] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.618] Packages: <none>
[13:34:34.618] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.618] Resolved: TRUE
[13:34:34.618] Value: 224 bytes of class ‘list’
[13:34:34.618] Early signaling: FALSE
[13:34:34.618] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.618] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.618] Chunk #1 of 1 ... DONE
[13:34:34.619] Launching 1 futures (chunks) ... DONE
[13:34:34.619] Resolving 1 futures (chunks) ...
[13:34:34.619] resolve() on list ...
[13:34:34.619]  recursive: 0
[13:34:34.619]  length: 1
[13:34:34.619] 
[13:34:34.619] resolved() for ‘SequentialFuture’ ...
[13:34:34.619] - state: ‘finished’
[13:34:34.619] - run: TRUE
[13:34:34.619] - result: ‘FutureResult’
[13:34:34.620] resolved() for ‘SequentialFuture’ ... done
[13:34:34.620] Future #1
[13:34:34.620] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.620] - nx: 1
[13:34:34.620] - relay: TRUE
[13:34:34.620] - stdout: TRUE
[13:34:34.620] - signal: TRUE
[13:34:34.620] - resignal: FALSE
[13:34:34.620] - force: TRUE
[13:34:34.620] - relayed: [n=1] FALSE
[13:34:34.620] - queued futures: [n=1] FALSE
[13:34:34.620]  - until=1
[13:34:34.621]  - relaying element #1
[13:34:34.621] - relayed: [n=1] TRUE
[13:34:34.621] - queued futures: [n=1] TRUE
[13:34:34.621] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.621]  length: 0 (resolved future 1)
[13:34:34.621] Relaying remaining futures
[13:34:34.621] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.621] - nx: 1
[13:34:34.621] - relay: TRUE
[13:34:34.621] - stdout: TRUE
[13:34:34.622] - signal: TRUE
[13:34:34.622] - resignal: FALSE
[13:34:34.622] - force: TRUE
[13:34:34.622] - relayed: [n=1] TRUE
[13:34:34.622] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.622] - relayed: [n=1] TRUE
[13:34:34.622] - queued futures: [n=1] TRUE
[13:34:34.622] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.622] resolve() on list ... DONE
[13:34:34.622]  - Number of value chunks collected: 1
[13:34:34.622] Resolving 1 futures (chunks) ... DONE
[13:34:34.623] Reducing values from 1 chunks ...
[13:34:34.623]  - Number of values collected after concatenation: 4
[13:34:34.623]  - Number of values expected: 4
[13:34:34.623] Reducing values from 1 chunks ... DONE
[13:34:34.623] future_mapply() ... DONE
- Parallel RNG ...
[13:34:34.623] future_mapply() ...
[13:34:34.623] Generating random seeds ...
[13:34:34.623] Generating random seed streams for 4 elements ...
[13:34:34.623] Generating random seed streams for 4 elements ... DONE
[13:34:34.624] Generating random seeds ... DONE
[13:34:34.624] Will set RNG state on exit: 10407, -259804394, -266992811, -1058659813, 123229225, -1996312975, -2013029471
[13:34:34.624] Number of chunks: 1
[13:34:34.624] getGlobalsAndPackagesXApply() ...
[13:34:34.624]  - future.globals: TRUE
[13:34:34.624] getGlobalsAndPackages() ...
[13:34:34.624] Searching for globals...
[13:34:34.627] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[13:34:34.627] Searching for globals ... DONE
[13:34:34.627] Resolving globals: FALSE
[13:34:34.628] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[13:34:34.628] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[13:34:34.628] - globals: [1] ‘FUN’
[13:34:34.628] - packages: [1] ‘stats’
[13:34:34.628] getGlobalsAndPackages() ... DONE
[13:34:34.628]  - globals found/used: [n=1] ‘FUN’
[13:34:34.629]  - needed namespaces: [n=1] ‘stats’
[13:34:34.629] Finding globals ... DONE
[13:34:34.629] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.629] List of 2
[13:34:34.629]  $ ...future.FUN:function (n, min = 0, max = 1)  
[13:34:34.629]  $ MoreArgs     :List of 1
[13:34:34.629]   ..$ min: num 1
[13:34:34.629]  - attr(*, "where")=List of 2
[13:34:34.629]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.629]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.629]  - attr(*, "resolved")= logi FALSE
[13:34:34.629]  - attr(*, "total_size")= num NA
[13:34:34.632] Packages to be attached in all futures: [n=1] ‘stats’
[13:34:34.632] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.632] Number of futures (= number of chunks): 1
[13:34:34.632] Launching 1 futures (chunks) ...
[13:34:34.632] Chunk #1 of 1 ...
[13:34:34.632]  - Finding globals in '...' for chunk #1 ...
[13:34:34.632] getGlobalsAndPackages() ...
[13:34:34.633] Searching for globals...
[13:34:34.633] 
[13:34:34.633] Searching for globals ... DONE
[13:34:34.633] - globals: [0] <none>
[13:34:34.633] getGlobalsAndPackages() ... DONE
[13:34:34.633]    + additional globals found: [n=0] 
[13:34:34.633]    + additional namespaces needed: [n=0] 
[13:34:34.633]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.633]  - seeds: [4] <seeds>
[13:34:34.634]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.634] getGlobalsAndPackages() ...
[13:34:34.634] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.634] Resolving globals: FALSE
[13:34:34.634] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[13:34:34.635] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[13:34:34.635] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.635] - packages: [1] ‘stats’
[13:34:34.635] getGlobalsAndPackages() ... DONE
[13:34:34.635] run() for ‘Future’ ...
[13:34:34.636] - state: ‘created’
[13:34:34.636] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.636] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.636] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.636]   - Field: ‘label’
[13:34:34.636]   - Field: ‘local’
[13:34:34.636]   - Field: ‘owner’
[13:34:34.636]   - Field: ‘envir’
[13:34:34.636]   - Field: ‘packages’
[13:34:34.637]   - Field: ‘gc’
[13:34:34.637]   - Field: ‘conditions’
[13:34:34.637]   - Field: ‘expr’
[13:34:34.637]   - Field: ‘uuid’
[13:34:34.637]   - Field: ‘seed’
[13:34:34.637]   - Field: ‘version’
[13:34:34.637]   - Field: ‘result’
[13:34:34.637]   - Field: ‘asynchronous’
[13:34:34.637]   - Field: ‘calls’
[13:34:34.637]   - Field: ‘globals’
[13:34:34.637]   - Field: ‘stdout’
[13:34:34.638]   - Field: ‘earlySignal’
[13:34:34.638]   - Field: ‘lazy’
[13:34:34.638]   - Field: ‘state’
[13:34:34.638] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.638] - Launch lazy future ...
[13:34:34.638] Packages needed by the future expression (n = 1): ‘stats’
[13:34:34.638] Packages needed by future strategies (n = 0): <none>
[13:34:34.639] {
[13:34:34.639]     {
[13:34:34.639]         {
[13:34:34.639]             ...future.startTime <- base::Sys.time()
[13:34:34.639]             {
[13:34:34.639]                 {
[13:34:34.639]                   {
[13:34:34.639]                     {
[13:34:34.639]                       base::local({
[13:34:34.639]                         has_future <- base::requireNamespace("future", 
[13:34:34.639]                           quietly = TRUE)
[13:34:34.639]                         if (has_future) {
[13:34:34.639]                           ns <- base::getNamespace("future")
[13:34:34.639]                           version <- ns[[".package"]][["version"]]
[13:34:34.639]                           if (is.null(version)) 
[13:34:34.639]                             version <- utils::packageVersion("future")
[13:34:34.639]                         }
[13:34:34.639]                         else {
[13:34:34.639]                           version <- NULL
[13:34:34.639]                         }
[13:34:34.639]                         if (!has_future || version < "1.8.0") {
[13:34:34.639]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.639]                             "", base::R.version$version.string), 
[13:34:34.639]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:34.639]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.639]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.639]                               "release", "version")], collapse = " "), 
[13:34:34.639]                             hostname = base::Sys.info()[["nodename"]])
[13:34:34.639]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.639]                             info)
[13:34:34.639]                           info <- base::paste(info, collapse = "; ")
[13:34:34.639]                           if (!has_future) {
[13:34:34.639]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.639]                               info)
[13:34:34.639]                           }
[13:34:34.639]                           else {
[13:34:34.639]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.639]                               info, version)
[13:34:34.639]                           }
[13:34:34.639]                           base::stop(msg)
[13:34:34.639]                         }
[13:34:34.639]                       })
[13:34:34.639]                     }
[13:34:34.639]                     base::local({
[13:34:34.639]                       for (pkg in "stats") {
[13:34:34.639]                         base::loadNamespace(pkg)
[13:34:34.639]                         base::library(pkg, character.only = TRUE)
[13:34:34.639]                       }
[13:34:34.639]                     })
[13:34:34.639]                   }
[13:34:34.639]                   ...future.strategy.old <- future::plan("list")
[13:34:34.639]                   options(future.plan = NULL)
[13:34:34.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.639]                 }
[13:34:34.639]                 ...future.workdir <- getwd()
[13:34:34.639]             }
[13:34:34.639]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.639]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.639]         }
[13:34:34.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.639]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.639]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.639]             base::names(...future.oldOptions))
[13:34:34.639]     }
[13:34:34.639]     if (FALSE) {
[13:34:34.639]     }
[13:34:34.639]     else {
[13:34:34.639]         if (TRUE) {
[13:34:34.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.639]                 open = "w")
[13:34:34.639]         }
[13:34:34.639]         else {
[13:34:34.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.639]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.639]         }
[13:34:34.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.639]             base::sink(type = "output", split = FALSE)
[13:34:34.639]             base::close(...future.stdout)
[13:34:34.639]         }, add = TRUE)
[13:34:34.639]     }
[13:34:34.639]     ...future.frame <- base::sys.nframe()
[13:34:34.639]     ...future.conditions <- base::list()
[13:34:34.639]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.639]     if (FALSE) {
[13:34:34.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.639]     }
[13:34:34.639]     ...future.result <- base::tryCatch({
[13:34:34.639]         base::withCallingHandlers({
[13:34:34.639]             ...future.value <- base::withVisible(base::local({
[13:34:34.639]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.639]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.639]                   ...future.globals.maxSize)) {
[13:34:34.639]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.639]                   on.exit(options(oopts), add = TRUE)
[13:34:34.639]                 }
[13:34:34.639]                 {
[13:34:34.639]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:34.639]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[13:34:34.639]                       envir = globalenv(), inherits = FALSE)
[13:34:34.639]                     ...future.FUN(...)
[13:34:34.639]                   }
[13:34:34.639]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:34.639]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:34.639]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.639]                     USE.NAMES = FALSE)
[13:34:34.639]                   do.call(mapply, args = args)
[13:34:34.639]                 }
[13:34:34.639]             }))
[13:34:34.639]             future::FutureResult(value = ...future.value$value, 
[13:34:34.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.639]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.639]                     ...future.globalenv.names))
[13:34:34.639]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.639]         }, condition = base::local({
[13:34:34.639]             c <- base::c
[13:34:34.639]             inherits <- base::inherits
[13:34:34.639]             invokeRestart <- base::invokeRestart
[13:34:34.639]             length <- base::length
[13:34:34.639]             list <- base::list
[13:34:34.639]             seq.int <- base::seq.int
[13:34:34.639]             signalCondition <- base::signalCondition
[13:34:34.639]             sys.calls <- base::sys.calls
[13:34:34.639]             `[[` <- base::`[[`
[13:34:34.639]             `+` <- base::`+`
[13:34:34.639]             `<<-` <- base::`<<-`
[13:34:34.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.639]                   3L)]
[13:34:34.639]             }
[13:34:34.639]             function(cond) {
[13:34:34.639]                 is_error <- inherits(cond, "error")
[13:34:34.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.639]                   NULL)
[13:34:34.639]                 if (is_error) {
[13:34:34.639]                   sessionInformation <- function() {
[13:34:34.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.639]                       search = base::search(), system = base::Sys.info())
[13:34:34.639]                   }
[13:34:34.639]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.639]                     cond$call), session = sessionInformation(), 
[13:34:34.639]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.639]                   signalCondition(cond)
[13:34:34.639]                 }
[13:34:34.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.639]                 "immediateCondition"))) {
[13:34:34.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.639]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.639]                   if (TRUE && !signal) {
[13:34:34.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.639]                     {
[13:34:34.639]                       inherits <- base::inherits
[13:34:34.639]                       invokeRestart <- base::invokeRestart
[13:34:34.639]                       is.null <- base::is.null
[13:34:34.639]                       muffled <- FALSE
[13:34:34.639]                       if (inherits(cond, "message")) {
[13:34:34.639]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.639]                         if (muffled) 
[13:34:34.639]                           invokeRestart("muffleMessage")
[13:34:34.639]                       }
[13:34:34.639]                       else if (inherits(cond, "warning")) {
[13:34:34.639]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.639]                         if (muffled) 
[13:34:34.639]                           invokeRestart("muffleWarning")
[13:34:34.639]                       }
[13:34:34.639]                       else if (inherits(cond, "condition")) {
[13:34:34.639]                         if (!is.null(pattern)) {
[13:34:34.639]                           computeRestarts <- base::computeRestarts
[13:34:34.639]                           grepl <- base::grepl
[13:34:34.639]                           restarts <- computeRestarts(cond)
[13:34:34.639]                           for (restart in restarts) {
[13:34:34.639]                             name <- restart$name
[13:34:34.639]                             if (is.null(name)) 
[13:34:34.639]                               next
[13:34:34.639]                             if (!grepl(pattern, name)) 
[13:34:34.639]                               next
[13:34:34.639]                             invokeRestart(restart)
[13:34:34.639]                             muffled <- TRUE
[13:34:34.639]                             break
[13:34:34.639]                           }
[13:34:34.639]                         }
[13:34:34.639]                       }
[13:34:34.639]                       invisible(muffled)
[13:34:34.639]                     }
[13:34:34.639]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.639]                   }
[13:34:34.639]                 }
[13:34:34.639]                 else {
[13:34:34.639]                   if (TRUE) {
[13:34:34.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.639]                     {
[13:34:34.639]                       inherits <- base::inherits
[13:34:34.639]                       invokeRestart <- base::invokeRestart
[13:34:34.639]                       is.null <- base::is.null
[13:34:34.639]                       muffled <- FALSE
[13:34:34.639]                       if (inherits(cond, "message")) {
[13:34:34.639]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.639]                         if (muffled) 
[13:34:34.639]                           invokeRestart("muffleMessage")
[13:34:34.639]                       }
[13:34:34.639]                       else if (inherits(cond, "warning")) {
[13:34:34.639]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.639]                         if (muffled) 
[13:34:34.639]                           invokeRestart("muffleWarning")
[13:34:34.639]                       }
[13:34:34.639]                       else if (inherits(cond, "condition")) {
[13:34:34.639]                         if (!is.null(pattern)) {
[13:34:34.639]                           computeRestarts <- base::computeRestarts
[13:34:34.639]                           grepl <- base::grepl
[13:34:34.639]                           restarts <- computeRestarts(cond)
[13:34:34.639]                           for (restart in restarts) {
[13:34:34.639]                             name <- restart$name
[13:34:34.639]                             if (is.null(name)) 
[13:34:34.639]                               next
[13:34:34.639]                             if (!grepl(pattern, name)) 
[13:34:34.639]                               next
[13:34:34.639]                             invokeRestart(restart)
[13:34:34.639]                             muffled <- TRUE
[13:34:34.639]                             break
[13:34:34.639]                           }
[13:34:34.639]                         }
[13:34:34.639]                       }
[13:34:34.639]                       invisible(muffled)
[13:34:34.639]                     }
[13:34:34.639]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.639]                   }
[13:34:34.639]                 }
[13:34:34.639]             }
[13:34:34.639]         }))
[13:34:34.639]     }, error = function(ex) {
[13:34:34.639]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.639]                 ...future.rng), started = ...future.startTime, 
[13:34:34.639]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.639]             version = "1.8"), class = "FutureResult")
[13:34:34.639]     }, finally = {
[13:34:34.639]         if (!identical(...future.workdir, getwd())) 
[13:34:34.639]             setwd(...future.workdir)
[13:34:34.639]         {
[13:34:34.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.639]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.639]             }
[13:34:34.639]             base::options(...future.oldOptions)
[13:34:34.639]             if (.Platform$OS.type == "windows") {
[13:34:34.639]                 old_names <- names(...future.oldEnvVars)
[13:34:34.639]                 envs <- base::Sys.getenv()
[13:34:34.639]                 names <- names(envs)
[13:34:34.639]                 common <- intersect(names, old_names)
[13:34:34.639]                 added <- setdiff(names, old_names)
[13:34:34.639]                 removed <- setdiff(old_names, names)
[13:34:34.639]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.639]                   envs[common]]
[13:34:34.639]                 NAMES <- toupper(changed)
[13:34:34.639]                 args <- list()
[13:34:34.639]                 for (kk in seq_along(NAMES)) {
[13:34:34.639]                   name <- changed[[kk]]
[13:34:34.639]                   NAME <- NAMES[[kk]]
[13:34:34.639]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.639]                     next
[13:34:34.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.639]                 }
[13:34:34.639]                 NAMES <- toupper(added)
[13:34:34.639]                 for (kk in seq_along(NAMES)) {
[13:34:34.639]                   name <- added[[kk]]
[13:34:34.639]                   NAME <- NAMES[[kk]]
[13:34:34.639]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.639]                     next
[13:34:34.639]                   args[[name]] <- ""
[13:34:34.639]                 }
[13:34:34.639]                 NAMES <- toupper(removed)
[13:34:34.639]                 for (kk in seq_along(NAMES)) {
[13:34:34.639]                   name <- removed[[kk]]
[13:34:34.639]                   NAME <- NAMES[[kk]]
[13:34:34.639]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.639]                     next
[13:34:34.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.639]                 }
[13:34:34.639]                 if (length(args) > 0) 
[13:34:34.639]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.639]             }
[13:34:34.639]             else {
[13:34:34.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.639]             }
[13:34:34.639]             {
[13:34:34.639]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.639]                   0L) {
[13:34:34.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.639]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.639]                   base::options(opts)
[13:34:34.639]                 }
[13:34:34.639]                 {
[13:34:34.639]                   {
[13:34:34.639]                     base::assign(".Random.seed", c(10407L, -259804394L, 
[13:34:34.639]                     -266992811L, -1058659813L, 123229225L, -1996312975L, 
[13:34:34.639]                     -2013029471L), envir = base::globalenv(), 
[13:34:34.639]                       inherits = FALSE)
[13:34:34.639]                     NULL
[13:34:34.639]                   }
[13:34:34.639]                   options(future.plan = NULL)
[13:34:34.639]                   if (is.na(NA_character_)) 
[13:34:34.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.639]                     .init = FALSE)
[13:34:34.639]                 }
[13:34:34.639]             }
[13:34:34.639]         }
[13:34:34.639]     })
[13:34:34.639]     if (TRUE) {
[13:34:34.639]         base::sink(type = "output", split = FALSE)
[13:34:34.639]         if (TRUE) {
[13:34:34.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.639]         }
[13:34:34.639]         else {
[13:34:34.639]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.639]         }
[13:34:34.639]         base::close(...future.stdout)
[13:34:34.639]         ...future.stdout <- NULL
[13:34:34.639]     }
[13:34:34.639]     ...future.result$conditions <- ...future.conditions
[13:34:34.639]     ...future.result$finished <- base::Sys.time()
[13:34:34.639]     ...future.result
[13:34:34.639] }
[13:34:34.640] assign_globals() ...
[13:34:34.640] List of 5
[13:34:34.640]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[13:34:34.640]  $ MoreArgs                 :List of 1
[13:34:34.640]   ..$ min: num 1
[13:34:34.640]  $ ...future.elements_ii    :List of 2
[13:34:34.640]   ..$ n  :List of 4
[13:34:34.640]   .. ..$ : int 1
[13:34:34.640]   .. ..$ : int 2
[13:34:34.640]   .. ..$ : int 3
[13:34:34.640]   .. ..$ : int 4
[13:34:34.640]   ..$ max:List of 4
[13:34:34.640]   .. ..$ : int 2
[13:34:34.640]   .. ..$ : int 3
[13:34:34.640]   .. ..$ : int 4
[13:34:34.640]   .. ..$ : int 5
[13:34:34.640]  $ ...future.seeds_ii       :List of 4
[13:34:34.640]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[13:34:34.640]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[13:34:34.640]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[13:34:34.640]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[13:34:34.640]  $ ...future.globals.maxSize: NULL
[13:34:34.640]  - attr(*, "where")=List of 5
[13:34:34.640]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.640]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.640]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.640]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.640]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.640]  - attr(*, "resolved")= logi FALSE
[13:34:34.640]  - attr(*, "total_size")= num 2912
[13:34:34.640]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.640]  - attr(*, "already-done")= logi TRUE
[13:34:34.651] - copied ‘...future.FUN’ to environment
[13:34:34.651] - copied ‘MoreArgs’ to environment
[13:34:34.651] - copied ‘...future.elements_ii’ to environment
[13:34:34.651] - copied ‘...future.seeds_ii’ to environment
[13:34:34.651] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.652] assign_globals() ... done
[13:34:34.652] plan(): Setting new future strategy stack:
[13:34:34.652] List of future strategies:
[13:34:34.652] 1. sequential:
[13:34:34.652]    - args: function (..., envir = parent.frame())
[13:34:34.652]    - tweaked: FALSE
[13:34:34.652]    - call: NULL
[13:34:34.652] plan(): nbrOfWorkers() = 1
[13:34:34.653] plan(): Setting new future strategy stack:
[13:34:34.653] List of future strategies:
[13:34:34.653] 1. sequential:
[13:34:34.653]    - args: function (..., envir = parent.frame())
[13:34:34.653]    - tweaked: FALSE
[13:34:34.653]    - call: plan(strategy)
[13:34:34.654] plan(): nbrOfWorkers() = 1
[13:34:34.654] SequentialFuture started (and completed)
[13:34:34.654] - Launch lazy future ... done
[13:34:34.654] run() for ‘SequentialFuture’ ... done
[13:34:34.654] Created future:
[13:34:34.654] SequentialFuture:
[13:34:34.654] Label: ‘future_mapply-1’
[13:34:34.654] Expression:
[13:34:34.654] {
[13:34:34.654]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.654]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.654]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.654]         on.exit(options(oopts), add = TRUE)
[13:34:34.654]     }
[13:34:34.654]     {
[13:34:34.654]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:34.654]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[13:34:34.654]                 inherits = FALSE)
[13:34:34.654]             ...future.FUN(...)
[13:34:34.654]         }
[13:34:34.654]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:34.654]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:34.654]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.654]         do.call(mapply, args = args)
[13:34:34.654]     }
[13:34:34.654] }
[13:34:34.654] Lazy evaluation: FALSE
[13:34:34.654] Asynchronous evaluation: FALSE
[13:34:34.654] Local evaluation: TRUE
[13:34:34.654] Environment: R_GlobalEnv
[13:34:34.654] Capture standard output: TRUE
[13:34:34.654] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.654] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.654] Packages: 1 packages (‘stats’)
[13:34:34.654] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:34:34.654] Resolved: TRUE
[13:34:34.654] Value: 280 bytes of class ‘list’
[13:34:34.654] Early signaling: FALSE
[13:34:34.654] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.654] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.655] Chunk #1 of 1 ... DONE
[13:34:34.655] Launching 1 futures (chunks) ... DONE
[13:34:34.655] Resolving 1 futures (chunks) ...
[13:34:34.655] resolve() on list ...
[13:34:34.655]  recursive: 0
[13:34:34.655]  length: 1
[13:34:34.656] 
[13:34:34.656] resolved() for ‘SequentialFuture’ ...
[13:34:34.656] - state: ‘finished’
[13:34:34.656] - run: TRUE
[13:34:34.656] - result: ‘FutureResult’
[13:34:34.656] resolved() for ‘SequentialFuture’ ... done
[13:34:34.656] Future #1
[13:34:34.656] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.656] - nx: 1
[13:34:34.656] - relay: TRUE
[13:34:34.656] - stdout: TRUE
[13:34:34.657] - signal: TRUE
[13:34:34.657] - resignal: FALSE
[13:34:34.657] - force: TRUE
[13:34:34.657] - relayed: [n=1] FALSE
[13:34:34.657] - queued futures: [n=1] FALSE
[13:34:34.657]  - until=1
[13:34:34.657]  - relaying element #1
[13:34:34.657] - relayed: [n=1] TRUE
[13:34:34.657] - queued futures: [n=1] TRUE
[13:34:34.657] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.658]  length: 0 (resolved future 1)
[13:34:34.658] Relaying remaining futures
[13:34:34.658] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.658] - nx: 1
[13:34:34.658] - relay: TRUE
[13:34:34.658] - stdout: TRUE
[13:34:34.658] - signal: TRUE
[13:34:34.658] - resignal: FALSE
[13:34:34.658] - force: TRUE
[13:34:34.658] - relayed: [n=1] TRUE
[13:34:34.658] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.658] - relayed: [n=1] TRUE
[13:34:34.659] - queued futures: [n=1] TRUE
[13:34:34.659] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.659] resolve() on list ... DONE
[13:34:34.659]  - Number of value chunks collected: 1
[13:34:34.659] Resolving 1 futures (chunks) ... DONE
[13:34:34.659] Reducing values from 1 chunks ...
[13:34:34.659]  - Number of values collected after concatenation: 4
[13:34:34.659]  - Number of values expected: 4
[13:34:34.659] Reducing values from 1 chunks ... DONE
[13:34:34.659] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[13:34:34.662] future_mapply() ...
[13:34:34.662] Number of chunks: 1
[13:34:34.662] getGlobalsAndPackagesXApply() ...
[13:34:34.662]  - future.globals: TRUE
[13:34:34.662] getGlobalsAndPackages() ...
[13:34:34.662] Searching for globals...
[13:34:34.663] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:34:34.663] Searching for globals ... DONE
[13:34:34.663] Resolving globals: FALSE
[13:34:34.664] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[13:34:34.664] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[13:34:34.664] - globals: [1] ‘FUN’
[13:34:34.664] - packages: [1] ‘stats’
[13:34:34.664] getGlobalsAndPackages() ... DONE
[13:34:34.664]  - globals found/used: [n=1] ‘FUN’
[13:34:34.664]  - needed namespaces: [n=1] ‘stats’
[13:34:34.665] Finding globals ... DONE
[13:34:34.665] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.665] List of 2
[13:34:34.665]  $ ...future.FUN:function (x, w, ...)  
[13:34:34.665]  $ MoreArgs     : NULL
[13:34:34.665]  - attr(*, "where")=List of 2
[13:34:34.665]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.665]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.665]  - attr(*, "resolved")= logi FALSE
[13:34:34.665]  - attr(*, "total_size")= num NA
[13:34:34.667] Packages to be attached in all futures: [n=1] ‘stats’
[13:34:34.667] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.667] Number of futures (= number of chunks): 1
[13:34:34.668] Launching 1 futures (chunks) ...
[13:34:34.668] Chunk #1 of 1 ...
[13:34:34.668]  - Finding globals in '...' for chunk #1 ...
[13:34:34.668] getGlobalsAndPackages() ...
[13:34:34.668] Searching for globals...
[13:34:34.668] 
[13:34:34.668] Searching for globals ... DONE
[13:34:34.668] - globals: [0] <none>
[13:34:34.669] getGlobalsAndPackages() ... DONE
[13:34:34.669]    + additional globals found: [n=0] 
[13:34:34.669]    + additional namespaces needed: [n=0] 
[13:34:34.669]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.669]  - seeds: <none>
[13:34:34.669]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.669] getGlobalsAndPackages() ...
[13:34:34.669] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.670] Resolving globals: FALSE
[13:34:34.671] The total size of the 5 globals is 3.10 KiB (3176 bytes)
[13:34:34.671] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (1.72 KiB of class ‘list’), ‘...future.FUN’ (1.38 KiB of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.671] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.672] - packages: [1] ‘stats’
[13:34:34.672] getGlobalsAndPackages() ... DONE
[13:34:34.672] run() for ‘Future’ ...
[13:34:34.672] - state: ‘created’
[13:34:34.672] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.672] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.672] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.673]   - Field: ‘label’
[13:34:34.673]   - Field: ‘local’
[13:34:34.673]   - Field: ‘owner’
[13:34:34.673]   - Field: ‘envir’
[13:34:34.673]   - Field: ‘packages’
[13:34:34.673]   - Field: ‘gc’
[13:34:34.673]   - Field: ‘conditions’
[13:34:34.673]   - Field: ‘expr’
[13:34:34.673]   - Field: ‘uuid’
[13:34:34.673]   - Field: ‘seed’
[13:34:34.674]   - Field: ‘version’
[13:34:34.674]   - Field: ‘result’
[13:34:34.674]   - Field: ‘asynchronous’
[13:34:34.674]   - Field: ‘calls’
[13:34:34.674]   - Field: ‘globals’
[13:34:34.674]   - Field: ‘stdout’
[13:34:34.674]   - Field: ‘earlySignal’
[13:34:34.674]   - Field: ‘lazy’
[13:34:34.674]   - Field: ‘state’
[13:34:34.674] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.674] - Launch lazy future ...
[13:34:34.675] Packages needed by the future expression (n = 1): ‘stats’
[13:34:34.675] Packages needed by future strategies (n = 0): <none>
[13:34:34.675] {
[13:34:34.675]     {
[13:34:34.675]         {
[13:34:34.675]             ...future.startTime <- base::Sys.time()
[13:34:34.675]             {
[13:34:34.675]                 {
[13:34:34.675]                   {
[13:34:34.675]                     {
[13:34:34.675]                       base::local({
[13:34:34.675]                         has_future <- base::requireNamespace("future", 
[13:34:34.675]                           quietly = TRUE)
[13:34:34.675]                         if (has_future) {
[13:34:34.675]                           ns <- base::getNamespace("future")
[13:34:34.675]                           version <- ns[[".package"]][["version"]]
[13:34:34.675]                           if (is.null(version)) 
[13:34:34.675]                             version <- utils::packageVersion("future")
[13:34:34.675]                         }
[13:34:34.675]                         else {
[13:34:34.675]                           version <- NULL
[13:34:34.675]                         }
[13:34:34.675]                         if (!has_future || version < "1.8.0") {
[13:34:34.675]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.675]                             "", base::R.version$version.string), 
[13:34:34.675]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:34.675]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.675]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.675]                               "release", "version")], collapse = " "), 
[13:34:34.675]                             hostname = base::Sys.info()[["nodename"]])
[13:34:34.675]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.675]                             info)
[13:34:34.675]                           info <- base::paste(info, collapse = "; ")
[13:34:34.675]                           if (!has_future) {
[13:34:34.675]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.675]                               info)
[13:34:34.675]                           }
[13:34:34.675]                           else {
[13:34:34.675]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.675]                               info, version)
[13:34:34.675]                           }
[13:34:34.675]                           base::stop(msg)
[13:34:34.675]                         }
[13:34:34.675]                       })
[13:34:34.675]                     }
[13:34:34.675]                     base::local({
[13:34:34.675]                       for (pkg in "stats") {
[13:34:34.675]                         base::loadNamespace(pkg)
[13:34:34.675]                         base::library(pkg, character.only = TRUE)
[13:34:34.675]                       }
[13:34:34.675]                     })
[13:34:34.675]                   }
[13:34:34.675]                   ...future.strategy.old <- future::plan("list")
[13:34:34.675]                   options(future.plan = NULL)
[13:34:34.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.675]                 }
[13:34:34.675]                 ...future.workdir <- getwd()
[13:34:34.675]             }
[13:34:34.675]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.675]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.675]         }
[13:34:34.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.675]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.675]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.675]             base::names(...future.oldOptions))
[13:34:34.675]     }
[13:34:34.675]     if (FALSE) {
[13:34:34.675]     }
[13:34:34.675]     else {
[13:34:34.675]         if (TRUE) {
[13:34:34.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.675]                 open = "w")
[13:34:34.675]         }
[13:34:34.675]         else {
[13:34:34.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.675]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.675]         }
[13:34:34.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.675]             base::sink(type = "output", split = FALSE)
[13:34:34.675]             base::close(...future.stdout)
[13:34:34.675]         }, add = TRUE)
[13:34:34.675]     }
[13:34:34.675]     ...future.frame <- base::sys.nframe()
[13:34:34.675]     ...future.conditions <- base::list()
[13:34:34.675]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.675]     if (FALSE) {
[13:34:34.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.675]     }
[13:34:34.675]     ...future.result <- base::tryCatch({
[13:34:34.675]         base::withCallingHandlers({
[13:34:34.675]             ...future.value <- base::withVisible(base::local({
[13:34:34.675]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.675]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.675]                   ...future.globals.maxSize)) {
[13:34:34.675]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.675]                   on.exit(options(oopts), add = TRUE)
[13:34:34.675]                 }
[13:34:34.675]                 {
[13:34:34.675]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.675]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.675]                     USE.NAMES = FALSE)
[13:34:34.675]                   do.call(mapply, args = args)
[13:34:34.675]                 }
[13:34:34.675]             }))
[13:34:34.675]             future::FutureResult(value = ...future.value$value, 
[13:34:34.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.675]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.675]                     ...future.globalenv.names))
[13:34:34.675]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.675]         }, condition = base::local({
[13:34:34.675]             c <- base::c
[13:34:34.675]             inherits <- base::inherits
[13:34:34.675]             invokeRestart <- base::invokeRestart
[13:34:34.675]             length <- base::length
[13:34:34.675]             list <- base::list
[13:34:34.675]             seq.int <- base::seq.int
[13:34:34.675]             signalCondition <- base::signalCondition
[13:34:34.675]             sys.calls <- base::sys.calls
[13:34:34.675]             `[[` <- base::`[[`
[13:34:34.675]             `+` <- base::`+`
[13:34:34.675]             `<<-` <- base::`<<-`
[13:34:34.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.675]                   3L)]
[13:34:34.675]             }
[13:34:34.675]             function(cond) {
[13:34:34.675]                 is_error <- inherits(cond, "error")
[13:34:34.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.675]                   NULL)
[13:34:34.675]                 if (is_error) {
[13:34:34.675]                   sessionInformation <- function() {
[13:34:34.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.675]                       search = base::search(), system = base::Sys.info())
[13:34:34.675]                   }
[13:34:34.675]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.675]                     cond$call), session = sessionInformation(), 
[13:34:34.675]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.675]                   signalCondition(cond)
[13:34:34.675]                 }
[13:34:34.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.675]                 "immediateCondition"))) {
[13:34:34.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.675]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.675]                   if (TRUE && !signal) {
[13:34:34.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.675]                     {
[13:34:34.675]                       inherits <- base::inherits
[13:34:34.675]                       invokeRestart <- base::invokeRestart
[13:34:34.675]                       is.null <- base::is.null
[13:34:34.675]                       muffled <- FALSE
[13:34:34.675]                       if (inherits(cond, "message")) {
[13:34:34.675]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.675]                         if (muffled) 
[13:34:34.675]                           invokeRestart("muffleMessage")
[13:34:34.675]                       }
[13:34:34.675]                       else if (inherits(cond, "warning")) {
[13:34:34.675]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.675]                         if (muffled) 
[13:34:34.675]                           invokeRestart("muffleWarning")
[13:34:34.675]                       }
[13:34:34.675]                       else if (inherits(cond, "condition")) {
[13:34:34.675]                         if (!is.null(pattern)) {
[13:34:34.675]                           computeRestarts <- base::computeRestarts
[13:34:34.675]                           grepl <- base::grepl
[13:34:34.675]                           restarts <- computeRestarts(cond)
[13:34:34.675]                           for (restart in restarts) {
[13:34:34.675]                             name <- restart$name
[13:34:34.675]                             if (is.null(name)) 
[13:34:34.675]                               next
[13:34:34.675]                             if (!grepl(pattern, name)) 
[13:34:34.675]                               next
[13:34:34.675]                             invokeRestart(restart)
[13:34:34.675]                             muffled <- TRUE
[13:34:34.675]                             break
[13:34:34.675]                           }
[13:34:34.675]                         }
[13:34:34.675]                       }
[13:34:34.675]                       invisible(muffled)
[13:34:34.675]                     }
[13:34:34.675]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.675]                   }
[13:34:34.675]                 }
[13:34:34.675]                 else {
[13:34:34.675]                   if (TRUE) {
[13:34:34.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.675]                     {
[13:34:34.675]                       inherits <- base::inherits
[13:34:34.675]                       invokeRestart <- base::invokeRestart
[13:34:34.675]                       is.null <- base::is.null
[13:34:34.675]                       muffled <- FALSE
[13:34:34.675]                       if (inherits(cond, "message")) {
[13:34:34.675]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.675]                         if (muffled) 
[13:34:34.675]                           invokeRestart("muffleMessage")
[13:34:34.675]                       }
[13:34:34.675]                       else if (inherits(cond, "warning")) {
[13:34:34.675]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.675]                         if (muffled) 
[13:34:34.675]                           invokeRestart("muffleWarning")
[13:34:34.675]                       }
[13:34:34.675]                       else if (inherits(cond, "condition")) {
[13:34:34.675]                         if (!is.null(pattern)) {
[13:34:34.675]                           computeRestarts <- base::computeRestarts
[13:34:34.675]                           grepl <- base::grepl
[13:34:34.675]                           restarts <- computeRestarts(cond)
[13:34:34.675]                           for (restart in restarts) {
[13:34:34.675]                             name <- restart$name
[13:34:34.675]                             if (is.null(name)) 
[13:34:34.675]                               next
[13:34:34.675]                             if (!grepl(pattern, name)) 
[13:34:34.675]                               next
[13:34:34.675]                             invokeRestart(restart)
[13:34:34.675]                             muffled <- TRUE
[13:34:34.675]                             break
[13:34:34.675]                           }
[13:34:34.675]                         }
[13:34:34.675]                       }
[13:34:34.675]                       invisible(muffled)
[13:34:34.675]                     }
[13:34:34.675]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.675]                   }
[13:34:34.675]                 }
[13:34:34.675]             }
[13:34:34.675]         }))
[13:34:34.675]     }, error = function(ex) {
[13:34:34.675]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.675]                 ...future.rng), started = ...future.startTime, 
[13:34:34.675]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.675]             version = "1.8"), class = "FutureResult")
[13:34:34.675]     }, finally = {
[13:34:34.675]         if (!identical(...future.workdir, getwd())) 
[13:34:34.675]             setwd(...future.workdir)
[13:34:34.675]         {
[13:34:34.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.675]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.675]             }
[13:34:34.675]             base::options(...future.oldOptions)
[13:34:34.675]             if (.Platform$OS.type == "windows") {
[13:34:34.675]                 old_names <- names(...future.oldEnvVars)
[13:34:34.675]                 envs <- base::Sys.getenv()
[13:34:34.675]                 names <- names(envs)
[13:34:34.675]                 common <- intersect(names, old_names)
[13:34:34.675]                 added <- setdiff(names, old_names)
[13:34:34.675]                 removed <- setdiff(old_names, names)
[13:34:34.675]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.675]                   envs[common]]
[13:34:34.675]                 NAMES <- toupper(changed)
[13:34:34.675]                 args <- list()
[13:34:34.675]                 for (kk in seq_along(NAMES)) {
[13:34:34.675]                   name <- changed[[kk]]
[13:34:34.675]                   NAME <- NAMES[[kk]]
[13:34:34.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.675]                     next
[13:34:34.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.675]                 }
[13:34:34.675]                 NAMES <- toupper(added)
[13:34:34.675]                 for (kk in seq_along(NAMES)) {
[13:34:34.675]                   name <- added[[kk]]
[13:34:34.675]                   NAME <- NAMES[[kk]]
[13:34:34.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.675]                     next
[13:34:34.675]                   args[[name]] <- ""
[13:34:34.675]                 }
[13:34:34.675]                 NAMES <- toupper(removed)
[13:34:34.675]                 for (kk in seq_along(NAMES)) {
[13:34:34.675]                   name <- removed[[kk]]
[13:34:34.675]                   NAME <- NAMES[[kk]]
[13:34:34.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.675]                     next
[13:34:34.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.675]                 }
[13:34:34.675]                 if (length(args) > 0) 
[13:34:34.675]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.675]             }
[13:34:34.675]             else {
[13:34:34.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.675]             }
[13:34:34.675]             {
[13:34:34.675]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.675]                   0L) {
[13:34:34.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.675]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.675]                   base::options(opts)
[13:34:34.675]                 }
[13:34:34.675]                 {
[13:34:34.675]                   {
[13:34:34.675]                     base::assign(".Random.seed", c(10407L, -1755399068L, 
[13:34:34.675]                     41092360L, -1942091459L, 750572923L, 836018968L, 
[13:34:34.675]                     1218846117L), envir = base::globalenv(), 
[13:34:34.675]                       inherits = FALSE)
[13:34:34.675]                     NULL
[13:34:34.675]                   }
[13:34:34.675]                   options(future.plan = NULL)
[13:34:34.675]                   if (is.na(NA_character_)) 
[13:34:34.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.675]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.675]                     .init = FALSE)
[13:34:34.675]                 }
[13:34:34.675]             }
[13:34:34.675]         }
[13:34:34.675]     })
[13:34:34.675]     if (TRUE) {
[13:34:34.675]         base::sink(type = "output", split = FALSE)
[13:34:34.675]         if (TRUE) {
[13:34:34.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.675]         }
[13:34:34.675]         else {
[13:34:34.675]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.675]         }
[13:34:34.675]         base::close(...future.stdout)
[13:34:34.675]         ...future.stdout <- NULL
[13:34:34.675]     }
[13:34:34.675]     ...future.result$conditions <- ...future.conditions
[13:34:34.675]     ...future.result$finished <- base::Sys.time()
[13:34:34.675]     ...future.result
[13:34:34.675] }
[13:34:34.677] assign_globals() ...
[13:34:34.677] List of 5
[13:34:34.677]  $ ...future.FUN            :function (x, w, ...)  
[13:34:34.677]  $ MoreArgs                 : NULL
[13:34:34.677]  $ ...future.elements_ii    :List of 2
[13:34:34.677]   ..$ :List of 5
[13:34:34.677]   .. ..$ : num [1:10] 0.114 0.4189 0.808 0.0354 0.0617 ...
[13:34:34.677]   .. ..$ : num [1:10] 0.476 0.342 0.881 0.923 0.338 ...
[13:34:34.677]   .. ..$ : num [1:10] 0.347 0.4 0.641 0.612 0.233 ...
[13:34:34.677]   .. ..$ : num [1:10] 0.971 0.988 0.239 0.333 0.581 ...
[13:34:34.677]   .. ..$ : num [1:10] 0.63 0.12 0.365 0.922 0.036 ...
[13:34:34.677]   ..$ :List of 5
[13:34:34.677]   .. ..$ : num [1:10] 6 5 5 5 5 4 5 3 4 6
[13:34:34.677]   .. ..$ : num [1:10] 6 5 6 7 5 7 4 4 6 5
[13:34:34.677]   .. ..$ : num [1:10] 2 8 7 8 8 6 8 7 7 5
[13:34:34.677]   .. ..$ : num [1:10] 5 4 7 6 5 5 5 7 9 7
[13:34:34.677]   .. ..$ : num [1:10] 8 9 6 11 7 5 3 5 8 4
[13:34:34.677]  $ ...future.seeds_ii       : NULL
[13:34:34.677]  $ ...future.globals.maxSize: NULL
[13:34:34.677]  - attr(*, "where")=List of 5
[13:34:34.677]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.677]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.677]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.677]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.677]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.677]  - attr(*, "resolved")= logi FALSE
[13:34:34.677]  - attr(*, "total_size")= num 3176
[13:34:34.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.677]  - attr(*, "already-done")= logi TRUE
[13:34:34.684] - copied ‘...future.FUN’ to environment
[13:34:34.684] - copied ‘MoreArgs’ to environment
[13:34:34.684] - copied ‘...future.elements_ii’ to environment
[13:34:34.684] - copied ‘...future.seeds_ii’ to environment
[13:34:34.684] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.684] assign_globals() ... done
[13:34:34.685] plan(): Setting new future strategy stack:
[13:34:34.685] List of future strategies:
[13:34:34.685] 1. sequential:
[13:34:34.685]    - args: function (..., envir = parent.frame())
[13:34:34.685]    - tweaked: FALSE
[13:34:34.685]    - call: NULL
[13:34:34.685] plan(): nbrOfWorkers() = 1
[13:34:34.686] plan(): Setting new future strategy stack:
[13:34:34.686] List of future strategies:
[13:34:34.686] 1. sequential:
[13:34:34.686]    - args: function (..., envir = parent.frame())
[13:34:34.686]    - tweaked: FALSE
[13:34:34.686]    - call: plan(strategy)
[13:34:34.686] plan(): nbrOfWorkers() = 1
[13:34:34.686] SequentialFuture started (and completed)
[13:34:34.687] - Launch lazy future ... done
[13:34:34.687] run() for ‘SequentialFuture’ ... done
[13:34:34.687] Created future:
[13:34:34.687] SequentialFuture:
[13:34:34.687] Label: ‘future_Map-1’
[13:34:34.687] Expression:
[13:34:34.687] {
[13:34:34.687]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.687]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.687]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.687]         on.exit(options(oopts), add = TRUE)
[13:34:34.687]     }
[13:34:34.687]     {
[13:34:34.687]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.687]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.687]         do.call(mapply, args = args)
[13:34:34.687]     }
[13:34:34.687] }
[13:34:34.687] Lazy evaluation: FALSE
[13:34:34.687] Asynchronous evaluation: FALSE
[13:34:34.687] Local evaluation: TRUE
[13:34:34.687] Environment: R_GlobalEnv
[13:34:34.687] Capture standard output: TRUE
[13:34:34.687] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.687] Globals: 5 objects totaling 3.10 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.687] Packages: 1 packages (‘stats’)
[13:34:34.687] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.687] Resolved: TRUE
[13:34:34.687] Value: 280 bytes of class ‘list’
[13:34:34.687] Early signaling: FALSE
[13:34:34.687] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.687] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.688] Chunk #1 of 1 ... DONE
[13:34:34.688] Launching 1 futures (chunks) ... DONE
[13:34:34.688] Resolving 1 futures (chunks) ...
[13:34:34.688] resolve() on list ...
[13:34:34.688]  recursive: 0
[13:34:34.688]  length: 1
[13:34:34.688] 
[13:34:34.688] resolved() for ‘SequentialFuture’ ...
[13:34:34.688] - state: ‘finished’
[13:34:34.688] - run: TRUE
[13:34:34.689] - result: ‘FutureResult’
[13:34:34.689] resolved() for ‘SequentialFuture’ ... done
[13:34:34.689] Future #1
[13:34:34.689] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.689] - nx: 1
[13:34:34.689] - relay: TRUE
[13:34:34.689] - stdout: TRUE
[13:34:34.689] - signal: TRUE
[13:34:34.689] - resignal: FALSE
[13:34:34.689] - force: TRUE
[13:34:34.689] - relayed: [n=1] FALSE
[13:34:34.689] - queued futures: [n=1] FALSE
[13:34:34.690]  - until=1
[13:34:34.690]  - relaying element #1
[13:34:34.690] - relayed: [n=1] TRUE
[13:34:34.690] - queued futures: [n=1] TRUE
[13:34:34.690] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.690]  length: 0 (resolved future 1)
[13:34:34.690] Relaying remaining futures
[13:34:34.690] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.690] - nx: 1
[13:34:34.690] - relay: TRUE
[13:34:34.691] - stdout: TRUE
[13:34:34.691] - signal: TRUE
[13:34:34.691] - resignal: FALSE
[13:34:34.691] - force: TRUE
[13:34:34.691] - relayed: [n=1] TRUE
[13:34:34.691] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.691] - relayed: [n=1] TRUE
[13:34:34.691] - queued futures: [n=1] TRUE
[13:34:34.692] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.692] resolve() on list ... DONE
[13:34:34.692]  - Number of value chunks collected: 1
[13:34:34.693] Resolving 1 futures (chunks) ... DONE
[13:34:34.693] Reducing values from 1 chunks ...
[13:34:34.693]  - Number of values collected after concatenation: 5
[13:34:34.693]  - Number of values expected: 5
[13:34:34.693] Reducing values from 1 chunks ... DONE
[13:34:34.693] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[13:34:34.695] future_mapply() ...
[13:34:34.695] Number of chunks: 1
[13:34:34.695] getGlobalsAndPackagesXApply() ...
[13:34:34.695]  - future.globals: TRUE
[13:34:34.695] getGlobalsAndPackages() ...
[13:34:34.695] Searching for globals...
[13:34:34.696] - globals found: [1] ‘FUN’
[13:34:34.696] Searching for globals ... DONE
[13:34:34.696] Resolving globals: FALSE
[13:34:34.696] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:34.696] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:34.696] - globals: [1] ‘FUN’
[13:34:34.697] 
[13:34:34.697] getGlobalsAndPackages() ... DONE
[13:34:34.697]  - globals found/used: [n=1] ‘FUN’
[13:34:34.697]  - needed namespaces: [n=0] 
[13:34:34.697] Finding globals ... DONE
[13:34:34.697] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.697] List of 2
[13:34:34.697]  $ ...future.FUN:function (e1, e2)  
[13:34:34.697]  $ MoreArgs     : NULL
[13:34:34.697]  - attr(*, "where")=List of 2
[13:34:34.697]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.697]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.697]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.697]  - attr(*, "resolved")= logi FALSE
[13:34:34.697]  - attr(*, "total_size")= num NA
[13:34:34.699] Packages to be attached in all futures: [n=0] 
[13:34:34.700] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.700] Number of futures (= number of chunks): 1
[13:34:34.700] Launching 1 futures (chunks) ...
[13:34:34.700] Chunk #1 of 1 ...
[13:34:34.700]  - Finding globals in '...' for chunk #1 ...
[13:34:34.700] getGlobalsAndPackages() ...
[13:34:34.700] Searching for globals...
[13:34:34.701] 
[13:34:34.701] Searching for globals ... DONE
[13:34:34.701] - globals: [0] <none>
[13:34:34.701] getGlobalsAndPackages() ... DONE
[13:34:34.701]    + additional globals found: [n=0] 
[13:34:34.701]    + additional namespaces needed: [n=0] 
[13:34:34.701]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.701]  - seeds: <none>
[13:34:34.701]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.701] getGlobalsAndPackages() ...
[13:34:34.701] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.702] Resolving globals: FALSE
[13:34:34.702] The total size of the 5 globals is 392 bytes (392 bytes)
[13:34:34.702] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 392 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (336 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.702] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.703] 
[13:34:34.703] getGlobalsAndPackages() ... DONE
[13:34:34.703] run() for ‘Future’ ...
[13:34:34.703] - state: ‘created’
[13:34:34.703] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.703] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.704]   - Field: ‘label’
[13:34:34.704]   - Field: ‘local’
[13:34:34.704]   - Field: ‘owner’
[13:34:34.704]   - Field: ‘envir’
[13:34:34.704]   - Field: ‘packages’
[13:34:34.704]   - Field: ‘gc’
[13:34:34.704]   - Field: ‘conditions’
[13:34:34.704]   - Field: ‘expr’
[13:34:34.704]   - Field: ‘uuid’
[13:34:34.704]   - Field: ‘seed’
[13:34:34.704]   - Field: ‘version’
[13:34:34.704]   - Field: ‘result’
[13:34:34.705]   - Field: ‘asynchronous’
[13:34:34.705]   - Field: ‘calls’
[13:34:34.705]   - Field: ‘globals’
[13:34:34.705]   - Field: ‘stdout’
[13:34:34.705]   - Field: ‘earlySignal’
[13:34:34.705]   - Field: ‘lazy’
[13:34:34.705]   - Field: ‘state’
[13:34:34.705] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.705] - Launch lazy future ...
[13:34:34.705] Packages needed by the future expression (n = 0): <none>
[13:34:34.706] Packages needed by future strategies (n = 0): <none>
[13:34:34.706] {
[13:34:34.706]     {
[13:34:34.706]         {
[13:34:34.706]             ...future.startTime <- base::Sys.time()
[13:34:34.706]             {
[13:34:34.706]                 {
[13:34:34.706]                   {
[13:34:34.706]                     base::local({
[13:34:34.706]                       has_future <- base::requireNamespace("future", 
[13:34:34.706]                         quietly = TRUE)
[13:34:34.706]                       if (has_future) {
[13:34:34.706]                         ns <- base::getNamespace("future")
[13:34:34.706]                         version <- ns[[".package"]][["version"]]
[13:34:34.706]                         if (is.null(version)) 
[13:34:34.706]                           version <- utils::packageVersion("future")
[13:34:34.706]                       }
[13:34:34.706]                       else {
[13:34:34.706]                         version <- NULL
[13:34:34.706]                       }
[13:34:34.706]                       if (!has_future || version < "1.8.0") {
[13:34:34.706]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.706]                           "", base::R.version$version.string), 
[13:34:34.706]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.706]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.706]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.706]                             "release", "version")], collapse = " "), 
[13:34:34.706]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.706]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.706]                           info)
[13:34:34.706]                         info <- base::paste(info, collapse = "; ")
[13:34:34.706]                         if (!has_future) {
[13:34:34.706]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.706]                             info)
[13:34:34.706]                         }
[13:34:34.706]                         else {
[13:34:34.706]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.706]                             info, version)
[13:34:34.706]                         }
[13:34:34.706]                         base::stop(msg)
[13:34:34.706]                       }
[13:34:34.706]                     })
[13:34:34.706]                   }
[13:34:34.706]                   ...future.strategy.old <- future::plan("list")
[13:34:34.706]                   options(future.plan = NULL)
[13:34:34.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.706]                 }
[13:34:34.706]                 ...future.workdir <- getwd()
[13:34:34.706]             }
[13:34:34.706]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.706]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.706]         }
[13:34:34.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.706]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.706]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.706]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.706]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.706]             base::names(...future.oldOptions))
[13:34:34.706]     }
[13:34:34.706]     if (FALSE) {
[13:34:34.706]     }
[13:34:34.706]     else {
[13:34:34.706]         if (TRUE) {
[13:34:34.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.706]                 open = "w")
[13:34:34.706]         }
[13:34:34.706]         else {
[13:34:34.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.706]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.706]         }
[13:34:34.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.706]             base::sink(type = "output", split = FALSE)
[13:34:34.706]             base::close(...future.stdout)
[13:34:34.706]         }, add = TRUE)
[13:34:34.706]     }
[13:34:34.706]     ...future.frame <- base::sys.nframe()
[13:34:34.706]     ...future.conditions <- base::list()
[13:34:34.706]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.706]     if (FALSE) {
[13:34:34.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.706]     }
[13:34:34.706]     ...future.result <- base::tryCatch({
[13:34:34.706]         base::withCallingHandlers({
[13:34:34.706]             ...future.value <- base::withVisible(base::local({
[13:34:34.706]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.706]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.706]                   ...future.globals.maxSize)) {
[13:34:34.706]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.706]                   on.exit(options(oopts), add = TRUE)
[13:34:34.706]                 }
[13:34:34.706]                 {
[13:34:34.706]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.706]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.706]                     USE.NAMES = FALSE)
[13:34:34.706]                   do.call(mapply, args = args)
[13:34:34.706]                 }
[13:34:34.706]             }))
[13:34:34.706]             future::FutureResult(value = ...future.value$value, 
[13:34:34.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.706]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.706]                     ...future.globalenv.names))
[13:34:34.706]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.706]         }, condition = base::local({
[13:34:34.706]             c <- base::c
[13:34:34.706]             inherits <- base::inherits
[13:34:34.706]             invokeRestart <- base::invokeRestart
[13:34:34.706]             length <- base::length
[13:34:34.706]             list <- base::list
[13:34:34.706]             seq.int <- base::seq.int
[13:34:34.706]             signalCondition <- base::signalCondition
[13:34:34.706]             sys.calls <- base::sys.calls
[13:34:34.706]             `[[` <- base::`[[`
[13:34:34.706]             `+` <- base::`+`
[13:34:34.706]             `<<-` <- base::`<<-`
[13:34:34.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.706]                   3L)]
[13:34:34.706]             }
[13:34:34.706]             function(cond) {
[13:34:34.706]                 is_error <- inherits(cond, "error")
[13:34:34.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.706]                   NULL)
[13:34:34.706]                 if (is_error) {
[13:34:34.706]                   sessionInformation <- function() {
[13:34:34.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.706]                       search = base::search(), system = base::Sys.info())
[13:34:34.706]                   }
[13:34:34.706]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.706]                     cond$call), session = sessionInformation(), 
[13:34:34.706]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.706]                   signalCondition(cond)
[13:34:34.706]                 }
[13:34:34.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.706]                 "immediateCondition"))) {
[13:34:34.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.706]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.706]                   if (TRUE && !signal) {
[13:34:34.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.706]                     {
[13:34:34.706]                       inherits <- base::inherits
[13:34:34.706]                       invokeRestart <- base::invokeRestart
[13:34:34.706]                       is.null <- base::is.null
[13:34:34.706]                       muffled <- FALSE
[13:34:34.706]                       if (inherits(cond, "message")) {
[13:34:34.706]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.706]                         if (muffled) 
[13:34:34.706]                           invokeRestart("muffleMessage")
[13:34:34.706]                       }
[13:34:34.706]                       else if (inherits(cond, "warning")) {
[13:34:34.706]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.706]                         if (muffled) 
[13:34:34.706]                           invokeRestart("muffleWarning")
[13:34:34.706]                       }
[13:34:34.706]                       else if (inherits(cond, "condition")) {
[13:34:34.706]                         if (!is.null(pattern)) {
[13:34:34.706]                           computeRestarts <- base::computeRestarts
[13:34:34.706]                           grepl <- base::grepl
[13:34:34.706]                           restarts <- computeRestarts(cond)
[13:34:34.706]                           for (restart in restarts) {
[13:34:34.706]                             name <- restart$name
[13:34:34.706]                             if (is.null(name)) 
[13:34:34.706]                               next
[13:34:34.706]                             if (!grepl(pattern, name)) 
[13:34:34.706]                               next
[13:34:34.706]                             invokeRestart(restart)
[13:34:34.706]                             muffled <- TRUE
[13:34:34.706]                             break
[13:34:34.706]                           }
[13:34:34.706]                         }
[13:34:34.706]                       }
[13:34:34.706]                       invisible(muffled)
[13:34:34.706]                     }
[13:34:34.706]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.706]                   }
[13:34:34.706]                 }
[13:34:34.706]                 else {
[13:34:34.706]                   if (TRUE) {
[13:34:34.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.706]                     {
[13:34:34.706]                       inherits <- base::inherits
[13:34:34.706]                       invokeRestart <- base::invokeRestart
[13:34:34.706]                       is.null <- base::is.null
[13:34:34.706]                       muffled <- FALSE
[13:34:34.706]                       if (inherits(cond, "message")) {
[13:34:34.706]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.706]                         if (muffled) 
[13:34:34.706]                           invokeRestart("muffleMessage")
[13:34:34.706]                       }
[13:34:34.706]                       else if (inherits(cond, "warning")) {
[13:34:34.706]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.706]                         if (muffled) 
[13:34:34.706]                           invokeRestart("muffleWarning")
[13:34:34.706]                       }
[13:34:34.706]                       else if (inherits(cond, "condition")) {
[13:34:34.706]                         if (!is.null(pattern)) {
[13:34:34.706]                           computeRestarts <- base::computeRestarts
[13:34:34.706]                           grepl <- base::grepl
[13:34:34.706]                           restarts <- computeRestarts(cond)
[13:34:34.706]                           for (restart in restarts) {
[13:34:34.706]                             name <- restart$name
[13:34:34.706]                             if (is.null(name)) 
[13:34:34.706]                               next
[13:34:34.706]                             if (!grepl(pattern, name)) 
[13:34:34.706]                               next
[13:34:34.706]                             invokeRestart(restart)
[13:34:34.706]                             muffled <- TRUE
[13:34:34.706]                             break
[13:34:34.706]                           }
[13:34:34.706]                         }
[13:34:34.706]                       }
[13:34:34.706]                       invisible(muffled)
[13:34:34.706]                     }
[13:34:34.706]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.706]                   }
[13:34:34.706]                 }
[13:34:34.706]             }
[13:34:34.706]         }))
[13:34:34.706]     }, error = function(ex) {
[13:34:34.706]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.706]                 ...future.rng), started = ...future.startTime, 
[13:34:34.706]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.706]             version = "1.8"), class = "FutureResult")
[13:34:34.706]     }, finally = {
[13:34:34.706]         if (!identical(...future.workdir, getwd())) 
[13:34:34.706]             setwd(...future.workdir)
[13:34:34.706]         {
[13:34:34.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.706]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.706]             }
[13:34:34.706]             base::options(...future.oldOptions)
[13:34:34.706]             if (.Platform$OS.type == "windows") {
[13:34:34.706]                 old_names <- names(...future.oldEnvVars)
[13:34:34.706]                 envs <- base::Sys.getenv()
[13:34:34.706]                 names <- names(envs)
[13:34:34.706]                 common <- intersect(names, old_names)
[13:34:34.706]                 added <- setdiff(names, old_names)
[13:34:34.706]                 removed <- setdiff(old_names, names)
[13:34:34.706]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.706]                   envs[common]]
[13:34:34.706]                 NAMES <- toupper(changed)
[13:34:34.706]                 args <- list()
[13:34:34.706]                 for (kk in seq_along(NAMES)) {
[13:34:34.706]                   name <- changed[[kk]]
[13:34:34.706]                   NAME <- NAMES[[kk]]
[13:34:34.706]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.706]                     next
[13:34:34.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.706]                 }
[13:34:34.706]                 NAMES <- toupper(added)
[13:34:34.706]                 for (kk in seq_along(NAMES)) {
[13:34:34.706]                   name <- added[[kk]]
[13:34:34.706]                   NAME <- NAMES[[kk]]
[13:34:34.706]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.706]                     next
[13:34:34.706]                   args[[name]] <- ""
[13:34:34.706]                 }
[13:34:34.706]                 NAMES <- toupper(removed)
[13:34:34.706]                 for (kk in seq_along(NAMES)) {
[13:34:34.706]                   name <- removed[[kk]]
[13:34:34.706]                   NAME <- NAMES[[kk]]
[13:34:34.706]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.706]                     next
[13:34:34.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.706]                 }
[13:34:34.706]                 if (length(args) > 0) 
[13:34:34.706]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.706]             }
[13:34:34.706]             else {
[13:34:34.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.706]             }
[13:34:34.706]             {
[13:34:34.706]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.706]                   0L) {
[13:34:34.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.706]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.706]                   base::options(opts)
[13:34:34.706]                 }
[13:34:34.706]                 {
[13:34:34.706]                   {
[13:34:34.706]                     base::assign(".Random.seed", c(10407L, -1755399068L, 
[13:34:34.706]                     41092360L, -1942091459L, 750572923L, 836018968L, 
[13:34:34.706]                     1218846117L), envir = base::globalenv(), 
[13:34:34.706]                       inherits = FALSE)
[13:34:34.706]                     NULL
[13:34:34.706]                   }
[13:34:34.706]                   options(future.plan = NULL)
[13:34:34.706]                   if (is.na(NA_character_)) 
[13:34:34.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.706]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.706]                     .init = FALSE)
[13:34:34.706]                 }
[13:34:34.706]             }
[13:34:34.706]         }
[13:34:34.706]     })
[13:34:34.706]     if (TRUE) {
[13:34:34.706]         base::sink(type = "output", split = FALSE)
[13:34:34.706]         if (TRUE) {
[13:34:34.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.706]         }
[13:34:34.706]         else {
[13:34:34.706]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.706]         }
[13:34:34.706]         base::close(...future.stdout)
[13:34:34.706]         ...future.stdout <- NULL
[13:34:34.706]     }
[13:34:34.706]     ...future.result$conditions <- ...future.conditions
[13:34:34.706]     ...future.result$finished <- base::Sys.time()
[13:34:34.706]     ...future.result
[13:34:34.706] }
[13:34:34.707] assign_globals() ...
[13:34:34.708] List of 5
[13:34:34.708]  $ ...future.FUN            :function (e1, e2)  
[13:34:34.708]  $ MoreArgs                 : NULL
[13:34:34.708]  $ ...future.elements_ii    :List of 2
[13:34:34.708]   ..$ :List of 3
[13:34:34.708]   .. ..$ : num 1
[13:34:34.708]   .. ..$ : num 1
[13:34:34.708]   .. ..$ : num 1
[13:34:34.708]   ..$ :List of 3
[13:34:34.708]   .. ..$ : int 1
[13:34:34.708]   .. ..$ : int 2
[13:34:34.708]   .. ..$ : int 3
[13:34:34.708]  $ ...future.seeds_ii       : NULL
[13:34:34.708]  $ ...future.globals.maxSize: NULL
[13:34:34.708]  - attr(*, "where")=List of 5
[13:34:34.708]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.708]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.708]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.708]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.708]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.708]  - attr(*, "resolved")= logi FALSE
[13:34:34.708]  - attr(*, "total_size")= num 392
[13:34:34.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.708]  - attr(*, "already-done")= logi TRUE
[13:34:34.714] - copied ‘...future.FUN’ to environment
[13:34:34.714] - copied ‘MoreArgs’ to environment
[13:34:34.714] - copied ‘...future.elements_ii’ to environment
[13:34:34.714] - copied ‘...future.seeds_ii’ to environment
[13:34:34.715] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.715] assign_globals() ... done
[13:34:34.715] plan(): Setting new future strategy stack:
[13:34:34.715] List of future strategies:
[13:34:34.715] 1. sequential:
[13:34:34.715]    - args: function (..., envir = parent.frame())
[13:34:34.715]    - tweaked: FALSE
[13:34:34.715]    - call: NULL
[13:34:34.715] plan(): nbrOfWorkers() = 1
[13:34:34.716] plan(): Setting new future strategy stack:
[13:34:34.716] List of future strategies:
[13:34:34.716] 1. sequential:
[13:34:34.716]    - args: function (..., envir = parent.frame())
[13:34:34.716]    - tweaked: FALSE
[13:34:34.716]    - call: plan(strategy)
[13:34:34.716] plan(): nbrOfWorkers() = 1
[13:34:34.717] SequentialFuture started (and completed)
[13:34:34.717] - Launch lazy future ... done
[13:34:34.717] run() for ‘SequentialFuture’ ... done
[13:34:34.717] Created future:
[13:34:34.717] SequentialFuture:
[13:34:34.717] Label: ‘future_Map-1’
[13:34:34.717] Expression:
[13:34:34.717] {
[13:34:34.717]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.717]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.717]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.717]         on.exit(options(oopts), add = TRUE)
[13:34:34.717]     }
[13:34:34.717]     {
[13:34:34.717]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.717]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.717]         do.call(mapply, args = args)
[13:34:34.717]     }
[13:34:34.717] }
[13:34:34.717] Lazy evaluation: FALSE
[13:34:34.717] Asynchronous evaluation: FALSE
[13:34:34.717] Local evaluation: TRUE
[13:34:34.717] Environment: R_GlobalEnv
[13:34:34.717] Capture standard output: TRUE
[13:34:34.717] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.717] Globals: 5 objects totaling 392 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.717] Packages: <none>
[13:34:34.717] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.717] Resolved: TRUE
[13:34:34.717] Value: 168 bytes of class ‘list’
[13:34:34.717] Early signaling: FALSE
[13:34:34.717] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.717] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.718] Chunk #1 of 1 ... DONE
[13:34:34.718] Launching 1 futures (chunks) ... DONE
[13:34:34.718] Resolving 1 futures (chunks) ...
[13:34:34.718] resolve() on list ...
[13:34:34.718]  recursive: 0
[13:34:34.718]  length: 1
[13:34:34.718] 
[13:34:34.718] resolved() for ‘SequentialFuture’ ...
[13:34:34.719] - state: ‘finished’
[13:34:34.719] - run: TRUE
[13:34:34.719] - result: ‘FutureResult’
[13:34:34.719] resolved() for ‘SequentialFuture’ ... done
[13:34:34.719] Future #1
[13:34:34.719] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.719] - nx: 1
[13:34:34.719] - relay: TRUE
[13:34:34.719] - stdout: TRUE
[13:34:34.719] - signal: TRUE
[13:34:34.719] - resignal: FALSE
[13:34:34.719] - force: TRUE
[13:34:34.720] - relayed: [n=1] FALSE
[13:34:34.720] - queued futures: [n=1] FALSE
[13:34:34.720]  - until=1
[13:34:34.720]  - relaying element #1
[13:34:34.720] - relayed: [n=1] TRUE
[13:34:34.720] - queued futures: [n=1] TRUE
[13:34:34.720] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.720]  length: 0 (resolved future 1)
[13:34:34.720] Relaying remaining futures
[13:34:34.720] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.720] - nx: 1
[13:34:34.721] - relay: TRUE
[13:34:34.721] - stdout: TRUE
[13:34:34.721] - signal: TRUE
[13:34:34.721] - resignal: FALSE
[13:34:34.721] - force: TRUE
[13:34:34.721] - relayed: [n=1] TRUE
[13:34:34.721] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.721] - relayed: [n=1] TRUE
[13:34:34.721] - queued futures: [n=1] TRUE
[13:34:34.721] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.721] resolve() on list ... DONE
[13:34:34.722]  - Number of value chunks collected: 1
[13:34:34.722] Resolving 1 futures (chunks) ... DONE
[13:34:34.722] Reducing values from 1 chunks ...
[13:34:34.722]  - Number of values collected after concatenation: 3
[13:34:34.722]  - Number of values expected: 3
[13:34:34.722] Reducing values from 1 chunks ... DONE
[13:34:34.722] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[13:34:34.722] future_mapply() ...
[13:34:34.723] Number of chunks: 1
[13:34:34.723] getGlobalsAndPackagesXApply() ...
[13:34:34.723]  - future.globals: TRUE
[13:34:34.723] getGlobalsAndPackages() ...
[13:34:34.723] Searching for globals...
[13:34:34.724] - globals found: [1] ‘FUN’
[13:34:34.724] Searching for globals ... DONE
[13:34:34.724] Resolving globals: FALSE
[13:34:34.724] The total size of the 1 globals is 848 bytes (848 bytes)
[13:34:34.724] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:34:34.725] - globals: [1] ‘FUN’
[13:34:34.725] 
[13:34:34.725] getGlobalsAndPackages() ... DONE
[13:34:34.725]  - globals found/used: [n=1] ‘FUN’
[13:34:34.725]  - needed namespaces: [n=0] 
[13:34:34.725] Finding globals ... DONE
[13:34:34.725] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.725] List of 2
[13:34:34.725]  $ ...future.FUN:function (x)  
[13:34:34.725]  $ MoreArgs     : NULL
[13:34:34.725]  - attr(*, "where")=List of 2
[13:34:34.725]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.725]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.725]  - attr(*, "resolved")= logi FALSE
[13:34:34.725]  - attr(*, "total_size")= num NA
[13:34:34.727] Packages to be attached in all futures: [n=0] 
[13:34:34.728] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.728] Number of futures (= number of chunks): 1
[13:34:34.728] Launching 1 futures (chunks) ...
[13:34:34.728] Chunk #1 of 1 ...
[13:34:34.728]  - Finding globals in '...' for chunk #1 ...
[13:34:34.728] getGlobalsAndPackages() ...
[13:34:34.728] Searching for globals...
[13:34:34.728] 
[13:34:34.729] Searching for globals ... DONE
[13:34:34.729] - globals: [0] <none>
[13:34:34.729] getGlobalsAndPackages() ... DONE
[13:34:34.729]    + additional globals found: [n=0] 
[13:34:34.729]    + additional namespaces needed: [n=0] 
[13:34:34.729]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.729]  - seeds: <none>
[13:34:34.729]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.729] getGlobalsAndPackages() ...
[13:34:34.729] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.729] Resolving globals: FALSE
[13:34:34.730] The total size of the 5 globals is 960 bytes (960 bytes)
[13:34:34.730] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 960 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.730] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.731] 
[13:34:34.731] getGlobalsAndPackages() ... DONE
[13:34:34.731] run() for ‘Future’ ...
[13:34:34.731] - state: ‘created’
[13:34:34.731] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:34:34.731] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.731] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:34:34.731]   - Field: ‘label’
[13:34:34.732]   - Field: ‘local’
[13:34:34.732]   - Field: ‘owner’
[13:34:34.732]   - Field: ‘envir’
[13:34:34.732]   - Field: ‘packages’
[13:34:34.732]   - Field: ‘gc’
[13:34:34.732]   - Field: ‘conditions’
[13:34:34.732]   - Field: ‘expr’
[13:34:34.732]   - Field: ‘uuid’
[13:34:34.732]   - Field: ‘seed’
[13:34:34.732]   - Field: ‘version’
[13:34:34.732]   - Field: ‘result’
[13:34:34.733]   - Field: ‘asynchronous’
[13:34:34.733]   - Field: ‘calls’
[13:34:34.733]   - Field: ‘globals’
[13:34:34.733]   - Field: ‘stdout’
[13:34:34.733]   - Field: ‘earlySignal’
[13:34:34.733]   - Field: ‘lazy’
[13:34:34.734]   - Field: ‘state’
[13:34:34.734] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:34:34.734] - Launch lazy future ...
[13:34:34.734] Packages needed by the future expression (n = 0): <none>
[13:34:34.734] Packages needed by future strategies (n = 0): <none>
[13:34:34.735] {
[13:34:34.735]     {
[13:34:34.735]         {
[13:34:34.735]             ...future.startTime <- base::Sys.time()
[13:34:34.735]             {
[13:34:34.735]                 {
[13:34:34.735]                   {
[13:34:34.735]                     base::local({
[13:34:34.735]                       has_future <- base::requireNamespace("future", 
[13:34:34.735]                         quietly = TRUE)
[13:34:34.735]                       if (has_future) {
[13:34:34.735]                         ns <- base::getNamespace("future")
[13:34:34.735]                         version <- ns[[".package"]][["version"]]
[13:34:34.735]                         if (is.null(version)) 
[13:34:34.735]                           version <- utils::packageVersion("future")
[13:34:34.735]                       }
[13:34:34.735]                       else {
[13:34:34.735]                         version <- NULL
[13:34:34.735]                       }
[13:34:34.735]                       if (!has_future || version < "1.8.0") {
[13:34:34.735]                         info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.735]                           "", base::R.version$version.string), 
[13:34:34.735]                           platform = base::sprintf("%s (%s-bit)", 
[13:34:34.735]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.735]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.735]                             "release", "version")], collapse = " "), 
[13:34:34.735]                           hostname = base::Sys.info()[["nodename"]])
[13:34:34.735]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.735]                           info)
[13:34:34.735]                         info <- base::paste(info, collapse = "; ")
[13:34:34.735]                         if (!has_future) {
[13:34:34.735]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.735]                             info)
[13:34:34.735]                         }
[13:34:34.735]                         else {
[13:34:34.735]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.735]                             info, version)
[13:34:34.735]                         }
[13:34:34.735]                         base::stop(msg)
[13:34:34.735]                       }
[13:34:34.735]                     })
[13:34:34.735]                   }
[13:34:34.735]                   ...future.strategy.old <- future::plan("list")
[13:34:34.735]                   options(future.plan = NULL)
[13:34:34.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.735]                 }
[13:34:34.735]                 ...future.workdir <- getwd()
[13:34:34.735]             }
[13:34:34.735]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.735]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.735]         }
[13:34:34.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.735]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:34.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.735]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.735]             base::names(...future.oldOptions))
[13:34:34.735]     }
[13:34:34.735]     if (FALSE) {
[13:34:34.735]     }
[13:34:34.735]     else {
[13:34:34.735]         if (TRUE) {
[13:34:34.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.735]                 open = "w")
[13:34:34.735]         }
[13:34:34.735]         else {
[13:34:34.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.735]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.735]         }
[13:34:34.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.735]             base::sink(type = "output", split = FALSE)
[13:34:34.735]             base::close(...future.stdout)
[13:34:34.735]         }, add = TRUE)
[13:34:34.735]     }
[13:34:34.735]     ...future.frame <- base::sys.nframe()
[13:34:34.735]     ...future.conditions <- base::list()
[13:34:34.735]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.735]     if (FALSE) {
[13:34:34.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.735]     }
[13:34:34.735]     ...future.result <- base::tryCatch({
[13:34:34.735]         base::withCallingHandlers({
[13:34:34.735]             ...future.value <- base::withVisible(base::local({
[13:34:34.735]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.735]                 if (!identical(...future.globals.maxSize.org, 
[13:34:34.735]                   ...future.globals.maxSize)) {
[13:34:34.735]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.735]                   on.exit(options(oopts), add = TRUE)
[13:34:34.735]                 }
[13:34:34.735]                 {
[13:34:34.735]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.735]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.735]                     USE.NAMES = FALSE)
[13:34:34.735]                   do.call(mapply, args = args)
[13:34:34.735]                 }
[13:34:34.735]             }))
[13:34:34.735]             future::FutureResult(value = ...future.value$value, 
[13:34:34.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.735]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.735]                     ...future.globalenv.names))
[13:34:34.735]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.735]         }, condition = base::local({
[13:34:34.735]             c <- base::c
[13:34:34.735]             inherits <- base::inherits
[13:34:34.735]             invokeRestart <- base::invokeRestart
[13:34:34.735]             length <- base::length
[13:34:34.735]             list <- base::list
[13:34:34.735]             seq.int <- base::seq.int
[13:34:34.735]             signalCondition <- base::signalCondition
[13:34:34.735]             sys.calls <- base::sys.calls
[13:34:34.735]             `[[` <- base::`[[`
[13:34:34.735]             `+` <- base::`+`
[13:34:34.735]             `<<-` <- base::`<<-`
[13:34:34.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.735]                   3L)]
[13:34:34.735]             }
[13:34:34.735]             function(cond) {
[13:34:34.735]                 is_error <- inherits(cond, "error")
[13:34:34.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.735]                   NULL)
[13:34:34.735]                 if (is_error) {
[13:34:34.735]                   sessionInformation <- function() {
[13:34:34.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.735]                       search = base::search(), system = base::Sys.info())
[13:34:34.735]                   }
[13:34:34.735]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.735]                     cond$call), session = sessionInformation(), 
[13:34:34.735]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.735]                   signalCondition(cond)
[13:34:34.735]                 }
[13:34:34.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.735]                 "immediateCondition"))) {
[13:34:34.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.735]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.735]                   if (TRUE && !signal) {
[13:34:34.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.735]                     {
[13:34:34.735]                       inherits <- base::inherits
[13:34:34.735]                       invokeRestart <- base::invokeRestart
[13:34:34.735]                       is.null <- base::is.null
[13:34:34.735]                       muffled <- FALSE
[13:34:34.735]                       if (inherits(cond, "message")) {
[13:34:34.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.735]                         if (muffled) 
[13:34:34.735]                           invokeRestart("muffleMessage")
[13:34:34.735]                       }
[13:34:34.735]                       else if (inherits(cond, "warning")) {
[13:34:34.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.735]                         if (muffled) 
[13:34:34.735]                           invokeRestart("muffleWarning")
[13:34:34.735]                       }
[13:34:34.735]                       else if (inherits(cond, "condition")) {
[13:34:34.735]                         if (!is.null(pattern)) {
[13:34:34.735]                           computeRestarts <- base::computeRestarts
[13:34:34.735]                           grepl <- base::grepl
[13:34:34.735]                           restarts <- computeRestarts(cond)
[13:34:34.735]                           for (restart in restarts) {
[13:34:34.735]                             name <- restart$name
[13:34:34.735]                             if (is.null(name)) 
[13:34:34.735]                               next
[13:34:34.735]                             if (!grepl(pattern, name)) 
[13:34:34.735]                               next
[13:34:34.735]                             invokeRestart(restart)
[13:34:34.735]                             muffled <- TRUE
[13:34:34.735]                             break
[13:34:34.735]                           }
[13:34:34.735]                         }
[13:34:34.735]                       }
[13:34:34.735]                       invisible(muffled)
[13:34:34.735]                     }
[13:34:34.735]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.735]                   }
[13:34:34.735]                 }
[13:34:34.735]                 else {
[13:34:34.735]                   if (TRUE) {
[13:34:34.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.735]                     {
[13:34:34.735]                       inherits <- base::inherits
[13:34:34.735]                       invokeRestart <- base::invokeRestart
[13:34:34.735]                       is.null <- base::is.null
[13:34:34.735]                       muffled <- FALSE
[13:34:34.735]                       if (inherits(cond, "message")) {
[13:34:34.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.735]                         if (muffled) 
[13:34:34.735]                           invokeRestart("muffleMessage")
[13:34:34.735]                       }
[13:34:34.735]                       else if (inherits(cond, "warning")) {
[13:34:34.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.735]                         if (muffled) 
[13:34:34.735]                           invokeRestart("muffleWarning")
[13:34:34.735]                       }
[13:34:34.735]                       else if (inherits(cond, "condition")) {
[13:34:34.735]                         if (!is.null(pattern)) {
[13:34:34.735]                           computeRestarts <- base::computeRestarts
[13:34:34.735]                           grepl <- base::grepl
[13:34:34.735]                           restarts <- computeRestarts(cond)
[13:34:34.735]                           for (restart in restarts) {
[13:34:34.735]                             name <- restart$name
[13:34:34.735]                             if (is.null(name)) 
[13:34:34.735]                               next
[13:34:34.735]                             if (!grepl(pattern, name)) 
[13:34:34.735]                               next
[13:34:34.735]                             invokeRestart(restart)
[13:34:34.735]                             muffled <- TRUE
[13:34:34.735]                             break
[13:34:34.735]                           }
[13:34:34.735]                         }
[13:34:34.735]                       }
[13:34:34.735]                       invisible(muffled)
[13:34:34.735]                     }
[13:34:34.735]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.735]                   }
[13:34:34.735]                 }
[13:34:34.735]             }
[13:34:34.735]         }))
[13:34:34.735]     }, error = function(ex) {
[13:34:34.735]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.735]                 ...future.rng), started = ...future.startTime, 
[13:34:34.735]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.735]             version = "1.8"), class = "FutureResult")
[13:34:34.735]     }, finally = {
[13:34:34.735]         if (!identical(...future.workdir, getwd())) 
[13:34:34.735]             setwd(...future.workdir)
[13:34:34.735]         {
[13:34:34.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.735]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.735]             }
[13:34:34.735]             base::options(...future.oldOptions)
[13:34:34.735]             if (.Platform$OS.type == "windows") {
[13:34:34.735]                 old_names <- names(...future.oldEnvVars)
[13:34:34.735]                 envs <- base::Sys.getenv()
[13:34:34.735]                 names <- names(envs)
[13:34:34.735]                 common <- intersect(names, old_names)
[13:34:34.735]                 added <- setdiff(names, old_names)
[13:34:34.735]                 removed <- setdiff(old_names, names)
[13:34:34.735]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.735]                   envs[common]]
[13:34:34.735]                 NAMES <- toupper(changed)
[13:34:34.735]                 args <- list()
[13:34:34.735]                 for (kk in seq_along(NAMES)) {
[13:34:34.735]                   name <- changed[[kk]]
[13:34:34.735]                   NAME <- NAMES[[kk]]
[13:34:34.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.735]                     next
[13:34:34.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.735]                 }
[13:34:34.735]                 NAMES <- toupper(added)
[13:34:34.735]                 for (kk in seq_along(NAMES)) {
[13:34:34.735]                   name <- added[[kk]]
[13:34:34.735]                   NAME <- NAMES[[kk]]
[13:34:34.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.735]                     next
[13:34:34.735]                   args[[name]] <- ""
[13:34:34.735]                 }
[13:34:34.735]                 NAMES <- toupper(removed)
[13:34:34.735]                 for (kk in seq_along(NAMES)) {
[13:34:34.735]                   name <- removed[[kk]]
[13:34:34.735]                   NAME <- NAMES[[kk]]
[13:34:34.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.735]                     next
[13:34:34.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.735]                 }
[13:34:34.735]                 if (length(args) > 0) 
[13:34:34.735]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.735]             }
[13:34:34.735]             else {
[13:34:34.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.735]             }
[13:34:34.735]             {
[13:34:34.735]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.735]                   0L) {
[13:34:34.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.735]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.735]                   base::options(opts)
[13:34:34.735]                 }
[13:34:34.735]                 {
[13:34:34.735]                   {
[13:34:34.735]                     base::assign(".Random.seed", c(10407L, -1755399068L, 
[13:34:34.735]                     41092360L, -1942091459L, 750572923L, 836018968L, 
[13:34:34.735]                     1218846117L), envir = base::globalenv(), 
[13:34:34.735]                       inherits = FALSE)
[13:34:34.735]                     NULL
[13:34:34.735]                   }
[13:34:34.735]                   options(future.plan = NULL)
[13:34:34.735]                   if (is.na(NA_character_)) 
[13:34:34.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.735]                     .init = FALSE)
[13:34:34.735]                 }
[13:34:34.735]             }
[13:34:34.735]         }
[13:34:34.735]     })
[13:34:34.735]     if (TRUE) {
[13:34:34.735]         base::sink(type = "output", split = FALSE)
[13:34:34.735]         if (TRUE) {
[13:34:34.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.735]         }
[13:34:34.735]         else {
[13:34:34.735]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.735]         }
[13:34:34.735]         base::close(...future.stdout)
[13:34:34.735]         ...future.stdout <- NULL
[13:34:34.735]     }
[13:34:34.735]     ...future.result$conditions <- ...future.conditions
[13:34:34.735]     ...future.result$finished <- base::Sys.time()
[13:34:34.735]     ...future.result
[13:34:34.735] }
[13:34:34.736] assign_globals() ...
[13:34:34.736] List of 5
[13:34:34.736]  $ ...future.FUN            :function (x)  
[13:34:34.736]  $ MoreArgs                 : NULL
[13:34:34.736]  $ ...future.elements_ii    :List of 1
[13:34:34.736]   ..$ :List of 2
[13:34:34.736]   .. ..$ a: num 0
[13:34:34.736]   .. ..$ b: num 0
[13:34:34.736]  $ ...future.seeds_ii       : NULL
[13:34:34.736]  $ ...future.globals.maxSize: NULL
[13:34:34.736]  - attr(*, "where")=List of 5
[13:34:34.736]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.736]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.736]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.736]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.736]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.736]  - attr(*, "resolved")= logi FALSE
[13:34:34.736]  - attr(*, "total_size")= num 960
[13:34:34.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.736]  - attr(*, "already-done")= logi TRUE
[13:34:34.741] - copied ‘...future.FUN’ to environment
[13:34:34.741] - copied ‘MoreArgs’ to environment
[13:34:34.741] - copied ‘...future.elements_ii’ to environment
[13:34:34.741] - copied ‘...future.seeds_ii’ to environment
[13:34:34.741] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.742] assign_globals() ... done
[13:34:34.742] plan(): Setting new future strategy stack:
[13:34:34.742] List of future strategies:
[13:34:34.742] 1. sequential:
[13:34:34.742]    - args: function (..., envir = parent.frame())
[13:34:34.742]    - tweaked: FALSE
[13:34:34.742]    - call: NULL
[13:34:34.742] plan(): nbrOfWorkers() = 1
[13:34:34.743] plan(): Setting new future strategy stack:
[13:34:34.743] List of future strategies:
[13:34:34.743] 1. sequential:
[13:34:34.743]    - args: function (..., envir = parent.frame())
[13:34:34.743]    - tweaked: FALSE
[13:34:34.743]    - call: plan(strategy)
[13:34:34.743] plan(): nbrOfWorkers() = 1
[13:34:34.743] SequentialFuture started (and completed)
[13:34:34.744] - Launch lazy future ... done
[13:34:34.744] run() for ‘SequentialFuture’ ... done
[13:34:34.744] Created future:
[13:34:34.744] SequentialFuture:
[13:34:34.744] Label: ‘future_mapply-1’
[13:34:34.744] Expression:
[13:34:34.744] {
[13:34:34.744]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.744]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.744]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.744]         on.exit(options(oopts), add = TRUE)
[13:34:34.744]     }
[13:34:34.744]     {
[13:34:34.744]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.744]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.744]         do.call(mapply, args = args)
[13:34:34.744]     }
[13:34:34.744] }
[13:34:34.744] Lazy evaluation: FALSE
[13:34:34.744] Asynchronous evaluation: FALSE
[13:34:34.744] Local evaluation: TRUE
[13:34:34.744] Environment: R_GlobalEnv
[13:34:34.744] Capture standard output: TRUE
[13:34:34.744] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.744] Globals: 5 objects totaling 960 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.744] Packages: <none>
[13:34:34.744] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.744] Resolved: TRUE
[13:34:34.744] Value: 112 bytes of class ‘list’
[13:34:34.744] Early signaling: FALSE
[13:34:34.744] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.744] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:34:34.745] Chunk #1 of 1 ... DONE
[13:34:34.745] Launching 1 futures (chunks) ... DONE
[13:34:34.745] Resolving 1 futures (chunks) ...
[13:34:34.745] resolve() on list ...
[13:34:34.745]  recursive: 0
[13:34:34.745]  length: 1
[13:34:34.745] 
[13:34:34.745] resolved() for ‘SequentialFuture’ ...
[13:34:34.745] - state: ‘finished’
[13:34:34.745] - run: TRUE
[13:34:34.745] - result: ‘FutureResult’
[13:34:34.746] resolved() for ‘SequentialFuture’ ... done
[13:34:34.746] Future #1
[13:34:34.746] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:34:34.746] - nx: 1
[13:34:34.746] - relay: TRUE
[13:34:34.746] - stdout: TRUE
[13:34:34.746] - signal: TRUE
[13:34:34.746] - resignal: FALSE
[13:34:34.746] - force: TRUE
[13:34:34.746] - relayed: [n=1] FALSE
[13:34:34.746] - queued futures: [n=1] FALSE
[13:34:34.746]  - until=1
[13:34:34.747]  - relaying element #1
[13:34:34.747] - relayed: [n=1] TRUE
[13:34:34.747] - queued futures: [n=1] TRUE
[13:34:34.747] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:34:34.747]  length: 0 (resolved future 1)
[13:34:34.747] Relaying remaining futures
[13:34:34.747] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.747] - nx: 1
[13:34:34.747] - relay: TRUE
[13:34:34.747] - stdout: TRUE
[13:34:34.747] - signal: TRUE
[13:34:34.748] - resignal: FALSE
[13:34:34.748] - force: TRUE
[13:34:34.748] - relayed: [n=1] TRUE
[13:34:34.748] - queued futures: [n=1] TRUE
 - flush all
[13:34:34.748] - relayed: [n=1] TRUE
[13:34:34.748] - queued futures: [n=1] TRUE
[13:34:34.748] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.748] resolve() on list ... DONE
[13:34:34.748]  - Number of value chunks collected: 1
[13:34:34.748] Resolving 1 futures (chunks) ... DONE
[13:34:34.748] Reducing values from 1 chunks ...
[13:34:34.749]  - Number of values collected after concatenation: 2
[13:34:34.749]  - Number of values expected: 2
[13:34:34.749] Reducing values from 1 chunks ... DONE
[13:34:34.749] future_mapply() ... DONE
[13:34:34.749] plan(): Setting new future strategy stack:
[13:34:34.749] List of future strategies:
[13:34:34.749] 1. sequential:
[13:34:34.749]    - args: function (..., envir = parent.frame())
[13:34:34.749]    - tweaked: FALSE
[13:34:34.749]    - call: plan(sequential)
[13:34:34.749] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[13:34:34.750] plan(): Setting new future strategy stack:
[13:34:34.750] List of future strategies:
[13:34:34.750] 1. multicore:
[13:34:34.750]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:34.750]    - tweaked: FALSE
[13:34:34.750]    - call: plan(strategy)
[13:34:34.754] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[13:34:34.754] future_mapply() ...
[13:34:34.757] Number of chunks: 2
[13:34:34.757] getGlobalsAndPackagesXApply() ...
[13:34:34.757]  - future.globals: TRUE
[13:34:34.758] getGlobalsAndPackages() ...
[13:34:34.758] Searching for globals...
[13:34:34.758] - globals found: [1] ‘FUN’
[13:34:34.758] Searching for globals ... DONE
[13:34:34.758] Resolving globals: FALSE
[13:34:34.759] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:34.759] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:34.759] - globals: [1] ‘FUN’
[13:34:34.759] 
[13:34:34.759] getGlobalsAndPackages() ... DONE
[13:34:34.759]  - globals found/used: [n=1] ‘FUN’
[13:34:34.759]  - needed namespaces: [n=0] 
[13:34:34.760] Finding globals ... DONE
[13:34:34.761] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.761] List of 2
[13:34:34.761]  $ ...future.FUN:function (x, ...)  
[13:34:34.761]  $ MoreArgs     : NULL
[13:34:34.761]  - attr(*, "where")=List of 2
[13:34:34.761]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.761]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.761]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.761]  - attr(*, "resolved")= logi FALSE
[13:34:34.761]  - attr(*, "total_size")= num NA
[13:34:34.764] Packages to be attached in all futures: [n=0] 
[13:34:34.764] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.764] Number of futures (= number of chunks): 2
[13:34:34.764] Launching 2 futures (chunks) ...
[13:34:34.765] Chunk #1 of 2 ...
[13:34:34.765]  - Finding globals in '...' for chunk #1 ...
[13:34:34.765] getGlobalsAndPackages() ...
[13:34:34.765] Searching for globals...
[13:34:34.765] 
[13:34:34.765] Searching for globals ... DONE
[13:34:34.765] - globals: [0] <none>
[13:34:34.765] getGlobalsAndPackages() ... DONE
[13:34:34.765]    + additional globals found: [n=0] 
[13:34:34.766]    + additional namespaces needed: [n=0] 
[13:34:34.766]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.766]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:34.766]  - seeds: <none>
[13:34:34.766]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.766] getGlobalsAndPackages() ...
[13:34:34.766] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.766] Resolving globals: FALSE
[13:34:34.767] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:34.767] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.767] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.767] 
[13:34:34.768] getGlobalsAndPackages() ... DONE
[13:34:34.768] run() for ‘Future’ ...
[13:34:34.768] - state: ‘created’
[13:34:34.768] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:34.772] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:34.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:34.772]   - Field: ‘label’
[13:34:34.772]   - Field: ‘local’
[13:34:34.772]   - Field: ‘owner’
[13:34:34.772]   - Field: ‘envir’
[13:34:34.772]   - Field: ‘workers’
[13:34:34.772]   - Field: ‘packages’
[13:34:34.773]   - Field: ‘gc’
[13:34:34.773]   - Field: ‘job’
[13:34:34.773]   - Field: ‘conditions’
[13:34:34.773]   - Field: ‘expr’
[13:34:34.773]   - Field: ‘uuid’
[13:34:34.773]   - Field: ‘seed’
[13:34:34.773]   - Field: ‘version’
[13:34:34.773]   - Field: ‘result’
[13:34:34.773]   - Field: ‘asynchronous’
[13:34:34.773]   - Field: ‘calls’
[13:34:34.773]   - Field: ‘globals’
[13:34:34.774]   - Field: ‘stdout’
[13:34:34.774]   - Field: ‘earlySignal’
[13:34:34.774]   - Field: ‘lazy’
[13:34:34.774]   - Field: ‘state’
[13:34:34.774] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:34.774] - Launch lazy future ...
[13:34:34.775] Packages needed by the future expression (n = 0): <none>
[13:34:34.775] Packages needed by future strategies (n = 0): <none>
[13:34:34.776] {
[13:34:34.776]     {
[13:34:34.776]         {
[13:34:34.776]             ...future.startTime <- base::Sys.time()
[13:34:34.776]             {
[13:34:34.776]                 {
[13:34:34.776]                   {
[13:34:34.776]                     {
[13:34:34.776]                       base::local({
[13:34:34.776]                         has_future <- base::requireNamespace("future", 
[13:34:34.776]                           quietly = TRUE)
[13:34:34.776]                         if (has_future) {
[13:34:34.776]                           ns <- base::getNamespace("future")
[13:34:34.776]                           version <- ns[[".package"]][["version"]]
[13:34:34.776]                           if (is.null(version)) 
[13:34:34.776]                             version <- utils::packageVersion("future")
[13:34:34.776]                         }
[13:34:34.776]                         else {
[13:34:34.776]                           version <- NULL
[13:34:34.776]                         }
[13:34:34.776]                         if (!has_future || version < "1.8.0") {
[13:34:34.776]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.776]                             "", base::R.version$version.string), 
[13:34:34.776]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:34.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.776]                               "release", "version")], collapse = " "), 
[13:34:34.776]                             hostname = base::Sys.info()[["nodename"]])
[13:34:34.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.776]                             info)
[13:34:34.776]                           info <- base::paste(info, collapse = "; ")
[13:34:34.776]                           if (!has_future) {
[13:34:34.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.776]                               info)
[13:34:34.776]                           }
[13:34:34.776]                           else {
[13:34:34.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.776]                               info, version)
[13:34:34.776]                           }
[13:34:34.776]                           base::stop(msg)
[13:34:34.776]                         }
[13:34:34.776]                       })
[13:34:34.776]                     }
[13:34:34.776]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:34.776]                     base::options(mc.cores = 1L)
[13:34:34.776]                   }
[13:34:34.776]                   ...future.strategy.old <- future::plan("list")
[13:34:34.776]                   options(future.plan = NULL)
[13:34:34.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.776]                 }
[13:34:34.776]                 ...future.workdir <- getwd()
[13:34:34.776]             }
[13:34:34.776]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.776]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.776]         }
[13:34:34.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.776]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:34.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.776]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.776]             base::names(...future.oldOptions))
[13:34:34.776]     }
[13:34:34.776]     if (FALSE) {
[13:34:34.776]     }
[13:34:34.776]     else {
[13:34:34.776]         if (TRUE) {
[13:34:34.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.776]                 open = "w")
[13:34:34.776]         }
[13:34:34.776]         else {
[13:34:34.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.776]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.776]         }
[13:34:34.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.776]             base::sink(type = "output", split = FALSE)
[13:34:34.776]             base::close(...future.stdout)
[13:34:34.776]         }, add = TRUE)
[13:34:34.776]     }
[13:34:34.776]     ...future.frame <- base::sys.nframe()
[13:34:34.776]     ...future.conditions <- base::list()
[13:34:34.776]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.776]     if (FALSE) {
[13:34:34.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.776]     }
[13:34:34.776]     ...future.result <- base::tryCatch({
[13:34:34.776]         base::withCallingHandlers({
[13:34:34.776]             ...future.value <- base::withVisible(base::local({
[13:34:34.776]                 withCallingHandlers({
[13:34:34.776]                   {
[13:34:34.776]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.776]                     if (!identical(...future.globals.maxSize.org, 
[13:34:34.776]                       ...future.globals.maxSize)) {
[13:34:34.776]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.776]                       on.exit(options(oopts), add = TRUE)
[13:34:34.776]                     }
[13:34:34.776]                     {
[13:34:34.776]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.776]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.776]                         USE.NAMES = FALSE)
[13:34:34.776]                       do.call(mapply, args = args)
[13:34:34.776]                     }
[13:34:34.776]                   }
[13:34:34.776]                 }, immediateCondition = function(cond) {
[13:34:34.776]                   save_rds <- function (object, pathname, ...) 
[13:34:34.776]                   {
[13:34:34.776]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:34.776]                     if (file_test("-f", pathname_tmp)) {
[13:34:34.776]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.776]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:34.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.776]                         fi_tmp[["mtime"]])
[13:34:34.776]                     }
[13:34:34.776]                     tryCatch({
[13:34:34.776]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:34.776]                     }, error = function(ex) {
[13:34:34.776]                       msg <- conditionMessage(ex)
[13:34:34.776]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.776]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:34.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.776]                         fi_tmp[["mtime"]], msg)
[13:34:34.776]                       ex$message <- msg
[13:34:34.776]                       stop(ex)
[13:34:34.776]                     })
[13:34:34.776]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:34.776]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:34.776]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:34.776]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.776]                       fi <- file.info(pathname)
[13:34:34.776]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:34.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.776]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:34.776]                         fi[["size"]], fi[["mtime"]])
[13:34:34.776]                       stop(msg)
[13:34:34.776]                     }
[13:34:34.776]                     invisible(pathname)
[13:34:34.776]                   }
[13:34:34.776]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:34.776]                     rootPath = tempdir()) 
[13:34:34.776]                   {
[13:34:34.776]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:34.776]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:34.776]                       tmpdir = path, fileext = ".rds")
[13:34:34.776]                     save_rds(obj, file)
[13:34:34.776]                   }
[13:34:34.776]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:34.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.776]                   {
[13:34:34.776]                     inherits <- base::inherits
[13:34:34.776]                     invokeRestart <- base::invokeRestart
[13:34:34.776]                     is.null <- base::is.null
[13:34:34.776]                     muffled <- FALSE
[13:34:34.776]                     if (inherits(cond, "message")) {
[13:34:34.776]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:34.776]                       if (muffled) 
[13:34:34.776]                         invokeRestart("muffleMessage")
[13:34:34.776]                     }
[13:34:34.776]                     else if (inherits(cond, "warning")) {
[13:34:34.776]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:34.776]                       if (muffled) 
[13:34:34.776]                         invokeRestart("muffleWarning")
[13:34:34.776]                     }
[13:34:34.776]                     else if (inherits(cond, "condition")) {
[13:34:34.776]                       if (!is.null(pattern)) {
[13:34:34.776]                         computeRestarts <- base::computeRestarts
[13:34:34.776]                         grepl <- base::grepl
[13:34:34.776]                         restarts <- computeRestarts(cond)
[13:34:34.776]                         for (restart in restarts) {
[13:34:34.776]                           name <- restart$name
[13:34:34.776]                           if (is.null(name)) 
[13:34:34.776]                             next
[13:34:34.776]                           if (!grepl(pattern, name)) 
[13:34:34.776]                             next
[13:34:34.776]                           invokeRestart(restart)
[13:34:34.776]                           muffled <- TRUE
[13:34:34.776]                           break
[13:34:34.776]                         }
[13:34:34.776]                       }
[13:34:34.776]                     }
[13:34:34.776]                     invisible(muffled)
[13:34:34.776]                   }
[13:34:34.776]                   muffleCondition(cond)
[13:34:34.776]                 })
[13:34:34.776]             }))
[13:34:34.776]             future::FutureResult(value = ...future.value$value, 
[13:34:34.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.776]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.776]                     ...future.globalenv.names))
[13:34:34.776]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.776]         }, condition = base::local({
[13:34:34.776]             c <- base::c
[13:34:34.776]             inherits <- base::inherits
[13:34:34.776]             invokeRestart <- base::invokeRestart
[13:34:34.776]             length <- base::length
[13:34:34.776]             list <- base::list
[13:34:34.776]             seq.int <- base::seq.int
[13:34:34.776]             signalCondition <- base::signalCondition
[13:34:34.776]             sys.calls <- base::sys.calls
[13:34:34.776]             `[[` <- base::`[[`
[13:34:34.776]             `+` <- base::`+`
[13:34:34.776]             `<<-` <- base::`<<-`
[13:34:34.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.776]                   3L)]
[13:34:34.776]             }
[13:34:34.776]             function(cond) {
[13:34:34.776]                 is_error <- inherits(cond, "error")
[13:34:34.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.776]                   NULL)
[13:34:34.776]                 if (is_error) {
[13:34:34.776]                   sessionInformation <- function() {
[13:34:34.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.776]                       search = base::search(), system = base::Sys.info())
[13:34:34.776]                   }
[13:34:34.776]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.776]                     cond$call), session = sessionInformation(), 
[13:34:34.776]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.776]                   signalCondition(cond)
[13:34:34.776]                 }
[13:34:34.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.776]                 "immediateCondition"))) {
[13:34:34.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.776]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.776]                   if (TRUE && !signal) {
[13:34:34.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.776]                     {
[13:34:34.776]                       inherits <- base::inherits
[13:34:34.776]                       invokeRestart <- base::invokeRestart
[13:34:34.776]                       is.null <- base::is.null
[13:34:34.776]                       muffled <- FALSE
[13:34:34.776]                       if (inherits(cond, "message")) {
[13:34:34.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.776]                         if (muffled) 
[13:34:34.776]                           invokeRestart("muffleMessage")
[13:34:34.776]                       }
[13:34:34.776]                       else if (inherits(cond, "warning")) {
[13:34:34.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.776]                         if (muffled) 
[13:34:34.776]                           invokeRestart("muffleWarning")
[13:34:34.776]                       }
[13:34:34.776]                       else if (inherits(cond, "condition")) {
[13:34:34.776]                         if (!is.null(pattern)) {
[13:34:34.776]                           computeRestarts <- base::computeRestarts
[13:34:34.776]                           grepl <- base::grepl
[13:34:34.776]                           restarts <- computeRestarts(cond)
[13:34:34.776]                           for (restart in restarts) {
[13:34:34.776]                             name <- restart$name
[13:34:34.776]                             if (is.null(name)) 
[13:34:34.776]                               next
[13:34:34.776]                             if (!grepl(pattern, name)) 
[13:34:34.776]                               next
[13:34:34.776]                             invokeRestart(restart)
[13:34:34.776]                             muffled <- TRUE
[13:34:34.776]                             break
[13:34:34.776]                           }
[13:34:34.776]                         }
[13:34:34.776]                       }
[13:34:34.776]                       invisible(muffled)
[13:34:34.776]                     }
[13:34:34.776]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.776]                   }
[13:34:34.776]                 }
[13:34:34.776]                 else {
[13:34:34.776]                   if (TRUE) {
[13:34:34.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.776]                     {
[13:34:34.776]                       inherits <- base::inherits
[13:34:34.776]                       invokeRestart <- base::invokeRestart
[13:34:34.776]                       is.null <- base::is.null
[13:34:34.776]                       muffled <- FALSE
[13:34:34.776]                       if (inherits(cond, "message")) {
[13:34:34.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.776]                         if (muffled) 
[13:34:34.776]                           invokeRestart("muffleMessage")
[13:34:34.776]                       }
[13:34:34.776]                       else if (inherits(cond, "warning")) {
[13:34:34.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.776]                         if (muffled) 
[13:34:34.776]                           invokeRestart("muffleWarning")
[13:34:34.776]                       }
[13:34:34.776]                       else if (inherits(cond, "condition")) {
[13:34:34.776]                         if (!is.null(pattern)) {
[13:34:34.776]                           computeRestarts <- base::computeRestarts
[13:34:34.776]                           grepl <- base::grepl
[13:34:34.776]                           restarts <- computeRestarts(cond)
[13:34:34.776]                           for (restart in restarts) {
[13:34:34.776]                             name <- restart$name
[13:34:34.776]                             if (is.null(name)) 
[13:34:34.776]                               next
[13:34:34.776]                             if (!grepl(pattern, name)) 
[13:34:34.776]                               next
[13:34:34.776]                             invokeRestart(restart)
[13:34:34.776]                             muffled <- TRUE
[13:34:34.776]                             break
[13:34:34.776]                           }
[13:34:34.776]                         }
[13:34:34.776]                       }
[13:34:34.776]                       invisible(muffled)
[13:34:34.776]                     }
[13:34:34.776]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.776]                   }
[13:34:34.776]                 }
[13:34:34.776]             }
[13:34:34.776]         }))
[13:34:34.776]     }, error = function(ex) {
[13:34:34.776]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.776]                 ...future.rng), started = ...future.startTime, 
[13:34:34.776]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.776]             version = "1.8"), class = "FutureResult")
[13:34:34.776]     }, finally = {
[13:34:34.776]         if (!identical(...future.workdir, getwd())) 
[13:34:34.776]             setwd(...future.workdir)
[13:34:34.776]         {
[13:34:34.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.776]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.776]             }
[13:34:34.776]             base::options(...future.oldOptions)
[13:34:34.776]             if (.Platform$OS.type == "windows") {
[13:34:34.776]                 old_names <- names(...future.oldEnvVars)
[13:34:34.776]                 envs <- base::Sys.getenv()
[13:34:34.776]                 names <- names(envs)
[13:34:34.776]                 common <- intersect(names, old_names)
[13:34:34.776]                 added <- setdiff(names, old_names)
[13:34:34.776]                 removed <- setdiff(old_names, names)
[13:34:34.776]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.776]                   envs[common]]
[13:34:34.776]                 NAMES <- toupper(changed)
[13:34:34.776]                 args <- list()
[13:34:34.776]                 for (kk in seq_along(NAMES)) {
[13:34:34.776]                   name <- changed[[kk]]
[13:34:34.776]                   NAME <- NAMES[[kk]]
[13:34:34.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.776]                     next
[13:34:34.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.776]                 }
[13:34:34.776]                 NAMES <- toupper(added)
[13:34:34.776]                 for (kk in seq_along(NAMES)) {
[13:34:34.776]                   name <- added[[kk]]
[13:34:34.776]                   NAME <- NAMES[[kk]]
[13:34:34.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.776]                     next
[13:34:34.776]                   args[[name]] <- ""
[13:34:34.776]                 }
[13:34:34.776]                 NAMES <- toupper(removed)
[13:34:34.776]                 for (kk in seq_along(NAMES)) {
[13:34:34.776]                   name <- removed[[kk]]
[13:34:34.776]                   NAME <- NAMES[[kk]]
[13:34:34.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.776]                     next
[13:34:34.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.776]                 }
[13:34:34.776]                 if (length(args) > 0) 
[13:34:34.776]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.776]             }
[13:34:34.776]             else {
[13:34:34.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.776]             }
[13:34:34.776]             {
[13:34:34.776]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.776]                   0L) {
[13:34:34.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.776]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.776]                   base::options(opts)
[13:34:34.776]                 }
[13:34:34.776]                 {
[13:34:34.776]                   {
[13:34:34.776]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:34.776]                     NULL
[13:34:34.776]                   }
[13:34:34.776]                   options(future.plan = NULL)
[13:34:34.776]                   if (is.na(NA_character_)) 
[13:34:34.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.776]                     .init = FALSE)
[13:34:34.776]                 }
[13:34:34.776]             }
[13:34:34.776]         }
[13:34:34.776]     })
[13:34:34.776]     if (TRUE) {
[13:34:34.776]         base::sink(type = "output", split = FALSE)
[13:34:34.776]         if (TRUE) {
[13:34:34.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.776]         }
[13:34:34.776]         else {
[13:34:34.776]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.776]         }
[13:34:34.776]         base::close(...future.stdout)
[13:34:34.776]         ...future.stdout <- NULL
[13:34:34.776]     }
[13:34:34.776]     ...future.result$conditions <- ...future.conditions
[13:34:34.776]     ...future.result$finished <- base::Sys.time()
[13:34:34.776]     ...future.result
[13:34:34.776] }
[13:34:34.778] assign_globals() ...
[13:34:34.778] List of 5
[13:34:34.778]  $ ...future.FUN            :function (x, ...)  
[13:34:34.778]  $ MoreArgs                 : NULL
[13:34:34.778]  $ ...future.elements_ii    :List of 2
[13:34:34.778]   ..$ :List of 2
[13:34:34.778]   .. ..$ : int 1
[13:34:34.778]   .. ..$ : int 2
[13:34:34.778]   ..$ :List of 2
[13:34:34.778]   .. ..$ : int 4
[13:34:34.778]   .. ..$ : int 3
[13:34:34.778]  $ ...future.seeds_ii       : NULL
[13:34:34.778]  $ ...future.globals.maxSize: NULL
[13:34:34.778]  - attr(*, "where")=List of 5
[13:34:34.778]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.778]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.778]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.778]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.778]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.778]  - attr(*, "resolved")= logi FALSE
[13:34:34.778]  - attr(*, "total_size")= num 280
[13:34:34.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.778]  - attr(*, "already-done")= logi TRUE
[13:34:34.783] - copied ‘...future.FUN’ to environment
[13:34:34.784] - copied ‘MoreArgs’ to environment
[13:34:34.784] - copied ‘...future.elements_ii’ to environment
[13:34:34.784] - copied ‘...future.seeds_ii’ to environment
[13:34:34.784] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.784] assign_globals() ... done
[13:34:34.784] requestCore(): workers = 2
[13:34:34.787] MulticoreFuture started
[13:34:34.788] - Launch lazy future ... done
[13:34:34.788] plan(): Setting new future strategy stack:
[13:34:34.788] run() for ‘MulticoreFuture’ ... done
[13:34:34.788] Created future:
[13:34:34.788] List of future strategies:
[13:34:34.788] 1. sequential:
[13:34:34.788]    - args: function (..., envir = parent.frame())
[13:34:34.788]    - tweaked: FALSE
[13:34:34.788]    - call: NULL
[13:34:34.789] plan(): nbrOfWorkers() = 1
[13:34:34.791] plan(): Setting new future strategy stack:
[13:34:34.791] List of future strategies:
[13:34:34.791] 1. multicore:
[13:34:34.791]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:34.791]    - tweaked: FALSE
[13:34:34.791]    - call: plan(strategy)
[13:34:34.803] plan(): nbrOfWorkers() = 2
[13:34:34.789] MulticoreFuture:
[13:34:34.789] Label: ‘future_mapply-1’
[13:34:34.789] Expression:
[13:34:34.789] {
[13:34:34.789]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.789]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.789]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.789]         on.exit(options(oopts), add = TRUE)
[13:34:34.789]     }
[13:34:34.789]     {
[13:34:34.789]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.789]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.789]         do.call(mapply, args = args)
[13:34:34.789]     }
[13:34:34.789] }
[13:34:34.789] Lazy evaluation: FALSE
[13:34:34.789] Asynchronous evaluation: TRUE
[13:34:34.789] Local evaluation: TRUE
[13:34:34.789] Environment: R_GlobalEnv
[13:34:34.789] Capture standard output: TRUE
[13:34:34.789] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.789] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.789] Packages: <none>
[13:34:34.789] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.789] Resolved: FALSE
[13:34:34.789] Value: <not collected>
[13:34:34.789] Conditions captured: <none>
[13:34:34.789] Early signaling: FALSE
[13:34:34.789] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.789] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:34.806] Chunk #1 of 2 ... DONE
[13:34:34.806] Chunk #2 of 2 ...
[13:34:34.807]  - Finding globals in '...' for chunk #2 ...
[13:34:34.807] getGlobalsAndPackages() ...
[13:34:34.807] Searching for globals...
[13:34:34.808] 
[13:34:34.808] Searching for globals ... DONE
[13:34:34.809] - globals: [0] <none>
[13:34:34.809] getGlobalsAndPackages() ... DONE
[13:34:34.809]    + additional globals found: [n=0] 
[13:34:34.809]    + additional namespaces needed: [n=0] 
[13:34:34.809]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:34.810]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:34.810]  - seeds: <none>
[13:34:34.810]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.811] getGlobalsAndPackages() ...
[13:34:34.811] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.811] Resolving globals: FALSE
[13:34:34.812] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:34.813] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.813] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.814] 
[13:34:34.814] getGlobalsAndPackages() ... DONE
[13:34:34.814] run() for ‘Future’ ...
[13:34:34.814] - state: ‘created’
[13:34:34.815] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:34.819] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:34.819] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:34.819]   - Field: ‘label’
[13:34:34.820]   - Field: ‘local’
[13:34:34.820]   - Field: ‘owner’
[13:34:34.820]   - Field: ‘envir’
[13:34:34.820]   - Field: ‘workers’
[13:34:34.821]   - Field: ‘packages’
[13:34:34.821]   - Field: ‘gc’
[13:34:34.821]   - Field: ‘job’
[13:34:34.821]   - Field: ‘conditions’
[13:34:34.821]   - Field: ‘expr’
[13:34:34.821]   - Field: ‘uuid’
[13:34:34.821]   - Field: ‘seed’
[13:34:34.821]   - Field: ‘version’
[13:34:34.822]   - Field: ‘result’
[13:34:34.822]   - Field: ‘asynchronous’
[13:34:34.822]   - Field: ‘calls’
[13:34:34.822]   - Field: ‘globals’
[13:34:34.822]   - Field: ‘stdout’
[13:34:34.822]   - Field: ‘earlySignal’
[13:34:34.823]   - Field: ‘lazy’
[13:34:34.823]   - Field: ‘state’
[13:34:34.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:34.823] - Launch lazy future ...
[13:34:34.823] Packages needed by the future expression (n = 0): <none>
[13:34:34.824] Packages needed by future strategies (n = 0): <none>
[13:34:34.824] {
[13:34:34.824]     {
[13:34:34.824]         {
[13:34:34.824]             ...future.startTime <- base::Sys.time()
[13:34:34.824]             {
[13:34:34.824]                 {
[13:34:34.824]                   {
[13:34:34.824]                     {
[13:34:34.824]                       base::local({
[13:34:34.824]                         has_future <- base::requireNamespace("future", 
[13:34:34.824]                           quietly = TRUE)
[13:34:34.824]                         if (has_future) {
[13:34:34.824]                           ns <- base::getNamespace("future")
[13:34:34.824]                           version <- ns[[".package"]][["version"]]
[13:34:34.824]                           if (is.null(version)) 
[13:34:34.824]                             version <- utils::packageVersion("future")
[13:34:34.824]                         }
[13:34:34.824]                         else {
[13:34:34.824]                           version <- NULL
[13:34:34.824]                         }
[13:34:34.824]                         if (!has_future || version < "1.8.0") {
[13:34:34.824]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.824]                             "", base::R.version$version.string), 
[13:34:34.824]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:34.824]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.824]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.824]                               "release", "version")], collapse = " "), 
[13:34:34.824]                             hostname = base::Sys.info()[["nodename"]])
[13:34:34.824]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.824]                             info)
[13:34:34.824]                           info <- base::paste(info, collapse = "; ")
[13:34:34.824]                           if (!has_future) {
[13:34:34.824]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.824]                               info)
[13:34:34.824]                           }
[13:34:34.824]                           else {
[13:34:34.824]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.824]                               info, version)
[13:34:34.824]                           }
[13:34:34.824]                           base::stop(msg)
[13:34:34.824]                         }
[13:34:34.824]                       })
[13:34:34.824]                     }
[13:34:34.824]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:34.824]                     base::options(mc.cores = 1L)
[13:34:34.824]                   }
[13:34:34.824]                   ...future.strategy.old <- future::plan("list")
[13:34:34.824]                   options(future.plan = NULL)
[13:34:34.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.824]                 }
[13:34:34.824]                 ...future.workdir <- getwd()
[13:34:34.824]             }
[13:34:34.824]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.824]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.824]         }
[13:34:34.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.824]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:34.824]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.824]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.824]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.824]             base::names(...future.oldOptions))
[13:34:34.824]     }
[13:34:34.824]     if (FALSE) {
[13:34:34.824]     }
[13:34:34.824]     else {
[13:34:34.824]         if (TRUE) {
[13:34:34.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.824]                 open = "w")
[13:34:34.824]         }
[13:34:34.824]         else {
[13:34:34.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.824]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.824]         }
[13:34:34.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.824]             base::sink(type = "output", split = FALSE)
[13:34:34.824]             base::close(...future.stdout)
[13:34:34.824]         }, add = TRUE)
[13:34:34.824]     }
[13:34:34.824]     ...future.frame <- base::sys.nframe()
[13:34:34.824]     ...future.conditions <- base::list()
[13:34:34.824]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.824]     if (FALSE) {
[13:34:34.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.824]     }
[13:34:34.824]     ...future.result <- base::tryCatch({
[13:34:34.824]         base::withCallingHandlers({
[13:34:34.824]             ...future.value <- base::withVisible(base::local({
[13:34:34.824]                 withCallingHandlers({
[13:34:34.824]                   {
[13:34:34.824]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.824]                     if (!identical(...future.globals.maxSize.org, 
[13:34:34.824]                       ...future.globals.maxSize)) {
[13:34:34.824]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.824]                       on.exit(options(oopts), add = TRUE)
[13:34:34.824]                     }
[13:34:34.824]                     {
[13:34:34.824]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.824]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.824]                         USE.NAMES = FALSE)
[13:34:34.824]                       do.call(mapply, args = args)
[13:34:34.824]                     }
[13:34:34.824]                   }
[13:34:34.824]                 }, immediateCondition = function(cond) {
[13:34:34.824]                   save_rds <- function (object, pathname, ...) 
[13:34:34.824]                   {
[13:34:34.824]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:34.824]                     if (file_test("-f", pathname_tmp)) {
[13:34:34.824]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.824]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:34.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.824]                         fi_tmp[["mtime"]])
[13:34:34.824]                     }
[13:34:34.824]                     tryCatch({
[13:34:34.824]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:34.824]                     }, error = function(ex) {
[13:34:34.824]                       msg <- conditionMessage(ex)
[13:34:34.824]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.824]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:34.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.824]                         fi_tmp[["mtime"]], msg)
[13:34:34.824]                       ex$message <- msg
[13:34:34.824]                       stop(ex)
[13:34:34.824]                     })
[13:34:34.824]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:34.824]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:34.824]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:34.824]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.824]                       fi <- file.info(pathname)
[13:34:34.824]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:34.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.824]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:34.824]                         fi[["size"]], fi[["mtime"]])
[13:34:34.824]                       stop(msg)
[13:34:34.824]                     }
[13:34:34.824]                     invisible(pathname)
[13:34:34.824]                   }
[13:34:34.824]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:34.824]                     rootPath = tempdir()) 
[13:34:34.824]                   {
[13:34:34.824]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:34.824]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:34.824]                       tmpdir = path, fileext = ".rds")
[13:34:34.824]                     save_rds(obj, file)
[13:34:34.824]                   }
[13:34:34.824]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:34.824]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.824]                   {
[13:34:34.824]                     inherits <- base::inherits
[13:34:34.824]                     invokeRestart <- base::invokeRestart
[13:34:34.824]                     is.null <- base::is.null
[13:34:34.824]                     muffled <- FALSE
[13:34:34.824]                     if (inherits(cond, "message")) {
[13:34:34.824]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:34.824]                       if (muffled) 
[13:34:34.824]                         invokeRestart("muffleMessage")
[13:34:34.824]                     }
[13:34:34.824]                     else if (inherits(cond, "warning")) {
[13:34:34.824]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:34.824]                       if (muffled) 
[13:34:34.824]                         invokeRestart("muffleWarning")
[13:34:34.824]                     }
[13:34:34.824]                     else if (inherits(cond, "condition")) {
[13:34:34.824]                       if (!is.null(pattern)) {
[13:34:34.824]                         computeRestarts <- base::computeRestarts
[13:34:34.824]                         grepl <- base::grepl
[13:34:34.824]                         restarts <- computeRestarts(cond)
[13:34:34.824]                         for (restart in restarts) {
[13:34:34.824]                           name <- restart$name
[13:34:34.824]                           if (is.null(name)) 
[13:34:34.824]                             next
[13:34:34.824]                           if (!grepl(pattern, name)) 
[13:34:34.824]                             next
[13:34:34.824]                           invokeRestart(restart)
[13:34:34.824]                           muffled <- TRUE
[13:34:34.824]                           break
[13:34:34.824]                         }
[13:34:34.824]                       }
[13:34:34.824]                     }
[13:34:34.824]                     invisible(muffled)
[13:34:34.824]                   }
[13:34:34.824]                   muffleCondition(cond)
[13:34:34.824]                 })
[13:34:34.824]             }))
[13:34:34.824]             future::FutureResult(value = ...future.value$value, 
[13:34:34.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.824]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.824]                     ...future.globalenv.names))
[13:34:34.824]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.824]         }, condition = base::local({
[13:34:34.824]             c <- base::c
[13:34:34.824]             inherits <- base::inherits
[13:34:34.824]             invokeRestart <- base::invokeRestart
[13:34:34.824]             length <- base::length
[13:34:34.824]             list <- base::list
[13:34:34.824]             seq.int <- base::seq.int
[13:34:34.824]             signalCondition <- base::signalCondition
[13:34:34.824]             sys.calls <- base::sys.calls
[13:34:34.824]             `[[` <- base::`[[`
[13:34:34.824]             `+` <- base::`+`
[13:34:34.824]             `<<-` <- base::`<<-`
[13:34:34.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.824]                   3L)]
[13:34:34.824]             }
[13:34:34.824]             function(cond) {
[13:34:34.824]                 is_error <- inherits(cond, "error")
[13:34:34.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.824]                   NULL)
[13:34:34.824]                 if (is_error) {
[13:34:34.824]                   sessionInformation <- function() {
[13:34:34.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.824]                       search = base::search(), system = base::Sys.info())
[13:34:34.824]                   }
[13:34:34.824]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.824]                     cond$call), session = sessionInformation(), 
[13:34:34.824]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.824]                   signalCondition(cond)
[13:34:34.824]                 }
[13:34:34.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.824]                 "immediateCondition"))) {
[13:34:34.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.824]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.824]                   if (TRUE && !signal) {
[13:34:34.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.824]                     {
[13:34:34.824]                       inherits <- base::inherits
[13:34:34.824]                       invokeRestart <- base::invokeRestart
[13:34:34.824]                       is.null <- base::is.null
[13:34:34.824]                       muffled <- FALSE
[13:34:34.824]                       if (inherits(cond, "message")) {
[13:34:34.824]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.824]                         if (muffled) 
[13:34:34.824]                           invokeRestart("muffleMessage")
[13:34:34.824]                       }
[13:34:34.824]                       else if (inherits(cond, "warning")) {
[13:34:34.824]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.824]                         if (muffled) 
[13:34:34.824]                           invokeRestart("muffleWarning")
[13:34:34.824]                       }
[13:34:34.824]                       else if (inherits(cond, "condition")) {
[13:34:34.824]                         if (!is.null(pattern)) {
[13:34:34.824]                           computeRestarts <- base::computeRestarts
[13:34:34.824]                           grepl <- base::grepl
[13:34:34.824]                           restarts <- computeRestarts(cond)
[13:34:34.824]                           for (restart in restarts) {
[13:34:34.824]                             name <- restart$name
[13:34:34.824]                             if (is.null(name)) 
[13:34:34.824]                               next
[13:34:34.824]                             if (!grepl(pattern, name)) 
[13:34:34.824]                               next
[13:34:34.824]                             invokeRestart(restart)
[13:34:34.824]                             muffled <- TRUE
[13:34:34.824]                             break
[13:34:34.824]                           }
[13:34:34.824]                         }
[13:34:34.824]                       }
[13:34:34.824]                       invisible(muffled)
[13:34:34.824]                     }
[13:34:34.824]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.824]                   }
[13:34:34.824]                 }
[13:34:34.824]                 else {
[13:34:34.824]                   if (TRUE) {
[13:34:34.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.824]                     {
[13:34:34.824]                       inherits <- base::inherits
[13:34:34.824]                       invokeRestart <- base::invokeRestart
[13:34:34.824]                       is.null <- base::is.null
[13:34:34.824]                       muffled <- FALSE
[13:34:34.824]                       if (inherits(cond, "message")) {
[13:34:34.824]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.824]                         if (muffled) 
[13:34:34.824]                           invokeRestart("muffleMessage")
[13:34:34.824]                       }
[13:34:34.824]                       else if (inherits(cond, "warning")) {
[13:34:34.824]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.824]                         if (muffled) 
[13:34:34.824]                           invokeRestart("muffleWarning")
[13:34:34.824]                       }
[13:34:34.824]                       else if (inherits(cond, "condition")) {
[13:34:34.824]                         if (!is.null(pattern)) {
[13:34:34.824]                           computeRestarts <- base::computeRestarts
[13:34:34.824]                           grepl <- base::grepl
[13:34:34.824]                           restarts <- computeRestarts(cond)
[13:34:34.824]                           for (restart in restarts) {
[13:34:34.824]                             name <- restart$name
[13:34:34.824]                             if (is.null(name)) 
[13:34:34.824]                               next
[13:34:34.824]                             if (!grepl(pattern, name)) 
[13:34:34.824]                               next
[13:34:34.824]                             invokeRestart(restart)
[13:34:34.824]                             muffled <- TRUE
[13:34:34.824]                             break
[13:34:34.824]                           }
[13:34:34.824]                         }
[13:34:34.824]                       }
[13:34:34.824]                       invisible(muffled)
[13:34:34.824]                     }
[13:34:34.824]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.824]                   }
[13:34:34.824]                 }
[13:34:34.824]             }
[13:34:34.824]         }))
[13:34:34.824]     }, error = function(ex) {
[13:34:34.824]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.824]                 ...future.rng), started = ...future.startTime, 
[13:34:34.824]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.824]             version = "1.8"), class = "FutureResult")
[13:34:34.824]     }, finally = {
[13:34:34.824]         if (!identical(...future.workdir, getwd())) 
[13:34:34.824]             setwd(...future.workdir)
[13:34:34.824]         {
[13:34:34.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.824]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.824]             }
[13:34:34.824]             base::options(...future.oldOptions)
[13:34:34.824]             if (.Platform$OS.type == "windows") {
[13:34:34.824]                 old_names <- names(...future.oldEnvVars)
[13:34:34.824]                 envs <- base::Sys.getenv()
[13:34:34.824]                 names <- names(envs)
[13:34:34.824]                 common <- intersect(names, old_names)
[13:34:34.824]                 added <- setdiff(names, old_names)
[13:34:34.824]                 removed <- setdiff(old_names, names)
[13:34:34.824]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.824]                   envs[common]]
[13:34:34.824]                 NAMES <- toupper(changed)
[13:34:34.824]                 args <- list()
[13:34:34.824]                 for (kk in seq_along(NAMES)) {
[13:34:34.824]                   name <- changed[[kk]]
[13:34:34.824]                   NAME <- NAMES[[kk]]
[13:34:34.824]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.824]                     next
[13:34:34.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.824]                 }
[13:34:34.824]                 NAMES <- toupper(added)
[13:34:34.824]                 for (kk in seq_along(NAMES)) {
[13:34:34.824]                   name <- added[[kk]]
[13:34:34.824]                   NAME <- NAMES[[kk]]
[13:34:34.824]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.824]                     next
[13:34:34.824]                   args[[name]] <- ""
[13:34:34.824]                 }
[13:34:34.824]                 NAMES <- toupper(removed)
[13:34:34.824]                 for (kk in seq_along(NAMES)) {
[13:34:34.824]                   name <- removed[[kk]]
[13:34:34.824]                   NAME <- NAMES[[kk]]
[13:34:34.824]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.824]                     next
[13:34:34.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.824]                 }
[13:34:34.824]                 if (length(args) > 0) 
[13:34:34.824]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.824]             }
[13:34:34.824]             else {
[13:34:34.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.824]             }
[13:34:34.824]             {
[13:34:34.824]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.824]                   0L) {
[13:34:34.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.824]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.824]                   base::options(opts)
[13:34:34.824]                 }
[13:34:34.824]                 {
[13:34:34.824]                   {
[13:34:34.824]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:34.824]                     NULL
[13:34:34.824]                   }
[13:34:34.824]                   options(future.plan = NULL)
[13:34:34.824]                   if (is.na(NA_character_)) 
[13:34:34.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.824]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.824]                     .init = FALSE)
[13:34:34.824]                 }
[13:34:34.824]             }
[13:34:34.824]         }
[13:34:34.824]     })
[13:34:34.824]     if (TRUE) {
[13:34:34.824]         base::sink(type = "output", split = FALSE)
[13:34:34.824]         if (TRUE) {
[13:34:34.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.824]         }
[13:34:34.824]         else {
[13:34:34.824]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.824]         }
[13:34:34.824]         base::close(...future.stdout)
[13:34:34.824]         ...future.stdout <- NULL
[13:34:34.824]     }
[13:34:34.824]     ...future.result$conditions <- ...future.conditions
[13:34:34.824]     ...future.result$finished <- base::Sys.time()
[13:34:34.824]     ...future.result
[13:34:34.824] }
[13:34:34.827] assign_globals() ...
[13:34:34.827] List of 5
[13:34:34.827]  $ ...future.FUN            :function (x, ...)  
[13:34:34.827]  $ MoreArgs                 : NULL
[13:34:34.827]  $ ...future.elements_ii    :List of 2
[13:34:34.827]   ..$ :List of 2
[13:34:34.827]   .. ..$ : int 3
[13:34:34.827]   .. ..$ : int 4
[13:34:34.827]   ..$ :List of 2
[13:34:34.827]   .. ..$ : int 2
[13:34:34.827]   .. ..$ : int 1
[13:34:34.827]  $ ...future.seeds_ii       : NULL
[13:34:34.827]  $ ...future.globals.maxSize: NULL
[13:34:34.827]  - attr(*, "where")=List of 5
[13:34:34.827]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.827]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.827]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.827]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.827]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.827]  - attr(*, "resolved")= logi FALSE
[13:34:34.827]  - attr(*, "total_size")= num 280
[13:34:34.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.827]  - attr(*, "already-done")= logi TRUE
[13:34:34.834] - copied ‘...future.FUN’ to environment
[13:34:34.834] - copied ‘MoreArgs’ to environment
[13:34:34.834] - copied ‘...future.elements_ii’ to environment
[13:34:34.834] - copied ‘...future.seeds_ii’ to environment
[13:34:34.835] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.835] assign_globals() ... done
[13:34:34.835] requestCore(): workers = 2
[13:34:34.840] MulticoreFuture started
[13:34:34.840] - Launch lazy future ... done
[13:34:34.840] run() for ‘MulticoreFuture’ ... done
[13:34:34.841] Created future:
[13:34:34.841] plan(): Setting new future strategy stack:
[13:34:34.841] List of future strategies:
[13:34:34.841] 1. sequential:
[13:34:34.841]    - args: function (..., envir = parent.frame())
[13:34:34.841]    - tweaked: FALSE
[13:34:34.841]    - call: NULL
[13:34:34.842] plan(): nbrOfWorkers() = 1
[13:34:34.844] plan(): Setting new future strategy stack:
[13:34:34.844] List of future strategies:
[13:34:34.844] 1. multicore:
[13:34:34.844]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:34.844]    - tweaked: FALSE
[13:34:34.844]    - call: plan(strategy)
[13:34:34.841] MulticoreFuture:
[13:34:34.841] Label: ‘future_mapply-2’
[13:34:34.841] Expression:
[13:34:34.841] {
[13:34:34.841]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.841]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.841]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.841]         on.exit(options(oopts), add = TRUE)
[13:34:34.841]     }
[13:34:34.841]     {
[13:34:34.841]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.841]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.841]         do.call(mapply, args = args)
[13:34:34.841]     }
[13:34:34.841] }
[13:34:34.841] Lazy evaluation: FALSE
[13:34:34.841] Asynchronous evaluation: TRUE
[13:34:34.841] Local evaluation: TRUE
[13:34:34.841] Environment: R_GlobalEnv
[13:34:34.841] Capture standard output: TRUE
[13:34:34.841] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.841] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.841] Packages: <none>
[13:34:34.841] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.841] Resolved: FALSE
[13:34:34.841] Value: <not collected>
[13:34:34.841] Conditions captured: <none>
[13:34:34.841] Early signaling: FALSE
[13:34:34.841] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.841] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:34.853] Chunk #2 of 2 ... DONE
[13:34:34.854] Launching 2 futures (chunks) ... DONE
[13:34:34.854] Resolving 2 futures (chunks) ...
[13:34:34.854] resolve() on list ...
[13:34:34.854]  recursive: 0
[13:34:34.855] plan(): nbrOfWorkers() = 2
[13:34:34.854]  length: 2
[13:34:34.857] 
[13:34:34.858] Future #1
[13:34:34.859] result() for MulticoreFuture ...
[13:34:34.861] result() for MulticoreFuture ...
[13:34:34.861] result() for MulticoreFuture ... done
[13:34:34.862] result() for MulticoreFuture ... done
[13:34:34.862] result() for MulticoreFuture ...
[13:34:34.862] result() for MulticoreFuture ... done
[13:34:34.862] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:34.863] - nx: 2
[13:34:34.863] - relay: TRUE
[13:34:34.863] - stdout: TRUE
[13:34:34.863] - signal: TRUE
[13:34:34.864] - resignal: FALSE
[13:34:34.864] - force: TRUE
[13:34:34.864] - relayed: [n=2] FALSE, FALSE
[13:34:34.864] - queued futures: [n=2] FALSE, FALSE
[13:34:34.864]  - until=1
[13:34:34.865]  - relaying element #1
[13:34:34.865] result() for MulticoreFuture ...
[13:34:34.865] result() for MulticoreFuture ... done
[13:34:34.865] result() for MulticoreFuture ...
[13:34:34.866] result() for MulticoreFuture ... done
[13:34:34.866] result() for MulticoreFuture ...
[13:34:34.866] result() for MulticoreFuture ... done
[13:34:34.866] result() for MulticoreFuture ...
[13:34:34.866] result() for MulticoreFuture ... done
[13:34:34.866] - relayed: [n=2] TRUE, FALSE
[13:34:34.867] - queued futures: [n=2] TRUE, FALSE
[13:34:34.867] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:34.867]  length: 1 (resolved future 1)
[13:34:34.867] Future #2
[13:34:34.867] result() for MulticoreFuture ...
[13:34:34.868] result() for MulticoreFuture ...
[13:34:34.868] result() for MulticoreFuture ... done
[13:34:34.868] result() for MulticoreFuture ... done
[13:34:34.868] result() for MulticoreFuture ...
[13:34:34.869] result() for MulticoreFuture ... done
[13:34:34.869] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:34.869] - nx: 2
[13:34:34.869] - relay: TRUE
[13:34:34.869] - stdout: TRUE
[13:34:34.869] - signal: TRUE
[13:34:34.869] - resignal: FALSE
[13:34:34.870] - force: TRUE
[13:34:34.870] - relayed: [n=2] TRUE, FALSE
[13:34:34.870] - queued futures: [n=2] TRUE, FALSE
[13:34:34.870]  - until=2
[13:34:34.870]  - relaying element #2
[13:34:34.870] result() for MulticoreFuture ...
[13:34:34.870] result() for MulticoreFuture ... done
[13:34:34.871] result() for MulticoreFuture ...
[13:34:34.871] result() for MulticoreFuture ... done
[13:34:34.871] result() for MulticoreFuture ...
[13:34:34.871] result() for MulticoreFuture ... done
[13:34:34.871] result() for MulticoreFuture ...
[13:34:34.871] result() for MulticoreFuture ... done
[13:34:34.871] - relayed: [n=2] TRUE, TRUE
[13:34:34.871] - queued futures: [n=2] TRUE, TRUE
[13:34:34.871] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:34.872]  length: 0 (resolved future 2)
[13:34:34.872] Relaying remaining futures
[13:34:34.872] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.872] - nx: 2
[13:34:34.872] - relay: TRUE
[13:34:34.872] - stdout: TRUE
[13:34:34.872] - signal: TRUE
[13:34:34.872] - resignal: FALSE
[13:34:34.872] - force: TRUE
[13:34:34.872] - relayed: [n=2] TRUE, TRUE
[13:34:34.873] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:34.873] - relayed: [n=2] TRUE, TRUE
[13:34:34.873] - queued futures: [n=2] TRUE, TRUE
[13:34:34.873] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.873] resolve() on list ... DONE
[13:34:34.873] result() for MulticoreFuture ...
[13:34:34.873] result() for MulticoreFuture ... done
[13:34:34.873] result() for MulticoreFuture ...
[13:34:34.873] result() for MulticoreFuture ... done
[13:34:34.874] result() for MulticoreFuture ...
[13:34:34.874] result() for MulticoreFuture ... done
[13:34:34.874] result() for MulticoreFuture ...
[13:34:34.874] result() for MulticoreFuture ... done
[13:34:34.874]  - Number of value chunks collected: 2
[13:34:34.874] Resolving 2 futures (chunks) ... DONE
[13:34:34.874] Reducing values from 2 chunks ...
[13:34:34.874]  - Number of values collected after concatenation: 4
[13:34:34.875]  - Number of values expected: 4
[13:34:34.875] Reducing values from 2 chunks ... DONE
[13:34:34.875] future_mapply() ... DONE
[13:34:34.875] future_mapply() ...
[13:34:34.879] Number of chunks: 2
[13:34:34.879] getGlobalsAndPackagesXApply() ...
[13:34:34.879]  - future.globals: TRUE
[13:34:34.880] getGlobalsAndPackages() ...
[13:34:34.880] Searching for globals...
[13:34:34.881] - globals found: [1] ‘FUN’
[13:34:34.881] Searching for globals ... DONE
[13:34:34.881] Resolving globals: FALSE
[13:34:34.881] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:34.882] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:34.882] - globals: [1] ‘FUN’
[13:34:34.882] 
[13:34:34.882] getGlobalsAndPackages() ... DONE
[13:34:34.882]  - globals found/used: [n=1] ‘FUN’
[13:34:34.882]  - needed namespaces: [n=0] 
[13:34:34.882] Finding globals ... DONE
[13:34:34.883] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.883] List of 2
[13:34:34.883]  $ ...future.FUN:function (x, ...)  
[13:34:34.883]  $ MoreArgs     : NULL
[13:34:34.883]  - attr(*, "where")=List of 2
[13:34:34.883]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.883]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.883]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.883]  - attr(*, "resolved")= logi FALSE
[13:34:34.883]  - attr(*, "total_size")= num NA
[13:34:34.885] Packages to be attached in all futures: [n=0] 
[13:34:34.886] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.886] Number of futures (= number of chunks): 2
[13:34:34.886] Launching 2 futures (chunks) ...
[13:34:34.886] Chunk #1 of 2 ...
[13:34:34.886]  - Finding globals in '...' for chunk #1 ...
[13:34:34.886] getGlobalsAndPackages() ...
[13:34:34.886] Searching for globals...
[13:34:34.887] 
[13:34:34.887] Searching for globals ... DONE
[13:34:34.887] - globals: [0] <none>
[13:34:34.887] getGlobalsAndPackages() ... DONE
[13:34:34.887]    + additional globals found: [n=0] 
[13:34:34.887]    + additional namespaces needed: [n=0] 
[13:34:34.887]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.888]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:34.888]  - seeds: <none>
[13:34:34.888]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.888] getGlobalsAndPackages() ...
[13:34:34.888] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.888] Resolving globals: FALSE
[13:34:34.889] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:34.889] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.889] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.889] 
[13:34:34.889] getGlobalsAndPackages() ... DONE
[13:34:34.892] run() for ‘Future’ ...
[13:34:34.892] - state: ‘created’
[13:34:34.892] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:34.896] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:34.896] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:34.896]   - Field: ‘label’
[13:34:34.896]   - Field: ‘local’
[13:34:34.896]   - Field: ‘owner’
[13:34:34.896]   - Field: ‘envir’
[13:34:34.896]   - Field: ‘workers’
[13:34:34.896]   - Field: ‘packages’
[13:34:34.897]   - Field: ‘gc’
[13:34:34.897]   - Field: ‘job’
[13:34:34.897]   - Field: ‘conditions’
[13:34:34.897]   - Field: ‘expr’
[13:34:34.897]   - Field: ‘uuid’
[13:34:34.897]   - Field: ‘seed’
[13:34:34.897]   - Field: ‘version’
[13:34:34.897]   - Field: ‘result’
[13:34:34.897]   - Field: ‘asynchronous’
[13:34:34.897]   - Field: ‘calls’
[13:34:34.898]   - Field: ‘globals’
[13:34:34.898]   - Field: ‘stdout’
[13:34:34.898]   - Field: ‘earlySignal’
[13:34:34.898]   - Field: ‘lazy’
[13:34:34.898]   - Field: ‘state’
[13:34:34.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:34.898] - Launch lazy future ...
[13:34:34.898] Packages needed by the future expression (n = 0): <none>
[13:34:34.898] Packages needed by future strategies (n = 0): <none>
[13:34:34.899] {
[13:34:34.899]     {
[13:34:34.899]         {
[13:34:34.899]             ...future.startTime <- base::Sys.time()
[13:34:34.899]             {
[13:34:34.899]                 {
[13:34:34.899]                   {
[13:34:34.899]                     {
[13:34:34.899]                       base::local({
[13:34:34.899]                         has_future <- base::requireNamespace("future", 
[13:34:34.899]                           quietly = TRUE)
[13:34:34.899]                         if (has_future) {
[13:34:34.899]                           ns <- base::getNamespace("future")
[13:34:34.899]                           version <- ns[[".package"]][["version"]]
[13:34:34.899]                           if (is.null(version)) 
[13:34:34.899]                             version <- utils::packageVersion("future")
[13:34:34.899]                         }
[13:34:34.899]                         else {
[13:34:34.899]                           version <- NULL
[13:34:34.899]                         }
[13:34:34.899]                         if (!has_future || version < "1.8.0") {
[13:34:34.899]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.899]                             "", base::R.version$version.string), 
[13:34:34.899]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:34.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.899]                               "release", "version")], collapse = " "), 
[13:34:34.899]                             hostname = base::Sys.info()[["nodename"]])
[13:34:34.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.899]                             info)
[13:34:34.899]                           info <- base::paste(info, collapse = "; ")
[13:34:34.899]                           if (!has_future) {
[13:34:34.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.899]                               info)
[13:34:34.899]                           }
[13:34:34.899]                           else {
[13:34:34.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.899]                               info, version)
[13:34:34.899]                           }
[13:34:34.899]                           base::stop(msg)
[13:34:34.899]                         }
[13:34:34.899]                       })
[13:34:34.899]                     }
[13:34:34.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:34.899]                     base::options(mc.cores = 1L)
[13:34:34.899]                   }
[13:34:34.899]                   ...future.strategy.old <- future::plan("list")
[13:34:34.899]                   options(future.plan = NULL)
[13:34:34.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.899]                 }
[13:34:34.899]                 ...future.workdir <- getwd()
[13:34:34.899]             }
[13:34:34.899]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.899]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.899]         }
[13:34:34.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.899]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:34.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.899]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.899]             base::names(...future.oldOptions))
[13:34:34.899]     }
[13:34:34.899]     if (FALSE) {
[13:34:34.899]     }
[13:34:34.899]     else {
[13:34:34.899]         if (TRUE) {
[13:34:34.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.899]                 open = "w")
[13:34:34.899]         }
[13:34:34.899]         else {
[13:34:34.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.899]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.899]         }
[13:34:34.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.899]             base::sink(type = "output", split = FALSE)
[13:34:34.899]             base::close(...future.stdout)
[13:34:34.899]         }, add = TRUE)
[13:34:34.899]     }
[13:34:34.899]     ...future.frame <- base::sys.nframe()
[13:34:34.899]     ...future.conditions <- base::list()
[13:34:34.899]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.899]     if (FALSE) {
[13:34:34.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.899]     }
[13:34:34.899]     ...future.result <- base::tryCatch({
[13:34:34.899]         base::withCallingHandlers({
[13:34:34.899]             ...future.value <- base::withVisible(base::local({
[13:34:34.899]                 withCallingHandlers({
[13:34:34.899]                   {
[13:34:34.899]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.899]                     if (!identical(...future.globals.maxSize.org, 
[13:34:34.899]                       ...future.globals.maxSize)) {
[13:34:34.899]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.899]                       on.exit(options(oopts), add = TRUE)
[13:34:34.899]                     }
[13:34:34.899]                     {
[13:34:34.899]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.899]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.899]                         USE.NAMES = FALSE)
[13:34:34.899]                       do.call(mapply, args = args)
[13:34:34.899]                     }
[13:34:34.899]                   }
[13:34:34.899]                 }, immediateCondition = function(cond) {
[13:34:34.899]                   save_rds <- function (object, pathname, ...) 
[13:34:34.899]                   {
[13:34:34.899]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:34.899]                     if (file_test("-f", pathname_tmp)) {
[13:34:34.899]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.899]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:34.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.899]                         fi_tmp[["mtime"]])
[13:34:34.899]                     }
[13:34:34.899]                     tryCatch({
[13:34:34.899]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:34.899]                     }, error = function(ex) {
[13:34:34.899]                       msg <- conditionMessage(ex)
[13:34:34.899]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.899]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:34.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.899]                         fi_tmp[["mtime"]], msg)
[13:34:34.899]                       ex$message <- msg
[13:34:34.899]                       stop(ex)
[13:34:34.899]                     })
[13:34:34.899]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:34.899]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:34.899]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:34.899]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.899]                       fi <- file.info(pathname)
[13:34:34.899]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:34.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.899]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:34.899]                         fi[["size"]], fi[["mtime"]])
[13:34:34.899]                       stop(msg)
[13:34:34.899]                     }
[13:34:34.899]                     invisible(pathname)
[13:34:34.899]                   }
[13:34:34.899]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:34.899]                     rootPath = tempdir()) 
[13:34:34.899]                   {
[13:34:34.899]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:34.899]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:34.899]                       tmpdir = path, fileext = ".rds")
[13:34:34.899]                     save_rds(obj, file)
[13:34:34.899]                   }
[13:34:34.899]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:34.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.899]                   {
[13:34:34.899]                     inherits <- base::inherits
[13:34:34.899]                     invokeRestart <- base::invokeRestart
[13:34:34.899]                     is.null <- base::is.null
[13:34:34.899]                     muffled <- FALSE
[13:34:34.899]                     if (inherits(cond, "message")) {
[13:34:34.899]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:34.899]                       if (muffled) 
[13:34:34.899]                         invokeRestart("muffleMessage")
[13:34:34.899]                     }
[13:34:34.899]                     else if (inherits(cond, "warning")) {
[13:34:34.899]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:34.899]                       if (muffled) 
[13:34:34.899]                         invokeRestart("muffleWarning")
[13:34:34.899]                     }
[13:34:34.899]                     else if (inherits(cond, "condition")) {
[13:34:34.899]                       if (!is.null(pattern)) {
[13:34:34.899]                         computeRestarts <- base::computeRestarts
[13:34:34.899]                         grepl <- base::grepl
[13:34:34.899]                         restarts <- computeRestarts(cond)
[13:34:34.899]                         for (restart in restarts) {
[13:34:34.899]                           name <- restart$name
[13:34:34.899]                           if (is.null(name)) 
[13:34:34.899]                             next
[13:34:34.899]                           if (!grepl(pattern, name)) 
[13:34:34.899]                             next
[13:34:34.899]                           invokeRestart(restart)
[13:34:34.899]                           muffled <- TRUE
[13:34:34.899]                           break
[13:34:34.899]                         }
[13:34:34.899]                       }
[13:34:34.899]                     }
[13:34:34.899]                     invisible(muffled)
[13:34:34.899]                   }
[13:34:34.899]                   muffleCondition(cond)
[13:34:34.899]                 })
[13:34:34.899]             }))
[13:34:34.899]             future::FutureResult(value = ...future.value$value, 
[13:34:34.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.899]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.899]                     ...future.globalenv.names))
[13:34:34.899]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.899]         }, condition = base::local({
[13:34:34.899]             c <- base::c
[13:34:34.899]             inherits <- base::inherits
[13:34:34.899]             invokeRestart <- base::invokeRestart
[13:34:34.899]             length <- base::length
[13:34:34.899]             list <- base::list
[13:34:34.899]             seq.int <- base::seq.int
[13:34:34.899]             signalCondition <- base::signalCondition
[13:34:34.899]             sys.calls <- base::sys.calls
[13:34:34.899]             `[[` <- base::`[[`
[13:34:34.899]             `+` <- base::`+`
[13:34:34.899]             `<<-` <- base::`<<-`
[13:34:34.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.899]                   3L)]
[13:34:34.899]             }
[13:34:34.899]             function(cond) {
[13:34:34.899]                 is_error <- inherits(cond, "error")
[13:34:34.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.899]                   NULL)
[13:34:34.899]                 if (is_error) {
[13:34:34.899]                   sessionInformation <- function() {
[13:34:34.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.899]                       search = base::search(), system = base::Sys.info())
[13:34:34.899]                   }
[13:34:34.899]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.899]                     cond$call), session = sessionInformation(), 
[13:34:34.899]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.899]                   signalCondition(cond)
[13:34:34.899]                 }
[13:34:34.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.899]                 "immediateCondition"))) {
[13:34:34.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.899]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.899]                   if (TRUE && !signal) {
[13:34:34.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.899]                     {
[13:34:34.899]                       inherits <- base::inherits
[13:34:34.899]                       invokeRestart <- base::invokeRestart
[13:34:34.899]                       is.null <- base::is.null
[13:34:34.899]                       muffled <- FALSE
[13:34:34.899]                       if (inherits(cond, "message")) {
[13:34:34.899]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.899]                         if (muffled) 
[13:34:34.899]                           invokeRestart("muffleMessage")
[13:34:34.899]                       }
[13:34:34.899]                       else if (inherits(cond, "warning")) {
[13:34:34.899]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.899]                         if (muffled) 
[13:34:34.899]                           invokeRestart("muffleWarning")
[13:34:34.899]                       }
[13:34:34.899]                       else if (inherits(cond, "condition")) {
[13:34:34.899]                         if (!is.null(pattern)) {
[13:34:34.899]                           computeRestarts <- base::computeRestarts
[13:34:34.899]                           grepl <- base::grepl
[13:34:34.899]                           restarts <- computeRestarts(cond)
[13:34:34.899]                           for (restart in restarts) {
[13:34:34.899]                             name <- restart$name
[13:34:34.899]                             if (is.null(name)) 
[13:34:34.899]                               next
[13:34:34.899]                             if (!grepl(pattern, name)) 
[13:34:34.899]                               next
[13:34:34.899]                             invokeRestart(restart)
[13:34:34.899]                             muffled <- TRUE
[13:34:34.899]                             break
[13:34:34.899]                           }
[13:34:34.899]                         }
[13:34:34.899]                       }
[13:34:34.899]                       invisible(muffled)
[13:34:34.899]                     }
[13:34:34.899]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.899]                   }
[13:34:34.899]                 }
[13:34:34.899]                 else {
[13:34:34.899]                   if (TRUE) {
[13:34:34.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.899]                     {
[13:34:34.899]                       inherits <- base::inherits
[13:34:34.899]                       invokeRestart <- base::invokeRestart
[13:34:34.899]                       is.null <- base::is.null
[13:34:34.899]                       muffled <- FALSE
[13:34:34.899]                       if (inherits(cond, "message")) {
[13:34:34.899]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.899]                         if (muffled) 
[13:34:34.899]                           invokeRestart("muffleMessage")
[13:34:34.899]                       }
[13:34:34.899]                       else if (inherits(cond, "warning")) {
[13:34:34.899]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.899]                         if (muffled) 
[13:34:34.899]                           invokeRestart("muffleWarning")
[13:34:34.899]                       }
[13:34:34.899]                       else if (inherits(cond, "condition")) {
[13:34:34.899]                         if (!is.null(pattern)) {
[13:34:34.899]                           computeRestarts <- base::computeRestarts
[13:34:34.899]                           grepl <- base::grepl
[13:34:34.899]                           restarts <- computeRestarts(cond)
[13:34:34.899]                           for (restart in restarts) {
[13:34:34.899]                             name <- restart$name
[13:34:34.899]                             if (is.null(name)) 
[13:34:34.899]                               next
[13:34:34.899]                             if (!grepl(pattern, name)) 
[13:34:34.899]                               next
[13:34:34.899]                             invokeRestart(restart)
[13:34:34.899]                             muffled <- TRUE
[13:34:34.899]                             break
[13:34:34.899]                           }
[13:34:34.899]                         }
[13:34:34.899]                       }
[13:34:34.899]                       invisible(muffled)
[13:34:34.899]                     }
[13:34:34.899]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.899]                   }
[13:34:34.899]                 }
[13:34:34.899]             }
[13:34:34.899]         }))
[13:34:34.899]     }, error = function(ex) {
[13:34:34.899]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.899]                 ...future.rng), started = ...future.startTime, 
[13:34:34.899]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.899]             version = "1.8"), class = "FutureResult")
[13:34:34.899]     }, finally = {
[13:34:34.899]         if (!identical(...future.workdir, getwd())) 
[13:34:34.899]             setwd(...future.workdir)
[13:34:34.899]         {
[13:34:34.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.899]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.899]             }
[13:34:34.899]             base::options(...future.oldOptions)
[13:34:34.899]             if (.Platform$OS.type == "windows") {
[13:34:34.899]                 old_names <- names(...future.oldEnvVars)
[13:34:34.899]                 envs <- base::Sys.getenv()
[13:34:34.899]                 names <- names(envs)
[13:34:34.899]                 common <- intersect(names, old_names)
[13:34:34.899]                 added <- setdiff(names, old_names)
[13:34:34.899]                 removed <- setdiff(old_names, names)
[13:34:34.899]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.899]                   envs[common]]
[13:34:34.899]                 NAMES <- toupper(changed)
[13:34:34.899]                 args <- list()
[13:34:34.899]                 for (kk in seq_along(NAMES)) {
[13:34:34.899]                   name <- changed[[kk]]
[13:34:34.899]                   NAME <- NAMES[[kk]]
[13:34:34.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.899]                     next
[13:34:34.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.899]                 }
[13:34:34.899]                 NAMES <- toupper(added)
[13:34:34.899]                 for (kk in seq_along(NAMES)) {
[13:34:34.899]                   name <- added[[kk]]
[13:34:34.899]                   NAME <- NAMES[[kk]]
[13:34:34.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.899]                     next
[13:34:34.899]                   args[[name]] <- ""
[13:34:34.899]                 }
[13:34:34.899]                 NAMES <- toupper(removed)
[13:34:34.899]                 for (kk in seq_along(NAMES)) {
[13:34:34.899]                   name <- removed[[kk]]
[13:34:34.899]                   NAME <- NAMES[[kk]]
[13:34:34.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.899]                     next
[13:34:34.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.899]                 }
[13:34:34.899]                 if (length(args) > 0) 
[13:34:34.899]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.899]             }
[13:34:34.899]             else {
[13:34:34.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.899]             }
[13:34:34.899]             {
[13:34:34.899]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.899]                   0L) {
[13:34:34.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.899]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.899]                   base::options(opts)
[13:34:34.899]                 }
[13:34:34.899]                 {
[13:34:34.899]                   {
[13:34:34.899]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:34.899]                     NULL
[13:34:34.899]                   }
[13:34:34.899]                   options(future.plan = NULL)
[13:34:34.899]                   if (is.na(NA_character_)) 
[13:34:34.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.899]                     .init = FALSE)
[13:34:34.899]                 }
[13:34:34.899]             }
[13:34:34.899]         }
[13:34:34.899]     })
[13:34:34.899]     if (TRUE) {
[13:34:34.899]         base::sink(type = "output", split = FALSE)
[13:34:34.899]         if (TRUE) {
[13:34:34.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.899]         }
[13:34:34.899]         else {
[13:34:34.899]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.899]         }
[13:34:34.899]         base::close(...future.stdout)
[13:34:34.899]         ...future.stdout <- NULL
[13:34:34.899]     }
[13:34:34.899]     ...future.result$conditions <- ...future.conditions
[13:34:34.899]     ...future.result$finished <- base::Sys.time()
[13:34:34.899]     ...future.result
[13:34:34.899] }
[13:34:34.901] assign_globals() ...
[13:34:34.901] List of 5
[13:34:34.901]  $ ...future.FUN            :function (x, ...)  
[13:34:34.901]  $ MoreArgs                 : NULL
[13:34:34.901]  $ ...future.elements_ii    :List of 2
[13:34:34.901]   ..$ :List of 2
[13:34:34.901]   .. ..$ : int 1
[13:34:34.901]   .. ..$ : int 2
[13:34:34.901]   ..$ :List of 2
[13:34:34.901]   .. ..$ : int 4
[13:34:34.901]   .. ..$ : int 3
[13:34:34.901]  $ ...future.seeds_ii       : NULL
[13:34:34.901]  $ ...future.globals.maxSize: NULL
[13:34:34.901]  - attr(*, "where")=List of 5
[13:34:34.901]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.901]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.901]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.901]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.901]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.901]  - attr(*, "resolved")= logi FALSE
[13:34:34.901]  - attr(*, "total_size")= num 280
[13:34:34.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.901]  - attr(*, "already-done")= logi TRUE
[13:34:34.907] - copied ‘...future.FUN’ to environment
[13:34:34.907] - copied ‘MoreArgs’ to environment
[13:34:34.907] - copied ‘...future.elements_ii’ to environment
[13:34:34.907] - copied ‘...future.seeds_ii’ to environment
[13:34:34.907] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.907] assign_globals() ... done
[13:34:34.907] requestCore(): workers = 2
[13:34:34.909] MulticoreFuture started
[13:34:34.910] - Launch lazy future ... done
[13:34:34.910] run() for ‘MulticoreFuture’ ... done
[13:34:34.910] Created future:
[13:34:34.911] plan(): Setting new future strategy stack:
[13:34:34.911] List of future strategies:
[13:34:34.911] 1. sequential:
[13:34:34.911]    - args: function (..., envir = parent.frame())
[13:34:34.911]    - tweaked: FALSE
[13:34:34.911]    - call: NULL
[13:34:34.912] plan(): nbrOfWorkers() = 1
[13:34:34.914] plan(): Setting new future strategy stack:
[13:34:34.914] List of future strategies:
[13:34:34.914] 1. multicore:
[13:34:34.914]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:34.914]    - tweaked: FALSE
[13:34:34.914]    - call: plan(strategy)
[13:34:34.919] plan(): nbrOfWorkers() = 2
[13:34:34.910] MulticoreFuture:
[13:34:34.910] Label: ‘future_mapply-1’
[13:34:34.910] Expression:
[13:34:34.910] {
[13:34:34.910]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.910]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.910]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.910]         on.exit(options(oopts), add = TRUE)
[13:34:34.910]     }
[13:34:34.910]     {
[13:34:34.910]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.910]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.910]         do.call(mapply, args = args)
[13:34:34.910]     }
[13:34:34.910] }
[13:34:34.910] Lazy evaluation: FALSE
[13:34:34.910] Asynchronous evaluation: TRUE
[13:34:34.910] Local evaluation: TRUE
[13:34:34.910] Environment: R_GlobalEnv
[13:34:34.910] Capture standard output: TRUE
[13:34:34.910] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.910] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.910] Packages: <none>
[13:34:34.910] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.910] Resolved: TRUE
[13:34:34.910] Value: <not collected>
[13:34:34.910] Conditions captured: <none>
[13:34:34.910] Early signaling: FALSE
[13:34:34.910] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.910] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:34.920] Chunk #1 of 2 ... DONE
[13:34:34.920] Chunk #2 of 2 ...
[13:34:34.920]  - Finding globals in '...' for chunk #2 ...
[13:34:34.921] getGlobalsAndPackages() ...
[13:34:34.921] Searching for globals...
[13:34:34.921] 
[13:34:34.921] Searching for globals ... DONE
[13:34:34.922] - globals: [0] <none>
[13:34:34.922] getGlobalsAndPackages() ... DONE
[13:34:34.922]    + additional globals found: [n=0] 
[13:34:34.922]    + additional namespaces needed: [n=0] 
[13:34:34.922]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:34.922]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:34.922]  - seeds: <none>
[13:34:34.923]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.923] getGlobalsAndPackages() ...
[13:34:34.923] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.923] Resolving globals: FALSE
[13:34:34.924] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:34.925] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.925] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.925] 
[13:34:34.925] getGlobalsAndPackages() ... DONE
[13:34:34.926] run() for ‘Future’ ...
[13:34:34.926] - state: ‘created’
[13:34:34.926] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:34.930] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:34.931] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:34.931]   - Field: ‘label’
[13:34:34.931]   - Field: ‘local’
[13:34:34.931]   - Field: ‘owner’
[13:34:34.931]   - Field: ‘envir’
[13:34:34.931]   - Field: ‘workers’
[13:34:34.932]   - Field: ‘packages’
[13:34:34.932]   - Field: ‘gc’
[13:34:34.932]   - Field: ‘job’
[13:34:34.932]   - Field: ‘conditions’
[13:34:34.932]   - Field: ‘expr’
[13:34:34.932]   - Field: ‘uuid’
[13:34:34.936]   - Field: ‘seed’
[13:34:34.936]   - Field: ‘version’
[13:34:34.936]   - Field: ‘result’
[13:34:34.937]   - Field: ‘asynchronous’
[13:34:34.937]   - Field: ‘calls’
[13:34:34.937]   - Field: ‘globals’
[13:34:34.938]   - Field: ‘stdout’
[13:34:34.938]   - Field: ‘earlySignal’
[13:34:34.938]   - Field: ‘lazy’
[13:34:34.938]   - Field: ‘state’
[13:34:34.939] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:34.939] - Launch lazy future ...
[13:34:34.939] Packages needed by the future expression (n = 0): <none>
[13:34:34.940] Packages needed by future strategies (n = 0): <none>
[13:34:34.941] {
[13:34:34.941]     {
[13:34:34.941]         {
[13:34:34.941]             ...future.startTime <- base::Sys.time()
[13:34:34.941]             {
[13:34:34.941]                 {
[13:34:34.941]                   {
[13:34:34.941]                     {
[13:34:34.941]                       base::local({
[13:34:34.941]                         has_future <- base::requireNamespace("future", 
[13:34:34.941]                           quietly = TRUE)
[13:34:34.941]                         if (has_future) {
[13:34:34.941]                           ns <- base::getNamespace("future")
[13:34:34.941]                           version <- ns[[".package"]][["version"]]
[13:34:34.941]                           if (is.null(version)) 
[13:34:34.941]                             version <- utils::packageVersion("future")
[13:34:34.941]                         }
[13:34:34.941]                         else {
[13:34:34.941]                           version <- NULL
[13:34:34.941]                         }
[13:34:34.941]                         if (!has_future || version < "1.8.0") {
[13:34:34.941]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:34.941]                             "", base::R.version$version.string), 
[13:34:34.941]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:34.941]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:34.941]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:34.941]                               "release", "version")], collapse = " "), 
[13:34:34.941]                             hostname = base::Sys.info()[["nodename"]])
[13:34:34.941]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:34.941]                             info)
[13:34:34.941]                           info <- base::paste(info, collapse = "; ")
[13:34:34.941]                           if (!has_future) {
[13:34:34.941]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:34.941]                               info)
[13:34:34.941]                           }
[13:34:34.941]                           else {
[13:34:34.941]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:34.941]                               info, version)
[13:34:34.941]                           }
[13:34:34.941]                           base::stop(msg)
[13:34:34.941]                         }
[13:34:34.941]                       })
[13:34:34.941]                     }
[13:34:34.941]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:34.941]                     base::options(mc.cores = 1L)
[13:34:34.941]                   }
[13:34:34.941]                   ...future.strategy.old <- future::plan("list")
[13:34:34.941]                   options(future.plan = NULL)
[13:34:34.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:34.941]                 }
[13:34:34.941]                 ...future.workdir <- getwd()
[13:34:34.941]             }
[13:34:34.941]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:34.941]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:34.941]         }
[13:34:34.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:34.941]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:34.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:34.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:34.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:34.941]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:34.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:34.941]             base::names(...future.oldOptions))
[13:34:34.941]     }
[13:34:34.941]     if (FALSE) {
[13:34:34.941]     }
[13:34:34.941]     else {
[13:34:34.941]         if (TRUE) {
[13:34:34.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:34.941]                 open = "w")
[13:34:34.941]         }
[13:34:34.941]         else {
[13:34:34.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:34.941]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:34.941]         }
[13:34:34.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:34.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:34.941]             base::sink(type = "output", split = FALSE)
[13:34:34.941]             base::close(...future.stdout)
[13:34:34.941]         }, add = TRUE)
[13:34:34.941]     }
[13:34:34.941]     ...future.frame <- base::sys.nframe()
[13:34:34.941]     ...future.conditions <- base::list()
[13:34:34.941]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:34.941]     if (FALSE) {
[13:34:34.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:34.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:34.941]     }
[13:34:34.941]     ...future.result <- base::tryCatch({
[13:34:34.941]         base::withCallingHandlers({
[13:34:34.941]             ...future.value <- base::withVisible(base::local({
[13:34:34.941]                 withCallingHandlers({
[13:34:34.941]                   {
[13:34:34.941]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.941]                     if (!identical(...future.globals.maxSize.org, 
[13:34:34.941]                       ...future.globals.maxSize)) {
[13:34:34.941]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.941]                       on.exit(options(oopts), add = TRUE)
[13:34:34.941]                     }
[13:34:34.941]                     {
[13:34:34.941]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.941]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:34.941]                         USE.NAMES = FALSE)
[13:34:34.941]                       do.call(mapply, args = args)
[13:34:34.941]                     }
[13:34:34.941]                   }
[13:34:34.941]                 }, immediateCondition = function(cond) {
[13:34:34.941]                   save_rds <- function (object, pathname, ...) 
[13:34:34.941]                   {
[13:34:34.941]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:34.941]                     if (file_test("-f", pathname_tmp)) {
[13:34:34.941]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.941]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:34.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.941]                         fi_tmp[["mtime"]])
[13:34:34.941]                     }
[13:34:34.941]                     tryCatch({
[13:34:34.941]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:34.941]                     }, error = function(ex) {
[13:34:34.941]                       msg <- conditionMessage(ex)
[13:34:34.941]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.941]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:34.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.941]                         fi_tmp[["mtime"]], msg)
[13:34:34.941]                       ex$message <- msg
[13:34:34.941]                       stop(ex)
[13:34:34.941]                     })
[13:34:34.941]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:34.941]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:34.941]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:34.941]                       fi_tmp <- file.info(pathname_tmp)
[13:34:34.941]                       fi <- file.info(pathname)
[13:34:34.941]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:34.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:34.941]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:34.941]                         fi[["size"]], fi[["mtime"]])
[13:34:34.941]                       stop(msg)
[13:34:34.941]                     }
[13:34:34.941]                     invisible(pathname)
[13:34:34.941]                   }
[13:34:34.941]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:34.941]                     rootPath = tempdir()) 
[13:34:34.941]                   {
[13:34:34.941]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:34.941]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:34.941]                       tmpdir = path, fileext = ".rds")
[13:34:34.941]                     save_rds(obj, file)
[13:34:34.941]                   }
[13:34:34.941]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:34.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.941]                   {
[13:34:34.941]                     inherits <- base::inherits
[13:34:34.941]                     invokeRestart <- base::invokeRestart
[13:34:34.941]                     is.null <- base::is.null
[13:34:34.941]                     muffled <- FALSE
[13:34:34.941]                     if (inherits(cond, "message")) {
[13:34:34.941]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:34.941]                       if (muffled) 
[13:34:34.941]                         invokeRestart("muffleMessage")
[13:34:34.941]                     }
[13:34:34.941]                     else if (inherits(cond, "warning")) {
[13:34:34.941]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:34.941]                       if (muffled) 
[13:34:34.941]                         invokeRestart("muffleWarning")
[13:34:34.941]                     }
[13:34:34.941]                     else if (inherits(cond, "condition")) {
[13:34:34.941]                       if (!is.null(pattern)) {
[13:34:34.941]                         computeRestarts <- base::computeRestarts
[13:34:34.941]                         grepl <- base::grepl
[13:34:34.941]                         restarts <- computeRestarts(cond)
[13:34:34.941]                         for (restart in restarts) {
[13:34:34.941]                           name <- restart$name
[13:34:34.941]                           if (is.null(name)) 
[13:34:34.941]                             next
[13:34:34.941]                           if (!grepl(pattern, name)) 
[13:34:34.941]                             next
[13:34:34.941]                           invokeRestart(restart)
[13:34:34.941]                           muffled <- TRUE
[13:34:34.941]                           break
[13:34:34.941]                         }
[13:34:34.941]                       }
[13:34:34.941]                     }
[13:34:34.941]                     invisible(muffled)
[13:34:34.941]                   }
[13:34:34.941]                   muffleCondition(cond)
[13:34:34.941]                 })
[13:34:34.941]             }))
[13:34:34.941]             future::FutureResult(value = ...future.value$value, 
[13:34:34.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.941]                   ...future.rng), globalenv = if (FALSE) 
[13:34:34.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:34.941]                     ...future.globalenv.names))
[13:34:34.941]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:34.941]         }, condition = base::local({
[13:34:34.941]             c <- base::c
[13:34:34.941]             inherits <- base::inherits
[13:34:34.941]             invokeRestart <- base::invokeRestart
[13:34:34.941]             length <- base::length
[13:34:34.941]             list <- base::list
[13:34:34.941]             seq.int <- base::seq.int
[13:34:34.941]             signalCondition <- base::signalCondition
[13:34:34.941]             sys.calls <- base::sys.calls
[13:34:34.941]             `[[` <- base::`[[`
[13:34:34.941]             `+` <- base::`+`
[13:34:34.941]             `<<-` <- base::`<<-`
[13:34:34.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:34.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:34.941]                   3L)]
[13:34:34.941]             }
[13:34:34.941]             function(cond) {
[13:34:34.941]                 is_error <- inherits(cond, "error")
[13:34:34.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:34.941]                   NULL)
[13:34:34.941]                 if (is_error) {
[13:34:34.941]                   sessionInformation <- function() {
[13:34:34.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:34.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:34.941]                       search = base::search(), system = base::Sys.info())
[13:34:34.941]                   }
[13:34:34.941]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:34.941]                     cond$call), session = sessionInformation(), 
[13:34:34.941]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:34.941]                   signalCondition(cond)
[13:34:34.941]                 }
[13:34:34.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:34.941]                 "immediateCondition"))) {
[13:34:34.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:34.941]                   ...future.conditions[[length(...future.conditions) + 
[13:34:34.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:34.941]                   if (TRUE && !signal) {
[13:34:34.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.941]                     {
[13:34:34.941]                       inherits <- base::inherits
[13:34:34.941]                       invokeRestart <- base::invokeRestart
[13:34:34.941]                       is.null <- base::is.null
[13:34:34.941]                       muffled <- FALSE
[13:34:34.941]                       if (inherits(cond, "message")) {
[13:34:34.941]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.941]                         if (muffled) 
[13:34:34.941]                           invokeRestart("muffleMessage")
[13:34:34.941]                       }
[13:34:34.941]                       else if (inherits(cond, "warning")) {
[13:34:34.941]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.941]                         if (muffled) 
[13:34:34.941]                           invokeRestart("muffleWarning")
[13:34:34.941]                       }
[13:34:34.941]                       else if (inherits(cond, "condition")) {
[13:34:34.941]                         if (!is.null(pattern)) {
[13:34:34.941]                           computeRestarts <- base::computeRestarts
[13:34:34.941]                           grepl <- base::grepl
[13:34:34.941]                           restarts <- computeRestarts(cond)
[13:34:34.941]                           for (restart in restarts) {
[13:34:34.941]                             name <- restart$name
[13:34:34.941]                             if (is.null(name)) 
[13:34:34.941]                               next
[13:34:34.941]                             if (!grepl(pattern, name)) 
[13:34:34.941]                               next
[13:34:34.941]                             invokeRestart(restart)
[13:34:34.941]                             muffled <- TRUE
[13:34:34.941]                             break
[13:34:34.941]                           }
[13:34:34.941]                         }
[13:34:34.941]                       }
[13:34:34.941]                       invisible(muffled)
[13:34:34.941]                     }
[13:34:34.941]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.941]                   }
[13:34:34.941]                 }
[13:34:34.941]                 else {
[13:34:34.941]                   if (TRUE) {
[13:34:34.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:34.941]                     {
[13:34:34.941]                       inherits <- base::inherits
[13:34:34.941]                       invokeRestart <- base::invokeRestart
[13:34:34.941]                       is.null <- base::is.null
[13:34:34.941]                       muffled <- FALSE
[13:34:34.941]                       if (inherits(cond, "message")) {
[13:34:34.941]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:34.941]                         if (muffled) 
[13:34:34.941]                           invokeRestart("muffleMessage")
[13:34:34.941]                       }
[13:34:34.941]                       else if (inherits(cond, "warning")) {
[13:34:34.941]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:34.941]                         if (muffled) 
[13:34:34.941]                           invokeRestart("muffleWarning")
[13:34:34.941]                       }
[13:34:34.941]                       else if (inherits(cond, "condition")) {
[13:34:34.941]                         if (!is.null(pattern)) {
[13:34:34.941]                           computeRestarts <- base::computeRestarts
[13:34:34.941]                           grepl <- base::grepl
[13:34:34.941]                           restarts <- computeRestarts(cond)
[13:34:34.941]                           for (restart in restarts) {
[13:34:34.941]                             name <- restart$name
[13:34:34.941]                             if (is.null(name)) 
[13:34:34.941]                               next
[13:34:34.941]                             if (!grepl(pattern, name)) 
[13:34:34.941]                               next
[13:34:34.941]                             invokeRestart(restart)
[13:34:34.941]                             muffled <- TRUE
[13:34:34.941]                             break
[13:34:34.941]                           }
[13:34:34.941]                         }
[13:34:34.941]                       }
[13:34:34.941]                       invisible(muffled)
[13:34:34.941]                     }
[13:34:34.941]                     muffleCondition(cond, pattern = "^muffle")
[13:34:34.941]                   }
[13:34:34.941]                 }
[13:34:34.941]             }
[13:34:34.941]         }))
[13:34:34.941]     }, error = function(ex) {
[13:34:34.941]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:34.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:34.941]                 ...future.rng), started = ...future.startTime, 
[13:34:34.941]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:34.941]             version = "1.8"), class = "FutureResult")
[13:34:34.941]     }, finally = {
[13:34:34.941]         if (!identical(...future.workdir, getwd())) 
[13:34:34.941]             setwd(...future.workdir)
[13:34:34.941]         {
[13:34:34.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:34.941]                 ...future.oldOptions$nwarnings <- NULL
[13:34:34.941]             }
[13:34:34.941]             base::options(...future.oldOptions)
[13:34:34.941]             if (.Platform$OS.type == "windows") {
[13:34:34.941]                 old_names <- names(...future.oldEnvVars)
[13:34:34.941]                 envs <- base::Sys.getenv()
[13:34:34.941]                 names <- names(envs)
[13:34:34.941]                 common <- intersect(names, old_names)
[13:34:34.941]                 added <- setdiff(names, old_names)
[13:34:34.941]                 removed <- setdiff(old_names, names)
[13:34:34.941]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:34.941]                   envs[common]]
[13:34:34.941]                 NAMES <- toupper(changed)
[13:34:34.941]                 args <- list()
[13:34:34.941]                 for (kk in seq_along(NAMES)) {
[13:34:34.941]                   name <- changed[[kk]]
[13:34:34.941]                   NAME <- NAMES[[kk]]
[13:34:34.941]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.941]                     next
[13:34:34.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.941]                 }
[13:34:34.941]                 NAMES <- toupper(added)
[13:34:34.941]                 for (kk in seq_along(NAMES)) {
[13:34:34.941]                   name <- added[[kk]]
[13:34:34.941]                   NAME <- NAMES[[kk]]
[13:34:34.941]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.941]                     next
[13:34:34.941]                   args[[name]] <- ""
[13:34:34.941]                 }
[13:34:34.941]                 NAMES <- toupper(removed)
[13:34:34.941]                 for (kk in seq_along(NAMES)) {
[13:34:34.941]                   name <- removed[[kk]]
[13:34:34.941]                   NAME <- NAMES[[kk]]
[13:34:34.941]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:34.941]                     next
[13:34:34.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:34.941]                 }
[13:34:34.941]                 if (length(args) > 0) 
[13:34:34.941]                   base::do.call(base::Sys.setenv, args = args)
[13:34:34.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:34.941]             }
[13:34:34.941]             else {
[13:34:34.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:34.941]             }
[13:34:34.941]             {
[13:34:34.941]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:34.941]                   0L) {
[13:34:34.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:34.941]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:34.941]                   base::options(opts)
[13:34:34.941]                 }
[13:34:34.941]                 {
[13:34:34.941]                   {
[13:34:34.941]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:34.941]                     NULL
[13:34:34.941]                   }
[13:34:34.941]                   options(future.plan = NULL)
[13:34:34.941]                   if (is.na(NA_character_)) 
[13:34:34.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:34.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:34.941]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:34.941]                     .init = FALSE)
[13:34:34.941]                 }
[13:34:34.941]             }
[13:34:34.941]         }
[13:34:34.941]     })
[13:34:34.941]     if (TRUE) {
[13:34:34.941]         base::sink(type = "output", split = FALSE)
[13:34:34.941]         if (TRUE) {
[13:34:34.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:34.941]         }
[13:34:34.941]         else {
[13:34:34.941]             ...future.result["stdout"] <- base::list(NULL)
[13:34:34.941]         }
[13:34:34.941]         base::close(...future.stdout)
[13:34:34.941]         ...future.stdout <- NULL
[13:34:34.941]     }
[13:34:34.941]     ...future.result$conditions <- ...future.conditions
[13:34:34.941]     ...future.result$finished <- base::Sys.time()
[13:34:34.941]     ...future.result
[13:34:34.941] }
[13:34:34.944] assign_globals() ...
[13:34:34.944] List of 5
[13:34:34.944]  $ ...future.FUN            :function (x, ...)  
[13:34:34.944]  $ MoreArgs                 : NULL
[13:34:34.944]  $ ...future.elements_ii    :List of 2
[13:34:34.944]   ..$ :List of 2
[13:34:34.944]   .. ..$ : int 3
[13:34:34.944]   .. ..$ : int 4
[13:34:34.944]   ..$ :List of 2
[13:34:34.944]   .. ..$ : int 2
[13:34:34.944]   .. ..$ : int 1
[13:34:34.944]  $ ...future.seeds_ii       : NULL
[13:34:34.944]  $ ...future.globals.maxSize: NULL
[13:34:34.944]  - attr(*, "where")=List of 5
[13:34:34.944]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:34.944]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:34.944]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:34.944]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:34.944]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:34.944]  - attr(*, "resolved")= logi FALSE
[13:34:34.944]  - attr(*, "total_size")= num 280
[13:34:34.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.944]  - attr(*, "already-done")= logi TRUE
[13:34:34.953] - copied ‘...future.FUN’ to environment
[13:34:34.953] - copied ‘MoreArgs’ to environment
[13:34:34.953] - copied ‘...future.elements_ii’ to environment
[13:34:34.953] - copied ‘...future.seeds_ii’ to environment
[13:34:34.954] - copied ‘...future.globals.maxSize’ to environment
[13:34:34.954] assign_globals() ... done
[13:34:34.954] requestCore(): workers = 2
[13:34:34.956] MulticoreFuture started
[13:34:34.956] - Launch lazy future ... done
[13:34:34.956] run() for ‘MulticoreFuture’ ... done
[13:34:34.957] Created future:
[13:34:34.957] plan(): Setting new future strategy stack:
[13:34:34.957] List of future strategies:
[13:34:34.957] 1. sequential:
[13:34:34.957]    - args: function (..., envir = parent.frame())
[13:34:34.957]    - tweaked: FALSE
[13:34:34.957]    - call: NULL
[13:34:34.958] plan(): nbrOfWorkers() = 1
[13:34:34.960] plan(): Setting new future strategy stack:
[13:34:34.960] List of future strategies:
[13:34:34.960] 1. multicore:
[13:34:34.960]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:34.960]    - tweaked: FALSE
[13:34:34.960]    - call: plan(strategy)
[13:34:34.965] plan(): nbrOfWorkers() = 2
[13:34:34.957] MulticoreFuture:
[13:34:34.957] Label: ‘future_mapply-2’
[13:34:34.957] Expression:
[13:34:34.957] {
[13:34:34.957]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:34.957]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:34.957]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:34.957]         on.exit(options(oopts), add = TRUE)
[13:34:34.957]     }
[13:34:34.957]     {
[13:34:34.957]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:34.957]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:34.957]         do.call(mapply, args = args)
[13:34:34.957]     }
[13:34:34.957] }
[13:34:34.957] Lazy evaluation: FALSE
[13:34:34.957] Asynchronous evaluation: TRUE
[13:34:34.957] Local evaluation: TRUE
[13:34:34.957] Environment: R_GlobalEnv
[13:34:34.957] Capture standard output: TRUE
[13:34:34.957] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:34.957] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:34.957] Packages: <none>
[13:34:34.957] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:34.957] Resolved: TRUE
[13:34:34.957] Value: <not collected>
[13:34:34.957] Conditions captured: <none>
[13:34:34.957] Early signaling: FALSE
[13:34:34.957] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:34.957] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:34.966] Chunk #2 of 2 ... DONE
[13:34:34.966] Launching 2 futures (chunks) ... DONE
[13:34:34.967] Resolving 2 futures (chunks) ...
[13:34:34.967] resolve() on list ...
[13:34:34.967]  recursive: 0
[13:34:34.967]  length: 2
[13:34:34.967] 
[13:34:34.967] Future #1
[13:34:34.968] result() for MulticoreFuture ...
[13:34:34.969] result() for MulticoreFuture ...
[13:34:34.969] result() for MulticoreFuture ... done
[13:34:34.969] result() for MulticoreFuture ... done
[13:34:34.969] result() for MulticoreFuture ...
[13:34:34.969] result() for MulticoreFuture ... done
[13:34:34.969] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:34.970] - nx: 2
[13:34:34.970] - relay: TRUE
[13:34:34.970] - stdout: TRUE
[13:34:34.970] - signal: TRUE
[13:34:34.970] - resignal: FALSE
[13:34:34.970] - force: TRUE
[13:34:34.970] - relayed: [n=2] FALSE, FALSE
[13:34:34.970] - queued futures: [n=2] FALSE, FALSE
[13:34:34.971]  - until=1
[13:34:34.971]  - relaying element #1
[13:34:34.971] result() for MulticoreFuture ...
[13:34:34.971] result() for MulticoreFuture ... done
[13:34:34.971] result() for MulticoreFuture ...
[13:34:34.971] result() for MulticoreFuture ... done
[13:34:34.972] result() for MulticoreFuture ...
[13:34:34.972] result() for MulticoreFuture ... done
[13:34:34.972] result() for MulticoreFuture ...
[13:34:34.972] result() for MulticoreFuture ... done
[13:34:34.972] - relayed: [n=2] TRUE, FALSE
[13:34:34.972] - queued futures: [n=2] TRUE, FALSE
[13:34:34.972] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:34.973]  length: 1 (resolved future 1)
[13:34:34.973] Future #2
[13:34:34.973] result() for MulticoreFuture ...
[13:34:34.974] result() for MulticoreFuture ...
[13:34:34.974] result() for MulticoreFuture ... done
[13:34:34.974] result() for MulticoreFuture ... done
[13:34:34.974] result() for MulticoreFuture ...
[13:34:34.974] result() for MulticoreFuture ... done
[13:34:34.975] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:34.975] - nx: 2
[13:34:34.975] - relay: TRUE
[13:34:34.975] - stdout: TRUE
[13:34:34.975] - signal: TRUE
[13:34:34.975] - resignal: FALSE
[13:34:34.975] - force: TRUE
[13:34:34.975] - relayed: [n=2] TRUE, FALSE
[13:34:34.976] - queued futures: [n=2] TRUE, FALSE
[13:34:34.976]  - until=2
[13:34:34.976]  - relaying element #2
[13:34:34.976] result() for MulticoreFuture ...
[13:34:34.976] result() for MulticoreFuture ... done
[13:34:34.976] result() for MulticoreFuture ...
[13:34:34.976] result() for MulticoreFuture ... done
[13:34:34.976] result() for MulticoreFuture ...
[13:34:34.977] result() for MulticoreFuture ... done
[13:34:34.977] result() for MulticoreFuture ...
[13:34:34.977] result() for MulticoreFuture ... done
[13:34:34.977] - relayed: [n=2] TRUE, TRUE
[13:34:34.977] - queued futures: [n=2] TRUE, TRUE
[13:34:34.977] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:34.977]  length: 0 (resolved future 2)
[13:34:34.977] Relaying remaining futures
[13:34:34.977] signalConditionsASAP(NULL, pos=0) ...
[13:34:34.978] - nx: 2
[13:34:34.978] - relay: TRUE
[13:34:34.978] - stdout: TRUE
[13:34:34.978] - signal: TRUE
[13:34:34.978] - resignal: FALSE
[13:34:34.978] - force: TRUE
[13:34:34.978] - relayed: [n=2] TRUE, TRUE
[13:34:34.978] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:34.978] - relayed: [n=2] TRUE, TRUE
[13:34:34.979] - queued futures: [n=2] TRUE, TRUE
[13:34:34.979] signalConditionsASAP(NULL, pos=0) ... done
[13:34:34.979] resolve() on list ... DONE
[13:34:34.979] result() for MulticoreFuture ...
[13:34:34.979] result() for MulticoreFuture ... done
[13:34:34.979] result() for MulticoreFuture ...
[13:34:34.982] result() for MulticoreFuture ... done
[13:34:34.982] result() for MulticoreFuture ...
[13:34:34.982] result() for MulticoreFuture ... done
[13:34:34.982] result() for MulticoreFuture ...
[13:34:34.983] result() for MulticoreFuture ... done
[13:34:34.983]  - Number of value chunks collected: 2
[13:34:34.983] Resolving 2 futures (chunks) ... DONE
[13:34:34.983] Reducing values from 2 chunks ...
[13:34:34.983]  - Number of values collected after concatenation: 4
[13:34:34.983]  - Number of values expected: 4
[13:34:34.983] Reducing values from 2 chunks ... DONE
[13:34:34.984] future_mapply() ... DONE
[13:34:34.984] future_mapply() ...
[13:34:34.988] Number of chunks: 2
[13:34:34.989] getGlobalsAndPackagesXApply() ...
[13:34:34.989]  - future.globals: TRUE
[13:34:34.989] getGlobalsAndPackages() ...
[13:34:34.989] Searching for globals...
[13:34:34.990] - globals found: [1] ‘FUN’
[13:34:34.990] Searching for globals ... DONE
[13:34:34.990] Resolving globals: FALSE
[13:34:34.990] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:34.991] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:34.991] - globals: [1] ‘FUN’
[13:34:34.991] 
[13:34:34.991] getGlobalsAndPackages() ... DONE
[13:34:34.991]  - globals found/used: [n=1] ‘FUN’
[13:34:34.991]  - needed namespaces: [n=0] 
[13:34:34.992] Finding globals ... DONE
[13:34:34.992] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:34.992] List of 2
[13:34:34.992]  $ ...future.FUN:function (x, ...)  
[13:34:34.992]  $ MoreArgs     : NULL
[13:34:34.992]  - attr(*, "where")=List of 2
[13:34:34.992]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:34.992]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:34.992]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:34.992]  - attr(*, "resolved")= logi FALSE
[13:34:34.992]  - attr(*, "total_size")= num NA
[13:34:34.995] Packages to be attached in all futures: [n=0] 
[13:34:34.995] getGlobalsAndPackagesXApply() ... DONE
[13:34:34.995] Number of futures (= number of chunks): 2
[13:34:34.996] Launching 2 futures (chunks) ...
[13:34:34.996] Chunk #1 of 2 ...
[13:34:34.996]  - Finding globals in '...' for chunk #1 ...
[13:34:34.996] getGlobalsAndPackages() ...
[13:34:34.996] Searching for globals...
[13:34:34.996] 
[13:34:34.996] Searching for globals ... DONE
[13:34:34.997] - globals: [0] <none>
[13:34:34.997] getGlobalsAndPackages() ... DONE
[13:34:34.997]    + additional globals found: [n=0] 
[13:34:34.997]    + additional namespaces needed: [n=0] 
[13:34:34.997]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:34.997]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:34.997]  - seeds: <none>
[13:34:34.997]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.997] getGlobalsAndPackages() ...
[13:34:34.997] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.998] Resolving globals: FALSE
[13:34:34.998] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:34.999] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:34.999] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:34.999] 
[13:34:34.999] getGlobalsAndPackages() ... DONE
[13:34:34.999] run() for ‘Future’ ...
[13:34:34.999] - state: ‘created’
[13:34:34.999] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.003] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.003] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.003]   - Field: ‘label’
[13:34:35.003]   - Field: ‘local’
[13:34:35.003]   - Field: ‘owner’
[13:34:35.004]   - Field: ‘envir’
[13:34:35.004]   - Field: ‘workers’
[13:34:35.004]   - Field: ‘packages’
[13:34:35.004]   - Field: ‘gc’
[13:34:35.004]   - Field: ‘job’
[13:34:35.004]   - Field: ‘conditions’
[13:34:35.004]   - Field: ‘expr’
[13:34:35.004]   - Field: ‘uuid’
[13:34:35.004]   - Field: ‘seed’
[13:34:35.004]   - Field: ‘version’
[13:34:35.004]   - Field: ‘result’
[13:34:35.005]   - Field: ‘asynchronous’
[13:34:35.005]   - Field: ‘calls’
[13:34:35.005]   - Field: ‘globals’
[13:34:35.005]   - Field: ‘stdout’
[13:34:35.005]   - Field: ‘earlySignal’
[13:34:35.005]   - Field: ‘lazy’
[13:34:35.005]   - Field: ‘state’
[13:34:35.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.005] - Launch lazy future ...
[13:34:35.005] Packages needed by the future expression (n = 0): <none>
[13:34:35.006] Packages needed by future strategies (n = 0): <none>
[13:34:35.006] {
[13:34:35.006]     {
[13:34:35.006]         {
[13:34:35.006]             ...future.startTime <- base::Sys.time()
[13:34:35.006]             {
[13:34:35.006]                 {
[13:34:35.006]                   {
[13:34:35.006]                     {
[13:34:35.006]                       base::local({
[13:34:35.006]                         has_future <- base::requireNamespace("future", 
[13:34:35.006]                           quietly = TRUE)
[13:34:35.006]                         if (has_future) {
[13:34:35.006]                           ns <- base::getNamespace("future")
[13:34:35.006]                           version <- ns[[".package"]][["version"]]
[13:34:35.006]                           if (is.null(version)) 
[13:34:35.006]                             version <- utils::packageVersion("future")
[13:34:35.006]                         }
[13:34:35.006]                         else {
[13:34:35.006]                           version <- NULL
[13:34:35.006]                         }
[13:34:35.006]                         if (!has_future || version < "1.8.0") {
[13:34:35.006]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.006]                             "", base::R.version$version.string), 
[13:34:35.006]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.006]                               "release", "version")], collapse = " "), 
[13:34:35.006]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.006]                             info)
[13:34:35.006]                           info <- base::paste(info, collapse = "; ")
[13:34:35.006]                           if (!has_future) {
[13:34:35.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.006]                               info)
[13:34:35.006]                           }
[13:34:35.006]                           else {
[13:34:35.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.006]                               info, version)
[13:34:35.006]                           }
[13:34:35.006]                           base::stop(msg)
[13:34:35.006]                         }
[13:34:35.006]                       })
[13:34:35.006]                     }
[13:34:35.006]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.006]                     base::options(mc.cores = 1L)
[13:34:35.006]                   }
[13:34:35.006]                   ...future.strategy.old <- future::plan("list")
[13:34:35.006]                   options(future.plan = NULL)
[13:34:35.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.006]                 }
[13:34:35.006]                 ...future.workdir <- getwd()
[13:34:35.006]             }
[13:34:35.006]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.006]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.006]         }
[13:34:35.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.006]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:35.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.006]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.006]             base::names(...future.oldOptions))
[13:34:35.006]     }
[13:34:35.006]     if (FALSE) {
[13:34:35.006]     }
[13:34:35.006]     else {
[13:34:35.006]         if (TRUE) {
[13:34:35.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.006]                 open = "w")
[13:34:35.006]         }
[13:34:35.006]         else {
[13:34:35.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.006]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.006]         }
[13:34:35.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.006]             base::sink(type = "output", split = FALSE)
[13:34:35.006]             base::close(...future.stdout)
[13:34:35.006]         }, add = TRUE)
[13:34:35.006]     }
[13:34:35.006]     ...future.frame <- base::sys.nframe()
[13:34:35.006]     ...future.conditions <- base::list()
[13:34:35.006]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.006]     if (FALSE) {
[13:34:35.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.006]     }
[13:34:35.006]     ...future.result <- base::tryCatch({
[13:34:35.006]         base::withCallingHandlers({
[13:34:35.006]             ...future.value <- base::withVisible(base::local({
[13:34:35.006]                 withCallingHandlers({
[13:34:35.006]                   {
[13:34:35.006]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.006]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.006]                       ...future.globals.maxSize)) {
[13:34:35.006]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.006]                       on.exit(options(oopts), add = TRUE)
[13:34:35.006]                     }
[13:34:35.006]                     {
[13:34:35.006]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.006]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.006]                         USE.NAMES = FALSE)
[13:34:35.006]                       do.call(mapply, args = args)
[13:34:35.006]                     }
[13:34:35.006]                   }
[13:34:35.006]                 }, immediateCondition = function(cond) {
[13:34:35.006]                   save_rds <- function (object, pathname, ...) 
[13:34:35.006]                   {
[13:34:35.006]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.006]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.006]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.006]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.006]                         fi_tmp[["mtime"]])
[13:34:35.006]                     }
[13:34:35.006]                     tryCatch({
[13:34:35.006]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.006]                     }, error = function(ex) {
[13:34:35.006]                       msg <- conditionMessage(ex)
[13:34:35.006]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.006]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.006]                         fi_tmp[["mtime"]], msg)
[13:34:35.006]                       ex$message <- msg
[13:34:35.006]                       stop(ex)
[13:34:35.006]                     })
[13:34:35.006]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.006]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.006]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.006]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.006]                       fi <- file.info(pathname)
[13:34:35.006]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.006]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.006]                         fi[["size"]], fi[["mtime"]])
[13:34:35.006]                       stop(msg)
[13:34:35.006]                     }
[13:34:35.006]                     invisible(pathname)
[13:34:35.006]                   }
[13:34:35.006]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.006]                     rootPath = tempdir()) 
[13:34:35.006]                   {
[13:34:35.006]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.006]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.006]                       tmpdir = path, fileext = ".rds")
[13:34:35.006]                     save_rds(obj, file)
[13:34:35.006]                   }
[13:34:35.006]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.006]                   {
[13:34:35.006]                     inherits <- base::inherits
[13:34:35.006]                     invokeRestart <- base::invokeRestart
[13:34:35.006]                     is.null <- base::is.null
[13:34:35.006]                     muffled <- FALSE
[13:34:35.006]                     if (inherits(cond, "message")) {
[13:34:35.006]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.006]                       if (muffled) 
[13:34:35.006]                         invokeRestart("muffleMessage")
[13:34:35.006]                     }
[13:34:35.006]                     else if (inherits(cond, "warning")) {
[13:34:35.006]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.006]                       if (muffled) 
[13:34:35.006]                         invokeRestart("muffleWarning")
[13:34:35.006]                     }
[13:34:35.006]                     else if (inherits(cond, "condition")) {
[13:34:35.006]                       if (!is.null(pattern)) {
[13:34:35.006]                         computeRestarts <- base::computeRestarts
[13:34:35.006]                         grepl <- base::grepl
[13:34:35.006]                         restarts <- computeRestarts(cond)
[13:34:35.006]                         for (restart in restarts) {
[13:34:35.006]                           name <- restart$name
[13:34:35.006]                           if (is.null(name)) 
[13:34:35.006]                             next
[13:34:35.006]                           if (!grepl(pattern, name)) 
[13:34:35.006]                             next
[13:34:35.006]                           invokeRestart(restart)
[13:34:35.006]                           muffled <- TRUE
[13:34:35.006]                           break
[13:34:35.006]                         }
[13:34:35.006]                       }
[13:34:35.006]                     }
[13:34:35.006]                     invisible(muffled)
[13:34:35.006]                   }
[13:34:35.006]                   muffleCondition(cond)
[13:34:35.006]                 })
[13:34:35.006]             }))
[13:34:35.006]             future::FutureResult(value = ...future.value$value, 
[13:34:35.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.006]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.006]                     ...future.globalenv.names))
[13:34:35.006]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.006]         }, condition = base::local({
[13:34:35.006]             c <- base::c
[13:34:35.006]             inherits <- base::inherits
[13:34:35.006]             invokeRestart <- base::invokeRestart
[13:34:35.006]             length <- base::length
[13:34:35.006]             list <- base::list
[13:34:35.006]             seq.int <- base::seq.int
[13:34:35.006]             signalCondition <- base::signalCondition
[13:34:35.006]             sys.calls <- base::sys.calls
[13:34:35.006]             `[[` <- base::`[[`
[13:34:35.006]             `+` <- base::`+`
[13:34:35.006]             `<<-` <- base::`<<-`
[13:34:35.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.006]                   3L)]
[13:34:35.006]             }
[13:34:35.006]             function(cond) {
[13:34:35.006]                 is_error <- inherits(cond, "error")
[13:34:35.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.006]                   NULL)
[13:34:35.006]                 if (is_error) {
[13:34:35.006]                   sessionInformation <- function() {
[13:34:35.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.006]                       search = base::search(), system = base::Sys.info())
[13:34:35.006]                   }
[13:34:35.006]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.006]                     cond$call), session = sessionInformation(), 
[13:34:35.006]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.006]                   signalCondition(cond)
[13:34:35.006]                 }
[13:34:35.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.006]                 "immediateCondition"))) {
[13:34:35.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.006]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.006]                   if (TRUE && !signal) {
[13:34:35.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.006]                     {
[13:34:35.006]                       inherits <- base::inherits
[13:34:35.006]                       invokeRestart <- base::invokeRestart
[13:34:35.006]                       is.null <- base::is.null
[13:34:35.006]                       muffled <- FALSE
[13:34:35.006]                       if (inherits(cond, "message")) {
[13:34:35.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.006]                         if (muffled) 
[13:34:35.006]                           invokeRestart("muffleMessage")
[13:34:35.006]                       }
[13:34:35.006]                       else if (inherits(cond, "warning")) {
[13:34:35.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.006]                         if (muffled) 
[13:34:35.006]                           invokeRestart("muffleWarning")
[13:34:35.006]                       }
[13:34:35.006]                       else if (inherits(cond, "condition")) {
[13:34:35.006]                         if (!is.null(pattern)) {
[13:34:35.006]                           computeRestarts <- base::computeRestarts
[13:34:35.006]                           grepl <- base::grepl
[13:34:35.006]                           restarts <- computeRestarts(cond)
[13:34:35.006]                           for (restart in restarts) {
[13:34:35.006]                             name <- restart$name
[13:34:35.006]                             if (is.null(name)) 
[13:34:35.006]                               next
[13:34:35.006]                             if (!grepl(pattern, name)) 
[13:34:35.006]                               next
[13:34:35.006]                             invokeRestart(restart)
[13:34:35.006]                             muffled <- TRUE
[13:34:35.006]                             break
[13:34:35.006]                           }
[13:34:35.006]                         }
[13:34:35.006]                       }
[13:34:35.006]                       invisible(muffled)
[13:34:35.006]                     }
[13:34:35.006]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.006]                   }
[13:34:35.006]                 }
[13:34:35.006]                 else {
[13:34:35.006]                   if (TRUE) {
[13:34:35.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.006]                     {
[13:34:35.006]                       inherits <- base::inherits
[13:34:35.006]                       invokeRestart <- base::invokeRestart
[13:34:35.006]                       is.null <- base::is.null
[13:34:35.006]                       muffled <- FALSE
[13:34:35.006]                       if (inherits(cond, "message")) {
[13:34:35.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.006]                         if (muffled) 
[13:34:35.006]                           invokeRestart("muffleMessage")
[13:34:35.006]                       }
[13:34:35.006]                       else if (inherits(cond, "warning")) {
[13:34:35.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.006]                         if (muffled) 
[13:34:35.006]                           invokeRestart("muffleWarning")
[13:34:35.006]                       }
[13:34:35.006]                       else if (inherits(cond, "condition")) {
[13:34:35.006]                         if (!is.null(pattern)) {
[13:34:35.006]                           computeRestarts <- base::computeRestarts
[13:34:35.006]                           grepl <- base::grepl
[13:34:35.006]                           restarts <- computeRestarts(cond)
[13:34:35.006]                           for (restart in restarts) {
[13:34:35.006]                             name <- restart$name
[13:34:35.006]                             if (is.null(name)) 
[13:34:35.006]                               next
[13:34:35.006]                             if (!grepl(pattern, name)) 
[13:34:35.006]                               next
[13:34:35.006]                             invokeRestart(restart)
[13:34:35.006]                             muffled <- TRUE
[13:34:35.006]                             break
[13:34:35.006]                           }
[13:34:35.006]                         }
[13:34:35.006]                       }
[13:34:35.006]                       invisible(muffled)
[13:34:35.006]                     }
[13:34:35.006]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.006]                   }
[13:34:35.006]                 }
[13:34:35.006]             }
[13:34:35.006]         }))
[13:34:35.006]     }, error = function(ex) {
[13:34:35.006]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.006]                 ...future.rng), started = ...future.startTime, 
[13:34:35.006]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.006]             version = "1.8"), class = "FutureResult")
[13:34:35.006]     }, finally = {
[13:34:35.006]         if (!identical(...future.workdir, getwd())) 
[13:34:35.006]             setwd(...future.workdir)
[13:34:35.006]         {
[13:34:35.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.006]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.006]             }
[13:34:35.006]             base::options(...future.oldOptions)
[13:34:35.006]             if (.Platform$OS.type == "windows") {
[13:34:35.006]                 old_names <- names(...future.oldEnvVars)
[13:34:35.006]                 envs <- base::Sys.getenv()
[13:34:35.006]                 names <- names(envs)
[13:34:35.006]                 common <- intersect(names, old_names)
[13:34:35.006]                 added <- setdiff(names, old_names)
[13:34:35.006]                 removed <- setdiff(old_names, names)
[13:34:35.006]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.006]                   envs[common]]
[13:34:35.006]                 NAMES <- toupper(changed)
[13:34:35.006]                 args <- list()
[13:34:35.006]                 for (kk in seq_along(NAMES)) {
[13:34:35.006]                   name <- changed[[kk]]
[13:34:35.006]                   NAME <- NAMES[[kk]]
[13:34:35.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.006]                     next
[13:34:35.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.006]                 }
[13:34:35.006]                 NAMES <- toupper(added)
[13:34:35.006]                 for (kk in seq_along(NAMES)) {
[13:34:35.006]                   name <- added[[kk]]
[13:34:35.006]                   NAME <- NAMES[[kk]]
[13:34:35.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.006]                     next
[13:34:35.006]                   args[[name]] <- ""
[13:34:35.006]                 }
[13:34:35.006]                 NAMES <- toupper(removed)
[13:34:35.006]                 for (kk in seq_along(NAMES)) {
[13:34:35.006]                   name <- removed[[kk]]
[13:34:35.006]                   NAME <- NAMES[[kk]]
[13:34:35.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.006]                     next
[13:34:35.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.006]                 }
[13:34:35.006]                 if (length(args) > 0) 
[13:34:35.006]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.006]             }
[13:34:35.006]             else {
[13:34:35.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.006]             }
[13:34:35.006]             {
[13:34:35.006]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.006]                   0L) {
[13:34:35.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.006]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.006]                   base::options(opts)
[13:34:35.006]                 }
[13:34:35.006]                 {
[13:34:35.006]                   {
[13:34:35.006]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.006]                     NULL
[13:34:35.006]                   }
[13:34:35.006]                   options(future.plan = NULL)
[13:34:35.006]                   if (is.na(NA_character_)) 
[13:34:35.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.006]                     .init = FALSE)
[13:34:35.006]                 }
[13:34:35.006]             }
[13:34:35.006]         }
[13:34:35.006]     })
[13:34:35.006]     if (TRUE) {
[13:34:35.006]         base::sink(type = "output", split = FALSE)
[13:34:35.006]         if (TRUE) {
[13:34:35.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.006]         }
[13:34:35.006]         else {
[13:34:35.006]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.006]         }
[13:34:35.006]         base::close(...future.stdout)
[13:34:35.006]         ...future.stdout <- NULL
[13:34:35.006]     }
[13:34:35.006]     ...future.result$conditions <- ...future.conditions
[13:34:35.006]     ...future.result$finished <- base::Sys.time()
[13:34:35.006]     ...future.result
[13:34:35.006] }
[13:34:35.008] assign_globals() ...
[13:34:35.008] List of 5
[13:34:35.008]  $ ...future.FUN            :function (x, ...)  
[13:34:35.008]  $ MoreArgs                 : NULL
[13:34:35.008]  $ ...future.elements_ii    :List of 2
[13:34:35.008]   ..$ times:List of 2
[13:34:35.008]   .. ..$ : int 1
[13:34:35.008]   .. ..$ : int 2
[13:34:35.008]   ..$ x    :List of 2
[13:34:35.008]   .. ..$ : int 4
[13:34:35.008]   .. ..$ : int 3
[13:34:35.008]  $ ...future.seeds_ii       : NULL
[13:34:35.008]  $ ...future.globals.maxSize: NULL
[13:34:35.008]  - attr(*, "where")=List of 5
[13:34:35.008]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.008]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.008]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.008]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.008]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.008]  - attr(*, "resolved")= logi FALSE
[13:34:35.008]  - attr(*, "total_size")= num 280
[13:34:35.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.008]  - attr(*, "already-done")= logi TRUE
[13:34:35.016] - copied ‘...future.FUN’ to environment
[13:34:35.016] - copied ‘MoreArgs’ to environment
[13:34:35.016] - copied ‘...future.elements_ii’ to environment
[13:34:35.016] - copied ‘...future.seeds_ii’ to environment
[13:34:35.017] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.017] assign_globals() ... done
[13:34:35.017] requestCore(): workers = 2
[13:34:35.019] MulticoreFuture started
[13:34:35.019] - Launch lazy future ... done
[13:34:35.020] run() for ‘MulticoreFuture’ ... done
[13:34:35.020] Created future:
[13:34:35.020] plan(): Setting new future strategy stack:
[13:34:35.020] List of future strategies:
[13:34:35.020] 1. sequential:
[13:34:35.020]    - args: function (..., envir = parent.frame())
[13:34:35.020]    - tweaked: FALSE
[13:34:35.020]    - call: NULL
[13:34:35.021] plan(): nbrOfWorkers() = 1
[13:34:35.023] plan(): Setting new future strategy stack:
[13:34:35.024] List of future strategies:
[13:34:35.024] 1. multicore:
[13:34:35.024]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.024]    - tweaked: FALSE
[13:34:35.024]    - call: plan(strategy)
[13:34:35.030] plan(): nbrOfWorkers() = 2
[13:34:35.020] MulticoreFuture:
[13:34:35.020] Label: ‘future_mapply-1’
[13:34:35.020] Expression:
[13:34:35.020] {
[13:34:35.020]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.020]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.020]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.020]         on.exit(options(oopts), add = TRUE)
[13:34:35.020]     }
[13:34:35.020]     {
[13:34:35.020]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.020]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.020]         do.call(mapply, args = args)
[13:34:35.020]     }
[13:34:35.020] }
[13:34:35.020] Lazy evaluation: FALSE
[13:34:35.020] Asynchronous evaluation: TRUE
[13:34:35.020] Local evaluation: TRUE
[13:34:35.020] Environment: R_GlobalEnv
[13:34:35.020] Capture standard output: TRUE
[13:34:35.020] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.020] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.020] Packages: <none>
[13:34:35.020] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.020] Resolved: TRUE
[13:34:35.020] Value: <not collected>
[13:34:35.020] Conditions captured: <none>
[13:34:35.020] Early signaling: FALSE
[13:34:35.020] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.020] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.031] Chunk #1 of 2 ... DONE
[13:34:35.031] Chunk #2 of 2 ...
[13:34:35.031]  - Finding globals in '...' for chunk #2 ...
[13:34:35.031] getGlobalsAndPackages() ...
[13:34:35.031] Searching for globals...
[13:34:35.032] 
[13:34:35.032] Searching for globals ... DONE
[13:34:35.033] - globals: [0] <none>
[13:34:35.033] getGlobalsAndPackages() ... DONE
[13:34:35.033]    + additional globals found: [n=0] 
[13:34:35.033]    + additional namespaces needed: [n=0] 
[13:34:35.033]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:35.033]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:35.033]  - seeds: <none>
[13:34:35.034]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.034] getGlobalsAndPackages() ...
[13:34:35.034] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.034] Resolving globals: FALSE
[13:34:35.035] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:35.036] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:35.036] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.036] 
[13:34:35.036] getGlobalsAndPackages() ... DONE
[13:34:35.037] run() for ‘Future’ ...
[13:34:35.037] - state: ‘created’
[13:34:35.037] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.042] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.042] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.042]   - Field: ‘label’
[13:34:35.042]   - Field: ‘local’
[13:34:35.043]   - Field: ‘owner’
[13:34:35.043]   - Field: ‘envir’
[13:34:35.043]   - Field: ‘workers’
[13:34:35.043]   - Field: ‘packages’
[13:34:35.043]   - Field: ‘gc’
[13:34:35.043]   - Field: ‘job’
[13:34:35.043]   - Field: ‘conditions’
[13:34:35.043]   - Field: ‘expr’
[13:34:35.044]   - Field: ‘uuid’
[13:34:35.044]   - Field: ‘seed’
[13:34:35.044]   - Field: ‘version’
[13:34:35.044]   - Field: ‘result’
[13:34:35.044]   - Field: ‘asynchronous’
[13:34:35.044]   - Field: ‘calls’
[13:34:35.044]   - Field: ‘globals’
[13:34:35.045]   - Field: ‘stdout’
[13:34:35.045]   - Field: ‘earlySignal’
[13:34:35.045]   - Field: ‘lazy’
[13:34:35.045]   - Field: ‘state’
[13:34:35.045] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.045] - Launch lazy future ...
[13:34:35.046] Packages needed by the future expression (n = 0): <none>
[13:34:35.046] Packages needed by future strategies (n = 0): <none>
[13:34:35.047] {
[13:34:35.047]     {
[13:34:35.047]         {
[13:34:35.047]             ...future.startTime <- base::Sys.time()
[13:34:35.047]             {
[13:34:35.047]                 {
[13:34:35.047]                   {
[13:34:35.047]                     {
[13:34:35.047]                       base::local({
[13:34:35.047]                         has_future <- base::requireNamespace("future", 
[13:34:35.047]                           quietly = TRUE)
[13:34:35.047]                         if (has_future) {
[13:34:35.047]                           ns <- base::getNamespace("future")
[13:34:35.047]                           version <- ns[[".package"]][["version"]]
[13:34:35.047]                           if (is.null(version)) 
[13:34:35.047]                             version <- utils::packageVersion("future")
[13:34:35.047]                         }
[13:34:35.047]                         else {
[13:34:35.047]                           version <- NULL
[13:34:35.047]                         }
[13:34:35.047]                         if (!has_future || version < "1.8.0") {
[13:34:35.047]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.047]                             "", base::R.version$version.string), 
[13:34:35.047]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.047]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.047]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.047]                               "release", "version")], collapse = " "), 
[13:34:35.047]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.047]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.047]                             info)
[13:34:35.047]                           info <- base::paste(info, collapse = "; ")
[13:34:35.047]                           if (!has_future) {
[13:34:35.047]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.047]                               info)
[13:34:35.047]                           }
[13:34:35.047]                           else {
[13:34:35.047]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.047]                               info, version)
[13:34:35.047]                           }
[13:34:35.047]                           base::stop(msg)
[13:34:35.047]                         }
[13:34:35.047]                       })
[13:34:35.047]                     }
[13:34:35.047]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.047]                     base::options(mc.cores = 1L)
[13:34:35.047]                   }
[13:34:35.047]                   ...future.strategy.old <- future::plan("list")
[13:34:35.047]                   options(future.plan = NULL)
[13:34:35.047]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.047]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.047]                 }
[13:34:35.047]                 ...future.workdir <- getwd()
[13:34:35.047]             }
[13:34:35.047]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.047]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.047]         }
[13:34:35.047]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.047]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:35.047]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.047]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.047]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.047]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.047]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.047]             base::names(...future.oldOptions))
[13:34:35.047]     }
[13:34:35.047]     if (FALSE) {
[13:34:35.047]     }
[13:34:35.047]     else {
[13:34:35.047]         if (TRUE) {
[13:34:35.047]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.047]                 open = "w")
[13:34:35.047]         }
[13:34:35.047]         else {
[13:34:35.047]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.047]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.047]         }
[13:34:35.047]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.047]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.047]             base::sink(type = "output", split = FALSE)
[13:34:35.047]             base::close(...future.stdout)
[13:34:35.047]         }, add = TRUE)
[13:34:35.047]     }
[13:34:35.047]     ...future.frame <- base::sys.nframe()
[13:34:35.047]     ...future.conditions <- base::list()
[13:34:35.047]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.047]     if (FALSE) {
[13:34:35.047]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.047]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.047]     }
[13:34:35.047]     ...future.result <- base::tryCatch({
[13:34:35.047]         base::withCallingHandlers({
[13:34:35.047]             ...future.value <- base::withVisible(base::local({
[13:34:35.047]                 withCallingHandlers({
[13:34:35.047]                   {
[13:34:35.047]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.047]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.047]                       ...future.globals.maxSize)) {
[13:34:35.047]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.047]                       on.exit(options(oopts), add = TRUE)
[13:34:35.047]                     }
[13:34:35.047]                     {
[13:34:35.047]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.047]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.047]                         USE.NAMES = FALSE)
[13:34:35.047]                       do.call(mapply, args = args)
[13:34:35.047]                     }
[13:34:35.047]                   }
[13:34:35.047]                 }, immediateCondition = function(cond) {
[13:34:35.047]                   save_rds <- function (object, pathname, ...) 
[13:34:35.047]                   {
[13:34:35.047]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.047]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.047]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.047]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.047]                         fi_tmp[["mtime"]])
[13:34:35.047]                     }
[13:34:35.047]                     tryCatch({
[13:34:35.047]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.047]                     }, error = function(ex) {
[13:34:35.047]                       msg <- conditionMessage(ex)
[13:34:35.047]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.047]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.047]                         fi_tmp[["mtime"]], msg)
[13:34:35.047]                       ex$message <- msg
[13:34:35.047]                       stop(ex)
[13:34:35.047]                     })
[13:34:35.047]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.047]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.047]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.047]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.047]                       fi <- file.info(pathname)
[13:34:35.047]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.047]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.047]                         fi[["size"]], fi[["mtime"]])
[13:34:35.047]                       stop(msg)
[13:34:35.047]                     }
[13:34:35.047]                     invisible(pathname)
[13:34:35.047]                   }
[13:34:35.047]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.047]                     rootPath = tempdir()) 
[13:34:35.047]                   {
[13:34:35.047]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.047]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.047]                       tmpdir = path, fileext = ".rds")
[13:34:35.047]                     save_rds(obj, file)
[13:34:35.047]                   }
[13:34:35.047]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.047]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.047]                   {
[13:34:35.047]                     inherits <- base::inherits
[13:34:35.047]                     invokeRestart <- base::invokeRestart
[13:34:35.047]                     is.null <- base::is.null
[13:34:35.047]                     muffled <- FALSE
[13:34:35.047]                     if (inherits(cond, "message")) {
[13:34:35.047]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.047]                       if (muffled) 
[13:34:35.047]                         invokeRestart("muffleMessage")
[13:34:35.047]                     }
[13:34:35.047]                     else if (inherits(cond, "warning")) {
[13:34:35.047]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.047]                       if (muffled) 
[13:34:35.047]                         invokeRestart("muffleWarning")
[13:34:35.047]                     }
[13:34:35.047]                     else if (inherits(cond, "condition")) {
[13:34:35.047]                       if (!is.null(pattern)) {
[13:34:35.047]                         computeRestarts <- base::computeRestarts
[13:34:35.047]                         grepl <- base::grepl
[13:34:35.047]                         restarts <- computeRestarts(cond)
[13:34:35.047]                         for (restart in restarts) {
[13:34:35.047]                           name <- restart$name
[13:34:35.047]                           if (is.null(name)) 
[13:34:35.047]                             next
[13:34:35.047]                           if (!grepl(pattern, name)) 
[13:34:35.047]                             next
[13:34:35.047]                           invokeRestart(restart)
[13:34:35.047]                           muffled <- TRUE
[13:34:35.047]                           break
[13:34:35.047]                         }
[13:34:35.047]                       }
[13:34:35.047]                     }
[13:34:35.047]                     invisible(muffled)
[13:34:35.047]                   }
[13:34:35.047]                   muffleCondition(cond)
[13:34:35.047]                 })
[13:34:35.047]             }))
[13:34:35.047]             future::FutureResult(value = ...future.value$value, 
[13:34:35.047]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.047]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.047]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.047]                     ...future.globalenv.names))
[13:34:35.047]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.047]         }, condition = base::local({
[13:34:35.047]             c <- base::c
[13:34:35.047]             inherits <- base::inherits
[13:34:35.047]             invokeRestart <- base::invokeRestart
[13:34:35.047]             length <- base::length
[13:34:35.047]             list <- base::list
[13:34:35.047]             seq.int <- base::seq.int
[13:34:35.047]             signalCondition <- base::signalCondition
[13:34:35.047]             sys.calls <- base::sys.calls
[13:34:35.047]             `[[` <- base::`[[`
[13:34:35.047]             `+` <- base::`+`
[13:34:35.047]             `<<-` <- base::`<<-`
[13:34:35.047]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.047]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.047]                   3L)]
[13:34:35.047]             }
[13:34:35.047]             function(cond) {
[13:34:35.047]                 is_error <- inherits(cond, "error")
[13:34:35.047]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.047]                   NULL)
[13:34:35.047]                 if (is_error) {
[13:34:35.047]                   sessionInformation <- function() {
[13:34:35.047]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.047]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.047]                       search = base::search(), system = base::Sys.info())
[13:34:35.047]                   }
[13:34:35.047]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.047]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.047]                     cond$call), session = sessionInformation(), 
[13:34:35.047]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.047]                   signalCondition(cond)
[13:34:35.047]                 }
[13:34:35.047]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.047]                 "immediateCondition"))) {
[13:34:35.047]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.047]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.047]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.047]                   if (TRUE && !signal) {
[13:34:35.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.047]                     {
[13:34:35.047]                       inherits <- base::inherits
[13:34:35.047]                       invokeRestart <- base::invokeRestart
[13:34:35.047]                       is.null <- base::is.null
[13:34:35.047]                       muffled <- FALSE
[13:34:35.047]                       if (inherits(cond, "message")) {
[13:34:35.047]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.047]                         if (muffled) 
[13:34:35.047]                           invokeRestart("muffleMessage")
[13:34:35.047]                       }
[13:34:35.047]                       else if (inherits(cond, "warning")) {
[13:34:35.047]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.047]                         if (muffled) 
[13:34:35.047]                           invokeRestart("muffleWarning")
[13:34:35.047]                       }
[13:34:35.047]                       else if (inherits(cond, "condition")) {
[13:34:35.047]                         if (!is.null(pattern)) {
[13:34:35.047]                           computeRestarts <- base::computeRestarts
[13:34:35.047]                           grepl <- base::grepl
[13:34:35.047]                           restarts <- computeRestarts(cond)
[13:34:35.047]                           for (restart in restarts) {
[13:34:35.047]                             name <- restart$name
[13:34:35.047]                             if (is.null(name)) 
[13:34:35.047]                               next
[13:34:35.047]                             if (!grepl(pattern, name)) 
[13:34:35.047]                               next
[13:34:35.047]                             invokeRestart(restart)
[13:34:35.047]                             muffled <- TRUE
[13:34:35.047]                             break
[13:34:35.047]                           }
[13:34:35.047]                         }
[13:34:35.047]                       }
[13:34:35.047]                       invisible(muffled)
[13:34:35.047]                     }
[13:34:35.047]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.047]                   }
[13:34:35.047]                 }
[13:34:35.047]                 else {
[13:34:35.047]                   if (TRUE) {
[13:34:35.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.047]                     {
[13:34:35.047]                       inherits <- base::inherits
[13:34:35.047]                       invokeRestart <- base::invokeRestart
[13:34:35.047]                       is.null <- base::is.null
[13:34:35.047]                       muffled <- FALSE
[13:34:35.047]                       if (inherits(cond, "message")) {
[13:34:35.047]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.047]                         if (muffled) 
[13:34:35.047]                           invokeRestart("muffleMessage")
[13:34:35.047]                       }
[13:34:35.047]                       else if (inherits(cond, "warning")) {
[13:34:35.047]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.047]                         if (muffled) 
[13:34:35.047]                           invokeRestart("muffleWarning")
[13:34:35.047]                       }
[13:34:35.047]                       else if (inherits(cond, "condition")) {
[13:34:35.047]                         if (!is.null(pattern)) {
[13:34:35.047]                           computeRestarts <- base::computeRestarts
[13:34:35.047]                           grepl <- base::grepl
[13:34:35.047]                           restarts <- computeRestarts(cond)
[13:34:35.047]                           for (restart in restarts) {
[13:34:35.047]                             name <- restart$name
[13:34:35.047]                             if (is.null(name)) 
[13:34:35.047]                               next
[13:34:35.047]                             if (!grepl(pattern, name)) 
[13:34:35.047]                               next
[13:34:35.047]                             invokeRestart(restart)
[13:34:35.047]                             muffled <- TRUE
[13:34:35.047]                             break
[13:34:35.047]                           }
[13:34:35.047]                         }
[13:34:35.047]                       }
[13:34:35.047]                       invisible(muffled)
[13:34:35.047]                     }
[13:34:35.047]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.047]                   }
[13:34:35.047]                 }
[13:34:35.047]             }
[13:34:35.047]         }))
[13:34:35.047]     }, error = function(ex) {
[13:34:35.047]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.047]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.047]                 ...future.rng), started = ...future.startTime, 
[13:34:35.047]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.047]             version = "1.8"), class = "FutureResult")
[13:34:35.047]     }, finally = {
[13:34:35.047]         if (!identical(...future.workdir, getwd())) 
[13:34:35.047]             setwd(...future.workdir)
[13:34:35.047]         {
[13:34:35.047]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.047]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.047]             }
[13:34:35.047]             base::options(...future.oldOptions)
[13:34:35.047]             if (.Platform$OS.type == "windows") {
[13:34:35.047]                 old_names <- names(...future.oldEnvVars)
[13:34:35.047]                 envs <- base::Sys.getenv()
[13:34:35.047]                 names <- names(envs)
[13:34:35.047]                 common <- intersect(names, old_names)
[13:34:35.047]                 added <- setdiff(names, old_names)
[13:34:35.047]                 removed <- setdiff(old_names, names)
[13:34:35.047]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.047]                   envs[common]]
[13:34:35.047]                 NAMES <- toupper(changed)
[13:34:35.047]                 args <- list()
[13:34:35.047]                 for (kk in seq_along(NAMES)) {
[13:34:35.047]                   name <- changed[[kk]]
[13:34:35.047]                   NAME <- NAMES[[kk]]
[13:34:35.047]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.047]                     next
[13:34:35.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.047]                 }
[13:34:35.047]                 NAMES <- toupper(added)
[13:34:35.047]                 for (kk in seq_along(NAMES)) {
[13:34:35.047]                   name <- added[[kk]]
[13:34:35.047]                   NAME <- NAMES[[kk]]
[13:34:35.047]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.047]                     next
[13:34:35.047]                   args[[name]] <- ""
[13:34:35.047]                 }
[13:34:35.047]                 NAMES <- toupper(removed)
[13:34:35.047]                 for (kk in seq_along(NAMES)) {
[13:34:35.047]                   name <- removed[[kk]]
[13:34:35.047]                   NAME <- NAMES[[kk]]
[13:34:35.047]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.047]                     next
[13:34:35.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.047]                 }
[13:34:35.047]                 if (length(args) > 0) 
[13:34:35.047]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.047]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.047]             }
[13:34:35.047]             else {
[13:34:35.047]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.047]             }
[13:34:35.047]             {
[13:34:35.047]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.047]                   0L) {
[13:34:35.047]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.047]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.047]                   base::options(opts)
[13:34:35.047]                 }
[13:34:35.047]                 {
[13:34:35.047]                   {
[13:34:35.047]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.047]                     NULL
[13:34:35.047]                   }
[13:34:35.047]                   options(future.plan = NULL)
[13:34:35.047]                   if (is.na(NA_character_)) 
[13:34:35.047]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.047]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.047]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.047]                     .init = FALSE)
[13:34:35.047]                 }
[13:34:35.047]             }
[13:34:35.047]         }
[13:34:35.047]     })
[13:34:35.047]     if (TRUE) {
[13:34:35.047]         base::sink(type = "output", split = FALSE)
[13:34:35.047]         if (TRUE) {
[13:34:35.047]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.047]         }
[13:34:35.047]         else {
[13:34:35.047]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.047]         }
[13:34:35.047]         base::close(...future.stdout)
[13:34:35.047]         ...future.stdout <- NULL
[13:34:35.047]     }
[13:34:35.047]     ...future.result$conditions <- ...future.conditions
[13:34:35.047]     ...future.result$finished <- base::Sys.time()
[13:34:35.047]     ...future.result
[13:34:35.047] }
[13:34:35.050] assign_globals() ...
[13:34:35.050] List of 5
[13:34:35.050]  $ ...future.FUN            :function (x, ...)  
[13:34:35.050]  $ MoreArgs                 : NULL
[13:34:35.050]  $ ...future.elements_ii    :List of 2
[13:34:35.050]   ..$ times:List of 2
[13:34:35.050]   .. ..$ : int 3
[13:34:35.050]   .. ..$ : int 4
[13:34:35.050]   ..$ x    :List of 2
[13:34:35.050]   .. ..$ : int 2
[13:34:35.050]   .. ..$ : int 1
[13:34:35.050]  $ ...future.seeds_ii       : NULL
[13:34:35.050]  $ ...future.globals.maxSize: NULL
[13:34:35.050]  - attr(*, "where")=List of 5
[13:34:35.050]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.050]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.050]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.050]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.050]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.050]  - attr(*, "resolved")= logi FALSE
[13:34:35.050]  - attr(*, "total_size")= num 280
[13:34:35.050]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.050]  - attr(*, "already-done")= logi TRUE
[13:34:35.062] - copied ‘...future.FUN’ to environment
[13:34:35.063] - copied ‘MoreArgs’ to environment
[13:34:35.063] - copied ‘...future.elements_ii’ to environment
[13:34:35.063] - copied ‘...future.seeds_ii’ to environment
[13:34:35.063] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.063] assign_globals() ... done
[13:34:35.064] requestCore(): workers = 2
[13:34:35.066] MulticoreFuture started
[13:34:35.067] - Launch lazy future ... done
[13:34:35.067] run() for ‘MulticoreFuture’ ... done
[13:34:35.068] plan(): Setting new future strategy stack:
[13:34:35.068] Created future:
[13:34:35.068] List of future strategies:
[13:34:35.068] 1. sequential:
[13:34:35.068]    - args: function (..., envir = parent.frame())
[13:34:35.068]    - tweaked: FALSE
[13:34:35.068]    - call: NULL
[13:34:35.069] plan(): nbrOfWorkers() = 1
[13:34:35.072] plan(): Setting new future strategy stack:
[13:34:35.072] List of future strategies:
[13:34:35.072] 1. multicore:
[13:34:35.072]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.072]    - tweaked: FALSE
[13:34:35.072]    - call: plan(strategy)
[13:34:35.078] plan(): nbrOfWorkers() = 2
[13:34:35.068] MulticoreFuture:
[13:34:35.068] Label: ‘future_mapply-2’
[13:34:35.068] Expression:
[13:34:35.068] {
[13:34:35.068]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.068]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.068]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.068]         on.exit(options(oopts), add = TRUE)
[13:34:35.068]     }
[13:34:35.068]     {
[13:34:35.068]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.068]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.068]         do.call(mapply, args = args)
[13:34:35.068]     }
[13:34:35.068] }
[13:34:35.068] Lazy evaluation: FALSE
[13:34:35.068] Asynchronous evaluation: TRUE
[13:34:35.068] Local evaluation: TRUE
[13:34:35.068] Environment: R_GlobalEnv
[13:34:35.068] Capture standard output: TRUE
[13:34:35.068] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.068] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.068] Packages: <none>
[13:34:35.068] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.068] Resolved: TRUE
[13:34:35.068] Value: <not collected>
[13:34:35.068] Conditions captured: <none>
[13:34:35.068] Early signaling: FALSE
[13:34:35.068] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.068] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.079] Chunk #2 of 2 ... DONE
[13:34:35.079] Launching 2 futures (chunks) ... DONE
[13:34:35.079] Resolving 2 futures (chunks) ...
[13:34:35.080] resolve() on list ...
[13:34:35.080]  recursive: 0
[13:34:35.080]  length: 2
[13:34:35.080] 
[13:34:35.081] Future #1
[13:34:35.081] result() for MulticoreFuture ...
[13:34:35.082] result() for MulticoreFuture ...
[13:34:35.082] result() for MulticoreFuture ... done
[13:34:35.082] result() for MulticoreFuture ... done
[13:34:35.082] result() for MulticoreFuture ...
[13:34:35.082] result() for MulticoreFuture ... done
[13:34:35.083] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:35.083] - nx: 2
[13:34:35.083] - relay: TRUE
[13:34:35.083] - stdout: TRUE
[13:34:35.083] - signal: TRUE
[13:34:35.083] - resignal: FALSE
[13:34:35.084] - force: TRUE
[13:34:35.084] - relayed: [n=2] FALSE, FALSE
[13:34:35.084] - queued futures: [n=2] FALSE, FALSE
[13:34:35.084]  - until=1
[13:34:35.085]  - relaying element #1
[13:34:35.085] result() for MulticoreFuture ...
[13:34:35.085] result() for MulticoreFuture ... done
[13:34:35.085] result() for MulticoreFuture ...
[13:34:35.085] result() for MulticoreFuture ... done
[13:34:35.085] result() for MulticoreFuture ...
[13:34:35.086] result() for MulticoreFuture ... done
[13:34:35.086] result() for MulticoreFuture ...
[13:34:35.086] result() for MulticoreFuture ... done
[13:34:35.086] - relayed: [n=2] TRUE, FALSE
[13:34:35.086] - queued futures: [n=2] TRUE, FALSE
[13:34:35.087] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:35.087]  length: 1 (resolved future 1)
[13:34:35.087] Future #2
[13:34:35.087] result() for MulticoreFuture ...
[13:34:35.088] result() for MulticoreFuture ...
[13:34:35.088] result() for MulticoreFuture ... done
[13:34:35.088] result() for MulticoreFuture ... done
[13:34:35.088] result() for MulticoreFuture ...
[13:34:35.089] result() for MulticoreFuture ... done
[13:34:35.089] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:35.089] - nx: 2
[13:34:35.089] - relay: TRUE
[13:34:35.089] - stdout: TRUE
[13:34:35.089] - signal: TRUE
[13:34:35.089] - resignal: FALSE
[13:34:35.089] - force: TRUE
[13:34:35.089] - relayed: [n=2] TRUE, FALSE
[13:34:35.090] - queued futures: [n=2] TRUE, FALSE
[13:34:35.090]  - until=2
[13:34:35.090]  - relaying element #2
[13:34:35.090] result() for MulticoreFuture ...
[13:34:35.090] result() for MulticoreFuture ... done
[13:34:35.090] result() for MulticoreFuture ...
[13:34:35.090] result() for MulticoreFuture ... done
[13:34:35.091] result() for MulticoreFuture ...
[13:34:35.091] result() for MulticoreFuture ... done
[13:34:35.091] result() for MulticoreFuture ...
[13:34:35.091] result() for MulticoreFuture ... done
[13:34:35.091] - relayed: [n=2] TRUE, TRUE
[13:34:35.091] - queued futures: [n=2] TRUE, TRUE
[13:34:35.091] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:35.091]  length: 0 (resolved future 2)
[13:34:35.091] Relaying remaining futures
[13:34:35.091] signalConditionsASAP(NULL, pos=0) ...
[13:34:35.092] - nx: 2
[13:34:35.092] - relay: TRUE
[13:34:35.092] - stdout: TRUE
[13:34:35.092] - signal: TRUE
[13:34:35.092] - resignal: FALSE
[13:34:35.092] - force: TRUE
[13:34:35.092] - relayed: [n=2] TRUE, TRUE
[13:34:35.092] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:35.092] - relayed: [n=2] TRUE, TRUE
[13:34:35.093] - queued futures: [n=2] TRUE, TRUE
[13:34:35.093] signalConditionsASAP(NULL, pos=0) ... done
[13:34:35.093] resolve() on list ... DONE
[13:34:35.093] result() for MulticoreFuture ...
[13:34:35.093] result() for MulticoreFuture ... done
[13:34:35.093] result() for MulticoreFuture ...
[13:34:35.093] result() for MulticoreFuture ... done
[13:34:35.093] result() for MulticoreFuture ...
[13:34:35.093] result() for MulticoreFuture ... done
[13:34:35.094] result() for MulticoreFuture ...
[13:34:35.094] result() for MulticoreFuture ... done
[13:34:35.094]  - Number of value chunks collected: 2
[13:34:35.094] Resolving 2 futures (chunks) ... DONE
[13:34:35.094] Reducing values from 2 chunks ...
[13:34:35.094]  - Number of values collected after concatenation: 4
[13:34:35.094]  - Number of values expected: 4
[13:34:35.094] Reducing values from 2 chunks ... DONE
[13:34:35.095] future_mapply() ... DONE
[13:34:35.095] future_mapply() ...
[13:34:35.099] Number of chunks: 2
[13:34:35.099] getGlobalsAndPackagesXApply() ...
[13:34:35.099]  - future.globals: TRUE
[13:34:35.099] getGlobalsAndPackages() ...
[13:34:35.100] Searching for globals...
[13:34:35.100] - globals found: [1] ‘FUN’
[13:34:35.101] Searching for globals ... DONE
[13:34:35.101] Resolving globals: FALSE
[13:34:35.101] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:35.102] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:35.102] - globals: [1] ‘FUN’
[13:34:35.102] 
[13:34:35.102] getGlobalsAndPackages() ... DONE
[13:34:35.102]  - globals found/used: [n=1] ‘FUN’
[13:34:35.102]  - needed namespaces: [n=0] 
[13:34:35.102] Finding globals ... DONE
[13:34:35.103] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:35.103] List of 2
[13:34:35.103]  $ ...future.FUN:function (x, ...)  
[13:34:35.103]  $ MoreArgs     :List of 1
[13:34:35.103]   ..$ x: num 42
[13:34:35.103]  - attr(*, "where")=List of 2
[13:34:35.103]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:35.103]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:35.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.103]  - attr(*, "resolved")= logi FALSE
[13:34:35.103]  - attr(*, "total_size")= num NA
[13:34:35.109] Packages to be attached in all futures: [n=0] 
[13:34:35.109] getGlobalsAndPackagesXApply() ... DONE
[13:34:35.109] Number of futures (= number of chunks): 2
[13:34:35.109] Launching 2 futures (chunks) ...
[13:34:35.109] Chunk #1 of 2 ...
[13:34:35.109]  - Finding globals in '...' for chunk #1 ...
[13:34:35.110] getGlobalsAndPackages() ...
[13:34:35.110] Searching for globals...
[13:34:35.110] 
[13:34:35.110] Searching for globals ... DONE
[13:34:35.110] - globals: [0] <none>
[13:34:35.110] getGlobalsAndPackages() ... DONE
[13:34:35.111]    + additional globals found: [n=0] 
[13:34:35.111]    + additional namespaces needed: [n=0] 
[13:34:35.111]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:35.111]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:35.111]  - seeds: <none>
[13:34:35.111]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.111] getGlobalsAndPackages() ...
[13:34:35.111] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.111] Resolving globals: FALSE
[13:34:35.112] The total size of the 5 globals is 224 bytes (224 bytes)
[13:34:35.112] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[13:34:35.113] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.113] 
[13:34:35.113] getGlobalsAndPackages() ... DONE
[13:34:35.113] run() for ‘Future’ ...
[13:34:35.113] - state: ‘created’
[13:34:35.113] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.117] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.117] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.117]   - Field: ‘label’
[13:34:35.117]   - Field: ‘local’
[13:34:35.117]   - Field: ‘owner’
[13:34:35.118]   - Field: ‘envir’
[13:34:35.118]   - Field: ‘workers’
[13:34:35.118]   - Field: ‘packages’
[13:34:35.118]   - Field: ‘gc’
[13:34:35.118]   - Field: ‘job’
[13:34:35.118]   - Field: ‘conditions’
[13:34:35.118]   - Field: ‘expr’
[13:34:35.118]   - Field: ‘uuid’
[13:34:35.118]   - Field: ‘seed’
[13:34:35.118]   - Field: ‘version’
[13:34:35.118]   - Field: ‘result’
[13:34:35.119]   - Field: ‘asynchronous’
[13:34:35.119]   - Field: ‘calls’
[13:34:35.119]   - Field: ‘globals’
[13:34:35.119]   - Field: ‘stdout’
[13:34:35.119]   - Field: ‘earlySignal’
[13:34:35.119]   - Field: ‘lazy’
[13:34:35.119]   - Field: ‘state’
[13:34:35.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.119] - Launch lazy future ...
[13:34:35.120] Packages needed by the future expression (n = 0): <none>
[13:34:35.120] Packages needed by future strategies (n = 0): <none>
[13:34:35.120] {
[13:34:35.120]     {
[13:34:35.120]         {
[13:34:35.120]             ...future.startTime <- base::Sys.time()
[13:34:35.120]             {
[13:34:35.120]                 {
[13:34:35.120]                   {
[13:34:35.120]                     {
[13:34:35.120]                       base::local({
[13:34:35.120]                         has_future <- base::requireNamespace("future", 
[13:34:35.120]                           quietly = TRUE)
[13:34:35.120]                         if (has_future) {
[13:34:35.120]                           ns <- base::getNamespace("future")
[13:34:35.120]                           version <- ns[[".package"]][["version"]]
[13:34:35.120]                           if (is.null(version)) 
[13:34:35.120]                             version <- utils::packageVersion("future")
[13:34:35.120]                         }
[13:34:35.120]                         else {
[13:34:35.120]                           version <- NULL
[13:34:35.120]                         }
[13:34:35.120]                         if (!has_future || version < "1.8.0") {
[13:34:35.120]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.120]                             "", base::R.version$version.string), 
[13:34:35.120]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.120]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.120]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.120]                               "release", "version")], collapse = " "), 
[13:34:35.120]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.120]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.120]                             info)
[13:34:35.120]                           info <- base::paste(info, collapse = "; ")
[13:34:35.120]                           if (!has_future) {
[13:34:35.120]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.120]                               info)
[13:34:35.120]                           }
[13:34:35.120]                           else {
[13:34:35.120]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.120]                               info, version)
[13:34:35.120]                           }
[13:34:35.120]                           base::stop(msg)
[13:34:35.120]                         }
[13:34:35.120]                       })
[13:34:35.120]                     }
[13:34:35.120]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.120]                     base::options(mc.cores = 1L)
[13:34:35.120]                   }
[13:34:35.120]                   ...future.strategy.old <- future::plan("list")
[13:34:35.120]                   options(future.plan = NULL)
[13:34:35.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.120]                 }
[13:34:35.120]                 ...future.workdir <- getwd()
[13:34:35.120]             }
[13:34:35.120]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.120]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.120]         }
[13:34:35.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.120]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:35.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.120]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.120]             base::names(...future.oldOptions))
[13:34:35.120]     }
[13:34:35.120]     if (FALSE) {
[13:34:35.120]     }
[13:34:35.120]     else {
[13:34:35.120]         if (TRUE) {
[13:34:35.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.120]                 open = "w")
[13:34:35.120]         }
[13:34:35.120]         else {
[13:34:35.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.120]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.120]         }
[13:34:35.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.120]             base::sink(type = "output", split = FALSE)
[13:34:35.120]             base::close(...future.stdout)
[13:34:35.120]         }, add = TRUE)
[13:34:35.120]     }
[13:34:35.120]     ...future.frame <- base::sys.nframe()
[13:34:35.120]     ...future.conditions <- base::list()
[13:34:35.120]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.120]     if (FALSE) {
[13:34:35.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.120]     }
[13:34:35.120]     ...future.result <- base::tryCatch({
[13:34:35.120]         base::withCallingHandlers({
[13:34:35.120]             ...future.value <- base::withVisible(base::local({
[13:34:35.120]                 withCallingHandlers({
[13:34:35.120]                   {
[13:34:35.120]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.120]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.120]                       ...future.globals.maxSize)) {
[13:34:35.120]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.120]                       on.exit(options(oopts), add = TRUE)
[13:34:35.120]                     }
[13:34:35.120]                     {
[13:34:35.120]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.120]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.120]                         USE.NAMES = FALSE)
[13:34:35.120]                       do.call(mapply, args = args)
[13:34:35.120]                     }
[13:34:35.120]                   }
[13:34:35.120]                 }, immediateCondition = function(cond) {
[13:34:35.120]                   save_rds <- function (object, pathname, ...) 
[13:34:35.120]                   {
[13:34:35.120]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.120]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.120]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.120]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.120]                         fi_tmp[["mtime"]])
[13:34:35.120]                     }
[13:34:35.120]                     tryCatch({
[13:34:35.120]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.120]                     }, error = function(ex) {
[13:34:35.120]                       msg <- conditionMessage(ex)
[13:34:35.120]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.120]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.120]                         fi_tmp[["mtime"]], msg)
[13:34:35.120]                       ex$message <- msg
[13:34:35.120]                       stop(ex)
[13:34:35.120]                     })
[13:34:35.120]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.120]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.120]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.120]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.120]                       fi <- file.info(pathname)
[13:34:35.120]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.120]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.120]                         fi[["size"]], fi[["mtime"]])
[13:34:35.120]                       stop(msg)
[13:34:35.120]                     }
[13:34:35.120]                     invisible(pathname)
[13:34:35.120]                   }
[13:34:35.120]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.120]                     rootPath = tempdir()) 
[13:34:35.120]                   {
[13:34:35.120]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.120]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.120]                       tmpdir = path, fileext = ".rds")
[13:34:35.120]                     save_rds(obj, file)
[13:34:35.120]                   }
[13:34:35.120]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.120]                   {
[13:34:35.120]                     inherits <- base::inherits
[13:34:35.120]                     invokeRestart <- base::invokeRestart
[13:34:35.120]                     is.null <- base::is.null
[13:34:35.120]                     muffled <- FALSE
[13:34:35.120]                     if (inherits(cond, "message")) {
[13:34:35.120]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.120]                       if (muffled) 
[13:34:35.120]                         invokeRestart("muffleMessage")
[13:34:35.120]                     }
[13:34:35.120]                     else if (inherits(cond, "warning")) {
[13:34:35.120]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.120]                       if (muffled) 
[13:34:35.120]                         invokeRestart("muffleWarning")
[13:34:35.120]                     }
[13:34:35.120]                     else if (inherits(cond, "condition")) {
[13:34:35.120]                       if (!is.null(pattern)) {
[13:34:35.120]                         computeRestarts <- base::computeRestarts
[13:34:35.120]                         grepl <- base::grepl
[13:34:35.120]                         restarts <- computeRestarts(cond)
[13:34:35.120]                         for (restart in restarts) {
[13:34:35.120]                           name <- restart$name
[13:34:35.120]                           if (is.null(name)) 
[13:34:35.120]                             next
[13:34:35.120]                           if (!grepl(pattern, name)) 
[13:34:35.120]                             next
[13:34:35.120]                           invokeRestart(restart)
[13:34:35.120]                           muffled <- TRUE
[13:34:35.120]                           break
[13:34:35.120]                         }
[13:34:35.120]                       }
[13:34:35.120]                     }
[13:34:35.120]                     invisible(muffled)
[13:34:35.120]                   }
[13:34:35.120]                   muffleCondition(cond)
[13:34:35.120]                 })
[13:34:35.120]             }))
[13:34:35.120]             future::FutureResult(value = ...future.value$value, 
[13:34:35.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.120]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.120]                     ...future.globalenv.names))
[13:34:35.120]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.120]         }, condition = base::local({
[13:34:35.120]             c <- base::c
[13:34:35.120]             inherits <- base::inherits
[13:34:35.120]             invokeRestart <- base::invokeRestart
[13:34:35.120]             length <- base::length
[13:34:35.120]             list <- base::list
[13:34:35.120]             seq.int <- base::seq.int
[13:34:35.120]             signalCondition <- base::signalCondition
[13:34:35.120]             sys.calls <- base::sys.calls
[13:34:35.120]             `[[` <- base::`[[`
[13:34:35.120]             `+` <- base::`+`
[13:34:35.120]             `<<-` <- base::`<<-`
[13:34:35.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.120]                   3L)]
[13:34:35.120]             }
[13:34:35.120]             function(cond) {
[13:34:35.120]                 is_error <- inherits(cond, "error")
[13:34:35.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.120]                   NULL)
[13:34:35.120]                 if (is_error) {
[13:34:35.120]                   sessionInformation <- function() {
[13:34:35.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.120]                       search = base::search(), system = base::Sys.info())
[13:34:35.120]                   }
[13:34:35.120]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.120]                     cond$call), session = sessionInformation(), 
[13:34:35.120]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.120]                   signalCondition(cond)
[13:34:35.120]                 }
[13:34:35.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.120]                 "immediateCondition"))) {
[13:34:35.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.120]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.120]                   if (TRUE && !signal) {
[13:34:35.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.120]                     {
[13:34:35.120]                       inherits <- base::inherits
[13:34:35.120]                       invokeRestart <- base::invokeRestart
[13:34:35.120]                       is.null <- base::is.null
[13:34:35.120]                       muffled <- FALSE
[13:34:35.120]                       if (inherits(cond, "message")) {
[13:34:35.120]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.120]                         if (muffled) 
[13:34:35.120]                           invokeRestart("muffleMessage")
[13:34:35.120]                       }
[13:34:35.120]                       else if (inherits(cond, "warning")) {
[13:34:35.120]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.120]                         if (muffled) 
[13:34:35.120]                           invokeRestart("muffleWarning")
[13:34:35.120]                       }
[13:34:35.120]                       else if (inherits(cond, "condition")) {
[13:34:35.120]                         if (!is.null(pattern)) {
[13:34:35.120]                           computeRestarts <- base::computeRestarts
[13:34:35.120]                           grepl <- base::grepl
[13:34:35.120]                           restarts <- computeRestarts(cond)
[13:34:35.120]                           for (restart in restarts) {
[13:34:35.120]                             name <- restart$name
[13:34:35.120]                             if (is.null(name)) 
[13:34:35.120]                               next
[13:34:35.120]                             if (!grepl(pattern, name)) 
[13:34:35.120]                               next
[13:34:35.120]                             invokeRestart(restart)
[13:34:35.120]                             muffled <- TRUE
[13:34:35.120]                             break
[13:34:35.120]                           }
[13:34:35.120]                         }
[13:34:35.120]                       }
[13:34:35.120]                       invisible(muffled)
[13:34:35.120]                     }
[13:34:35.120]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.120]                   }
[13:34:35.120]                 }
[13:34:35.120]                 else {
[13:34:35.120]                   if (TRUE) {
[13:34:35.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.120]                     {
[13:34:35.120]                       inherits <- base::inherits
[13:34:35.120]                       invokeRestart <- base::invokeRestart
[13:34:35.120]                       is.null <- base::is.null
[13:34:35.120]                       muffled <- FALSE
[13:34:35.120]                       if (inherits(cond, "message")) {
[13:34:35.120]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.120]                         if (muffled) 
[13:34:35.120]                           invokeRestart("muffleMessage")
[13:34:35.120]                       }
[13:34:35.120]                       else if (inherits(cond, "warning")) {
[13:34:35.120]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.120]                         if (muffled) 
[13:34:35.120]                           invokeRestart("muffleWarning")
[13:34:35.120]                       }
[13:34:35.120]                       else if (inherits(cond, "condition")) {
[13:34:35.120]                         if (!is.null(pattern)) {
[13:34:35.120]                           computeRestarts <- base::computeRestarts
[13:34:35.120]                           grepl <- base::grepl
[13:34:35.120]                           restarts <- computeRestarts(cond)
[13:34:35.120]                           for (restart in restarts) {
[13:34:35.120]                             name <- restart$name
[13:34:35.120]                             if (is.null(name)) 
[13:34:35.120]                               next
[13:34:35.120]                             if (!grepl(pattern, name)) 
[13:34:35.120]                               next
[13:34:35.120]                             invokeRestart(restart)
[13:34:35.120]                             muffled <- TRUE
[13:34:35.120]                             break
[13:34:35.120]                           }
[13:34:35.120]                         }
[13:34:35.120]                       }
[13:34:35.120]                       invisible(muffled)
[13:34:35.120]                     }
[13:34:35.120]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.120]                   }
[13:34:35.120]                 }
[13:34:35.120]             }
[13:34:35.120]         }))
[13:34:35.120]     }, error = function(ex) {
[13:34:35.120]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.120]                 ...future.rng), started = ...future.startTime, 
[13:34:35.120]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.120]             version = "1.8"), class = "FutureResult")
[13:34:35.120]     }, finally = {
[13:34:35.120]         if (!identical(...future.workdir, getwd())) 
[13:34:35.120]             setwd(...future.workdir)
[13:34:35.120]         {
[13:34:35.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.120]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.120]             }
[13:34:35.120]             base::options(...future.oldOptions)
[13:34:35.120]             if (.Platform$OS.type == "windows") {
[13:34:35.120]                 old_names <- names(...future.oldEnvVars)
[13:34:35.120]                 envs <- base::Sys.getenv()
[13:34:35.120]                 names <- names(envs)
[13:34:35.120]                 common <- intersect(names, old_names)
[13:34:35.120]                 added <- setdiff(names, old_names)
[13:34:35.120]                 removed <- setdiff(old_names, names)
[13:34:35.120]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.120]                   envs[common]]
[13:34:35.120]                 NAMES <- toupper(changed)
[13:34:35.120]                 args <- list()
[13:34:35.120]                 for (kk in seq_along(NAMES)) {
[13:34:35.120]                   name <- changed[[kk]]
[13:34:35.120]                   NAME <- NAMES[[kk]]
[13:34:35.120]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.120]                     next
[13:34:35.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.120]                 }
[13:34:35.120]                 NAMES <- toupper(added)
[13:34:35.120]                 for (kk in seq_along(NAMES)) {
[13:34:35.120]                   name <- added[[kk]]
[13:34:35.120]                   NAME <- NAMES[[kk]]
[13:34:35.120]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.120]                     next
[13:34:35.120]                   args[[name]] <- ""
[13:34:35.120]                 }
[13:34:35.120]                 NAMES <- toupper(removed)
[13:34:35.120]                 for (kk in seq_along(NAMES)) {
[13:34:35.120]                   name <- removed[[kk]]
[13:34:35.120]                   NAME <- NAMES[[kk]]
[13:34:35.120]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.120]                     next
[13:34:35.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.120]                 }
[13:34:35.120]                 if (length(args) > 0) 
[13:34:35.120]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.120]             }
[13:34:35.120]             else {
[13:34:35.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.120]             }
[13:34:35.120]             {
[13:34:35.120]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.120]                   0L) {
[13:34:35.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.120]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.120]                   base::options(opts)
[13:34:35.120]                 }
[13:34:35.120]                 {
[13:34:35.120]                   {
[13:34:35.120]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.120]                     NULL
[13:34:35.120]                   }
[13:34:35.120]                   options(future.plan = NULL)
[13:34:35.120]                   if (is.na(NA_character_)) 
[13:34:35.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.120]                     .init = FALSE)
[13:34:35.120]                 }
[13:34:35.120]             }
[13:34:35.120]         }
[13:34:35.120]     })
[13:34:35.120]     if (TRUE) {
[13:34:35.120]         base::sink(type = "output", split = FALSE)
[13:34:35.120]         if (TRUE) {
[13:34:35.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.120]         }
[13:34:35.120]         else {
[13:34:35.120]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.120]         }
[13:34:35.120]         base::close(...future.stdout)
[13:34:35.120]         ...future.stdout <- NULL
[13:34:35.120]     }
[13:34:35.120]     ...future.result$conditions <- ...future.conditions
[13:34:35.120]     ...future.result$finished <- base::Sys.time()
[13:34:35.120]     ...future.result
[13:34:35.120] }
[13:34:35.123] assign_globals() ...
[13:34:35.123] List of 5
[13:34:35.123]  $ ...future.FUN            :function (x, ...)  
[13:34:35.123]  $ MoreArgs                 :List of 1
[13:34:35.123]   ..$ x: num 42
[13:34:35.123]  $ ...future.elements_ii    :List of 1
[13:34:35.123]   ..$ times:List of 2
[13:34:35.123]   .. ..$ : int 1
[13:34:35.123]   .. ..$ : int 2
[13:34:35.123]  $ ...future.seeds_ii       : NULL
[13:34:35.123]  $ ...future.globals.maxSize: NULL
[13:34:35.123]  - attr(*, "where")=List of 5
[13:34:35.123]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.123]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.123]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.123]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.123]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.123]  - attr(*, "resolved")= logi FALSE
[13:34:35.123]  - attr(*, "total_size")= num 224
[13:34:35.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.123]  - attr(*, "already-done")= logi TRUE
[13:34:35.128] - copied ‘...future.FUN’ to environment
[13:34:35.128] - copied ‘MoreArgs’ to environment
[13:34:35.128] - copied ‘...future.elements_ii’ to environment
[13:34:35.128] - copied ‘...future.seeds_ii’ to environment
[13:34:35.128] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.128] assign_globals() ... done
[13:34:35.128] requestCore(): workers = 2
[13:34:35.130] MulticoreFuture started
[13:34:35.131] - Launch lazy future ... done
[13:34:35.131] run() for ‘MulticoreFuture’ ... done
[13:34:35.131] Created future:
[13:34:35.131] plan(): Setting new future strategy stack:
[13:34:35.132] List of future strategies:
[13:34:35.132] 1. sequential:
[13:34:35.132]    - args: function (..., envir = parent.frame())
[13:34:35.132]    - tweaked: FALSE
[13:34:35.132]    - call: NULL
[13:34:35.132] plan(): nbrOfWorkers() = 1
[13:34:35.134] plan(): Setting new future strategy stack:
[13:34:35.135] List of future strategies:
[13:34:35.135] 1. multicore:
[13:34:35.135]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.135]    - tweaked: FALSE
[13:34:35.135]    - call: plan(strategy)
[13:34:35.140] plan(): nbrOfWorkers() = 2
[13:34:35.131] MulticoreFuture:
[13:34:35.131] Label: ‘future_mapply-1’
[13:34:35.131] Expression:
[13:34:35.131] {
[13:34:35.131]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.131]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.131]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.131]         on.exit(options(oopts), add = TRUE)
[13:34:35.131]     }
[13:34:35.131]     {
[13:34:35.131]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.131]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.131]         do.call(mapply, args = args)
[13:34:35.131]     }
[13:34:35.131] }
[13:34:35.131] Lazy evaluation: FALSE
[13:34:35.131] Asynchronous evaluation: TRUE
[13:34:35.131] Local evaluation: TRUE
[13:34:35.131] Environment: R_GlobalEnv
[13:34:35.131] Capture standard output: TRUE
[13:34:35.131] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.131] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.131] Packages: <none>
[13:34:35.131] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.131] Resolved: TRUE
[13:34:35.131] Value: <not collected>
[13:34:35.131] Conditions captured: <none>
[13:34:35.131] Early signaling: FALSE
[13:34:35.131] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.131] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.141] Chunk #1 of 2 ... DONE
[13:34:35.141] Chunk #2 of 2 ...
[13:34:35.141]  - Finding globals in '...' for chunk #2 ...
[13:34:35.142] getGlobalsAndPackages() ...
[13:34:35.142] Searching for globals...
[13:34:35.142] 
[13:34:35.143] Searching for globals ... DONE
[13:34:35.143] - globals: [0] <none>
[13:34:35.143] getGlobalsAndPackages() ... DONE
[13:34:35.143]    + additional globals found: [n=0] 
[13:34:35.143]    + additional namespaces needed: [n=0] 
[13:34:35.143]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:35.143]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:35.146]  - seeds: <none>
[13:34:35.146]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.147] getGlobalsAndPackages() ...
[13:34:35.147] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.148] Resolving globals: FALSE
[13:34:35.150] The total size of the 5 globals is 224 bytes (224 bytes)
[13:34:35.151] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[13:34:35.151] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.151] 
[13:34:35.152] getGlobalsAndPackages() ... DONE
[13:34:35.152] run() for ‘Future’ ...
[13:34:35.153] - state: ‘created’
[13:34:35.153] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.158] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.158] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.159]   - Field: ‘label’
[13:34:35.159]   - Field: ‘local’
[13:34:35.159]   - Field: ‘owner’
[13:34:35.159]   - Field: ‘envir’
[13:34:35.159]   - Field: ‘workers’
[13:34:35.159]   - Field: ‘packages’
[13:34:35.160]   - Field: ‘gc’
[13:34:35.160]   - Field: ‘job’
[13:34:35.160]   - Field: ‘conditions’
[13:34:35.160]   - Field: ‘expr’
[13:34:35.160]   - Field: ‘uuid’
[13:34:35.160]   - Field: ‘seed’
[13:34:35.160]   - Field: ‘version’
[13:34:35.161]   - Field: ‘result’
[13:34:35.161]   - Field: ‘asynchronous’
[13:34:35.161]   - Field: ‘calls’
[13:34:35.161]   - Field: ‘globals’
[13:34:35.161]   - Field: ‘stdout’
[13:34:35.162]   - Field: ‘earlySignal’
[13:34:35.162]   - Field: ‘lazy’
[13:34:35.162]   - Field: ‘state’
[13:34:35.162] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.162] - Launch lazy future ...
[13:34:35.163] Packages needed by the future expression (n = 0): <none>
[13:34:35.163] Packages needed by future strategies (n = 0): <none>
[13:34:35.164] {
[13:34:35.164]     {
[13:34:35.164]         {
[13:34:35.164]             ...future.startTime <- base::Sys.time()
[13:34:35.164]             {
[13:34:35.164]                 {
[13:34:35.164]                   {
[13:34:35.164]                     {
[13:34:35.164]                       base::local({
[13:34:35.164]                         has_future <- base::requireNamespace("future", 
[13:34:35.164]                           quietly = TRUE)
[13:34:35.164]                         if (has_future) {
[13:34:35.164]                           ns <- base::getNamespace("future")
[13:34:35.164]                           version <- ns[[".package"]][["version"]]
[13:34:35.164]                           if (is.null(version)) 
[13:34:35.164]                             version <- utils::packageVersion("future")
[13:34:35.164]                         }
[13:34:35.164]                         else {
[13:34:35.164]                           version <- NULL
[13:34:35.164]                         }
[13:34:35.164]                         if (!has_future || version < "1.8.0") {
[13:34:35.164]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.164]                             "", base::R.version$version.string), 
[13:34:35.164]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.164]                               "release", "version")], collapse = " "), 
[13:34:35.164]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.164]                             info)
[13:34:35.164]                           info <- base::paste(info, collapse = "; ")
[13:34:35.164]                           if (!has_future) {
[13:34:35.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.164]                               info)
[13:34:35.164]                           }
[13:34:35.164]                           else {
[13:34:35.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.164]                               info, version)
[13:34:35.164]                           }
[13:34:35.164]                           base::stop(msg)
[13:34:35.164]                         }
[13:34:35.164]                       })
[13:34:35.164]                     }
[13:34:35.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.164]                     base::options(mc.cores = 1L)
[13:34:35.164]                   }
[13:34:35.164]                   ...future.strategy.old <- future::plan("list")
[13:34:35.164]                   options(future.plan = NULL)
[13:34:35.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.164]                 }
[13:34:35.164]                 ...future.workdir <- getwd()
[13:34:35.164]             }
[13:34:35.164]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.164]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.164]         }
[13:34:35.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.164]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:35.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.164]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.164]             base::names(...future.oldOptions))
[13:34:35.164]     }
[13:34:35.164]     if (FALSE) {
[13:34:35.164]     }
[13:34:35.164]     else {
[13:34:35.164]         if (TRUE) {
[13:34:35.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.164]                 open = "w")
[13:34:35.164]         }
[13:34:35.164]         else {
[13:34:35.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.164]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.164]         }
[13:34:35.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.164]             base::sink(type = "output", split = FALSE)
[13:34:35.164]             base::close(...future.stdout)
[13:34:35.164]         }, add = TRUE)
[13:34:35.164]     }
[13:34:35.164]     ...future.frame <- base::sys.nframe()
[13:34:35.164]     ...future.conditions <- base::list()
[13:34:35.164]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.164]     if (FALSE) {
[13:34:35.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.164]     }
[13:34:35.164]     ...future.result <- base::tryCatch({
[13:34:35.164]         base::withCallingHandlers({
[13:34:35.164]             ...future.value <- base::withVisible(base::local({
[13:34:35.164]                 withCallingHandlers({
[13:34:35.164]                   {
[13:34:35.164]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.164]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.164]                       ...future.globals.maxSize)) {
[13:34:35.164]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.164]                       on.exit(options(oopts), add = TRUE)
[13:34:35.164]                     }
[13:34:35.164]                     {
[13:34:35.164]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.164]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.164]                         USE.NAMES = FALSE)
[13:34:35.164]                       do.call(mapply, args = args)
[13:34:35.164]                     }
[13:34:35.164]                   }
[13:34:35.164]                 }, immediateCondition = function(cond) {
[13:34:35.164]                   save_rds <- function (object, pathname, ...) 
[13:34:35.164]                   {
[13:34:35.164]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.164]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.164]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.164]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.164]                         fi_tmp[["mtime"]])
[13:34:35.164]                     }
[13:34:35.164]                     tryCatch({
[13:34:35.164]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.164]                     }, error = function(ex) {
[13:34:35.164]                       msg <- conditionMessage(ex)
[13:34:35.164]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.164]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.164]                         fi_tmp[["mtime"]], msg)
[13:34:35.164]                       ex$message <- msg
[13:34:35.164]                       stop(ex)
[13:34:35.164]                     })
[13:34:35.164]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.164]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.164]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.164]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.164]                       fi <- file.info(pathname)
[13:34:35.164]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.164]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.164]                         fi[["size"]], fi[["mtime"]])
[13:34:35.164]                       stop(msg)
[13:34:35.164]                     }
[13:34:35.164]                     invisible(pathname)
[13:34:35.164]                   }
[13:34:35.164]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.164]                     rootPath = tempdir()) 
[13:34:35.164]                   {
[13:34:35.164]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.164]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.164]                       tmpdir = path, fileext = ".rds")
[13:34:35.164]                     save_rds(obj, file)
[13:34:35.164]                   }
[13:34:35.164]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.164]                   {
[13:34:35.164]                     inherits <- base::inherits
[13:34:35.164]                     invokeRestart <- base::invokeRestart
[13:34:35.164]                     is.null <- base::is.null
[13:34:35.164]                     muffled <- FALSE
[13:34:35.164]                     if (inherits(cond, "message")) {
[13:34:35.164]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.164]                       if (muffled) 
[13:34:35.164]                         invokeRestart("muffleMessage")
[13:34:35.164]                     }
[13:34:35.164]                     else if (inherits(cond, "warning")) {
[13:34:35.164]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.164]                       if (muffled) 
[13:34:35.164]                         invokeRestart("muffleWarning")
[13:34:35.164]                     }
[13:34:35.164]                     else if (inherits(cond, "condition")) {
[13:34:35.164]                       if (!is.null(pattern)) {
[13:34:35.164]                         computeRestarts <- base::computeRestarts
[13:34:35.164]                         grepl <- base::grepl
[13:34:35.164]                         restarts <- computeRestarts(cond)
[13:34:35.164]                         for (restart in restarts) {
[13:34:35.164]                           name <- restart$name
[13:34:35.164]                           if (is.null(name)) 
[13:34:35.164]                             next
[13:34:35.164]                           if (!grepl(pattern, name)) 
[13:34:35.164]                             next
[13:34:35.164]                           invokeRestart(restart)
[13:34:35.164]                           muffled <- TRUE
[13:34:35.164]                           break
[13:34:35.164]                         }
[13:34:35.164]                       }
[13:34:35.164]                     }
[13:34:35.164]                     invisible(muffled)
[13:34:35.164]                   }
[13:34:35.164]                   muffleCondition(cond)
[13:34:35.164]                 })
[13:34:35.164]             }))
[13:34:35.164]             future::FutureResult(value = ...future.value$value, 
[13:34:35.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.164]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.164]                     ...future.globalenv.names))
[13:34:35.164]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.164]         }, condition = base::local({
[13:34:35.164]             c <- base::c
[13:34:35.164]             inherits <- base::inherits
[13:34:35.164]             invokeRestart <- base::invokeRestart
[13:34:35.164]             length <- base::length
[13:34:35.164]             list <- base::list
[13:34:35.164]             seq.int <- base::seq.int
[13:34:35.164]             signalCondition <- base::signalCondition
[13:34:35.164]             sys.calls <- base::sys.calls
[13:34:35.164]             `[[` <- base::`[[`
[13:34:35.164]             `+` <- base::`+`
[13:34:35.164]             `<<-` <- base::`<<-`
[13:34:35.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.164]                   3L)]
[13:34:35.164]             }
[13:34:35.164]             function(cond) {
[13:34:35.164]                 is_error <- inherits(cond, "error")
[13:34:35.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.164]                   NULL)
[13:34:35.164]                 if (is_error) {
[13:34:35.164]                   sessionInformation <- function() {
[13:34:35.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.164]                       search = base::search(), system = base::Sys.info())
[13:34:35.164]                   }
[13:34:35.164]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.164]                     cond$call), session = sessionInformation(), 
[13:34:35.164]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.164]                   signalCondition(cond)
[13:34:35.164]                 }
[13:34:35.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.164]                 "immediateCondition"))) {
[13:34:35.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.164]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.164]                   if (TRUE && !signal) {
[13:34:35.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.164]                     {
[13:34:35.164]                       inherits <- base::inherits
[13:34:35.164]                       invokeRestart <- base::invokeRestart
[13:34:35.164]                       is.null <- base::is.null
[13:34:35.164]                       muffled <- FALSE
[13:34:35.164]                       if (inherits(cond, "message")) {
[13:34:35.164]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.164]                         if (muffled) 
[13:34:35.164]                           invokeRestart("muffleMessage")
[13:34:35.164]                       }
[13:34:35.164]                       else if (inherits(cond, "warning")) {
[13:34:35.164]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.164]                         if (muffled) 
[13:34:35.164]                           invokeRestart("muffleWarning")
[13:34:35.164]                       }
[13:34:35.164]                       else if (inherits(cond, "condition")) {
[13:34:35.164]                         if (!is.null(pattern)) {
[13:34:35.164]                           computeRestarts <- base::computeRestarts
[13:34:35.164]                           grepl <- base::grepl
[13:34:35.164]                           restarts <- computeRestarts(cond)
[13:34:35.164]                           for (restart in restarts) {
[13:34:35.164]                             name <- restart$name
[13:34:35.164]                             if (is.null(name)) 
[13:34:35.164]                               next
[13:34:35.164]                             if (!grepl(pattern, name)) 
[13:34:35.164]                               next
[13:34:35.164]                             invokeRestart(restart)
[13:34:35.164]                             muffled <- TRUE
[13:34:35.164]                             break
[13:34:35.164]                           }
[13:34:35.164]                         }
[13:34:35.164]                       }
[13:34:35.164]                       invisible(muffled)
[13:34:35.164]                     }
[13:34:35.164]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.164]                   }
[13:34:35.164]                 }
[13:34:35.164]                 else {
[13:34:35.164]                   if (TRUE) {
[13:34:35.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.164]                     {
[13:34:35.164]                       inherits <- base::inherits
[13:34:35.164]                       invokeRestart <- base::invokeRestart
[13:34:35.164]                       is.null <- base::is.null
[13:34:35.164]                       muffled <- FALSE
[13:34:35.164]                       if (inherits(cond, "message")) {
[13:34:35.164]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.164]                         if (muffled) 
[13:34:35.164]                           invokeRestart("muffleMessage")
[13:34:35.164]                       }
[13:34:35.164]                       else if (inherits(cond, "warning")) {
[13:34:35.164]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.164]                         if (muffled) 
[13:34:35.164]                           invokeRestart("muffleWarning")
[13:34:35.164]                       }
[13:34:35.164]                       else if (inherits(cond, "condition")) {
[13:34:35.164]                         if (!is.null(pattern)) {
[13:34:35.164]                           computeRestarts <- base::computeRestarts
[13:34:35.164]                           grepl <- base::grepl
[13:34:35.164]                           restarts <- computeRestarts(cond)
[13:34:35.164]                           for (restart in restarts) {
[13:34:35.164]                             name <- restart$name
[13:34:35.164]                             if (is.null(name)) 
[13:34:35.164]                               next
[13:34:35.164]                             if (!grepl(pattern, name)) 
[13:34:35.164]                               next
[13:34:35.164]                             invokeRestart(restart)
[13:34:35.164]                             muffled <- TRUE
[13:34:35.164]                             break
[13:34:35.164]                           }
[13:34:35.164]                         }
[13:34:35.164]                       }
[13:34:35.164]                       invisible(muffled)
[13:34:35.164]                     }
[13:34:35.164]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.164]                   }
[13:34:35.164]                 }
[13:34:35.164]             }
[13:34:35.164]         }))
[13:34:35.164]     }, error = function(ex) {
[13:34:35.164]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.164]                 ...future.rng), started = ...future.startTime, 
[13:34:35.164]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.164]             version = "1.8"), class = "FutureResult")
[13:34:35.164]     }, finally = {
[13:34:35.164]         if (!identical(...future.workdir, getwd())) 
[13:34:35.164]             setwd(...future.workdir)
[13:34:35.164]         {
[13:34:35.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.164]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.164]             }
[13:34:35.164]             base::options(...future.oldOptions)
[13:34:35.164]             if (.Platform$OS.type == "windows") {
[13:34:35.164]                 old_names <- names(...future.oldEnvVars)
[13:34:35.164]                 envs <- base::Sys.getenv()
[13:34:35.164]                 names <- names(envs)
[13:34:35.164]                 common <- intersect(names, old_names)
[13:34:35.164]                 added <- setdiff(names, old_names)
[13:34:35.164]                 removed <- setdiff(old_names, names)
[13:34:35.164]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.164]                   envs[common]]
[13:34:35.164]                 NAMES <- toupper(changed)
[13:34:35.164]                 args <- list()
[13:34:35.164]                 for (kk in seq_along(NAMES)) {
[13:34:35.164]                   name <- changed[[kk]]
[13:34:35.164]                   NAME <- NAMES[[kk]]
[13:34:35.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.164]                     next
[13:34:35.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.164]                 }
[13:34:35.164]                 NAMES <- toupper(added)
[13:34:35.164]                 for (kk in seq_along(NAMES)) {
[13:34:35.164]                   name <- added[[kk]]
[13:34:35.164]                   NAME <- NAMES[[kk]]
[13:34:35.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.164]                     next
[13:34:35.164]                   args[[name]] <- ""
[13:34:35.164]                 }
[13:34:35.164]                 NAMES <- toupper(removed)
[13:34:35.164]                 for (kk in seq_along(NAMES)) {
[13:34:35.164]                   name <- removed[[kk]]
[13:34:35.164]                   NAME <- NAMES[[kk]]
[13:34:35.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.164]                     next
[13:34:35.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.164]                 }
[13:34:35.164]                 if (length(args) > 0) 
[13:34:35.164]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.164]             }
[13:34:35.164]             else {
[13:34:35.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.164]             }
[13:34:35.164]             {
[13:34:35.164]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.164]                   0L) {
[13:34:35.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.164]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.164]                   base::options(opts)
[13:34:35.164]                 }
[13:34:35.164]                 {
[13:34:35.164]                   {
[13:34:35.164]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.164]                     NULL
[13:34:35.164]                   }
[13:34:35.164]                   options(future.plan = NULL)
[13:34:35.164]                   if (is.na(NA_character_)) 
[13:34:35.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.164]                     .init = FALSE)
[13:34:35.164]                 }
[13:34:35.164]             }
[13:34:35.164]         }
[13:34:35.164]     })
[13:34:35.164]     if (TRUE) {
[13:34:35.164]         base::sink(type = "output", split = FALSE)
[13:34:35.164]         if (TRUE) {
[13:34:35.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.164]         }
[13:34:35.164]         else {
[13:34:35.164]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.164]         }
[13:34:35.164]         base::close(...future.stdout)
[13:34:35.164]         ...future.stdout <- NULL
[13:34:35.164]     }
[13:34:35.164]     ...future.result$conditions <- ...future.conditions
[13:34:35.164]     ...future.result$finished <- base::Sys.time()
[13:34:35.164]     ...future.result
[13:34:35.164] }
[13:34:35.166] assign_globals() ...
[13:34:35.166] List of 5
[13:34:35.166]  $ ...future.FUN            :function (x, ...)  
[13:34:35.166]  $ MoreArgs                 :List of 1
[13:34:35.166]   ..$ x: num 42
[13:34:35.166]  $ ...future.elements_ii    :List of 1
[13:34:35.166]   ..$ times:List of 2
[13:34:35.166]   .. ..$ : int 3
[13:34:35.166]   .. ..$ : int 4
[13:34:35.166]  $ ...future.seeds_ii       : NULL
[13:34:35.166]  $ ...future.globals.maxSize: NULL
[13:34:35.166]  - attr(*, "where")=List of 5
[13:34:35.166]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.166]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.166]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.166]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.166]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.166]  - attr(*, "resolved")= logi FALSE
[13:34:35.166]  - attr(*, "total_size")= num 224
[13:34:35.166]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.166]  - attr(*, "already-done")= logi TRUE
[13:34:35.173] - copied ‘...future.FUN’ to environment
[13:34:35.173] - copied ‘MoreArgs’ to environment
[13:34:35.174] - copied ‘...future.elements_ii’ to environment
[13:34:35.174] - copied ‘...future.seeds_ii’ to environment
[13:34:35.174] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.174] assign_globals() ... done
[13:34:35.174] requestCore(): workers = 2
[13:34:35.176] MulticoreFuture started
[13:34:35.177] - Launch lazy future ... done
[13:34:35.177] run() for ‘MulticoreFuture’ ... done
[13:34:35.177] Created future:
[13:34:35.177] plan(): Setting new future strategy stack:
[13:34:35.178] List of future strategies:
[13:34:35.178] 1. sequential:
[13:34:35.178]    - args: function (..., envir = parent.frame())
[13:34:35.178]    - tweaked: FALSE
[13:34:35.178]    - call: NULL
[13:34:35.178] plan(): nbrOfWorkers() = 1
[13:34:35.181] plan(): Setting new future strategy stack:
[13:34:35.181] List of future strategies:
[13:34:35.181] 1. multicore:
[13:34:35.181]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.181]    - tweaked: FALSE
[13:34:35.181]    - call: plan(strategy)
[13:34:35.186] plan(): nbrOfWorkers() = 2
[13:34:35.177] MulticoreFuture:
[13:34:35.177] Label: ‘future_mapply-2’
[13:34:35.177] Expression:
[13:34:35.177] {
[13:34:35.177]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.177]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.177]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.177]         on.exit(options(oopts), add = TRUE)
[13:34:35.177]     }
[13:34:35.177]     {
[13:34:35.177]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.177]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.177]         do.call(mapply, args = args)
[13:34:35.177]     }
[13:34:35.177] }
[13:34:35.177] Lazy evaluation: FALSE
[13:34:35.177] Asynchronous evaluation: TRUE
[13:34:35.177] Local evaluation: TRUE
[13:34:35.177] Environment: R_GlobalEnv
[13:34:35.177] Capture standard output: TRUE
[13:34:35.177] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.177] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.177] Packages: <none>
[13:34:35.177] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.177] Resolved: TRUE
[13:34:35.177] Value: <not collected>
[13:34:35.177] Conditions captured: <none>
[13:34:35.177] Early signaling: FALSE
[13:34:35.177] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.177] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.187] Chunk #2 of 2 ... DONE
[13:34:35.187] Launching 2 futures (chunks) ... DONE
[13:34:35.187] Resolving 2 futures (chunks) ...
[13:34:35.187] resolve() on list ...
[13:34:35.188]  recursive: 0
[13:34:35.188]  length: 2
[13:34:35.188] 
[13:34:35.188] Future #1
[13:34:35.188] result() for MulticoreFuture ...
[13:34:35.189] result() for MulticoreFuture ...
[13:34:35.190] result() for MulticoreFuture ... done
[13:34:35.190] result() for MulticoreFuture ... done
[13:34:35.190] result() for MulticoreFuture ...
[13:34:35.190] result() for MulticoreFuture ... done
[13:34:35.190] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:35.190] - nx: 2
[13:34:35.190] - relay: TRUE
[13:34:35.191] - stdout: TRUE
[13:34:35.191] - signal: TRUE
[13:34:35.191] - resignal: FALSE
[13:34:35.191] - force: TRUE
[13:34:35.191] - relayed: [n=2] FALSE, FALSE
[13:34:35.191] - queued futures: [n=2] FALSE, FALSE
[13:34:35.191]  - until=1
[13:34:35.192]  - relaying element #1
[13:34:35.192] result() for MulticoreFuture ...
[13:34:35.192] result() for MulticoreFuture ... done
[13:34:35.192] result() for MulticoreFuture ...
[13:34:35.192] result() for MulticoreFuture ... done
[13:34:35.192] result() for MulticoreFuture ...
[13:34:35.192] result() for MulticoreFuture ... done
[13:34:35.193] result() for MulticoreFuture ...
[13:34:35.193] result() for MulticoreFuture ... done
[13:34:35.193] - relayed: [n=2] TRUE, FALSE
[13:34:35.193] - queued futures: [n=2] TRUE, FALSE
[13:34:35.193] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:35.193]  length: 1 (resolved future 1)
[13:34:35.194] Future #2
[13:34:35.198] result() for MulticoreFuture ...
[13:34:35.199] result() for MulticoreFuture ...
[13:34:35.199] result() for MulticoreFuture ... done
[13:34:35.200] result() for MulticoreFuture ... done
[13:34:35.200] result() for MulticoreFuture ...
[13:34:35.200] result() for MulticoreFuture ... done
[13:34:35.201] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:35.201] - nx: 2
[13:34:35.201] - relay: TRUE
[13:34:35.201] - stdout: TRUE
[13:34:35.201] - signal: TRUE
[13:34:35.201] - resignal: FALSE
[13:34:35.202] - force: TRUE
[13:34:35.202] - relayed: [n=2] TRUE, FALSE
[13:34:35.202] - queued futures: [n=2] TRUE, FALSE
[13:34:35.202]  - until=2
[13:34:35.202]  - relaying element #2
[13:34:35.202] result() for MulticoreFuture ...
[13:34:35.202] result() for MulticoreFuture ... done
[13:34:35.203] result() for MulticoreFuture ...
[13:34:35.203] result() for MulticoreFuture ... done
[13:34:35.203] result() for MulticoreFuture ...
[13:34:35.203] result() for MulticoreFuture ... done
[13:34:35.203] result() for MulticoreFuture ...
[13:34:35.203] result() for MulticoreFuture ... done
[13:34:35.204] - relayed: [n=2] TRUE, TRUE
[13:34:35.204] - queued futures: [n=2] TRUE, TRUE
[13:34:35.204] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:35.204]  length: 0 (resolved future 2)
[13:34:35.204] Relaying remaining futures
[13:34:35.204] signalConditionsASAP(NULL, pos=0) ...
[13:34:35.204] - nx: 2
[13:34:35.204] - relay: TRUE
[13:34:35.204] - stdout: TRUE
[13:34:35.205] - signal: TRUE
[13:34:35.205] - resignal: FALSE
[13:34:35.205] - force: TRUE
[13:34:35.205] - relayed: [n=2] TRUE, TRUE
[13:34:35.205] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:35.205] - relayed: [n=2] TRUE, TRUE
[13:34:35.205] - queued futures: [n=2] TRUE, TRUE
[13:34:35.205] signalConditionsASAP(NULL, pos=0) ... done
[13:34:35.205] resolve() on list ... DONE
[13:34:35.206] result() for MulticoreFuture ...
[13:34:35.206] result() for MulticoreFuture ... done
[13:34:35.206] result() for MulticoreFuture ...
[13:34:35.206] result() for MulticoreFuture ... done
[13:34:35.206] result() for MulticoreFuture ...
[13:34:35.206] result() for MulticoreFuture ... done
[13:34:35.206] result() for MulticoreFuture ...
[13:34:35.207] result() for MulticoreFuture ... done
[13:34:35.207]  - Number of value chunks collected: 2
[13:34:35.207] Resolving 2 futures (chunks) ... DONE
[13:34:35.207] Reducing values from 2 chunks ...
[13:34:35.207]  - Number of values collected after concatenation: 4
[13:34:35.207]  - Number of values expected: 4
[13:34:35.207] Reducing values from 2 chunks ... DONE
[13:34:35.207] future_mapply() ... DONE
[13:34:35.208] future_mapply() ...
[13:34:35.211] Number of chunks: 2
[13:34:35.212] getGlobalsAndPackagesXApply() ...
[13:34:35.212]  - future.globals: TRUE
[13:34:35.212] getGlobalsAndPackages() ...
[13:34:35.212] Searching for globals...
[13:34:35.213] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[13:34:35.214] Searching for globals ... DONE
[13:34:35.214] Resolving globals: FALSE
[13:34:35.214] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[13:34:35.214] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[13:34:35.215] - globals: [1] ‘FUN’
[13:34:35.215] 
[13:34:35.215] getGlobalsAndPackages() ... DONE
[13:34:35.215]  - globals found/used: [n=1] ‘FUN’
[13:34:35.215]  - needed namespaces: [n=0] 
[13:34:35.215] Finding globals ... DONE
[13:34:35.215] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:35.216] List of 2
[13:34:35.216]  $ ...future.FUN:function (x, y)  
[13:34:35.216]  $ MoreArgs     : NULL
[13:34:35.216]  - attr(*, "where")=List of 2
[13:34:35.216]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:35.216]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:35.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.216]  - attr(*, "resolved")= logi FALSE
[13:34:35.216]  - attr(*, "total_size")= num NA
[13:34:35.218] Packages to be attached in all futures: [n=0] 
[13:34:35.218] getGlobalsAndPackagesXApply() ... DONE
[13:34:35.219] Number of futures (= number of chunks): 2
[13:34:35.219] Launching 2 futures (chunks) ...
[13:34:35.219] Chunk #1 of 2 ...
[13:34:35.219]  - Finding globals in '...' for chunk #1 ...
[13:34:35.219] getGlobalsAndPackages() ...
[13:34:35.219] Searching for globals...
[13:34:35.219] 
[13:34:35.220] Searching for globals ... DONE
[13:34:35.220] - globals: [0] <none>
[13:34:35.220] getGlobalsAndPackages() ... DONE
[13:34:35.220]    + additional globals found: [n=0] 
[13:34:35.220]    + additional namespaces needed: [n=0] 
[13:34:35.220]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:35.220]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:35.220]  - seeds: <none>
[13:34:35.220]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.220] getGlobalsAndPackages() ...
[13:34:35.220] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.221] Resolving globals: FALSE
[13:34:35.221] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[13:34:35.221] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:35.222] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.222] 
[13:34:35.222] getGlobalsAndPackages() ... DONE
[13:34:35.222] run() for ‘Future’ ...
[13:34:35.222] - state: ‘created’
[13:34:35.222] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.226] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.226]   - Field: ‘label’
[13:34:35.228]   - Field: ‘local’
[13:34:35.228]   - Field: ‘owner’
[13:34:35.229]   - Field: ‘envir’
[13:34:35.229]   - Field: ‘workers’
[13:34:35.229]   - Field: ‘packages’
[13:34:35.229]   - Field: ‘gc’
[13:34:35.229]   - Field: ‘job’
[13:34:35.229]   - Field: ‘conditions’
[13:34:35.229]   - Field: ‘expr’
[13:34:35.229]   - Field: ‘uuid’
[13:34:35.229]   - Field: ‘seed’
[13:34:35.229]   - Field: ‘version’
[13:34:35.230]   - Field: ‘result’
[13:34:35.230]   - Field: ‘asynchronous’
[13:34:35.230]   - Field: ‘calls’
[13:34:35.230]   - Field: ‘globals’
[13:34:35.230]   - Field: ‘stdout’
[13:34:35.230]   - Field: ‘earlySignal’
[13:34:35.230]   - Field: ‘lazy’
[13:34:35.230]   - Field: ‘state’
[13:34:35.230] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.231] - Launch lazy future ...
[13:34:35.231] Packages needed by the future expression (n = 0): <none>
[13:34:35.231] Packages needed by future strategies (n = 0): <none>
[13:34:35.231] {
[13:34:35.231]     {
[13:34:35.231]         {
[13:34:35.231]             ...future.startTime <- base::Sys.time()
[13:34:35.231]             {
[13:34:35.231]                 {
[13:34:35.231]                   {
[13:34:35.231]                     {
[13:34:35.231]                       base::local({
[13:34:35.231]                         has_future <- base::requireNamespace("future", 
[13:34:35.231]                           quietly = TRUE)
[13:34:35.231]                         if (has_future) {
[13:34:35.231]                           ns <- base::getNamespace("future")
[13:34:35.231]                           version <- ns[[".package"]][["version"]]
[13:34:35.231]                           if (is.null(version)) 
[13:34:35.231]                             version <- utils::packageVersion("future")
[13:34:35.231]                         }
[13:34:35.231]                         else {
[13:34:35.231]                           version <- NULL
[13:34:35.231]                         }
[13:34:35.231]                         if (!has_future || version < "1.8.0") {
[13:34:35.231]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.231]                             "", base::R.version$version.string), 
[13:34:35.231]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.231]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.231]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.231]                               "release", "version")], collapse = " "), 
[13:34:35.231]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.231]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.231]                             info)
[13:34:35.231]                           info <- base::paste(info, collapse = "; ")
[13:34:35.231]                           if (!has_future) {
[13:34:35.231]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.231]                               info)
[13:34:35.231]                           }
[13:34:35.231]                           else {
[13:34:35.231]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.231]                               info, version)
[13:34:35.231]                           }
[13:34:35.231]                           base::stop(msg)
[13:34:35.231]                         }
[13:34:35.231]                       })
[13:34:35.231]                     }
[13:34:35.231]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.231]                     base::options(mc.cores = 1L)
[13:34:35.231]                   }
[13:34:35.231]                   ...future.strategy.old <- future::plan("list")
[13:34:35.231]                   options(future.plan = NULL)
[13:34:35.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.231]                 }
[13:34:35.231]                 ...future.workdir <- getwd()
[13:34:35.231]             }
[13:34:35.231]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.231]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.231]         }
[13:34:35.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.231]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:35.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.231]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.231]             base::names(...future.oldOptions))
[13:34:35.231]     }
[13:34:35.231]     if (FALSE) {
[13:34:35.231]     }
[13:34:35.231]     else {
[13:34:35.231]         if (TRUE) {
[13:34:35.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.231]                 open = "w")
[13:34:35.231]         }
[13:34:35.231]         else {
[13:34:35.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.231]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.231]         }
[13:34:35.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.231]             base::sink(type = "output", split = FALSE)
[13:34:35.231]             base::close(...future.stdout)
[13:34:35.231]         }, add = TRUE)
[13:34:35.231]     }
[13:34:35.231]     ...future.frame <- base::sys.nframe()
[13:34:35.231]     ...future.conditions <- base::list()
[13:34:35.231]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.231]     if (FALSE) {
[13:34:35.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.231]     }
[13:34:35.231]     ...future.result <- base::tryCatch({
[13:34:35.231]         base::withCallingHandlers({
[13:34:35.231]             ...future.value <- base::withVisible(base::local({
[13:34:35.231]                 withCallingHandlers({
[13:34:35.231]                   {
[13:34:35.231]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.231]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.231]                       ...future.globals.maxSize)) {
[13:34:35.231]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.231]                       on.exit(options(oopts), add = TRUE)
[13:34:35.231]                     }
[13:34:35.231]                     {
[13:34:35.231]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.231]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.231]                         USE.NAMES = FALSE)
[13:34:35.231]                       do.call(mapply, args = args)
[13:34:35.231]                     }
[13:34:35.231]                   }
[13:34:35.231]                 }, immediateCondition = function(cond) {
[13:34:35.231]                   save_rds <- function (object, pathname, ...) 
[13:34:35.231]                   {
[13:34:35.231]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.231]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.231]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.231]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.231]                         fi_tmp[["mtime"]])
[13:34:35.231]                     }
[13:34:35.231]                     tryCatch({
[13:34:35.231]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.231]                     }, error = function(ex) {
[13:34:35.231]                       msg <- conditionMessage(ex)
[13:34:35.231]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.231]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.231]                         fi_tmp[["mtime"]], msg)
[13:34:35.231]                       ex$message <- msg
[13:34:35.231]                       stop(ex)
[13:34:35.231]                     })
[13:34:35.231]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.231]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.231]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.231]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.231]                       fi <- file.info(pathname)
[13:34:35.231]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.231]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.231]                         fi[["size"]], fi[["mtime"]])
[13:34:35.231]                       stop(msg)
[13:34:35.231]                     }
[13:34:35.231]                     invisible(pathname)
[13:34:35.231]                   }
[13:34:35.231]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.231]                     rootPath = tempdir()) 
[13:34:35.231]                   {
[13:34:35.231]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.231]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.231]                       tmpdir = path, fileext = ".rds")
[13:34:35.231]                     save_rds(obj, file)
[13:34:35.231]                   }
[13:34:35.231]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.231]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.231]                   {
[13:34:35.231]                     inherits <- base::inherits
[13:34:35.231]                     invokeRestart <- base::invokeRestart
[13:34:35.231]                     is.null <- base::is.null
[13:34:35.231]                     muffled <- FALSE
[13:34:35.231]                     if (inherits(cond, "message")) {
[13:34:35.231]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.231]                       if (muffled) 
[13:34:35.231]                         invokeRestart("muffleMessage")
[13:34:35.231]                     }
[13:34:35.231]                     else if (inherits(cond, "warning")) {
[13:34:35.231]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.231]                       if (muffled) 
[13:34:35.231]                         invokeRestart("muffleWarning")
[13:34:35.231]                     }
[13:34:35.231]                     else if (inherits(cond, "condition")) {
[13:34:35.231]                       if (!is.null(pattern)) {
[13:34:35.231]                         computeRestarts <- base::computeRestarts
[13:34:35.231]                         grepl <- base::grepl
[13:34:35.231]                         restarts <- computeRestarts(cond)
[13:34:35.231]                         for (restart in restarts) {
[13:34:35.231]                           name <- restart$name
[13:34:35.231]                           if (is.null(name)) 
[13:34:35.231]                             next
[13:34:35.231]                           if (!grepl(pattern, name)) 
[13:34:35.231]                             next
[13:34:35.231]                           invokeRestart(restart)
[13:34:35.231]                           muffled <- TRUE
[13:34:35.231]                           break
[13:34:35.231]                         }
[13:34:35.231]                       }
[13:34:35.231]                     }
[13:34:35.231]                     invisible(muffled)
[13:34:35.231]                   }
[13:34:35.231]                   muffleCondition(cond)
[13:34:35.231]                 })
[13:34:35.231]             }))
[13:34:35.231]             future::FutureResult(value = ...future.value$value, 
[13:34:35.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.231]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.231]                     ...future.globalenv.names))
[13:34:35.231]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.231]         }, condition = base::local({
[13:34:35.231]             c <- base::c
[13:34:35.231]             inherits <- base::inherits
[13:34:35.231]             invokeRestart <- base::invokeRestart
[13:34:35.231]             length <- base::length
[13:34:35.231]             list <- base::list
[13:34:35.231]             seq.int <- base::seq.int
[13:34:35.231]             signalCondition <- base::signalCondition
[13:34:35.231]             sys.calls <- base::sys.calls
[13:34:35.231]             `[[` <- base::`[[`
[13:34:35.231]             `+` <- base::`+`
[13:34:35.231]             `<<-` <- base::`<<-`
[13:34:35.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.231]                   3L)]
[13:34:35.231]             }
[13:34:35.231]             function(cond) {
[13:34:35.231]                 is_error <- inherits(cond, "error")
[13:34:35.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.231]                   NULL)
[13:34:35.231]                 if (is_error) {
[13:34:35.231]                   sessionInformation <- function() {
[13:34:35.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.231]                       search = base::search(), system = base::Sys.info())
[13:34:35.231]                   }
[13:34:35.231]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.231]                     cond$call), session = sessionInformation(), 
[13:34:35.231]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.231]                   signalCondition(cond)
[13:34:35.231]                 }
[13:34:35.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.231]                 "immediateCondition"))) {
[13:34:35.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.231]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.231]                   if (TRUE && !signal) {
[13:34:35.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.231]                     {
[13:34:35.231]                       inherits <- base::inherits
[13:34:35.231]                       invokeRestart <- base::invokeRestart
[13:34:35.231]                       is.null <- base::is.null
[13:34:35.231]                       muffled <- FALSE
[13:34:35.231]                       if (inherits(cond, "message")) {
[13:34:35.231]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.231]                         if (muffled) 
[13:34:35.231]                           invokeRestart("muffleMessage")
[13:34:35.231]                       }
[13:34:35.231]                       else if (inherits(cond, "warning")) {
[13:34:35.231]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.231]                         if (muffled) 
[13:34:35.231]                           invokeRestart("muffleWarning")
[13:34:35.231]                       }
[13:34:35.231]                       else if (inherits(cond, "condition")) {
[13:34:35.231]                         if (!is.null(pattern)) {
[13:34:35.231]                           computeRestarts <- base::computeRestarts
[13:34:35.231]                           grepl <- base::grepl
[13:34:35.231]                           restarts <- computeRestarts(cond)
[13:34:35.231]                           for (restart in restarts) {
[13:34:35.231]                             name <- restart$name
[13:34:35.231]                             if (is.null(name)) 
[13:34:35.231]                               next
[13:34:35.231]                             if (!grepl(pattern, name)) 
[13:34:35.231]                               next
[13:34:35.231]                             invokeRestart(restart)
[13:34:35.231]                             muffled <- TRUE
[13:34:35.231]                             break
[13:34:35.231]                           }
[13:34:35.231]                         }
[13:34:35.231]                       }
[13:34:35.231]                       invisible(muffled)
[13:34:35.231]                     }
[13:34:35.231]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.231]                   }
[13:34:35.231]                 }
[13:34:35.231]                 else {
[13:34:35.231]                   if (TRUE) {
[13:34:35.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.231]                     {
[13:34:35.231]                       inherits <- base::inherits
[13:34:35.231]                       invokeRestart <- base::invokeRestart
[13:34:35.231]                       is.null <- base::is.null
[13:34:35.231]                       muffled <- FALSE
[13:34:35.231]                       if (inherits(cond, "message")) {
[13:34:35.231]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.231]                         if (muffled) 
[13:34:35.231]                           invokeRestart("muffleMessage")
[13:34:35.231]                       }
[13:34:35.231]                       else if (inherits(cond, "warning")) {
[13:34:35.231]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.231]                         if (muffled) 
[13:34:35.231]                           invokeRestart("muffleWarning")
[13:34:35.231]                       }
[13:34:35.231]                       else if (inherits(cond, "condition")) {
[13:34:35.231]                         if (!is.null(pattern)) {
[13:34:35.231]                           computeRestarts <- base::computeRestarts
[13:34:35.231]                           grepl <- base::grepl
[13:34:35.231]                           restarts <- computeRestarts(cond)
[13:34:35.231]                           for (restart in restarts) {
[13:34:35.231]                             name <- restart$name
[13:34:35.231]                             if (is.null(name)) 
[13:34:35.231]                               next
[13:34:35.231]                             if (!grepl(pattern, name)) 
[13:34:35.231]                               next
[13:34:35.231]                             invokeRestart(restart)
[13:34:35.231]                             muffled <- TRUE
[13:34:35.231]                             break
[13:34:35.231]                           }
[13:34:35.231]                         }
[13:34:35.231]                       }
[13:34:35.231]                       invisible(muffled)
[13:34:35.231]                     }
[13:34:35.231]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.231]                   }
[13:34:35.231]                 }
[13:34:35.231]             }
[13:34:35.231]         }))
[13:34:35.231]     }, error = function(ex) {
[13:34:35.231]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.231]                 ...future.rng), started = ...future.startTime, 
[13:34:35.231]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.231]             version = "1.8"), class = "FutureResult")
[13:34:35.231]     }, finally = {
[13:34:35.231]         if (!identical(...future.workdir, getwd())) 
[13:34:35.231]             setwd(...future.workdir)
[13:34:35.231]         {
[13:34:35.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.231]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.231]             }
[13:34:35.231]             base::options(...future.oldOptions)
[13:34:35.231]             if (.Platform$OS.type == "windows") {
[13:34:35.231]                 old_names <- names(...future.oldEnvVars)
[13:34:35.231]                 envs <- base::Sys.getenv()
[13:34:35.231]                 names <- names(envs)
[13:34:35.231]                 common <- intersect(names, old_names)
[13:34:35.231]                 added <- setdiff(names, old_names)
[13:34:35.231]                 removed <- setdiff(old_names, names)
[13:34:35.231]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.231]                   envs[common]]
[13:34:35.231]                 NAMES <- toupper(changed)
[13:34:35.231]                 args <- list()
[13:34:35.231]                 for (kk in seq_along(NAMES)) {
[13:34:35.231]                   name <- changed[[kk]]
[13:34:35.231]                   NAME <- NAMES[[kk]]
[13:34:35.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.231]                     next
[13:34:35.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.231]                 }
[13:34:35.231]                 NAMES <- toupper(added)
[13:34:35.231]                 for (kk in seq_along(NAMES)) {
[13:34:35.231]                   name <- added[[kk]]
[13:34:35.231]                   NAME <- NAMES[[kk]]
[13:34:35.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.231]                     next
[13:34:35.231]                   args[[name]] <- ""
[13:34:35.231]                 }
[13:34:35.231]                 NAMES <- toupper(removed)
[13:34:35.231]                 for (kk in seq_along(NAMES)) {
[13:34:35.231]                   name <- removed[[kk]]
[13:34:35.231]                   NAME <- NAMES[[kk]]
[13:34:35.231]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.231]                     next
[13:34:35.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.231]                 }
[13:34:35.231]                 if (length(args) > 0) 
[13:34:35.231]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.231]             }
[13:34:35.231]             else {
[13:34:35.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.231]             }
[13:34:35.231]             {
[13:34:35.231]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.231]                   0L) {
[13:34:35.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.231]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.231]                   base::options(opts)
[13:34:35.231]                 }
[13:34:35.231]                 {
[13:34:35.231]                   {
[13:34:35.231]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.231]                     NULL
[13:34:35.231]                   }
[13:34:35.231]                   options(future.plan = NULL)
[13:34:35.231]                   if (is.na(NA_character_)) 
[13:34:35.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.231]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.231]                     .init = FALSE)
[13:34:35.231]                 }
[13:34:35.231]             }
[13:34:35.231]         }
[13:34:35.231]     })
[13:34:35.231]     if (TRUE) {
[13:34:35.231]         base::sink(type = "output", split = FALSE)
[13:34:35.231]         if (TRUE) {
[13:34:35.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.231]         }
[13:34:35.231]         else {
[13:34:35.231]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.231]         }
[13:34:35.231]         base::close(...future.stdout)
[13:34:35.231]         ...future.stdout <- NULL
[13:34:35.231]     }
[13:34:35.231]     ...future.result$conditions <- ...future.conditions
[13:34:35.231]     ...future.result$finished <- base::Sys.time()
[13:34:35.231]     ...future.result
[13:34:35.231] }
[13:34:35.234] assign_globals() ...
[13:34:35.234] List of 5
[13:34:35.234]  $ ...future.FUN            :function (x, y)  
[13:34:35.234]  $ MoreArgs                 : NULL
[13:34:35.234]  $ ...future.elements_ii    :List of 2
[13:34:35.234]   ..$ :List of 1
[13:34:35.234]   .. ..$ a: num 1
[13:34:35.234]   ..$ :List of 1
[13:34:35.234]   .. ..$ A: num 10
[13:34:35.234]  $ ...future.seeds_ii       : NULL
[13:34:35.234]  $ ...future.globals.maxSize: NULL
[13:34:35.234]  - attr(*, "where")=List of 5
[13:34:35.234]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.234]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.234]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.234]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.234]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.234]  - attr(*, "resolved")= logi FALSE
[13:34:35.234]  - attr(*, "total_size")= num 2088
[13:34:35.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.234]  - attr(*, "already-done")= logi TRUE
[13:34:35.239] - reassign environment for ‘...future.FUN’
[13:34:35.239] - copied ‘...future.FUN’ to environment
[13:34:35.239] - copied ‘MoreArgs’ to environment
[13:34:35.239] - copied ‘...future.elements_ii’ to environment
[13:34:35.239] - copied ‘...future.seeds_ii’ to environment
[13:34:35.239] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.239] assign_globals() ... done
[13:34:35.240] requestCore(): workers = 2
[13:34:35.241] MulticoreFuture started
[13:34:35.242] - Launch lazy future ... done
[13:34:35.242] run() for ‘MulticoreFuture’ ... done
[13:34:35.242] Created future:
[13:34:35.242] plan(): Setting new future strategy stack:
[13:34:35.243] List of future strategies:
[13:34:35.243] 1. sequential:
[13:34:35.243]    - args: function (..., envir = parent.frame())
[13:34:35.243]    - tweaked: FALSE
[13:34:35.243]    - call: NULL
[13:34:35.243] plan(): nbrOfWorkers() = 1
[13:34:35.245] plan(): Setting new future strategy stack:
[13:34:35.246] List of future strategies:
[13:34:35.246] 1. multicore:
[13:34:35.246]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.246]    - tweaked: FALSE
[13:34:35.246]    - call: plan(strategy)
[13:34:35.251] plan(): nbrOfWorkers() = 2
[13:34:35.242] MulticoreFuture:
[13:34:35.242] Label: ‘future_mapply-1’
[13:34:35.242] Expression:
[13:34:35.242] {
[13:34:35.242]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.242]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.242]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.242]         on.exit(options(oopts), add = TRUE)
[13:34:35.242]     }
[13:34:35.242]     {
[13:34:35.242]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.242]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.242]         do.call(mapply, args = args)
[13:34:35.242]     }
[13:34:35.242] }
[13:34:35.242] Lazy evaluation: FALSE
[13:34:35.242] Asynchronous evaluation: TRUE
[13:34:35.242] Local evaluation: TRUE
[13:34:35.242] Environment: R_GlobalEnv
[13:34:35.242] Capture standard output: TRUE
[13:34:35.242] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.242] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.242] Packages: <none>
[13:34:35.242] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.242] Resolved: TRUE
[13:34:35.242] Value: <not collected>
[13:34:35.242] Conditions captured: <none>
[13:34:35.242] Early signaling: FALSE
[13:34:35.242] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.242] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.252] Chunk #1 of 2 ... DONE
[13:34:35.252] Chunk #2 of 2 ...
[13:34:35.252]  - Finding globals in '...' for chunk #2 ...
[13:34:35.252] getGlobalsAndPackages() ...
[13:34:35.253] Searching for globals...
[13:34:35.253] 
[13:34:35.253] Searching for globals ... DONE
[13:34:35.253] - globals: [0] <none>
[13:34:35.254] getGlobalsAndPackages() ... DONE
[13:34:35.254]    + additional globals found: [n=0] 
[13:34:35.254]    + additional namespaces needed: [n=0] 
[13:34:35.254]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:35.254]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:35.254]  - seeds: <none>
[13:34:35.254]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.255] getGlobalsAndPackages() ...
[13:34:35.255] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.255] Resolving globals: FALSE
[13:34:35.256] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[13:34:35.257] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:35.257] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.257] 
[13:34:35.257] getGlobalsAndPackages() ... DONE
[13:34:35.258] run() for ‘Future’ ...
[13:34:35.258] - state: ‘created’
[13:34:35.258] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.263] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.263] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.263]   - Field: ‘label’
[13:34:35.263]   - Field: ‘local’
[13:34:35.263]   - Field: ‘owner’
[13:34:35.263]   - Field: ‘envir’
[13:34:35.264]   - Field: ‘workers’
[13:34:35.264]   - Field: ‘packages’
[13:34:35.264]   - Field: ‘gc’
[13:34:35.264]   - Field: ‘job’
[13:34:35.264]   - Field: ‘conditions’
[13:34:35.264]   - Field: ‘expr’
[13:34:35.264]   - Field: ‘uuid’
[13:34:35.265]   - Field: ‘seed’
[13:34:35.265]   - Field: ‘version’
[13:34:35.265]   - Field: ‘result’
[13:34:35.265]   - Field: ‘asynchronous’
[13:34:35.265]   - Field: ‘calls’
[13:34:35.265]   - Field: ‘globals’
[13:34:35.265]   - Field: ‘stdout’
[13:34:35.266]   - Field: ‘earlySignal’
[13:34:35.266]   - Field: ‘lazy’
[13:34:35.266]   - Field: ‘state’
[13:34:35.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.266] - Launch lazy future ...
[13:34:35.270] Packages needed by the future expression (n = 0): <none>
[13:34:35.270] Packages needed by future strategies (n = 0): <none>
[13:34:35.272] {
[13:34:35.272]     {
[13:34:35.272]         {
[13:34:35.272]             ...future.startTime <- base::Sys.time()
[13:34:35.272]             {
[13:34:35.272]                 {
[13:34:35.272]                   {
[13:34:35.272]                     {
[13:34:35.272]                       base::local({
[13:34:35.272]                         has_future <- base::requireNamespace("future", 
[13:34:35.272]                           quietly = TRUE)
[13:34:35.272]                         if (has_future) {
[13:34:35.272]                           ns <- base::getNamespace("future")
[13:34:35.272]                           version <- ns[[".package"]][["version"]]
[13:34:35.272]                           if (is.null(version)) 
[13:34:35.272]                             version <- utils::packageVersion("future")
[13:34:35.272]                         }
[13:34:35.272]                         else {
[13:34:35.272]                           version <- NULL
[13:34:35.272]                         }
[13:34:35.272]                         if (!has_future || version < "1.8.0") {
[13:34:35.272]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.272]                             "", base::R.version$version.string), 
[13:34:35.272]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.272]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.272]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.272]                               "release", "version")], collapse = " "), 
[13:34:35.272]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.272]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.272]                             info)
[13:34:35.272]                           info <- base::paste(info, collapse = "; ")
[13:34:35.272]                           if (!has_future) {
[13:34:35.272]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.272]                               info)
[13:34:35.272]                           }
[13:34:35.272]                           else {
[13:34:35.272]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.272]                               info, version)
[13:34:35.272]                           }
[13:34:35.272]                           base::stop(msg)
[13:34:35.272]                         }
[13:34:35.272]                       })
[13:34:35.272]                     }
[13:34:35.272]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.272]                     base::options(mc.cores = 1L)
[13:34:35.272]                   }
[13:34:35.272]                   ...future.strategy.old <- future::plan("list")
[13:34:35.272]                   options(future.plan = NULL)
[13:34:35.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.272]                 }
[13:34:35.272]                 ...future.workdir <- getwd()
[13:34:35.272]             }
[13:34:35.272]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.272]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.272]         }
[13:34:35.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.272]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:35.272]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.272]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.272]             base::names(...future.oldOptions))
[13:34:35.272]     }
[13:34:35.272]     if (FALSE) {
[13:34:35.272]     }
[13:34:35.272]     else {
[13:34:35.272]         if (TRUE) {
[13:34:35.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.272]                 open = "w")
[13:34:35.272]         }
[13:34:35.272]         else {
[13:34:35.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.272]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.272]         }
[13:34:35.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.272]             base::sink(type = "output", split = FALSE)
[13:34:35.272]             base::close(...future.stdout)
[13:34:35.272]         }, add = TRUE)
[13:34:35.272]     }
[13:34:35.272]     ...future.frame <- base::sys.nframe()
[13:34:35.272]     ...future.conditions <- base::list()
[13:34:35.272]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.272]     if (FALSE) {
[13:34:35.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.272]     }
[13:34:35.272]     ...future.result <- base::tryCatch({
[13:34:35.272]         base::withCallingHandlers({
[13:34:35.272]             ...future.value <- base::withVisible(base::local({
[13:34:35.272]                 withCallingHandlers({
[13:34:35.272]                   {
[13:34:35.272]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.272]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.272]                       ...future.globals.maxSize)) {
[13:34:35.272]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.272]                       on.exit(options(oopts), add = TRUE)
[13:34:35.272]                     }
[13:34:35.272]                     {
[13:34:35.272]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.272]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.272]                         USE.NAMES = FALSE)
[13:34:35.272]                       do.call(mapply, args = args)
[13:34:35.272]                     }
[13:34:35.272]                   }
[13:34:35.272]                 }, immediateCondition = function(cond) {
[13:34:35.272]                   save_rds <- function (object, pathname, ...) 
[13:34:35.272]                   {
[13:34:35.272]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.272]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.272]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.272]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.272]                         fi_tmp[["mtime"]])
[13:34:35.272]                     }
[13:34:35.272]                     tryCatch({
[13:34:35.272]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.272]                     }, error = function(ex) {
[13:34:35.272]                       msg <- conditionMessage(ex)
[13:34:35.272]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.272]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.272]                         fi_tmp[["mtime"]], msg)
[13:34:35.272]                       ex$message <- msg
[13:34:35.272]                       stop(ex)
[13:34:35.272]                     })
[13:34:35.272]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.272]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.272]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.272]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.272]                       fi <- file.info(pathname)
[13:34:35.272]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.272]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.272]                         fi[["size"]], fi[["mtime"]])
[13:34:35.272]                       stop(msg)
[13:34:35.272]                     }
[13:34:35.272]                     invisible(pathname)
[13:34:35.272]                   }
[13:34:35.272]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.272]                     rootPath = tempdir()) 
[13:34:35.272]                   {
[13:34:35.272]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.272]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.272]                       tmpdir = path, fileext = ".rds")
[13:34:35.272]                     save_rds(obj, file)
[13:34:35.272]                   }
[13:34:35.272]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.272]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.272]                   {
[13:34:35.272]                     inherits <- base::inherits
[13:34:35.272]                     invokeRestart <- base::invokeRestart
[13:34:35.272]                     is.null <- base::is.null
[13:34:35.272]                     muffled <- FALSE
[13:34:35.272]                     if (inherits(cond, "message")) {
[13:34:35.272]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.272]                       if (muffled) 
[13:34:35.272]                         invokeRestart("muffleMessage")
[13:34:35.272]                     }
[13:34:35.272]                     else if (inherits(cond, "warning")) {
[13:34:35.272]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.272]                       if (muffled) 
[13:34:35.272]                         invokeRestart("muffleWarning")
[13:34:35.272]                     }
[13:34:35.272]                     else if (inherits(cond, "condition")) {
[13:34:35.272]                       if (!is.null(pattern)) {
[13:34:35.272]                         computeRestarts <- base::computeRestarts
[13:34:35.272]                         grepl <- base::grepl
[13:34:35.272]                         restarts <- computeRestarts(cond)
[13:34:35.272]                         for (restart in restarts) {
[13:34:35.272]                           name <- restart$name
[13:34:35.272]                           if (is.null(name)) 
[13:34:35.272]                             next
[13:34:35.272]                           if (!grepl(pattern, name)) 
[13:34:35.272]                             next
[13:34:35.272]                           invokeRestart(restart)
[13:34:35.272]                           muffled <- TRUE
[13:34:35.272]                           break
[13:34:35.272]                         }
[13:34:35.272]                       }
[13:34:35.272]                     }
[13:34:35.272]                     invisible(muffled)
[13:34:35.272]                   }
[13:34:35.272]                   muffleCondition(cond)
[13:34:35.272]                 })
[13:34:35.272]             }))
[13:34:35.272]             future::FutureResult(value = ...future.value$value, 
[13:34:35.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.272]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.272]                     ...future.globalenv.names))
[13:34:35.272]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.272]         }, condition = base::local({
[13:34:35.272]             c <- base::c
[13:34:35.272]             inherits <- base::inherits
[13:34:35.272]             invokeRestart <- base::invokeRestart
[13:34:35.272]             length <- base::length
[13:34:35.272]             list <- base::list
[13:34:35.272]             seq.int <- base::seq.int
[13:34:35.272]             signalCondition <- base::signalCondition
[13:34:35.272]             sys.calls <- base::sys.calls
[13:34:35.272]             `[[` <- base::`[[`
[13:34:35.272]             `+` <- base::`+`
[13:34:35.272]             `<<-` <- base::`<<-`
[13:34:35.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.272]                   3L)]
[13:34:35.272]             }
[13:34:35.272]             function(cond) {
[13:34:35.272]                 is_error <- inherits(cond, "error")
[13:34:35.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.272]                   NULL)
[13:34:35.272]                 if (is_error) {
[13:34:35.272]                   sessionInformation <- function() {
[13:34:35.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.272]                       search = base::search(), system = base::Sys.info())
[13:34:35.272]                   }
[13:34:35.272]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.272]                     cond$call), session = sessionInformation(), 
[13:34:35.272]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.272]                   signalCondition(cond)
[13:34:35.272]                 }
[13:34:35.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.272]                 "immediateCondition"))) {
[13:34:35.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.272]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.272]                   if (TRUE && !signal) {
[13:34:35.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.272]                     {
[13:34:35.272]                       inherits <- base::inherits
[13:34:35.272]                       invokeRestart <- base::invokeRestart
[13:34:35.272]                       is.null <- base::is.null
[13:34:35.272]                       muffled <- FALSE
[13:34:35.272]                       if (inherits(cond, "message")) {
[13:34:35.272]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.272]                         if (muffled) 
[13:34:35.272]                           invokeRestart("muffleMessage")
[13:34:35.272]                       }
[13:34:35.272]                       else if (inherits(cond, "warning")) {
[13:34:35.272]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.272]                         if (muffled) 
[13:34:35.272]                           invokeRestart("muffleWarning")
[13:34:35.272]                       }
[13:34:35.272]                       else if (inherits(cond, "condition")) {
[13:34:35.272]                         if (!is.null(pattern)) {
[13:34:35.272]                           computeRestarts <- base::computeRestarts
[13:34:35.272]                           grepl <- base::grepl
[13:34:35.272]                           restarts <- computeRestarts(cond)
[13:34:35.272]                           for (restart in restarts) {
[13:34:35.272]                             name <- restart$name
[13:34:35.272]                             if (is.null(name)) 
[13:34:35.272]                               next
[13:34:35.272]                             if (!grepl(pattern, name)) 
[13:34:35.272]                               next
[13:34:35.272]                             invokeRestart(restart)
[13:34:35.272]                             muffled <- TRUE
[13:34:35.272]                             break
[13:34:35.272]                           }
[13:34:35.272]                         }
[13:34:35.272]                       }
[13:34:35.272]                       invisible(muffled)
[13:34:35.272]                     }
[13:34:35.272]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.272]                   }
[13:34:35.272]                 }
[13:34:35.272]                 else {
[13:34:35.272]                   if (TRUE) {
[13:34:35.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.272]                     {
[13:34:35.272]                       inherits <- base::inherits
[13:34:35.272]                       invokeRestart <- base::invokeRestart
[13:34:35.272]                       is.null <- base::is.null
[13:34:35.272]                       muffled <- FALSE
[13:34:35.272]                       if (inherits(cond, "message")) {
[13:34:35.272]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.272]                         if (muffled) 
[13:34:35.272]                           invokeRestart("muffleMessage")
[13:34:35.272]                       }
[13:34:35.272]                       else if (inherits(cond, "warning")) {
[13:34:35.272]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.272]                         if (muffled) 
[13:34:35.272]                           invokeRestart("muffleWarning")
[13:34:35.272]                       }
[13:34:35.272]                       else if (inherits(cond, "condition")) {
[13:34:35.272]                         if (!is.null(pattern)) {
[13:34:35.272]                           computeRestarts <- base::computeRestarts
[13:34:35.272]                           grepl <- base::grepl
[13:34:35.272]                           restarts <- computeRestarts(cond)
[13:34:35.272]                           for (restart in restarts) {
[13:34:35.272]                             name <- restart$name
[13:34:35.272]                             if (is.null(name)) 
[13:34:35.272]                               next
[13:34:35.272]                             if (!grepl(pattern, name)) 
[13:34:35.272]                               next
[13:34:35.272]                             invokeRestart(restart)
[13:34:35.272]                             muffled <- TRUE
[13:34:35.272]                             break
[13:34:35.272]                           }
[13:34:35.272]                         }
[13:34:35.272]                       }
[13:34:35.272]                       invisible(muffled)
[13:34:35.272]                     }
[13:34:35.272]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.272]                   }
[13:34:35.272]                 }
[13:34:35.272]             }
[13:34:35.272]         }))
[13:34:35.272]     }, error = function(ex) {
[13:34:35.272]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.272]                 ...future.rng), started = ...future.startTime, 
[13:34:35.272]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.272]             version = "1.8"), class = "FutureResult")
[13:34:35.272]     }, finally = {
[13:34:35.272]         if (!identical(...future.workdir, getwd())) 
[13:34:35.272]             setwd(...future.workdir)
[13:34:35.272]         {
[13:34:35.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.272]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.272]             }
[13:34:35.272]             base::options(...future.oldOptions)
[13:34:35.272]             if (.Platform$OS.type == "windows") {
[13:34:35.272]                 old_names <- names(...future.oldEnvVars)
[13:34:35.272]                 envs <- base::Sys.getenv()
[13:34:35.272]                 names <- names(envs)
[13:34:35.272]                 common <- intersect(names, old_names)
[13:34:35.272]                 added <- setdiff(names, old_names)
[13:34:35.272]                 removed <- setdiff(old_names, names)
[13:34:35.272]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.272]                   envs[common]]
[13:34:35.272]                 NAMES <- toupper(changed)
[13:34:35.272]                 args <- list()
[13:34:35.272]                 for (kk in seq_along(NAMES)) {
[13:34:35.272]                   name <- changed[[kk]]
[13:34:35.272]                   NAME <- NAMES[[kk]]
[13:34:35.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.272]                     next
[13:34:35.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.272]                 }
[13:34:35.272]                 NAMES <- toupper(added)
[13:34:35.272]                 for (kk in seq_along(NAMES)) {
[13:34:35.272]                   name <- added[[kk]]
[13:34:35.272]                   NAME <- NAMES[[kk]]
[13:34:35.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.272]                     next
[13:34:35.272]                   args[[name]] <- ""
[13:34:35.272]                 }
[13:34:35.272]                 NAMES <- toupper(removed)
[13:34:35.272]                 for (kk in seq_along(NAMES)) {
[13:34:35.272]                   name <- removed[[kk]]
[13:34:35.272]                   NAME <- NAMES[[kk]]
[13:34:35.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.272]                     next
[13:34:35.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.272]                 }
[13:34:35.272]                 if (length(args) > 0) 
[13:34:35.272]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.272]             }
[13:34:35.272]             else {
[13:34:35.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.272]             }
[13:34:35.272]             {
[13:34:35.272]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.272]                   0L) {
[13:34:35.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.272]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.272]                   base::options(opts)
[13:34:35.272]                 }
[13:34:35.272]                 {
[13:34:35.272]                   {
[13:34:35.272]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.272]                     NULL
[13:34:35.272]                   }
[13:34:35.272]                   options(future.plan = NULL)
[13:34:35.272]                   if (is.na(NA_character_)) 
[13:34:35.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.272]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.272]                     .init = FALSE)
[13:34:35.272]                 }
[13:34:35.272]             }
[13:34:35.272]         }
[13:34:35.272]     })
[13:34:35.272]     if (TRUE) {
[13:34:35.272]         base::sink(type = "output", split = FALSE)
[13:34:35.272]         if (TRUE) {
[13:34:35.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.272]         }
[13:34:35.272]         else {
[13:34:35.272]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.272]         }
[13:34:35.272]         base::close(...future.stdout)
[13:34:35.272]         ...future.stdout <- NULL
[13:34:35.272]     }
[13:34:35.272]     ...future.result$conditions <- ...future.conditions
[13:34:35.272]     ...future.result$finished <- base::Sys.time()
[13:34:35.272]     ...future.result
[13:34:35.272] }
[13:34:35.275] assign_globals() ...
[13:34:35.275] List of 5
[13:34:35.275]  $ ...future.FUN            :function (x, y)  
[13:34:35.275]  $ MoreArgs                 : NULL
[13:34:35.275]  $ ...future.elements_ii    :List of 2
[13:34:35.275]   ..$ :List of 2
[13:34:35.275]   .. ..$ b: num 2
[13:34:35.275]   .. ..$ c: num 3
[13:34:35.275]   ..$ :List of 2
[13:34:35.275]   .. ..$ B: num 0
[13:34:35.275]   .. ..$ C: num -10
[13:34:35.275]  $ ...future.seeds_ii       : NULL
[13:34:35.275]  $ ...future.globals.maxSize: NULL
[13:34:35.275]  - attr(*, "where")=List of 5
[13:34:35.275]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.275]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.275]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.275]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.275]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.275]  - attr(*, "resolved")= logi FALSE
[13:34:35.275]  - attr(*, "total_size")= num 2200
[13:34:35.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.275]  - attr(*, "already-done")= logi TRUE
[13:34:35.285] - reassign environment for ‘...future.FUN’
[13:34:35.285] - copied ‘...future.FUN’ to environment
[13:34:35.286] - copied ‘MoreArgs’ to environment
[13:34:35.286] - copied ‘...future.elements_ii’ to environment
[13:34:35.286] - copied ‘...future.seeds_ii’ to environment
[13:34:35.286] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.286] assign_globals() ... done
[13:34:35.286] requestCore(): workers = 2
[13:34:35.288] MulticoreFuture started
[13:34:35.289] - Launch lazy future ... done
[13:34:35.289] run() for ‘MulticoreFuture’ ... done
[13:34:35.289] Created future:
[13:34:35.290] plan(): Setting new future strategy stack:
[13:34:35.290] List of future strategies:
[13:34:35.290] 1. sequential:
[13:34:35.290]    - args: function (..., envir = parent.frame())
[13:34:35.290]    - tweaked: FALSE
[13:34:35.290]    - call: NULL
[13:34:35.291] plan(): nbrOfWorkers() = 1
[13:34:35.293] plan(): Setting new future strategy stack:
[13:34:35.293] List of future strategies:
[13:34:35.293] 1. multicore:
[13:34:35.293]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.293]    - tweaked: FALSE
[13:34:35.293]    - call: plan(strategy)
[13:34:35.298] plan(): nbrOfWorkers() = 2
[13:34:35.289] MulticoreFuture:
[13:34:35.289] Label: ‘future_mapply-2’
[13:34:35.289] Expression:
[13:34:35.289] {
[13:34:35.289]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.289]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.289]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.289]         on.exit(options(oopts), add = TRUE)
[13:34:35.289]     }
[13:34:35.289]     {
[13:34:35.289]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.289]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.289]         do.call(mapply, args = args)
[13:34:35.289]     }
[13:34:35.289] }
[13:34:35.289] Lazy evaluation: FALSE
[13:34:35.289] Asynchronous evaluation: TRUE
[13:34:35.289] Local evaluation: TRUE
[13:34:35.289] Environment: R_GlobalEnv
[13:34:35.289] Capture standard output: TRUE
[13:34:35.289] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.289] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.289] Packages: <none>
[13:34:35.289] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.289] Resolved: TRUE
[13:34:35.289] Value: <not collected>
[13:34:35.289] Conditions captured: <none>
[13:34:35.289] Early signaling: FALSE
[13:34:35.289] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.289] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.299] Chunk #2 of 2 ... DONE
[13:34:35.299] Launching 2 futures (chunks) ... DONE
[13:34:35.299] Resolving 2 futures (chunks) ...
[13:34:35.300] resolve() on list ...
[13:34:35.300]  recursive: 0
[13:34:35.300]  length: 2
[13:34:35.300] 
[13:34:35.300] Future #1
[13:34:35.300] result() for MulticoreFuture ...
[13:34:35.301] result() for MulticoreFuture ...
[13:34:35.301] result() for MulticoreFuture ... done
[13:34:35.302] result() for MulticoreFuture ... done
[13:34:35.302] result() for MulticoreFuture ...
[13:34:35.302] result() for MulticoreFuture ... done
[13:34:35.302] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:35.302] - nx: 2
[13:34:35.302] - relay: TRUE
[13:34:35.303] - stdout: TRUE
[13:34:35.303] - signal: TRUE
[13:34:35.303] - resignal: FALSE
[13:34:35.303] - force: TRUE
[13:34:35.303] - relayed: [n=2] FALSE, FALSE
[13:34:35.303] - queued futures: [n=2] FALSE, FALSE
[13:34:35.303]  - until=1
[13:34:35.303]  - relaying element #1
[13:34:35.304] result() for MulticoreFuture ...
[13:34:35.304] result() for MulticoreFuture ... done
[13:34:35.304] result() for MulticoreFuture ...
[13:34:35.304] result() for MulticoreFuture ... done
[13:34:35.304] result() for MulticoreFuture ...
[13:34:35.304] result() for MulticoreFuture ... done
[13:34:35.305] result() for MulticoreFuture ...
[13:34:35.305] result() for MulticoreFuture ... done
[13:34:35.305] - relayed: [n=2] TRUE, FALSE
[13:34:35.305] - queued futures: [n=2] TRUE, FALSE
[13:34:35.305] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:35.305]  length: 1 (resolved future 1)
[13:34:35.306] Future #2
[13:34:35.306] result() for MulticoreFuture ...
[13:34:35.307] result() for MulticoreFuture ...
[13:34:35.307] result() for MulticoreFuture ... done
[13:34:35.307] result() for MulticoreFuture ... done
[13:34:35.307] result() for MulticoreFuture ...
[13:34:35.308] result() for MulticoreFuture ... done
[13:34:35.308] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:35.308] - nx: 2
[13:34:35.308] - relay: TRUE
[13:34:35.308] - stdout: TRUE
[13:34:35.308] - signal: TRUE
[13:34:35.309] - resignal: FALSE
[13:34:35.309] - force: TRUE
[13:34:35.309] - relayed: [n=2] TRUE, FALSE
[13:34:35.309] - queued futures: [n=2] TRUE, FALSE
[13:34:35.309]  - until=2
[13:34:35.309]  - relaying element #2
[13:34:35.309] result() for MulticoreFuture ...
[13:34:35.310] result() for MulticoreFuture ... done
[13:34:35.310] result() for MulticoreFuture ...
[13:34:35.310] result() for MulticoreFuture ... done
[13:34:35.310] result() for MulticoreFuture ...
[13:34:35.310] result() for MulticoreFuture ... done
[13:34:35.310] result() for MulticoreFuture ...
[13:34:35.310] result() for MulticoreFuture ... done
[13:34:35.310] - relayed: [n=2] TRUE, TRUE
[13:34:35.311] - queued futures: [n=2] TRUE, TRUE
[13:34:35.311] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:35.311]  length: 0 (resolved future 2)
[13:34:35.311] Relaying remaining futures
[13:34:35.311] signalConditionsASAP(NULL, pos=0) ...
[13:34:35.311] - nx: 2
[13:34:35.311] - relay: TRUE
[13:34:35.311] - stdout: TRUE
[13:34:35.311] - signal: TRUE
[13:34:35.311] - resignal: FALSE
[13:34:35.312] - force: TRUE
[13:34:35.312] - relayed: [n=2] TRUE, TRUE
[13:34:35.312] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:35.312] - relayed: [n=2] TRUE, TRUE
[13:34:35.312] - queued futures: [n=2] TRUE, TRUE
[13:34:35.312] signalConditionsASAP(NULL, pos=0) ... done
[13:34:35.312] resolve() on list ... DONE
[13:34:35.312] result() for MulticoreFuture ...
[13:34:35.312] result() for MulticoreFuture ... done
[13:34:35.313] result() for MulticoreFuture ...
[13:34:35.315] result() for MulticoreFuture ... done
[13:34:35.316] result() for MulticoreFuture ...
[13:34:35.316] result() for MulticoreFuture ... done
[13:34:35.316] result() for MulticoreFuture ...
[13:34:35.316] result() for MulticoreFuture ... done
[13:34:35.316]  - Number of value chunks collected: 2
[13:34:35.317] Resolving 2 futures (chunks) ... DONE
[13:34:35.317] Reducing values from 2 chunks ...
[13:34:35.317]  - Number of values collected after concatenation: 3
[13:34:35.317]  - Number of values expected: 3
[13:34:35.317] Reducing values from 2 chunks ... DONE
[13:34:35.317] future_mapply() ... DONE
- future_.mapply()
[13:34:35.318] future_mapply() ...
[13:34:35.322] Number of chunks: 2
[13:34:35.322] getGlobalsAndPackagesXApply() ...
[13:34:35.323]  - future.globals: TRUE
[13:34:35.323] getGlobalsAndPackages() ...
[13:34:35.323] Searching for globals...
[13:34:35.324] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[13:34:35.325] Searching for globals ... DONE
[13:34:35.325] Resolving globals: FALSE
[13:34:35.325] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[13:34:35.326] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[13:34:35.326] - globals: [1] ‘FUN’
[13:34:35.326] 
[13:34:35.326] getGlobalsAndPackages() ... DONE
[13:34:35.326]  - globals found/used: [n=1] ‘FUN’
[13:34:35.326]  - needed namespaces: [n=0] 
[13:34:35.327] Finding globals ... DONE
[13:34:35.327] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:35.327] List of 2
[13:34:35.327]  $ ...future.FUN:function (x, y)  
[13:34:35.327]  $ MoreArgs     : list()
[13:34:35.327]  - attr(*, "where")=List of 2
[13:34:35.327]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:35.327]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:35.327]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.327]  - attr(*, "resolved")= logi FALSE
[13:34:35.327]  - attr(*, "total_size")= num NA
[13:34:35.330] Packages to be attached in all futures: [n=0] 
[13:34:35.330] getGlobalsAndPackagesXApply() ... DONE
[13:34:35.330] Number of futures (= number of chunks): 2
[13:34:35.330] Launching 2 futures (chunks) ...
[13:34:35.330] Chunk #1 of 2 ...
[13:34:35.330]  - Finding globals in '...' for chunk #1 ...
[13:34:35.331] getGlobalsAndPackages() ...
[13:34:35.331] Searching for globals...
[13:34:35.331] 
[13:34:35.331] Searching for globals ... DONE
[13:34:35.331] - globals: [0] <none>
[13:34:35.331] getGlobalsAndPackages() ... DONE
[13:34:35.331]    + additional globals found: [n=0] 
[13:34:35.331]    + additional namespaces needed: [n=0] 
[13:34:35.332]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:35.332]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:35.332]  - seeds: <none>
[13:34:35.332]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.332] getGlobalsAndPackages() ...
[13:34:35.332] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.332] Resolving globals: FALSE
[13:34:35.333] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[13:34:35.333] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:35.333] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.333] 
[13:34:35.333] getGlobalsAndPackages() ... DONE
[13:34:35.334] run() for ‘Future’ ...
[13:34:35.334] - state: ‘created’
[13:34:35.334] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.337] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.337] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.338]   - Field: ‘label’
[13:34:35.338]   - Field: ‘local’
[13:34:35.338]   - Field: ‘owner’
[13:34:35.338]   - Field: ‘envir’
[13:34:35.338]   - Field: ‘workers’
[13:34:35.338]   - Field: ‘packages’
[13:34:35.338]   - Field: ‘gc’
[13:34:35.338]   - Field: ‘job’
[13:34:35.338]   - Field: ‘conditions’
[13:34:35.339]   - Field: ‘expr’
[13:34:35.339]   - Field: ‘uuid’
[13:34:35.339]   - Field: ‘seed’
[13:34:35.339]   - Field: ‘version’
[13:34:35.339]   - Field: ‘result’
[13:34:35.339]   - Field: ‘asynchronous’
[13:34:35.339]   - Field: ‘calls’
[13:34:35.339]   - Field: ‘globals’
[13:34:35.340]   - Field: ‘stdout’
[13:34:35.340]   - Field: ‘earlySignal’
[13:34:35.340]   - Field: ‘lazy’
[13:34:35.340]   - Field: ‘state’
[13:34:35.340] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.340] - Launch lazy future ...
[13:34:35.340] Packages needed by the future expression (n = 0): <none>
[13:34:35.340] Packages needed by future strategies (n = 0): <none>
[13:34:35.341] {
[13:34:35.341]     {
[13:34:35.341]         {
[13:34:35.341]             ...future.startTime <- base::Sys.time()
[13:34:35.341]             {
[13:34:35.341]                 {
[13:34:35.341]                   {
[13:34:35.341]                     {
[13:34:35.341]                       base::local({
[13:34:35.341]                         has_future <- base::requireNamespace("future", 
[13:34:35.341]                           quietly = TRUE)
[13:34:35.341]                         if (has_future) {
[13:34:35.341]                           ns <- base::getNamespace("future")
[13:34:35.341]                           version <- ns[[".package"]][["version"]]
[13:34:35.341]                           if (is.null(version)) 
[13:34:35.341]                             version <- utils::packageVersion("future")
[13:34:35.341]                         }
[13:34:35.341]                         else {
[13:34:35.341]                           version <- NULL
[13:34:35.341]                         }
[13:34:35.341]                         if (!has_future || version < "1.8.0") {
[13:34:35.341]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.341]                             "", base::R.version$version.string), 
[13:34:35.341]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.341]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.341]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.341]                               "release", "version")], collapse = " "), 
[13:34:35.341]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.341]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.341]                             info)
[13:34:35.341]                           info <- base::paste(info, collapse = "; ")
[13:34:35.341]                           if (!has_future) {
[13:34:35.341]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.341]                               info)
[13:34:35.341]                           }
[13:34:35.341]                           else {
[13:34:35.341]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.341]                               info, version)
[13:34:35.341]                           }
[13:34:35.341]                           base::stop(msg)
[13:34:35.341]                         }
[13:34:35.341]                       })
[13:34:35.341]                     }
[13:34:35.341]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.341]                     base::options(mc.cores = 1L)
[13:34:35.341]                   }
[13:34:35.341]                   ...future.strategy.old <- future::plan("list")
[13:34:35.341]                   options(future.plan = NULL)
[13:34:35.341]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.341]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.341]                 }
[13:34:35.341]                 ...future.workdir <- getwd()
[13:34:35.341]             }
[13:34:35.341]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.341]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.341]         }
[13:34:35.341]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.341]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:35.341]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.341]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.341]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.341]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.341]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.341]             base::names(...future.oldOptions))
[13:34:35.341]     }
[13:34:35.341]     if (FALSE) {
[13:34:35.341]     }
[13:34:35.341]     else {
[13:34:35.341]         if (TRUE) {
[13:34:35.341]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.341]                 open = "w")
[13:34:35.341]         }
[13:34:35.341]         else {
[13:34:35.341]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.341]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.341]         }
[13:34:35.341]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.341]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.341]             base::sink(type = "output", split = FALSE)
[13:34:35.341]             base::close(...future.stdout)
[13:34:35.341]         }, add = TRUE)
[13:34:35.341]     }
[13:34:35.341]     ...future.frame <- base::sys.nframe()
[13:34:35.341]     ...future.conditions <- base::list()
[13:34:35.341]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.341]     if (FALSE) {
[13:34:35.341]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.341]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.341]     }
[13:34:35.341]     ...future.result <- base::tryCatch({
[13:34:35.341]         base::withCallingHandlers({
[13:34:35.341]             ...future.value <- base::withVisible(base::local({
[13:34:35.341]                 withCallingHandlers({
[13:34:35.341]                   {
[13:34:35.341]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.341]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.341]                       ...future.globals.maxSize)) {
[13:34:35.341]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.341]                       on.exit(options(oopts), add = TRUE)
[13:34:35.341]                     }
[13:34:35.341]                     {
[13:34:35.341]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.341]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.341]                         USE.NAMES = FALSE)
[13:34:35.341]                       do.call(mapply, args = args)
[13:34:35.341]                     }
[13:34:35.341]                   }
[13:34:35.341]                 }, immediateCondition = function(cond) {
[13:34:35.341]                   save_rds <- function (object, pathname, ...) 
[13:34:35.341]                   {
[13:34:35.341]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.341]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.341]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.341]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.341]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.341]                         fi_tmp[["mtime"]])
[13:34:35.341]                     }
[13:34:35.341]                     tryCatch({
[13:34:35.341]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.341]                     }, error = function(ex) {
[13:34:35.341]                       msg <- conditionMessage(ex)
[13:34:35.341]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.341]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.341]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.341]                         fi_tmp[["mtime"]], msg)
[13:34:35.341]                       ex$message <- msg
[13:34:35.341]                       stop(ex)
[13:34:35.341]                     })
[13:34:35.341]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.341]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.341]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.341]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.341]                       fi <- file.info(pathname)
[13:34:35.341]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.341]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.341]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.341]                         fi[["size"]], fi[["mtime"]])
[13:34:35.341]                       stop(msg)
[13:34:35.341]                     }
[13:34:35.341]                     invisible(pathname)
[13:34:35.341]                   }
[13:34:35.341]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.341]                     rootPath = tempdir()) 
[13:34:35.341]                   {
[13:34:35.341]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.341]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.341]                       tmpdir = path, fileext = ".rds")
[13:34:35.341]                     save_rds(obj, file)
[13:34:35.341]                   }
[13:34:35.341]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.341]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.341]                   {
[13:34:35.341]                     inherits <- base::inherits
[13:34:35.341]                     invokeRestart <- base::invokeRestart
[13:34:35.341]                     is.null <- base::is.null
[13:34:35.341]                     muffled <- FALSE
[13:34:35.341]                     if (inherits(cond, "message")) {
[13:34:35.341]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.341]                       if (muffled) 
[13:34:35.341]                         invokeRestart("muffleMessage")
[13:34:35.341]                     }
[13:34:35.341]                     else if (inherits(cond, "warning")) {
[13:34:35.341]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.341]                       if (muffled) 
[13:34:35.341]                         invokeRestart("muffleWarning")
[13:34:35.341]                     }
[13:34:35.341]                     else if (inherits(cond, "condition")) {
[13:34:35.341]                       if (!is.null(pattern)) {
[13:34:35.341]                         computeRestarts <- base::computeRestarts
[13:34:35.341]                         grepl <- base::grepl
[13:34:35.341]                         restarts <- computeRestarts(cond)
[13:34:35.341]                         for (restart in restarts) {
[13:34:35.341]                           name <- restart$name
[13:34:35.341]                           if (is.null(name)) 
[13:34:35.341]                             next
[13:34:35.341]                           if (!grepl(pattern, name)) 
[13:34:35.341]                             next
[13:34:35.341]                           invokeRestart(restart)
[13:34:35.341]                           muffled <- TRUE
[13:34:35.341]                           break
[13:34:35.341]                         }
[13:34:35.341]                       }
[13:34:35.341]                     }
[13:34:35.341]                     invisible(muffled)
[13:34:35.341]                   }
[13:34:35.341]                   muffleCondition(cond)
[13:34:35.341]                 })
[13:34:35.341]             }))
[13:34:35.341]             future::FutureResult(value = ...future.value$value, 
[13:34:35.341]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.341]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.341]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.341]                     ...future.globalenv.names))
[13:34:35.341]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.341]         }, condition = base::local({
[13:34:35.341]             c <- base::c
[13:34:35.341]             inherits <- base::inherits
[13:34:35.341]             invokeRestart <- base::invokeRestart
[13:34:35.341]             length <- base::length
[13:34:35.341]             list <- base::list
[13:34:35.341]             seq.int <- base::seq.int
[13:34:35.341]             signalCondition <- base::signalCondition
[13:34:35.341]             sys.calls <- base::sys.calls
[13:34:35.341]             `[[` <- base::`[[`
[13:34:35.341]             `+` <- base::`+`
[13:34:35.341]             `<<-` <- base::`<<-`
[13:34:35.341]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.341]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.341]                   3L)]
[13:34:35.341]             }
[13:34:35.341]             function(cond) {
[13:34:35.341]                 is_error <- inherits(cond, "error")
[13:34:35.341]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.341]                   NULL)
[13:34:35.341]                 if (is_error) {
[13:34:35.341]                   sessionInformation <- function() {
[13:34:35.341]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.341]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.341]                       search = base::search(), system = base::Sys.info())
[13:34:35.341]                   }
[13:34:35.341]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.341]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.341]                     cond$call), session = sessionInformation(), 
[13:34:35.341]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.341]                   signalCondition(cond)
[13:34:35.341]                 }
[13:34:35.341]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.341]                 "immediateCondition"))) {
[13:34:35.341]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.341]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.341]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.341]                   if (TRUE && !signal) {
[13:34:35.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.341]                     {
[13:34:35.341]                       inherits <- base::inherits
[13:34:35.341]                       invokeRestart <- base::invokeRestart
[13:34:35.341]                       is.null <- base::is.null
[13:34:35.341]                       muffled <- FALSE
[13:34:35.341]                       if (inherits(cond, "message")) {
[13:34:35.341]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.341]                         if (muffled) 
[13:34:35.341]                           invokeRestart("muffleMessage")
[13:34:35.341]                       }
[13:34:35.341]                       else if (inherits(cond, "warning")) {
[13:34:35.341]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.341]                         if (muffled) 
[13:34:35.341]                           invokeRestart("muffleWarning")
[13:34:35.341]                       }
[13:34:35.341]                       else if (inherits(cond, "condition")) {
[13:34:35.341]                         if (!is.null(pattern)) {
[13:34:35.341]                           computeRestarts <- base::computeRestarts
[13:34:35.341]                           grepl <- base::grepl
[13:34:35.341]                           restarts <- computeRestarts(cond)
[13:34:35.341]                           for (restart in restarts) {
[13:34:35.341]                             name <- restart$name
[13:34:35.341]                             if (is.null(name)) 
[13:34:35.341]                               next
[13:34:35.341]                             if (!grepl(pattern, name)) 
[13:34:35.341]                               next
[13:34:35.341]                             invokeRestart(restart)
[13:34:35.341]                             muffled <- TRUE
[13:34:35.341]                             break
[13:34:35.341]                           }
[13:34:35.341]                         }
[13:34:35.341]                       }
[13:34:35.341]                       invisible(muffled)
[13:34:35.341]                     }
[13:34:35.341]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.341]                   }
[13:34:35.341]                 }
[13:34:35.341]                 else {
[13:34:35.341]                   if (TRUE) {
[13:34:35.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.341]                     {
[13:34:35.341]                       inherits <- base::inherits
[13:34:35.341]                       invokeRestart <- base::invokeRestart
[13:34:35.341]                       is.null <- base::is.null
[13:34:35.341]                       muffled <- FALSE
[13:34:35.341]                       if (inherits(cond, "message")) {
[13:34:35.341]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.341]                         if (muffled) 
[13:34:35.341]                           invokeRestart("muffleMessage")
[13:34:35.341]                       }
[13:34:35.341]                       else if (inherits(cond, "warning")) {
[13:34:35.341]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.341]                         if (muffled) 
[13:34:35.341]                           invokeRestart("muffleWarning")
[13:34:35.341]                       }
[13:34:35.341]                       else if (inherits(cond, "condition")) {
[13:34:35.341]                         if (!is.null(pattern)) {
[13:34:35.341]                           computeRestarts <- base::computeRestarts
[13:34:35.341]                           grepl <- base::grepl
[13:34:35.341]                           restarts <- computeRestarts(cond)
[13:34:35.341]                           for (restart in restarts) {
[13:34:35.341]                             name <- restart$name
[13:34:35.341]                             if (is.null(name)) 
[13:34:35.341]                               next
[13:34:35.341]                             if (!grepl(pattern, name)) 
[13:34:35.341]                               next
[13:34:35.341]                             invokeRestart(restart)
[13:34:35.341]                             muffled <- TRUE
[13:34:35.341]                             break
[13:34:35.341]                           }
[13:34:35.341]                         }
[13:34:35.341]                       }
[13:34:35.341]                       invisible(muffled)
[13:34:35.341]                     }
[13:34:35.341]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.341]                   }
[13:34:35.341]                 }
[13:34:35.341]             }
[13:34:35.341]         }))
[13:34:35.341]     }, error = function(ex) {
[13:34:35.341]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.341]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.341]                 ...future.rng), started = ...future.startTime, 
[13:34:35.341]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.341]             version = "1.8"), class = "FutureResult")
[13:34:35.341]     }, finally = {
[13:34:35.341]         if (!identical(...future.workdir, getwd())) 
[13:34:35.341]             setwd(...future.workdir)
[13:34:35.341]         {
[13:34:35.341]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.341]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.341]             }
[13:34:35.341]             base::options(...future.oldOptions)
[13:34:35.341]             if (.Platform$OS.type == "windows") {
[13:34:35.341]                 old_names <- names(...future.oldEnvVars)
[13:34:35.341]                 envs <- base::Sys.getenv()
[13:34:35.341]                 names <- names(envs)
[13:34:35.341]                 common <- intersect(names, old_names)
[13:34:35.341]                 added <- setdiff(names, old_names)
[13:34:35.341]                 removed <- setdiff(old_names, names)
[13:34:35.341]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.341]                   envs[common]]
[13:34:35.341]                 NAMES <- toupper(changed)
[13:34:35.341]                 args <- list()
[13:34:35.341]                 for (kk in seq_along(NAMES)) {
[13:34:35.341]                   name <- changed[[kk]]
[13:34:35.341]                   NAME <- NAMES[[kk]]
[13:34:35.341]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.341]                     next
[13:34:35.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.341]                 }
[13:34:35.341]                 NAMES <- toupper(added)
[13:34:35.341]                 for (kk in seq_along(NAMES)) {
[13:34:35.341]                   name <- added[[kk]]
[13:34:35.341]                   NAME <- NAMES[[kk]]
[13:34:35.341]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.341]                     next
[13:34:35.341]                   args[[name]] <- ""
[13:34:35.341]                 }
[13:34:35.341]                 NAMES <- toupper(removed)
[13:34:35.341]                 for (kk in seq_along(NAMES)) {
[13:34:35.341]                   name <- removed[[kk]]
[13:34:35.341]                   NAME <- NAMES[[kk]]
[13:34:35.341]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.341]                     next
[13:34:35.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.341]                 }
[13:34:35.341]                 if (length(args) > 0) 
[13:34:35.341]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.341]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.341]             }
[13:34:35.341]             else {
[13:34:35.341]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.341]             }
[13:34:35.341]             {
[13:34:35.341]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.341]                   0L) {
[13:34:35.341]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.341]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.341]                   base::options(opts)
[13:34:35.341]                 }
[13:34:35.341]                 {
[13:34:35.341]                   {
[13:34:35.341]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.341]                     NULL
[13:34:35.341]                   }
[13:34:35.341]                   options(future.plan = NULL)
[13:34:35.341]                   if (is.na(NA_character_)) 
[13:34:35.341]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.341]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.341]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.341]                     .init = FALSE)
[13:34:35.341]                 }
[13:34:35.341]             }
[13:34:35.341]         }
[13:34:35.341]     })
[13:34:35.341]     if (TRUE) {
[13:34:35.341]         base::sink(type = "output", split = FALSE)
[13:34:35.341]         if (TRUE) {
[13:34:35.341]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.341]         }
[13:34:35.341]         else {
[13:34:35.341]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.341]         }
[13:34:35.341]         base::close(...future.stdout)
[13:34:35.341]         ...future.stdout <- NULL
[13:34:35.341]     }
[13:34:35.341]     ...future.result$conditions <- ...future.conditions
[13:34:35.341]     ...future.result$finished <- base::Sys.time()
[13:34:35.341]     ...future.result
[13:34:35.341] }
[13:34:35.343] assign_globals() ...
[13:34:35.343] List of 5
[13:34:35.343]  $ ...future.FUN            :function (x, y)  
[13:34:35.343]  $ MoreArgs                 : list()
[13:34:35.343]  $ ...future.elements_ii    :List of 2
[13:34:35.343]   ..$ :List of 1
[13:34:35.343]   .. ..$ a: num 1
[13:34:35.343]   ..$ :List of 1
[13:34:35.343]   .. ..$ A: num 10
[13:34:35.343]  $ ...future.seeds_ii       : NULL
[13:34:35.343]  $ ...future.globals.maxSize: NULL
[13:34:35.343]  - attr(*, "where")=List of 5
[13:34:35.343]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.343]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.343]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.343]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.343]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.343]  - attr(*, "resolved")= logi FALSE
[13:34:35.343]  - attr(*, "total_size")= num 2088
[13:34:35.343]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.343]  - attr(*, "already-done")= logi TRUE
[13:34:35.351] - reassign environment for ‘...future.FUN’
[13:34:35.351] - copied ‘...future.FUN’ to environment
[13:34:35.351] - copied ‘MoreArgs’ to environment
[13:34:35.351] - copied ‘...future.elements_ii’ to environment
[13:34:35.351] - copied ‘...future.seeds_ii’ to environment
[13:34:35.351] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.352] assign_globals() ... done
[13:34:35.352] requestCore(): workers = 2
[13:34:35.354] MulticoreFuture started
[13:34:35.354] - Launch lazy future ... done
[13:34:35.354] run() for ‘MulticoreFuture’ ... done
[13:34:35.355] Created future:
[13:34:35.355] plan(): Setting new future strategy stack:
[13:34:35.355] List of future strategies:
[13:34:35.355] 1. sequential:
[13:34:35.355]    - args: function (..., envir = parent.frame())
[13:34:35.355]    - tweaked: FALSE
[13:34:35.355]    - call: NULL
[13:34:35.356] plan(): nbrOfWorkers() = 1
[13:34:35.358] plan(): Setting new future strategy stack:
[13:34:35.358] List of future strategies:
[13:34:35.358] 1. multicore:
[13:34:35.358]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.358]    - tweaked: FALSE
[13:34:35.358]    - call: plan(strategy)
[13:34:35.364] plan(): nbrOfWorkers() = 2
[13:34:35.355] MulticoreFuture:
[13:34:35.355] Label: ‘future_.mapply-1’
[13:34:35.355] Expression:
[13:34:35.355] {
[13:34:35.355]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.355]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.355]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.355]         on.exit(options(oopts), add = TRUE)
[13:34:35.355]     }
[13:34:35.355]     {
[13:34:35.355]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.355]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.355]         do.call(mapply, args = args)
[13:34:35.355]     }
[13:34:35.355] }
[13:34:35.355] Lazy evaluation: FALSE
[13:34:35.355] Asynchronous evaluation: TRUE
[13:34:35.355] Local evaluation: TRUE
[13:34:35.355] Environment: R_GlobalEnv
[13:34:35.355] Capture standard output: TRUE
[13:34:35.355] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.355] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.355] Packages: <none>
[13:34:35.355] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.355] Resolved: TRUE
[13:34:35.355] Value: <not collected>
[13:34:35.355] Conditions captured: <none>
[13:34:35.355] Early signaling: FALSE
[13:34:35.355] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.355] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.365] Chunk #1 of 2 ... DONE
[13:34:35.365] Chunk #2 of 2 ...
[13:34:35.366]  - Finding globals in '...' for chunk #2 ...
[13:34:35.366] getGlobalsAndPackages() ...
[13:34:35.366] Searching for globals...
[13:34:35.367] 
[13:34:35.367] Searching for globals ... DONE
[13:34:35.367] - globals: [0] <none>
[13:34:35.367] getGlobalsAndPackages() ... DONE
[13:34:35.367]    + additional globals found: [n=0] 
[13:34:35.367]    + additional namespaces needed: [n=0] 
[13:34:35.367]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:35.368]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:35.368]  - seeds: <none>
[13:34:35.368]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.368] getGlobalsAndPackages() ...
[13:34:35.368] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.368] Resolving globals: FALSE
[13:34:35.369] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[13:34:35.370] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:35.370] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.370] 
[13:34:35.370] getGlobalsAndPackages() ... DONE
[13:34:35.371] run() for ‘Future’ ...
[13:34:35.371] - state: ‘created’
[13:34:35.371] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.376] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.376] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.376]   - Field: ‘label’
[13:34:35.376]   - Field: ‘local’
[13:34:35.376]   - Field: ‘owner’
[13:34:35.377]   - Field: ‘envir’
[13:34:35.377]   - Field: ‘workers’
[13:34:35.377]   - Field: ‘packages’
[13:34:35.377]   - Field: ‘gc’
[13:34:35.377]   - Field: ‘job’
[13:34:35.377]   - Field: ‘conditions’
[13:34:35.377]   - Field: ‘expr’
[13:34:35.378]   - Field: ‘uuid’
[13:34:35.378]   - Field: ‘seed’
[13:34:35.378]   - Field: ‘version’
[13:34:35.378]   - Field: ‘result’
[13:34:35.378]   - Field: ‘asynchronous’
[13:34:35.378]   - Field: ‘calls’
[13:34:35.379]   - Field: ‘globals’
[13:34:35.379]   - Field: ‘stdout’
[13:34:35.379]   - Field: ‘earlySignal’
[13:34:35.379]   - Field: ‘lazy’
[13:34:35.379]   - Field: ‘state’
[13:34:35.379] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.380] - Launch lazy future ...
[13:34:35.380] Packages needed by the future expression (n = 0): <none>
[13:34:35.380] Packages needed by future strategies (n = 0): <none>
[13:34:35.381] {
[13:34:35.381]     {
[13:34:35.381]         {
[13:34:35.381]             ...future.startTime <- base::Sys.time()
[13:34:35.381]             {
[13:34:35.381]                 {
[13:34:35.381]                   {
[13:34:35.381]                     {
[13:34:35.381]                       base::local({
[13:34:35.381]                         has_future <- base::requireNamespace("future", 
[13:34:35.381]                           quietly = TRUE)
[13:34:35.381]                         if (has_future) {
[13:34:35.381]                           ns <- base::getNamespace("future")
[13:34:35.381]                           version <- ns[[".package"]][["version"]]
[13:34:35.381]                           if (is.null(version)) 
[13:34:35.381]                             version <- utils::packageVersion("future")
[13:34:35.381]                         }
[13:34:35.381]                         else {
[13:34:35.381]                           version <- NULL
[13:34:35.381]                         }
[13:34:35.381]                         if (!has_future || version < "1.8.0") {
[13:34:35.381]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.381]                             "", base::R.version$version.string), 
[13:34:35.381]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.381]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.381]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.381]                               "release", "version")], collapse = " "), 
[13:34:35.381]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.381]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.381]                             info)
[13:34:35.381]                           info <- base::paste(info, collapse = "; ")
[13:34:35.381]                           if (!has_future) {
[13:34:35.381]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.381]                               info)
[13:34:35.381]                           }
[13:34:35.381]                           else {
[13:34:35.381]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.381]                               info, version)
[13:34:35.381]                           }
[13:34:35.381]                           base::stop(msg)
[13:34:35.381]                         }
[13:34:35.381]                       })
[13:34:35.381]                     }
[13:34:35.381]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.381]                     base::options(mc.cores = 1L)
[13:34:35.381]                   }
[13:34:35.381]                   ...future.strategy.old <- future::plan("list")
[13:34:35.381]                   options(future.plan = NULL)
[13:34:35.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.381]                 }
[13:34:35.381]                 ...future.workdir <- getwd()
[13:34:35.381]             }
[13:34:35.381]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.381]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.381]         }
[13:34:35.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.381]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:35.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.381]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.381]             base::names(...future.oldOptions))
[13:34:35.381]     }
[13:34:35.381]     if (FALSE) {
[13:34:35.381]     }
[13:34:35.381]     else {
[13:34:35.381]         if (TRUE) {
[13:34:35.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.381]                 open = "w")
[13:34:35.381]         }
[13:34:35.381]         else {
[13:34:35.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.381]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.381]         }
[13:34:35.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.381]             base::sink(type = "output", split = FALSE)
[13:34:35.381]             base::close(...future.stdout)
[13:34:35.381]         }, add = TRUE)
[13:34:35.381]     }
[13:34:35.381]     ...future.frame <- base::sys.nframe()
[13:34:35.381]     ...future.conditions <- base::list()
[13:34:35.381]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.381]     if (FALSE) {
[13:34:35.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.381]     }
[13:34:35.381]     ...future.result <- base::tryCatch({
[13:34:35.381]         base::withCallingHandlers({
[13:34:35.381]             ...future.value <- base::withVisible(base::local({
[13:34:35.381]                 withCallingHandlers({
[13:34:35.381]                   {
[13:34:35.381]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.381]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.381]                       ...future.globals.maxSize)) {
[13:34:35.381]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.381]                       on.exit(options(oopts), add = TRUE)
[13:34:35.381]                     }
[13:34:35.381]                     {
[13:34:35.381]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.381]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.381]                         USE.NAMES = FALSE)
[13:34:35.381]                       do.call(mapply, args = args)
[13:34:35.381]                     }
[13:34:35.381]                   }
[13:34:35.381]                 }, immediateCondition = function(cond) {
[13:34:35.381]                   save_rds <- function (object, pathname, ...) 
[13:34:35.381]                   {
[13:34:35.381]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.381]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.381]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.381]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.381]                         fi_tmp[["mtime"]])
[13:34:35.381]                     }
[13:34:35.381]                     tryCatch({
[13:34:35.381]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.381]                     }, error = function(ex) {
[13:34:35.381]                       msg <- conditionMessage(ex)
[13:34:35.381]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.381]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.381]                         fi_tmp[["mtime"]], msg)
[13:34:35.381]                       ex$message <- msg
[13:34:35.381]                       stop(ex)
[13:34:35.381]                     })
[13:34:35.381]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.381]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.381]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.381]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.381]                       fi <- file.info(pathname)
[13:34:35.381]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.381]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.381]                         fi[["size"]], fi[["mtime"]])
[13:34:35.381]                       stop(msg)
[13:34:35.381]                     }
[13:34:35.381]                     invisible(pathname)
[13:34:35.381]                   }
[13:34:35.381]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.381]                     rootPath = tempdir()) 
[13:34:35.381]                   {
[13:34:35.381]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.381]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.381]                       tmpdir = path, fileext = ".rds")
[13:34:35.381]                     save_rds(obj, file)
[13:34:35.381]                   }
[13:34:35.381]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.381]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.381]                   {
[13:34:35.381]                     inherits <- base::inherits
[13:34:35.381]                     invokeRestart <- base::invokeRestart
[13:34:35.381]                     is.null <- base::is.null
[13:34:35.381]                     muffled <- FALSE
[13:34:35.381]                     if (inherits(cond, "message")) {
[13:34:35.381]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.381]                       if (muffled) 
[13:34:35.381]                         invokeRestart("muffleMessage")
[13:34:35.381]                     }
[13:34:35.381]                     else if (inherits(cond, "warning")) {
[13:34:35.381]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.381]                       if (muffled) 
[13:34:35.381]                         invokeRestart("muffleWarning")
[13:34:35.381]                     }
[13:34:35.381]                     else if (inherits(cond, "condition")) {
[13:34:35.381]                       if (!is.null(pattern)) {
[13:34:35.381]                         computeRestarts <- base::computeRestarts
[13:34:35.381]                         grepl <- base::grepl
[13:34:35.381]                         restarts <- computeRestarts(cond)
[13:34:35.381]                         for (restart in restarts) {
[13:34:35.381]                           name <- restart$name
[13:34:35.381]                           if (is.null(name)) 
[13:34:35.381]                             next
[13:34:35.381]                           if (!grepl(pattern, name)) 
[13:34:35.381]                             next
[13:34:35.381]                           invokeRestart(restart)
[13:34:35.381]                           muffled <- TRUE
[13:34:35.381]                           break
[13:34:35.381]                         }
[13:34:35.381]                       }
[13:34:35.381]                     }
[13:34:35.381]                     invisible(muffled)
[13:34:35.381]                   }
[13:34:35.381]                   muffleCondition(cond)
[13:34:35.381]                 })
[13:34:35.381]             }))
[13:34:35.381]             future::FutureResult(value = ...future.value$value, 
[13:34:35.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.381]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.381]                     ...future.globalenv.names))
[13:34:35.381]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.381]         }, condition = base::local({
[13:34:35.381]             c <- base::c
[13:34:35.381]             inherits <- base::inherits
[13:34:35.381]             invokeRestart <- base::invokeRestart
[13:34:35.381]             length <- base::length
[13:34:35.381]             list <- base::list
[13:34:35.381]             seq.int <- base::seq.int
[13:34:35.381]             signalCondition <- base::signalCondition
[13:34:35.381]             sys.calls <- base::sys.calls
[13:34:35.381]             `[[` <- base::`[[`
[13:34:35.381]             `+` <- base::`+`
[13:34:35.381]             `<<-` <- base::`<<-`
[13:34:35.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.381]                   3L)]
[13:34:35.381]             }
[13:34:35.381]             function(cond) {
[13:34:35.381]                 is_error <- inherits(cond, "error")
[13:34:35.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.381]                   NULL)
[13:34:35.381]                 if (is_error) {
[13:34:35.381]                   sessionInformation <- function() {
[13:34:35.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.381]                       search = base::search(), system = base::Sys.info())
[13:34:35.381]                   }
[13:34:35.381]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.381]                     cond$call), session = sessionInformation(), 
[13:34:35.381]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.381]                   signalCondition(cond)
[13:34:35.381]                 }
[13:34:35.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.381]                 "immediateCondition"))) {
[13:34:35.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.381]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.381]                   if (TRUE && !signal) {
[13:34:35.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.381]                     {
[13:34:35.381]                       inherits <- base::inherits
[13:34:35.381]                       invokeRestart <- base::invokeRestart
[13:34:35.381]                       is.null <- base::is.null
[13:34:35.381]                       muffled <- FALSE
[13:34:35.381]                       if (inherits(cond, "message")) {
[13:34:35.381]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.381]                         if (muffled) 
[13:34:35.381]                           invokeRestart("muffleMessage")
[13:34:35.381]                       }
[13:34:35.381]                       else if (inherits(cond, "warning")) {
[13:34:35.381]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.381]                         if (muffled) 
[13:34:35.381]                           invokeRestart("muffleWarning")
[13:34:35.381]                       }
[13:34:35.381]                       else if (inherits(cond, "condition")) {
[13:34:35.381]                         if (!is.null(pattern)) {
[13:34:35.381]                           computeRestarts <- base::computeRestarts
[13:34:35.381]                           grepl <- base::grepl
[13:34:35.381]                           restarts <- computeRestarts(cond)
[13:34:35.381]                           for (restart in restarts) {
[13:34:35.381]                             name <- restart$name
[13:34:35.381]                             if (is.null(name)) 
[13:34:35.381]                               next
[13:34:35.381]                             if (!grepl(pattern, name)) 
[13:34:35.381]                               next
[13:34:35.381]                             invokeRestart(restart)
[13:34:35.381]                             muffled <- TRUE
[13:34:35.381]                             break
[13:34:35.381]                           }
[13:34:35.381]                         }
[13:34:35.381]                       }
[13:34:35.381]                       invisible(muffled)
[13:34:35.381]                     }
[13:34:35.381]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.381]                   }
[13:34:35.381]                 }
[13:34:35.381]                 else {
[13:34:35.381]                   if (TRUE) {
[13:34:35.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.381]                     {
[13:34:35.381]                       inherits <- base::inherits
[13:34:35.381]                       invokeRestart <- base::invokeRestart
[13:34:35.381]                       is.null <- base::is.null
[13:34:35.381]                       muffled <- FALSE
[13:34:35.381]                       if (inherits(cond, "message")) {
[13:34:35.381]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.381]                         if (muffled) 
[13:34:35.381]                           invokeRestart("muffleMessage")
[13:34:35.381]                       }
[13:34:35.381]                       else if (inherits(cond, "warning")) {
[13:34:35.381]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.381]                         if (muffled) 
[13:34:35.381]                           invokeRestart("muffleWarning")
[13:34:35.381]                       }
[13:34:35.381]                       else if (inherits(cond, "condition")) {
[13:34:35.381]                         if (!is.null(pattern)) {
[13:34:35.381]                           computeRestarts <- base::computeRestarts
[13:34:35.381]                           grepl <- base::grepl
[13:34:35.381]                           restarts <- computeRestarts(cond)
[13:34:35.381]                           for (restart in restarts) {
[13:34:35.381]                             name <- restart$name
[13:34:35.381]                             if (is.null(name)) 
[13:34:35.381]                               next
[13:34:35.381]                             if (!grepl(pattern, name)) 
[13:34:35.381]                               next
[13:34:35.381]                             invokeRestart(restart)
[13:34:35.381]                             muffled <- TRUE
[13:34:35.381]                             break
[13:34:35.381]                           }
[13:34:35.381]                         }
[13:34:35.381]                       }
[13:34:35.381]                       invisible(muffled)
[13:34:35.381]                     }
[13:34:35.381]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.381]                   }
[13:34:35.381]                 }
[13:34:35.381]             }
[13:34:35.381]         }))
[13:34:35.381]     }, error = function(ex) {
[13:34:35.381]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.381]                 ...future.rng), started = ...future.startTime, 
[13:34:35.381]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.381]             version = "1.8"), class = "FutureResult")
[13:34:35.381]     }, finally = {
[13:34:35.381]         if (!identical(...future.workdir, getwd())) 
[13:34:35.381]             setwd(...future.workdir)
[13:34:35.381]         {
[13:34:35.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.381]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.381]             }
[13:34:35.381]             base::options(...future.oldOptions)
[13:34:35.381]             if (.Platform$OS.type == "windows") {
[13:34:35.381]                 old_names <- names(...future.oldEnvVars)
[13:34:35.381]                 envs <- base::Sys.getenv()
[13:34:35.381]                 names <- names(envs)
[13:34:35.381]                 common <- intersect(names, old_names)
[13:34:35.381]                 added <- setdiff(names, old_names)
[13:34:35.381]                 removed <- setdiff(old_names, names)
[13:34:35.381]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.381]                   envs[common]]
[13:34:35.381]                 NAMES <- toupper(changed)
[13:34:35.381]                 args <- list()
[13:34:35.381]                 for (kk in seq_along(NAMES)) {
[13:34:35.381]                   name <- changed[[kk]]
[13:34:35.381]                   NAME <- NAMES[[kk]]
[13:34:35.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.381]                     next
[13:34:35.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.381]                 }
[13:34:35.381]                 NAMES <- toupper(added)
[13:34:35.381]                 for (kk in seq_along(NAMES)) {
[13:34:35.381]                   name <- added[[kk]]
[13:34:35.381]                   NAME <- NAMES[[kk]]
[13:34:35.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.381]                     next
[13:34:35.381]                   args[[name]] <- ""
[13:34:35.381]                 }
[13:34:35.381]                 NAMES <- toupper(removed)
[13:34:35.381]                 for (kk in seq_along(NAMES)) {
[13:34:35.381]                   name <- removed[[kk]]
[13:34:35.381]                   NAME <- NAMES[[kk]]
[13:34:35.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.381]                     next
[13:34:35.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.381]                 }
[13:34:35.381]                 if (length(args) > 0) 
[13:34:35.381]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.381]             }
[13:34:35.381]             else {
[13:34:35.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.381]             }
[13:34:35.381]             {
[13:34:35.381]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.381]                   0L) {
[13:34:35.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.381]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.381]                   base::options(opts)
[13:34:35.381]                 }
[13:34:35.381]                 {
[13:34:35.381]                   {
[13:34:35.381]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.381]                     NULL
[13:34:35.381]                   }
[13:34:35.381]                   options(future.plan = NULL)
[13:34:35.381]                   if (is.na(NA_character_)) 
[13:34:35.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.381]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.381]                     .init = FALSE)
[13:34:35.381]                 }
[13:34:35.381]             }
[13:34:35.381]         }
[13:34:35.381]     })
[13:34:35.381]     if (TRUE) {
[13:34:35.381]         base::sink(type = "output", split = FALSE)
[13:34:35.381]         if (TRUE) {
[13:34:35.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.381]         }
[13:34:35.381]         else {
[13:34:35.381]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.381]         }
[13:34:35.381]         base::close(...future.stdout)
[13:34:35.381]         ...future.stdout <- NULL
[13:34:35.381]     }
[13:34:35.381]     ...future.result$conditions <- ...future.conditions
[13:34:35.381]     ...future.result$finished <- base::Sys.time()
[13:34:35.381]     ...future.result
[13:34:35.381] }
[13:34:35.384] assign_globals() ...
[13:34:35.384] List of 5
[13:34:35.384]  $ ...future.FUN            :function (x, y)  
[13:34:35.384]  $ MoreArgs                 : list()
[13:34:35.384]  $ ...future.elements_ii    :List of 2
[13:34:35.384]   ..$ :List of 2
[13:34:35.384]   .. ..$ b: num 2
[13:34:35.384]   .. ..$ c: num 3
[13:34:35.384]   ..$ :List of 2
[13:34:35.384]   .. ..$ B: num 0
[13:34:35.384]   .. ..$ C: num -10
[13:34:35.384]  $ ...future.seeds_ii       : NULL
[13:34:35.384]  $ ...future.globals.maxSize: NULL
[13:34:35.384]  - attr(*, "where")=List of 5
[13:34:35.384]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.384]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.384]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.384]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.384]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.384]  - attr(*, "resolved")= logi FALSE
[13:34:35.384]  - attr(*, "total_size")= num 2200
[13:34:35.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.384]  - attr(*, "already-done")= logi TRUE
[13:34:35.398] - reassign environment for ‘...future.FUN’
[13:34:35.398] - copied ‘...future.FUN’ to environment
[13:34:35.398] - copied ‘MoreArgs’ to environment
[13:34:35.398] - copied ‘...future.elements_ii’ to environment
[13:34:35.399] - copied ‘...future.seeds_ii’ to environment
[13:34:35.399] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.399] assign_globals() ... done
[13:34:35.399] requestCore(): workers = 2
[13:34:35.401] MulticoreFuture started
[13:34:35.402] - Launch lazy future ... done
[13:34:35.402] run() for ‘MulticoreFuture’ ... done
[13:34:35.403] Created future:
[13:34:35.403] plan(): Setting new future strategy stack:
[13:34:35.403] List of future strategies:
[13:34:35.403] 1. sequential:
[13:34:35.403]    - args: function (..., envir = parent.frame())
[13:34:35.403]    - tweaked: FALSE
[13:34:35.403]    - call: NULL
[13:34:35.404] plan(): nbrOfWorkers() = 1
[13:34:35.406] plan(): Setting new future strategy stack:
[13:34:35.407] List of future strategies:
[13:34:35.407] 1. multicore:
[13:34:35.407]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.407]    - tweaked: FALSE
[13:34:35.407]    - call: plan(strategy)
[13:34:35.413] plan(): nbrOfWorkers() = 2
[13:34:35.403] MulticoreFuture:
[13:34:35.403] Label: ‘future_.mapply-2’
[13:34:35.403] Expression:
[13:34:35.403] {
[13:34:35.403]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.403]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.403]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.403]         on.exit(options(oopts), add = TRUE)
[13:34:35.403]     }
[13:34:35.403]     {
[13:34:35.403]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.403]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.403]         do.call(mapply, args = args)
[13:34:35.403]     }
[13:34:35.403] }
[13:34:35.403] Lazy evaluation: FALSE
[13:34:35.403] Asynchronous evaluation: TRUE
[13:34:35.403] Local evaluation: TRUE
[13:34:35.403] Environment: R_GlobalEnv
[13:34:35.403] Capture standard output: TRUE
[13:34:35.403] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.403] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.403] Packages: <none>
[13:34:35.403] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.403] Resolved: TRUE
[13:34:35.403] Value: <not collected>
[13:34:35.403] Conditions captured: <none>
[13:34:35.403] Early signaling: FALSE
[13:34:35.403] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.403] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.414] Chunk #2 of 2 ... DONE
[13:34:35.414] Launching 2 futures (chunks) ... DONE
[13:34:35.415] Resolving 2 futures (chunks) ...
[13:34:35.415] resolve() on list ...
[13:34:35.415]  recursive: 0
[13:34:35.415]  length: 2
[13:34:35.415] 
[13:34:35.416] Future #1
[13:34:35.416] result() for MulticoreFuture ...
[13:34:35.417] result() for MulticoreFuture ...
[13:34:35.417] result() for MulticoreFuture ... done
[13:34:35.417] result() for MulticoreFuture ... done
[13:34:35.417] result() for MulticoreFuture ...
[13:34:35.418] result() for MulticoreFuture ... done
[13:34:35.418] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:35.418] - nx: 2
[13:34:35.418] - relay: TRUE
[13:34:35.418] - stdout: TRUE
[13:34:35.418] - signal: TRUE
[13:34:35.419] - resignal: FALSE
[13:34:35.419] - force: TRUE
[13:34:35.419] - relayed: [n=2] FALSE, FALSE
[13:34:35.419] - queued futures: [n=2] FALSE, FALSE
[13:34:35.419]  - until=1
[13:34:35.419]  - relaying element #1
[13:34:35.420] result() for MulticoreFuture ...
[13:34:35.420] result() for MulticoreFuture ... done
[13:34:35.420] result() for MulticoreFuture ...
[13:34:35.420] result() for MulticoreFuture ... done
[13:34:35.420] result() for MulticoreFuture ...
[13:34:35.420] result() for MulticoreFuture ... done
[13:34:35.420] result() for MulticoreFuture ...
[13:34:35.421] result() for MulticoreFuture ... done
[13:34:35.421] - relayed: [n=2] TRUE, FALSE
[13:34:35.421] - queued futures: [n=2] TRUE, FALSE
[13:34:35.421] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:35.421]  length: 1 (resolved future 1)
[13:34:35.422] Future #2
[13:34:35.422] result() for MulticoreFuture ...
[13:34:35.422] result() for MulticoreFuture ...
[13:34:35.423] result() for MulticoreFuture ... done
[13:34:35.423] result() for MulticoreFuture ... done
[13:34:35.423] result() for MulticoreFuture ...
[13:34:35.423] result() for MulticoreFuture ... done
[13:34:35.423] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:35.423] - nx: 2
[13:34:35.423] - relay: TRUE
[13:34:35.424] - stdout: TRUE
[13:34:35.424] - signal: TRUE
[13:34:35.424] - resignal: FALSE
[13:34:35.424] - force: TRUE
[13:34:35.424] - relayed: [n=2] TRUE, FALSE
[13:34:35.424] - queued futures: [n=2] TRUE, FALSE
[13:34:35.424]  - until=2
[13:34:35.424]  - relaying element #2
[13:34:35.425] result() for MulticoreFuture ...
[13:34:35.425] result() for MulticoreFuture ... done
[13:34:35.425] result() for MulticoreFuture ...
[13:34:35.425] result() for MulticoreFuture ... done
[13:34:35.425] result() for MulticoreFuture ...
[13:34:35.425] result() for MulticoreFuture ... done
[13:34:35.425] result() for MulticoreFuture ...
[13:34:35.425] result() for MulticoreFuture ... done
[13:34:35.426] - relayed: [n=2] TRUE, TRUE
[13:34:35.426] - queued futures: [n=2] TRUE, TRUE
[13:34:35.426] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:35.426]  length: 0 (resolved future 2)
[13:34:35.426] Relaying remaining futures
[13:34:35.426] signalConditionsASAP(NULL, pos=0) ...
[13:34:35.426] - nx: 2
[13:34:35.426] - relay: TRUE
[13:34:35.427] - stdout: TRUE
[13:34:35.427] - signal: TRUE
[13:34:35.427] - resignal: FALSE
[13:34:35.427] - force: TRUE
[13:34:35.427] - relayed: [n=2] TRUE, TRUE
[13:34:35.427] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:35.427] - relayed: [n=2] TRUE, TRUE
[13:34:35.427] - queued futures: [n=2] TRUE, TRUE
[13:34:35.427] signalConditionsASAP(NULL, pos=0) ... done
[13:34:35.428] resolve() on list ... DONE
[13:34:35.428] result() for MulticoreFuture ...
[13:34:35.428] result() for MulticoreFuture ... done
[13:34:35.428] result() for MulticoreFuture ...
[13:34:35.428] result() for MulticoreFuture ... done
[13:34:35.428] result() for MulticoreFuture ...
[13:34:35.428] result() for MulticoreFuture ... done
[13:34:35.428] result() for MulticoreFuture ...
[13:34:35.428] result() for MulticoreFuture ... done
[13:34:35.429]  - Number of value chunks collected: 2
[13:34:35.429] Resolving 2 futures (chunks) ... DONE
[13:34:35.429] Reducing values from 2 chunks ...
[13:34:35.429]  - Number of values collected after concatenation: 3
[13:34:35.429]  - Number of values expected: 3
[13:34:35.429] Reducing values from 2 chunks ... DONE
[13:34:35.429] future_mapply() ... DONE
[13:34:35.430] future_mapply() ...
[13:34:35.434] Number of chunks: 5
[13:34:35.434] getGlobalsAndPackagesXApply() ...
[13:34:35.434]  - future.globals: TRUE
[13:34:35.434] getGlobalsAndPackages() ...
[13:34:35.434] Searching for globals...
[13:34:35.442] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:35.442] Searching for globals ... DONE
[13:34:35.442] Resolving globals: FALSE
[13:34:35.442] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:35.443] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:35.443] - globals: [1] ‘FUN’
[13:34:35.443] 
[13:34:35.443] getGlobalsAndPackages() ... DONE
[13:34:35.444]  - globals found/used: [n=1] ‘FUN’
[13:34:35.444]  - needed namespaces: [n=0] 
[13:34:35.444] Finding globals ... DONE
[13:34:35.444] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:35.444] List of 2
[13:34:35.444]  $ ...future.FUN:function (C, k)  
[13:34:35.444]  $ MoreArgs     : NULL
[13:34:35.444]  - attr(*, "where")=List of 2
[13:34:35.444]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:35.444]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:35.444]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.444]  - attr(*, "resolved")= logi FALSE
[13:34:35.444]  - attr(*, "total_size")= num NA
[13:34:35.448] Packages to be attached in all futures: [n=0] 
[13:34:35.448] getGlobalsAndPackagesXApply() ... DONE
[13:34:35.448] Number of futures (= number of chunks): 5
[13:34:35.448] Launching 5 futures (chunks) ...
[13:34:35.448] Chunk #1 of 5 ...
[13:34:35.448]  - Finding globals in '...' for chunk #1 ...
[13:34:35.448] getGlobalsAndPackages() ...
[13:34:35.448] Searching for globals...
[13:34:35.449] 
[13:34:35.449] Searching for globals ... DONE
[13:34:35.449] - globals: [0] <none>
[13:34:35.449] getGlobalsAndPackages() ... DONE
[13:34:35.449]    + additional globals found: [n=0] 
[13:34:35.449]    + additional namespaces needed: [n=0] 
[13:34:35.449]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:35.450]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:35.450]  - seeds: <none>
[13:34:35.450]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.450] getGlobalsAndPackages() ...
[13:34:35.450] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.450] Resolving globals: FALSE
[13:34:35.451] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:35.451] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:35.451] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.451] 
[13:34:35.451] getGlobalsAndPackages() ... DONE
[13:34:35.452] run() for ‘Future’ ...
[13:34:35.452] - state: ‘created’
[13:34:35.452] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.456] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.456] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.456]   - Field: ‘label’
[13:34:35.456]   - Field: ‘local’
[13:34:35.457]   - Field: ‘owner’
[13:34:35.457]   - Field: ‘envir’
[13:34:35.457]   - Field: ‘workers’
[13:34:35.457]   - Field: ‘packages’
[13:34:35.457]   - Field: ‘gc’
[13:34:35.457]   - Field: ‘job’
[13:34:35.457]   - Field: ‘conditions’
[13:34:35.457]   - Field: ‘expr’
[13:34:35.457]   - Field: ‘uuid’
[13:34:35.458]   - Field: ‘seed’
[13:34:35.458]   - Field: ‘version’
[13:34:35.458]   - Field: ‘result’
[13:34:35.458]   - Field: ‘asynchronous’
[13:34:35.458]   - Field: ‘calls’
[13:34:35.458]   - Field: ‘globals’
[13:34:35.458]   - Field: ‘stdout’
[13:34:35.458]   - Field: ‘earlySignal’
[13:34:35.458]   - Field: ‘lazy’
[13:34:35.458]   - Field: ‘state’
[13:34:35.459] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.459] - Launch lazy future ...
[13:34:35.459] Packages needed by the future expression (n = 0): <none>
[13:34:35.459] Packages needed by future strategies (n = 0): <none>
[13:34:35.460] {
[13:34:35.460]     {
[13:34:35.460]         {
[13:34:35.460]             ...future.startTime <- base::Sys.time()
[13:34:35.460]             {
[13:34:35.460]                 {
[13:34:35.460]                   {
[13:34:35.460]                     {
[13:34:35.460]                       base::local({
[13:34:35.460]                         has_future <- base::requireNamespace("future", 
[13:34:35.460]                           quietly = TRUE)
[13:34:35.460]                         if (has_future) {
[13:34:35.460]                           ns <- base::getNamespace("future")
[13:34:35.460]                           version <- ns[[".package"]][["version"]]
[13:34:35.460]                           if (is.null(version)) 
[13:34:35.460]                             version <- utils::packageVersion("future")
[13:34:35.460]                         }
[13:34:35.460]                         else {
[13:34:35.460]                           version <- NULL
[13:34:35.460]                         }
[13:34:35.460]                         if (!has_future || version < "1.8.0") {
[13:34:35.460]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.460]                             "", base::R.version$version.string), 
[13:34:35.460]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.460]                               "release", "version")], collapse = " "), 
[13:34:35.460]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.460]                             info)
[13:34:35.460]                           info <- base::paste(info, collapse = "; ")
[13:34:35.460]                           if (!has_future) {
[13:34:35.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.460]                               info)
[13:34:35.460]                           }
[13:34:35.460]                           else {
[13:34:35.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.460]                               info, version)
[13:34:35.460]                           }
[13:34:35.460]                           base::stop(msg)
[13:34:35.460]                         }
[13:34:35.460]                       })
[13:34:35.460]                     }
[13:34:35.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.460]                     base::options(mc.cores = 1L)
[13:34:35.460]                   }
[13:34:35.460]                   ...future.strategy.old <- future::plan("list")
[13:34:35.460]                   options(future.plan = NULL)
[13:34:35.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.460]                 }
[13:34:35.460]                 ...future.workdir <- getwd()
[13:34:35.460]             }
[13:34:35.460]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.460]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.460]         }
[13:34:35.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.460]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:35.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.460]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.460]             base::names(...future.oldOptions))
[13:34:35.460]     }
[13:34:35.460]     if (FALSE) {
[13:34:35.460]     }
[13:34:35.460]     else {
[13:34:35.460]         if (TRUE) {
[13:34:35.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.460]                 open = "w")
[13:34:35.460]         }
[13:34:35.460]         else {
[13:34:35.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.460]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.460]         }
[13:34:35.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.460]             base::sink(type = "output", split = FALSE)
[13:34:35.460]             base::close(...future.stdout)
[13:34:35.460]         }, add = TRUE)
[13:34:35.460]     }
[13:34:35.460]     ...future.frame <- base::sys.nframe()
[13:34:35.460]     ...future.conditions <- base::list()
[13:34:35.460]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.460]     if (FALSE) {
[13:34:35.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.460]     }
[13:34:35.460]     ...future.result <- base::tryCatch({
[13:34:35.460]         base::withCallingHandlers({
[13:34:35.460]             ...future.value <- base::withVisible(base::local({
[13:34:35.460]                 withCallingHandlers({
[13:34:35.460]                   {
[13:34:35.460]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.460]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.460]                       ...future.globals.maxSize)) {
[13:34:35.460]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.460]                       on.exit(options(oopts), add = TRUE)
[13:34:35.460]                     }
[13:34:35.460]                     {
[13:34:35.460]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.460]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.460]                         USE.NAMES = FALSE)
[13:34:35.460]                       do.call(mapply, args = args)
[13:34:35.460]                     }
[13:34:35.460]                   }
[13:34:35.460]                 }, immediateCondition = function(cond) {
[13:34:35.460]                   save_rds <- function (object, pathname, ...) 
[13:34:35.460]                   {
[13:34:35.460]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.460]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.460]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.460]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.460]                         fi_tmp[["mtime"]])
[13:34:35.460]                     }
[13:34:35.460]                     tryCatch({
[13:34:35.460]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.460]                     }, error = function(ex) {
[13:34:35.460]                       msg <- conditionMessage(ex)
[13:34:35.460]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.460]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.460]                         fi_tmp[["mtime"]], msg)
[13:34:35.460]                       ex$message <- msg
[13:34:35.460]                       stop(ex)
[13:34:35.460]                     })
[13:34:35.460]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.460]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.460]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.460]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.460]                       fi <- file.info(pathname)
[13:34:35.460]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.460]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.460]                         fi[["size"]], fi[["mtime"]])
[13:34:35.460]                       stop(msg)
[13:34:35.460]                     }
[13:34:35.460]                     invisible(pathname)
[13:34:35.460]                   }
[13:34:35.460]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.460]                     rootPath = tempdir()) 
[13:34:35.460]                   {
[13:34:35.460]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.460]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.460]                       tmpdir = path, fileext = ".rds")
[13:34:35.460]                     save_rds(obj, file)
[13:34:35.460]                   }
[13:34:35.460]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.460]                   {
[13:34:35.460]                     inherits <- base::inherits
[13:34:35.460]                     invokeRestart <- base::invokeRestart
[13:34:35.460]                     is.null <- base::is.null
[13:34:35.460]                     muffled <- FALSE
[13:34:35.460]                     if (inherits(cond, "message")) {
[13:34:35.460]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.460]                       if (muffled) 
[13:34:35.460]                         invokeRestart("muffleMessage")
[13:34:35.460]                     }
[13:34:35.460]                     else if (inherits(cond, "warning")) {
[13:34:35.460]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.460]                       if (muffled) 
[13:34:35.460]                         invokeRestart("muffleWarning")
[13:34:35.460]                     }
[13:34:35.460]                     else if (inherits(cond, "condition")) {
[13:34:35.460]                       if (!is.null(pattern)) {
[13:34:35.460]                         computeRestarts <- base::computeRestarts
[13:34:35.460]                         grepl <- base::grepl
[13:34:35.460]                         restarts <- computeRestarts(cond)
[13:34:35.460]                         for (restart in restarts) {
[13:34:35.460]                           name <- restart$name
[13:34:35.460]                           if (is.null(name)) 
[13:34:35.460]                             next
[13:34:35.460]                           if (!grepl(pattern, name)) 
[13:34:35.460]                             next
[13:34:35.460]                           invokeRestart(restart)
[13:34:35.460]                           muffled <- TRUE
[13:34:35.460]                           break
[13:34:35.460]                         }
[13:34:35.460]                       }
[13:34:35.460]                     }
[13:34:35.460]                     invisible(muffled)
[13:34:35.460]                   }
[13:34:35.460]                   muffleCondition(cond)
[13:34:35.460]                 })
[13:34:35.460]             }))
[13:34:35.460]             future::FutureResult(value = ...future.value$value, 
[13:34:35.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.460]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.460]                     ...future.globalenv.names))
[13:34:35.460]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.460]         }, condition = base::local({
[13:34:35.460]             c <- base::c
[13:34:35.460]             inherits <- base::inherits
[13:34:35.460]             invokeRestart <- base::invokeRestart
[13:34:35.460]             length <- base::length
[13:34:35.460]             list <- base::list
[13:34:35.460]             seq.int <- base::seq.int
[13:34:35.460]             signalCondition <- base::signalCondition
[13:34:35.460]             sys.calls <- base::sys.calls
[13:34:35.460]             `[[` <- base::`[[`
[13:34:35.460]             `+` <- base::`+`
[13:34:35.460]             `<<-` <- base::`<<-`
[13:34:35.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.460]                   3L)]
[13:34:35.460]             }
[13:34:35.460]             function(cond) {
[13:34:35.460]                 is_error <- inherits(cond, "error")
[13:34:35.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.460]                   NULL)
[13:34:35.460]                 if (is_error) {
[13:34:35.460]                   sessionInformation <- function() {
[13:34:35.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.460]                       search = base::search(), system = base::Sys.info())
[13:34:35.460]                   }
[13:34:35.460]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.460]                     cond$call), session = sessionInformation(), 
[13:34:35.460]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.460]                   signalCondition(cond)
[13:34:35.460]                 }
[13:34:35.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.460]                 "immediateCondition"))) {
[13:34:35.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.460]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.460]                   if (TRUE && !signal) {
[13:34:35.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.460]                     {
[13:34:35.460]                       inherits <- base::inherits
[13:34:35.460]                       invokeRestart <- base::invokeRestart
[13:34:35.460]                       is.null <- base::is.null
[13:34:35.460]                       muffled <- FALSE
[13:34:35.460]                       if (inherits(cond, "message")) {
[13:34:35.460]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.460]                         if (muffled) 
[13:34:35.460]                           invokeRestart("muffleMessage")
[13:34:35.460]                       }
[13:34:35.460]                       else if (inherits(cond, "warning")) {
[13:34:35.460]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.460]                         if (muffled) 
[13:34:35.460]                           invokeRestart("muffleWarning")
[13:34:35.460]                       }
[13:34:35.460]                       else if (inherits(cond, "condition")) {
[13:34:35.460]                         if (!is.null(pattern)) {
[13:34:35.460]                           computeRestarts <- base::computeRestarts
[13:34:35.460]                           grepl <- base::grepl
[13:34:35.460]                           restarts <- computeRestarts(cond)
[13:34:35.460]                           for (restart in restarts) {
[13:34:35.460]                             name <- restart$name
[13:34:35.460]                             if (is.null(name)) 
[13:34:35.460]                               next
[13:34:35.460]                             if (!grepl(pattern, name)) 
[13:34:35.460]                               next
[13:34:35.460]                             invokeRestart(restart)
[13:34:35.460]                             muffled <- TRUE
[13:34:35.460]                             break
[13:34:35.460]                           }
[13:34:35.460]                         }
[13:34:35.460]                       }
[13:34:35.460]                       invisible(muffled)
[13:34:35.460]                     }
[13:34:35.460]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.460]                   }
[13:34:35.460]                 }
[13:34:35.460]                 else {
[13:34:35.460]                   if (TRUE) {
[13:34:35.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.460]                     {
[13:34:35.460]                       inherits <- base::inherits
[13:34:35.460]                       invokeRestart <- base::invokeRestart
[13:34:35.460]                       is.null <- base::is.null
[13:34:35.460]                       muffled <- FALSE
[13:34:35.460]                       if (inherits(cond, "message")) {
[13:34:35.460]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.460]                         if (muffled) 
[13:34:35.460]                           invokeRestart("muffleMessage")
[13:34:35.460]                       }
[13:34:35.460]                       else if (inherits(cond, "warning")) {
[13:34:35.460]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.460]                         if (muffled) 
[13:34:35.460]                           invokeRestart("muffleWarning")
[13:34:35.460]                       }
[13:34:35.460]                       else if (inherits(cond, "condition")) {
[13:34:35.460]                         if (!is.null(pattern)) {
[13:34:35.460]                           computeRestarts <- base::computeRestarts
[13:34:35.460]                           grepl <- base::grepl
[13:34:35.460]                           restarts <- computeRestarts(cond)
[13:34:35.460]                           for (restart in restarts) {
[13:34:35.460]                             name <- restart$name
[13:34:35.460]                             if (is.null(name)) 
[13:34:35.460]                               next
[13:34:35.460]                             if (!grepl(pattern, name)) 
[13:34:35.460]                               next
[13:34:35.460]                             invokeRestart(restart)
[13:34:35.460]                             muffled <- TRUE
[13:34:35.460]                             break
[13:34:35.460]                           }
[13:34:35.460]                         }
[13:34:35.460]                       }
[13:34:35.460]                       invisible(muffled)
[13:34:35.460]                     }
[13:34:35.460]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.460]                   }
[13:34:35.460]                 }
[13:34:35.460]             }
[13:34:35.460]         }))
[13:34:35.460]     }, error = function(ex) {
[13:34:35.460]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.460]                 ...future.rng), started = ...future.startTime, 
[13:34:35.460]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.460]             version = "1.8"), class = "FutureResult")
[13:34:35.460]     }, finally = {
[13:34:35.460]         if (!identical(...future.workdir, getwd())) 
[13:34:35.460]             setwd(...future.workdir)
[13:34:35.460]         {
[13:34:35.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.460]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.460]             }
[13:34:35.460]             base::options(...future.oldOptions)
[13:34:35.460]             if (.Platform$OS.type == "windows") {
[13:34:35.460]                 old_names <- names(...future.oldEnvVars)
[13:34:35.460]                 envs <- base::Sys.getenv()
[13:34:35.460]                 names <- names(envs)
[13:34:35.460]                 common <- intersect(names, old_names)
[13:34:35.460]                 added <- setdiff(names, old_names)
[13:34:35.460]                 removed <- setdiff(old_names, names)
[13:34:35.460]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.460]                   envs[common]]
[13:34:35.460]                 NAMES <- toupper(changed)
[13:34:35.460]                 args <- list()
[13:34:35.460]                 for (kk in seq_along(NAMES)) {
[13:34:35.460]                   name <- changed[[kk]]
[13:34:35.460]                   NAME <- NAMES[[kk]]
[13:34:35.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.460]                     next
[13:34:35.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.460]                 }
[13:34:35.460]                 NAMES <- toupper(added)
[13:34:35.460]                 for (kk in seq_along(NAMES)) {
[13:34:35.460]                   name <- added[[kk]]
[13:34:35.460]                   NAME <- NAMES[[kk]]
[13:34:35.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.460]                     next
[13:34:35.460]                   args[[name]] <- ""
[13:34:35.460]                 }
[13:34:35.460]                 NAMES <- toupper(removed)
[13:34:35.460]                 for (kk in seq_along(NAMES)) {
[13:34:35.460]                   name <- removed[[kk]]
[13:34:35.460]                   NAME <- NAMES[[kk]]
[13:34:35.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.460]                     next
[13:34:35.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.460]                 }
[13:34:35.460]                 if (length(args) > 0) 
[13:34:35.460]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.460]             }
[13:34:35.460]             else {
[13:34:35.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.460]             }
[13:34:35.460]             {
[13:34:35.460]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.460]                   0L) {
[13:34:35.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.460]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.460]                   base::options(opts)
[13:34:35.460]                 }
[13:34:35.460]                 {
[13:34:35.460]                   {
[13:34:35.460]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.460]                     NULL
[13:34:35.460]                   }
[13:34:35.460]                   options(future.plan = NULL)
[13:34:35.460]                   if (is.na(NA_character_)) 
[13:34:35.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.460]                     .init = FALSE)
[13:34:35.460]                 }
[13:34:35.460]             }
[13:34:35.460]         }
[13:34:35.460]     })
[13:34:35.460]     if (TRUE) {
[13:34:35.460]         base::sink(type = "output", split = FALSE)
[13:34:35.460]         if (TRUE) {
[13:34:35.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.460]         }
[13:34:35.460]         else {
[13:34:35.460]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.460]         }
[13:34:35.460]         base::close(...future.stdout)
[13:34:35.460]         ...future.stdout <- NULL
[13:34:35.460]     }
[13:34:35.460]     ...future.result$conditions <- ...future.conditions
[13:34:35.460]     ...future.result$finished <- base::Sys.time()
[13:34:35.460]     ...future.result
[13:34:35.460] }
[13:34:35.462] assign_globals() ...
[13:34:35.462] List of 5
[13:34:35.462]  $ ...future.FUN            :function (C, k)  
[13:34:35.462]  $ MoreArgs                 : NULL
[13:34:35.462]  $ ...future.elements_ii    :List of 2
[13:34:35.462]   ..$ :List of 1
[13:34:35.462]   .. ..$ : chr "A"
[13:34:35.462]   ..$ :List of 1
[13:34:35.462]   .. ..$ : int 5
[13:34:35.462]  $ ...future.seeds_ii       : NULL
[13:34:35.462]  $ ...future.globals.maxSize: NULL
[13:34:35.462]  - attr(*, "where")=List of 5
[13:34:35.462]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.462]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.462]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.462]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.462]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.462]  - attr(*, "resolved")= logi FALSE
[13:34:35.462]  - attr(*, "total_size")= num 3488
[13:34:35.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.462]  - attr(*, "already-done")= logi TRUE
[13:34:35.469] - reassign environment for ‘...future.FUN’
[13:34:35.469] - copied ‘...future.FUN’ to environment
[13:34:35.470] - copied ‘MoreArgs’ to environment
[13:34:35.470] - copied ‘...future.elements_ii’ to environment
[13:34:35.470] - copied ‘...future.seeds_ii’ to environment
[13:34:35.470] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.470] assign_globals() ... done
[13:34:35.470] requestCore(): workers = 2
[13:34:35.473] MulticoreFuture started
[13:34:35.473] - Launch lazy future ... done
[13:34:35.474] plan(): Setting new future strategy stack:
[13:34:35.474] run() for ‘MulticoreFuture’ ... done
[13:34:35.475] Created future:
[13:34:35.474] List of future strategies:
[13:34:35.474] 1. sequential:
[13:34:35.474]    - args: function (..., envir = parent.frame())
[13:34:35.474]    - tweaked: FALSE
[13:34:35.474]    - call: NULL
[13:34:35.476] plan(): nbrOfWorkers() = 1
[13:34:35.479] plan(): Setting new future strategy stack:
[13:34:35.479] List of future strategies:
[13:34:35.479] 1. multicore:
[13:34:35.479]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.479]    - tweaked: FALSE
[13:34:35.479]    - call: plan(strategy)
[13:34:35.486] plan(): nbrOfWorkers() = 2
[13:34:35.475] MulticoreFuture:
[13:34:35.475] Label: ‘future_mapply-1’
[13:34:35.475] Expression:
[13:34:35.475] {
[13:34:35.475]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.475]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.475]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.475]         on.exit(options(oopts), add = TRUE)
[13:34:35.475]     }
[13:34:35.475]     {
[13:34:35.475]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.475]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.475]         do.call(mapply, args = args)
[13:34:35.475]     }
[13:34:35.475] }
[13:34:35.475] Lazy evaluation: FALSE
[13:34:35.475] Asynchronous evaluation: TRUE
[13:34:35.475] Local evaluation: TRUE
[13:34:35.475] Environment: R_GlobalEnv
[13:34:35.475] Capture standard output: TRUE
[13:34:35.475] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.475] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.475] Packages: <none>
[13:34:35.475] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.475] Resolved: TRUE
[13:34:35.475] Value: <not collected>
[13:34:35.475] Conditions captured: <none>
[13:34:35.475] Early signaling: FALSE
[13:34:35.475] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.475] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.487] Chunk #1 of 5 ... DONE
[13:34:35.488] Chunk #2 of 5 ...
[13:34:35.488]  - Finding globals in '...' for chunk #2 ...
[13:34:35.488] getGlobalsAndPackages() ...
[13:34:35.489] Searching for globals...
[13:34:35.489] 
[13:34:35.490] Searching for globals ... DONE
[13:34:35.490] - globals: [0] <none>
[13:34:35.490] getGlobalsAndPackages() ... DONE
[13:34:35.490]    + additional globals found: [n=0] 
[13:34:35.490]    + additional namespaces needed: [n=0] 
[13:34:35.491]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:35.491]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:35.491]  - seeds: <none>
[13:34:35.491]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.492] getGlobalsAndPackages() ...
[13:34:35.492] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.492] Resolving globals: FALSE
[13:34:35.493] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:35.494] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:35.494] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.494] 
[13:34:35.495] getGlobalsAndPackages() ... DONE
[13:34:35.495] run() for ‘Future’ ...
[13:34:35.495] - state: ‘created’
[13:34:35.495] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.500] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.501] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.501]   - Field: ‘label’
[13:34:35.501]   - Field: ‘local’
[13:34:35.501]   - Field: ‘owner’
[13:34:35.501]   - Field: ‘envir’
[13:34:35.501]   - Field: ‘workers’
[13:34:35.502]   - Field: ‘packages’
[13:34:35.502]   - Field: ‘gc’
[13:34:35.502]   - Field: ‘job’
[13:34:35.502]   - Field: ‘conditions’
[13:34:35.502]   - Field: ‘expr’
[13:34:35.503]   - Field: ‘uuid’
[13:34:35.503]   - Field: ‘seed’
[13:34:35.503]   - Field: ‘version’
[13:34:35.503]   - Field: ‘result’
[13:34:35.503]   - Field: ‘asynchronous’
[13:34:35.503]   - Field: ‘calls’
[13:34:35.503]   - Field: ‘globals’
[13:34:35.504]   - Field: ‘stdout’
[13:34:35.504]   - Field: ‘earlySignal’
[13:34:35.504]   - Field: ‘lazy’
[13:34:35.504]   - Field: ‘state’
[13:34:35.504] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.504] - Launch lazy future ...
[13:34:35.505] Packages needed by the future expression (n = 0): <none>
[13:34:35.505] Packages needed by future strategies (n = 0): <none>
[13:34:35.505] {
[13:34:35.505]     {
[13:34:35.505]         {
[13:34:35.505]             ...future.startTime <- base::Sys.time()
[13:34:35.505]             {
[13:34:35.505]                 {
[13:34:35.505]                   {
[13:34:35.505]                     {
[13:34:35.505]                       base::local({
[13:34:35.505]                         has_future <- base::requireNamespace("future", 
[13:34:35.505]                           quietly = TRUE)
[13:34:35.505]                         if (has_future) {
[13:34:35.505]                           ns <- base::getNamespace("future")
[13:34:35.505]                           version <- ns[[".package"]][["version"]]
[13:34:35.505]                           if (is.null(version)) 
[13:34:35.505]                             version <- utils::packageVersion("future")
[13:34:35.505]                         }
[13:34:35.505]                         else {
[13:34:35.505]                           version <- NULL
[13:34:35.505]                         }
[13:34:35.505]                         if (!has_future || version < "1.8.0") {
[13:34:35.505]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.505]                             "", base::R.version$version.string), 
[13:34:35.505]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.505]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.505]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.505]                               "release", "version")], collapse = " "), 
[13:34:35.505]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.505]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.505]                             info)
[13:34:35.505]                           info <- base::paste(info, collapse = "; ")
[13:34:35.505]                           if (!has_future) {
[13:34:35.505]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.505]                               info)
[13:34:35.505]                           }
[13:34:35.505]                           else {
[13:34:35.505]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.505]                               info, version)
[13:34:35.505]                           }
[13:34:35.505]                           base::stop(msg)
[13:34:35.505]                         }
[13:34:35.505]                       })
[13:34:35.505]                     }
[13:34:35.505]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.505]                     base::options(mc.cores = 1L)
[13:34:35.505]                   }
[13:34:35.505]                   ...future.strategy.old <- future::plan("list")
[13:34:35.505]                   options(future.plan = NULL)
[13:34:35.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.505]                 }
[13:34:35.505]                 ...future.workdir <- getwd()
[13:34:35.505]             }
[13:34:35.505]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.505]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.505]         }
[13:34:35.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.505]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:35.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.505]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.505]             base::names(...future.oldOptions))
[13:34:35.505]     }
[13:34:35.505]     if (FALSE) {
[13:34:35.505]     }
[13:34:35.505]     else {
[13:34:35.505]         if (TRUE) {
[13:34:35.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.505]                 open = "w")
[13:34:35.505]         }
[13:34:35.505]         else {
[13:34:35.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.505]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.505]         }
[13:34:35.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.505]             base::sink(type = "output", split = FALSE)
[13:34:35.505]             base::close(...future.stdout)
[13:34:35.505]         }, add = TRUE)
[13:34:35.505]     }
[13:34:35.505]     ...future.frame <- base::sys.nframe()
[13:34:35.505]     ...future.conditions <- base::list()
[13:34:35.505]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.505]     if (FALSE) {
[13:34:35.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.505]     }
[13:34:35.505]     ...future.result <- base::tryCatch({
[13:34:35.505]         base::withCallingHandlers({
[13:34:35.505]             ...future.value <- base::withVisible(base::local({
[13:34:35.505]                 withCallingHandlers({
[13:34:35.505]                   {
[13:34:35.505]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.505]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.505]                       ...future.globals.maxSize)) {
[13:34:35.505]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.505]                       on.exit(options(oopts), add = TRUE)
[13:34:35.505]                     }
[13:34:35.505]                     {
[13:34:35.505]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.505]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.505]                         USE.NAMES = FALSE)
[13:34:35.505]                       do.call(mapply, args = args)
[13:34:35.505]                     }
[13:34:35.505]                   }
[13:34:35.505]                 }, immediateCondition = function(cond) {
[13:34:35.505]                   save_rds <- function (object, pathname, ...) 
[13:34:35.505]                   {
[13:34:35.505]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.505]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.505]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.505]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.505]                         fi_tmp[["mtime"]])
[13:34:35.505]                     }
[13:34:35.505]                     tryCatch({
[13:34:35.505]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.505]                     }, error = function(ex) {
[13:34:35.505]                       msg <- conditionMessage(ex)
[13:34:35.505]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.505]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.505]                         fi_tmp[["mtime"]], msg)
[13:34:35.505]                       ex$message <- msg
[13:34:35.505]                       stop(ex)
[13:34:35.505]                     })
[13:34:35.505]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.505]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.505]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.505]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.505]                       fi <- file.info(pathname)
[13:34:35.505]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.505]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.505]                         fi[["size"]], fi[["mtime"]])
[13:34:35.505]                       stop(msg)
[13:34:35.505]                     }
[13:34:35.505]                     invisible(pathname)
[13:34:35.505]                   }
[13:34:35.505]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.505]                     rootPath = tempdir()) 
[13:34:35.505]                   {
[13:34:35.505]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.505]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.505]                       tmpdir = path, fileext = ".rds")
[13:34:35.505]                     save_rds(obj, file)
[13:34:35.505]                   }
[13:34:35.505]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.505]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.505]                   {
[13:34:35.505]                     inherits <- base::inherits
[13:34:35.505]                     invokeRestart <- base::invokeRestart
[13:34:35.505]                     is.null <- base::is.null
[13:34:35.505]                     muffled <- FALSE
[13:34:35.505]                     if (inherits(cond, "message")) {
[13:34:35.505]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.505]                       if (muffled) 
[13:34:35.505]                         invokeRestart("muffleMessage")
[13:34:35.505]                     }
[13:34:35.505]                     else if (inherits(cond, "warning")) {
[13:34:35.505]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.505]                       if (muffled) 
[13:34:35.505]                         invokeRestart("muffleWarning")
[13:34:35.505]                     }
[13:34:35.505]                     else if (inherits(cond, "condition")) {
[13:34:35.505]                       if (!is.null(pattern)) {
[13:34:35.505]                         computeRestarts <- base::computeRestarts
[13:34:35.505]                         grepl <- base::grepl
[13:34:35.505]                         restarts <- computeRestarts(cond)
[13:34:35.505]                         for (restart in restarts) {
[13:34:35.505]                           name <- restart$name
[13:34:35.505]                           if (is.null(name)) 
[13:34:35.505]                             next
[13:34:35.505]                           if (!grepl(pattern, name)) 
[13:34:35.505]                             next
[13:34:35.505]                           invokeRestart(restart)
[13:34:35.505]                           muffled <- TRUE
[13:34:35.505]                           break
[13:34:35.505]                         }
[13:34:35.505]                       }
[13:34:35.505]                     }
[13:34:35.505]                     invisible(muffled)
[13:34:35.505]                   }
[13:34:35.505]                   muffleCondition(cond)
[13:34:35.505]                 })
[13:34:35.505]             }))
[13:34:35.505]             future::FutureResult(value = ...future.value$value, 
[13:34:35.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.505]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.505]                     ...future.globalenv.names))
[13:34:35.505]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.505]         }, condition = base::local({
[13:34:35.505]             c <- base::c
[13:34:35.505]             inherits <- base::inherits
[13:34:35.505]             invokeRestart <- base::invokeRestart
[13:34:35.505]             length <- base::length
[13:34:35.505]             list <- base::list
[13:34:35.505]             seq.int <- base::seq.int
[13:34:35.505]             signalCondition <- base::signalCondition
[13:34:35.505]             sys.calls <- base::sys.calls
[13:34:35.505]             `[[` <- base::`[[`
[13:34:35.505]             `+` <- base::`+`
[13:34:35.505]             `<<-` <- base::`<<-`
[13:34:35.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.505]                   3L)]
[13:34:35.505]             }
[13:34:35.505]             function(cond) {
[13:34:35.505]                 is_error <- inherits(cond, "error")
[13:34:35.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.505]                   NULL)
[13:34:35.505]                 if (is_error) {
[13:34:35.505]                   sessionInformation <- function() {
[13:34:35.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.505]                       search = base::search(), system = base::Sys.info())
[13:34:35.505]                   }
[13:34:35.505]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.505]                     cond$call), session = sessionInformation(), 
[13:34:35.505]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.505]                   signalCondition(cond)
[13:34:35.505]                 }
[13:34:35.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.505]                 "immediateCondition"))) {
[13:34:35.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.505]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.505]                   if (TRUE && !signal) {
[13:34:35.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.505]                     {
[13:34:35.505]                       inherits <- base::inherits
[13:34:35.505]                       invokeRestart <- base::invokeRestart
[13:34:35.505]                       is.null <- base::is.null
[13:34:35.505]                       muffled <- FALSE
[13:34:35.505]                       if (inherits(cond, "message")) {
[13:34:35.505]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.505]                         if (muffled) 
[13:34:35.505]                           invokeRestart("muffleMessage")
[13:34:35.505]                       }
[13:34:35.505]                       else if (inherits(cond, "warning")) {
[13:34:35.505]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.505]                         if (muffled) 
[13:34:35.505]                           invokeRestart("muffleWarning")
[13:34:35.505]                       }
[13:34:35.505]                       else if (inherits(cond, "condition")) {
[13:34:35.505]                         if (!is.null(pattern)) {
[13:34:35.505]                           computeRestarts <- base::computeRestarts
[13:34:35.505]                           grepl <- base::grepl
[13:34:35.505]                           restarts <- computeRestarts(cond)
[13:34:35.505]                           for (restart in restarts) {
[13:34:35.505]                             name <- restart$name
[13:34:35.505]                             if (is.null(name)) 
[13:34:35.505]                               next
[13:34:35.505]                             if (!grepl(pattern, name)) 
[13:34:35.505]                               next
[13:34:35.505]                             invokeRestart(restart)
[13:34:35.505]                             muffled <- TRUE
[13:34:35.505]                             break
[13:34:35.505]                           }
[13:34:35.505]                         }
[13:34:35.505]                       }
[13:34:35.505]                       invisible(muffled)
[13:34:35.505]                     }
[13:34:35.505]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.505]                   }
[13:34:35.505]                 }
[13:34:35.505]                 else {
[13:34:35.505]                   if (TRUE) {
[13:34:35.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.505]                     {
[13:34:35.505]                       inherits <- base::inherits
[13:34:35.505]                       invokeRestart <- base::invokeRestart
[13:34:35.505]                       is.null <- base::is.null
[13:34:35.505]                       muffled <- FALSE
[13:34:35.505]                       if (inherits(cond, "message")) {
[13:34:35.505]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.505]                         if (muffled) 
[13:34:35.505]                           invokeRestart("muffleMessage")
[13:34:35.505]                       }
[13:34:35.505]                       else if (inherits(cond, "warning")) {
[13:34:35.505]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.505]                         if (muffled) 
[13:34:35.505]                           invokeRestart("muffleWarning")
[13:34:35.505]                       }
[13:34:35.505]                       else if (inherits(cond, "condition")) {
[13:34:35.505]                         if (!is.null(pattern)) {
[13:34:35.505]                           computeRestarts <- base::computeRestarts
[13:34:35.505]                           grepl <- base::grepl
[13:34:35.505]                           restarts <- computeRestarts(cond)
[13:34:35.505]                           for (restart in restarts) {
[13:34:35.505]                             name <- restart$name
[13:34:35.505]                             if (is.null(name)) 
[13:34:35.505]                               next
[13:34:35.505]                             if (!grepl(pattern, name)) 
[13:34:35.505]                               next
[13:34:35.505]                             invokeRestart(restart)
[13:34:35.505]                             muffled <- TRUE
[13:34:35.505]                             break
[13:34:35.505]                           }
[13:34:35.505]                         }
[13:34:35.505]                       }
[13:34:35.505]                       invisible(muffled)
[13:34:35.505]                     }
[13:34:35.505]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.505]                   }
[13:34:35.505]                 }
[13:34:35.505]             }
[13:34:35.505]         }))
[13:34:35.505]     }, error = function(ex) {
[13:34:35.505]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.505]                 ...future.rng), started = ...future.startTime, 
[13:34:35.505]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.505]             version = "1.8"), class = "FutureResult")
[13:34:35.505]     }, finally = {
[13:34:35.505]         if (!identical(...future.workdir, getwd())) 
[13:34:35.505]             setwd(...future.workdir)
[13:34:35.505]         {
[13:34:35.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.505]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.505]             }
[13:34:35.505]             base::options(...future.oldOptions)
[13:34:35.505]             if (.Platform$OS.type == "windows") {
[13:34:35.505]                 old_names <- names(...future.oldEnvVars)
[13:34:35.505]                 envs <- base::Sys.getenv()
[13:34:35.505]                 names <- names(envs)
[13:34:35.505]                 common <- intersect(names, old_names)
[13:34:35.505]                 added <- setdiff(names, old_names)
[13:34:35.505]                 removed <- setdiff(old_names, names)
[13:34:35.505]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.505]                   envs[common]]
[13:34:35.505]                 NAMES <- toupper(changed)
[13:34:35.505]                 args <- list()
[13:34:35.505]                 for (kk in seq_along(NAMES)) {
[13:34:35.505]                   name <- changed[[kk]]
[13:34:35.505]                   NAME <- NAMES[[kk]]
[13:34:35.505]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.505]                     next
[13:34:35.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.505]                 }
[13:34:35.505]                 NAMES <- toupper(added)
[13:34:35.505]                 for (kk in seq_along(NAMES)) {
[13:34:35.505]                   name <- added[[kk]]
[13:34:35.505]                   NAME <- NAMES[[kk]]
[13:34:35.505]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.505]                     next
[13:34:35.505]                   args[[name]] <- ""
[13:34:35.505]                 }
[13:34:35.505]                 NAMES <- toupper(removed)
[13:34:35.505]                 for (kk in seq_along(NAMES)) {
[13:34:35.505]                   name <- removed[[kk]]
[13:34:35.505]                   NAME <- NAMES[[kk]]
[13:34:35.505]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.505]                     next
[13:34:35.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.505]                 }
[13:34:35.505]                 if (length(args) > 0) 
[13:34:35.505]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.505]             }
[13:34:35.505]             else {
[13:34:35.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.505]             }
[13:34:35.505]             {
[13:34:35.505]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.505]                   0L) {
[13:34:35.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.505]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.505]                   base::options(opts)
[13:34:35.505]                 }
[13:34:35.505]                 {
[13:34:35.505]                   {
[13:34:35.505]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.505]                     NULL
[13:34:35.505]                   }
[13:34:35.505]                   options(future.plan = NULL)
[13:34:35.505]                   if (is.na(NA_character_)) 
[13:34:35.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.505]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.505]                     .init = FALSE)
[13:34:35.505]                 }
[13:34:35.505]             }
[13:34:35.505]         }
[13:34:35.505]     })
[13:34:35.505]     if (TRUE) {
[13:34:35.505]         base::sink(type = "output", split = FALSE)
[13:34:35.505]         if (TRUE) {
[13:34:35.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.505]         }
[13:34:35.505]         else {
[13:34:35.505]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.505]         }
[13:34:35.505]         base::close(...future.stdout)
[13:34:35.505]         ...future.stdout <- NULL
[13:34:35.505]     }
[13:34:35.505]     ...future.result$conditions <- ...future.conditions
[13:34:35.505]     ...future.result$finished <- base::Sys.time()
[13:34:35.505]     ...future.result
[13:34:35.505] }
[13:34:35.509] assign_globals() ...
[13:34:35.509] List of 5
[13:34:35.509]  $ ...future.FUN            :function (C, k)  
[13:34:35.509]  $ MoreArgs                 : NULL
[13:34:35.509]  $ ...future.elements_ii    :List of 2
[13:34:35.509]   ..$ :List of 1
[13:34:35.509]   .. ..$ : chr "B"
[13:34:35.509]   ..$ :List of 1
[13:34:35.509]   .. ..$ : int 4
[13:34:35.509]  $ ...future.seeds_ii       : NULL
[13:34:35.509]  $ ...future.globals.maxSize: NULL
[13:34:35.509]  - attr(*, "where")=List of 5
[13:34:35.509]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.509]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.509]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.509]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.509]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.509]  - attr(*, "resolved")= logi FALSE
[13:34:35.509]  - attr(*, "total_size")= num 3488
[13:34:35.509]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.509]  - attr(*, "already-done")= logi TRUE
[13:34:35.515] - reassign environment for ‘...future.FUN’
[13:34:35.515] - copied ‘...future.FUN’ to environment
[13:34:35.516] - copied ‘MoreArgs’ to environment
[13:34:35.516] - copied ‘...future.elements_ii’ to environment
[13:34:35.516] - copied ‘...future.seeds_ii’ to environment
[13:34:35.516] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.516] assign_globals() ... done
[13:34:35.516] requestCore(): workers = 2
[13:34:35.518] MulticoreFuture started
[13:34:35.519] - Launch lazy future ... done
[13:34:35.519] run() for ‘MulticoreFuture’ ... done
[13:34:35.519] Created future:
[13:34:35.520] plan(): Setting new future strategy stack:
[13:34:35.520] List of future strategies:
[13:34:35.520] 1. sequential:
[13:34:35.520]    - args: function (..., envir = parent.frame())
[13:34:35.520]    - tweaked: FALSE
[13:34:35.520]    - call: NULL
[13:34:35.521] plan(): nbrOfWorkers() = 1
[13:34:35.523] plan(): Setting new future strategy stack:
[13:34:35.523] List of future strategies:
[13:34:35.523] 1. multicore:
[13:34:35.523]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.523]    - tweaked: FALSE
[13:34:35.523]    - call: plan(strategy)
[13:34:35.520] MulticoreFuture:
[13:34:35.520] Label: ‘future_mapply-2’
[13:34:35.520] Expression:
[13:34:35.520] {
[13:34:35.520]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.520]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.520]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.520]         on.exit(options(oopts), add = TRUE)
[13:34:35.520]     }
[13:34:35.520]     {
[13:34:35.520]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.520]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.520]         do.call(mapply, args = args)
[13:34:35.520]     }
[13:34:35.520] }
[13:34:35.520] Lazy evaluation: FALSE
[13:34:35.520] Asynchronous evaluation: TRUE
[13:34:35.520] Local evaluation: TRUE
[13:34:35.520] Environment: R_GlobalEnv
[13:34:35.520] Capture standard output: TRUE
[13:34:35.520] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.520] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.520] Packages: <none>
[13:34:35.520] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.520] Resolved: FALSE
[13:34:35.520] Value: <not collected>
[13:34:35.520] Conditions captured: <none>
[13:34:35.520] Early signaling: FALSE
[13:34:35.520] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.520] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.532] Chunk #2 of 5 ... DONE
[13:34:35.532] Chunk #3 of 5 ...
[13:34:35.532]  - Finding globals in '...' for chunk #3 ...
[13:34:35.533] getGlobalsAndPackages() ...
[13:34:35.533] Searching for globals...
[13:34:35.533] 
[13:34:35.534] plan(): nbrOfWorkers() = 2
[13:34:35.533] Searching for globals ... DONE
[13:34:35.537] - globals: [0] <none>
[13:34:35.537] getGlobalsAndPackages() ... DONE
[13:34:35.538]    + additional globals found: [n=0] 
[13:34:35.538]    + additional namespaces needed: [n=0] 
[13:34:35.538]  - Finding globals in '...' for chunk #3 ... DONE
[13:34:35.538]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:35.539]  - seeds: <none>
[13:34:35.539]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.540] getGlobalsAndPackages() ...
[13:34:35.540] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.540] Resolving globals: FALSE
[13:34:35.542] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:35.543] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:35.543] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.543] 
[13:34:35.544] getGlobalsAndPackages() ... DONE
[13:34:35.544] run() for ‘Future’ ...
[13:34:35.545] - state: ‘created’
[13:34:35.545] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.551] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.551] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.551]   - Field: ‘label’
[13:34:35.551]   - Field: ‘local’
[13:34:35.552]   - Field: ‘owner’
[13:34:35.552]   - Field: ‘envir’
[13:34:35.552]   - Field: ‘workers’
[13:34:35.552]   - Field: ‘packages’
[13:34:35.552]   - Field: ‘gc’
[13:34:35.552]   - Field: ‘job’
[13:34:35.553]   - Field: ‘conditions’
[13:34:35.553]   - Field: ‘expr’
[13:34:35.553]   - Field: ‘uuid’
[13:34:35.553]   - Field: ‘seed’
[13:34:35.553]   - Field: ‘version’
[13:34:35.553]   - Field: ‘result’
[13:34:35.553]   - Field: ‘asynchronous’
[13:34:35.554]   - Field: ‘calls’
[13:34:35.554]   - Field: ‘globals’
[13:34:35.554]   - Field: ‘stdout’
[13:34:35.554]   - Field: ‘earlySignal’
[13:34:35.554]   - Field: ‘lazy’
[13:34:35.554]   - Field: ‘state’
[13:34:35.554] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.555] - Launch lazy future ...
[13:34:35.555] Packages needed by the future expression (n = 0): <none>
[13:34:35.555] Packages needed by future strategies (n = 0): <none>
[13:34:35.556] {
[13:34:35.556]     {
[13:34:35.556]         {
[13:34:35.556]             ...future.startTime <- base::Sys.time()
[13:34:35.556]             {
[13:34:35.556]                 {
[13:34:35.556]                   {
[13:34:35.556]                     {
[13:34:35.556]                       base::local({
[13:34:35.556]                         has_future <- base::requireNamespace("future", 
[13:34:35.556]                           quietly = TRUE)
[13:34:35.556]                         if (has_future) {
[13:34:35.556]                           ns <- base::getNamespace("future")
[13:34:35.556]                           version <- ns[[".package"]][["version"]]
[13:34:35.556]                           if (is.null(version)) 
[13:34:35.556]                             version <- utils::packageVersion("future")
[13:34:35.556]                         }
[13:34:35.556]                         else {
[13:34:35.556]                           version <- NULL
[13:34:35.556]                         }
[13:34:35.556]                         if (!has_future || version < "1.8.0") {
[13:34:35.556]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.556]                             "", base::R.version$version.string), 
[13:34:35.556]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.556]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.556]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.556]                               "release", "version")], collapse = " "), 
[13:34:35.556]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.556]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.556]                             info)
[13:34:35.556]                           info <- base::paste(info, collapse = "; ")
[13:34:35.556]                           if (!has_future) {
[13:34:35.556]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.556]                               info)
[13:34:35.556]                           }
[13:34:35.556]                           else {
[13:34:35.556]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.556]                               info, version)
[13:34:35.556]                           }
[13:34:35.556]                           base::stop(msg)
[13:34:35.556]                         }
[13:34:35.556]                       })
[13:34:35.556]                     }
[13:34:35.556]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.556]                     base::options(mc.cores = 1L)
[13:34:35.556]                   }
[13:34:35.556]                   ...future.strategy.old <- future::plan("list")
[13:34:35.556]                   options(future.plan = NULL)
[13:34:35.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.556]                 }
[13:34:35.556]                 ...future.workdir <- getwd()
[13:34:35.556]             }
[13:34:35.556]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.556]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.556]         }
[13:34:35.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.556]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:35.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.556]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.556]             base::names(...future.oldOptions))
[13:34:35.556]     }
[13:34:35.556]     if (FALSE) {
[13:34:35.556]     }
[13:34:35.556]     else {
[13:34:35.556]         if (TRUE) {
[13:34:35.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.556]                 open = "w")
[13:34:35.556]         }
[13:34:35.556]         else {
[13:34:35.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.556]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.556]         }
[13:34:35.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.556]             base::sink(type = "output", split = FALSE)
[13:34:35.556]             base::close(...future.stdout)
[13:34:35.556]         }, add = TRUE)
[13:34:35.556]     }
[13:34:35.556]     ...future.frame <- base::sys.nframe()
[13:34:35.556]     ...future.conditions <- base::list()
[13:34:35.556]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.556]     if (FALSE) {
[13:34:35.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.556]     }
[13:34:35.556]     ...future.result <- base::tryCatch({
[13:34:35.556]         base::withCallingHandlers({
[13:34:35.556]             ...future.value <- base::withVisible(base::local({
[13:34:35.556]                 withCallingHandlers({
[13:34:35.556]                   {
[13:34:35.556]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.556]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.556]                       ...future.globals.maxSize)) {
[13:34:35.556]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.556]                       on.exit(options(oopts), add = TRUE)
[13:34:35.556]                     }
[13:34:35.556]                     {
[13:34:35.556]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.556]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.556]                         USE.NAMES = FALSE)
[13:34:35.556]                       do.call(mapply, args = args)
[13:34:35.556]                     }
[13:34:35.556]                   }
[13:34:35.556]                 }, immediateCondition = function(cond) {
[13:34:35.556]                   save_rds <- function (object, pathname, ...) 
[13:34:35.556]                   {
[13:34:35.556]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.556]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.556]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.556]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.556]                         fi_tmp[["mtime"]])
[13:34:35.556]                     }
[13:34:35.556]                     tryCatch({
[13:34:35.556]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.556]                     }, error = function(ex) {
[13:34:35.556]                       msg <- conditionMessage(ex)
[13:34:35.556]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.556]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.556]                         fi_tmp[["mtime"]], msg)
[13:34:35.556]                       ex$message <- msg
[13:34:35.556]                       stop(ex)
[13:34:35.556]                     })
[13:34:35.556]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.556]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.556]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.556]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.556]                       fi <- file.info(pathname)
[13:34:35.556]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.556]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.556]                         fi[["size"]], fi[["mtime"]])
[13:34:35.556]                       stop(msg)
[13:34:35.556]                     }
[13:34:35.556]                     invisible(pathname)
[13:34:35.556]                   }
[13:34:35.556]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.556]                     rootPath = tempdir()) 
[13:34:35.556]                   {
[13:34:35.556]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.556]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.556]                       tmpdir = path, fileext = ".rds")
[13:34:35.556]                     save_rds(obj, file)
[13:34:35.556]                   }
[13:34:35.556]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.556]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.556]                   {
[13:34:35.556]                     inherits <- base::inherits
[13:34:35.556]                     invokeRestart <- base::invokeRestart
[13:34:35.556]                     is.null <- base::is.null
[13:34:35.556]                     muffled <- FALSE
[13:34:35.556]                     if (inherits(cond, "message")) {
[13:34:35.556]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.556]                       if (muffled) 
[13:34:35.556]                         invokeRestart("muffleMessage")
[13:34:35.556]                     }
[13:34:35.556]                     else if (inherits(cond, "warning")) {
[13:34:35.556]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.556]                       if (muffled) 
[13:34:35.556]                         invokeRestart("muffleWarning")
[13:34:35.556]                     }
[13:34:35.556]                     else if (inherits(cond, "condition")) {
[13:34:35.556]                       if (!is.null(pattern)) {
[13:34:35.556]                         computeRestarts <- base::computeRestarts
[13:34:35.556]                         grepl <- base::grepl
[13:34:35.556]                         restarts <- computeRestarts(cond)
[13:34:35.556]                         for (restart in restarts) {
[13:34:35.556]                           name <- restart$name
[13:34:35.556]                           if (is.null(name)) 
[13:34:35.556]                             next
[13:34:35.556]                           if (!grepl(pattern, name)) 
[13:34:35.556]                             next
[13:34:35.556]                           invokeRestart(restart)
[13:34:35.556]                           muffled <- TRUE
[13:34:35.556]                           break
[13:34:35.556]                         }
[13:34:35.556]                       }
[13:34:35.556]                     }
[13:34:35.556]                     invisible(muffled)
[13:34:35.556]                   }
[13:34:35.556]                   muffleCondition(cond)
[13:34:35.556]                 })
[13:34:35.556]             }))
[13:34:35.556]             future::FutureResult(value = ...future.value$value, 
[13:34:35.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.556]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.556]                     ...future.globalenv.names))
[13:34:35.556]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.556]         }, condition = base::local({
[13:34:35.556]             c <- base::c
[13:34:35.556]             inherits <- base::inherits
[13:34:35.556]             invokeRestart <- base::invokeRestart
[13:34:35.556]             length <- base::length
[13:34:35.556]             list <- base::list
[13:34:35.556]             seq.int <- base::seq.int
[13:34:35.556]             signalCondition <- base::signalCondition
[13:34:35.556]             sys.calls <- base::sys.calls
[13:34:35.556]             `[[` <- base::`[[`
[13:34:35.556]             `+` <- base::`+`
[13:34:35.556]             `<<-` <- base::`<<-`
[13:34:35.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.556]                   3L)]
[13:34:35.556]             }
[13:34:35.556]             function(cond) {
[13:34:35.556]                 is_error <- inherits(cond, "error")
[13:34:35.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.556]                   NULL)
[13:34:35.556]                 if (is_error) {
[13:34:35.556]                   sessionInformation <- function() {
[13:34:35.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.556]                       search = base::search(), system = base::Sys.info())
[13:34:35.556]                   }
[13:34:35.556]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.556]                     cond$call), session = sessionInformation(), 
[13:34:35.556]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.556]                   signalCondition(cond)
[13:34:35.556]                 }
[13:34:35.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.556]                 "immediateCondition"))) {
[13:34:35.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.556]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.556]                   if (TRUE && !signal) {
[13:34:35.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.556]                     {
[13:34:35.556]                       inherits <- base::inherits
[13:34:35.556]                       invokeRestart <- base::invokeRestart
[13:34:35.556]                       is.null <- base::is.null
[13:34:35.556]                       muffled <- FALSE
[13:34:35.556]                       if (inherits(cond, "message")) {
[13:34:35.556]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.556]                         if (muffled) 
[13:34:35.556]                           invokeRestart("muffleMessage")
[13:34:35.556]                       }
[13:34:35.556]                       else if (inherits(cond, "warning")) {
[13:34:35.556]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.556]                         if (muffled) 
[13:34:35.556]                           invokeRestart("muffleWarning")
[13:34:35.556]                       }
[13:34:35.556]                       else if (inherits(cond, "condition")) {
[13:34:35.556]                         if (!is.null(pattern)) {
[13:34:35.556]                           computeRestarts <- base::computeRestarts
[13:34:35.556]                           grepl <- base::grepl
[13:34:35.556]                           restarts <- computeRestarts(cond)
[13:34:35.556]                           for (restart in restarts) {
[13:34:35.556]                             name <- restart$name
[13:34:35.556]                             if (is.null(name)) 
[13:34:35.556]                               next
[13:34:35.556]                             if (!grepl(pattern, name)) 
[13:34:35.556]                               next
[13:34:35.556]                             invokeRestart(restart)
[13:34:35.556]                             muffled <- TRUE
[13:34:35.556]                             break
[13:34:35.556]                           }
[13:34:35.556]                         }
[13:34:35.556]                       }
[13:34:35.556]                       invisible(muffled)
[13:34:35.556]                     }
[13:34:35.556]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.556]                   }
[13:34:35.556]                 }
[13:34:35.556]                 else {
[13:34:35.556]                   if (TRUE) {
[13:34:35.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.556]                     {
[13:34:35.556]                       inherits <- base::inherits
[13:34:35.556]                       invokeRestart <- base::invokeRestart
[13:34:35.556]                       is.null <- base::is.null
[13:34:35.556]                       muffled <- FALSE
[13:34:35.556]                       if (inherits(cond, "message")) {
[13:34:35.556]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.556]                         if (muffled) 
[13:34:35.556]                           invokeRestart("muffleMessage")
[13:34:35.556]                       }
[13:34:35.556]                       else if (inherits(cond, "warning")) {
[13:34:35.556]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.556]                         if (muffled) 
[13:34:35.556]                           invokeRestart("muffleWarning")
[13:34:35.556]                       }
[13:34:35.556]                       else if (inherits(cond, "condition")) {
[13:34:35.556]                         if (!is.null(pattern)) {
[13:34:35.556]                           computeRestarts <- base::computeRestarts
[13:34:35.556]                           grepl <- base::grepl
[13:34:35.556]                           restarts <- computeRestarts(cond)
[13:34:35.556]                           for (restart in restarts) {
[13:34:35.556]                             name <- restart$name
[13:34:35.556]                             if (is.null(name)) 
[13:34:35.556]                               next
[13:34:35.556]                             if (!grepl(pattern, name)) 
[13:34:35.556]                               next
[13:34:35.556]                             invokeRestart(restart)
[13:34:35.556]                             muffled <- TRUE
[13:34:35.556]                             break
[13:34:35.556]                           }
[13:34:35.556]                         }
[13:34:35.556]                       }
[13:34:35.556]                       invisible(muffled)
[13:34:35.556]                     }
[13:34:35.556]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.556]                   }
[13:34:35.556]                 }
[13:34:35.556]             }
[13:34:35.556]         }))
[13:34:35.556]     }, error = function(ex) {
[13:34:35.556]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.556]                 ...future.rng), started = ...future.startTime, 
[13:34:35.556]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.556]             version = "1.8"), class = "FutureResult")
[13:34:35.556]     }, finally = {
[13:34:35.556]         if (!identical(...future.workdir, getwd())) 
[13:34:35.556]             setwd(...future.workdir)
[13:34:35.556]         {
[13:34:35.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.556]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.556]             }
[13:34:35.556]             base::options(...future.oldOptions)
[13:34:35.556]             if (.Platform$OS.type == "windows") {
[13:34:35.556]                 old_names <- names(...future.oldEnvVars)
[13:34:35.556]                 envs <- base::Sys.getenv()
[13:34:35.556]                 names <- names(envs)
[13:34:35.556]                 common <- intersect(names, old_names)
[13:34:35.556]                 added <- setdiff(names, old_names)
[13:34:35.556]                 removed <- setdiff(old_names, names)
[13:34:35.556]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.556]                   envs[common]]
[13:34:35.556]                 NAMES <- toupper(changed)
[13:34:35.556]                 args <- list()
[13:34:35.556]                 for (kk in seq_along(NAMES)) {
[13:34:35.556]                   name <- changed[[kk]]
[13:34:35.556]                   NAME <- NAMES[[kk]]
[13:34:35.556]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.556]                     next
[13:34:35.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.556]                 }
[13:34:35.556]                 NAMES <- toupper(added)
[13:34:35.556]                 for (kk in seq_along(NAMES)) {
[13:34:35.556]                   name <- added[[kk]]
[13:34:35.556]                   NAME <- NAMES[[kk]]
[13:34:35.556]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.556]                     next
[13:34:35.556]                   args[[name]] <- ""
[13:34:35.556]                 }
[13:34:35.556]                 NAMES <- toupper(removed)
[13:34:35.556]                 for (kk in seq_along(NAMES)) {
[13:34:35.556]                   name <- removed[[kk]]
[13:34:35.556]                   NAME <- NAMES[[kk]]
[13:34:35.556]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.556]                     next
[13:34:35.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.556]                 }
[13:34:35.556]                 if (length(args) > 0) 
[13:34:35.556]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.556]             }
[13:34:35.556]             else {
[13:34:35.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.556]             }
[13:34:35.556]             {
[13:34:35.556]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.556]                   0L) {
[13:34:35.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.556]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.556]                   base::options(opts)
[13:34:35.556]                 }
[13:34:35.556]                 {
[13:34:35.556]                   {
[13:34:35.556]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.556]                     NULL
[13:34:35.556]                   }
[13:34:35.556]                   options(future.plan = NULL)
[13:34:35.556]                   if (is.na(NA_character_)) 
[13:34:35.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.556]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.556]                     .init = FALSE)
[13:34:35.556]                 }
[13:34:35.556]             }
[13:34:35.556]         }
[13:34:35.556]     })
[13:34:35.556]     if (TRUE) {
[13:34:35.556]         base::sink(type = "output", split = FALSE)
[13:34:35.556]         if (TRUE) {
[13:34:35.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.556]         }
[13:34:35.556]         else {
[13:34:35.556]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.556]         }
[13:34:35.556]         base::close(...future.stdout)
[13:34:35.556]         ...future.stdout <- NULL
[13:34:35.556]     }
[13:34:35.556]     ...future.result$conditions <- ...future.conditions
[13:34:35.556]     ...future.result$finished <- base::Sys.time()
[13:34:35.556]     ...future.result
[13:34:35.556] }
[13:34:35.559] assign_globals() ...
[13:34:35.559] List of 5
[13:34:35.559]  $ ...future.FUN            :function (C, k)  
[13:34:35.559]  $ MoreArgs                 : NULL
[13:34:35.559]  $ ...future.elements_ii    :List of 2
[13:34:35.559]   ..$ :List of 1
[13:34:35.559]   .. ..$ : chr "C"
[13:34:35.559]   ..$ :List of 1
[13:34:35.559]   .. ..$ : int 3
[13:34:35.559]  $ ...future.seeds_ii       : NULL
[13:34:35.559]  $ ...future.globals.maxSize: NULL
[13:34:35.559]  - attr(*, "where")=List of 5
[13:34:35.559]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.559]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.559]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.559]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.559]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.559]  - attr(*, "resolved")= logi FALSE
[13:34:35.559]  - attr(*, "total_size")= num 3488
[13:34:35.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.559]  - attr(*, "already-done")= logi TRUE
[13:34:35.566] - reassign environment for ‘...future.FUN’
[13:34:35.566] - copied ‘...future.FUN’ to environment
[13:34:35.566] - copied ‘MoreArgs’ to environment
[13:34:35.566] - copied ‘...future.elements_ii’ to environment
[13:34:35.566] - copied ‘...future.seeds_ii’ to environment
[13:34:35.566] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.566] assign_globals() ... done
[13:34:35.567] requestCore(): workers = 2
[13:34:35.567] Poll #1 (0): usedCores() = 2, workers = 2
[13:34:35.577] result() for MulticoreFuture ...
[13:34:35.578] result() for MulticoreFuture ...
[13:34:35.578] result() for MulticoreFuture ... done
[13:34:35.579] result() for MulticoreFuture ... done
[13:34:35.579] result() for MulticoreFuture ...
[13:34:35.579] result() for MulticoreFuture ... done
[13:34:35.581] MulticoreFuture started
[13:34:35.582] - Launch lazy future ... done
[13:34:35.582] run() for ‘MulticoreFuture’ ... done
[13:34:35.583] Created future:
[13:34:35.583] plan(): Setting new future strategy stack:
[13:34:35.583] List of future strategies:
[13:34:35.583] 1. sequential:
[13:34:35.583]    - args: function (..., envir = parent.frame())
[13:34:35.583]    - tweaked: FALSE
[13:34:35.583]    - call: NULL
[13:34:35.584] plan(): nbrOfWorkers() = 1
[13:34:35.587] plan(): Setting new future strategy stack:
[13:34:35.587] List of future strategies:
[13:34:35.587] 1. multicore:
[13:34:35.587]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.587]    - tweaked: FALSE
[13:34:35.587]    - call: plan(strategy)
[13:34:35.592] plan(): nbrOfWorkers() = 2
[13:34:35.583] MulticoreFuture:
[13:34:35.583] Label: ‘future_mapply-3’
[13:34:35.583] Expression:
[13:34:35.583] {
[13:34:35.583]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.583]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.583]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.583]         on.exit(options(oopts), add = TRUE)
[13:34:35.583]     }
[13:34:35.583]     {
[13:34:35.583]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.583]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.583]         do.call(mapply, args = args)
[13:34:35.583]     }
[13:34:35.583] }
[13:34:35.583] Lazy evaluation: FALSE
[13:34:35.583] Asynchronous evaluation: TRUE
[13:34:35.583] Local evaluation: TRUE
[13:34:35.583] Environment: R_GlobalEnv
[13:34:35.583] Capture standard output: TRUE
[13:34:35.583] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.583] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.583] Packages: <none>
[13:34:35.583] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.583] Resolved: TRUE
[13:34:35.583] Value: <not collected>
[13:34:35.583] Conditions captured: <none>
[13:34:35.583] Early signaling: FALSE
[13:34:35.583] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.583] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.593] Chunk #3 of 5 ... DONE
[13:34:35.593] Chunk #4 of 5 ...
[13:34:35.593]  - Finding globals in '...' for chunk #4 ...
[13:34:35.594] getGlobalsAndPackages() ...
[13:34:35.594] Searching for globals...
[13:34:35.594] 
[13:34:35.595] Searching for globals ... DONE
[13:34:35.595] - globals: [0] <none>
[13:34:35.595] getGlobalsAndPackages() ... DONE
[13:34:35.595]    + additional globals found: [n=0] 
[13:34:35.595]    + additional namespaces needed: [n=0] 
[13:34:35.595]  - Finding globals in '...' for chunk #4 ... DONE
[13:34:35.595]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:35.595]  - seeds: <none>
[13:34:35.596]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.596] getGlobalsAndPackages() ...
[13:34:35.596] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.596] Resolving globals: FALSE
[13:34:35.597] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:35.598] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:35.602] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.603] 
[13:34:35.603] getGlobalsAndPackages() ... DONE
[13:34:35.604] run() for ‘Future’ ...
[13:34:35.604] - state: ‘created’
[13:34:35.605] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.611] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.611] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.611]   - Field: ‘label’
[13:34:35.611]   - Field: ‘local’
[13:34:35.612]   - Field: ‘owner’
[13:34:35.612]   - Field: ‘envir’
[13:34:35.612]   - Field: ‘workers’
[13:34:35.612]   - Field: ‘packages’
[13:34:35.613]   - Field: ‘gc’
[13:34:35.613]   - Field: ‘job’
[13:34:35.613]   - Field: ‘conditions’
[13:34:35.613]   - Field: ‘expr’
[13:34:35.613]   - Field: ‘uuid’
[13:34:35.614]   - Field: ‘seed’
[13:34:35.614]   - Field: ‘version’
[13:34:35.614]   - Field: ‘result’
[13:34:35.614]   - Field: ‘asynchronous’
[13:34:35.614]   - Field: ‘calls’
[13:34:35.615]   - Field: ‘globals’
[13:34:35.615]   - Field: ‘stdout’
[13:34:35.615]   - Field: ‘earlySignal’
[13:34:35.615]   - Field: ‘lazy’
[13:34:35.615]   - Field: ‘state’
[13:34:35.616] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.616] - Launch lazy future ...
[13:34:35.616] Packages needed by the future expression (n = 0): <none>
[13:34:35.616] Packages needed by future strategies (n = 0): <none>
[13:34:35.617] {
[13:34:35.617]     {
[13:34:35.617]         {
[13:34:35.617]             ...future.startTime <- base::Sys.time()
[13:34:35.617]             {
[13:34:35.617]                 {
[13:34:35.617]                   {
[13:34:35.617]                     {
[13:34:35.617]                       base::local({
[13:34:35.617]                         has_future <- base::requireNamespace("future", 
[13:34:35.617]                           quietly = TRUE)
[13:34:35.617]                         if (has_future) {
[13:34:35.617]                           ns <- base::getNamespace("future")
[13:34:35.617]                           version <- ns[[".package"]][["version"]]
[13:34:35.617]                           if (is.null(version)) 
[13:34:35.617]                             version <- utils::packageVersion("future")
[13:34:35.617]                         }
[13:34:35.617]                         else {
[13:34:35.617]                           version <- NULL
[13:34:35.617]                         }
[13:34:35.617]                         if (!has_future || version < "1.8.0") {
[13:34:35.617]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.617]                             "", base::R.version$version.string), 
[13:34:35.617]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.617]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.617]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.617]                               "release", "version")], collapse = " "), 
[13:34:35.617]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.617]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.617]                             info)
[13:34:35.617]                           info <- base::paste(info, collapse = "; ")
[13:34:35.617]                           if (!has_future) {
[13:34:35.617]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.617]                               info)
[13:34:35.617]                           }
[13:34:35.617]                           else {
[13:34:35.617]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.617]                               info, version)
[13:34:35.617]                           }
[13:34:35.617]                           base::stop(msg)
[13:34:35.617]                         }
[13:34:35.617]                       })
[13:34:35.617]                     }
[13:34:35.617]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.617]                     base::options(mc.cores = 1L)
[13:34:35.617]                   }
[13:34:35.617]                   ...future.strategy.old <- future::plan("list")
[13:34:35.617]                   options(future.plan = NULL)
[13:34:35.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.617]                 }
[13:34:35.617]                 ...future.workdir <- getwd()
[13:34:35.617]             }
[13:34:35.617]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.617]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.617]         }
[13:34:35.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.617]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:35.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.617]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.617]             base::names(...future.oldOptions))
[13:34:35.617]     }
[13:34:35.617]     if (FALSE) {
[13:34:35.617]     }
[13:34:35.617]     else {
[13:34:35.617]         if (TRUE) {
[13:34:35.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.617]                 open = "w")
[13:34:35.617]         }
[13:34:35.617]         else {
[13:34:35.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.617]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.617]         }
[13:34:35.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.617]             base::sink(type = "output", split = FALSE)
[13:34:35.617]             base::close(...future.stdout)
[13:34:35.617]         }, add = TRUE)
[13:34:35.617]     }
[13:34:35.617]     ...future.frame <- base::sys.nframe()
[13:34:35.617]     ...future.conditions <- base::list()
[13:34:35.617]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.617]     if (FALSE) {
[13:34:35.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.617]     }
[13:34:35.617]     ...future.result <- base::tryCatch({
[13:34:35.617]         base::withCallingHandlers({
[13:34:35.617]             ...future.value <- base::withVisible(base::local({
[13:34:35.617]                 withCallingHandlers({
[13:34:35.617]                   {
[13:34:35.617]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.617]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.617]                       ...future.globals.maxSize)) {
[13:34:35.617]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.617]                       on.exit(options(oopts), add = TRUE)
[13:34:35.617]                     }
[13:34:35.617]                     {
[13:34:35.617]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.617]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.617]                         USE.NAMES = FALSE)
[13:34:35.617]                       do.call(mapply, args = args)
[13:34:35.617]                     }
[13:34:35.617]                   }
[13:34:35.617]                 }, immediateCondition = function(cond) {
[13:34:35.617]                   save_rds <- function (object, pathname, ...) 
[13:34:35.617]                   {
[13:34:35.617]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.617]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.617]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.617]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.617]                         fi_tmp[["mtime"]])
[13:34:35.617]                     }
[13:34:35.617]                     tryCatch({
[13:34:35.617]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.617]                     }, error = function(ex) {
[13:34:35.617]                       msg <- conditionMessage(ex)
[13:34:35.617]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.617]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.617]                         fi_tmp[["mtime"]], msg)
[13:34:35.617]                       ex$message <- msg
[13:34:35.617]                       stop(ex)
[13:34:35.617]                     })
[13:34:35.617]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.617]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.617]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.617]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.617]                       fi <- file.info(pathname)
[13:34:35.617]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.617]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.617]                         fi[["size"]], fi[["mtime"]])
[13:34:35.617]                       stop(msg)
[13:34:35.617]                     }
[13:34:35.617]                     invisible(pathname)
[13:34:35.617]                   }
[13:34:35.617]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.617]                     rootPath = tempdir()) 
[13:34:35.617]                   {
[13:34:35.617]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.617]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.617]                       tmpdir = path, fileext = ".rds")
[13:34:35.617]                     save_rds(obj, file)
[13:34:35.617]                   }
[13:34:35.617]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.617]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.617]                   {
[13:34:35.617]                     inherits <- base::inherits
[13:34:35.617]                     invokeRestart <- base::invokeRestart
[13:34:35.617]                     is.null <- base::is.null
[13:34:35.617]                     muffled <- FALSE
[13:34:35.617]                     if (inherits(cond, "message")) {
[13:34:35.617]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.617]                       if (muffled) 
[13:34:35.617]                         invokeRestart("muffleMessage")
[13:34:35.617]                     }
[13:34:35.617]                     else if (inherits(cond, "warning")) {
[13:34:35.617]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.617]                       if (muffled) 
[13:34:35.617]                         invokeRestart("muffleWarning")
[13:34:35.617]                     }
[13:34:35.617]                     else if (inherits(cond, "condition")) {
[13:34:35.617]                       if (!is.null(pattern)) {
[13:34:35.617]                         computeRestarts <- base::computeRestarts
[13:34:35.617]                         grepl <- base::grepl
[13:34:35.617]                         restarts <- computeRestarts(cond)
[13:34:35.617]                         for (restart in restarts) {
[13:34:35.617]                           name <- restart$name
[13:34:35.617]                           if (is.null(name)) 
[13:34:35.617]                             next
[13:34:35.617]                           if (!grepl(pattern, name)) 
[13:34:35.617]                             next
[13:34:35.617]                           invokeRestart(restart)
[13:34:35.617]                           muffled <- TRUE
[13:34:35.617]                           break
[13:34:35.617]                         }
[13:34:35.617]                       }
[13:34:35.617]                     }
[13:34:35.617]                     invisible(muffled)
[13:34:35.617]                   }
[13:34:35.617]                   muffleCondition(cond)
[13:34:35.617]                 })
[13:34:35.617]             }))
[13:34:35.617]             future::FutureResult(value = ...future.value$value, 
[13:34:35.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.617]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.617]                     ...future.globalenv.names))
[13:34:35.617]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.617]         }, condition = base::local({
[13:34:35.617]             c <- base::c
[13:34:35.617]             inherits <- base::inherits
[13:34:35.617]             invokeRestart <- base::invokeRestart
[13:34:35.617]             length <- base::length
[13:34:35.617]             list <- base::list
[13:34:35.617]             seq.int <- base::seq.int
[13:34:35.617]             signalCondition <- base::signalCondition
[13:34:35.617]             sys.calls <- base::sys.calls
[13:34:35.617]             `[[` <- base::`[[`
[13:34:35.617]             `+` <- base::`+`
[13:34:35.617]             `<<-` <- base::`<<-`
[13:34:35.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.617]                   3L)]
[13:34:35.617]             }
[13:34:35.617]             function(cond) {
[13:34:35.617]                 is_error <- inherits(cond, "error")
[13:34:35.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.617]                   NULL)
[13:34:35.617]                 if (is_error) {
[13:34:35.617]                   sessionInformation <- function() {
[13:34:35.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.617]                       search = base::search(), system = base::Sys.info())
[13:34:35.617]                   }
[13:34:35.617]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.617]                     cond$call), session = sessionInformation(), 
[13:34:35.617]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.617]                   signalCondition(cond)
[13:34:35.617]                 }
[13:34:35.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.617]                 "immediateCondition"))) {
[13:34:35.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.617]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.617]                   if (TRUE && !signal) {
[13:34:35.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.617]                     {
[13:34:35.617]                       inherits <- base::inherits
[13:34:35.617]                       invokeRestart <- base::invokeRestart
[13:34:35.617]                       is.null <- base::is.null
[13:34:35.617]                       muffled <- FALSE
[13:34:35.617]                       if (inherits(cond, "message")) {
[13:34:35.617]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.617]                         if (muffled) 
[13:34:35.617]                           invokeRestart("muffleMessage")
[13:34:35.617]                       }
[13:34:35.617]                       else if (inherits(cond, "warning")) {
[13:34:35.617]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.617]                         if (muffled) 
[13:34:35.617]                           invokeRestart("muffleWarning")
[13:34:35.617]                       }
[13:34:35.617]                       else if (inherits(cond, "condition")) {
[13:34:35.617]                         if (!is.null(pattern)) {
[13:34:35.617]                           computeRestarts <- base::computeRestarts
[13:34:35.617]                           grepl <- base::grepl
[13:34:35.617]                           restarts <- computeRestarts(cond)
[13:34:35.617]                           for (restart in restarts) {
[13:34:35.617]                             name <- restart$name
[13:34:35.617]                             if (is.null(name)) 
[13:34:35.617]                               next
[13:34:35.617]                             if (!grepl(pattern, name)) 
[13:34:35.617]                               next
[13:34:35.617]                             invokeRestart(restart)
[13:34:35.617]                             muffled <- TRUE
[13:34:35.617]                             break
[13:34:35.617]                           }
[13:34:35.617]                         }
[13:34:35.617]                       }
[13:34:35.617]                       invisible(muffled)
[13:34:35.617]                     }
[13:34:35.617]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.617]                   }
[13:34:35.617]                 }
[13:34:35.617]                 else {
[13:34:35.617]                   if (TRUE) {
[13:34:35.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.617]                     {
[13:34:35.617]                       inherits <- base::inherits
[13:34:35.617]                       invokeRestart <- base::invokeRestart
[13:34:35.617]                       is.null <- base::is.null
[13:34:35.617]                       muffled <- FALSE
[13:34:35.617]                       if (inherits(cond, "message")) {
[13:34:35.617]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.617]                         if (muffled) 
[13:34:35.617]                           invokeRestart("muffleMessage")
[13:34:35.617]                       }
[13:34:35.617]                       else if (inherits(cond, "warning")) {
[13:34:35.617]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.617]                         if (muffled) 
[13:34:35.617]                           invokeRestart("muffleWarning")
[13:34:35.617]                       }
[13:34:35.617]                       else if (inherits(cond, "condition")) {
[13:34:35.617]                         if (!is.null(pattern)) {
[13:34:35.617]                           computeRestarts <- base::computeRestarts
[13:34:35.617]                           grepl <- base::grepl
[13:34:35.617]                           restarts <- computeRestarts(cond)
[13:34:35.617]                           for (restart in restarts) {
[13:34:35.617]                             name <- restart$name
[13:34:35.617]                             if (is.null(name)) 
[13:34:35.617]                               next
[13:34:35.617]                             if (!grepl(pattern, name)) 
[13:34:35.617]                               next
[13:34:35.617]                             invokeRestart(restart)
[13:34:35.617]                             muffled <- TRUE
[13:34:35.617]                             break
[13:34:35.617]                           }
[13:34:35.617]                         }
[13:34:35.617]                       }
[13:34:35.617]                       invisible(muffled)
[13:34:35.617]                     }
[13:34:35.617]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.617]                   }
[13:34:35.617]                 }
[13:34:35.617]             }
[13:34:35.617]         }))
[13:34:35.617]     }, error = function(ex) {
[13:34:35.617]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.617]                 ...future.rng), started = ...future.startTime, 
[13:34:35.617]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.617]             version = "1.8"), class = "FutureResult")
[13:34:35.617]     }, finally = {
[13:34:35.617]         if (!identical(...future.workdir, getwd())) 
[13:34:35.617]             setwd(...future.workdir)
[13:34:35.617]         {
[13:34:35.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.617]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.617]             }
[13:34:35.617]             base::options(...future.oldOptions)
[13:34:35.617]             if (.Platform$OS.type == "windows") {
[13:34:35.617]                 old_names <- names(...future.oldEnvVars)
[13:34:35.617]                 envs <- base::Sys.getenv()
[13:34:35.617]                 names <- names(envs)
[13:34:35.617]                 common <- intersect(names, old_names)
[13:34:35.617]                 added <- setdiff(names, old_names)
[13:34:35.617]                 removed <- setdiff(old_names, names)
[13:34:35.617]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.617]                   envs[common]]
[13:34:35.617]                 NAMES <- toupper(changed)
[13:34:35.617]                 args <- list()
[13:34:35.617]                 for (kk in seq_along(NAMES)) {
[13:34:35.617]                   name <- changed[[kk]]
[13:34:35.617]                   NAME <- NAMES[[kk]]
[13:34:35.617]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.617]                     next
[13:34:35.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.617]                 }
[13:34:35.617]                 NAMES <- toupper(added)
[13:34:35.617]                 for (kk in seq_along(NAMES)) {
[13:34:35.617]                   name <- added[[kk]]
[13:34:35.617]                   NAME <- NAMES[[kk]]
[13:34:35.617]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.617]                     next
[13:34:35.617]                   args[[name]] <- ""
[13:34:35.617]                 }
[13:34:35.617]                 NAMES <- toupper(removed)
[13:34:35.617]                 for (kk in seq_along(NAMES)) {
[13:34:35.617]                   name <- removed[[kk]]
[13:34:35.617]                   NAME <- NAMES[[kk]]
[13:34:35.617]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.617]                     next
[13:34:35.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.617]                 }
[13:34:35.617]                 if (length(args) > 0) 
[13:34:35.617]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.617]             }
[13:34:35.617]             else {
[13:34:35.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.617]             }
[13:34:35.617]             {
[13:34:35.617]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.617]                   0L) {
[13:34:35.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.617]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.617]                   base::options(opts)
[13:34:35.617]                 }
[13:34:35.617]                 {
[13:34:35.617]                   {
[13:34:35.617]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.617]                     NULL
[13:34:35.617]                   }
[13:34:35.617]                   options(future.plan = NULL)
[13:34:35.617]                   if (is.na(NA_character_)) 
[13:34:35.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.617]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.617]                     .init = FALSE)
[13:34:35.617]                 }
[13:34:35.617]             }
[13:34:35.617]         }
[13:34:35.617]     })
[13:34:35.617]     if (TRUE) {
[13:34:35.617]         base::sink(type = "output", split = FALSE)
[13:34:35.617]         if (TRUE) {
[13:34:35.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.617]         }
[13:34:35.617]         else {
[13:34:35.617]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.617]         }
[13:34:35.617]         base::close(...future.stdout)
[13:34:35.617]         ...future.stdout <- NULL
[13:34:35.617]     }
[13:34:35.617]     ...future.result$conditions <- ...future.conditions
[13:34:35.617]     ...future.result$finished <- base::Sys.time()
[13:34:35.617]     ...future.result
[13:34:35.617] }
[13:34:35.620] assign_globals() ...
[13:34:35.620] List of 5
[13:34:35.620]  $ ...future.FUN            :function (C, k)  
[13:34:35.620]  $ MoreArgs                 : NULL
[13:34:35.620]  $ ...future.elements_ii    :List of 2
[13:34:35.620]   ..$ :List of 1
[13:34:35.620]   .. ..$ : chr "D"
[13:34:35.620]   ..$ :List of 1
[13:34:35.620]   .. ..$ : int 2
[13:34:35.620]  $ ...future.seeds_ii       : NULL
[13:34:35.620]  $ ...future.globals.maxSize: NULL
[13:34:35.620]  - attr(*, "where")=List of 5
[13:34:35.620]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.620]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.620]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.620]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.620]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.620]  - attr(*, "resolved")= logi FALSE
[13:34:35.620]  - attr(*, "total_size")= num 3488
[13:34:35.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.620]  - attr(*, "already-done")= logi TRUE
[13:34:35.627] - reassign environment for ‘...future.FUN’
[13:34:35.628] - copied ‘...future.FUN’ to environment
[13:34:35.628] - copied ‘MoreArgs’ to environment
[13:34:35.628] - copied ‘...future.elements_ii’ to environment
[13:34:35.628] - copied ‘...future.seeds_ii’ to environment
[13:34:35.628] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.628] assign_globals() ... done
[13:34:35.628] requestCore(): workers = 2
[13:34:35.629] Poll #1 (0): usedCores() = 2, workers = 2
[13:34:35.651] result() for MulticoreFuture ...
[13:34:35.652] result() for MulticoreFuture ...
[13:34:35.652] result() for MulticoreFuture ... done
[13:34:35.652] result() for MulticoreFuture ... done
[13:34:35.652] result() for MulticoreFuture ...
[13:34:35.652] result() for MulticoreFuture ... done
[13:34:35.655] MulticoreFuture started
[13:34:35.656] - Launch lazy future ... done
[13:34:35.656] run() for ‘MulticoreFuture’ ... done
[13:34:35.656] plan(): Setting new future strategy stack:
[13:34:35.657] Created future:
[13:34:35.657] List of future strategies:
[13:34:35.657] 1. sequential:
[13:34:35.657]    - args: function (..., envir = parent.frame())
[13:34:35.657]    - tweaked: FALSE
[13:34:35.657]    - call: NULL
[13:34:35.658] plan(): nbrOfWorkers() = 1
[13:34:35.661] plan(): Setting new future strategy stack:
[13:34:35.661] List of future strategies:
[13:34:35.661] 1. multicore:
[13:34:35.661]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.661]    - tweaked: FALSE
[13:34:35.661]    - call: plan(strategy)
[13:34:35.667] plan(): nbrOfWorkers() = 2
[13:34:35.657] MulticoreFuture:
[13:34:35.657] Label: ‘future_mapply-4’
[13:34:35.657] Expression:
[13:34:35.657] {
[13:34:35.657]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.657]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.657]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.657]         on.exit(options(oopts), add = TRUE)
[13:34:35.657]     }
[13:34:35.657]     {
[13:34:35.657]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.657]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.657]         do.call(mapply, args = args)
[13:34:35.657]     }
[13:34:35.657] }
[13:34:35.657] Lazy evaluation: FALSE
[13:34:35.657] Asynchronous evaluation: TRUE
[13:34:35.657] Local evaluation: TRUE
[13:34:35.657] Environment: R_GlobalEnv
[13:34:35.657] Capture standard output: TRUE
[13:34:35.657] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.657] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.657] Packages: <none>
[13:34:35.657] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.657] Resolved: TRUE
[13:34:35.657] Value: <not collected>
[13:34:35.657] Conditions captured: <none>
[13:34:35.657] Early signaling: FALSE
[13:34:35.657] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.657] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.668] Chunk #4 of 5 ... DONE
[13:34:35.668] Chunk #5 of 5 ...
[13:34:35.669]  - Finding globals in '...' for chunk #5 ...
[13:34:35.669] getGlobalsAndPackages() ...
[13:34:35.669] Searching for globals...
[13:34:35.670] 
[13:34:35.670] Searching for globals ... DONE
[13:34:35.670] - globals: [0] <none>
[13:34:35.670] getGlobalsAndPackages() ... DONE
[13:34:35.670]    + additional globals found: [n=0] 
[13:34:35.671]    + additional namespaces needed: [n=0] 
[13:34:35.671]  - Finding globals in '...' for chunk #5 ... DONE
[13:34:35.671]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:35.671]  - seeds: <none>
[13:34:35.671]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.671] getGlobalsAndPackages() ...
[13:34:35.672] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.672] Resolving globals: FALSE
[13:34:35.673] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:35.674] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:35.674] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.674] 
[13:34:35.674] getGlobalsAndPackages() ... DONE
[13:34:35.675] run() for ‘Future’ ...
[13:34:35.675] - state: ‘created’
[13:34:35.675] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.680] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.680] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.680]   - Field: ‘label’
[13:34:35.680]   - Field: ‘local’
[13:34:35.680]   - Field: ‘owner’
[13:34:35.680]   - Field: ‘envir’
[13:34:35.681]   - Field: ‘workers’
[13:34:35.681]   - Field: ‘packages’
[13:34:35.681]   - Field: ‘gc’
[13:34:35.681]   - Field: ‘job’
[13:34:35.681]   - Field: ‘conditions’
[13:34:35.681]   - Field: ‘expr’
[13:34:35.681]   - Field: ‘uuid’
[13:34:35.682]   - Field: ‘seed’
[13:34:35.682]   - Field: ‘version’
[13:34:35.682]   - Field: ‘result’
[13:34:35.682]   - Field: ‘asynchronous’
[13:34:35.682]   - Field: ‘calls’
[13:34:35.682]   - Field: ‘globals’
[13:34:35.682]   - Field: ‘stdout’
[13:34:35.683]   - Field: ‘earlySignal’
[13:34:35.683]   - Field: ‘lazy’
[13:34:35.683]   - Field: ‘state’
[13:34:35.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.683] - Launch lazy future ...
[13:34:35.684] Packages needed by the future expression (n = 0): <none>
[13:34:35.684] Packages needed by future strategies (n = 0): <none>
[13:34:35.684] {
[13:34:35.684]     {
[13:34:35.684]         {
[13:34:35.684]             ...future.startTime <- base::Sys.time()
[13:34:35.684]             {
[13:34:35.684]                 {
[13:34:35.684]                   {
[13:34:35.684]                     {
[13:34:35.684]                       base::local({
[13:34:35.684]                         has_future <- base::requireNamespace("future", 
[13:34:35.684]                           quietly = TRUE)
[13:34:35.684]                         if (has_future) {
[13:34:35.684]                           ns <- base::getNamespace("future")
[13:34:35.684]                           version <- ns[[".package"]][["version"]]
[13:34:35.684]                           if (is.null(version)) 
[13:34:35.684]                             version <- utils::packageVersion("future")
[13:34:35.684]                         }
[13:34:35.684]                         else {
[13:34:35.684]                           version <- NULL
[13:34:35.684]                         }
[13:34:35.684]                         if (!has_future || version < "1.8.0") {
[13:34:35.684]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.684]                             "", base::R.version$version.string), 
[13:34:35.684]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.684]                               "release", "version")], collapse = " "), 
[13:34:35.684]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.684]                             info)
[13:34:35.684]                           info <- base::paste(info, collapse = "; ")
[13:34:35.684]                           if (!has_future) {
[13:34:35.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.684]                               info)
[13:34:35.684]                           }
[13:34:35.684]                           else {
[13:34:35.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.684]                               info, version)
[13:34:35.684]                           }
[13:34:35.684]                           base::stop(msg)
[13:34:35.684]                         }
[13:34:35.684]                       })
[13:34:35.684]                     }
[13:34:35.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.684]                     base::options(mc.cores = 1L)
[13:34:35.684]                   }
[13:34:35.684]                   ...future.strategy.old <- future::plan("list")
[13:34:35.684]                   options(future.plan = NULL)
[13:34:35.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.684]                 }
[13:34:35.684]                 ...future.workdir <- getwd()
[13:34:35.684]             }
[13:34:35.684]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.684]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.684]         }
[13:34:35.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.684]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:35.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.684]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.684]             base::names(...future.oldOptions))
[13:34:35.684]     }
[13:34:35.684]     if (FALSE) {
[13:34:35.684]     }
[13:34:35.684]     else {
[13:34:35.684]         if (TRUE) {
[13:34:35.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.684]                 open = "w")
[13:34:35.684]         }
[13:34:35.684]         else {
[13:34:35.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.684]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.684]         }
[13:34:35.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.684]             base::sink(type = "output", split = FALSE)
[13:34:35.684]             base::close(...future.stdout)
[13:34:35.684]         }, add = TRUE)
[13:34:35.684]     }
[13:34:35.684]     ...future.frame <- base::sys.nframe()
[13:34:35.684]     ...future.conditions <- base::list()
[13:34:35.684]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.684]     if (FALSE) {
[13:34:35.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.684]     }
[13:34:35.684]     ...future.result <- base::tryCatch({
[13:34:35.684]         base::withCallingHandlers({
[13:34:35.684]             ...future.value <- base::withVisible(base::local({
[13:34:35.684]                 withCallingHandlers({
[13:34:35.684]                   {
[13:34:35.684]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.684]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.684]                       ...future.globals.maxSize)) {
[13:34:35.684]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.684]                       on.exit(options(oopts), add = TRUE)
[13:34:35.684]                     }
[13:34:35.684]                     {
[13:34:35.684]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.684]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.684]                         USE.NAMES = FALSE)
[13:34:35.684]                       do.call(mapply, args = args)
[13:34:35.684]                     }
[13:34:35.684]                   }
[13:34:35.684]                 }, immediateCondition = function(cond) {
[13:34:35.684]                   save_rds <- function (object, pathname, ...) 
[13:34:35.684]                   {
[13:34:35.684]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.684]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.684]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.684]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.684]                         fi_tmp[["mtime"]])
[13:34:35.684]                     }
[13:34:35.684]                     tryCatch({
[13:34:35.684]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.684]                     }, error = function(ex) {
[13:34:35.684]                       msg <- conditionMessage(ex)
[13:34:35.684]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.684]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.684]                         fi_tmp[["mtime"]], msg)
[13:34:35.684]                       ex$message <- msg
[13:34:35.684]                       stop(ex)
[13:34:35.684]                     })
[13:34:35.684]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.684]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.684]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.684]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.684]                       fi <- file.info(pathname)
[13:34:35.684]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.684]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.684]                         fi[["size"]], fi[["mtime"]])
[13:34:35.684]                       stop(msg)
[13:34:35.684]                     }
[13:34:35.684]                     invisible(pathname)
[13:34:35.684]                   }
[13:34:35.684]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.684]                     rootPath = tempdir()) 
[13:34:35.684]                   {
[13:34:35.684]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.684]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.684]                       tmpdir = path, fileext = ".rds")
[13:34:35.684]                     save_rds(obj, file)
[13:34:35.684]                   }
[13:34:35.684]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.684]                   {
[13:34:35.684]                     inherits <- base::inherits
[13:34:35.684]                     invokeRestart <- base::invokeRestart
[13:34:35.684]                     is.null <- base::is.null
[13:34:35.684]                     muffled <- FALSE
[13:34:35.684]                     if (inherits(cond, "message")) {
[13:34:35.684]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.684]                       if (muffled) 
[13:34:35.684]                         invokeRestart("muffleMessage")
[13:34:35.684]                     }
[13:34:35.684]                     else if (inherits(cond, "warning")) {
[13:34:35.684]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.684]                       if (muffled) 
[13:34:35.684]                         invokeRestart("muffleWarning")
[13:34:35.684]                     }
[13:34:35.684]                     else if (inherits(cond, "condition")) {
[13:34:35.684]                       if (!is.null(pattern)) {
[13:34:35.684]                         computeRestarts <- base::computeRestarts
[13:34:35.684]                         grepl <- base::grepl
[13:34:35.684]                         restarts <- computeRestarts(cond)
[13:34:35.684]                         for (restart in restarts) {
[13:34:35.684]                           name <- restart$name
[13:34:35.684]                           if (is.null(name)) 
[13:34:35.684]                             next
[13:34:35.684]                           if (!grepl(pattern, name)) 
[13:34:35.684]                             next
[13:34:35.684]                           invokeRestart(restart)
[13:34:35.684]                           muffled <- TRUE
[13:34:35.684]                           break
[13:34:35.684]                         }
[13:34:35.684]                       }
[13:34:35.684]                     }
[13:34:35.684]                     invisible(muffled)
[13:34:35.684]                   }
[13:34:35.684]                   muffleCondition(cond)
[13:34:35.684]                 })
[13:34:35.684]             }))
[13:34:35.684]             future::FutureResult(value = ...future.value$value, 
[13:34:35.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.684]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.684]                     ...future.globalenv.names))
[13:34:35.684]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.684]         }, condition = base::local({
[13:34:35.684]             c <- base::c
[13:34:35.684]             inherits <- base::inherits
[13:34:35.684]             invokeRestart <- base::invokeRestart
[13:34:35.684]             length <- base::length
[13:34:35.684]             list <- base::list
[13:34:35.684]             seq.int <- base::seq.int
[13:34:35.684]             signalCondition <- base::signalCondition
[13:34:35.684]             sys.calls <- base::sys.calls
[13:34:35.684]             `[[` <- base::`[[`
[13:34:35.684]             `+` <- base::`+`
[13:34:35.684]             `<<-` <- base::`<<-`
[13:34:35.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.684]                   3L)]
[13:34:35.684]             }
[13:34:35.684]             function(cond) {
[13:34:35.684]                 is_error <- inherits(cond, "error")
[13:34:35.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.684]                   NULL)
[13:34:35.684]                 if (is_error) {
[13:34:35.684]                   sessionInformation <- function() {
[13:34:35.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.684]                       search = base::search(), system = base::Sys.info())
[13:34:35.684]                   }
[13:34:35.684]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.684]                     cond$call), session = sessionInformation(), 
[13:34:35.684]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.684]                   signalCondition(cond)
[13:34:35.684]                 }
[13:34:35.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.684]                 "immediateCondition"))) {
[13:34:35.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.684]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.684]                   if (TRUE && !signal) {
[13:34:35.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.684]                     {
[13:34:35.684]                       inherits <- base::inherits
[13:34:35.684]                       invokeRestart <- base::invokeRestart
[13:34:35.684]                       is.null <- base::is.null
[13:34:35.684]                       muffled <- FALSE
[13:34:35.684]                       if (inherits(cond, "message")) {
[13:34:35.684]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.684]                         if (muffled) 
[13:34:35.684]                           invokeRestart("muffleMessage")
[13:34:35.684]                       }
[13:34:35.684]                       else if (inherits(cond, "warning")) {
[13:34:35.684]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.684]                         if (muffled) 
[13:34:35.684]                           invokeRestart("muffleWarning")
[13:34:35.684]                       }
[13:34:35.684]                       else if (inherits(cond, "condition")) {
[13:34:35.684]                         if (!is.null(pattern)) {
[13:34:35.684]                           computeRestarts <- base::computeRestarts
[13:34:35.684]                           grepl <- base::grepl
[13:34:35.684]                           restarts <- computeRestarts(cond)
[13:34:35.684]                           for (restart in restarts) {
[13:34:35.684]                             name <- restart$name
[13:34:35.684]                             if (is.null(name)) 
[13:34:35.684]                               next
[13:34:35.684]                             if (!grepl(pattern, name)) 
[13:34:35.684]                               next
[13:34:35.684]                             invokeRestart(restart)
[13:34:35.684]                             muffled <- TRUE
[13:34:35.684]                             break
[13:34:35.684]                           }
[13:34:35.684]                         }
[13:34:35.684]                       }
[13:34:35.684]                       invisible(muffled)
[13:34:35.684]                     }
[13:34:35.684]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.684]                   }
[13:34:35.684]                 }
[13:34:35.684]                 else {
[13:34:35.684]                   if (TRUE) {
[13:34:35.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.684]                     {
[13:34:35.684]                       inherits <- base::inherits
[13:34:35.684]                       invokeRestart <- base::invokeRestart
[13:34:35.684]                       is.null <- base::is.null
[13:34:35.684]                       muffled <- FALSE
[13:34:35.684]                       if (inherits(cond, "message")) {
[13:34:35.684]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.684]                         if (muffled) 
[13:34:35.684]                           invokeRestart("muffleMessage")
[13:34:35.684]                       }
[13:34:35.684]                       else if (inherits(cond, "warning")) {
[13:34:35.684]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.684]                         if (muffled) 
[13:34:35.684]                           invokeRestart("muffleWarning")
[13:34:35.684]                       }
[13:34:35.684]                       else if (inherits(cond, "condition")) {
[13:34:35.684]                         if (!is.null(pattern)) {
[13:34:35.684]                           computeRestarts <- base::computeRestarts
[13:34:35.684]                           grepl <- base::grepl
[13:34:35.684]                           restarts <- computeRestarts(cond)
[13:34:35.684]                           for (restart in restarts) {
[13:34:35.684]                             name <- restart$name
[13:34:35.684]                             if (is.null(name)) 
[13:34:35.684]                               next
[13:34:35.684]                             if (!grepl(pattern, name)) 
[13:34:35.684]                               next
[13:34:35.684]                             invokeRestart(restart)
[13:34:35.684]                             muffled <- TRUE
[13:34:35.684]                             break
[13:34:35.684]                           }
[13:34:35.684]                         }
[13:34:35.684]                       }
[13:34:35.684]                       invisible(muffled)
[13:34:35.684]                     }
[13:34:35.684]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.684]                   }
[13:34:35.684]                 }
[13:34:35.684]             }
[13:34:35.684]         }))
[13:34:35.684]     }, error = function(ex) {
[13:34:35.684]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.684]                 ...future.rng), started = ...future.startTime, 
[13:34:35.684]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.684]             version = "1.8"), class = "FutureResult")
[13:34:35.684]     }, finally = {
[13:34:35.684]         if (!identical(...future.workdir, getwd())) 
[13:34:35.684]             setwd(...future.workdir)
[13:34:35.684]         {
[13:34:35.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.684]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.684]             }
[13:34:35.684]             base::options(...future.oldOptions)
[13:34:35.684]             if (.Platform$OS.type == "windows") {
[13:34:35.684]                 old_names <- names(...future.oldEnvVars)
[13:34:35.684]                 envs <- base::Sys.getenv()
[13:34:35.684]                 names <- names(envs)
[13:34:35.684]                 common <- intersect(names, old_names)
[13:34:35.684]                 added <- setdiff(names, old_names)
[13:34:35.684]                 removed <- setdiff(old_names, names)
[13:34:35.684]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.684]                   envs[common]]
[13:34:35.684]                 NAMES <- toupper(changed)
[13:34:35.684]                 args <- list()
[13:34:35.684]                 for (kk in seq_along(NAMES)) {
[13:34:35.684]                   name <- changed[[kk]]
[13:34:35.684]                   NAME <- NAMES[[kk]]
[13:34:35.684]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.684]                     next
[13:34:35.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.684]                 }
[13:34:35.684]                 NAMES <- toupper(added)
[13:34:35.684]                 for (kk in seq_along(NAMES)) {
[13:34:35.684]                   name <- added[[kk]]
[13:34:35.684]                   NAME <- NAMES[[kk]]
[13:34:35.684]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.684]                     next
[13:34:35.684]                   args[[name]] <- ""
[13:34:35.684]                 }
[13:34:35.684]                 NAMES <- toupper(removed)
[13:34:35.684]                 for (kk in seq_along(NAMES)) {
[13:34:35.684]                   name <- removed[[kk]]
[13:34:35.684]                   NAME <- NAMES[[kk]]
[13:34:35.684]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.684]                     next
[13:34:35.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.684]                 }
[13:34:35.684]                 if (length(args) > 0) 
[13:34:35.684]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.684]             }
[13:34:35.684]             else {
[13:34:35.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.684]             }
[13:34:35.684]             {
[13:34:35.684]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.684]                   0L) {
[13:34:35.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.684]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.684]                   base::options(opts)
[13:34:35.684]                 }
[13:34:35.684]                 {
[13:34:35.684]                   {
[13:34:35.684]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.684]                     NULL
[13:34:35.684]                   }
[13:34:35.684]                   options(future.plan = NULL)
[13:34:35.684]                   if (is.na(NA_character_)) 
[13:34:35.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.684]                     .init = FALSE)
[13:34:35.684]                 }
[13:34:35.684]             }
[13:34:35.684]         }
[13:34:35.684]     })
[13:34:35.684]     if (TRUE) {
[13:34:35.684]         base::sink(type = "output", split = FALSE)
[13:34:35.684]         if (TRUE) {
[13:34:35.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.684]         }
[13:34:35.684]         else {
[13:34:35.684]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.684]         }
[13:34:35.684]         base::close(...future.stdout)
[13:34:35.684]         ...future.stdout <- NULL
[13:34:35.684]     }
[13:34:35.684]     ...future.result$conditions <- ...future.conditions
[13:34:35.684]     ...future.result$finished <- base::Sys.time()
[13:34:35.684]     ...future.result
[13:34:35.684] }
[13:34:35.688] assign_globals() ...
[13:34:35.688] List of 5
[13:34:35.688]  $ ...future.FUN            :function (C, k)  
[13:34:35.688]  $ MoreArgs                 : NULL
[13:34:35.688]  $ ...future.elements_ii    :List of 2
[13:34:35.688]   ..$ :List of 1
[13:34:35.688]   .. ..$ : chr "E"
[13:34:35.688]   ..$ :List of 1
[13:34:35.688]   .. ..$ : int 1
[13:34:35.688]  $ ...future.seeds_ii       : NULL
[13:34:35.688]  $ ...future.globals.maxSize: NULL
[13:34:35.688]  - attr(*, "where")=List of 5
[13:34:35.688]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.688]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.688]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.688]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.688]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.688]  - attr(*, "resolved")= logi FALSE
[13:34:35.688]  - attr(*, "total_size")= num 3488
[13:34:35.688]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.688]  - attr(*, "already-done")= logi TRUE
[13:34:35.699] - reassign environment for ‘...future.FUN’
[13:34:35.699] - copied ‘...future.FUN’ to environment
[13:34:35.700] - copied ‘MoreArgs’ to environment
[13:34:35.700] - copied ‘...future.elements_ii’ to environment
[13:34:35.700] - copied ‘...future.seeds_ii’ to environment
[13:34:35.700] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.700] assign_globals() ... done
[13:34:35.700] requestCore(): workers = 2
[13:34:35.701] Poll #1 (0): usedCores() = 2, workers = 2
[13:34:35.712] result() for MulticoreFuture ...
[13:34:35.712] result() for MulticoreFuture ...
[13:34:35.713] result() for MulticoreFuture ... done
[13:34:35.713] result() for MulticoreFuture ... done
[13:34:35.713] result() for MulticoreFuture ...
[13:34:35.713] result() for MulticoreFuture ... done
[13:34:35.717] MulticoreFuture started
[13:34:35.717] - Launch lazy future ... done
[13:34:35.718] run() for ‘MulticoreFuture’ ... done
[13:34:35.718] plan(): Setting new future strategy stack:
[13:34:35.718] Created future:
[13:34:35.718] List of future strategies:
[13:34:35.718] 1. sequential:
[13:34:35.718]    - args: function (..., envir = parent.frame())
[13:34:35.718]    - tweaked: FALSE
[13:34:35.718]    - call: NULL
[13:34:35.719] plan(): nbrOfWorkers() = 1
[13:34:35.723] plan(): Setting new future strategy stack:
[13:34:35.723] List of future strategies:
[13:34:35.723] 1. multicore:
[13:34:35.723]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.723]    - tweaked: FALSE
[13:34:35.723]    - call: plan(strategy)
[13:34:35.729] plan(): nbrOfWorkers() = 2
[13:34:35.719] MulticoreFuture:
[13:34:35.719] Label: ‘future_mapply-5’
[13:34:35.719] Expression:
[13:34:35.719] {
[13:34:35.719]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.719]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.719]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.719]         on.exit(options(oopts), add = TRUE)
[13:34:35.719]     }
[13:34:35.719]     {
[13:34:35.719]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.719]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.719]         do.call(mapply, args = args)
[13:34:35.719]     }
[13:34:35.719] }
[13:34:35.719] Lazy evaluation: FALSE
[13:34:35.719] Asynchronous evaluation: TRUE
[13:34:35.719] Local evaluation: TRUE
[13:34:35.719] Environment: R_GlobalEnv
[13:34:35.719] Capture standard output: TRUE
[13:34:35.719] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.719] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.719] Packages: <none>
[13:34:35.719] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.719] Resolved: TRUE
[13:34:35.719] Value: <not collected>
[13:34:35.719] Conditions captured: <none>
[13:34:35.719] Early signaling: FALSE
[13:34:35.719] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.719] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.730] Chunk #5 of 5 ... DONE
[13:34:35.731] Launching 5 futures (chunks) ... DONE
[13:34:35.731] Resolving 5 futures (chunks) ...
[13:34:35.731] resolve() on list ...
[13:34:35.731]  recursive: 0
[13:34:35.731]  length: 5
[13:34:35.731] 
[13:34:35.732] Future #1
[13:34:35.732] result() for MulticoreFuture ...
[13:34:35.732] result() for MulticoreFuture ... done
[13:34:35.732] result() for MulticoreFuture ...
[13:34:35.732] result() for MulticoreFuture ... done
[13:34:35.733] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:35.733] - nx: 5
[13:34:35.733] - relay: TRUE
[13:34:35.733] - stdout: TRUE
[13:34:35.733] - signal: TRUE
[13:34:35.733] - resignal: FALSE
[13:34:35.733] - force: TRUE
[13:34:35.733] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[13:34:35.734] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[13:34:35.734]  - until=1
[13:34:35.734]  - relaying element #1
[13:34:35.734] result() for MulticoreFuture ...
[13:34:35.735] result() for MulticoreFuture ... done
[13:34:35.735] result() for MulticoreFuture ...
[13:34:35.735] result() for MulticoreFuture ... done
[13:34:35.735] result() for MulticoreFuture ...
[13:34:35.736] result() for MulticoreFuture ... done
[13:34:35.736] result() for MulticoreFuture ...
[13:34:35.736] result() for MulticoreFuture ... done
[13:34:35.736] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:35.736] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:35.736] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:35.737]  length: 4 (resolved future 1)
[13:34:35.737] Future #2
[13:34:35.737] result() for MulticoreFuture ...
[13:34:35.737] result() for MulticoreFuture ... done
[13:34:35.737] result() for MulticoreFuture ...
[13:34:35.737] result() for MulticoreFuture ... done
[13:34:35.738] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:35.738] - nx: 5
[13:34:35.738] - relay: TRUE
[13:34:35.738] - stdout: TRUE
[13:34:35.738] - signal: TRUE
[13:34:35.738] - resignal: FALSE
[13:34:35.738] - force: TRUE
[13:34:35.739] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:35.739] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:35.739]  - until=2
[13:34:35.739]  - relaying element #2
[13:34:35.739] result() for MulticoreFuture ...
[13:34:35.739] result() for MulticoreFuture ... done
[13:34:35.739] result() for MulticoreFuture ...
[13:34:35.740] result() for MulticoreFuture ... done
[13:34:35.740] result() for MulticoreFuture ...
[13:34:35.740] result() for MulticoreFuture ... done
[13:34:35.740] result() for MulticoreFuture ...
[13:34:35.740] result() for MulticoreFuture ... done
[13:34:35.740] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:35.740] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:35.741] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:35.741]  length: 3 (resolved future 2)
[13:34:35.741] Future #3
[13:34:35.741] result() for MulticoreFuture ...
[13:34:35.741] result() for MulticoreFuture ... done
[13:34:35.741] result() for MulticoreFuture ...
[13:34:35.741] result() for MulticoreFuture ... done
[13:34:35.741] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:34:35.742] - nx: 5
[13:34:35.742] - relay: TRUE
[13:34:35.742] - stdout: TRUE
[13:34:35.742] - signal: TRUE
[13:34:35.742] - resignal: FALSE
[13:34:35.742] - force: TRUE
[13:34:35.742] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:35.743] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:35.743]  - until=3
[13:34:35.743]  - relaying element #3
[13:34:35.743] result() for MulticoreFuture ...
[13:34:35.743] result() for MulticoreFuture ... done
[13:34:35.743] result() for MulticoreFuture ...
[13:34:35.743] result() for MulticoreFuture ... done
[13:34:35.744] result() for MulticoreFuture ...
[13:34:35.744] result() for MulticoreFuture ... done
[13:34:35.744] result() for MulticoreFuture ...
[13:34:35.744] result() for MulticoreFuture ... done
[13:34:35.744] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:35.744] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:35.744] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:34:35.745]  length: 2 (resolved future 3)
[13:34:35.745] Future #4
[13:34:35.745] result() for MulticoreFuture ...
[13:34:35.746] result() for MulticoreFuture ...
[13:34:35.746] result() for MulticoreFuture ... done
[13:34:35.746] result() for MulticoreFuture ... done
[13:34:35.746] result() for MulticoreFuture ...
[13:34:35.747] result() for MulticoreFuture ... done
[13:34:35.747] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:34:35.747] - nx: 5
[13:34:35.747] - relay: TRUE
[13:34:35.747] - stdout: TRUE
[13:34:35.747] - signal: TRUE
[13:34:35.748] - resignal: FALSE
[13:34:35.748] - force: TRUE
[13:34:35.748] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:35.748] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:35.748]  - until=4
[13:34:35.748]  - relaying element #4
[13:34:35.749] result() for MulticoreFuture ...
[13:34:35.749] result() for MulticoreFuture ... done
[13:34:35.749] result() for MulticoreFuture ...
[13:34:35.749] result() for MulticoreFuture ... done
[13:34:35.749] result() for MulticoreFuture ...
[13:34:35.750] result() for MulticoreFuture ... done
[13:34:35.750] result() for MulticoreFuture ...
[13:34:35.750] result() for MulticoreFuture ... done
[13:34:35.750] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:35.750] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:35.750] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:34:35.751]  length: 1 (resolved future 4)
[13:34:35.751] Future #5
[13:34:35.751] result() for MulticoreFuture ...
[13:34:35.752] result() for MulticoreFuture ...
[13:34:35.752] result() for MulticoreFuture ... done
[13:34:35.752] result() for MulticoreFuture ... done
[13:34:35.752] result() for MulticoreFuture ...
[13:34:35.752] result() for MulticoreFuture ... done
[13:34:35.752] signalConditionsASAP(MulticoreFuture, pos=5) ...
[13:34:35.753] - nx: 5
[13:34:35.753] - relay: TRUE
[13:34:35.753] - stdout: TRUE
[13:34:35.753] - signal: TRUE
[13:34:35.753] - resignal: FALSE
[13:34:35.753] - force: TRUE
[13:34:35.753] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:35.753] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:35.753]  - until=5
[13:34:35.756]  - relaying element #5
[13:34:35.757] result() for MulticoreFuture ...
[13:34:35.757] result() for MulticoreFuture ... done
[13:34:35.757] result() for MulticoreFuture ...
[13:34:35.757] result() for MulticoreFuture ... done
[13:34:35.757] result() for MulticoreFuture ...
[13:34:35.757] result() for MulticoreFuture ... done
[13:34:35.758] result() for MulticoreFuture ...
[13:34:35.758] result() for MulticoreFuture ... done
[13:34:35.758] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:35.758] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:35.758] signalConditionsASAP(MulticoreFuture, pos=5) ... done
[13:34:35.758]  length: 0 (resolved future 5)
[13:34:35.758] Relaying remaining futures
[13:34:35.758] signalConditionsASAP(NULL, pos=0) ...
[13:34:35.759] - nx: 5
[13:34:35.759] - relay: TRUE
[13:34:35.759] - stdout: TRUE
[13:34:35.759] - signal: TRUE
[13:34:35.759] - resignal: FALSE
[13:34:35.759] - force: TRUE
[13:34:35.759] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:35.759] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[13:34:35.760] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:35.760] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:35.760] signalConditionsASAP(NULL, pos=0) ... done
[13:34:35.760] resolve() on list ... DONE
[13:34:35.760] result() for MulticoreFuture ...
[13:34:35.760] result() for MulticoreFuture ... done
[13:34:35.760] result() for MulticoreFuture ...
[13:34:35.761] result() for MulticoreFuture ... done
[13:34:35.761] result() for MulticoreFuture ...
[13:34:35.761] result() for MulticoreFuture ... done
[13:34:35.761] result() for MulticoreFuture ...
[13:34:35.761] result() for MulticoreFuture ... done
[13:34:35.761] result() for MulticoreFuture ...
[13:34:35.761] result() for MulticoreFuture ... done
[13:34:35.761] result() for MulticoreFuture ...
[13:34:35.762] result() for MulticoreFuture ... done
[13:34:35.762] result() for MulticoreFuture ...
[13:34:35.762] result() for MulticoreFuture ... done
[13:34:35.762] result() for MulticoreFuture ...
[13:34:35.762] result() for MulticoreFuture ... done
[13:34:35.762] result() for MulticoreFuture ...
[13:34:35.762] result() for MulticoreFuture ... done
[13:34:35.762] result() for MulticoreFuture ...
[13:34:35.762] result() for MulticoreFuture ... done
[13:34:35.763]  - Number of value chunks collected: 5
[13:34:35.763] Resolving 5 futures (chunks) ... DONE
[13:34:35.763] Reducing values from 5 chunks ...
[13:34:35.763]  - Number of values collected after concatenation: 5
[13:34:35.763]  - Number of values expected: 5
[13:34:35.763] Reducing values from 5 chunks ... DONE
[13:34:35.763] future_mapply() ... DONE
[13:34:35.763] future_mapply() ...
[13:34:35.768] Number of chunks: 2
[13:34:35.768] getGlobalsAndPackagesXApply() ...
[13:34:35.769]  - future.globals: TRUE
[13:34:35.769] getGlobalsAndPackages() ...
[13:34:35.769] Searching for globals...
[13:34:35.771] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:35.771] Searching for globals ... DONE
[13:34:35.771] Resolving globals: FALSE
[13:34:35.771] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:35.772] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:35.772] - globals: [1] ‘FUN’
[13:34:35.772] 
[13:34:35.772] getGlobalsAndPackages() ... DONE
[13:34:35.772]  - globals found/used: [n=1] ‘FUN’
[13:34:35.772]  - needed namespaces: [n=0] 
[13:34:35.772] Finding globals ... DONE
[13:34:35.773] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:35.773] List of 2
[13:34:35.773]  $ ...future.FUN:function (C, k)  
[13:34:35.773]  $ MoreArgs     : list()
[13:34:35.773]  - attr(*, "where")=List of 2
[13:34:35.773]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:35.773]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:35.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.773]  - attr(*, "resolved")= logi FALSE
[13:34:35.773]  - attr(*, "total_size")= num NA
[13:34:35.775] Packages to be attached in all futures: [n=0] 
[13:34:35.776] getGlobalsAndPackagesXApply() ... DONE
[13:34:35.776] Number of futures (= number of chunks): 2
[13:34:35.776] Launching 2 futures (chunks) ...
[13:34:35.776] Chunk #1 of 2 ...
[13:34:35.776]  - Finding globals in '...' for chunk #1 ...
[13:34:35.776] getGlobalsAndPackages() ...
[13:34:35.776] Searching for globals...
[13:34:35.777] 
[13:34:35.777] Searching for globals ... DONE
[13:34:35.777] - globals: [0] <none>
[13:34:35.777] getGlobalsAndPackages() ... DONE
[13:34:35.777]    + additional globals found: [n=0] 
[13:34:35.777]    + additional namespaces needed: [n=0] 
[13:34:35.777]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:35.777]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:35.777]  - seeds: <none>
[13:34:35.777]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.778] getGlobalsAndPackages() ...
[13:34:35.778] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.778] Resolving globals: FALSE
[13:34:35.778] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:35.779] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:35.779] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.779] 
[13:34:35.779] getGlobalsAndPackages() ... DONE
[13:34:35.779] run() for ‘Future’ ...
[13:34:35.780] - state: ‘created’
[13:34:35.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.783] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.783]   - Field: ‘label’
[13:34:35.784]   - Field: ‘local’
[13:34:35.784]   - Field: ‘owner’
[13:34:35.786]   - Field: ‘envir’
[13:34:35.786]   - Field: ‘workers’
[13:34:35.786]   - Field: ‘packages’
[13:34:35.786]   - Field: ‘gc’
[13:34:35.787]   - Field: ‘job’
[13:34:35.787]   - Field: ‘conditions’
[13:34:35.787]   - Field: ‘expr’
[13:34:35.787]   - Field: ‘uuid’
[13:34:35.787]   - Field: ‘seed’
[13:34:35.787]   - Field: ‘version’
[13:34:35.787]   - Field: ‘result’
[13:34:35.787]   - Field: ‘asynchronous’
[13:34:35.787]   - Field: ‘calls’
[13:34:35.788]   - Field: ‘globals’
[13:34:35.788]   - Field: ‘stdout’
[13:34:35.788]   - Field: ‘earlySignal’
[13:34:35.788]   - Field: ‘lazy’
[13:34:35.788]   - Field: ‘state’
[13:34:35.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.788] - Launch lazy future ...
[13:34:35.789] Packages needed by the future expression (n = 0): <none>
[13:34:35.789] Packages needed by future strategies (n = 0): <none>
[13:34:35.789] {
[13:34:35.789]     {
[13:34:35.789]         {
[13:34:35.789]             ...future.startTime <- base::Sys.time()
[13:34:35.789]             {
[13:34:35.789]                 {
[13:34:35.789]                   {
[13:34:35.789]                     {
[13:34:35.789]                       base::local({
[13:34:35.789]                         has_future <- base::requireNamespace("future", 
[13:34:35.789]                           quietly = TRUE)
[13:34:35.789]                         if (has_future) {
[13:34:35.789]                           ns <- base::getNamespace("future")
[13:34:35.789]                           version <- ns[[".package"]][["version"]]
[13:34:35.789]                           if (is.null(version)) 
[13:34:35.789]                             version <- utils::packageVersion("future")
[13:34:35.789]                         }
[13:34:35.789]                         else {
[13:34:35.789]                           version <- NULL
[13:34:35.789]                         }
[13:34:35.789]                         if (!has_future || version < "1.8.0") {
[13:34:35.789]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.789]                             "", base::R.version$version.string), 
[13:34:35.789]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.789]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.789]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.789]                               "release", "version")], collapse = " "), 
[13:34:35.789]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.789]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.789]                             info)
[13:34:35.789]                           info <- base::paste(info, collapse = "; ")
[13:34:35.789]                           if (!has_future) {
[13:34:35.789]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.789]                               info)
[13:34:35.789]                           }
[13:34:35.789]                           else {
[13:34:35.789]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.789]                               info, version)
[13:34:35.789]                           }
[13:34:35.789]                           base::stop(msg)
[13:34:35.789]                         }
[13:34:35.789]                       })
[13:34:35.789]                     }
[13:34:35.789]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.789]                     base::options(mc.cores = 1L)
[13:34:35.789]                   }
[13:34:35.789]                   ...future.strategy.old <- future::plan("list")
[13:34:35.789]                   options(future.plan = NULL)
[13:34:35.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.789]                 }
[13:34:35.789]                 ...future.workdir <- getwd()
[13:34:35.789]             }
[13:34:35.789]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.789]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.789]         }
[13:34:35.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.789]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:35.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.789]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.789]             base::names(...future.oldOptions))
[13:34:35.789]     }
[13:34:35.789]     if (FALSE) {
[13:34:35.789]     }
[13:34:35.789]     else {
[13:34:35.789]         if (TRUE) {
[13:34:35.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.789]                 open = "w")
[13:34:35.789]         }
[13:34:35.789]         else {
[13:34:35.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.789]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.789]         }
[13:34:35.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.789]             base::sink(type = "output", split = FALSE)
[13:34:35.789]             base::close(...future.stdout)
[13:34:35.789]         }, add = TRUE)
[13:34:35.789]     }
[13:34:35.789]     ...future.frame <- base::sys.nframe()
[13:34:35.789]     ...future.conditions <- base::list()
[13:34:35.789]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.789]     if (FALSE) {
[13:34:35.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.789]     }
[13:34:35.789]     ...future.result <- base::tryCatch({
[13:34:35.789]         base::withCallingHandlers({
[13:34:35.789]             ...future.value <- base::withVisible(base::local({
[13:34:35.789]                 withCallingHandlers({
[13:34:35.789]                   {
[13:34:35.789]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.789]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.789]                       ...future.globals.maxSize)) {
[13:34:35.789]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.789]                       on.exit(options(oopts), add = TRUE)
[13:34:35.789]                     }
[13:34:35.789]                     {
[13:34:35.789]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.789]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.789]                         USE.NAMES = FALSE)
[13:34:35.789]                       do.call(mapply, args = args)
[13:34:35.789]                     }
[13:34:35.789]                   }
[13:34:35.789]                 }, immediateCondition = function(cond) {
[13:34:35.789]                   save_rds <- function (object, pathname, ...) 
[13:34:35.789]                   {
[13:34:35.789]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.789]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.789]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.789]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.789]                         fi_tmp[["mtime"]])
[13:34:35.789]                     }
[13:34:35.789]                     tryCatch({
[13:34:35.789]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.789]                     }, error = function(ex) {
[13:34:35.789]                       msg <- conditionMessage(ex)
[13:34:35.789]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.789]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.789]                         fi_tmp[["mtime"]], msg)
[13:34:35.789]                       ex$message <- msg
[13:34:35.789]                       stop(ex)
[13:34:35.789]                     })
[13:34:35.789]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.789]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.789]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.789]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.789]                       fi <- file.info(pathname)
[13:34:35.789]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.789]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.789]                         fi[["size"]], fi[["mtime"]])
[13:34:35.789]                       stop(msg)
[13:34:35.789]                     }
[13:34:35.789]                     invisible(pathname)
[13:34:35.789]                   }
[13:34:35.789]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.789]                     rootPath = tempdir()) 
[13:34:35.789]                   {
[13:34:35.789]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.789]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.789]                       tmpdir = path, fileext = ".rds")
[13:34:35.789]                     save_rds(obj, file)
[13:34:35.789]                   }
[13:34:35.789]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.789]                   {
[13:34:35.789]                     inherits <- base::inherits
[13:34:35.789]                     invokeRestart <- base::invokeRestart
[13:34:35.789]                     is.null <- base::is.null
[13:34:35.789]                     muffled <- FALSE
[13:34:35.789]                     if (inherits(cond, "message")) {
[13:34:35.789]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.789]                       if (muffled) 
[13:34:35.789]                         invokeRestart("muffleMessage")
[13:34:35.789]                     }
[13:34:35.789]                     else if (inherits(cond, "warning")) {
[13:34:35.789]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.789]                       if (muffled) 
[13:34:35.789]                         invokeRestart("muffleWarning")
[13:34:35.789]                     }
[13:34:35.789]                     else if (inherits(cond, "condition")) {
[13:34:35.789]                       if (!is.null(pattern)) {
[13:34:35.789]                         computeRestarts <- base::computeRestarts
[13:34:35.789]                         grepl <- base::grepl
[13:34:35.789]                         restarts <- computeRestarts(cond)
[13:34:35.789]                         for (restart in restarts) {
[13:34:35.789]                           name <- restart$name
[13:34:35.789]                           if (is.null(name)) 
[13:34:35.789]                             next
[13:34:35.789]                           if (!grepl(pattern, name)) 
[13:34:35.789]                             next
[13:34:35.789]                           invokeRestart(restart)
[13:34:35.789]                           muffled <- TRUE
[13:34:35.789]                           break
[13:34:35.789]                         }
[13:34:35.789]                       }
[13:34:35.789]                     }
[13:34:35.789]                     invisible(muffled)
[13:34:35.789]                   }
[13:34:35.789]                   muffleCondition(cond)
[13:34:35.789]                 })
[13:34:35.789]             }))
[13:34:35.789]             future::FutureResult(value = ...future.value$value, 
[13:34:35.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.789]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.789]                     ...future.globalenv.names))
[13:34:35.789]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.789]         }, condition = base::local({
[13:34:35.789]             c <- base::c
[13:34:35.789]             inherits <- base::inherits
[13:34:35.789]             invokeRestart <- base::invokeRestart
[13:34:35.789]             length <- base::length
[13:34:35.789]             list <- base::list
[13:34:35.789]             seq.int <- base::seq.int
[13:34:35.789]             signalCondition <- base::signalCondition
[13:34:35.789]             sys.calls <- base::sys.calls
[13:34:35.789]             `[[` <- base::`[[`
[13:34:35.789]             `+` <- base::`+`
[13:34:35.789]             `<<-` <- base::`<<-`
[13:34:35.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.789]                   3L)]
[13:34:35.789]             }
[13:34:35.789]             function(cond) {
[13:34:35.789]                 is_error <- inherits(cond, "error")
[13:34:35.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.789]                   NULL)
[13:34:35.789]                 if (is_error) {
[13:34:35.789]                   sessionInformation <- function() {
[13:34:35.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.789]                       search = base::search(), system = base::Sys.info())
[13:34:35.789]                   }
[13:34:35.789]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.789]                     cond$call), session = sessionInformation(), 
[13:34:35.789]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.789]                   signalCondition(cond)
[13:34:35.789]                 }
[13:34:35.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.789]                 "immediateCondition"))) {
[13:34:35.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.789]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.789]                   if (TRUE && !signal) {
[13:34:35.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.789]                     {
[13:34:35.789]                       inherits <- base::inherits
[13:34:35.789]                       invokeRestart <- base::invokeRestart
[13:34:35.789]                       is.null <- base::is.null
[13:34:35.789]                       muffled <- FALSE
[13:34:35.789]                       if (inherits(cond, "message")) {
[13:34:35.789]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.789]                         if (muffled) 
[13:34:35.789]                           invokeRestart("muffleMessage")
[13:34:35.789]                       }
[13:34:35.789]                       else if (inherits(cond, "warning")) {
[13:34:35.789]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.789]                         if (muffled) 
[13:34:35.789]                           invokeRestart("muffleWarning")
[13:34:35.789]                       }
[13:34:35.789]                       else if (inherits(cond, "condition")) {
[13:34:35.789]                         if (!is.null(pattern)) {
[13:34:35.789]                           computeRestarts <- base::computeRestarts
[13:34:35.789]                           grepl <- base::grepl
[13:34:35.789]                           restarts <- computeRestarts(cond)
[13:34:35.789]                           for (restart in restarts) {
[13:34:35.789]                             name <- restart$name
[13:34:35.789]                             if (is.null(name)) 
[13:34:35.789]                               next
[13:34:35.789]                             if (!grepl(pattern, name)) 
[13:34:35.789]                               next
[13:34:35.789]                             invokeRestart(restart)
[13:34:35.789]                             muffled <- TRUE
[13:34:35.789]                             break
[13:34:35.789]                           }
[13:34:35.789]                         }
[13:34:35.789]                       }
[13:34:35.789]                       invisible(muffled)
[13:34:35.789]                     }
[13:34:35.789]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.789]                   }
[13:34:35.789]                 }
[13:34:35.789]                 else {
[13:34:35.789]                   if (TRUE) {
[13:34:35.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.789]                     {
[13:34:35.789]                       inherits <- base::inherits
[13:34:35.789]                       invokeRestart <- base::invokeRestart
[13:34:35.789]                       is.null <- base::is.null
[13:34:35.789]                       muffled <- FALSE
[13:34:35.789]                       if (inherits(cond, "message")) {
[13:34:35.789]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.789]                         if (muffled) 
[13:34:35.789]                           invokeRestart("muffleMessage")
[13:34:35.789]                       }
[13:34:35.789]                       else if (inherits(cond, "warning")) {
[13:34:35.789]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.789]                         if (muffled) 
[13:34:35.789]                           invokeRestart("muffleWarning")
[13:34:35.789]                       }
[13:34:35.789]                       else if (inherits(cond, "condition")) {
[13:34:35.789]                         if (!is.null(pattern)) {
[13:34:35.789]                           computeRestarts <- base::computeRestarts
[13:34:35.789]                           grepl <- base::grepl
[13:34:35.789]                           restarts <- computeRestarts(cond)
[13:34:35.789]                           for (restart in restarts) {
[13:34:35.789]                             name <- restart$name
[13:34:35.789]                             if (is.null(name)) 
[13:34:35.789]                               next
[13:34:35.789]                             if (!grepl(pattern, name)) 
[13:34:35.789]                               next
[13:34:35.789]                             invokeRestart(restart)
[13:34:35.789]                             muffled <- TRUE
[13:34:35.789]                             break
[13:34:35.789]                           }
[13:34:35.789]                         }
[13:34:35.789]                       }
[13:34:35.789]                       invisible(muffled)
[13:34:35.789]                     }
[13:34:35.789]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.789]                   }
[13:34:35.789]                 }
[13:34:35.789]             }
[13:34:35.789]         }))
[13:34:35.789]     }, error = function(ex) {
[13:34:35.789]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.789]                 ...future.rng), started = ...future.startTime, 
[13:34:35.789]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.789]             version = "1.8"), class = "FutureResult")
[13:34:35.789]     }, finally = {
[13:34:35.789]         if (!identical(...future.workdir, getwd())) 
[13:34:35.789]             setwd(...future.workdir)
[13:34:35.789]         {
[13:34:35.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.789]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.789]             }
[13:34:35.789]             base::options(...future.oldOptions)
[13:34:35.789]             if (.Platform$OS.type == "windows") {
[13:34:35.789]                 old_names <- names(...future.oldEnvVars)
[13:34:35.789]                 envs <- base::Sys.getenv()
[13:34:35.789]                 names <- names(envs)
[13:34:35.789]                 common <- intersect(names, old_names)
[13:34:35.789]                 added <- setdiff(names, old_names)
[13:34:35.789]                 removed <- setdiff(old_names, names)
[13:34:35.789]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.789]                   envs[common]]
[13:34:35.789]                 NAMES <- toupper(changed)
[13:34:35.789]                 args <- list()
[13:34:35.789]                 for (kk in seq_along(NAMES)) {
[13:34:35.789]                   name <- changed[[kk]]
[13:34:35.789]                   NAME <- NAMES[[kk]]
[13:34:35.789]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.789]                     next
[13:34:35.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.789]                 }
[13:34:35.789]                 NAMES <- toupper(added)
[13:34:35.789]                 for (kk in seq_along(NAMES)) {
[13:34:35.789]                   name <- added[[kk]]
[13:34:35.789]                   NAME <- NAMES[[kk]]
[13:34:35.789]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.789]                     next
[13:34:35.789]                   args[[name]] <- ""
[13:34:35.789]                 }
[13:34:35.789]                 NAMES <- toupper(removed)
[13:34:35.789]                 for (kk in seq_along(NAMES)) {
[13:34:35.789]                   name <- removed[[kk]]
[13:34:35.789]                   NAME <- NAMES[[kk]]
[13:34:35.789]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.789]                     next
[13:34:35.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.789]                 }
[13:34:35.789]                 if (length(args) > 0) 
[13:34:35.789]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.789]             }
[13:34:35.789]             else {
[13:34:35.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.789]             }
[13:34:35.789]             {
[13:34:35.789]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.789]                   0L) {
[13:34:35.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.789]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.789]                   base::options(opts)
[13:34:35.789]                 }
[13:34:35.789]                 {
[13:34:35.789]                   {
[13:34:35.789]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.789]                     NULL
[13:34:35.789]                   }
[13:34:35.789]                   options(future.plan = NULL)
[13:34:35.789]                   if (is.na(NA_character_)) 
[13:34:35.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.789]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.789]                     .init = FALSE)
[13:34:35.789]                 }
[13:34:35.789]             }
[13:34:35.789]         }
[13:34:35.789]     })
[13:34:35.789]     if (TRUE) {
[13:34:35.789]         base::sink(type = "output", split = FALSE)
[13:34:35.789]         if (TRUE) {
[13:34:35.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.789]         }
[13:34:35.789]         else {
[13:34:35.789]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.789]         }
[13:34:35.789]         base::close(...future.stdout)
[13:34:35.789]         ...future.stdout <- NULL
[13:34:35.789]     }
[13:34:35.789]     ...future.result$conditions <- ...future.conditions
[13:34:35.789]     ...future.result$finished <- base::Sys.time()
[13:34:35.789]     ...future.result
[13:34:35.789] }
[13:34:35.792] assign_globals() ...
[13:34:35.792] List of 5
[13:34:35.792]  $ ...future.FUN            :function (C, k)  
[13:34:35.792]  $ MoreArgs                 : list()
[13:34:35.792]  $ ...future.elements_ii    :List of 2
[13:34:35.792]   ..$ :List of 2
[13:34:35.792]   .. ..$ : chr "A"
[13:34:35.792]   .. ..$ : chr "B"
[13:34:35.792]   ..$ :List of 2
[13:34:35.792]   .. ..$ : int 5
[13:34:35.792]   .. ..$ : int 4
[13:34:35.792]  $ ...future.seeds_ii       : NULL
[13:34:35.792]  $ ...future.globals.maxSize: NULL
[13:34:35.792]  - attr(*, "where")=List of 5
[13:34:35.792]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.792]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.792]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.792]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.792]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.792]  - attr(*, "resolved")= logi FALSE
[13:34:35.792]  - attr(*, "total_size")= num 3656
[13:34:35.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.792]  - attr(*, "already-done")= logi TRUE
[13:34:35.798] - reassign environment for ‘...future.FUN’
[13:34:35.798] - copied ‘...future.FUN’ to environment
[13:34:35.798] - copied ‘MoreArgs’ to environment
[13:34:35.798] - copied ‘...future.elements_ii’ to environment
[13:34:35.798] - copied ‘...future.seeds_ii’ to environment
[13:34:35.798] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.798] assign_globals() ... done
[13:34:35.798] requestCore(): workers = 2
[13:34:35.800] MulticoreFuture started
[13:34:35.801] - Launch lazy future ... done
[13:34:35.801] run() for ‘MulticoreFuture’ ... done
[13:34:35.801] Created future:
[13:34:35.802] plan(): Setting new future strategy stack:
[13:34:35.802] List of future strategies:
[13:34:35.802] 1. sequential:
[13:34:35.802]    - args: function (..., envir = parent.frame())
[13:34:35.802]    - tweaked: FALSE
[13:34:35.802]    - call: NULL
[13:34:35.803] plan(): nbrOfWorkers() = 1
[13:34:35.805] plan(): Setting new future strategy stack:
[13:34:35.805] List of future strategies:
[13:34:35.805] 1. multicore:
[13:34:35.805]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.805]    - tweaked: FALSE
[13:34:35.805]    - call: plan(strategy)
[13:34:35.810] plan(): nbrOfWorkers() = 2
[13:34:35.802] MulticoreFuture:
[13:34:35.802] Label: ‘future_.mapply-1’
[13:34:35.802] Expression:
[13:34:35.802] {
[13:34:35.802]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.802]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.802]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.802]         on.exit(options(oopts), add = TRUE)
[13:34:35.802]     }
[13:34:35.802]     {
[13:34:35.802]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.802]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.802]         do.call(mapply, args = args)
[13:34:35.802]     }
[13:34:35.802] }
[13:34:35.802] Lazy evaluation: FALSE
[13:34:35.802] Asynchronous evaluation: TRUE
[13:34:35.802] Local evaluation: TRUE
[13:34:35.802] Environment: R_GlobalEnv
[13:34:35.802] Capture standard output: TRUE
[13:34:35.802] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.802] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.802] Packages: <none>
[13:34:35.802] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.802] Resolved: TRUE
[13:34:35.802] Value: <not collected>
[13:34:35.802] Conditions captured: <none>
[13:34:35.802] Early signaling: FALSE
[13:34:35.802] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.802] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.811] Chunk #1 of 2 ... DONE
[13:34:35.811] Chunk #2 of 2 ...
[13:34:35.811]  - Finding globals in '...' for chunk #2 ...
[13:34:35.812] getGlobalsAndPackages() ...
[13:34:35.812] Searching for globals...
[13:34:35.812] 
[13:34:35.812] Searching for globals ... DONE
[13:34:35.813] - globals: [0] <none>
[13:34:35.813] getGlobalsAndPackages() ... DONE
[13:34:35.813]    + additional globals found: [n=0] 
[13:34:35.813]    + additional namespaces needed: [n=0] 
[13:34:35.813]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:35.813]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:35.813]  - seeds: <none>
[13:34:35.813]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.814] getGlobalsAndPackages() ...
[13:34:35.814] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.814] Resolving globals: FALSE
[13:34:35.815] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[13:34:35.816] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:35.816] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.816] 
[13:34:35.816] getGlobalsAndPackages() ... DONE
[13:34:35.817] run() for ‘Future’ ...
[13:34:35.817] - state: ‘created’
[13:34:35.817] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.822] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.822] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.822]   - Field: ‘label’
[13:34:35.823]   - Field: ‘local’
[13:34:35.823]   - Field: ‘owner’
[13:34:35.823]   - Field: ‘envir’
[13:34:35.823]   - Field: ‘workers’
[13:34:35.823]   - Field: ‘packages’
[13:34:35.823]   - Field: ‘gc’
[13:34:35.823]   - Field: ‘job’
[13:34:35.824]   - Field: ‘conditions’
[13:34:35.824]   - Field: ‘expr’
[13:34:35.824]   - Field: ‘uuid’
[13:34:35.824]   - Field: ‘seed’
[13:34:35.824]   - Field: ‘version’
[13:34:35.824]   - Field: ‘result’
[13:34:35.824]   - Field: ‘asynchronous’
[13:34:35.825]   - Field: ‘calls’
[13:34:35.825]   - Field: ‘globals’
[13:34:35.825]   - Field: ‘stdout’
[13:34:35.829]   - Field: ‘earlySignal’
[13:34:35.829]   - Field: ‘lazy’
[13:34:35.829]   - Field: ‘state’
[13:34:35.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.830] - Launch lazy future ...
[13:34:35.831] Packages needed by the future expression (n = 0): <none>
[13:34:35.831] Packages needed by future strategies (n = 0): <none>
[13:34:35.832] {
[13:34:35.832]     {
[13:34:35.832]         {
[13:34:35.832]             ...future.startTime <- base::Sys.time()
[13:34:35.832]             {
[13:34:35.832]                 {
[13:34:35.832]                   {
[13:34:35.832]                     {
[13:34:35.832]                       base::local({
[13:34:35.832]                         has_future <- base::requireNamespace("future", 
[13:34:35.832]                           quietly = TRUE)
[13:34:35.832]                         if (has_future) {
[13:34:35.832]                           ns <- base::getNamespace("future")
[13:34:35.832]                           version <- ns[[".package"]][["version"]]
[13:34:35.832]                           if (is.null(version)) 
[13:34:35.832]                             version <- utils::packageVersion("future")
[13:34:35.832]                         }
[13:34:35.832]                         else {
[13:34:35.832]                           version <- NULL
[13:34:35.832]                         }
[13:34:35.832]                         if (!has_future || version < "1.8.0") {
[13:34:35.832]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.832]                             "", base::R.version$version.string), 
[13:34:35.832]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.832]                               "release", "version")], collapse = " "), 
[13:34:35.832]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.832]                             info)
[13:34:35.832]                           info <- base::paste(info, collapse = "; ")
[13:34:35.832]                           if (!has_future) {
[13:34:35.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.832]                               info)
[13:34:35.832]                           }
[13:34:35.832]                           else {
[13:34:35.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.832]                               info, version)
[13:34:35.832]                           }
[13:34:35.832]                           base::stop(msg)
[13:34:35.832]                         }
[13:34:35.832]                       })
[13:34:35.832]                     }
[13:34:35.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.832]                     base::options(mc.cores = 1L)
[13:34:35.832]                   }
[13:34:35.832]                   ...future.strategy.old <- future::plan("list")
[13:34:35.832]                   options(future.plan = NULL)
[13:34:35.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.832]                 }
[13:34:35.832]                 ...future.workdir <- getwd()
[13:34:35.832]             }
[13:34:35.832]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.832]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.832]         }
[13:34:35.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.832]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:35.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.832]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.832]             base::names(...future.oldOptions))
[13:34:35.832]     }
[13:34:35.832]     if (FALSE) {
[13:34:35.832]     }
[13:34:35.832]     else {
[13:34:35.832]         if (TRUE) {
[13:34:35.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.832]                 open = "w")
[13:34:35.832]         }
[13:34:35.832]         else {
[13:34:35.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.832]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.832]         }
[13:34:35.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.832]             base::sink(type = "output", split = FALSE)
[13:34:35.832]             base::close(...future.stdout)
[13:34:35.832]         }, add = TRUE)
[13:34:35.832]     }
[13:34:35.832]     ...future.frame <- base::sys.nframe()
[13:34:35.832]     ...future.conditions <- base::list()
[13:34:35.832]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.832]     if (FALSE) {
[13:34:35.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.832]     }
[13:34:35.832]     ...future.result <- base::tryCatch({
[13:34:35.832]         base::withCallingHandlers({
[13:34:35.832]             ...future.value <- base::withVisible(base::local({
[13:34:35.832]                 withCallingHandlers({
[13:34:35.832]                   {
[13:34:35.832]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.832]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.832]                       ...future.globals.maxSize)) {
[13:34:35.832]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.832]                       on.exit(options(oopts), add = TRUE)
[13:34:35.832]                     }
[13:34:35.832]                     {
[13:34:35.832]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.832]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.832]                         USE.NAMES = FALSE)
[13:34:35.832]                       do.call(mapply, args = args)
[13:34:35.832]                     }
[13:34:35.832]                   }
[13:34:35.832]                 }, immediateCondition = function(cond) {
[13:34:35.832]                   save_rds <- function (object, pathname, ...) 
[13:34:35.832]                   {
[13:34:35.832]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.832]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.832]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.832]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.832]                         fi_tmp[["mtime"]])
[13:34:35.832]                     }
[13:34:35.832]                     tryCatch({
[13:34:35.832]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.832]                     }, error = function(ex) {
[13:34:35.832]                       msg <- conditionMessage(ex)
[13:34:35.832]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.832]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.832]                         fi_tmp[["mtime"]], msg)
[13:34:35.832]                       ex$message <- msg
[13:34:35.832]                       stop(ex)
[13:34:35.832]                     })
[13:34:35.832]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.832]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.832]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.832]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.832]                       fi <- file.info(pathname)
[13:34:35.832]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.832]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.832]                         fi[["size"]], fi[["mtime"]])
[13:34:35.832]                       stop(msg)
[13:34:35.832]                     }
[13:34:35.832]                     invisible(pathname)
[13:34:35.832]                   }
[13:34:35.832]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.832]                     rootPath = tempdir()) 
[13:34:35.832]                   {
[13:34:35.832]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.832]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.832]                       tmpdir = path, fileext = ".rds")
[13:34:35.832]                     save_rds(obj, file)
[13:34:35.832]                   }
[13:34:35.832]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.832]                   {
[13:34:35.832]                     inherits <- base::inherits
[13:34:35.832]                     invokeRestart <- base::invokeRestart
[13:34:35.832]                     is.null <- base::is.null
[13:34:35.832]                     muffled <- FALSE
[13:34:35.832]                     if (inherits(cond, "message")) {
[13:34:35.832]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.832]                       if (muffled) 
[13:34:35.832]                         invokeRestart("muffleMessage")
[13:34:35.832]                     }
[13:34:35.832]                     else if (inherits(cond, "warning")) {
[13:34:35.832]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.832]                       if (muffled) 
[13:34:35.832]                         invokeRestart("muffleWarning")
[13:34:35.832]                     }
[13:34:35.832]                     else if (inherits(cond, "condition")) {
[13:34:35.832]                       if (!is.null(pattern)) {
[13:34:35.832]                         computeRestarts <- base::computeRestarts
[13:34:35.832]                         grepl <- base::grepl
[13:34:35.832]                         restarts <- computeRestarts(cond)
[13:34:35.832]                         for (restart in restarts) {
[13:34:35.832]                           name <- restart$name
[13:34:35.832]                           if (is.null(name)) 
[13:34:35.832]                             next
[13:34:35.832]                           if (!grepl(pattern, name)) 
[13:34:35.832]                             next
[13:34:35.832]                           invokeRestart(restart)
[13:34:35.832]                           muffled <- TRUE
[13:34:35.832]                           break
[13:34:35.832]                         }
[13:34:35.832]                       }
[13:34:35.832]                     }
[13:34:35.832]                     invisible(muffled)
[13:34:35.832]                   }
[13:34:35.832]                   muffleCondition(cond)
[13:34:35.832]                 })
[13:34:35.832]             }))
[13:34:35.832]             future::FutureResult(value = ...future.value$value, 
[13:34:35.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.832]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.832]                     ...future.globalenv.names))
[13:34:35.832]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.832]         }, condition = base::local({
[13:34:35.832]             c <- base::c
[13:34:35.832]             inherits <- base::inherits
[13:34:35.832]             invokeRestart <- base::invokeRestart
[13:34:35.832]             length <- base::length
[13:34:35.832]             list <- base::list
[13:34:35.832]             seq.int <- base::seq.int
[13:34:35.832]             signalCondition <- base::signalCondition
[13:34:35.832]             sys.calls <- base::sys.calls
[13:34:35.832]             `[[` <- base::`[[`
[13:34:35.832]             `+` <- base::`+`
[13:34:35.832]             `<<-` <- base::`<<-`
[13:34:35.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.832]                   3L)]
[13:34:35.832]             }
[13:34:35.832]             function(cond) {
[13:34:35.832]                 is_error <- inherits(cond, "error")
[13:34:35.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.832]                   NULL)
[13:34:35.832]                 if (is_error) {
[13:34:35.832]                   sessionInformation <- function() {
[13:34:35.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.832]                       search = base::search(), system = base::Sys.info())
[13:34:35.832]                   }
[13:34:35.832]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.832]                     cond$call), session = sessionInformation(), 
[13:34:35.832]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.832]                   signalCondition(cond)
[13:34:35.832]                 }
[13:34:35.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.832]                 "immediateCondition"))) {
[13:34:35.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.832]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.832]                   if (TRUE && !signal) {
[13:34:35.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.832]                     {
[13:34:35.832]                       inherits <- base::inherits
[13:34:35.832]                       invokeRestart <- base::invokeRestart
[13:34:35.832]                       is.null <- base::is.null
[13:34:35.832]                       muffled <- FALSE
[13:34:35.832]                       if (inherits(cond, "message")) {
[13:34:35.832]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.832]                         if (muffled) 
[13:34:35.832]                           invokeRestart("muffleMessage")
[13:34:35.832]                       }
[13:34:35.832]                       else if (inherits(cond, "warning")) {
[13:34:35.832]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.832]                         if (muffled) 
[13:34:35.832]                           invokeRestart("muffleWarning")
[13:34:35.832]                       }
[13:34:35.832]                       else if (inherits(cond, "condition")) {
[13:34:35.832]                         if (!is.null(pattern)) {
[13:34:35.832]                           computeRestarts <- base::computeRestarts
[13:34:35.832]                           grepl <- base::grepl
[13:34:35.832]                           restarts <- computeRestarts(cond)
[13:34:35.832]                           for (restart in restarts) {
[13:34:35.832]                             name <- restart$name
[13:34:35.832]                             if (is.null(name)) 
[13:34:35.832]                               next
[13:34:35.832]                             if (!grepl(pattern, name)) 
[13:34:35.832]                               next
[13:34:35.832]                             invokeRestart(restart)
[13:34:35.832]                             muffled <- TRUE
[13:34:35.832]                             break
[13:34:35.832]                           }
[13:34:35.832]                         }
[13:34:35.832]                       }
[13:34:35.832]                       invisible(muffled)
[13:34:35.832]                     }
[13:34:35.832]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.832]                   }
[13:34:35.832]                 }
[13:34:35.832]                 else {
[13:34:35.832]                   if (TRUE) {
[13:34:35.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.832]                     {
[13:34:35.832]                       inherits <- base::inherits
[13:34:35.832]                       invokeRestart <- base::invokeRestart
[13:34:35.832]                       is.null <- base::is.null
[13:34:35.832]                       muffled <- FALSE
[13:34:35.832]                       if (inherits(cond, "message")) {
[13:34:35.832]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.832]                         if (muffled) 
[13:34:35.832]                           invokeRestart("muffleMessage")
[13:34:35.832]                       }
[13:34:35.832]                       else if (inherits(cond, "warning")) {
[13:34:35.832]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.832]                         if (muffled) 
[13:34:35.832]                           invokeRestart("muffleWarning")
[13:34:35.832]                       }
[13:34:35.832]                       else if (inherits(cond, "condition")) {
[13:34:35.832]                         if (!is.null(pattern)) {
[13:34:35.832]                           computeRestarts <- base::computeRestarts
[13:34:35.832]                           grepl <- base::grepl
[13:34:35.832]                           restarts <- computeRestarts(cond)
[13:34:35.832]                           for (restart in restarts) {
[13:34:35.832]                             name <- restart$name
[13:34:35.832]                             if (is.null(name)) 
[13:34:35.832]                               next
[13:34:35.832]                             if (!grepl(pattern, name)) 
[13:34:35.832]                               next
[13:34:35.832]                             invokeRestart(restart)
[13:34:35.832]                             muffled <- TRUE
[13:34:35.832]                             break
[13:34:35.832]                           }
[13:34:35.832]                         }
[13:34:35.832]                       }
[13:34:35.832]                       invisible(muffled)
[13:34:35.832]                     }
[13:34:35.832]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.832]                   }
[13:34:35.832]                 }
[13:34:35.832]             }
[13:34:35.832]         }))
[13:34:35.832]     }, error = function(ex) {
[13:34:35.832]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.832]                 ...future.rng), started = ...future.startTime, 
[13:34:35.832]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.832]             version = "1.8"), class = "FutureResult")
[13:34:35.832]     }, finally = {
[13:34:35.832]         if (!identical(...future.workdir, getwd())) 
[13:34:35.832]             setwd(...future.workdir)
[13:34:35.832]         {
[13:34:35.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.832]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.832]             }
[13:34:35.832]             base::options(...future.oldOptions)
[13:34:35.832]             if (.Platform$OS.type == "windows") {
[13:34:35.832]                 old_names <- names(...future.oldEnvVars)
[13:34:35.832]                 envs <- base::Sys.getenv()
[13:34:35.832]                 names <- names(envs)
[13:34:35.832]                 common <- intersect(names, old_names)
[13:34:35.832]                 added <- setdiff(names, old_names)
[13:34:35.832]                 removed <- setdiff(old_names, names)
[13:34:35.832]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.832]                   envs[common]]
[13:34:35.832]                 NAMES <- toupper(changed)
[13:34:35.832]                 args <- list()
[13:34:35.832]                 for (kk in seq_along(NAMES)) {
[13:34:35.832]                   name <- changed[[kk]]
[13:34:35.832]                   NAME <- NAMES[[kk]]
[13:34:35.832]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.832]                     next
[13:34:35.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.832]                 }
[13:34:35.832]                 NAMES <- toupper(added)
[13:34:35.832]                 for (kk in seq_along(NAMES)) {
[13:34:35.832]                   name <- added[[kk]]
[13:34:35.832]                   NAME <- NAMES[[kk]]
[13:34:35.832]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.832]                     next
[13:34:35.832]                   args[[name]] <- ""
[13:34:35.832]                 }
[13:34:35.832]                 NAMES <- toupper(removed)
[13:34:35.832]                 for (kk in seq_along(NAMES)) {
[13:34:35.832]                   name <- removed[[kk]]
[13:34:35.832]                   NAME <- NAMES[[kk]]
[13:34:35.832]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.832]                     next
[13:34:35.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.832]                 }
[13:34:35.832]                 if (length(args) > 0) 
[13:34:35.832]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.832]             }
[13:34:35.832]             else {
[13:34:35.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.832]             }
[13:34:35.832]             {
[13:34:35.832]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.832]                   0L) {
[13:34:35.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.832]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.832]                   base::options(opts)
[13:34:35.832]                 }
[13:34:35.832]                 {
[13:34:35.832]                   {
[13:34:35.832]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.832]                     NULL
[13:34:35.832]                   }
[13:34:35.832]                   options(future.plan = NULL)
[13:34:35.832]                   if (is.na(NA_character_)) 
[13:34:35.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.832]                     .init = FALSE)
[13:34:35.832]                 }
[13:34:35.832]             }
[13:34:35.832]         }
[13:34:35.832]     })
[13:34:35.832]     if (TRUE) {
[13:34:35.832]         base::sink(type = "output", split = FALSE)
[13:34:35.832]         if (TRUE) {
[13:34:35.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.832]         }
[13:34:35.832]         else {
[13:34:35.832]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.832]         }
[13:34:35.832]         base::close(...future.stdout)
[13:34:35.832]         ...future.stdout <- NULL
[13:34:35.832]     }
[13:34:35.832]     ...future.result$conditions <- ...future.conditions
[13:34:35.832]     ...future.result$finished <- base::Sys.time()
[13:34:35.832]     ...future.result
[13:34:35.832] }
[13:34:35.835] assign_globals() ...
[13:34:35.836] List of 5
[13:34:35.836]  $ ...future.FUN            :function (C, k)  
[13:34:35.836]  $ MoreArgs                 : list()
[13:34:35.836]  $ ...future.elements_ii    :List of 2
[13:34:35.836]   ..$ :List of 3
[13:34:35.836]   .. ..$ : chr "C"
[13:34:35.836]   .. ..$ : chr "D"
[13:34:35.836]   .. ..$ : chr "E"
[13:34:35.836]   ..$ :List of 3
[13:34:35.836]   .. ..$ : int 3
[13:34:35.836]   .. ..$ : int 2
[13:34:35.836]   .. ..$ : int 1
[13:34:35.836]  $ ...future.seeds_ii       : NULL
[13:34:35.836]  $ ...future.globals.maxSize: NULL
[13:34:35.836]  - attr(*, "where")=List of 5
[13:34:35.836]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.836]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.836]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.836]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.836]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.836]  - attr(*, "resolved")= logi FALSE
[13:34:35.836]  - attr(*, "total_size")= num 3824
[13:34:35.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.836]  - attr(*, "already-done")= logi TRUE
[13:34:35.847] - reassign environment for ‘...future.FUN’
[13:34:35.847] - copied ‘...future.FUN’ to environment
[13:34:35.847] - copied ‘MoreArgs’ to environment
[13:34:35.847] - copied ‘...future.elements_ii’ to environment
[13:34:35.847] - copied ‘...future.seeds_ii’ to environment
[13:34:35.847] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.848] assign_globals() ... done
[13:34:35.848] requestCore(): workers = 2
[13:34:35.850] MulticoreFuture started
[13:34:35.850] - Launch lazy future ... done
[13:34:35.851] run() for ‘MulticoreFuture’ ... done
[13:34:35.851] Created future:
[13:34:35.851] plan(): Setting new future strategy stack:
[13:34:35.852] List of future strategies:
[13:34:35.852] 1. sequential:
[13:34:35.852]    - args: function (..., envir = parent.frame())
[13:34:35.852]    - tweaked: FALSE
[13:34:35.852]    - call: NULL
[13:34:35.852] plan(): nbrOfWorkers() = 1
[13:34:35.854] plan(): Setting new future strategy stack:
[13:34:35.855] List of future strategies:
[13:34:35.855] 1. multicore:
[13:34:35.855]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.855]    - tweaked: FALSE
[13:34:35.855]    - call: plan(strategy)
[13:34:35.860] plan(): nbrOfWorkers() = 2
[13:34:35.851] MulticoreFuture:
[13:34:35.851] Label: ‘future_.mapply-2’
[13:34:35.851] Expression:
[13:34:35.851] {
[13:34:35.851]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.851]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.851]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.851]         on.exit(options(oopts), add = TRUE)
[13:34:35.851]     }
[13:34:35.851]     {
[13:34:35.851]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.851]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.851]         do.call(mapply, args = args)
[13:34:35.851]     }
[13:34:35.851] }
[13:34:35.851] Lazy evaluation: FALSE
[13:34:35.851] Asynchronous evaluation: TRUE
[13:34:35.851] Local evaluation: TRUE
[13:34:35.851] Environment: R_GlobalEnv
[13:34:35.851] Capture standard output: TRUE
[13:34:35.851] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.851] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.851] Packages: <none>
[13:34:35.851] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.851] Resolved: TRUE
[13:34:35.851] Value: <not collected>
[13:34:35.851] Conditions captured: <none>
[13:34:35.851] Early signaling: FALSE
[13:34:35.851] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.851] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.861] Chunk #2 of 2 ... DONE
[13:34:35.861] Launching 2 futures (chunks) ... DONE
[13:34:35.861] Resolving 2 futures (chunks) ...
[13:34:35.861] resolve() on list ...
[13:34:35.862]  recursive: 0
[13:34:35.862]  length: 2
[13:34:35.862] 
[13:34:35.862] Future #1
[13:34:35.862] result() for MulticoreFuture ...
[13:34:35.863] result() for MulticoreFuture ...
[13:34:35.863] result() for MulticoreFuture ... done
[13:34:35.864] result() for MulticoreFuture ... done
[13:34:35.864] result() for MulticoreFuture ...
[13:34:35.864] result() for MulticoreFuture ... done
[13:34:35.864] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:35.865] - nx: 2
[13:34:35.865] - relay: TRUE
[13:34:35.865] - stdout: TRUE
[13:34:35.865] - signal: TRUE
[13:34:35.865] - resignal: FALSE
[13:34:35.865] - force: TRUE
[13:34:35.866] - relayed: [n=2] FALSE, FALSE
[13:34:35.866] - queued futures: [n=2] FALSE, FALSE
[13:34:35.866]  - until=1
[13:34:35.866]  - relaying element #1
[13:34:35.867] result() for MulticoreFuture ...
[13:34:35.867] result() for MulticoreFuture ... done
[13:34:35.867] result() for MulticoreFuture ...
[13:34:35.867] result() for MulticoreFuture ... done
[13:34:35.867] result() for MulticoreFuture ...
[13:34:35.868] result() for MulticoreFuture ... done
[13:34:35.868] result() for MulticoreFuture ...
[13:34:35.868] result() for MulticoreFuture ... done
[13:34:35.868] - relayed: [n=2] TRUE, FALSE
[13:34:35.868] - queued futures: [n=2] TRUE, FALSE
[13:34:35.868] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:35.869]  length: 1 (resolved future 1)
[13:34:35.869] Future #2
[13:34:35.869] result() for MulticoreFuture ...
[13:34:35.870] result() for MulticoreFuture ...
[13:34:35.870] result() for MulticoreFuture ... done
[13:34:35.870] result() for MulticoreFuture ... done
[13:34:35.870] result() for MulticoreFuture ...
[13:34:35.871] result() for MulticoreFuture ... done
[13:34:35.871] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:35.871] - nx: 2
[13:34:35.871] - relay: TRUE
[13:34:35.871] - stdout: TRUE
[13:34:35.871] - signal: TRUE
[13:34:35.871] - resignal: FALSE
[13:34:35.871] - force: TRUE
[13:34:35.872] - relayed: [n=2] TRUE, FALSE
[13:34:35.872] - queued futures: [n=2] TRUE, FALSE
[13:34:35.872]  - until=2
[13:34:35.872]  - relaying element #2
[13:34:35.872] result() for MulticoreFuture ...
[13:34:35.872] result() for MulticoreFuture ... done
[13:34:35.872] result() for MulticoreFuture ...
[13:34:35.872] result() for MulticoreFuture ... done
[13:34:35.873] result() for MulticoreFuture ...
[13:34:35.873] result() for MulticoreFuture ... done
[13:34:35.873] result() for MulticoreFuture ...
[13:34:35.873] result() for MulticoreFuture ... done
[13:34:35.873] - relayed: [n=2] TRUE, TRUE
[13:34:35.873] - queued futures: [n=2] TRUE, TRUE
[13:34:35.873] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:35.873]  length: 0 (resolved future 2)
[13:34:35.874] Relaying remaining futures
[13:34:35.874] signalConditionsASAP(NULL, pos=0) ...
[13:34:35.874] - nx: 2
[13:34:35.874] - relay: TRUE
[13:34:35.874] - stdout: TRUE
[13:34:35.877] - signal: TRUE
[13:34:35.877] - resignal: FALSE
[13:34:35.877] - force: TRUE
[13:34:35.877] - relayed: [n=2] TRUE, TRUE
[13:34:35.878] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:35.878] - relayed: [n=2] TRUE, TRUE
[13:34:35.878] - queued futures: [n=2] TRUE, TRUE
[13:34:35.878] signalConditionsASAP(NULL, pos=0) ... done
[13:34:35.878] resolve() on list ... DONE
[13:34:35.879] result() for MulticoreFuture ...
[13:34:35.879] result() for MulticoreFuture ... done
[13:34:35.879] result() for MulticoreFuture ...
[13:34:35.879] result() for MulticoreFuture ... done
[13:34:35.879] result() for MulticoreFuture ...
[13:34:35.880] result() for MulticoreFuture ... done
[13:34:35.880] result() for MulticoreFuture ...
[13:34:35.880] result() for MulticoreFuture ... done
[13:34:35.880]  - Number of value chunks collected: 2
[13:34:35.880] Resolving 2 futures (chunks) ... DONE
[13:34:35.880] Reducing values from 2 chunks ...
[13:34:35.881]  - Number of values collected after concatenation: 5
[13:34:35.881]  - Number of values expected: 5
[13:34:35.881] Reducing values from 2 chunks ... DONE
[13:34:35.881] future_mapply() ... DONE
[13:34:35.881] future_mapply() ...
[13:34:35.886] Number of chunks: 3
[13:34:35.886] Index remapping (attribute 'ordering'): [n = 5] 4, 2, 5, 3, 1
[13:34:35.886] getGlobalsAndPackagesXApply() ...
[13:34:35.886]  - future.globals: TRUE
[13:34:35.886] getGlobalsAndPackages() ...
[13:34:35.887] Searching for globals...
[13:34:35.888] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:35.888] Searching for globals ... DONE
[13:34:35.888] Resolving globals: FALSE
[13:34:35.889] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:35.889] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:35.890] - globals: [1] ‘FUN’
[13:34:35.890] 
[13:34:35.890] getGlobalsAndPackages() ... DONE
[13:34:35.890]  - globals found/used: [n=1] ‘FUN’
[13:34:35.890]  - needed namespaces: [n=0] 
[13:34:35.890] Finding globals ... DONE
[13:34:35.890] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:35.890] List of 2
[13:34:35.890]  $ ...future.FUN:function (C, k)  
[13:34:35.890]  $ MoreArgs     : NULL
[13:34:35.890]  - attr(*, "where")=List of 2
[13:34:35.890]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:35.890]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:35.890]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.890]  - attr(*, "resolved")= logi FALSE
[13:34:35.890]  - attr(*, "total_size")= num NA
[13:34:35.893] Packages to be attached in all futures: [n=0] 
[13:34:35.893] getGlobalsAndPackagesXApply() ... DONE
[13:34:35.894] Number of futures (= number of chunks): 3
[13:34:35.894] Launching 3 futures (chunks) ...
[13:34:35.894] Chunk #1 of 3 ...
[13:34:35.894]  - Finding globals in '...' for chunk #1 ...
[13:34:35.894] getGlobalsAndPackages() ...
[13:34:35.894] Searching for globals...
[13:34:35.894] 
[13:34:35.895] Searching for globals ... DONE
[13:34:35.895] - globals: [0] <none>
[13:34:35.895] getGlobalsAndPackages() ... DONE
[13:34:35.895]    + additional globals found: [n=0] 
[13:34:35.895]    + additional namespaces needed: [n=0] 
[13:34:35.895]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:35.895]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:34:35.895]  - seeds: <none>
[13:34:35.895]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.895] getGlobalsAndPackages() ...
[13:34:35.895] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.896] Resolving globals: FALSE
[13:34:35.896] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:35.897] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:35.897] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.897] 
[13:34:35.897] getGlobalsAndPackages() ... DONE
[13:34:35.897] run() for ‘Future’ ...
[13:34:35.897] - state: ‘created’
[13:34:35.897] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.901] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.901]   - Field: ‘label’
[13:34:35.901]   - Field: ‘local’
[13:34:35.901]   - Field: ‘owner’
[13:34:35.901]   - Field: ‘envir’
[13:34:35.902]   - Field: ‘workers’
[13:34:35.902]   - Field: ‘packages’
[13:34:35.902]   - Field: ‘gc’
[13:34:35.902]   - Field: ‘job’
[13:34:35.902]   - Field: ‘conditions’
[13:34:35.902]   - Field: ‘expr’
[13:34:35.902]   - Field: ‘uuid’
[13:34:35.902]   - Field: ‘seed’
[13:34:35.902]   - Field: ‘version’
[13:34:35.902]   - Field: ‘result’
[13:34:35.903]   - Field: ‘asynchronous’
[13:34:35.903]   - Field: ‘calls’
[13:34:35.903]   - Field: ‘globals’
[13:34:35.903]   - Field: ‘stdout’
[13:34:35.903]   - Field: ‘earlySignal’
[13:34:35.903]   - Field: ‘lazy’
[13:34:35.903]   - Field: ‘state’
[13:34:35.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.903] - Launch lazy future ...
[13:34:35.904] Packages needed by the future expression (n = 0): <none>
[13:34:35.904] Packages needed by future strategies (n = 0): <none>
[13:34:35.906] {
[13:34:35.906]     {
[13:34:35.906]         {
[13:34:35.906]             ...future.startTime <- base::Sys.time()
[13:34:35.906]             {
[13:34:35.906]                 {
[13:34:35.906]                   {
[13:34:35.906]                     {
[13:34:35.906]                       base::local({
[13:34:35.906]                         has_future <- base::requireNamespace("future", 
[13:34:35.906]                           quietly = TRUE)
[13:34:35.906]                         if (has_future) {
[13:34:35.906]                           ns <- base::getNamespace("future")
[13:34:35.906]                           version <- ns[[".package"]][["version"]]
[13:34:35.906]                           if (is.null(version)) 
[13:34:35.906]                             version <- utils::packageVersion("future")
[13:34:35.906]                         }
[13:34:35.906]                         else {
[13:34:35.906]                           version <- NULL
[13:34:35.906]                         }
[13:34:35.906]                         if (!has_future || version < "1.8.0") {
[13:34:35.906]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.906]                             "", base::R.version$version.string), 
[13:34:35.906]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.906]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.906]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.906]                               "release", "version")], collapse = " "), 
[13:34:35.906]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.906]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.906]                             info)
[13:34:35.906]                           info <- base::paste(info, collapse = "; ")
[13:34:35.906]                           if (!has_future) {
[13:34:35.906]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.906]                               info)
[13:34:35.906]                           }
[13:34:35.906]                           else {
[13:34:35.906]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.906]                               info, version)
[13:34:35.906]                           }
[13:34:35.906]                           base::stop(msg)
[13:34:35.906]                         }
[13:34:35.906]                       })
[13:34:35.906]                     }
[13:34:35.906]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.906]                     base::options(mc.cores = 1L)
[13:34:35.906]                   }
[13:34:35.906]                   ...future.strategy.old <- future::plan("list")
[13:34:35.906]                   options(future.plan = NULL)
[13:34:35.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.906]                 }
[13:34:35.906]                 ...future.workdir <- getwd()
[13:34:35.906]             }
[13:34:35.906]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.906]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.906]         }
[13:34:35.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.906]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:34:35.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.906]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.906]             base::names(...future.oldOptions))
[13:34:35.906]     }
[13:34:35.906]     if (FALSE) {
[13:34:35.906]     }
[13:34:35.906]     else {
[13:34:35.906]         if (TRUE) {
[13:34:35.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.906]                 open = "w")
[13:34:35.906]         }
[13:34:35.906]         else {
[13:34:35.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.906]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.906]         }
[13:34:35.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.906]             base::sink(type = "output", split = FALSE)
[13:34:35.906]             base::close(...future.stdout)
[13:34:35.906]         }, add = TRUE)
[13:34:35.906]     }
[13:34:35.906]     ...future.frame <- base::sys.nframe()
[13:34:35.906]     ...future.conditions <- base::list()
[13:34:35.906]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.906]     if (FALSE) {
[13:34:35.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.906]     }
[13:34:35.906]     ...future.result <- base::tryCatch({
[13:34:35.906]         base::withCallingHandlers({
[13:34:35.906]             ...future.value <- base::withVisible(base::local({
[13:34:35.906]                 withCallingHandlers({
[13:34:35.906]                   {
[13:34:35.906]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.906]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.906]                       ...future.globals.maxSize)) {
[13:34:35.906]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.906]                       on.exit(options(oopts), add = TRUE)
[13:34:35.906]                     }
[13:34:35.906]                     {
[13:34:35.906]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.906]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.906]                         USE.NAMES = FALSE)
[13:34:35.906]                       do.call(mapply, args = args)
[13:34:35.906]                     }
[13:34:35.906]                   }
[13:34:35.906]                 }, immediateCondition = function(cond) {
[13:34:35.906]                   save_rds <- function (object, pathname, ...) 
[13:34:35.906]                   {
[13:34:35.906]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.906]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.906]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.906]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.906]                         fi_tmp[["mtime"]])
[13:34:35.906]                     }
[13:34:35.906]                     tryCatch({
[13:34:35.906]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.906]                     }, error = function(ex) {
[13:34:35.906]                       msg <- conditionMessage(ex)
[13:34:35.906]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.906]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.906]                         fi_tmp[["mtime"]], msg)
[13:34:35.906]                       ex$message <- msg
[13:34:35.906]                       stop(ex)
[13:34:35.906]                     })
[13:34:35.906]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.906]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.906]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.906]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.906]                       fi <- file.info(pathname)
[13:34:35.906]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.906]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.906]                         fi[["size"]], fi[["mtime"]])
[13:34:35.906]                       stop(msg)
[13:34:35.906]                     }
[13:34:35.906]                     invisible(pathname)
[13:34:35.906]                   }
[13:34:35.906]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.906]                     rootPath = tempdir()) 
[13:34:35.906]                   {
[13:34:35.906]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.906]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.906]                       tmpdir = path, fileext = ".rds")
[13:34:35.906]                     save_rds(obj, file)
[13:34:35.906]                   }
[13:34:35.906]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.906]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.906]                   {
[13:34:35.906]                     inherits <- base::inherits
[13:34:35.906]                     invokeRestart <- base::invokeRestart
[13:34:35.906]                     is.null <- base::is.null
[13:34:35.906]                     muffled <- FALSE
[13:34:35.906]                     if (inherits(cond, "message")) {
[13:34:35.906]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.906]                       if (muffled) 
[13:34:35.906]                         invokeRestart("muffleMessage")
[13:34:35.906]                     }
[13:34:35.906]                     else if (inherits(cond, "warning")) {
[13:34:35.906]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.906]                       if (muffled) 
[13:34:35.906]                         invokeRestart("muffleWarning")
[13:34:35.906]                     }
[13:34:35.906]                     else if (inherits(cond, "condition")) {
[13:34:35.906]                       if (!is.null(pattern)) {
[13:34:35.906]                         computeRestarts <- base::computeRestarts
[13:34:35.906]                         grepl <- base::grepl
[13:34:35.906]                         restarts <- computeRestarts(cond)
[13:34:35.906]                         for (restart in restarts) {
[13:34:35.906]                           name <- restart$name
[13:34:35.906]                           if (is.null(name)) 
[13:34:35.906]                             next
[13:34:35.906]                           if (!grepl(pattern, name)) 
[13:34:35.906]                             next
[13:34:35.906]                           invokeRestart(restart)
[13:34:35.906]                           muffled <- TRUE
[13:34:35.906]                           break
[13:34:35.906]                         }
[13:34:35.906]                       }
[13:34:35.906]                     }
[13:34:35.906]                     invisible(muffled)
[13:34:35.906]                   }
[13:34:35.906]                   muffleCondition(cond)
[13:34:35.906]                 })
[13:34:35.906]             }))
[13:34:35.906]             future::FutureResult(value = ...future.value$value, 
[13:34:35.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.906]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.906]                     ...future.globalenv.names))
[13:34:35.906]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.906]         }, condition = base::local({
[13:34:35.906]             c <- base::c
[13:34:35.906]             inherits <- base::inherits
[13:34:35.906]             invokeRestart <- base::invokeRestart
[13:34:35.906]             length <- base::length
[13:34:35.906]             list <- base::list
[13:34:35.906]             seq.int <- base::seq.int
[13:34:35.906]             signalCondition <- base::signalCondition
[13:34:35.906]             sys.calls <- base::sys.calls
[13:34:35.906]             `[[` <- base::`[[`
[13:34:35.906]             `+` <- base::`+`
[13:34:35.906]             `<<-` <- base::`<<-`
[13:34:35.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.906]                   3L)]
[13:34:35.906]             }
[13:34:35.906]             function(cond) {
[13:34:35.906]                 is_error <- inherits(cond, "error")
[13:34:35.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.906]                   NULL)
[13:34:35.906]                 if (is_error) {
[13:34:35.906]                   sessionInformation <- function() {
[13:34:35.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.906]                       search = base::search(), system = base::Sys.info())
[13:34:35.906]                   }
[13:34:35.906]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.906]                     cond$call), session = sessionInformation(), 
[13:34:35.906]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.906]                   signalCondition(cond)
[13:34:35.906]                 }
[13:34:35.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.906]                 "immediateCondition"))) {
[13:34:35.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.906]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.906]                   if (TRUE && !signal) {
[13:34:35.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.906]                     {
[13:34:35.906]                       inherits <- base::inherits
[13:34:35.906]                       invokeRestart <- base::invokeRestart
[13:34:35.906]                       is.null <- base::is.null
[13:34:35.906]                       muffled <- FALSE
[13:34:35.906]                       if (inherits(cond, "message")) {
[13:34:35.906]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.906]                         if (muffled) 
[13:34:35.906]                           invokeRestart("muffleMessage")
[13:34:35.906]                       }
[13:34:35.906]                       else if (inherits(cond, "warning")) {
[13:34:35.906]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.906]                         if (muffled) 
[13:34:35.906]                           invokeRestart("muffleWarning")
[13:34:35.906]                       }
[13:34:35.906]                       else if (inherits(cond, "condition")) {
[13:34:35.906]                         if (!is.null(pattern)) {
[13:34:35.906]                           computeRestarts <- base::computeRestarts
[13:34:35.906]                           grepl <- base::grepl
[13:34:35.906]                           restarts <- computeRestarts(cond)
[13:34:35.906]                           for (restart in restarts) {
[13:34:35.906]                             name <- restart$name
[13:34:35.906]                             if (is.null(name)) 
[13:34:35.906]                               next
[13:34:35.906]                             if (!grepl(pattern, name)) 
[13:34:35.906]                               next
[13:34:35.906]                             invokeRestart(restart)
[13:34:35.906]                             muffled <- TRUE
[13:34:35.906]                             break
[13:34:35.906]                           }
[13:34:35.906]                         }
[13:34:35.906]                       }
[13:34:35.906]                       invisible(muffled)
[13:34:35.906]                     }
[13:34:35.906]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.906]                   }
[13:34:35.906]                 }
[13:34:35.906]                 else {
[13:34:35.906]                   if (TRUE) {
[13:34:35.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.906]                     {
[13:34:35.906]                       inherits <- base::inherits
[13:34:35.906]                       invokeRestart <- base::invokeRestart
[13:34:35.906]                       is.null <- base::is.null
[13:34:35.906]                       muffled <- FALSE
[13:34:35.906]                       if (inherits(cond, "message")) {
[13:34:35.906]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.906]                         if (muffled) 
[13:34:35.906]                           invokeRestart("muffleMessage")
[13:34:35.906]                       }
[13:34:35.906]                       else if (inherits(cond, "warning")) {
[13:34:35.906]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.906]                         if (muffled) 
[13:34:35.906]                           invokeRestart("muffleWarning")
[13:34:35.906]                       }
[13:34:35.906]                       else if (inherits(cond, "condition")) {
[13:34:35.906]                         if (!is.null(pattern)) {
[13:34:35.906]                           computeRestarts <- base::computeRestarts
[13:34:35.906]                           grepl <- base::grepl
[13:34:35.906]                           restarts <- computeRestarts(cond)
[13:34:35.906]                           for (restart in restarts) {
[13:34:35.906]                             name <- restart$name
[13:34:35.906]                             if (is.null(name)) 
[13:34:35.906]                               next
[13:34:35.906]                             if (!grepl(pattern, name)) 
[13:34:35.906]                               next
[13:34:35.906]                             invokeRestart(restart)
[13:34:35.906]                             muffled <- TRUE
[13:34:35.906]                             break
[13:34:35.906]                           }
[13:34:35.906]                         }
[13:34:35.906]                       }
[13:34:35.906]                       invisible(muffled)
[13:34:35.906]                     }
[13:34:35.906]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.906]                   }
[13:34:35.906]                 }
[13:34:35.906]             }
[13:34:35.906]         }))
[13:34:35.906]     }, error = function(ex) {
[13:34:35.906]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.906]                 ...future.rng), started = ...future.startTime, 
[13:34:35.906]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.906]             version = "1.8"), class = "FutureResult")
[13:34:35.906]     }, finally = {
[13:34:35.906]         if (!identical(...future.workdir, getwd())) 
[13:34:35.906]             setwd(...future.workdir)
[13:34:35.906]         {
[13:34:35.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.906]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.906]             }
[13:34:35.906]             base::options(...future.oldOptions)
[13:34:35.906]             if (.Platform$OS.type == "windows") {
[13:34:35.906]                 old_names <- names(...future.oldEnvVars)
[13:34:35.906]                 envs <- base::Sys.getenv()
[13:34:35.906]                 names <- names(envs)
[13:34:35.906]                 common <- intersect(names, old_names)
[13:34:35.906]                 added <- setdiff(names, old_names)
[13:34:35.906]                 removed <- setdiff(old_names, names)
[13:34:35.906]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.906]                   envs[common]]
[13:34:35.906]                 NAMES <- toupper(changed)
[13:34:35.906]                 args <- list()
[13:34:35.906]                 for (kk in seq_along(NAMES)) {
[13:34:35.906]                   name <- changed[[kk]]
[13:34:35.906]                   NAME <- NAMES[[kk]]
[13:34:35.906]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.906]                     next
[13:34:35.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.906]                 }
[13:34:35.906]                 NAMES <- toupper(added)
[13:34:35.906]                 for (kk in seq_along(NAMES)) {
[13:34:35.906]                   name <- added[[kk]]
[13:34:35.906]                   NAME <- NAMES[[kk]]
[13:34:35.906]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.906]                     next
[13:34:35.906]                   args[[name]] <- ""
[13:34:35.906]                 }
[13:34:35.906]                 NAMES <- toupper(removed)
[13:34:35.906]                 for (kk in seq_along(NAMES)) {
[13:34:35.906]                   name <- removed[[kk]]
[13:34:35.906]                   NAME <- NAMES[[kk]]
[13:34:35.906]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.906]                     next
[13:34:35.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.906]                 }
[13:34:35.906]                 if (length(args) > 0) 
[13:34:35.906]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.906]             }
[13:34:35.906]             else {
[13:34:35.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.906]             }
[13:34:35.906]             {
[13:34:35.906]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.906]                   0L) {
[13:34:35.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.906]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.906]                   base::options(opts)
[13:34:35.906]                 }
[13:34:35.906]                 {
[13:34:35.906]                   {
[13:34:35.906]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.906]                     NULL
[13:34:35.906]                   }
[13:34:35.906]                   options(future.plan = NULL)
[13:34:35.906]                   if (is.na(NA_character_)) 
[13:34:35.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.906]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.906]                     .init = FALSE)
[13:34:35.906]                 }
[13:34:35.906]             }
[13:34:35.906]         }
[13:34:35.906]     })
[13:34:35.906]     if (TRUE) {
[13:34:35.906]         base::sink(type = "output", split = FALSE)
[13:34:35.906]         if (TRUE) {
[13:34:35.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.906]         }
[13:34:35.906]         else {
[13:34:35.906]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.906]         }
[13:34:35.906]         base::close(...future.stdout)
[13:34:35.906]         ...future.stdout <- NULL
[13:34:35.906]     }
[13:34:35.906]     ...future.result$conditions <- ...future.conditions
[13:34:35.906]     ...future.result$finished <- base::Sys.time()
[13:34:35.906]     ...future.result
[13:34:35.906] }
[13:34:35.909] assign_globals() ...
[13:34:35.909] List of 5
[13:34:35.909]  $ ...future.FUN            :function (C, k)  
[13:34:35.909]  $ MoreArgs                 : NULL
[13:34:35.909]  $ ...future.elements_ii    :List of 2
[13:34:35.909]   ..$ :List of 2
[13:34:35.909]   .. ..$ : chr "D"
[13:34:35.909]   .. ..$ : chr "B"
[13:34:35.909]   ..$ :List of 2
[13:34:35.909]   .. ..$ : int 2
[13:34:35.909]   .. ..$ : int 4
[13:34:35.909]  $ ...future.seeds_ii       : NULL
[13:34:35.909]  $ ...future.globals.maxSize: NULL
[13:34:35.909]  - attr(*, "where")=List of 5
[13:34:35.909]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.909]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.909]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.909]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.909]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.909]  - attr(*, "resolved")= logi FALSE
[13:34:35.909]  - attr(*, "total_size")= num 3656
[13:34:35.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.909]  - attr(*, "already-done")= logi TRUE
[13:34:35.915] - reassign environment for ‘...future.FUN’
[13:34:35.915] - copied ‘...future.FUN’ to environment
[13:34:35.915] - copied ‘MoreArgs’ to environment
[13:34:35.915] - copied ‘...future.elements_ii’ to environment
[13:34:35.915] - copied ‘...future.seeds_ii’ to environment
[13:34:35.915] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.915] assign_globals() ... done
[13:34:35.915] requestCore(): workers = 2
[13:34:35.918] MulticoreFuture started
[13:34:35.918] - Launch lazy future ... done
[13:34:35.919] plan(): Setting new future strategy stack:
[13:34:35.919] run() for ‘MulticoreFuture’ ... done
[13:34:35.919] Created future:
[13:34:35.919] List of future strategies:
[13:34:35.919] 1. sequential:
[13:34:35.919]    - args: function (..., envir = parent.frame())
[13:34:35.919]    - tweaked: FALSE
[13:34:35.919]    - call: NULL
[13:34:35.920] plan(): nbrOfWorkers() = 1
[13:34:35.922] plan(): Setting new future strategy stack:
[13:34:35.923] List of future strategies:
[13:34:35.923] 1. multicore:
[13:34:35.923]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.923]    - tweaked: FALSE
[13:34:35.923]    - call: plan(strategy)
[13:34:35.928] plan(): nbrOfWorkers() = 2
[13:34:35.920] MulticoreFuture:
[13:34:35.920] Label: ‘future_mapply-1’
[13:34:35.920] Expression:
[13:34:35.920] {
[13:34:35.920]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.920]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.920]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.920]         on.exit(options(oopts), add = TRUE)
[13:34:35.920]     }
[13:34:35.920]     {
[13:34:35.920]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.920]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.920]         do.call(mapply, args = args)
[13:34:35.920]     }
[13:34:35.920] }
[13:34:35.920] Lazy evaluation: FALSE
[13:34:35.920] Asynchronous evaluation: TRUE
[13:34:35.920] Local evaluation: TRUE
[13:34:35.920] Environment: R_GlobalEnv
[13:34:35.920] Capture standard output: TRUE
[13:34:35.920] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.920] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.920] Packages: <none>
[13:34:35.920] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.920] Resolved: TRUE
[13:34:35.920] Value: <not collected>
[13:34:35.920] Conditions captured: <none>
[13:34:35.920] Early signaling: FALSE
[13:34:35.920] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.920] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.929] Chunk #1 of 3 ... DONE
[13:34:35.929] Chunk #2 of 3 ...
[13:34:35.929]  - Finding globals in '...' for chunk #2 ...
[13:34:35.929] getGlobalsAndPackages() ...
[13:34:35.930] Searching for globals...
[13:34:35.930] 
[13:34:35.930] Searching for globals ... DONE
[13:34:35.931] - globals: [0] <none>
[13:34:35.931] getGlobalsAndPackages() ... DONE
[13:34:35.931]    + additional globals found: [n=0] 
[13:34:35.931]    + additional namespaces needed: [n=0] 
[13:34:35.931]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:35.931]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:34:35.931]  - seeds: <none>
[13:34:35.931]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.932] getGlobalsAndPackages() ...
[13:34:35.932] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.932] Resolving globals: FALSE
[13:34:35.933] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:35.934] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:35.934] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.934] 
[13:34:35.934] getGlobalsAndPackages() ... DONE
[13:34:35.935] run() for ‘Future’ ...
[13:34:35.935] - state: ‘created’
[13:34:35.935] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.940] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.940] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.940]   - Field: ‘label’
[13:34:35.940]   - Field: ‘local’
[13:34:35.940]   - Field: ‘owner’
[13:34:35.940]   - Field: ‘envir’
[13:34:35.941]   - Field: ‘workers’
[13:34:35.941]   - Field: ‘packages’
[13:34:35.941]   - Field: ‘gc’
[13:34:35.941]   - Field: ‘job’
[13:34:35.941]   - Field: ‘conditions’
[13:34:35.941]   - Field: ‘expr’
[13:34:35.942]   - Field: ‘uuid’
[13:34:35.942]   - Field: ‘seed’
[13:34:35.942]   - Field: ‘version’
[13:34:35.942]   - Field: ‘result’
[13:34:35.942]   - Field: ‘asynchronous’
[13:34:35.942]   - Field: ‘calls’
[13:34:35.943]   - Field: ‘globals’
[13:34:35.943]   - Field: ‘stdout’
[13:34:35.943]   - Field: ‘earlySignal’
[13:34:35.943]   - Field: ‘lazy’
[13:34:35.943]   - Field: ‘state’
[13:34:35.943] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.944] - Launch lazy future ...
[13:34:35.944] Packages needed by the future expression (n = 0): <none>
[13:34:35.944] Packages needed by future strategies (n = 0): <none>
[13:34:35.945] {
[13:34:35.945]     {
[13:34:35.945]         {
[13:34:35.945]             ...future.startTime <- base::Sys.time()
[13:34:35.945]             {
[13:34:35.945]                 {
[13:34:35.945]                   {
[13:34:35.945]                     {
[13:34:35.945]                       base::local({
[13:34:35.945]                         has_future <- base::requireNamespace("future", 
[13:34:35.945]                           quietly = TRUE)
[13:34:35.945]                         if (has_future) {
[13:34:35.945]                           ns <- base::getNamespace("future")
[13:34:35.945]                           version <- ns[[".package"]][["version"]]
[13:34:35.945]                           if (is.null(version)) 
[13:34:35.945]                             version <- utils::packageVersion("future")
[13:34:35.945]                         }
[13:34:35.945]                         else {
[13:34:35.945]                           version <- NULL
[13:34:35.945]                         }
[13:34:35.945]                         if (!has_future || version < "1.8.0") {
[13:34:35.945]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.945]                             "", base::R.version$version.string), 
[13:34:35.945]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.945]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.945]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.945]                               "release", "version")], collapse = " "), 
[13:34:35.945]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.945]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.945]                             info)
[13:34:35.945]                           info <- base::paste(info, collapse = "; ")
[13:34:35.945]                           if (!has_future) {
[13:34:35.945]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.945]                               info)
[13:34:35.945]                           }
[13:34:35.945]                           else {
[13:34:35.945]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.945]                               info, version)
[13:34:35.945]                           }
[13:34:35.945]                           base::stop(msg)
[13:34:35.945]                         }
[13:34:35.945]                       })
[13:34:35.945]                     }
[13:34:35.945]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.945]                     base::options(mc.cores = 1L)
[13:34:35.945]                   }
[13:34:35.945]                   ...future.strategy.old <- future::plan("list")
[13:34:35.945]                   options(future.plan = NULL)
[13:34:35.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.945]                 }
[13:34:35.945]                 ...future.workdir <- getwd()
[13:34:35.945]             }
[13:34:35.945]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.945]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.945]         }
[13:34:35.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.945]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:34:35.945]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.945]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.945]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.945]             base::names(...future.oldOptions))
[13:34:35.945]     }
[13:34:35.945]     if (FALSE) {
[13:34:35.945]     }
[13:34:35.945]     else {
[13:34:35.945]         if (TRUE) {
[13:34:35.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.945]                 open = "w")
[13:34:35.945]         }
[13:34:35.945]         else {
[13:34:35.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.945]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.945]         }
[13:34:35.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.945]             base::sink(type = "output", split = FALSE)
[13:34:35.945]             base::close(...future.stdout)
[13:34:35.945]         }, add = TRUE)
[13:34:35.945]     }
[13:34:35.945]     ...future.frame <- base::sys.nframe()
[13:34:35.945]     ...future.conditions <- base::list()
[13:34:35.945]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.945]     if (FALSE) {
[13:34:35.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.945]     }
[13:34:35.945]     ...future.result <- base::tryCatch({
[13:34:35.945]         base::withCallingHandlers({
[13:34:35.945]             ...future.value <- base::withVisible(base::local({
[13:34:35.945]                 withCallingHandlers({
[13:34:35.945]                   {
[13:34:35.945]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.945]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.945]                       ...future.globals.maxSize)) {
[13:34:35.945]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.945]                       on.exit(options(oopts), add = TRUE)
[13:34:35.945]                     }
[13:34:35.945]                     {
[13:34:35.945]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.945]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.945]                         USE.NAMES = FALSE)
[13:34:35.945]                       do.call(mapply, args = args)
[13:34:35.945]                     }
[13:34:35.945]                   }
[13:34:35.945]                 }, immediateCondition = function(cond) {
[13:34:35.945]                   save_rds <- function (object, pathname, ...) 
[13:34:35.945]                   {
[13:34:35.945]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.945]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.945]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.945]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.945]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.945]                         fi_tmp[["mtime"]])
[13:34:35.945]                     }
[13:34:35.945]                     tryCatch({
[13:34:35.945]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.945]                     }, error = function(ex) {
[13:34:35.945]                       msg <- conditionMessage(ex)
[13:34:35.945]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.945]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.945]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.945]                         fi_tmp[["mtime"]], msg)
[13:34:35.945]                       ex$message <- msg
[13:34:35.945]                       stop(ex)
[13:34:35.945]                     })
[13:34:35.945]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.945]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.945]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.945]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.945]                       fi <- file.info(pathname)
[13:34:35.945]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.945]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.945]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.945]                         fi[["size"]], fi[["mtime"]])
[13:34:35.945]                       stop(msg)
[13:34:35.945]                     }
[13:34:35.945]                     invisible(pathname)
[13:34:35.945]                   }
[13:34:35.945]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.945]                     rootPath = tempdir()) 
[13:34:35.945]                   {
[13:34:35.945]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.945]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.945]                       tmpdir = path, fileext = ".rds")
[13:34:35.945]                     save_rds(obj, file)
[13:34:35.945]                   }
[13:34:35.945]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.945]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.945]                   {
[13:34:35.945]                     inherits <- base::inherits
[13:34:35.945]                     invokeRestart <- base::invokeRestart
[13:34:35.945]                     is.null <- base::is.null
[13:34:35.945]                     muffled <- FALSE
[13:34:35.945]                     if (inherits(cond, "message")) {
[13:34:35.945]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.945]                       if (muffled) 
[13:34:35.945]                         invokeRestart("muffleMessage")
[13:34:35.945]                     }
[13:34:35.945]                     else if (inherits(cond, "warning")) {
[13:34:35.945]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.945]                       if (muffled) 
[13:34:35.945]                         invokeRestart("muffleWarning")
[13:34:35.945]                     }
[13:34:35.945]                     else if (inherits(cond, "condition")) {
[13:34:35.945]                       if (!is.null(pattern)) {
[13:34:35.945]                         computeRestarts <- base::computeRestarts
[13:34:35.945]                         grepl <- base::grepl
[13:34:35.945]                         restarts <- computeRestarts(cond)
[13:34:35.945]                         for (restart in restarts) {
[13:34:35.945]                           name <- restart$name
[13:34:35.945]                           if (is.null(name)) 
[13:34:35.945]                             next
[13:34:35.945]                           if (!grepl(pattern, name)) 
[13:34:35.945]                             next
[13:34:35.945]                           invokeRestart(restart)
[13:34:35.945]                           muffled <- TRUE
[13:34:35.945]                           break
[13:34:35.945]                         }
[13:34:35.945]                       }
[13:34:35.945]                     }
[13:34:35.945]                     invisible(muffled)
[13:34:35.945]                   }
[13:34:35.945]                   muffleCondition(cond)
[13:34:35.945]                 })
[13:34:35.945]             }))
[13:34:35.945]             future::FutureResult(value = ...future.value$value, 
[13:34:35.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.945]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.945]                     ...future.globalenv.names))
[13:34:35.945]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.945]         }, condition = base::local({
[13:34:35.945]             c <- base::c
[13:34:35.945]             inherits <- base::inherits
[13:34:35.945]             invokeRestart <- base::invokeRestart
[13:34:35.945]             length <- base::length
[13:34:35.945]             list <- base::list
[13:34:35.945]             seq.int <- base::seq.int
[13:34:35.945]             signalCondition <- base::signalCondition
[13:34:35.945]             sys.calls <- base::sys.calls
[13:34:35.945]             `[[` <- base::`[[`
[13:34:35.945]             `+` <- base::`+`
[13:34:35.945]             `<<-` <- base::`<<-`
[13:34:35.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.945]                   3L)]
[13:34:35.945]             }
[13:34:35.945]             function(cond) {
[13:34:35.945]                 is_error <- inherits(cond, "error")
[13:34:35.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.945]                   NULL)
[13:34:35.945]                 if (is_error) {
[13:34:35.945]                   sessionInformation <- function() {
[13:34:35.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.945]                       search = base::search(), system = base::Sys.info())
[13:34:35.945]                   }
[13:34:35.945]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.945]                     cond$call), session = sessionInformation(), 
[13:34:35.945]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.945]                   signalCondition(cond)
[13:34:35.945]                 }
[13:34:35.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.945]                 "immediateCondition"))) {
[13:34:35.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.945]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.945]                   if (TRUE && !signal) {
[13:34:35.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.945]                     {
[13:34:35.945]                       inherits <- base::inherits
[13:34:35.945]                       invokeRestart <- base::invokeRestart
[13:34:35.945]                       is.null <- base::is.null
[13:34:35.945]                       muffled <- FALSE
[13:34:35.945]                       if (inherits(cond, "message")) {
[13:34:35.945]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.945]                         if (muffled) 
[13:34:35.945]                           invokeRestart("muffleMessage")
[13:34:35.945]                       }
[13:34:35.945]                       else if (inherits(cond, "warning")) {
[13:34:35.945]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.945]                         if (muffled) 
[13:34:35.945]                           invokeRestart("muffleWarning")
[13:34:35.945]                       }
[13:34:35.945]                       else if (inherits(cond, "condition")) {
[13:34:35.945]                         if (!is.null(pattern)) {
[13:34:35.945]                           computeRestarts <- base::computeRestarts
[13:34:35.945]                           grepl <- base::grepl
[13:34:35.945]                           restarts <- computeRestarts(cond)
[13:34:35.945]                           for (restart in restarts) {
[13:34:35.945]                             name <- restart$name
[13:34:35.945]                             if (is.null(name)) 
[13:34:35.945]                               next
[13:34:35.945]                             if (!grepl(pattern, name)) 
[13:34:35.945]                               next
[13:34:35.945]                             invokeRestart(restart)
[13:34:35.945]                             muffled <- TRUE
[13:34:35.945]                             break
[13:34:35.945]                           }
[13:34:35.945]                         }
[13:34:35.945]                       }
[13:34:35.945]                       invisible(muffled)
[13:34:35.945]                     }
[13:34:35.945]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.945]                   }
[13:34:35.945]                 }
[13:34:35.945]                 else {
[13:34:35.945]                   if (TRUE) {
[13:34:35.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.945]                     {
[13:34:35.945]                       inherits <- base::inherits
[13:34:35.945]                       invokeRestart <- base::invokeRestart
[13:34:35.945]                       is.null <- base::is.null
[13:34:35.945]                       muffled <- FALSE
[13:34:35.945]                       if (inherits(cond, "message")) {
[13:34:35.945]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.945]                         if (muffled) 
[13:34:35.945]                           invokeRestart("muffleMessage")
[13:34:35.945]                       }
[13:34:35.945]                       else if (inherits(cond, "warning")) {
[13:34:35.945]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.945]                         if (muffled) 
[13:34:35.945]                           invokeRestart("muffleWarning")
[13:34:35.945]                       }
[13:34:35.945]                       else if (inherits(cond, "condition")) {
[13:34:35.945]                         if (!is.null(pattern)) {
[13:34:35.945]                           computeRestarts <- base::computeRestarts
[13:34:35.945]                           grepl <- base::grepl
[13:34:35.945]                           restarts <- computeRestarts(cond)
[13:34:35.945]                           for (restart in restarts) {
[13:34:35.945]                             name <- restart$name
[13:34:35.945]                             if (is.null(name)) 
[13:34:35.945]                               next
[13:34:35.945]                             if (!grepl(pattern, name)) 
[13:34:35.945]                               next
[13:34:35.945]                             invokeRestart(restart)
[13:34:35.945]                             muffled <- TRUE
[13:34:35.945]                             break
[13:34:35.945]                           }
[13:34:35.945]                         }
[13:34:35.945]                       }
[13:34:35.945]                       invisible(muffled)
[13:34:35.945]                     }
[13:34:35.945]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.945]                   }
[13:34:35.945]                 }
[13:34:35.945]             }
[13:34:35.945]         }))
[13:34:35.945]     }, error = function(ex) {
[13:34:35.945]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.945]                 ...future.rng), started = ...future.startTime, 
[13:34:35.945]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.945]             version = "1.8"), class = "FutureResult")
[13:34:35.945]     }, finally = {
[13:34:35.945]         if (!identical(...future.workdir, getwd())) 
[13:34:35.945]             setwd(...future.workdir)
[13:34:35.945]         {
[13:34:35.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.945]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.945]             }
[13:34:35.945]             base::options(...future.oldOptions)
[13:34:35.945]             if (.Platform$OS.type == "windows") {
[13:34:35.945]                 old_names <- names(...future.oldEnvVars)
[13:34:35.945]                 envs <- base::Sys.getenv()
[13:34:35.945]                 names <- names(envs)
[13:34:35.945]                 common <- intersect(names, old_names)
[13:34:35.945]                 added <- setdiff(names, old_names)
[13:34:35.945]                 removed <- setdiff(old_names, names)
[13:34:35.945]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.945]                   envs[common]]
[13:34:35.945]                 NAMES <- toupper(changed)
[13:34:35.945]                 args <- list()
[13:34:35.945]                 for (kk in seq_along(NAMES)) {
[13:34:35.945]                   name <- changed[[kk]]
[13:34:35.945]                   NAME <- NAMES[[kk]]
[13:34:35.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.945]                     next
[13:34:35.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.945]                 }
[13:34:35.945]                 NAMES <- toupper(added)
[13:34:35.945]                 for (kk in seq_along(NAMES)) {
[13:34:35.945]                   name <- added[[kk]]
[13:34:35.945]                   NAME <- NAMES[[kk]]
[13:34:35.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.945]                     next
[13:34:35.945]                   args[[name]] <- ""
[13:34:35.945]                 }
[13:34:35.945]                 NAMES <- toupper(removed)
[13:34:35.945]                 for (kk in seq_along(NAMES)) {
[13:34:35.945]                   name <- removed[[kk]]
[13:34:35.945]                   NAME <- NAMES[[kk]]
[13:34:35.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.945]                     next
[13:34:35.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.945]                 }
[13:34:35.945]                 if (length(args) > 0) 
[13:34:35.945]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.945]             }
[13:34:35.945]             else {
[13:34:35.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.945]             }
[13:34:35.945]             {
[13:34:35.945]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.945]                   0L) {
[13:34:35.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.945]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.945]                   base::options(opts)
[13:34:35.945]                 }
[13:34:35.945]                 {
[13:34:35.945]                   {
[13:34:35.945]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.945]                     NULL
[13:34:35.945]                   }
[13:34:35.945]                   options(future.plan = NULL)
[13:34:35.945]                   if (is.na(NA_character_)) 
[13:34:35.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.945]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.945]                     .init = FALSE)
[13:34:35.945]                 }
[13:34:35.945]             }
[13:34:35.945]         }
[13:34:35.945]     })
[13:34:35.945]     if (TRUE) {
[13:34:35.945]         base::sink(type = "output", split = FALSE)
[13:34:35.945]         if (TRUE) {
[13:34:35.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.945]         }
[13:34:35.945]         else {
[13:34:35.945]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.945]         }
[13:34:35.945]         base::close(...future.stdout)
[13:34:35.945]         ...future.stdout <- NULL
[13:34:35.945]     }
[13:34:35.945]     ...future.result$conditions <- ...future.conditions
[13:34:35.945]     ...future.result$finished <- base::Sys.time()
[13:34:35.945]     ...future.result
[13:34:35.945] }
[13:34:35.948] assign_globals() ...
[13:34:35.948] List of 5
[13:34:35.948]  $ ...future.FUN            :function (C, k)  
[13:34:35.948]  $ MoreArgs                 : NULL
[13:34:35.948]  $ ...future.elements_ii    :List of 2
[13:34:35.948]   ..$ :List of 1
[13:34:35.948]   .. ..$ : chr "E"
[13:34:35.948]   ..$ :List of 1
[13:34:35.948]   .. ..$ : int 1
[13:34:35.948]  $ ...future.seeds_ii       : NULL
[13:34:35.948]  $ ...future.globals.maxSize: NULL
[13:34:35.948]  - attr(*, "where")=List of 5
[13:34:35.948]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.948]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.948]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.948]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.948]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.948]  - attr(*, "resolved")= logi FALSE
[13:34:35.948]  - attr(*, "total_size")= num 3488
[13:34:35.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.948]  - attr(*, "already-done")= logi TRUE
[13:34:35.962] - reassign environment for ‘...future.FUN’
[13:34:35.963] - copied ‘...future.FUN’ to environment
[13:34:35.963] - copied ‘MoreArgs’ to environment
[13:34:35.963] - copied ‘...future.elements_ii’ to environment
[13:34:35.963] - copied ‘...future.seeds_ii’ to environment
[13:34:35.963] - copied ‘...future.globals.maxSize’ to environment
[13:34:35.963] assign_globals() ... done
[13:34:35.963] requestCore(): workers = 2
[13:34:35.966] MulticoreFuture started
[13:34:35.966] - Launch lazy future ... done
[13:34:35.967] run() for ‘MulticoreFuture’ ... done
[13:34:35.967] plan(): Setting new future strategy stack:
[13:34:35.967] Created future:
[13:34:35.967] List of future strategies:
[13:34:35.967] 1. sequential:
[13:34:35.967]    - args: function (..., envir = parent.frame())
[13:34:35.967]    - tweaked: FALSE
[13:34:35.967]    - call: NULL
[13:34:35.968] plan(): nbrOfWorkers() = 1
[13:34:35.971] plan(): Setting new future strategy stack:
[13:34:35.971] List of future strategies:
[13:34:35.971] 1. multicore:
[13:34:35.971]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:35.971]    - tweaked: FALSE
[13:34:35.971]    - call: plan(strategy)
[13:34:35.977] plan(): nbrOfWorkers() = 2
[13:34:35.967] MulticoreFuture:
[13:34:35.967] Label: ‘future_mapply-2’
[13:34:35.967] Expression:
[13:34:35.967] {
[13:34:35.967]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.967]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:35.967]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.967]         on.exit(options(oopts), add = TRUE)
[13:34:35.967]     }
[13:34:35.967]     {
[13:34:35.967]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.967]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:35.967]         do.call(mapply, args = args)
[13:34:35.967]     }
[13:34:35.967] }
[13:34:35.967] Lazy evaluation: FALSE
[13:34:35.967] Asynchronous evaluation: TRUE
[13:34:35.967] Local evaluation: TRUE
[13:34:35.967] Environment: R_GlobalEnv
[13:34:35.967] Capture standard output: TRUE
[13:34:35.967] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:35.967] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:35.967] Packages: <none>
[13:34:35.967] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:35.967] Resolved: TRUE
[13:34:35.967] Value: <not collected>
[13:34:35.967] Conditions captured: <none>
[13:34:35.967] Early signaling: FALSE
[13:34:35.967] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:35.967] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.978] Chunk #2 of 3 ... DONE
[13:34:35.978] Chunk #3 of 3 ...
[13:34:35.979]  - Finding globals in '...' for chunk #3 ...
[13:34:35.979] getGlobalsAndPackages() ...
[13:34:35.979] Searching for globals...
[13:34:35.980] 
[13:34:35.980] Searching for globals ... DONE
[13:34:35.980] - globals: [0] <none>
[13:34:35.980] getGlobalsAndPackages() ... DONE
[13:34:35.980]    + additional globals found: [n=0] 
[13:34:35.980]    + additional namespaces needed: [n=0] 
[13:34:35.981]  - Finding globals in '...' for chunk #3 ... DONE
[13:34:35.981]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:34:35.981]  - seeds: <none>
[13:34:35.981]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.981] getGlobalsAndPackages() ...
[13:34:35.981] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.982] Resolving globals: FALSE
[13:34:35.983] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:35.984] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:35.984] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:35.984] 
[13:34:35.984] getGlobalsAndPackages() ... DONE
[13:34:35.985] run() for ‘Future’ ...
[13:34:35.985] - state: ‘created’
[13:34:35.985] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:35.990] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:35.990] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:35.990]   - Field: ‘label’
[13:34:35.990]   - Field: ‘local’
[13:34:35.991]   - Field: ‘owner’
[13:34:35.991]   - Field: ‘envir’
[13:34:35.991]   - Field: ‘workers’
[13:34:35.991]   - Field: ‘packages’
[13:34:35.991]   - Field: ‘gc’
[13:34:35.991]   - Field: ‘job’
[13:34:35.991]   - Field: ‘conditions’
[13:34:35.992]   - Field: ‘expr’
[13:34:35.992]   - Field: ‘uuid’
[13:34:35.992]   - Field: ‘seed’
[13:34:35.992]   - Field: ‘version’
[13:34:35.992]   - Field: ‘result’
[13:34:35.992]   - Field: ‘asynchronous’
[13:34:35.992]   - Field: ‘calls’
[13:34:35.993]   - Field: ‘globals’
[13:34:35.993]   - Field: ‘stdout’
[13:34:35.993]   - Field: ‘earlySignal’
[13:34:35.993]   - Field: ‘lazy’
[13:34:35.993]   - Field: ‘state’
[13:34:35.993] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:35.994] - Launch lazy future ...
[13:34:35.994] Packages needed by the future expression (n = 0): <none>
[13:34:35.994] Packages needed by future strategies (n = 0): <none>
[13:34:35.995] {
[13:34:35.995]     {
[13:34:35.995]         {
[13:34:35.995]             ...future.startTime <- base::Sys.time()
[13:34:35.995]             {
[13:34:35.995]                 {
[13:34:35.995]                   {
[13:34:35.995]                     {
[13:34:35.995]                       base::local({
[13:34:35.995]                         has_future <- base::requireNamespace("future", 
[13:34:35.995]                           quietly = TRUE)
[13:34:35.995]                         if (has_future) {
[13:34:35.995]                           ns <- base::getNamespace("future")
[13:34:35.995]                           version <- ns[[".package"]][["version"]]
[13:34:35.995]                           if (is.null(version)) 
[13:34:35.995]                             version <- utils::packageVersion("future")
[13:34:35.995]                         }
[13:34:35.995]                         else {
[13:34:35.995]                           version <- NULL
[13:34:35.995]                         }
[13:34:35.995]                         if (!has_future || version < "1.8.0") {
[13:34:35.995]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:35.995]                             "", base::R.version$version.string), 
[13:34:35.995]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:35.995]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:35.995]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:35.995]                               "release", "version")], collapse = " "), 
[13:34:35.995]                             hostname = base::Sys.info()[["nodename"]])
[13:34:35.995]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:35.995]                             info)
[13:34:35.995]                           info <- base::paste(info, collapse = "; ")
[13:34:35.995]                           if (!has_future) {
[13:34:35.995]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:35.995]                               info)
[13:34:35.995]                           }
[13:34:35.995]                           else {
[13:34:35.995]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:35.995]                               info, version)
[13:34:35.995]                           }
[13:34:35.995]                           base::stop(msg)
[13:34:35.995]                         }
[13:34:35.995]                       })
[13:34:35.995]                     }
[13:34:35.995]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:35.995]                     base::options(mc.cores = 1L)
[13:34:35.995]                   }
[13:34:35.995]                   ...future.strategy.old <- future::plan("list")
[13:34:35.995]                   options(future.plan = NULL)
[13:34:35.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.995]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:35.995]                 }
[13:34:35.995]                 ...future.workdir <- getwd()
[13:34:35.995]             }
[13:34:35.995]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:35.995]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:35.995]         }
[13:34:35.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:35.995]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:34:35.995]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:35.995]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:35.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:35.995]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:35.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:35.995]             base::names(...future.oldOptions))
[13:34:35.995]     }
[13:34:35.995]     if (FALSE) {
[13:34:35.995]     }
[13:34:35.995]     else {
[13:34:35.995]         if (TRUE) {
[13:34:35.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:35.995]                 open = "w")
[13:34:35.995]         }
[13:34:35.995]         else {
[13:34:35.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:35.995]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:35.995]         }
[13:34:35.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:35.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:35.995]             base::sink(type = "output", split = FALSE)
[13:34:35.995]             base::close(...future.stdout)
[13:34:35.995]         }, add = TRUE)
[13:34:35.995]     }
[13:34:35.995]     ...future.frame <- base::sys.nframe()
[13:34:35.995]     ...future.conditions <- base::list()
[13:34:35.995]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:35.995]     if (FALSE) {
[13:34:35.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:35.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:35.995]     }
[13:34:35.995]     ...future.result <- base::tryCatch({
[13:34:35.995]         base::withCallingHandlers({
[13:34:35.995]             ...future.value <- base::withVisible(base::local({
[13:34:35.995]                 withCallingHandlers({
[13:34:35.995]                   {
[13:34:35.995]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:35.995]                     if (!identical(...future.globals.maxSize.org, 
[13:34:35.995]                       ...future.globals.maxSize)) {
[13:34:35.995]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:35.995]                       on.exit(options(oopts), add = TRUE)
[13:34:35.995]                     }
[13:34:35.995]                     {
[13:34:35.995]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:35.995]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:35.995]                         USE.NAMES = FALSE)
[13:34:35.995]                       do.call(mapply, args = args)
[13:34:35.995]                     }
[13:34:35.995]                   }
[13:34:35.995]                 }, immediateCondition = function(cond) {
[13:34:35.995]                   save_rds <- function (object, pathname, ...) 
[13:34:35.995]                   {
[13:34:35.995]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:35.995]                     if (file_test("-f", pathname_tmp)) {
[13:34:35.995]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.995]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:35.995]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.995]                         fi_tmp[["mtime"]])
[13:34:35.995]                     }
[13:34:35.995]                     tryCatch({
[13:34:35.995]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:35.995]                     }, error = function(ex) {
[13:34:35.995]                       msg <- conditionMessage(ex)
[13:34:35.995]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.995]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:35.995]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.995]                         fi_tmp[["mtime"]], msg)
[13:34:35.995]                       ex$message <- msg
[13:34:35.995]                       stop(ex)
[13:34:35.995]                     })
[13:34:35.995]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:35.995]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:35.995]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:35.995]                       fi_tmp <- file.info(pathname_tmp)
[13:34:35.995]                       fi <- file.info(pathname)
[13:34:35.995]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:35.995]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:35.995]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:35.995]                         fi[["size"]], fi[["mtime"]])
[13:34:35.995]                       stop(msg)
[13:34:35.995]                     }
[13:34:35.995]                     invisible(pathname)
[13:34:35.995]                   }
[13:34:35.995]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:35.995]                     rootPath = tempdir()) 
[13:34:35.995]                   {
[13:34:35.995]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:35.995]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:35.995]                       tmpdir = path, fileext = ".rds")
[13:34:35.995]                     save_rds(obj, file)
[13:34:35.995]                   }
[13:34:35.995]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:35.995]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.995]                   {
[13:34:35.995]                     inherits <- base::inherits
[13:34:35.995]                     invokeRestart <- base::invokeRestart
[13:34:35.995]                     is.null <- base::is.null
[13:34:35.995]                     muffled <- FALSE
[13:34:35.995]                     if (inherits(cond, "message")) {
[13:34:35.995]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:35.995]                       if (muffled) 
[13:34:35.995]                         invokeRestart("muffleMessage")
[13:34:35.995]                     }
[13:34:35.995]                     else if (inherits(cond, "warning")) {
[13:34:35.995]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:35.995]                       if (muffled) 
[13:34:35.995]                         invokeRestart("muffleWarning")
[13:34:35.995]                     }
[13:34:35.995]                     else if (inherits(cond, "condition")) {
[13:34:35.995]                       if (!is.null(pattern)) {
[13:34:35.995]                         computeRestarts <- base::computeRestarts
[13:34:35.995]                         grepl <- base::grepl
[13:34:35.995]                         restarts <- computeRestarts(cond)
[13:34:35.995]                         for (restart in restarts) {
[13:34:35.995]                           name <- restart$name
[13:34:35.995]                           if (is.null(name)) 
[13:34:35.995]                             next
[13:34:35.995]                           if (!grepl(pattern, name)) 
[13:34:35.995]                             next
[13:34:35.995]                           invokeRestart(restart)
[13:34:35.995]                           muffled <- TRUE
[13:34:35.995]                           break
[13:34:35.995]                         }
[13:34:35.995]                       }
[13:34:35.995]                     }
[13:34:35.995]                     invisible(muffled)
[13:34:35.995]                   }
[13:34:35.995]                   muffleCondition(cond)
[13:34:35.995]                 })
[13:34:35.995]             }))
[13:34:35.995]             future::FutureResult(value = ...future.value$value, 
[13:34:35.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.995]                   ...future.rng), globalenv = if (FALSE) 
[13:34:35.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:35.995]                     ...future.globalenv.names))
[13:34:35.995]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:35.995]         }, condition = base::local({
[13:34:35.995]             c <- base::c
[13:34:35.995]             inherits <- base::inherits
[13:34:35.995]             invokeRestart <- base::invokeRestart
[13:34:35.995]             length <- base::length
[13:34:35.995]             list <- base::list
[13:34:35.995]             seq.int <- base::seq.int
[13:34:35.995]             signalCondition <- base::signalCondition
[13:34:35.995]             sys.calls <- base::sys.calls
[13:34:35.995]             `[[` <- base::`[[`
[13:34:35.995]             `+` <- base::`+`
[13:34:35.995]             `<<-` <- base::`<<-`
[13:34:35.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:35.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:35.995]                   3L)]
[13:34:35.995]             }
[13:34:35.995]             function(cond) {
[13:34:35.995]                 is_error <- inherits(cond, "error")
[13:34:35.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:35.995]                   NULL)
[13:34:35.995]                 if (is_error) {
[13:34:35.995]                   sessionInformation <- function() {
[13:34:35.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:35.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:35.995]                       search = base::search(), system = base::Sys.info())
[13:34:35.995]                   }
[13:34:35.995]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:35.995]                     cond$call), session = sessionInformation(), 
[13:34:35.995]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:35.995]                   signalCondition(cond)
[13:34:35.995]                 }
[13:34:35.995]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:35.995]                 "immediateCondition"))) {
[13:34:35.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:35.995]                   ...future.conditions[[length(...future.conditions) + 
[13:34:35.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:35.995]                   if (TRUE && !signal) {
[13:34:35.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.995]                     {
[13:34:35.995]                       inherits <- base::inherits
[13:34:35.995]                       invokeRestart <- base::invokeRestart
[13:34:35.995]                       is.null <- base::is.null
[13:34:35.995]                       muffled <- FALSE
[13:34:35.995]                       if (inherits(cond, "message")) {
[13:34:35.995]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.995]                         if (muffled) 
[13:34:35.995]                           invokeRestart("muffleMessage")
[13:34:35.995]                       }
[13:34:35.995]                       else if (inherits(cond, "warning")) {
[13:34:35.995]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.995]                         if (muffled) 
[13:34:35.995]                           invokeRestart("muffleWarning")
[13:34:35.995]                       }
[13:34:35.995]                       else if (inherits(cond, "condition")) {
[13:34:35.995]                         if (!is.null(pattern)) {
[13:34:35.995]                           computeRestarts <- base::computeRestarts
[13:34:35.995]                           grepl <- base::grepl
[13:34:35.995]                           restarts <- computeRestarts(cond)
[13:34:35.995]                           for (restart in restarts) {
[13:34:35.995]                             name <- restart$name
[13:34:35.995]                             if (is.null(name)) 
[13:34:35.995]                               next
[13:34:35.995]                             if (!grepl(pattern, name)) 
[13:34:35.995]                               next
[13:34:35.995]                             invokeRestart(restart)
[13:34:35.995]                             muffled <- TRUE
[13:34:35.995]                             break
[13:34:35.995]                           }
[13:34:35.995]                         }
[13:34:35.995]                       }
[13:34:35.995]                       invisible(muffled)
[13:34:35.995]                     }
[13:34:35.995]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.995]                   }
[13:34:35.995]                 }
[13:34:35.995]                 else {
[13:34:35.995]                   if (TRUE) {
[13:34:35.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:35.995]                     {
[13:34:35.995]                       inherits <- base::inherits
[13:34:35.995]                       invokeRestart <- base::invokeRestart
[13:34:35.995]                       is.null <- base::is.null
[13:34:35.995]                       muffled <- FALSE
[13:34:35.995]                       if (inherits(cond, "message")) {
[13:34:35.995]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:35.995]                         if (muffled) 
[13:34:35.995]                           invokeRestart("muffleMessage")
[13:34:35.995]                       }
[13:34:35.995]                       else if (inherits(cond, "warning")) {
[13:34:35.995]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:35.995]                         if (muffled) 
[13:34:35.995]                           invokeRestart("muffleWarning")
[13:34:35.995]                       }
[13:34:35.995]                       else if (inherits(cond, "condition")) {
[13:34:35.995]                         if (!is.null(pattern)) {
[13:34:35.995]                           computeRestarts <- base::computeRestarts
[13:34:35.995]                           grepl <- base::grepl
[13:34:35.995]                           restarts <- computeRestarts(cond)
[13:34:35.995]                           for (restart in restarts) {
[13:34:35.995]                             name <- restart$name
[13:34:35.995]                             if (is.null(name)) 
[13:34:35.995]                               next
[13:34:35.995]                             if (!grepl(pattern, name)) 
[13:34:35.995]                               next
[13:34:35.995]                             invokeRestart(restart)
[13:34:35.995]                             muffled <- TRUE
[13:34:35.995]                             break
[13:34:35.995]                           }
[13:34:35.995]                         }
[13:34:35.995]                       }
[13:34:35.995]                       invisible(muffled)
[13:34:35.995]                     }
[13:34:35.995]                     muffleCondition(cond, pattern = "^muffle")
[13:34:35.995]                   }
[13:34:35.995]                 }
[13:34:35.995]             }
[13:34:35.995]         }))
[13:34:35.995]     }, error = function(ex) {
[13:34:35.995]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:35.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:35.995]                 ...future.rng), started = ...future.startTime, 
[13:34:35.995]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:35.995]             version = "1.8"), class = "FutureResult")
[13:34:35.995]     }, finally = {
[13:34:35.995]         if (!identical(...future.workdir, getwd())) 
[13:34:35.995]             setwd(...future.workdir)
[13:34:35.995]         {
[13:34:35.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:35.995]                 ...future.oldOptions$nwarnings <- NULL
[13:34:35.995]             }
[13:34:35.995]             base::options(...future.oldOptions)
[13:34:35.995]             if (.Platform$OS.type == "windows") {
[13:34:35.995]                 old_names <- names(...future.oldEnvVars)
[13:34:35.995]                 envs <- base::Sys.getenv()
[13:34:35.995]                 names <- names(envs)
[13:34:35.995]                 common <- intersect(names, old_names)
[13:34:35.995]                 added <- setdiff(names, old_names)
[13:34:35.995]                 removed <- setdiff(old_names, names)
[13:34:35.995]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:35.995]                   envs[common]]
[13:34:35.995]                 NAMES <- toupper(changed)
[13:34:35.995]                 args <- list()
[13:34:35.995]                 for (kk in seq_along(NAMES)) {
[13:34:35.995]                   name <- changed[[kk]]
[13:34:35.995]                   NAME <- NAMES[[kk]]
[13:34:35.995]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.995]                     next
[13:34:35.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.995]                 }
[13:34:35.995]                 NAMES <- toupper(added)
[13:34:35.995]                 for (kk in seq_along(NAMES)) {
[13:34:35.995]                   name <- added[[kk]]
[13:34:35.995]                   NAME <- NAMES[[kk]]
[13:34:35.995]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.995]                     next
[13:34:35.995]                   args[[name]] <- ""
[13:34:35.995]                 }
[13:34:35.995]                 NAMES <- toupper(removed)
[13:34:35.995]                 for (kk in seq_along(NAMES)) {
[13:34:35.995]                   name <- removed[[kk]]
[13:34:35.995]                   NAME <- NAMES[[kk]]
[13:34:35.995]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:35.995]                     next
[13:34:35.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:35.995]                 }
[13:34:35.995]                 if (length(args) > 0) 
[13:34:35.995]                   base::do.call(base::Sys.setenv, args = args)
[13:34:35.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:35.995]             }
[13:34:35.995]             else {
[13:34:35.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:35.995]             }
[13:34:35.995]             {
[13:34:35.995]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:35.995]                   0L) {
[13:34:35.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:35.995]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:35.995]                   base::options(opts)
[13:34:35.995]                 }
[13:34:35.995]                 {
[13:34:35.995]                   {
[13:34:35.995]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:35.995]                     NULL
[13:34:35.995]                   }
[13:34:35.995]                   options(future.plan = NULL)
[13:34:35.995]                   if (is.na(NA_character_)) 
[13:34:35.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:35.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:35.995]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:35.995]                     .init = FALSE)
[13:34:35.995]                 }
[13:34:35.995]             }
[13:34:35.995]         }
[13:34:35.995]     })
[13:34:35.995]     if (TRUE) {
[13:34:35.995]         base::sink(type = "output", split = FALSE)
[13:34:35.995]         if (TRUE) {
[13:34:35.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:35.995]         }
[13:34:35.995]         else {
[13:34:35.995]             ...future.result["stdout"] <- base::list(NULL)
[13:34:35.995]         }
[13:34:35.995]         base::close(...future.stdout)
[13:34:35.995]         ...future.stdout <- NULL
[13:34:35.995]     }
[13:34:35.995]     ...future.result$conditions <- ...future.conditions
[13:34:35.995]     ...future.result$finished <- base::Sys.time()
[13:34:35.995]     ...future.result
[13:34:35.995] }
[13:34:35.998] assign_globals() ...
[13:34:35.999] List of 5
[13:34:35.999]  $ ...future.FUN            :function (C, k)  
[13:34:35.999]  $ MoreArgs                 : NULL
[13:34:35.999]  $ ...future.elements_ii    :List of 2
[13:34:35.999]   ..$ :List of 2
[13:34:35.999]   .. ..$ : chr "C"
[13:34:35.999]   .. ..$ : chr "A"
[13:34:35.999]   ..$ :List of 2
[13:34:35.999]   .. ..$ : int 3
[13:34:35.999]   .. ..$ : int 5
[13:34:35.999]  $ ...future.seeds_ii       : NULL
[13:34:35.999]  $ ...future.globals.maxSize: NULL
[13:34:35.999]  - attr(*, "where")=List of 5
[13:34:35.999]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:35.999]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:35.999]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:35.999]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:35.999]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:35.999]  - attr(*, "resolved")= logi FALSE
[13:34:35.999]  - attr(*, "total_size")= num 3656
[13:34:35.999]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:35.999]  - attr(*, "already-done")= logi TRUE
[13:34:36.012] - reassign environment for ‘...future.FUN’
[13:34:36.013] - copied ‘...future.FUN’ to environment
[13:34:36.013] - copied ‘MoreArgs’ to environment
[13:34:36.013] - copied ‘...future.elements_ii’ to environment
[13:34:36.013] - copied ‘...future.seeds_ii’ to environment
[13:34:36.013] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.013] assign_globals() ... done
[13:34:36.013] requestCore(): workers = 2
[13:34:36.014] Poll #1 (0): usedCores() = 2, workers = 2
[13:34:36.024] result() for MulticoreFuture ...
[13:34:36.025] result() for MulticoreFuture ...
[13:34:36.025] result() for MulticoreFuture ... done
[13:34:36.026] result() for MulticoreFuture ... done
[13:34:36.026] result() for MulticoreFuture ...
[13:34:36.026] result() for MulticoreFuture ... done
[13:34:36.028] MulticoreFuture started
[13:34:36.029] - Launch lazy future ... done
[13:34:36.029] run() for ‘MulticoreFuture’ ... done
[13:34:36.030] Created future:
[13:34:36.030] plan(): Setting new future strategy stack:
[13:34:36.030] List of future strategies:
[13:34:36.030] 1. sequential:
[13:34:36.030]    - args: function (..., envir = parent.frame())
[13:34:36.030]    - tweaked: FALSE
[13:34:36.030]    - call: NULL
[13:34:36.031] plan(): nbrOfWorkers() = 1
[13:34:36.034] plan(): Setting new future strategy stack:
[13:34:36.034] List of future strategies:
[13:34:36.034] 1. multicore:
[13:34:36.034]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.034]    - tweaked: FALSE
[13:34:36.034]    - call: plan(strategy)
[13:34:36.041] plan(): nbrOfWorkers() = 2
[13:34:36.030] MulticoreFuture:
[13:34:36.030] Label: ‘future_mapply-3’
[13:34:36.030] Expression:
[13:34:36.030] {
[13:34:36.030]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.030]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.030]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.030]         on.exit(options(oopts), add = TRUE)
[13:34:36.030]     }
[13:34:36.030]     {
[13:34:36.030]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.030]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.030]         do.call(mapply, args = args)
[13:34:36.030]     }
[13:34:36.030] }
[13:34:36.030] Lazy evaluation: FALSE
[13:34:36.030] Asynchronous evaluation: TRUE
[13:34:36.030] Local evaluation: TRUE
[13:34:36.030] Environment: R_GlobalEnv
[13:34:36.030] Capture standard output: TRUE
[13:34:36.030] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.030] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.030] Packages: <none>
[13:34:36.030] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.030] Resolved: TRUE
[13:34:36.030] Value: <not collected>
[13:34:36.030] Conditions captured: <none>
[13:34:36.030] Early signaling: FALSE
[13:34:36.030] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.030] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.042] Chunk #3 of 3 ... DONE
[13:34:36.042] Launching 3 futures (chunks) ... DONE
[13:34:36.043] Resolving 3 futures (chunks) ...
[13:34:36.043] resolve() on list ...
[13:34:36.043]  recursive: 0
[13:34:36.043]  length: 3
[13:34:36.043] 
[13:34:36.043] Future #1
[13:34:36.044] result() for MulticoreFuture ...
[13:34:36.044] result() for MulticoreFuture ... done
[13:34:36.044] result() for MulticoreFuture ...
[13:34:36.044] result() for MulticoreFuture ... done
[13:34:36.044] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:36.044] - nx: 3
[13:34:36.045] - relay: TRUE
[13:34:36.045] - stdout: TRUE
[13:34:36.045] - signal: TRUE
[13:34:36.045] - resignal: FALSE
[13:34:36.045] - force: TRUE
[13:34:36.045] - relayed: [n=3] FALSE, FALSE, FALSE
[13:34:36.045] - queued futures: [n=3] FALSE, FALSE, FALSE
[13:34:36.046]  - until=1
[13:34:36.046]  - relaying element #1
[13:34:36.046] result() for MulticoreFuture ...
[13:34:36.046] result() for MulticoreFuture ... done
[13:34:36.046] result() for MulticoreFuture ...
[13:34:36.046] result() for MulticoreFuture ... done
[13:34:36.047] result() for MulticoreFuture ...
[13:34:36.047] result() for MulticoreFuture ... done
[13:34:36.047] result() for MulticoreFuture ...
[13:34:36.047] result() for MulticoreFuture ... done
[13:34:36.047] - relayed: [n=3] TRUE, FALSE, FALSE
[13:34:36.047] - queued futures: [n=3] TRUE, FALSE, FALSE
[13:34:36.047] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:36.048]  length: 2 (resolved future 1)
[13:34:36.048] Future #2
[13:34:36.048] result() for MulticoreFuture ...
[13:34:36.049] result() for MulticoreFuture ...
[13:34:36.049] result() for MulticoreFuture ... done
[13:34:36.049] result() for MulticoreFuture ... done
[13:34:36.050] result() for MulticoreFuture ...
[13:34:36.050] result() for MulticoreFuture ... done
[13:34:36.050] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:36.050] - nx: 3
[13:34:36.050] - relay: TRUE
[13:34:36.050] - stdout: TRUE
[13:34:36.050] - signal: TRUE
[13:34:36.051] - resignal: FALSE
[13:34:36.051] - force: TRUE
[13:34:36.051] - relayed: [n=3] TRUE, FALSE, FALSE
[13:34:36.051] - queued futures: [n=3] TRUE, FALSE, FALSE
[13:34:36.051]  - until=2
[13:34:36.051]  - relaying element #2
[13:34:36.052] result() for MulticoreFuture ...
[13:34:36.052] result() for MulticoreFuture ... done
[13:34:36.052] result() for MulticoreFuture ...
[13:34:36.052] result() for MulticoreFuture ... done
[13:34:36.052] result() for MulticoreFuture ...
[13:34:36.052] result() for MulticoreFuture ... done
[13:34:36.053] result() for MulticoreFuture ...
[13:34:36.053] result() for MulticoreFuture ... done
[13:34:36.053] - relayed: [n=3] TRUE, TRUE, FALSE
[13:34:36.053] - queued futures: [n=3] TRUE, TRUE, FALSE
[13:34:36.053] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:36.053]  length: 1 (resolved future 2)
[13:34:36.054] Future #3
[13:34:36.054] result() for MulticoreFuture ...
[13:34:36.055] result() for MulticoreFuture ...
[13:34:36.055] result() for MulticoreFuture ... done
[13:34:36.055] result() for MulticoreFuture ... done
[13:34:36.055] result() for MulticoreFuture ...
[13:34:36.055] result() for MulticoreFuture ... done
[13:34:36.055] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:34:36.056] - nx: 3
[13:34:36.056] - relay: TRUE
[13:34:36.056] - stdout: TRUE
[13:34:36.056] - signal: TRUE
[13:34:36.056] - resignal: FALSE
[13:34:36.056] - force: TRUE
[13:34:36.056] - relayed: [n=3] TRUE, TRUE, FALSE
[13:34:36.056] - queued futures: [n=3] TRUE, TRUE, FALSE
[13:34:36.056]  - until=3
[13:34:36.057]  - relaying element #3
[13:34:36.057] result() for MulticoreFuture ...
[13:34:36.057] result() for MulticoreFuture ... done
[13:34:36.057] result() for MulticoreFuture ...
[13:34:36.057] result() for MulticoreFuture ... done
[13:34:36.057] result() for MulticoreFuture ...
[13:34:36.057] result() for MulticoreFuture ... done
[13:34:36.058] result() for MulticoreFuture ...
[13:34:36.058] result() for MulticoreFuture ... done
[13:34:36.058] - relayed: [n=3] TRUE, TRUE, TRUE
[13:34:36.058] - queued futures: [n=3] TRUE, TRUE, TRUE
[13:34:36.058] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:34:36.058]  length: 0 (resolved future 3)
[13:34:36.058] Relaying remaining futures
[13:34:36.058] signalConditionsASAP(NULL, pos=0) ...
[13:34:36.061] - nx: 3
[13:34:36.061] - relay: TRUE
[13:34:36.062] - stdout: TRUE
[13:34:36.062] - signal: TRUE
[13:34:36.062] - resignal: FALSE
[13:34:36.062] - force: TRUE
[13:34:36.062] - relayed: [n=3] TRUE, TRUE, TRUE
[13:34:36.062] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[13:34:36.063] - relayed: [n=3] TRUE, TRUE, TRUE
[13:34:36.063] - queued futures: [n=3] TRUE, TRUE, TRUE
[13:34:36.063] signalConditionsASAP(NULL, pos=0) ... done
[13:34:36.063] resolve() on list ... DONE
[13:34:36.063] result() for MulticoreFuture ...
[13:34:36.063] result() for MulticoreFuture ... done
[13:34:36.063] result() for MulticoreFuture ...
[13:34:36.064] result() for MulticoreFuture ... done
[13:34:36.064] result() for MulticoreFuture ...
[13:34:36.064] result() for MulticoreFuture ... done
[13:34:36.064] result() for MulticoreFuture ...
[13:34:36.064] result() for MulticoreFuture ... done
[13:34:36.064] result() for MulticoreFuture ...
[13:34:36.065] result() for MulticoreFuture ... done
[13:34:36.065] result() for MulticoreFuture ...
[13:34:36.065] result() for MulticoreFuture ... done
[13:34:36.065]  - Number of value chunks collected: 3
[13:34:36.065] Resolving 3 futures (chunks) ... DONE
[13:34:36.065] Reducing values from 3 chunks ...
[13:34:36.065]  - Number of values collected after concatenation: 5
[13:34:36.066]  - Number of values expected: 5
[13:34:36.066] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 2, 4, 1, 3
[13:34:36.066] Reducing values from 3 chunks ... DONE
[13:34:36.066] future_mapply() ... DONE
[13:34:36.066] future_mapply() ...
[13:34:36.071] Number of chunks: 2
[13:34:36.071] getGlobalsAndPackagesXApply() ...
[13:34:36.071]  - future.globals: TRUE
[13:34:36.071] getGlobalsAndPackages() ...
[13:34:36.071] Searching for globals...
[13:34:36.073] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:36.073] Searching for globals ... DONE
[13:34:36.073] Resolving globals: FALSE
[13:34:36.073] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:36.074] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:36.074] - globals: [1] ‘FUN’
[13:34:36.074] 
[13:34:36.074] getGlobalsAndPackages() ... DONE
[13:34:36.074]  - globals found/used: [n=1] ‘FUN’
[13:34:36.074]  - needed namespaces: [n=0] 
[13:34:36.074] Finding globals ... DONE
[13:34:36.075] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:36.075] List of 2
[13:34:36.075]  $ ...future.FUN:function (C, k)  
[13:34:36.075]  $ MoreArgs     : list()
[13:34:36.075]  - attr(*, "where")=List of 2
[13:34:36.075]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:36.075]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:36.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.075]  - attr(*, "resolved")= logi FALSE
[13:34:36.075]  - attr(*, "total_size")= num NA
[13:34:36.077] Packages to be attached in all futures: [n=0] 
[13:34:36.077] getGlobalsAndPackagesXApply() ... DONE
[13:34:36.078] Number of futures (= number of chunks): 2
[13:34:36.078] Launching 2 futures (chunks) ...
[13:34:36.078] Chunk #1 of 2 ...
[13:34:36.078]  - Finding globals in '...' for chunk #1 ...
[13:34:36.078] getGlobalsAndPackages() ...
[13:34:36.078] Searching for globals...
[13:34:36.078] 
[13:34:36.079] Searching for globals ... DONE
[13:34:36.079] - globals: [0] <none>
[13:34:36.079] getGlobalsAndPackages() ... DONE
[13:34:36.079]    + additional globals found: [n=0] 
[13:34:36.079]    + additional namespaces needed: [n=0] 
[13:34:36.079]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:36.079]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.079]  - seeds: <none>
[13:34:36.079]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.079] getGlobalsAndPackages() ...
[13:34:36.080] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.080] Resolving globals: FALSE
[13:34:36.080] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:36.081] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:36.081] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.081] 
[13:34:36.081] getGlobalsAndPackages() ... DONE
[13:34:36.081] run() for ‘Future’ ...
[13:34:36.081] - state: ‘created’
[13:34:36.081] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.085] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.085] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.085]   - Field: ‘label’
[13:34:36.085]   - Field: ‘local’
[13:34:36.086]   - Field: ‘owner’
[13:34:36.086]   - Field: ‘envir’
[13:34:36.086]   - Field: ‘workers’
[13:34:36.086]   - Field: ‘packages’
[13:34:36.086]   - Field: ‘gc’
[13:34:36.086]   - Field: ‘job’
[13:34:36.086]   - Field: ‘conditions’
[13:34:36.086]   - Field: ‘expr’
[13:34:36.086]   - Field: ‘uuid’
[13:34:36.087]   - Field: ‘seed’
[13:34:36.087]   - Field: ‘version’
[13:34:36.087]   - Field: ‘result’
[13:34:36.089]   - Field: ‘asynchronous’
[13:34:36.089]   - Field: ‘calls’
[13:34:36.089]   - Field: ‘globals’
[13:34:36.089]   - Field: ‘stdout’
[13:34:36.090]   - Field: ‘earlySignal’
[13:34:36.090]   - Field: ‘lazy’
[13:34:36.090]   - Field: ‘state’
[13:34:36.090] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.090] - Launch lazy future ...
[13:34:36.090] Packages needed by the future expression (n = 0): <none>
[13:34:36.090] Packages needed by future strategies (n = 0): <none>
[13:34:36.091] {
[13:34:36.091]     {
[13:34:36.091]         {
[13:34:36.091]             ...future.startTime <- base::Sys.time()
[13:34:36.091]             {
[13:34:36.091]                 {
[13:34:36.091]                   {
[13:34:36.091]                     {
[13:34:36.091]                       base::local({
[13:34:36.091]                         has_future <- base::requireNamespace("future", 
[13:34:36.091]                           quietly = TRUE)
[13:34:36.091]                         if (has_future) {
[13:34:36.091]                           ns <- base::getNamespace("future")
[13:34:36.091]                           version <- ns[[".package"]][["version"]]
[13:34:36.091]                           if (is.null(version)) 
[13:34:36.091]                             version <- utils::packageVersion("future")
[13:34:36.091]                         }
[13:34:36.091]                         else {
[13:34:36.091]                           version <- NULL
[13:34:36.091]                         }
[13:34:36.091]                         if (!has_future || version < "1.8.0") {
[13:34:36.091]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.091]                             "", base::R.version$version.string), 
[13:34:36.091]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.091]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.091]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.091]                               "release", "version")], collapse = " "), 
[13:34:36.091]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.091]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.091]                             info)
[13:34:36.091]                           info <- base::paste(info, collapse = "; ")
[13:34:36.091]                           if (!has_future) {
[13:34:36.091]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.091]                               info)
[13:34:36.091]                           }
[13:34:36.091]                           else {
[13:34:36.091]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.091]                               info, version)
[13:34:36.091]                           }
[13:34:36.091]                           base::stop(msg)
[13:34:36.091]                         }
[13:34:36.091]                       })
[13:34:36.091]                     }
[13:34:36.091]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.091]                     base::options(mc.cores = 1L)
[13:34:36.091]                   }
[13:34:36.091]                   ...future.strategy.old <- future::plan("list")
[13:34:36.091]                   options(future.plan = NULL)
[13:34:36.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.091]                 }
[13:34:36.091]                 ...future.workdir <- getwd()
[13:34:36.091]             }
[13:34:36.091]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.091]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.091]         }
[13:34:36.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.091]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.091]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.091]             base::names(...future.oldOptions))
[13:34:36.091]     }
[13:34:36.091]     if (FALSE) {
[13:34:36.091]     }
[13:34:36.091]     else {
[13:34:36.091]         if (TRUE) {
[13:34:36.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.091]                 open = "w")
[13:34:36.091]         }
[13:34:36.091]         else {
[13:34:36.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.091]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.091]         }
[13:34:36.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.091]             base::sink(type = "output", split = FALSE)
[13:34:36.091]             base::close(...future.stdout)
[13:34:36.091]         }, add = TRUE)
[13:34:36.091]     }
[13:34:36.091]     ...future.frame <- base::sys.nframe()
[13:34:36.091]     ...future.conditions <- base::list()
[13:34:36.091]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.091]     if (FALSE) {
[13:34:36.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.091]     }
[13:34:36.091]     ...future.result <- base::tryCatch({
[13:34:36.091]         base::withCallingHandlers({
[13:34:36.091]             ...future.value <- base::withVisible(base::local({
[13:34:36.091]                 withCallingHandlers({
[13:34:36.091]                   {
[13:34:36.091]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.091]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.091]                       ...future.globals.maxSize)) {
[13:34:36.091]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.091]                       on.exit(options(oopts), add = TRUE)
[13:34:36.091]                     }
[13:34:36.091]                     {
[13:34:36.091]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.091]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.091]                         USE.NAMES = FALSE)
[13:34:36.091]                       do.call(mapply, args = args)
[13:34:36.091]                     }
[13:34:36.091]                   }
[13:34:36.091]                 }, immediateCondition = function(cond) {
[13:34:36.091]                   save_rds <- function (object, pathname, ...) 
[13:34:36.091]                   {
[13:34:36.091]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.091]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.091]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.091]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.091]                         fi_tmp[["mtime"]])
[13:34:36.091]                     }
[13:34:36.091]                     tryCatch({
[13:34:36.091]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.091]                     }, error = function(ex) {
[13:34:36.091]                       msg <- conditionMessage(ex)
[13:34:36.091]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.091]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.091]                         fi_tmp[["mtime"]], msg)
[13:34:36.091]                       ex$message <- msg
[13:34:36.091]                       stop(ex)
[13:34:36.091]                     })
[13:34:36.091]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.091]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.091]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.091]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.091]                       fi <- file.info(pathname)
[13:34:36.091]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.091]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.091]                         fi[["size"]], fi[["mtime"]])
[13:34:36.091]                       stop(msg)
[13:34:36.091]                     }
[13:34:36.091]                     invisible(pathname)
[13:34:36.091]                   }
[13:34:36.091]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.091]                     rootPath = tempdir()) 
[13:34:36.091]                   {
[13:34:36.091]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.091]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.091]                       tmpdir = path, fileext = ".rds")
[13:34:36.091]                     save_rds(obj, file)
[13:34:36.091]                   }
[13:34:36.091]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.091]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.091]                   {
[13:34:36.091]                     inherits <- base::inherits
[13:34:36.091]                     invokeRestart <- base::invokeRestart
[13:34:36.091]                     is.null <- base::is.null
[13:34:36.091]                     muffled <- FALSE
[13:34:36.091]                     if (inherits(cond, "message")) {
[13:34:36.091]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.091]                       if (muffled) 
[13:34:36.091]                         invokeRestart("muffleMessage")
[13:34:36.091]                     }
[13:34:36.091]                     else if (inherits(cond, "warning")) {
[13:34:36.091]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.091]                       if (muffled) 
[13:34:36.091]                         invokeRestart("muffleWarning")
[13:34:36.091]                     }
[13:34:36.091]                     else if (inherits(cond, "condition")) {
[13:34:36.091]                       if (!is.null(pattern)) {
[13:34:36.091]                         computeRestarts <- base::computeRestarts
[13:34:36.091]                         grepl <- base::grepl
[13:34:36.091]                         restarts <- computeRestarts(cond)
[13:34:36.091]                         for (restart in restarts) {
[13:34:36.091]                           name <- restart$name
[13:34:36.091]                           if (is.null(name)) 
[13:34:36.091]                             next
[13:34:36.091]                           if (!grepl(pattern, name)) 
[13:34:36.091]                             next
[13:34:36.091]                           invokeRestart(restart)
[13:34:36.091]                           muffled <- TRUE
[13:34:36.091]                           break
[13:34:36.091]                         }
[13:34:36.091]                       }
[13:34:36.091]                     }
[13:34:36.091]                     invisible(muffled)
[13:34:36.091]                   }
[13:34:36.091]                   muffleCondition(cond)
[13:34:36.091]                 })
[13:34:36.091]             }))
[13:34:36.091]             future::FutureResult(value = ...future.value$value, 
[13:34:36.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.091]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.091]                     ...future.globalenv.names))
[13:34:36.091]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.091]         }, condition = base::local({
[13:34:36.091]             c <- base::c
[13:34:36.091]             inherits <- base::inherits
[13:34:36.091]             invokeRestart <- base::invokeRestart
[13:34:36.091]             length <- base::length
[13:34:36.091]             list <- base::list
[13:34:36.091]             seq.int <- base::seq.int
[13:34:36.091]             signalCondition <- base::signalCondition
[13:34:36.091]             sys.calls <- base::sys.calls
[13:34:36.091]             `[[` <- base::`[[`
[13:34:36.091]             `+` <- base::`+`
[13:34:36.091]             `<<-` <- base::`<<-`
[13:34:36.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.091]                   3L)]
[13:34:36.091]             }
[13:34:36.091]             function(cond) {
[13:34:36.091]                 is_error <- inherits(cond, "error")
[13:34:36.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.091]                   NULL)
[13:34:36.091]                 if (is_error) {
[13:34:36.091]                   sessionInformation <- function() {
[13:34:36.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.091]                       search = base::search(), system = base::Sys.info())
[13:34:36.091]                   }
[13:34:36.091]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.091]                     cond$call), session = sessionInformation(), 
[13:34:36.091]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.091]                   signalCondition(cond)
[13:34:36.091]                 }
[13:34:36.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.091]                 "immediateCondition"))) {
[13:34:36.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.091]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.091]                   if (TRUE && !signal) {
[13:34:36.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.091]                     {
[13:34:36.091]                       inherits <- base::inherits
[13:34:36.091]                       invokeRestart <- base::invokeRestart
[13:34:36.091]                       is.null <- base::is.null
[13:34:36.091]                       muffled <- FALSE
[13:34:36.091]                       if (inherits(cond, "message")) {
[13:34:36.091]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.091]                         if (muffled) 
[13:34:36.091]                           invokeRestart("muffleMessage")
[13:34:36.091]                       }
[13:34:36.091]                       else if (inherits(cond, "warning")) {
[13:34:36.091]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.091]                         if (muffled) 
[13:34:36.091]                           invokeRestart("muffleWarning")
[13:34:36.091]                       }
[13:34:36.091]                       else if (inherits(cond, "condition")) {
[13:34:36.091]                         if (!is.null(pattern)) {
[13:34:36.091]                           computeRestarts <- base::computeRestarts
[13:34:36.091]                           grepl <- base::grepl
[13:34:36.091]                           restarts <- computeRestarts(cond)
[13:34:36.091]                           for (restart in restarts) {
[13:34:36.091]                             name <- restart$name
[13:34:36.091]                             if (is.null(name)) 
[13:34:36.091]                               next
[13:34:36.091]                             if (!grepl(pattern, name)) 
[13:34:36.091]                               next
[13:34:36.091]                             invokeRestart(restart)
[13:34:36.091]                             muffled <- TRUE
[13:34:36.091]                             break
[13:34:36.091]                           }
[13:34:36.091]                         }
[13:34:36.091]                       }
[13:34:36.091]                       invisible(muffled)
[13:34:36.091]                     }
[13:34:36.091]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.091]                   }
[13:34:36.091]                 }
[13:34:36.091]                 else {
[13:34:36.091]                   if (TRUE) {
[13:34:36.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.091]                     {
[13:34:36.091]                       inherits <- base::inherits
[13:34:36.091]                       invokeRestart <- base::invokeRestart
[13:34:36.091]                       is.null <- base::is.null
[13:34:36.091]                       muffled <- FALSE
[13:34:36.091]                       if (inherits(cond, "message")) {
[13:34:36.091]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.091]                         if (muffled) 
[13:34:36.091]                           invokeRestart("muffleMessage")
[13:34:36.091]                       }
[13:34:36.091]                       else if (inherits(cond, "warning")) {
[13:34:36.091]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.091]                         if (muffled) 
[13:34:36.091]                           invokeRestart("muffleWarning")
[13:34:36.091]                       }
[13:34:36.091]                       else if (inherits(cond, "condition")) {
[13:34:36.091]                         if (!is.null(pattern)) {
[13:34:36.091]                           computeRestarts <- base::computeRestarts
[13:34:36.091]                           grepl <- base::grepl
[13:34:36.091]                           restarts <- computeRestarts(cond)
[13:34:36.091]                           for (restart in restarts) {
[13:34:36.091]                             name <- restart$name
[13:34:36.091]                             if (is.null(name)) 
[13:34:36.091]                               next
[13:34:36.091]                             if (!grepl(pattern, name)) 
[13:34:36.091]                               next
[13:34:36.091]                             invokeRestart(restart)
[13:34:36.091]                             muffled <- TRUE
[13:34:36.091]                             break
[13:34:36.091]                           }
[13:34:36.091]                         }
[13:34:36.091]                       }
[13:34:36.091]                       invisible(muffled)
[13:34:36.091]                     }
[13:34:36.091]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.091]                   }
[13:34:36.091]                 }
[13:34:36.091]             }
[13:34:36.091]         }))
[13:34:36.091]     }, error = function(ex) {
[13:34:36.091]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.091]                 ...future.rng), started = ...future.startTime, 
[13:34:36.091]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.091]             version = "1.8"), class = "FutureResult")
[13:34:36.091]     }, finally = {
[13:34:36.091]         if (!identical(...future.workdir, getwd())) 
[13:34:36.091]             setwd(...future.workdir)
[13:34:36.091]         {
[13:34:36.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.091]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.091]             }
[13:34:36.091]             base::options(...future.oldOptions)
[13:34:36.091]             if (.Platform$OS.type == "windows") {
[13:34:36.091]                 old_names <- names(...future.oldEnvVars)
[13:34:36.091]                 envs <- base::Sys.getenv()
[13:34:36.091]                 names <- names(envs)
[13:34:36.091]                 common <- intersect(names, old_names)
[13:34:36.091]                 added <- setdiff(names, old_names)
[13:34:36.091]                 removed <- setdiff(old_names, names)
[13:34:36.091]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.091]                   envs[common]]
[13:34:36.091]                 NAMES <- toupper(changed)
[13:34:36.091]                 args <- list()
[13:34:36.091]                 for (kk in seq_along(NAMES)) {
[13:34:36.091]                   name <- changed[[kk]]
[13:34:36.091]                   NAME <- NAMES[[kk]]
[13:34:36.091]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.091]                     next
[13:34:36.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.091]                 }
[13:34:36.091]                 NAMES <- toupper(added)
[13:34:36.091]                 for (kk in seq_along(NAMES)) {
[13:34:36.091]                   name <- added[[kk]]
[13:34:36.091]                   NAME <- NAMES[[kk]]
[13:34:36.091]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.091]                     next
[13:34:36.091]                   args[[name]] <- ""
[13:34:36.091]                 }
[13:34:36.091]                 NAMES <- toupper(removed)
[13:34:36.091]                 for (kk in seq_along(NAMES)) {
[13:34:36.091]                   name <- removed[[kk]]
[13:34:36.091]                   NAME <- NAMES[[kk]]
[13:34:36.091]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.091]                     next
[13:34:36.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.091]                 }
[13:34:36.091]                 if (length(args) > 0) 
[13:34:36.091]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.091]             }
[13:34:36.091]             else {
[13:34:36.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.091]             }
[13:34:36.091]             {
[13:34:36.091]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.091]                   0L) {
[13:34:36.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.091]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.091]                   base::options(opts)
[13:34:36.091]                 }
[13:34:36.091]                 {
[13:34:36.091]                   {
[13:34:36.091]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.091]                     NULL
[13:34:36.091]                   }
[13:34:36.091]                   options(future.plan = NULL)
[13:34:36.091]                   if (is.na(NA_character_)) 
[13:34:36.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.091]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.091]                     .init = FALSE)
[13:34:36.091]                 }
[13:34:36.091]             }
[13:34:36.091]         }
[13:34:36.091]     })
[13:34:36.091]     if (TRUE) {
[13:34:36.091]         base::sink(type = "output", split = FALSE)
[13:34:36.091]         if (TRUE) {
[13:34:36.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.091]         }
[13:34:36.091]         else {
[13:34:36.091]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.091]         }
[13:34:36.091]         base::close(...future.stdout)
[13:34:36.091]         ...future.stdout <- NULL
[13:34:36.091]     }
[13:34:36.091]     ...future.result$conditions <- ...future.conditions
[13:34:36.091]     ...future.result$finished <- base::Sys.time()
[13:34:36.091]     ...future.result
[13:34:36.091] }
[13:34:36.093] assign_globals() ...
[13:34:36.094] List of 5
[13:34:36.094]  $ ...future.FUN            :function (C, k)  
[13:34:36.094]  $ MoreArgs                 : list()
[13:34:36.094]  $ ...future.elements_ii    :List of 2
[13:34:36.094]   ..$ :List of 2
[13:34:36.094]   .. ..$ : chr "A"
[13:34:36.094]   .. ..$ : chr "B"
[13:34:36.094]   ..$ :List of 2
[13:34:36.094]   .. ..$ : int 5
[13:34:36.094]   .. ..$ : int 4
[13:34:36.094]  $ ...future.seeds_ii       : NULL
[13:34:36.094]  $ ...future.globals.maxSize: NULL
[13:34:36.094]  - attr(*, "where")=List of 5
[13:34:36.094]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.094]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.094]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.094]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.094]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.094]  - attr(*, "resolved")= logi FALSE
[13:34:36.094]  - attr(*, "total_size")= num 3656
[13:34:36.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.094]  - attr(*, "already-done")= logi TRUE
[13:34:36.099] - reassign environment for ‘...future.FUN’
[13:34:36.099] - copied ‘...future.FUN’ to environment
[13:34:36.100] - copied ‘MoreArgs’ to environment
[13:34:36.100] - copied ‘...future.elements_ii’ to environment
[13:34:36.100] - copied ‘...future.seeds_ii’ to environment
[13:34:36.100] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.100] assign_globals() ... done
[13:34:36.100] requestCore(): workers = 2
[13:34:36.102] MulticoreFuture started
[13:34:36.103] - Launch lazy future ... done
[13:34:36.103] run() for ‘MulticoreFuture’ ... done
[13:34:36.103] Created future:
[13:34:36.103] plan(): Setting new future strategy stack:
[13:34:36.103] List of future strategies:
[13:34:36.103] 1. sequential:
[13:34:36.103]    - args: function (..., envir = parent.frame())
[13:34:36.103]    - tweaked: FALSE
[13:34:36.103]    - call: NULL
[13:34:36.104] plan(): nbrOfWorkers() = 1
[13:34:36.106] plan(): Setting new future strategy stack:
[13:34:36.106] List of future strategies:
[13:34:36.106] 1. multicore:
[13:34:36.106]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.106]    - tweaked: FALSE
[13:34:36.106]    - call: plan(strategy)
[13:34:36.112] plan(): nbrOfWorkers() = 2
[13:34:36.103] MulticoreFuture:
[13:34:36.103] Label: ‘future_.mapply-1’
[13:34:36.103] Expression:
[13:34:36.103] {
[13:34:36.103]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.103]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.103]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.103]         on.exit(options(oopts), add = TRUE)
[13:34:36.103]     }
[13:34:36.103]     {
[13:34:36.103]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.103]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.103]         do.call(mapply, args = args)
[13:34:36.103]     }
[13:34:36.103] }
[13:34:36.103] Lazy evaluation: FALSE
[13:34:36.103] Asynchronous evaluation: TRUE
[13:34:36.103] Local evaluation: TRUE
[13:34:36.103] Environment: R_GlobalEnv
[13:34:36.103] Capture standard output: TRUE
[13:34:36.103] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.103] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.103] Packages: <none>
[13:34:36.103] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.103] Resolved: TRUE
[13:34:36.103] Value: <not collected>
[13:34:36.103] Conditions captured: <none>
[13:34:36.103] Early signaling: FALSE
[13:34:36.103] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.103] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.113] Chunk #1 of 2 ... DONE
[13:34:36.113] Chunk #2 of 2 ...
[13:34:36.113]  - Finding globals in '...' for chunk #2 ...
[13:34:36.113] getGlobalsAndPackages() ...
[13:34:36.113] Searching for globals...
[13:34:36.114] 
[13:34:36.114] Searching for globals ... DONE
[13:34:36.114] - globals: [0] <none>
[13:34:36.114] getGlobalsAndPackages() ... DONE
[13:34:36.115]    + additional globals found: [n=0] 
[13:34:36.115]    + additional namespaces needed: [n=0] 
[13:34:36.115]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:36.115]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.115]  - seeds: <none>
[13:34:36.115]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.115] getGlobalsAndPackages() ...
[13:34:36.116] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.116] Resolving globals: FALSE
[13:34:36.117] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[13:34:36.118] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:36.118] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.118] 
[13:34:36.118] getGlobalsAndPackages() ... DONE
[13:34:36.119] run() for ‘Future’ ...
[13:34:36.119] - state: ‘created’
[13:34:36.119] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.124] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.124] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.124]   - Field: ‘label’
[13:34:36.124]   - Field: ‘local’
[13:34:36.125]   - Field: ‘owner’
[13:34:36.125]   - Field: ‘envir’
[13:34:36.125]   - Field: ‘workers’
[13:34:36.125]   - Field: ‘packages’
[13:34:36.125]   - Field: ‘gc’
[13:34:36.125]   - Field: ‘job’
[13:34:36.126]   - Field: ‘conditions’
[13:34:36.126]   - Field: ‘expr’
[13:34:36.126]   - Field: ‘uuid’
[13:34:36.126]   - Field: ‘seed’
[13:34:36.126]   - Field: ‘version’
[13:34:36.126]   - Field: ‘result’
[13:34:36.127]   - Field: ‘asynchronous’
[13:34:36.127]   - Field: ‘calls’
[13:34:36.127]   - Field: ‘globals’
[13:34:36.127]   - Field: ‘stdout’
[13:34:36.127]   - Field: ‘earlySignal’
[13:34:36.131]   - Field: ‘lazy’
[13:34:36.131]   - Field: ‘state’
[13:34:36.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.132] - Launch lazy future ...
[13:34:36.133] Packages needed by the future expression (n = 0): <none>
[13:34:36.133] Packages needed by future strategies (n = 0): <none>
[13:34:36.134] {
[13:34:36.134]     {
[13:34:36.134]         {
[13:34:36.134]             ...future.startTime <- base::Sys.time()
[13:34:36.134]             {
[13:34:36.134]                 {
[13:34:36.134]                   {
[13:34:36.134]                     {
[13:34:36.134]                       base::local({
[13:34:36.134]                         has_future <- base::requireNamespace("future", 
[13:34:36.134]                           quietly = TRUE)
[13:34:36.134]                         if (has_future) {
[13:34:36.134]                           ns <- base::getNamespace("future")
[13:34:36.134]                           version <- ns[[".package"]][["version"]]
[13:34:36.134]                           if (is.null(version)) 
[13:34:36.134]                             version <- utils::packageVersion("future")
[13:34:36.134]                         }
[13:34:36.134]                         else {
[13:34:36.134]                           version <- NULL
[13:34:36.134]                         }
[13:34:36.134]                         if (!has_future || version < "1.8.0") {
[13:34:36.134]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.134]                             "", base::R.version$version.string), 
[13:34:36.134]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.134]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.134]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.134]                               "release", "version")], collapse = " "), 
[13:34:36.134]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.134]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.134]                             info)
[13:34:36.134]                           info <- base::paste(info, collapse = "; ")
[13:34:36.134]                           if (!has_future) {
[13:34:36.134]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.134]                               info)
[13:34:36.134]                           }
[13:34:36.134]                           else {
[13:34:36.134]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.134]                               info, version)
[13:34:36.134]                           }
[13:34:36.134]                           base::stop(msg)
[13:34:36.134]                         }
[13:34:36.134]                       })
[13:34:36.134]                     }
[13:34:36.134]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.134]                     base::options(mc.cores = 1L)
[13:34:36.134]                   }
[13:34:36.134]                   ...future.strategy.old <- future::plan("list")
[13:34:36.134]                   options(future.plan = NULL)
[13:34:36.134]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.134]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.134]                 }
[13:34:36.134]                 ...future.workdir <- getwd()
[13:34:36.134]             }
[13:34:36.134]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.134]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.134]         }
[13:34:36.134]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.134]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.134]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.134]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.134]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.134]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.134]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.134]             base::names(...future.oldOptions))
[13:34:36.134]     }
[13:34:36.134]     if (FALSE) {
[13:34:36.134]     }
[13:34:36.134]     else {
[13:34:36.134]         if (TRUE) {
[13:34:36.134]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.134]                 open = "w")
[13:34:36.134]         }
[13:34:36.134]         else {
[13:34:36.134]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.134]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.134]         }
[13:34:36.134]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.134]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.134]             base::sink(type = "output", split = FALSE)
[13:34:36.134]             base::close(...future.stdout)
[13:34:36.134]         }, add = TRUE)
[13:34:36.134]     }
[13:34:36.134]     ...future.frame <- base::sys.nframe()
[13:34:36.134]     ...future.conditions <- base::list()
[13:34:36.134]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.134]     if (FALSE) {
[13:34:36.134]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.134]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.134]     }
[13:34:36.134]     ...future.result <- base::tryCatch({
[13:34:36.134]         base::withCallingHandlers({
[13:34:36.134]             ...future.value <- base::withVisible(base::local({
[13:34:36.134]                 withCallingHandlers({
[13:34:36.134]                   {
[13:34:36.134]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.134]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.134]                       ...future.globals.maxSize)) {
[13:34:36.134]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.134]                       on.exit(options(oopts), add = TRUE)
[13:34:36.134]                     }
[13:34:36.134]                     {
[13:34:36.134]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.134]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.134]                         USE.NAMES = FALSE)
[13:34:36.134]                       do.call(mapply, args = args)
[13:34:36.134]                     }
[13:34:36.134]                   }
[13:34:36.134]                 }, immediateCondition = function(cond) {
[13:34:36.134]                   save_rds <- function (object, pathname, ...) 
[13:34:36.134]                   {
[13:34:36.134]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.134]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.134]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.134]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.134]                         fi_tmp[["mtime"]])
[13:34:36.134]                     }
[13:34:36.134]                     tryCatch({
[13:34:36.134]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.134]                     }, error = function(ex) {
[13:34:36.134]                       msg <- conditionMessage(ex)
[13:34:36.134]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.134]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.134]                         fi_tmp[["mtime"]], msg)
[13:34:36.134]                       ex$message <- msg
[13:34:36.134]                       stop(ex)
[13:34:36.134]                     })
[13:34:36.134]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.134]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.134]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.134]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.134]                       fi <- file.info(pathname)
[13:34:36.134]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.134]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.134]                         fi[["size"]], fi[["mtime"]])
[13:34:36.134]                       stop(msg)
[13:34:36.134]                     }
[13:34:36.134]                     invisible(pathname)
[13:34:36.134]                   }
[13:34:36.134]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.134]                     rootPath = tempdir()) 
[13:34:36.134]                   {
[13:34:36.134]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.134]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.134]                       tmpdir = path, fileext = ".rds")
[13:34:36.134]                     save_rds(obj, file)
[13:34:36.134]                   }
[13:34:36.134]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.134]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.134]                   {
[13:34:36.134]                     inherits <- base::inherits
[13:34:36.134]                     invokeRestart <- base::invokeRestart
[13:34:36.134]                     is.null <- base::is.null
[13:34:36.134]                     muffled <- FALSE
[13:34:36.134]                     if (inherits(cond, "message")) {
[13:34:36.134]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.134]                       if (muffled) 
[13:34:36.134]                         invokeRestart("muffleMessage")
[13:34:36.134]                     }
[13:34:36.134]                     else if (inherits(cond, "warning")) {
[13:34:36.134]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.134]                       if (muffled) 
[13:34:36.134]                         invokeRestart("muffleWarning")
[13:34:36.134]                     }
[13:34:36.134]                     else if (inherits(cond, "condition")) {
[13:34:36.134]                       if (!is.null(pattern)) {
[13:34:36.134]                         computeRestarts <- base::computeRestarts
[13:34:36.134]                         grepl <- base::grepl
[13:34:36.134]                         restarts <- computeRestarts(cond)
[13:34:36.134]                         for (restart in restarts) {
[13:34:36.134]                           name <- restart$name
[13:34:36.134]                           if (is.null(name)) 
[13:34:36.134]                             next
[13:34:36.134]                           if (!grepl(pattern, name)) 
[13:34:36.134]                             next
[13:34:36.134]                           invokeRestart(restart)
[13:34:36.134]                           muffled <- TRUE
[13:34:36.134]                           break
[13:34:36.134]                         }
[13:34:36.134]                       }
[13:34:36.134]                     }
[13:34:36.134]                     invisible(muffled)
[13:34:36.134]                   }
[13:34:36.134]                   muffleCondition(cond)
[13:34:36.134]                 })
[13:34:36.134]             }))
[13:34:36.134]             future::FutureResult(value = ...future.value$value, 
[13:34:36.134]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.134]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.134]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.134]                     ...future.globalenv.names))
[13:34:36.134]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.134]         }, condition = base::local({
[13:34:36.134]             c <- base::c
[13:34:36.134]             inherits <- base::inherits
[13:34:36.134]             invokeRestart <- base::invokeRestart
[13:34:36.134]             length <- base::length
[13:34:36.134]             list <- base::list
[13:34:36.134]             seq.int <- base::seq.int
[13:34:36.134]             signalCondition <- base::signalCondition
[13:34:36.134]             sys.calls <- base::sys.calls
[13:34:36.134]             `[[` <- base::`[[`
[13:34:36.134]             `+` <- base::`+`
[13:34:36.134]             `<<-` <- base::`<<-`
[13:34:36.134]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.134]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.134]                   3L)]
[13:34:36.134]             }
[13:34:36.134]             function(cond) {
[13:34:36.134]                 is_error <- inherits(cond, "error")
[13:34:36.134]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.134]                   NULL)
[13:34:36.134]                 if (is_error) {
[13:34:36.134]                   sessionInformation <- function() {
[13:34:36.134]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.134]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.134]                       search = base::search(), system = base::Sys.info())
[13:34:36.134]                   }
[13:34:36.134]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.134]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.134]                     cond$call), session = sessionInformation(), 
[13:34:36.134]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.134]                   signalCondition(cond)
[13:34:36.134]                 }
[13:34:36.134]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.134]                 "immediateCondition"))) {
[13:34:36.134]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.134]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.134]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.134]                   if (TRUE && !signal) {
[13:34:36.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.134]                     {
[13:34:36.134]                       inherits <- base::inherits
[13:34:36.134]                       invokeRestart <- base::invokeRestart
[13:34:36.134]                       is.null <- base::is.null
[13:34:36.134]                       muffled <- FALSE
[13:34:36.134]                       if (inherits(cond, "message")) {
[13:34:36.134]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.134]                         if (muffled) 
[13:34:36.134]                           invokeRestart("muffleMessage")
[13:34:36.134]                       }
[13:34:36.134]                       else if (inherits(cond, "warning")) {
[13:34:36.134]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.134]                         if (muffled) 
[13:34:36.134]                           invokeRestart("muffleWarning")
[13:34:36.134]                       }
[13:34:36.134]                       else if (inherits(cond, "condition")) {
[13:34:36.134]                         if (!is.null(pattern)) {
[13:34:36.134]                           computeRestarts <- base::computeRestarts
[13:34:36.134]                           grepl <- base::grepl
[13:34:36.134]                           restarts <- computeRestarts(cond)
[13:34:36.134]                           for (restart in restarts) {
[13:34:36.134]                             name <- restart$name
[13:34:36.134]                             if (is.null(name)) 
[13:34:36.134]                               next
[13:34:36.134]                             if (!grepl(pattern, name)) 
[13:34:36.134]                               next
[13:34:36.134]                             invokeRestart(restart)
[13:34:36.134]                             muffled <- TRUE
[13:34:36.134]                             break
[13:34:36.134]                           }
[13:34:36.134]                         }
[13:34:36.134]                       }
[13:34:36.134]                       invisible(muffled)
[13:34:36.134]                     }
[13:34:36.134]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.134]                   }
[13:34:36.134]                 }
[13:34:36.134]                 else {
[13:34:36.134]                   if (TRUE) {
[13:34:36.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.134]                     {
[13:34:36.134]                       inherits <- base::inherits
[13:34:36.134]                       invokeRestart <- base::invokeRestart
[13:34:36.134]                       is.null <- base::is.null
[13:34:36.134]                       muffled <- FALSE
[13:34:36.134]                       if (inherits(cond, "message")) {
[13:34:36.134]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.134]                         if (muffled) 
[13:34:36.134]                           invokeRestart("muffleMessage")
[13:34:36.134]                       }
[13:34:36.134]                       else if (inherits(cond, "warning")) {
[13:34:36.134]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.134]                         if (muffled) 
[13:34:36.134]                           invokeRestart("muffleWarning")
[13:34:36.134]                       }
[13:34:36.134]                       else if (inherits(cond, "condition")) {
[13:34:36.134]                         if (!is.null(pattern)) {
[13:34:36.134]                           computeRestarts <- base::computeRestarts
[13:34:36.134]                           grepl <- base::grepl
[13:34:36.134]                           restarts <- computeRestarts(cond)
[13:34:36.134]                           for (restart in restarts) {
[13:34:36.134]                             name <- restart$name
[13:34:36.134]                             if (is.null(name)) 
[13:34:36.134]                               next
[13:34:36.134]                             if (!grepl(pattern, name)) 
[13:34:36.134]                               next
[13:34:36.134]                             invokeRestart(restart)
[13:34:36.134]                             muffled <- TRUE
[13:34:36.134]                             break
[13:34:36.134]                           }
[13:34:36.134]                         }
[13:34:36.134]                       }
[13:34:36.134]                       invisible(muffled)
[13:34:36.134]                     }
[13:34:36.134]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.134]                   }
[13:34:36.134]                 }
[13:34:36.134]             }
[13:34:36.134]         }))
[13:34:36.134]     }, error = function(ex) {
[13:34:36.134]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.134]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.134]                 ...future.rng), started = ...future.startTime, 
[13:34:36.134]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.134]             version = "1.8"), class = "FutureResult")
[13:34:36.134]     }, finally = {
[13:34:36.134]         if (!identical(...future.workdir, getwd())) 
[13:34:36.134]             setwd(...future.workdir)
[13:34:36.134]         {
[13:34:36.134]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.134]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.134]             }
[13:34:36.134]             base::options(...future.oldOptions)
[13:34:36.134]             if (.Platform$OS.type == "windows") {
[13:34:36.134]                 old_names <- names(...future.oldEnvVars)
[13:34:36.134]                 envs <- base::Sys.getenv()
[13:34:36.134]                 names <- names(envs)
[13:34:36.134]                 common <- intersect(names, old_names)
[13:34:36.134]                 added <- setdiff(names, old_names)
[13:34:36.134]                 removed <- setdiff(old_names, names)
[13:34:36.134]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.134]                   envs[common]]
[13:34:36.134]                 NAMES <- toupper(changed)
[13:34:36.134]                 args <- list()
[13:34:36.134]                 for (kk in seq_along(NAMES)) {
[13:34:36.134]                   name <- changed[[kk]]
[13:34:36.134]                   NAME <- NAMES[[kk]]
[13:34:36.134]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.134]                     next
[13:34:36.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.134]                 }
[13:34:36.134]                 NAMES <- toupper(added)
[13:34:36.134]                 for (kk in seq_along(NAMES)) {
[13:34:36.134]                   name <- added[[kk]]
[13:34:36.134]                   NAME <- NAMES[[kk]]
[13:34:36.134]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.134]                     next
[13:34:36.134]                   args[[name]] <- ""
[13:34:36.134]                 }
[13:34:36.134]                 NAMES <- toupper(removed)
[13:34:36.134]                 for (kk in seq_along(NAMES)) {
[13:34:36.134]                   name <- removed[[kk]]
[13:34:36.134]                   NAME <- NAMES[[kk]]
[13:34:36.134]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.134]                     next
[13:34:36.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.134]                 }
[13:34:36.134]                 if (length(args) > 0) 
[13:34:36.134]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.134]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.134]             }
[13:34:36.134]             else {
[13:34:36.134]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.134]             }
[13:34:36.134]             {
[13:34:36.134]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.134]                   0L) {
[13:34:36.134]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.134]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.134]                   base::options(opts)
[13:34:36.134]                 }
[13:34:36.134]                 {
[13:34:36.134]                   {
[13:34:36.134]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.134]                     NULL
[13:34:36.134]                   }
[13:34:36.134]                   options(future.plan = NULL)
[13:34:36.134]                   if (is.na(NA_character_)) 
[13:34:36.134]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.134]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.134]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.134]                     .init = FALSE)
[13:34:36.134]                 }
[13:34:36.134]             }
[13:34:36.134]         }
[13:34:36.134]     })
[13:34:36.134]     if (TRUE) {
[13:34:36.134]         base::sink(type = "output", split = FALSE)
[13:34:36.134]         if (TRUE) {
[13:34:36.134]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.134]         }
[13:34:36.134]         else {
[13:34:36.134]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.134]         }
[13:34:36.134]         base::close(...future.stdout)
[13:34:36.134]         ...future.stdout <- NULL
[13:34:36.134]     }
[13:34:36.134]     ...future.result$conditions <- ...future.conditions
[13:34:36.134]     ...future.result$finished <- base::Sys.time()
[13:34:36.134]     ...future.result
[13:34:36.134] }
[13:34:36.137] assign_globals() ...
[13:34:36.137] List of 5
[13:34:36.137]  $ ...future.FUN            :function (C, k)  
[13:34:36.137]  $ MoreArgs                 : list()
[13:34:36.137]  $ ...future.elements_ii    :List of 2
[13:34:36.137]   ..$ :List of 3
[13:34:36.137]   .. ..$ : chr "C"
[13:34:36.137]   .. ..$ : chr "D"
[13:34:36.137]   .. ..$ : chr "E"
[13:34:36.137]   ..$ :List of 3
[13:34:36.137]   .. ..$ : int 3
[13:34:36.137]   .. ..$ : int 2
[13:34:36.137]   .. ..$ : int 1
[13:34:36.137]  $ ...future.seeds_ii       : NULL
[13:34:36.137]  $ ...future.globals.maxSize: NULL
[13:34:36.137]  - attr(*, "where")=List of 5
[13:34:36.137]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.137]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.137]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.137]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.137]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.137]  - attr(*, "resolved")= logi FALSE
[13:34:36.137]  - attr(*, "total_size")= num 3824
[13:34:36.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.137]  - attr(*, "already-done")= logi TRUE
[13:34:36.148] - reassign environment for ‘...future.FUN’
[13:34:36.149] - copied ‘...future.FUN’ to environment
[13:34:36.149] - copied ‘MoreArgs’ to environment
[13:34:36.149] - copied ‘...future.elements_ii’ to environment
[13:34:36.149] - copied ‘...future.seeds_ii’ to environment
[13:34:36.149] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.149] assign_globals() ... done
[13:34:36.149] requestCore(): workers = 2
[13:34:36.152] MulticoreFuture started
[13:34:36.152] - Launch lazy future ... done
[13:34:36.152] run() for ‘MulticoreFuture’ ... done
[13:34:36.153] Created future:
[13:34:36.153] plan(): Setting new future strategy stack:
[13:34:36.153] List of future strategies:
[13:34:36.153] 1. sequential:
[13:34:36.153]    - args: function (..., envir = parent.frame())
[13:34:36.153]    - tweaked: FALSE
[13:34:36.153]    - call: NULL
[13:34:36.154] plan(): nbrOfWorkers() = 1
[13:34:36.156] plan(): Setting new future strategy stack:
[13:34:36.156] List of future strategies:
[13:34:36.156] 1. multicore:
[13:34:36.156]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.156]    - tweaked: FALSE
[13:34:36.156]    - call: plan(strategy)
[13:34:36.161] plan(): nbrOfWorkers() = 2
[13:34:36.153] MulticoreFuture:
[13:34:36.153] Label: ‘future_.mapply-2’
[13:34:36.153] Expression:
[13:34:36.153] {
[13:34:36.153]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.153]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.153]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.153]         on.exit(options(oopts), add = TRUE)
[13:34:36.153]     }
[13:34:36.153]     {
[13:34:36.153]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.153]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.153]         do.call(mapply, args = args)
[13:34:36.153]     }
[13:34:36.153] }
[13:34:36.153] Lazy evaluation: FALSE
[13:34:36.153] Asynchronous evaluation: TRUE
[13:34:36.153] Local evaluation: TRUE
[13:34:36.153] Environment: R_GlobalEnv
[13:34:36.153] Capture standard output: TRUE
[13:34:36.153] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.153] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.153] Packages: <none>
[13:34:36.153] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.153] Resolved: TRUE
[13:34:36.153] Value: <not collected>
[13:34:36.153] Conditions captured: <none>
[13:34:36.153] Early signaling: FALSE
[13:34:36.153] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.153] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.162] Chunk #2 of 2 ... DONE
[13:34:36.163] Launching 2 futures (chunks) ... DONE
[13:34:36.163] Resolving 2 futures (chunks) ...
[13:34:36.163] resolve() on list ...
[13:34:36.163]  recursive: 0
[13:34:36.163]  length: 2
[13:34:36.163] 
[13:34:36.164] Future #1
[13:34:36.164] result() for MulticoreFuture ...
[13:34:36.165] result() for MulticoreFuture ...
[13:34:36.165] result() for MulticoreFuture ... done
[13:34:36.165] result() for MulticoreFuture ... done
[13:34:36.165] result() for MulticoreFuture ...
[13:34:36.165] result() for MulticoreFuture ... done
[13:34:36.166] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:36.166] - nx: 2
[13:34:36.166] - relay: TRUE
[13:34:36.166] - stdout: TRUE
[13:34:36.166] - signal: TRUE
[13:34:36.166] - resignal: FALSE
[13:34:36.167] - force: TRUE
[13:34:36.167] - relayed: [n=2] FALSE, FALSE
[13:34:36.167] - queued futures: [n=2] FALSE, FALSE
[13:34:36.167]  - until=1
[13:34:36.167]  - relaying element #1
[13:34:36.167] result() for MulticoreFuture ...
[13:34:36.167] result() for MulticoreFuture ... done
[13:34:36.168] result() for MulticoreFuture ...
[13:34:36.168] result() for MulticoreFuture ... done
[13:34:36.168] result() for MulticoreFuture ...
[13:34:36.168] result() for MulticoreFuture ... done
[13:34:36.168] result() for MulticoreFuture ...
[13:34:36.169] result() for MulticoreFuture ... done
[13:34:36.169] - relayed: [n=2] TRUE, FALSE
[13:34:36.169] - queued futures: [n=2] TRUE, FALSE
[13:34:36.169] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:36.169]  length: 1 (resolved future 1)
[13:34:36.170] Future #2
[13:34:36.170] result() for MulticoreFuture ...
[13:34:36.170] result() for MulticoreFuture ...
[13:34:36.171] result() for MulticoreFuture ... done
[13:34:36.171] result() for MulticoreFuture ... done
[13:34:36.171] result() for MulticoreFuture ...
[13:34:36.171] result() for MulticoreFuture ... done
[13:34:36.171] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:36.171] - nx: 2
[13:34:36.172] - relay: TRUE
[13:34:36.172] - stdout: TRUE
[13:34:36.172] - signal: TRUE
[13:34:36.172] - resignal: FALSE
[13:34:36.172] - force: TRUE
[13:34:36.172] - relayed: [n=2] TRUE, FALSE
[13:34:36.172] - queued futures: [n=2] TRUE, FALSE
[13:34:36.172]  - until=2
[13:34:36.173]  - relaying element #2
[13:34:36.173] result() for MulticoreFuture ...
[13:34:36.173] result() for MulticoreFuture ... done
[13:34:36.173] result() for MulticoreFuture ...
[13:34:36.173] result() for MulticoreFuture ... done
[13:34:36.173] result() for MulticoreFuture ...
[13:34:36.173] result() for MulticoreFuture ... done
[13:34:36.176] result() for MulticoreFuture ...
[13:34:36.177] result() for MulticoreFuture ... done
[13:34:36.177] - relayed: [n=2] TRUE, TRUE
[13:34:36.177] - queued futures: [n=2] TRUE, TRUE
[13:34:36.177] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:36.177]  length: 0 (resolved future 2)
[13:34:36.178] Relaying remaining futures
[13:34:36.178] signalConditionsASAP(NULL, pos=0) ...
[13:34:36.178] - nx: 2
[13:34:36.178] - relay: TRUE
[13:34:36.178] - stdout: TRUE
[13:34:36.178] - signal: TRUE
[13:34:36.179] - resignal: FALSE
[13:34:36.179] - force: TRUE
[13:34:36.179] - relayed: [n=2] TRUE, TRUE
[13:34:36.179] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:36.179] - relayed: [n=2] TRUE, TRUE
[13:34:36.179] - queued futures: [n=2] TRUE, TRUE
[13:34:36.179] signalConditionsASAP(NULL, pos=0) ... done
[13:34:36.180] resolve() on list ... DONE
[13:34:36.180] result() for MulticoreFuture ...
[13:34:36.180] result() for MulticoreFuture ... done
[13:34:36.180] result() for MulticoreFuture ...
[13:34:36.180] result() for MulticoreFuture ... done
[13:34:36.180] result() for MulticoreFuture ...
[13:34:36.181] result() for MulticoreFuture ... done
[13:34:36.181] result() for MulticoreFuture ...
[13:34:36.181] result() for MulticoreFuture ... done
[13:34:36.181]  - Number of value chunks collected: 2
[13:34:36.181] Resolving 2 futures (chunks) ... DONE
[13:34:36.181] Reducing values from 2 chunks ...
[13:34:36.181]  - Number of values collected after concatenation: 5
[13:34:36.182]  - Number of values expected: 5
[13:34:36.182] Reducing values from 2 chunks ... DONE
[13:34:36.182] future_mapply() ... DONE
[13:34:36.182] future_mapply() ...
[13:34:36.186] Number of chunks: 2
[13:34:36.187] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[13:34:36.187] getGlobalsAndPackagesXApply() ...
[13:34:36.187]  - future.globals: TRUE
[13:34:36.187] getGlobalsAndPackages() ...
[13:34:36.187] Searching for globals...
[13:34:36.189] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:36.189] Searching for globals ... DONE
[13:34:36.189] Resolving globals: FALSE
[13:34:36.190] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:36.190] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:36.190] - globals: [1] ‘FUN’
[13:34:36.190] 
[13:34:36.190] getGlobalsAndPackages() ... DONE
[13:34:36.190]  - globals found/used: [n=1] ‘FUN’
[13:34:36.191]  - needed namespaces: [n=0] 
[13:34:36.191] Finding globals ... DONE
[13:34:36.191] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:36.191] List of 2
[13:34:36.191]  $ ...future.FUN:function (C, k)  
[13:34:36.191]  $ MoreArgs     : NULL
[13:34:36.191]  - attr(*, "where")=List of 2
[13:34:36.191]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:36.191]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:36.191]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.191]  - attr(*, "resolved")= logi FALSE
[13:34:36.191]  - attr(*, "total_size")= num NA
[13:34:36.194] Packages to be attached in all futures: [n=0] 
[13:34:36.194] getGlobalsAndPackagesXApply() ... DONE
[13:34:36.194] Number of futures (= number of chunks): 2
[13:34:36.194] Launching 2 futures (chunks) ...
[13:34:36.194] Chunk #1 of 2 ...
[13:34:36.194]  - Finding globals in '...' for chunk #1 ...
[13:34:36.195] getGlobalsAndPackages() ...
[13:34:36.195] Searching for globals...
[13:34:36.195] 
[13:34:36.195] Searching for globals ... DONE
[13:34:36.195] - globals: [0] <none>
[13:34:36.195] getGlobalsAndPackages() ... DONE
[13:34:36.195]    + additional globals found: [n=0] 
[13:34:36.195]    + additional namespaces needed: [n=0] 
[13:34:36.196]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:36.196]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.196]  - seeds: <none>
[13:34:36.196]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.196] getGlobalsAndPackages() ...
[13:34:36.196] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.196] Resolving globals: FALSE
[13:34:36.197] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:36.197] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:36.197] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.197] 
[13:34:36.197] getGlobalsAndPackages() ... DONE
[13:34:36.198] run() for ‘Future’ ...
[13:34:36.198] - state: ‘created’
[13:34:36.198] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.202] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.202]   - Field: ‘label’
[13:34:36.202]   - Field: ‘local’
[13:34:36.202]   - Field: ‘owner’
[13:34:36.202]   - Field: ‘envir’
[13:34:36.202]   - Field: ‘workers’
[13:34:36.202]   - Field: ‘packages’
[13:34:36.202]   - Field: ‘gc’
[13:34:36.203]   - Field: ‘job’
[13:34:36.205]   - Field: ‘conditions’
[13:34:36.205]   - Field: ‘expr’
[13:34:36.205]   - Field: ‘uuid’
[13:34:36.205]   - Field: ‘seed’
[13:34:36.205]   - Field: ‘version’
[13:34:36.205]   - Field: ‘result’
[13:34:36.205]   - Field: ‘asynchronous’
[13:34:36.206]   - Field: ‘calls’
[13:34:36.206]   - Field: ‘globals’
[13:34:36.206]   - Field: ‘stdout’
[13:34:36.206]   - Field: ‘earlySignal’
[13:34:36.206]   - Field: ‘lazy’
[13:34:36.206]   - Field: ‘state’
[13:34:36.206] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.206] - Launch lazy future ...
[13:34:36.207] Packages needed by the future expression (n = 0): <none>
[13:34:36.207] Packages needed by future strategies (n = 0): <none>
[13:34:36.207] {
[13:34:36.207]     {
[13:34:36.207]         {
[13:34:36.207]             ...future.startTime <- base::Sys.time()
[13:34:36.207]             {
[13:34:36.207]                 {
[13:34:36.207]                   {
[13:34:36.207]                     {
[13:34:36.207]                       base::local({
[13:34:36.207]                         has_future <- base::requireNamespace("future", 
[13:34:36.207]                           quietly = TRUE)
[13:34:36.207]                         if (has_future) {
[13:34:36.207]                           ns <- base::getNamespace("future")
[13:34:36.207]                           version <- ns[[".package"]][["version"]]
[13:34:36.207]                           if (is.null(version)) 
[13:34:36.207]                             version <- utils::packageVersion("future")
[13:34:36.207]                         }
[13:34:36.207]                         else {
[13:34:36.207]                           version <- NULL
[13:34:36.207]                         }
[13:34:36.207]                         if (!has_future || version < "1.8.0") {
[13:34:36.207]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.207]                             "", base::R.version$version.string), 
[13:34:36.207]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.207]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.207]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.207]                               "release", "version")], collapse = " "), 
[13:34:36.207]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.207]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.207]                             info)
[13:34:36.207]                           info <- base::paste(info, collapse = "; ")
[13:34:36.207]                           if (!has_future) {
[13:34:36.207]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.207]                               info)
[13:34:36.207]                           }
[13:34:36.207]                           else {
[13:34:36.207]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.207]                               info, version)
[13:34:36.207]                           }
[13:34:36.207]                           base::stop(msg)
[13:34:36.207]                         }
[13:34:36.207]                       })
[13:34:36.207]                     }
[13:34:36.207]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.207]                     base::options(mc.cores = 1L)
[13:34:36.207]                   }
[13:34:36.207]                   ...future.strategy.old <- future::plan("list")
[13:34:36.207]                   options(future.plan = NULL)
[13:34:36.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.207]                 }
[13:34:36.207]                 ...future.workdir <- getwd()
[13:34:36.207]             }
[13:34:36.207]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.207]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.207]         }
[13:34:36.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.207]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.207]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.207]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.207]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.207]             base::names(...future.oldOptions))
[13:34:36.207]     }
[13:34:36.207]     if (FALSE) {
[13:34:36.207]     }
[13:34:36.207]     else {
[13:34:36.207]         if (TRUE) {
[13:34:36.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.207]                 open = "w")
[13:34:36.207]         }
[13:34:36.207]         else {
[13:34:36.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.207]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.207]         }
[13:34:36.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.207]             base::sink(type = "output", split = FALSE)
[13:34:36.207]             base::close(...future.stdout)
[13:34:36.207]         }, add = TRUE)
[13:34:36.207]     }
[13:34:36.207]     ...future.frame <- base::sys.nframe()
[13:34:36.207]     ...future.conditions <- base::list()
[13:34:36.207]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.207]     if (FALSE) {
[13:34:36.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.207]     }
[13:34:36.207]     ...future.result <- base::tryCatch({
[13:34:36.207]         base::withCallingHandlers({
[13:34:36.207]             ...future.value <- base::withVisible(base::local({
[13:34:36.207]                 withCallingHandlers({
[13:34:36.207]                   {
[13:34:36.207]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.207]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.207]                       ...future.globals.maxSize)) {
[13:34:36.207]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.207]                       on.exit(options(oopts), add = TRUE)
[13:34:36.207]                     }
[13:34:36.207]                     {
[13:34:36.207]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.207]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.207]                         USE.NAMES = FALSE)
[13:34:36.207]                       do.call(mapply, args = args)
[13:34:36.207]                     }
[13:34:36.207]                   }
[13:34:36.207]                 }, immediateCondition = function(cond) {
[13:34:36.207]                   save_rds <- function (object, pathname, ...) 
[13:34:36.207]                   {
[13:34:36.207]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.207]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.207]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.207]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.207]                         fi_tmp[["mtime"]])
[13:34:36.207]                     }
[13:34:36.207]                     tryCatch({
[13:34:36.207]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.207]                     }, error = function(ex) {
[13:34:36.207]                       msg <- conditionMessage(ex)
[13:34:36.207]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.207]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.207]                         fi_tmp[["mtime"]], msg)
[13:34:36.207]                       ex$message <- msg
[13:34:36.207]                       stop(ex)
[13:34:36.207]                     })
[13:34:36.207]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.207]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.207]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.207]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.207]                       fi <- file.info(pathname)
[13:34:36.207]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.207]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.207]                         fi[["size"]], fi[["mtime"]])
[13:34:36.207]                       stop(msg)
[13:34:36.207]                     }
[13:34:36.207]                     invisible(pathname)
[13:34:36.207]                   }
[13:34:36.207]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.207]                     rootPath = tempdir()) 
[13:34:36.207]                   {
[13:34:36.207]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.207]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.207]                       tmpdir = path, fileext = ".rds")
[13:34:36.207]                     save_rds(obj, file)
[13:34:36.207]                   }
[13:34:36.207]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.207]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.207]                   {
[13:34:36.207]                     inherits <- base::inherits
[13:34:36.207]                     invokeRestart <- base::invokeRestart
[13:34:36.207]                     is.null <- base::is.null
[13:34:36.207]                     muffled <- FALSE
[13:34:36.207]                     if (inherits(cond, "message")) {
[13:34:36.207]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.207]                       if (muffled) 
[13:34:36.207]                         invokeRestart("muffleMessage")
[13:34:36.207]                     }
[13:34:36.207]                     else if (inherits(cond, "warning")) {
[13:34:36.207]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.207]                       if (muffled) 
[13:34:36.207]                         invokeRestart("muffleWarning")
[13:34:36.207]                     }
[13:34:36.207]                     else if (inherits(cond, "condition")) {
[13:34:36.207]                       if (!is.null(pattern)) {
[13:34:36.207]                         computeRestarts <- base::computeRestarts
[13:34:36.207]                         grepl <- base::grepl
[13:34:36.207]                         restarts <- computeRestarts(cond)
[13:34:36.207]                         for (restart in restarts) {
[13:34:36.207]                           name <- restart$name
[13:34:36.207]                           if (is.null(name)) 
[13:34:36.207]                             next
[13:34:36.207]                           if (!grepl(pattern, name)) 
[13:34:36.207]                             next
[13:34:36.207]                           invokeRestart(restart)
[13:34:36.207]                           muffled <- TRUE
[13:34:36.207]                           break
[13:34:36.207]                         }
[13:34:36.207]                       }
[13:34:36.207]                     }
[13:34:36.207]                     invisible(muffled)
[13:34:36.207]                   }
[13:34:36.207]                   muffleCondition(cond)
[13:34:36.207]                 })
[13:34:36.207]             }))
[13:34:36.207]             future::FutureResult(value = ...future.value$value, 
[13:34:36.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.207]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.207]                     ...future.globalenv.names))
[13:34:36.207]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.207]         }, condition = base::local({
[13:34:36.207]             c <- base::c
[13:34:36.207]             inherits <- base::inherits
[13:34:36.207]             invokeRestart <- base::invokeRestart
[13:34:36.207]             length <- base::length
[13:34:36.207]             list <- base::list
[13:34:36.207]             seq.int <- base::seq.int
[13:34:36.207]             signalCondition <- base::signalCondition
[13:34:36.207]             sys.calls <- base::sys.calls
[13:34:36.207]             `[[` <- base::`[[`
[13:34:36.207]             `+` <- base::`+`
[13:34:36.207]             `<<-` <- base::`<<-`
[13:34:36.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.207]                   3L)]
[13:34:36.207]             }
[13:34:36.207]             function(cond) {
[13:34:36.207]                 is_error <- inherits(cond, "error")
[13:34:36.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.207]                   NULL)
[13:34:36.207]                 if (is_error) {
[13:34:36.207]                   sessionInformation <- function() {
[13:34:36.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.207]                       search = base::search(), system = base::Sys.info())
[13:34:36.207]                   }
[13:34:36.207]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.207]                     cond$call), session = sessionInformation(), 
[13:34:36.207]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.207]                   signalCondition(cond)
[13:34:36.207]                 }
[13:34:36.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.207]                 "immediateCondition"))) {
[13:34:36.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.207]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.207]                   if (TRUE && !signal) {
[13:34:36.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.207]                     {
[13:34:36.207]                       inherits <- base::inherits
[13:34:36.207]                       invokeRestart <- base::invokeRestart
[13:34:36.207]                       is.null <- base::is.null
[13:34:36.207]                       muffled <- FALSE
[13:34:36.207]                       if (inherits(cond, "message")) {
[13:34:36.207]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.207]                         if (muffled) 
[13:34:36.207]                           invokeRestart("muffleMessage")
[13:34:36.207]                       }
[13:34:36.207]                       else if (inherits(cond, "warning")) {
[13:34:36.207]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.207]                         if (muffled) 
[13:34:36.207]                           invokeRestart("muffleWarning")
[13:34:36.207]                       }
[13:34:36.207]                       else if (inherits(cond, "condition")) {
[13:34:36.207]                         if (!is.null(pattern)) {
[13:34:36.207]                           computeRestarts <- base::computeRestarts
[13:34:36.207]                           grepl <- base::grepl
[13:34:36.207]                           restarts <- computeRestarts(cond)
[13:34:36.207]                           for (restart in restarts) {
[13:34:36.207]                             name <- restart$name
[13:34:36.207]                             if (is.null(name)) 
[13:34:36.207]                               next
[13:34:36.207]                             if (!grepl(pattern, name)) 
[13:34:36.207]                               next
[13:34:36.207]                             invokeRestart(restart)
[13:34:36.207]                             muffled <- TRUE
[13:34:36.207]                             break
[13:34:36.207]                           }
[13:34:36.207]                         }
[13:34:36.207]                       }
[13:34:36.207]                       invisible(muffled)
[13:34:36.207]                     }
[13:34:36.207]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.207]                   }
[13:34:36.207]                 }
[13:34:36.207]                 else {
[13:34:36.207]                   if (TRUE) {
[13:34:36.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.207]                     {
[13:34:36.207]                       inherits <- base::inherits
[13:34:36.207]                       invokeRestart <- base::invokeRestart
[13:34:36.207]                       is.null <- base::is.null
[13:34:36.207]                       muffled <- FALSE
[13:34:36.207]                       if (inherits(cond, "message")) {
[13:34:36.207]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.207]                         if (muffled) 
[13:34:36.207]                           invokeRestart("muffleMessage")
[13:34:36.207]                       }
[13:34:36.207]                       else if (inherits(cond, "warning")) {
[13:34:36.207]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.207]                         if (muffled) 
[13:34:36.207]                           invokeRestart("muffleWarning")
[13:34:36.207]                       }
[13:34:36.207]                       else if (inherits(cond, "condition")) {
[13:34:36.207]                         if (!is.null(pattern)) {
[13:34:36.207]                           computeRestarts <- base::computeRestarts
[13:34:36.207]                           grepl <- base::grepl
[13:34:36.207]                           restarts <- computeRestarts(cond)
[13:34:36.207]                           for (restart in restarts) {
[13:34:36.207]                             name <- restart$name
[13:34:36.207]                             if (is.null(name)) 
[13:34:36.207]                               next
[13:34:36.207]                             if (!grepl(pattern, name)) 
[13:34:36.207]                               next
[13:34:36.207]                             invokeRestart(restart)
[13:34:36.207]                             muffled <- TRUE
[13:34:36.207]                             break
[13:34:36.207]                           }
[13:34:36.207]                         }
[13:34:36.207]                       }
[13:34:36.207]                       invisible(muffled)
[13:34:36.207]                     }
[13:34:36.207]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.207]                   }
[13:34:36.207]                 }
[13:34:36.207]             }
[13:34:36.207]         }))
[13:34:36.207]     }, error = function(ex) {
[13:34:36.207]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.207]                 ...future.rng), started = ...future.startTime, 
[13:34:36.207]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.207]             version = "1.8"), class = "FutureResult")
[13:34:36.207]     }, finally = {
[13:34:36.207]         if (!identical(...future.workdir, getwd())) 
[13:34:36.207]             setwd(...future.workdir)
[13:34:36.207]         {
[13:34:36.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.207]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.207]             }
[13:34:36.207]             base::options(...future.oldOptions)
[13:34:36.207]             if (.Platform$OS.type == "windows") {
[13:34:36.207]                 old_names <- names(...future.oldEnvVars)
[13:34:36.207]                 envs <- base::Sys.getenv()
[13:34:36.207]                 names <- names(envs)
[13:34:36.207]                 common <- intersect(names, old_names)
[13:34:36.207]                 added <- setdiff(names, old_names)
[13:34:36.207]                 removed <- setdiff(old_names, names)
[13:34:36.207]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.207]                   envs[common]]
[13:34:36.207]                 NAMES <- toupper(changed)
[13:34:36.207]                 args <- list()
[13:34:36.207]                 for (kk in seq_along(NAMES)) {
[13:34:36.207]                   name <- changed[[kk]]
[13:34:36.207]                   NAME <- NAMES[[kk]]
[13:34:36.207]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.207]                     next
[13:34:36.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.207]                 }
[13:34:36.207]                 NAMES <- toupper(added)
[13:34:36.207]                 for (kk in seq_along(NAMES)) {
[13:34:36.207]                   name <- added[[kk]]
[13:34:36.207]                   NAME <- NAMES[[kk]]
[13:34:36.207]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.207]                     next
[13:34:36.207]                   args[[name]] <- ""
[13:34:36.207]                 }
[13:34:36.207]                 NAMES <- toupper(removed)
[13:34:36.207]                 for (kk in seq_along(NAMES)) {
[13:34:36.207]                   name <- removed[[kk]]
[13:34:36.207]                   NAME <- NAMES[[kk]]
[13:34:36.207]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.207]                     next
[13:34:36.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.207]                 }
[13:34:36.207]                 if (length(args) > 0) 
[13:34:36.207]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.207]             }
[13:34:36.207]             else {
[13:34:36.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.207]             }
[13:34:36.207]             {
[13:34:36.207]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.207]                   0L) {
[13:34:36.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.207]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.207]                   base::options(opts)
[13:34:36.207]                 }
[13:34:36.207]                 {
[13:34:36.207]                   {
[13:34:36.207]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.207]                     NULL
[13:34:36.207]                   }
[13:34:36.207]                   options(future.plan = NULL)
[13:34:36.207]                   if (is.na(NA_character_)) 
[13:34:36.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.207]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.207]                     .init = FALSE)
[13:34:36.207]                 }
[13:34:36.207]             }
[13:34:36.207]         }
[13:34:36.207]     })
[13:34:36.207]     if (TRUE) {
[13:34:36.207]         base::sink(type = "output", split = FALSE)
[13:34:36.207]         if (TRUE) {
[13:34:36.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.207]         }
[13:34:36.207]         else {
[13:34:36.207]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.207]         }
[13:34:36.207]         base::close(...future.stdout)
[13:34:36.207]         ...future.stdout <- NULL
[13:34:36.207]     }
[13:34:36.207]     ...future.result$conditions <- ...future.conditions
[13:34:36.207]     ...future.result$finished <- base::Sys.time()
[13:34:36.207]     ...future.result
[13:34:36.207] }
[13:34:36.210] assign_globals() ...
[13:34:36.210] List of 5
[13:34:36.210]  $ ...future.FUN            :function (C, k)  
[13:34:36.210]  $ MoreArgs                 : NULL
[13:34:36.210]  $ ...future.elements_ii    :List of 2
[13:34:36.210]   ..$ :List of 2
[13:34:36.210]   .. ..$ : chr "E"
[13:34:36.210]   .. ..$ : chr "D"
[13:34:36.210]   ..$ :List of 2
[13:34:36.210]   .. ..$ : int 1
[13:34:36.210]   .. ..$ : int 2
[13:34:36.210]  $ ...future.seeds_ii       : NULL
[13:34:36.210]  $ ...future.globals.maxSize: NULL
[13:34:36.210]  - attr(*, "where")=List of 5
[13:34:36.210]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.210]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.210]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.210]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.210]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.210]  - attr(*, "resolved")= logi FALSE
[13:34:36.210]  - attr(*, "total_size")= num 3656
[13:34:36.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.210]  - attr(*, "already-done")= logi TRUE
[13:34:36.215] - reassign environment for ‘...future.FUN’
[13:34:36.215] - copied ‘...future.FUN’ to environment
[13:34:36.216] - copied ‘MoreArgs’ to environment
[13:34:36.216] - copied ‘...future.elements_ii’ to environment
[13:34:36.216] - copied ‘...future.seeds_ii’ to environment
[13:34:36.216] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.216] assign_globals() ... done
[13:34:36.216] requestCore(): workers = 2
[13:34:36.218] MulticoreFuture started
[13:34:36.218] - Launch lazy future ... done
[13:34:36.219] run() for ‘MulticoreFuture’ ... done
[13:34:36.219] Created future:
[13:34:36.219] plan(): Setting new future strategy stack:
[13:34:36.219] List of future strategies:
[13:34:36.219] 1. sequential:
[13:34:36.219]    - args: function (..., envir = parent.frame())
[13:34:36.219]    - tweaked: FALSE
[13:34:36.219]    - call: NULL
[13:34:36.220] plan(): nbrOfWorkers() = 1
[13:34:36.222] plan(): Setting new future strategy stack:
[13:34:36.222] List of future strategies:
[13:34:36.222] 1. multicore:
[13:34:36.222]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.222]    - tweaked: FALSE
[13:34:36.222]    - call: plan(strategy)
[13:34:36.228] plan(): nbrOfWorkers() = 2
[13:34:36.219] MulticoreFuture:
[13:34:36.219] Label: ‘future_mapply-1’
[13:34:36.219] Expression:
[13:34:36.219] {
[13:34:36.219]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.219]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.219]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.219]         on.exit(options(oopts), add = TRUE)
[13:34:36.219]     }
[13:34:36.219]     {
[13:34:36.219]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.219]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.219]         do.call(mapply, args = args)
[13:34:36.219]     }
[13:34:36.219] }
[13:34:36.219] Lazy evaluation: FALSE
[13:34:36.219] Asynchronous evaluation: TRUE
[13:34:36.219] Local evaluation: TRUE
[13:34:36.219] Environment: R_GlobalEnv
[13:34:36.219] Capture standard output: TRUE
[13:34:36.219] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.219] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.219] Packages: <none>
[13:34:36.219] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.219] Resolved: TRUE
[13:34:36.219] Value: <not collected>
[13:34:36.219] Conditions captured: <none>
[13:34:36.219] Early signaling: FALSE
[13:34:36.219] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.219] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.229] Chunk #1 of 2 ... DONE
[13:34:36.229] Chunk #2 of 2 ...
[13:34:36.229]  - Finding globals in '...' for chunk #2 ...
[13:34:36.229] getGlobalsAndPackages() ...
[13:34:36.229] Searching for globals...
[13:34:36.230] 
[13:34:36.230] Searching for globals ... DONE
[13:34:36.230] - globals: [0] <none>
[13:34:36.230] getGlobalsAndPackages() ... DONE
[13:34:36.230]    + additional globals found: [n=0] 
[13:34:36.231]    + additional namespaces needed: [n=0] 
[13:34:36.231]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:36.231]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.231]  - seeds: <none>
[13:34:36.231]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.231] getGlobalsAndPackages() ...
[13:34:36.231] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.232] Resolving globals: FALSE
[13:34:36.233] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[13:34:36.233] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:36.234] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.234] 
[13:34:36.234] getGlobalsAndPackages() ... DONE
[13:34:36.234] run() for ‘Future’ ...
[13:34:36.235] - state: ‘created’
[13:34:36.235] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.240] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.240]   - Field: ‘label’
[13:34:36.240]   - Field: ‘local’
[13:34:36.240]   - Field: ‘owner’
[13:34:36.240]   - Field: ‘envir’
[13:34:36.241]   - Field: ‘workers’
[13:34:36.241]   - Field: ‘packages’
[13:34:36.241]   - Field: ‘gc’
[13:34:36.241]   - Field: ‘job’
[13:34:36.241]   - Field: ‘conditions’
[13:34:36.241]   - Field: ‘expr’
[13:34:36.245]   - Field: ‘uuid’
[13:34:36.245]   - Field: ‘seed’
[13:34:36.246]   - Field: ‘version’
[13:34:36.246]   - Field: ‘result’
[13:34:36.246]   - Field: ‘asynchronous’
[13:34:36.247]   - Field: ‘calls’
[13:34:36.247]   - Field: ‘globals’
[13:34:36.247]   - Field: ‘stdout’
[13:34:36.248]   - Field: ‘earlySignal’
[13:34:36.248]   - Field: ‘lazy’
[13:34:36.248]   - Field: ‘state’
[13:34:36.248] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.249] - Launch lazy future ...
[13:34:36.249] Packages needed by the future expression (n = 0): <none>
[13:34:36.249] Packages needed by future strategies (n = 0): <none>
[13:34:36.250] {
[13:34:36.250]     {
[13:34:36.250]         {
[13:34:36.250]             ...future.startTime <- base::Sys.time()
[13:34:36.250]             {
[13:34:36.250]                 {
[13:34:36.250]                   {
[13:34:36.250]                     {
[13:34:36.250]                       base::local({
[13:34:36.250]                         has_future <- base::requireNamespace("future", 
[13:34:36.250]                           quietly = TRUE)
[13:34:36.250]                         if (has_future) {
[13:34:36.250]                           ns <- base::getNamespace("future")
[13:34:36.250]                           version <- ns[[".package"]][["version"]]
[13:34:36.250]                           if (is.null(version)) 
[13:34:36.250]                             version <- utils::packageVersion("future")
[13:34:36.250]                         }
[13:34:36.250]                         else {
[13:34:36.250]                           version <- NULL
[13:34:36.250]                         }
[13:34:36.250]                         if (!has_future || version < "1.8.0") {
[13:34:36.250]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.250]                             "", base::R.version$version.string), 
[13:34:36.250]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.250]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.250]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.250]                               "release", "version")], collapse = " "), 
[13:34:36.250]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.250]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.250]                             info)
[13:34:36.250]                           info <- base::paste(info, collapse = "; ")
[13:34:36.250]                           if (!has_future) {
[13:34:36.250]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.250]                               info)
[13:34:36.250]                           }
[13:34:36.250]                           else {
[13:34:36.250]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.250]                               info, version)
[13:34:36.250]                           }
[13:34:36.250]                           base::stop(msg)
[13:34:36.250]                         }
[13:34:36.250]                       })
[13:34:36.250]                     }
[13:34:36.250]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.250]                     base::options(mc.cores = 1L)
[13:34:36.250]                   }
[13:34:36.250]                   ...future.strategy.old <- future::plan("list")
[13:34:36.250]                   options(future.plan = NULL)
[13:34:36.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.250]                 }
[13:34:36.250]                 ...future.workdir <- getwd()
[13:34:36.250]             }
[13:34:36.250]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.250]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.250]         }
[13:34:36.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.250]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.250]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.250]             base::names(...future.oldOptions))
[13:34:36.250]     }
[13:34:36.250]     if (FALSE) {
[13:34:36.250]     }
[13:34:36.250]     else {
[13:34:36.250]         if (TRUE) {
[13:34:36.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.250]                 open = "w")
[13:34:36.250]         }
[13:34:36.250]         else {
[13:34:36.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.250]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.250]         }
[13:34:36.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.250]             base::sink(type = "output", split = FALSE)
[13:34:36.250]             base::close(...future.stdout)
[13:34:36.250]         }, add = TRUE)
[13:34:36.250]     }
[13:34:36.250]     ...future.frame <- base::sys.nframe()
[13:34:36.250]     ...future.conditions <- base::list()
[13:34:36.250]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.250]     if (FALSE) {
[13:34:36.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.250]     }
[13:34:36.250]     ...future.result <- base::tryCatch({
[13:34:36.250]         base::withCallingHandlers({
[13:34:36.250]             ...future.value <- base::withVisible(base::local({
[13:34:36.250]                 withCallingHandlers({
[13:34:36.250]                   {
[13:34:36.250]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.250]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.250]                       ...future.globals.maxSize)) {
[13:34:36.250]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.250]                       on.exit(options(oopts), add = TRUE)
[13:34:36.250]                     }
[13:34:36.250]                     {
[13:34:36.250]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.250]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.250]                         USE.NAMES = FALSE)
[13:34:36.250]                       do.call(mapply, args = args)
[13:34:36.250]                     }
[13:34:36.250]                   }
[13:34:36.250]                 }, immediateCondition = function(cond) {
[13:34:36.250]                   save_rds <- function (object, pathname, ...) 
[13:34:36.250]                   {
[13:34:36.250]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.250]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.250]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.250]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.250]                         fi_tmp[["mtime"]])
[13:34:36.250]                     }
[13:34:36.250]                     tryCatch({
[13:34:36.250]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.250]                     }, error = function(ex) {
[13:34:36.250]                       msg <- conditionMessage(ex)
[13:34:36.250]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.250]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.250]                         fi_tmp[["mtime"]], msg)
[13:34:36.250]                       ex$message <- msg
[13:34:36.250]                       stop(ex)
[13:34:36.250]                     })
[13:34:36.250]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.250]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.250]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.250]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.250]                       fi <- file.info(pathname)
[13:34:36.250]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.250]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.250]                         fi[["size"]], fi[["mtime"]])
[13:34:36.250]                       stop(msg)
[13:34:36.250]                     }
[13:34:36.250]                     invisible(pathname)
[13:34:36.250]                   }
[13:34:36.250]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.250]                     rootPath = tempdir()) 
[13:34:36.250]                   {
[13:34:36.250]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.250]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.250]                       tmpdir = path, fileext = ".rds")
[13:34:36.250]                     save_rds(obj, file)
[13:34:36.250]                   }
[13:34:36.250]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.250]                   {
[13:34:36.250]                     inherits <- base::inherits
[13:34:36.250]                     invokeRestart <- base::invokeRestart
[13:34:36.250]                     is.null <- base::is.null
[13:34:36.250]                     muffled <- FALSE
[13:34:36.250]                     if (inherits(cond, "message")) {
[13:34:36.250]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.250]                       if (muffled) 
[13:34:36.250]                         invokeRestart("muffleMessage")
[13:34:36.250]                     }
[13:34:36.250]                     else if (inherits(cond, "warning")) {
[13:34:36.250]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.250]                       if (muffled) 
[13:34:36.250]                         invokeRestart("muffleWarning")
[13:34:36.250]                     }
[13:34:36.250]                     else if (inherits(cond, "condition")) {
[13:34:36.250]                       if (!is.null(pattern)) {
[13:34:36.250]                         computeRestarts <- base::computeRestarts
[13:34:36.250]                         grepl <- base::grepl
[13:34:36.250]                         restarts <- computeRestarts(cond)
[13:34:36.250]                         for (restart in restarts) {
[13:34:36.250]                           name <- restart$name
[13:34:36.250]                           if (is.null(name)) 
[13:34:36.250]                             next
[13:34:36.250]                           if (!grepl(pattern, name)) 
[13:34:36.250]                             next
[13:34:36.250]                           invokeRestart(restart)
[13:34:36.250]                           muffled <- TRUE
[13:34:36.250]                           break
[13:34:36.250]                         }
[13:34:36.250]                       }
[13:34:36.250]                     }
[13:34:36.250]                     invisible(muffled)
[13:34:36.250]                   }
[13:34:36.250]                   muffleCondition(cond)
[13:34:36.250]                 })
[13:34:36.250]             }))
[13:34:36.250]             future::FutureResult(value = ...future.value$value, 
[13:34:36.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.250]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.250]                     ...future.globalenv.names))
[13:34:36.250]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.250]         }, condition = base::local({
[13:34:36.250]             c <- base::c
[13:34:36.250]             inherits <- base::inherits
[13:34:36.250]             invokeRestart <- base::invokeRestart
[13:34:36.250]             length <- base::length
[13:34:36.250]             list <- base::list
[13:34:36.250]             seq.int <- base::seq.int
[13:34:36.250]             signalCondition <- base::signalCondition
[13:34:36.250]             sys.calls <- base::sys.calls
[13:34:36.250]             `[[` <- base::`[[`
[13:34:36.250]             `+` <- base::`+`
[13:34:36.250]             `<<-` <- base::`<<-`
[13:34:36.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.250]                   3L)]
[13:34:36.250]             }
[13:34:36.250]             function(cond) {
[13:34:36.250]                 is_error <- inherits(cond, "error")
[13:34:36.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.250]                   NULL)
[13:34:36.250]                 if (is_error) {
[13:34:36.250]                   sessionInformation <- function() {
[13:34:36.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.250]                       search = base::search(), system = base::Sys.info())
[13:34:36.250]                   }
[13:34:36.250]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.250]                     cond$call), session = sessionInformation(), 
[13:34:36.250]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.250]                   signalCondition(cond)
[13:34:36.250]                 }
[13:34:36.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.250]                 "immediateCondition"))) {
[13:34:36.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.250]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.250]                   if (TRUE && !signal) {
[13:34:36.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.250]                     {
[13:34:36.250]                       inherits <- base::inherits
[13:34:36.250]                       invokeRestart <- base::invokeRestart
[13:34:36.250]                       is.null <- base::is.null
[13:34:36.250]                       muffled <- FALSE
[13:34:36.250]                       if (inherits(cond, "message")) {
[13:34:36.250]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.250]                         if (muffled) 
[13:34:36.250]                           invokeRestart("muffleMessage")
[13:34:36.250]                       }
[13:34:36.250]                       else if (inherits(cond, "warning")) {
[13:34:36.250]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.250]                         if (muffled) 
[13:34:36.250]                           invokeRestart("muffleWarning")
[13:34:36.250]                       }
[13:34:36.250]                       else if (inherits(cond, "condition")) {
[13:34:36.250]                         if (!is.null(pattern)) {
[13:34:36.250]                           computeRestarts <- base::computeRestarts
[13:34:36.250]                           grepl <- base::grepl
[13:34:36.250]                           restarts <- computeRestarts(cond)
[13:34:36.250]                           for (restart in restarts) {
[13:34:36.250]                             name <- restart$name
[13:34:36.250]                             if (is.null(name)) 
[13:34:36.250]                               next
[13:34:36.250]                             if (!grepl(pattern, name)) 
[13:34:36.250]                               next
[13:34:36.250]                             invokeRestart(restart)
[13:34:36.250]                             muffled <- TRUE
[13:34:36.250]                             break
[13:34:36.250]                           }
[13:34:36.250]                         }
[13:34:36.250]                       }
[13:34:36.250]                       invisible(muffled)
[13:34:36.250]                     }
[13:34:36.250]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.250]                   }
[13:34:36.250]                 }
[13:34:36.250]                 else {
[13:34:36.250]                   if (TRUE) {
[13:34:36.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.250]                     {
[13:34:36.250]                       inherits <- base::inherits
[13:34:36.250]                       invokeRestart <- base::invokeRestart
[13:34:36.250]                       is.null <- base::is.null
[13:34:36.250]                       muffled <- FALSE
[13:34:36.250]                       if (inherits(cond, "message")) {
[13:34:36.250]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.250]                         if (muffled) 
[13:34:36.250]                           invokeRestart("muffleMessage")
[13:34:36.250]                       }
[13:34:36.250]                       else if (inherits(cond, "warning")) {
[13:34:36.250]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.250]                         if (muffled) 
[13:34:36.250]                           invokeRestart("muffleWarning")
[13:34:36.250]                       }
[13:34:36.250]                       else if (inherits(cond, "condition")) {
[13:34:36.250]                         if (!is.null(pattern)) {
[13:34:36.250]                           computeRestarts <- base::computeRestarts
[13:34:36.250]                           grepl <- base::grepl
[13:34:36.250]                           restarts <- computeRestarts(cond)
[13:34:36.250]                           for (restart in restarts) {
[13:34:36.250]                             name <- restart$name
[13:34:36.250]                             if (is.null(name)) 
[13:34:36.250]                               next
[13:34:36.250]                             if (!grepl(pattern, name)) 
[13:34:36.250]                               next
[13:34:36.250]                             invokeRestart(restart)
[13:34:36.250]                             muffled <- TRUE
[13:34:36.250]                             break
[13:34:36.250]                           }
[13:34:36.250]                         }
[13:34:36.250]                       }
[13:34:36.250]                       invisible(muffled)
[13:34:36.250]                     }
[13:34:36.250]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.250]                   }
[13:34:36.250]                 }
[13:34:36.250]             }
[13:34:36.250]         }))
[13:34:36.250]     }, error = function(ex) {
[13:34:36.250]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.250]                 ...future.rng), started = ...future.startTime, 
[13:34:36.250]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.250]             version = "1.8"), class = "FutureResult")
[13:34:36.250]     }, finally = {
[13:34:36.250]         if (!identical(...future.workdir, getwd())) 
[13:34:36.250]             setwd(...future.workdir)
[13:34:36.250]         {
[13:34:36.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.250]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.250]             }
[13:34:36.250]             base::options(...future.oldOptions)
[13:34:36.250]             if (.Platform$OS.type == "windows") {
[13:34:36.250]                 old_names <- names(...future.oldEnvVars)
[13:34:36.250]                 envs <- base::Sys.getenv()
[13:34:36.250]                 names <- names(envs)
[13:34:36.250]                 common <- intersect(names, old_names)
[13:34:36.250]                 added <- setdiff(names, old_names)
[13:34:36.250]                 removed <- setdiff(old_names, names)
[13:34:36.250]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.250]                   envs[common]]
[13:34:36.250]                 NAMES <- toupper(changed)
[13:34:36.250]                 args <- list()
[13:34:36.250]                 for (kk in seq_along(NAMES)) {
[13:34:36.250]                   name <- changed[[kk]]
[13:34:36.250]                   NAME <- NAMES[[kk]]
[13:34:36.250]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.250]                     next
[13:34:36.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.250]                 }
[13:34:36.250]                 NAMES <- toupper(added)
[13:34:36.250]                 for (kk in seq_along(NAMES)) {
[13:34:36.250]                   name <- added[[kk]]
[13:34:36.250]                   NAME <- NAMES[[kk]]
[13:34:36.250]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.250]                     next
[13:34:36.250]                   args[[name]] <- ""
[13:34:36.250]                 }
[13:34:36.250]                 NAMES <- toupper(removed)
[13:34:36.250]                 for (kk in seq_along(NAMES)) {
[13:34:36.250]                   name <- removed[[kk]]
[13:34:36.250]                   NAME <- NAMES[[kk]]
[13:34:36.250]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.250]                     next
[13:34:36.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.250]                 }
[13:34:36.250]                 if (length(args) > 0) 
[13:34:36.250]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.250]             }
[13:34:36.250]             else {
[13:34:36.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.250]             }
[13:34:36.250]             {
[13:34:36.250]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.250]                   0L) {
[13:34:36.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.250]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.250]                   base::options(opts)
[13:34:36.250]                 }
[13:34:36.250]                 {
[13:34:36.250]                   {
[13:34:36.250]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.250]                     NULL
[13:34:36.250]                   }
[13:34:36.250]                   options(future.plan = NULL)
[13:34:36.250]                   if (is.na(NA_character_)) 
[13:34:36.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.250]                     .init = FALSE)
[13:34:36.250]                 }
[13:34:36.250]             }
[13:34:36.250]         }
[13:34:36.250]     })
[13:34:36.250]     if (TRUE) {
[13:34:36.250]         base::sink(type = "output", split = FALSE)
[13:34:36.250]         if (TRUE) {
[13:34:36.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.250]         }
[13:34:36.250]         else {
[13:34:36.250]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.250]         }
[13:34:36.250]         base::close(...future.stdout)
[13:34:36.250]         ...future.stdout <- NULL
[13:34:36.250]     }
[13:34:36.250]     ...future.result$conditions <- ...future.conditions
[13:34:36.250]     ...future.result$finished <- base::Sys.time()
[13:34:36.250]     ...future.result
[13:34:36.250] }
[13:34:36.253] assign_globals() ...
[13:34:36.254] List of 5
[13:34:36.254]  $ ...future.FUN            :function (C, k)  
[13:34:36.254]  $ MoreArgs                 : NULL
[13:34:36.254]  $ ...future.elements_ii    :List of 2
[13:34:36.254]   ..$ :List of 3
[13:34:36.254]   .. ..$ : chr "C"
[13:34:36.254]   .. ..$ : chr "B"
[13:34:36.254]   .. ..$ : chr "A"
[13:34:36.254]   ..$ :List of 3
[13:34:36.254]   .. ..$ : int 3
[13:34:36.254]   .. ..$ : int 4
[13:34:36.254]   .. ..$ : int 5
[13:34:36.254]  $ ...future.seeds_ii       : NULL
[13:34:36.254]  $ ...future.globals.maxSize: NULL
[13:34:36.254]  - attr(*, "where")=List of 5
[13:34:36.254]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.254]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.254]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.254]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.254]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.254]  - attr(*, "resolved")= logi FALSE
[13:34:36.254]  - attr(*, "total_size")= num 3824
[13:34:36.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.254]  - attr(*, "already-done")= logi TRUE
[13:34:36.264] - reassign environment for ‘...future.FUN’
[13:34:36.264] - copied ‘...future.FUN’ to environment
[13:34:36.264] - copied ‘MoreArgs’ to environment
[13:34:36.264] - copied ‘...future.elements_ii’ to environment
[13:34:36.265] - copied ‘...future.seeds_ii’ to environment
[13:34:36.265] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.265] assign_globals() ... done
[13:34:36.265] requestCore(): workers = 2
[13:34:36.267] MulticoreFuture started
[13:34:36.267] - Launch lazy future ... done
[13:34:36.268] run() for ‘MulticoreFuture’ ... done
[13:34:36.268] Created future:
[13:34:36.268] plan(): Setting new future strategy stack:
[13:34:36.269] List of future strategies:
[13:34:36.269] 1. sequential:
[13:34:36.269]    - args: function (..., envir = parent.frame())
[13:34:36.269]    - tweaked: FALSE
[13:34:36.269]    - call: NULL
[13:34:36.269] plan(): nbrOfWorkers() = 1
[13:34:36.271] plan(): Setting new future strategy stack:
[13:34:36.272] List of future strategies:
[13:34:36.272] 1. multicore:
[13:34:36.272]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.272]    - tweaked: FALSE
[13:34:36.272]    - call: plan(strategy)
[13:34:36.277] plan(): nbrOfWorkers() = 2
[13:34:36.268] MulticoreFuture:
[13:34:36.268] Label: ‘future_mapply-2’
[13:34:36.268] Expression:
[13:34:36.268] {
[13:34:36.268]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.268]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.268]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.268]         on.exit(options(oopts), add = TRUE)
[13:34:36.268]     }
[13:34:36.268]     {
[13:34:36.268]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.268]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.268]         do.call(mapply, args = args)
[13:34:36.268]     }
[13:34:36.268] }
[13:34:36.268] Lazy evaluation: FALSE
[13:34:36.268] Asynchronous evaluation: TRUE
[13:34:36.268] Local evaluation: TRUE
[13:34:36.268] Environment: R_GlobalEnv
[13:34:36.268] Capture standard output: TRUE
[13:34:36.268] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.268] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.268] Packages: <none>
[13:34:36.268] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.268] Resolved: TRUE
[13:34:36.268] Value: <not collected>
[13:34:36.268] Conditions captured: <none>
[13:34:36.268] Early signaling: FALSE
[13:34:36.268] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.268] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.278] Chunk #2 of 2 ... DONE
[13:34:36.278] Launching 2 futures (chunks) ... DONE
[13:34:36.278] Resolving 2 futures (chunks) ...
[13:34:36.278] resolve() on list ...
[13:34:36.279]  recursive: 0
[13:34:36.279]  length: 2
[13:34:36.279] 
[13:34:36.279] Future #1
[13:34:36.279] result() for MulticoreFuture ...
[13:34:36.280] result() for MulticoreFuture ...
[13:34:36.281] result() for MulticoreFuture ... done
[13:34:36.281] result() for MulticoreFuture ... done
[13:34:36.281] result() for MulticoreFuture ...
[13:34:36.281] result() for MulticoreFuture ... done
[13:34:36.281] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:36.282] - nx: 2
[13:34:36.282] - relay: TRUE
[13:34:36.282] - stdout: TRUE
[13:34:36.282] - signal: TRUE
[13:34:36.282] - resignal: FALSE
[13:34:36.283] - force: TRUE
[13:34:36.283] - relayed: [n=2] FALSE, FALSE
[13:34:36.283] - queued futures: [n=2] FALSE, FALSE
[13:34:36.283]  - until=1
[13:34:36.284]  - relaying element #1
[13:34:36.284] result() for MulticoreFuture ...
[13:34:36.284] result() for MulticoreFuture ... done
[13:34:36.284] result() for MulticoreFuture ...
[13:34:36.284] result() for MulticoreFuture ... done
[13:34:36.285] result() for MulticoreFuture ...
[13:34:36.285] result() for MulticoreFuture ... done
[13:34:36.285] result() for MulticoreFuture ...
[13:34:36.285] result() for MulticoreFuture ... done
[13:34:36.285] - relayed: [n=2] TRUE, FALSE
[13:34:36.285] - queued futures: [n=2] TRUE, FALSE
[13:34:36.286] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:36.286]  length: 1 (resolved future 1)
[13:34:36.286] Future #2
[13:34:36.286] result() for MulticoreFuture ...
[13:34:36.287] result() for MulticoreFuture ...
[13:34:36.287] result() for MulticoreFuture ... done
[13:34:36.287] result() for MulticoreFuture ... done
[13:34:36.287] result() for MulticoreFuture ...
[13:34:36.288] result() for MulticoreFuture ... done
[13:34:36.288] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:36.288] - nx: 2
[13:34:36.288] - relay: TRUE
[13:34:36.288] - stdout: TRUE
[13:34:36.288] - signal: TRUE
[13:34:36.291] - resignal: FALSE
[13:34:36.292] - force: TRUE
[13:34:36.292] - relayed: [n=2] TRUE, FALSE
[13:34:36.292] - queued futures: [n=2] TRUE, FALSE
[13:34:36.292]  - until=2
[13:34:36.292]  - relaying element #2
[13:34:36.293] result() for MulticoreFuture ...
[13:34:36.293] result() for MulticoreFuture ... done
[13:34:36.293] result() for MulticoreFuture ...
[13:34:36.293] result() for MulticoreFuture ... done
[13:34:36.293] result() for MulticoreFuture ...
[13:34:36.294] result() for MulticoreFuture ... done
[13:34:36.294] result() for MulticoreFuture ...
[13:34:36.294] result() for MulticoreFuture ... done
[13:34:36.294] - relayed: [n=2] TRUE, TRUE
[13:34:36.294] - queued futures: [n=2] TRUE, TRUE
[13:34:36.294] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:36.295]  length: 0 (resolved future 2)
[13:34:36.295] Relaying remaining futures
[13:34:36.295] signalConditionsASAP(NULL, pos=0) ...
[13:34:36.295] - nx: 2
[13:34:36.295] - relay: TRUE
[13:34:36.295] - stdout: TRUE
[13:34:36.295] - signal: TRUE
[13:34:36.296] - resignal: FALSE
[13:34:36.296] - force: TRUE
[13:34:36.296] - relayed: [n=2] TRUE, TRUE
[13:34:36.296] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:36.296] - relayed: [n=2] TRUE, TRUE
[13:34:36.296] - queued futures: [n=2] TRUE, TRUE
[13:34:36.296] signalConditionsASAP(NULL, pos=0) ... done
[13:34:36.297] resolve() on list ... DONE
[13:34:36.297] result() for MulticoreFuture ...
[13:34:36.297] result() for MulticoreFuture ... done
[13:34:36.297] result() for MulticoreFuture ...
[13:34:36.297] result() for MulticoreFuture ... done
[13:34:36.297] result() for MulticoreFuture ...
[13:34:36.298] result() for MulticoreFuture ... done
[13:34:36.298] result() for MulticoreFuture ...
[13:34:36.298] result() for MulticoreFuture ... done
[13:34:36.298]  - Number of value chunks collected: 2
[13:34:36.298] Resolving 2 futures (chunks) ... DONE
[13:34:36.299] Reducing values from 2 chunks ...
[13:34:36.299]  - Number of values collected after concatenation: 5
[13:34:36.299]  - Number of values expected: 5
[13:34:36.299] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[13:34:36.299] Reducing values from 2 chunks ... DONE
[13:34:36.299] future_mapply() ... DONE
[13:34:36.300] future_mapply() ...
[13:34:36.304] Number of chunks: 2
[13:34:36.304] getGlobalsAndPackagesXApply() ...
[13:34:36.304]  - future.globals: TRUE
[13:34:36.305] getGlobalsAndPackages() ...
[13:34:36.305] Searching for globals...
[13:34:36.306] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:36.307] Searching for globals ... DONE
[13:34:36.307] Resolving globals: FALSE
[13:34:36.307] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:36.307] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:36.308] - globals: [1] ‘FUN’
[13:34:36.308] 
[13:34:36.308] getGlobalsAndPackages() ... DONE
[13:34:36.308]  - globals found/used: [n=1] ‘FUN’
[13:34:36.308]  - needed namespaces: [n=0] 
[13:34:36.308] Finding globals ... DONE
[13:34:36.308] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:36.309] List of 2
[13:34:36.309]  $ ...future.FUN:function (C, k)  
[13:34:36.309]  $ MoreArgs     : list()
[13:34:36.309]  - attr(*, "where")=List of 2
[13:34:36.309]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:36.309]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:36.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.309]  - attr(*, "resolved")= logi FALSE
[13:34:36.309]  - attr(*, "total_size")= num NA
[13:34:36.311] Packages to be attached in all futures: [n=0] 
[13:34:36.311] getGlobalsAndPackagesXApply() ... DONE
[13:34:36.312] Number of futures (= number of chunks): 2
[13:34:36.312] Launching 2 futures (chunks) ...
[13:34:36.312] Chunk #1 of 2 ...
[13:34:36.312]  - Finding globals in '...' for chunk #1 ...
[13:34:36.312] getGlobalsAndPackages() ...
[13:34:36.312] Searching for globals...
[13:34:36.312] 
[13:34:36.313] Searching for globals ... DONE
[13:34:36.313] - globals: [0] <none>
[13:34:36.313] getGlobalsAndPackages() ... DONE
[13:34:36.313]    + additional globals found: [n=0] 
[13:34:36.313]    + additional namespaces needed: [n=0] 
[13:34:36.313]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:36.313]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.313]  - seeds: <none>
[13:34:36.313]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.313] getGlobalsAndPackages() ...
[13:34:36.313] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.314] Resolving globals: FALSE
[13:34:36.314] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:36.315] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:36.315] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.315] 
[13:34:36.315] getGlobalsAndPackages() ... DONE
[13:34:36.315] run() for ‘Future’ ...
[13:34:36.315] - state: ‘created’
[13:34:36.315] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.321] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.322] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.322]   - Field: ‘label’
[13:34:36.322]   - Field: ‘local’
[13:34:36.322]   - Field: ‘owner’
[13:34:36.322]   - Field: ‘envir’
[13:34:36.322]   - Field: ‘workers’
[13:34:36.322]   - Field: ‘packages’
[13:34:36.323]   - Field: ‘gc’
[13:34:36.323]   - Field: ‘job’
[13:34:36.323]   - Field: ‘conditions’
[13:34:36.323]   - Field: ‘expr’
[13:34:36.323]   - Field: ‘uuid’
[13:34:36.323]   - Field: ‘seed’
[13:34:36.323]   - Field: ‘version’
[13:34:36.323]   - Field: ‘result’
[13:34:36.323]   - Field: ‘asynchronous’
[13:34:36.324]   - Field: ‘calls’
[13:34:36.324]   - Field: ‘globals’
[13:34:36.324]   - Field: ‘stdout’
[13:34:36.324]   - Field: ‘earlySignal’
[13:34:36.324]   - Field: ‘lazy’
[13:34:36.324]   - Field: ‘state’
[13:34:36.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.324] - Launch lazy future ...
[13:34:36.325] Packages needed by the future expression (n = 0): <none>
[13:34:36.325] Packages needed by future strategies (n = 0): <none>
[13:34:36.325] {
[13:34:36.325]     {
[13:34:36.325]         {
[13:34:36.325]             ...future.startTime <- base::Sys.time()
[13:34:36.325]             {
[13:34:36.325]                 {
[13:34:36.325]                   {
[13:34:36.325]                     {
[13:34:36.325]                       base::local({
[13:34:36.325]                         has_future <- base::requireNamespace("future", 
[13:34:36.325]                           quietly = TRUE)
[13:34:36.325]                         if (has_future) {
[13:34:36.325]                           ns <- base::getNamespace("future")
[13:34:36.325]                           version <- ns[[".package"]][["version"]]
[13:34:36.325]                           if (is.null(version)) 
[13:34:36.325]                             version <- utils::packageVersion("future")
[13:34:36.325]                         }
[13:34:36.325]                         else {
[13:34:36.325]                           version <- NULL
[13:34:36.325]                         }
[13:34:36.325]                         if (!has_future || version < "1.8.0") {
[13:34:36.325]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.325]                             "", base::R.version$version.string), 
[13:34:36.325]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.325]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.325]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.325]                               "release", "version")], collapse = " "), 
[13:34:36.325]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.325]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.325]                             info)
[13:34:36.325]                           info <- base::paste(info, collapse = "; ")
[13:34:36.325]                           if (!has_future) {
[13:34:36.325]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.325]                               info)
[13:34:36.325]                           }
[13:34:36.325]                           else {
[13:34:36.325]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.325]                               info, version)
[13:34:36.325]                           }
[13:34:36.325]                           base::stop(msg)
[13:34:36.325]                         }
[13:34:36.325]                       })
[13:34:36.325]                     }
[13:34:36.325]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.325]                     base::options(mc.cores = 1L)
[13:34:36.325]                   }
[13:34:36.325]                   ...future.strategy.old <- future::plan("list")
[13:34:36.325]                   options(future.plan = NULL)
[13:34:36.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.325]                 }
[13:34:36.325]                 ...future.workdir <- getwd()
[13:34:36.325]             }
[13:34:36.325]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.325]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.325]         }
[13:34:36.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.325]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.325]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.325]             base::names(...future.oldOptions))
[13:34:36.325]     }
[13:34:36.325]     if (FALSE) {
[13:34:36.325]     }
[13:34:36.325]     else {
[13:34:36.325]         if (TRUE) {
[13:34:36.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.325]                 open = "w")
[13:34:36.325]         }
[13:34:36.325]         else {
[13:34:36.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.325]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.325]         }
[13:34:36.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.325]             base::sink(type = "output", split = FALSE)
[13:34:36.325]             base::close(...future.stdout)
[13:34:36.325]         }, add = TRUE)
[13:34:36.325]     }
[13:34:36.325]     ...future.frame <- base::sys.nframe()
[13:34:36.325]     ...future.conditions <- base::list()
[13:34:36.325]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.325]     if (FALSE) {
[13:34:36.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.325]     }
[13:34:36.325]     ...future.result <- base::tryCatch({
[13:34:36.325]         base::withCallingHandlers({
[13:34:36.325]             ...future.value <- base::withVisible(base::local({
[13:34:36.325]                 withCallingHandlers({
[13:34:36.325]                   {
[13:34:36.325]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.325]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.325]                       ...future.globals.maxSize)) {
[13:34:36.325]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.325]                       on.exit(options(oopts), add = TRUE)
[13:34:36.325]                     }
[13:34:36.325]                     {
[13:34:36.325]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.325]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.325]                         USE.NAMES = FALSE)
[13:34:36.325]                       do.call(mapply, args = args)
[13:34:36.325]                     }
[13:34:36.325]                   }
[13:34:36.325]                 }, immediateCondition = function(cond) {
[13:34:36.325]                   save_rds <- function (object, pathname, ...) 
[13:34:36.325]                   {
[13:34:36.325]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.325]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.325]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.325]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.325]                         fi_tmp[["mtime"]])
[13:34:36.325]                     }
[13:34:36.325]                     tryCatch({
[13:34:36.325]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.325]                     }, error = function(ex) {
[13:34:36.325]                       msg <- conditionMessage(ex)
[13:34:36.325]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.325]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.325]                         fi_tmp[["mtime"]], msg)
[13:34:36.325]                       ex$message <- msg
[13:34:36.325]                       stop(ex)
[13:34:36.325]                     })
[13:34:36.325]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.325]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.325]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.325]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.325]                       fi <- file.info(pathname)
[13:34:36.325]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.325]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.325]                         fi[["size"]], fi[["mtime"]])
[13:34:36.325]                       stop(msg)
[13:34:36.325]                     }
[13:34:36.325]                     invisible(pathname)
[13:34:36.325]                   }
[13:34:36.325]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.325]                     rootPath = tempdir()) 
[13:34:36.325]                   {
[13:34:36.325]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.325]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.325]                       tmpdir = path, fileext = ".rds")
[13:34:36.325]                     save_rds(obj, file)
[13:34:36.325]                   }
[13:34:36.325]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.325]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.325]                   {
[13:34:36.325]                     inherits <- base::inherits
[13:34:36.325]                     invokeRestart <- base::invokeRestart
[13:34:36.325]                     is.null <- base::is.null
[13:34:36.325]                     muffled <- FALSE
[13:34:36.325]                     if (inherits(cond, "message")) {
[13:34:36.325]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.325]                       if (muffled) 
[13:34:36.325]                         invokeRestart("muffleMessage")
[13:34:36.325]                     }
[13:34:36.325]                     else if (inherits(cond, "warning")) {
[13:34:36.325]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.325]                       if (muffled) 
[13:34:36.325]                         invokeRestart("muffleWarning")
[13:34:36.325]                     }
[13:34:36.325]                     else if (inherits(cond, "condition")) {
[13:34:36.325]                       if (!is.null(pattern)) {
[13:34:36.325]                         computeRestarts <- base::computeRestarts
[13:34:36.325]                         grepl <- base::grepl
[13:34:36.325]                         restarts <- computeRestarts(cond)
[13:34:36.325]                         for (restart in restarts) {
[13:34:36.325]                           name <- restart$name
[13:34:36.325]                           if (is.null(name)) 
[13:34:36.325]                             next
[13:34:36.325]                           if (!grepl(pattern, name)) 
[13:34:36.325]                             next
[13:34:36.325]                           invokeRestart(restart)
[13:34:36.325]                           muffled <- TRUE
[13:34:36.325]                           break
[13:34:36.325]                         }
[13:34:36.325]                       }
[13:34:36.325]                     }
[13:34:36.325]                     invisible(muffled)
[13:34:36.325]                   }
[13:34:36.325]                   muffleCondition(cond)
[13:34:36.325]                 })
[13:34:36.325]             }))
[13:34:36.325]             future::FutureResult(value = ...future.value$value, 
[13:34:36.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.325]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.325]                     ...future.globalenv.names))
[13:34:36.325]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.325]         }, condition = base::local({
[13:34:36.325]             c <- base::c
[13:34:36.325]             inherits <- base::inherits
[13:34:36.325]             invokeRestart <- base::invokeRestart
[13:34:36.325]             length <- base::length
[13:34:36.325]             list <- base::list
[13:34:36.325]             seq.int <- base::seq.int
[13:34:36.325]             signalCondition <- base::signalCondition
[13:34:36.325]             sys.calls <- base::sys.calls
[13:34:36.325]             `[[` <- base::`[[`
[13:34:36.325]             `+` <- base::`+`
[13:34:36.325]             `<<-` <- base::`<<-`
[13:34:36.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.325]                   3L)]
[13:34:36.325]             }
[13:34:36.325]             function(cond) {
[13:34:36.325]                 is_error <- inherits(cond, "error")
[13:34:36.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.325]                   NULL)
[13:34:36.325]                 if (is_error) {
[13:34:36.325]                   sessionInformation <- function() {
[13:34:36.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.325]                       search = base::search(), system = base::Sys.info())
[13:34:36.325]                   }
[13:34:36.325]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.325]                     cond$call), session = sessionInformation(), 
[13:34:36.325]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.325]                   signalCondition(cond)
[13:34:36.325]                 }
[13:34:36.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.325]                 "immediateCondition"))) {
[13:34:36.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.325]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.325]                   if (TRUE && !signal) {
[13:34:36.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.325]                     {
[13:34:36.325]                       inherits <- base::inherits
[13:34:36.325]                       invokeRestart <- base::invokeRestart
[13:34:36.325]                       is.null <- base::is.null
[13:34:36.325]                       muffled <- FALSE
[13:34:36.325]                       if (inherits(cond, "message")) {
[13:34:36.325]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.325]                         if (muffled) 
[13:34:36.325]                           invokeRestart("muffleMessage")
[13:34:36.325]                       }
[13:34:36.325]                       else if (inherits(cond, "warning")) {
[13:34:36.325]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.325]                         if (muffled) 
[13:34:36.325]                           invokeRestart("muffleWarning")
[13:34:36.325]                       }
[13:34:36.325]                       else if (inherits(cond, "condition")) {
[13:34:36.325]                         if (!is.null(pattern)) {
[13:34:36.325]                           computeRestarts <- base::computeRestarts
[13:34:36.325]                           grepl <- base::grepl
[13:34:36.325]                           restarts <- computeRestarts(cond)
[13:34:36.325]                           for (restart in restarts) {
[13:34:36.325]                             name <- restart$name
[13:34:36.325]                             if (is.null(name)) 
[13:34:36.325]                               next
[13:34:36.325]                             if (!grepl(pattern, name)) 
[13:34:36.325]                               next
[13:34:36.325]                             invokeRestart(restart)
[13:34:36.325]                             muffled <- TRUE
[13:34:36.325]                             break
[13:34:36.325]                           }
[13:34:36.325]                         }
[13:34:36.325]                       }
[13:34:36.325]                       invisible(muffled)
[13:34:36.325]                     }
[13:34:36.325]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.325]                   }
[13:34:36.325]                 }
[13:34:36.325]                 else {
[13:34:36.325]                   if (TRUE) {
[13:34:36.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.325]                     {
[13:34:36.325]                       inherits <- base::inherits
[13:34:36.325]                       invokeRestart <- base::invokeRestart
[13:34:36.325]                       is.null <- base::is.null
[13:34:36.325]                       muffled <- FALSE
[13:34:36.325]                       if (inherits(cond, "message")) {
[13:34:36.325]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.325]                         if (muffled) 
[13:34:36.325]                           invokeRestart("muffleMessage")
[13:34:36.325]                       }
[13:34:36.325]                       else if (inherits(cond, "warning")) {
[13:34:36.325]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.325]                         if (muffled) 
[13:34:36.325]                           invokeRestart("muffleWarning")
[13:34:36.325]                       }
[13:34:36.325]                       else if (inherits(cond, "condition")) {
[13:34:36.325]                         if (!is.null(pattern)) {
[13:34:36.325]                           computeRestarts <- base::computeRestarts
[13:34:36.325]                           grepl <- base::grepl
[13:34:36.325]                           restarts <- computeRestarts(cond)
[13:34:36.325]                           for (restart in restarts) {
[13:34:36.325]                             name <- restart$name
[13:34:36.325]                             if (is.null(name)) 
[13:34:36.325]                               next
[13:34:36.325]                             if (!grepl(pattern, name)) 
[13:34:36.325]                               next
[13:34:36.325]                             invokeRestart(restart)
[13:34:36.325]                             muffled <- TRUE
[13:34:36.325]                             break
[13:34:36.325]                           }
[13:34:36.325]                         }
[13:34:36.325]                       }
[13:34:36.325]                       invisible(muffled)
[13:34:36.325]                     }
[13:34:36.325]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.325]                   }
[13:34:36.325]                 }
[13:34:36.325]             }
[13:34:36.325]         }))
[13:34:36.325]     }, error = function(ex) {
[13:34:36.325]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.325]                 ...future.rng), started = ...future.startTime, 
[13:34:36.325]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.325]             version = "1.8"), class = "FutureResult")
[13:34:36.325]     }, finally = {
[13:34:36.325]         if (!identical(...future.workdir, getwd())) 
[13:34:36.325]             setwd(...future.workdir)
[13:34:36.325]         {
[13:34:36.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.325]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.325]             }
[13:34:36.325]             base::options(...future.oldOptions)
[13:34:36.325]             if (.Platform$OS.type == "windows") {
[13:34:36.325]                 old_names <- names(...future.oldEnvVars)
[13:34:36.325]                 envs <- base::Sys.getenv()
[13:34:36.325]                 names <- names(envs)
[13:34:36.325]                 common <- intersect(names, old_names)
[13:34:36.325]                 added <- setdiff(names, old_names)
[13:34:36.325]                 removed <- setdiff(old_names, names)
[13:34:36.325]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.325]                   envs[common]]
[13:34:36.325]                 NAMES <- toupper(changed)
[13:34:36.325]                 args <- list()
[13:34:36.325]                 for (kk in seq_along(NAMES)) {
[13:34:36.325]                   name <- changed[[kk]]
[13:34:36.325]                   NAME <- NAMES[[kk]]
[13:34:36.325]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.325]                     next
[13:34:36.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.325]                 }
[13:34:36.325]                 NAMES <- toupper(added)
[13:34:36.325]                 for (kk in seq_along(NAMES)) {
[13:34:36.325]                   name <- added[[kk]]
[13:34:36.325]                   NAME <- NAMES[[kk]]
[13:34:36.325]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.325]                     next
[13:34:36.325]                   args[[name]] <- ""
[13:34:36.325]                 }
[13:34:36.325]                 NAMES <- toupper(removed)
[13:34:36.325]                 for (kk in seq_along(NAMES)) {
[13:34:36.325]                   name <- removed[[kk]]
[13:34:36.325]                   NAME <- NAMES[[kk]]
[13:34:36.325]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.325]                     next
[13:34:36.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.325]                 }
[13:34:36.325]                 if (length(args) > 0) 
[13:34:36.325]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.325]             }
[13:34:36.325]             else {
[13:34:36.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.325]             }
[13:34:36.325]             {
[13:34:36.325]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.325]                   0L) {
[13:34:36.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.325]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.325]                   base::options(opts)
[13:34:36.325]                 }
[13:34:36.325]                 {
[13:34:36.325]                   {
[13:34:36.325]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.325]                     NULL
[13:34:36.325]                   }
[13:34:36.325]                   options(future.plan = NULL)
[13:34:36.325]                   if (is.na(NA_character_)) 
[13:34:36.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.325]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.325]                     .init = FALSE)
[13:34:36.325]                 }
[13:34:36.325]             }
[13:34:36.325]         }
[13:34:36.325]     })
[13:34:36.325]     if (TRUE) {
[13:34:36.325]         base::sink(type = "output", split = FALSE)
[13:34:36.325]         if (TRUE) {
[13:34:36.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.325]         }
[13:34:36.325]         else {
[13:34:36.325]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.325]         }
[13:34:36.325]         base::close(...future.stdout)
[13:34:36.325]         ...future.stdout <- NULL
[13:34:36.325]     }
[13:34:36.325]     ...future.result$conditions <- ...future.conditions
[13:34:36.325]     ...future.result$finished <- base::Sys.time()
[13:34:36.325]     ...future.result
[13:34:36.325] }
[13:34:36.328] assign_globals() ...
[13:34:36.328] List of 5
[13:34:36.328]  $ ...future.FUN            :function (C, k)  
[13:34:36.328]  $ MoreArgs                 : list()
[13:34:36.328]  $ ...future.elements_ii    :List of 2
[13:34:36.328]   ..$ :List of 2
[13:34:36.328]   .. ..$ : chr "A"
[13:34:36.328]   .. ..$ : chr "B"
[13:34:36.328]   ..$ :List of 2
[13:34:36.328]   .. ..$ : int 5
[13:34:36.328]   .. ..$ : int 4
[13:34:36.328]  $ ...future.seeds_ii       : NULL
[13:34:36.328]  $ ...future.globals.maxSize: NULL
[13:34:36.328]  - attr(*, "where")=List of 5
[13:34:36.328]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.328]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.328]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.328]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.328]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.328]  - attr(*, "resolved")= logi FALSE
[13:34:36.328]  - attr(*, "total_size")= num 3656
[13:34:36.328]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.328]  - attr(*, "already-done")= logi TRUE
[13:34:36.333] - reassign environment for ‘...future.FUN’
[13:34:36.333] - copied ‘...future.FUN’ to environment
[13:34:36.334] - copied ‘MoreArgs’ to environment
[13:34:36.334] - copied ‘...future.elements_ii’ to environment
[13:34:36.334] - copied ‘...future.seeds_ii’ to environment
[13:34:36.334] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.334] assign_globals() ... done
[13:34:36.334] requestCore(): workers = 2
[13:34:36.336] MulticoreFuture started
[13:34:36.337] - Launch lazy future ... done
[13:34:36.337] run() for ‘MulticoreFuture’ ... done
[13:34:36.337] Created future:
[13:34:36.337] plan(): Setting new future strategy stack:
[13:34:36.338] List of future strategies:
[13:34:36.338] 1. sequential:
[13:34:36.338]    - args: function (..., envir = parent.frame())
[13:34:36.338]    - tweaked: FALSE
[13:34:36.338]    - call: NULL
[13:34:36.338] plan(): nbrOfWorkers() = 1
[13:34:36.341] plan(): Setting new future strategy stack:
[13:34:36.341] List of future strategies:
[13:34:36.341] 1. multicore:
[13:34:36.341]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.341]    - tweaked: FALSE
[13:34:36.341]    - call: plan(strategy)
[13:34:36.346] plan(): nbrOfWorkers() = 2
[13:34:36.337] MulticoreFuture:
[13:34:36.337] Label: ‘future_.mapply-1’
[13:34:36.337] Expression:
[13:34:36.337] {
[13:34:36.337]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.337]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.337]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.337]         on.exit(options(oopts), add = TRUE)
[13:34:36.337]     }
[13:34:36.337]     {
[13:34:36.337]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.337]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.337]         do.call(mapply, args = args)
[13:34:36.337]     }
[13:34:36.337] }
[13:34:36.337] Lazy evaluation: FALSE
[13:34:36.337] Asynchronous evaluation: TRUE
[13:34:36.337] Local evaluation: TRUE
[13:34:36.337] Environment: R_GlobalEnv
[13:34:36.337] Capture standard output: TRUE
[13:34:36.337] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.337] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.337] Packages: <none>
[13:34:36.337] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.337] Resolved: TRUE
[13:34:36.337] Value: <not collected>
[13:34:36.337] Conditions captured: <none>
[13:34:36.337] Early signaling: FALSE
[13:34:36.337] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.337] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.347] Chunk #1 of 2 ... DONE
[13:34:36.347] Chunk #2 of 2 ...
[13:34:36.348]  - Finding globals in '...' for chunk #2 ...
[13:34:36.348] getGlobalsAndPackages() ...
[13:34:36.348] Searching for globals...
[13:34:36.348] 
[13:34:36.349] Searching for globals ... DONE
[13:34:36.349] - globals: [0] <none>
[13:34:36.349] getGlobalsAndPackages() ... DONE
[13:34:36.349]    + additional globals found: [n=0] 
[13:34:36.349]    + additional namespaces needed: [n=0] 
[13:34:36.349]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:36.349]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.350]  - seeds: <none>
[13:34:36.350]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.350] getGlobalsAndPackages() ...
[13:34:36.350] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.350] Resolving globals: FALSE
[13:34:36.351] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[13:34:36.352] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:36.352] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.352] 
[13:34:36.353] getGlobalsAndPackages() ... DONE
[13:34:36.353] run() for ‘Future’ ...
[13:34:36.353] - state: ‘created’
[13:34:36.354] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.366] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.366] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.366]   - Field: ‘label’
[13:34:36.367]   - Field: ‘local’
[13:34:36.367]   - Field: ‘owner’
[13:34:36.367]   - Field: ‘envir’
[13:34:36.367]   - Field: ‘workers’
[13:34:36.367]   - Field: ‘packages’
[13:34:36.367]   - Field: ‘gc’
[13:34:36.367]   - Field: ‘job’
[13:34:36.367]   - Field: ‘conditions’
[13:34:36.368]   - Field: ‘expr’
[13:34:36.368]   - Field: ‘uuid’
[13:34:36.368]   - Field: ‘seed’
[13:34:36.368]   - Field: ‘version’
[13:34:36.369]   - Field: ‘result’
[13:34:36.369]   - Field: ‘asynchronous’
[13:34:36.369]   - Field: ‘calls’
[13:34:36.369]   - Field: ‘globals’
[13:34:36.369]   - Field: ‘stdout’
[13:34:36.370]   - Field: ‘earlySignal’
[13:34:36.370]   - Field: ‘lazy’
[13:34:36.370]   - Field: ‘state’
[13:34:36.370] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.370] - Launch lazy future ...
[13:34:36.371] Packages needed by the future expression (n = 0): <none>
[13:34:36.371] Packages needed by future strategies (n = 0): <none>
[13:34:36.372] {
[13:34:36.372]     {
[13:34:36.372]         {
[13:34:36.372]             ...future.startTime <- base::Sys.time()
[13:34:36.372]             {
[13:34:36.372]                 {
[13:34:36.372]                   {
[13:34:36.372]                     {
[13:34:36.372]                       base::local({
[13:34:36.372]                         has_future <- base::requireNamespace("future", 
[13:34:36.372]                           quietly = TRUE)
[13:34:36.372]                         if (has_future) {
[13:34:36.372]                           ns <- base::getNamespace("future")
[13:34:36.372]                           version <- ns[[".package"]][["version"]]
[13:34:36.372]                           if (is.null(version)) 
[13:34:36.372]                             version <- utils::packageVersion("future")
[13:34:36.372]                         }
[13:34:36.372]                         else {
[13:34:36.372]                           version <- NULL
[13:34:36.372]                         }
[13:34:36.372]                         if (!has_future || version < "1.8.0") {
[13:34:36.372]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.372]                             "", base::R.version$version.string), 
[13:34:36.372]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.372]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.372]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.372]                               "release", "version")], collapse = " "), 
[13:34:36.372]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.372]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.372]                             info)
[13:34:36.372]                           info <- base::paste(info, collapse = "; ")
[13:34:36.372]                           if (!has_future) {
[13:34:36.372]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.372]                               info)
[13:34:36.372]                           }
[13:34:36.372]                           else {
[13:34:36.372]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.372]                               info, version)
[13:34:36.372]                           }
[13:34:36.372]                           base::stop(msg)
[13:34:36.372]                         }
[13:34:36.372]                       })
[13:34:36.372]                     }
[13:34:36.372]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.372]                     base::options(mc.cores = 1L)
[13:34:36.372]                   }
[13:34:36.372]                   ...future.strategy.old <- future::plan("list")
[13:34:36.372]                   options(future.plan = NULL)
[13:34:36.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.372]                 }
[13:34:36.372]                 ...future.workdir <- getwd()
[13:34:36.372]             }
[13:34:36.372]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.372]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.372]         }
[13:34:36.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.372]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.372]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.372]             base::names(...future.oldOptions))
[13:34:36.372]     }
[13:34:36.372]     if (FALSE) {
[13:34:36.372]     }
[13:34:36.372]     else {
[13:34:36.372]         if (TRUE) {
[13:34:36.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.372]                 open = "w")
[13:34:36.372]         }
[13:34:36.372]         else {
[13:34:36.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.372]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.372]         }
[13:34:36.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.372]             base::sink(type = "output", split = FALSE)
[13:34:36.372]             base::close(...future.stdout)
[13:34:36.372]         }, add = TRUE)
[13:34:36.372]     }
[13:34:36.372]     ...future.frame <- base::sys.nframe()
[13:34:36.372]     ...future.conditions <- base::list()
[13:34:36.372]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.372]     if (FALSE) {
[13:34:36.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.372]     }
[13:34:36.372]     ...future.result <- base::tryCatch({
[13:34:36.372]         base::withCallingHandlers({
[13:34:36.372]             ...future.value <- base::withVisible(base::local({
[13:34:36.372]                 withCallingHandlers({
[13:34:36.372]                   {
[13:34:36.372]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.372]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.372]                       ...future.globals.maxSize)) {
[13:34:36.372]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.372]                       on.exit(options(oopts), add = TRUE)
[13:34:36.372]                     }
[13:34:36.372]                     {
[13:34:36.372]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.372]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.372]                         USE.NAMES = FALSE)
[13:34:36.372]                       do.call(mapply, args = args)
[13:34:36.372]                     }
[13:34:36.372]                   }
[13:34:36.372]                 }, immediateCondition = function(cond) {
[13:34:36.372]                   save_rds <- function (object, pathname, ...) 
[13:34:36.372]                   {
[13:34:36.372]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.372]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.372]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.372]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.372]                         fi_tmp[["mtime"]])
[13:34:36.372]                     }
[13:34:36.372]                     tryCatch({
[13:34:36.372]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.372]                     }, error = function(ex) {
[13:34:36.372]                       msg <- conditionMessage(ex)
[13:34:36.372]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.372]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.372]                         fi_tmp[["mtime"]], msg)
[13:34:36.372]                       ex$message <- msg
[13:34:36.372]                       stop(ex)
[13:34:36.372]                     })
[13:34:36.372]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.372]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.372]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.372]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.372]                       fi <- file.info(pathname)
[13:34:36.372]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.372]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.372]                         fi[["size"]], fi[["mtime"]])
[13:34:36.372]                       stop(msg)
[13:34:36.372]                     }
[13:34:36.372]                     invisible(pathname)
[13:34:36.372]                   }
[13:34:36.372]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.372]                     rootPath = tempdir()) 
[13:34:36.372]                   {
[13:34:36.372]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.372]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.372]                       tmpdir = path, fileext = ".rds")
[13:34:36.372]                     save_rds(obj, file)
[13:34:36.372]                   }
[13:34:36.372]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.372]                   {
[13:34:36.372]                     inherits <- base::inherits
[13:34:36.372]                     invokeRestart <- base::invokeRestart
[13:34:36.372]                     is.null <- base::is.null
[13:34:36.372]                     muffled <- FALSE
[13:34:36.372]                     if (inherits(cond, "message")) {
[13:34:36.372]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.372]                       if (muffled) 
[13:34:36.372]                         invokeRestart("muffleMessage")
[13:34:36.372]                     }
[13:34:36.372]                     else if (inherits(cond, "warning")) {
[13:34:36.372]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.372]                       if (muffled) 
[13:34:36.372]                         invokeRestart("muffleWarning")
[13:34:36.372]                     }
[13:34:36.372]                     else if (inherits(cond, "condition")) {
[13:34:36.372]                       if (!is.null(pattern)) {
[13:34:36.372]                         computeRestarts <- base::computeRestarts
[13:34:36.372]                         grepl <- base::grepl
[13:34:36.372]                         restarts <- computeRestarts(cond)
[13:34:36.372]                         for (restart in restarts) {
[13:34:36.372]                           name <- restart$name
[13:34:36.372]                           if (is.null(name)) 
[13:34:36.372]                             next
[13:34:36.372]                           if (!grepl(pattern, name)) 
[13:34:36.372]                             next
[13:34:36.372]                           invokeRestart(restart)
[13:34:36.372]                           muffled <- TRUE
[13:34:36.372]                           break
[13:34:36.372]                         }
[13:34:36.372]                       }
[13:34:36.372]                     }
[13:34:36.372]                     invisible(muffled)
[13:34:36.372]                   }
[13:34:36.372]                   muffleCondition(cond)
[13:34:36.372]                 })
[13:34:36.372]             }))
[13:34:36.372]             future::FutureResult(value = ...future.value$value, 
[13:34:36.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.372]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.372]                     ...future.globalenv.names))
[13:34:36.372]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.372]         }, condition = base::local({
[13:34:36.372]             c <- base::c
[13:34:36.372]             inherits <- base::inherits
[13:34:36.372]             invokeRestart <- base::invokeRestart
[13:34:36.372]             length <- base::length
[13:34:36.372]             list <- base::list
[13:34:36.372]             seq.int <- base::seq.int
[13:34:36.372]             signalCondition <- base::signalCondition
[13:34:36.372]             sys.calls <- base::sys.calls
[13:34:36.372]             `[[` <- base::`[[`
[13:34:36.372]             `+` <- base::`+`
[13:34:36.372]             `<<-` <- base::`<<-`
[13:34:36.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.372]                   3L)]
[13:34:36.372]             }
[13:34:36.372]             function(cond) {
[13:34:36.372]                 is_error <- inherits(cond, "error")
[13:34:36.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.372]                   NULL)
[13:34:36.372]                 if (is_error) {
[13:34:36.372]                   sessionInformation <- function() {
[13:34:36.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.372]                       search = base::search(), system = base::Sys.info())
[13:34:36.372]                   }
[13:34:36.372]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.372]                     cond$call), session = sessionInformation(), 
[13:34:36.372]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.372]                   signalCondition(cond)
[13:34:36.372]                 }
[13:34:36.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.372]                 "immediateCondition"))) {
[13:34:36.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.372]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.372]                   if (TRUE && !signal) {
[13:34:36.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.372]                     {
[13:34:36.372]                       inherits <- base::inherits
[13:34:36.372]                       invokeRestart <- base::invokeRestart
[13:34:36.372]                       is.null <- base::is.null
[13:34:36.372]                       muffled <- FALSE
[13:34:36.372]                       if (inherits(cond, "message")) {
[13:34:36.372]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.372]                         if (muffled) 
[13:34:36.372]                           invokeRestart("muffleMessage")
[13:34:36.372]                       }
[13:34:36.372]                       else if (inherits(cond, "warning")) {
[13:34:36.372]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.372]                         if (muffled) 
[13:34:36.372]                           invokeRestart("muffleWarning")
[13:34:36.372]                       }
[13:34:36.372]                       else if (inherits(cond, "condition")) {
[13:34:36.372]                         if (!is.null(pattern)) {
[13:34:36.372]                           computeRestarts <- base::computeRestarts
[13:34:36.372]                           grepl <- base::grepl
[13:34:36.372]                           restarts <- computeRestarts(cond)
[13:34:36.372]                           for (restart in restarts) {
[13:34:36.372]                             name <- restart$name
[13:34:36.372]                             if (is.null(name)) 
[13:34:36.372]                               next
[13:34:36.372]                             if (!grepl(pattern, name)) 
[13:34:36.372]                               next
[13:34:36.372]                             invokeRestart(restart)
[13:34:36.372]                             muffled <- TRUE
[13:34:36.372]                             break
[13:34:36.372]                           }
[13:34:36.372]                         }
[13:34:36.372]                       }
[13:34:36.372]                       invisible(muffled)
[13:34:36.372]                     }
[13:34:36.372]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.372]                   }
[13:34:36.372]                 }
[13:34:36.372]                 else {
[13:34:36.372]                   if (TRUE) {
[13:34:36.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.372]                     {
[13:34:36.372]                       inherits <- base::inherits
[13:34:36.372]                       invokeRestart <- base::invokeRestart
[13:34:36.372]                       is.null <- base::is.null
[13:34:36.372]                       muffled <- FALSE
[13:34:36.372]                       if (inherits(cond, "message")) {
[13:34:36.372]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.372]                         if (muffled) 
[13:34:36.372]                           invokeRestart("muffleMessage")
[13:34:36.372]                       }
[13:34:36.372]                       else if (inherits(cond, "warning")) {
[13:34:36.372]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.372]                         if (muffled) 
[13:34:36.372]                           invokeRestart("muffleWarning")
[13:34:36.372]                       }
[13:34:36.372]                       else if (inherits(cond, "condition")) {
[13:34:36.372]                         if (!is.null(pattern)) {
[13:34:36.372]                           computeRestarts <- base::computeRestarts
[13:34:36.372]                           grepl <- base::grepl
[13:34:36.372]                           restarts <- computeRestarts(cond)
[13:34:36.372]                           for (restart in restarts) {
[13:34:36.372]                             name <- restart$name
[13:34:36.372]                             if (is.null(name)) 
[13:34:36.372]                               next
[13:34:36.372]                             if (!grepl(pattern, name)) 
[13:34:36.372]                               next
[13:34:36.372]                             invokeRestart(restart)
[13:34:36.372]                             muffled <- TRUE
[13:34:36.372]                             break
[13:34:36.372]                           }
[13:34:36.372]                         }
[13:34:36.372]                       }
[13:34:36.372]                       invisible(muffled)
[13:34:36.372]                     }
[13:34:36.372]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.372]                   }
[13:34:36.372]                 }
[13:34:36.372]             }
[13:34:36.372]         }))
[13:34:36.372]     }, error = function(ex) {
[13:34:36.372]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.372]                 ...future.rng), started = ...future.startTime, 
[13:34:36.372]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.372]             version = "1.8"), class = "FutureResult")
[13:34:36.372]     }, finally = {
[13:34:36.372]         if (!identical(...future.workdir, getwd())) 
[13:34:36.372]             setwd(...future.workdir)
[13:34:36.372]         {
[13:34:36.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.372]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.372]             }
[13:34:36.372]             base::options(...future.oldOptions)
[13:34:36.372]             if (.Platform$OS.type == "windows") {
[13:34:36.372]                 old_names <- names(...future.oldEnvVars)
[13:34:36.372]                 envs <- base::Sys.getenv()
[13:34:36.372]                 names <- names(envs)
[13:34:36.372]                 common <- intersect(names, old_names)
[13:34:36.372]                 added <- setdiff(names, old_names)
[13:34:36.372]                 removed <- setdiff(old_names, names)
[13:34:36.372]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.372]                   envs[common]]
[13:34:36.372]                 NAMES <- toupper(changed)
[13:34:36.372]                 args <- list()
[13:34:36.372]                 for (kk in seq_along(NAMES)) {
[13:34:36.372]                   name <- changed[[kk]]
[13:34:36.372]                   NAME <- NAMES[[kk]]
[13:34:36.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.372]                     next
[13:34:36.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.372]                 }
[13:34:36.372]                 NAMES <- toupper(added)
[13:34:36.372]                 for (kk in seq_along(NAMES)) {
[13:34:36.372]                   name <- added[[kk]]
[13:34:36.372]                   NAME <- NAMES[[kk]]
[13:34:36.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.372]                     next
[13:34:36.372]                   args[[name]] <- ""
[13:34:36.372]                 }
[13:34:36.372]                 NAMES <- toupper(removed)
[13:34:36.372]                 for (kk in seq_along(NAMES)) {
[13:34:36.372]                   name <- removed[[kk]]
[13:34:36.372]                   NAME <- NAMES[[kk]]
[13:34:36.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.372]                     next
[13:34:36.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.372]                 }
[13:34:36.372]                 if (length(args) > 0) 
[13:34:36.372]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.372]             }
[13:34:36.372]             else {
[13:34:36.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.372]             }
[13:34:36.372]             {
[13:34:36.372]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.372]                   0L) {
[13:34:36.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.372]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.372]                   base::options(opts)
[13:34:36.372]                 }
[13:34:36.372]                 {
[13:34:36.372]                   {
[13:34:36.372]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.372]                     NULL
[13:34:36.372]                   }
[13:34:36.372]                   options(future.plan = NULL)
[13:34:36.372]                   if (is.na(NA_character_)) 
[13:34:36.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.372]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.372]                     .init = FALSE)
[13:34:36.372]                 }
[13:34:36.372]             }
[13:34:36.372]         }
[13:34:36.372]     })
[13:34:36.372]     if (TRUE) {
[13:34:36.372]         base::sink(type = "output", split = FALSE)
[13:34:36.372]         if (TRUE) {
[13:34:36.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.372]         }
[13:34:36.372]         else {
[13:34:36.372]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.372]         }
[13:34:36.372]         base::close(...future.stdout)
[13:34:36.372]         ...future.stdout <- NULL
[13:34:36.372]     }
[13:34:36.372]     ...future.result$conditions <- ...future.conditions
[13:34:36.372]     ...future.result$finished <- base::Sys.time()
[13:34:36.372]     ...future.result
[13:34:36.372] }
[13:34:36.375] assign_globals() ...
[13:34:36.375] List of 5
[13:34:36.375]  $ ...future.FUN            :function (C, k)  
[13:34:36.375]  $ MoreArgs                 : list()
[13:34:36.375]  $ ...future.elements_ii    :List of 2
[13:34:36.375]   ..$ :List of 3
[13:34:36.375]   .. ..$ : chr "C"
[13:34:36.375]   .. ..$ : chr "D"
[13:34:36.375]   .. ..$ : chr "E"
[13:34:36.375]   ..$ :List of 3
[13:34:36.375]   .. ..$ : int 3
[13:34:36.375]   .. ..$ : int 2
[13:34:36.375]   .. ..$ : int 1
[13:34:36.375]  $ ...future.seeds_ii       : NULL
[13:34:36.375]  $ ...future.globals.maxSize: NULL
[13:34:36.375]  - attr(*, "where")=List of 5
[13:34:36.375]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.375]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.375]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.375]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.375]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.375]  - attr(*, "resolved")= logi FALSE
[13:34:36.375]  - attr(*, "total_size")= num 3824
[13:34:36.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.375]  - attr(*, "already-done")= logi TRUE
[13:34:36.385] - reassign environment for ‘...future.FUN’
[13:34:36.385] - copied ‘...future.FUN’ to environment
[13:34:36.385] - copied ‘MoreArgs’ to environment
[13:34:36.385] - copied ‘...future.elements_ii’ to environment
[13:34:36.385] - copied ‘...future.seeds_ii’ to environment
[13:34:36.385] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.385] assign_globals() ... done
[13:34:36.386] requestCore(): workers = 2
[13:34:36.388] MulticoreFuture started
[13:34:36.388] - Launch lazy future ... done
[13:34:36.388] run() for ‘MulticoreFuture’ ... done
[13:34:36.389] Created future:
[13:34:36.389] plan(): Setting new future strategy stack:
[13:34:36.389] List of future strategies:
[13:34:36.389] 1. sequential:
[13:34:36.389]    - args: function (..., envir = parent.frame())
[13:34:36.389]    - tweaked: FALSE
[13:34:36.389]    - call: NULL
[13:34:36.390] plan(): nbrOfWorkers() = 1
[13:34:36.392] plan(): Setting new future strategy stack:
[13:34:36.392] List of future strategies:
[13:34:36.392] 1. multicore:
[13:34:36.392]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.392]    - tweaked: FALSE
[13:34:36.392]    - call: plan(strategy)
[13:34:36.398] plan(): nbrOfWorkers() = 2
[13:34:36.389] MulticoreFuture:
[13:34:36.389] Label: ‘future_.mapply-2’
[13:34:36.389] Expression:
[13:34:36.389] {
[13:34:36.389]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.389]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.389]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.389]         on.exit(options(oopts), add = TRUE)
[13:34:36.389]     }
[13:34:36.389]     {
[13:34:36.389]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.389]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.389]         do.call(mapply, args = args)
[13:34:36.389]     }
[13:34:36.389] }
[13:34:36.389] Lazy evaluation: FALSE
[13:34:36.389] Asynchronous evaluation: TRUE
[13:34:36.389] Local evaluation: TRUE
[13:34:36.389] Environment: R_GlobalEnv
[13:34:36.389] Capture standard output: TRUE
[13:34:36.389] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.389] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.389] Packages: <none>
[13:34:36.389] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.389] Resolved: TRUE
[13:34:36.389] Value: <not collected>
[13:34:36.389] Conditions captured: <none>
[13:34:36.389] Early signaling: FALSE
[13:34:36.389] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.389] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.399] Chunk #2 of 2 ... DONE
[13:34:36.399] Launching 2 futures (chunks) ... DONE
[13:34:36.399] Resolving 2 futures (chunks) ...
[13:34:36.399] resolve() on list ...
[13:34:36.399]  recursive: 0
[13:34:36.400]  length: 2
[13:34:36.400] 
[13:34:36.400] Future #1
[13:34:36.400] result() for MulticoreFuture ...
[13:34:36.401] result() for MulticoreFuture ...
[13:34:36.401] result() for MulticoreFuture ... done
[13:34:36.401] result() for MulticoreFuture ... done
[13:34:36.402] result() for MulticoreFuture ...
[13:34:36.402] result() for MulticoreFuture ... done
[13:34:36.402] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:36.402] - nx: 2
[13:34:36.402] - relay: TRUE
[13:34:36.402] - stdout: TRUE
[13:34:36.403] - signal: TRUE
[13:34:36.403] - resignal: FALSE
[13:34:36.403] - force: TRUE
[13:34:36.403] - relayed: [n=2] FALSE, FALSE
[13:34:36.403] - queued futures: [n=2] FALSE, FALSE
[13:34:36.403]  - until=1
[13:34:36.403]  - relaying element #1
[13:34:36.404] result() for MulticoreFuture ...
[13:34:36.404] result() for MulticoreFuture ... done
[13:34:36.404] result() for MulticoreFuture ...
[13:34:36.404] result() for MulticoreFuture ... done
[13:34:36.404] result() for MulticoreFuture ...
[13:34:36.405] result() for MulticoreFuture ... done
[13:34:36.405] result() for MulticoreFuture ...
[13:34:36.405] result() for MulticoreFuture ... done
[13:34:36.405] - relayed: [n=2] TRUE, FALSE
[13:34:36.405] - queued futures: [n=2] TRUE, FALSE
[13:34:36.405] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:36.406]  length: 1 (resolved future 1)
[13:34:36.406] Future #2
[13:34:36.406] result() for MulticoreFuture ...
[13:34:36.407] result() for MulticoreFuture ...
[13:34:36.407] result() for MulticoreFuture ... done
[13:34:36.407] result() for MulticoreFuture ... done
[13:34:36.407] result() for MulticoreFuture ...
[13:34:36.407] result() for MulticoreFuture ... done
[13:34:36.408] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:36.411] - nx: 2
[13:34:36.411] - relay: TRUE
[13:34:36.411] - stdout: TRUE
[13:34:36.412] - signal: TRUE
[13:34:36.412] - resignal: FALSE
[13:34:36.412] - force: TRUE
[13:34:36.412] - relayed: [n=2] TRUE, FALSE
[13:34:36.412] - queued futures: [n=2] TRUE, FALSE
[13:34:36.412]  - until=2
[13:34:36.413]  - relaying element #2
[13:34:36.413] result() for MulticoreFuture ...
[13:34:36.413] result() for MulticoreFuture ... done
[13:34:36.413] result() for MulticoreFuture ...
[13:34:36.413] result() for MulticoreFuture ... done
[13:34:36.413] result() for MulticoreFuture ...
[13:34:36.414] result() for MulticoreFuture ... done
[13:34:36.414] result() for MulticoreFuture ...
[13:34:36.414] result() for MulticoreFuture ... done
[13:34:36.414] - relayed: [n=2] TRUE, TRUE
[13:34:36.414] - queued futures: [n=2] TRUE, TRUE
[13:34:36.414] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:36.415]  length: 0 (resolved future 2)
[13:34:36.415] Relaying remaining futures
[13:34:36.415] signalConditionsASAP(NULL, pos=0) ...
[13:34:36.415] - nx: 2
[13:34:36.415] - relay: TRUE
[13:34:36.415] - stdout: TRUE
[13:34:36.415] - signal: TRUE
[13:34:36.415] - resignal: FALSE
[13:34:36.416] - force: TRUE
[13:34:36.416] - relayed: [n=2] TRUE, TRUE
[13:34:36.416] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:36.416] - relayed: [n=2] TRUE, TRUE
[13:34:36.416] - queued futures: [n=2] TRUE, TRUE
[13:34:36.416] signalConditionsASAP(NULL, pos=0) ... done
[13:34:36.416] resolve() on list ... DONE
[13:34:36.417] result() for MulticoreFuture ...
[13:34:36.417] result() for MulticoreFuture ... done
[13:34:36.417] result() for MulticoreFuture ...
[13:34:36.417] result() for MulticoreFuture ... done
[13:34:36.417] result() for MulticoreFuture ...
[13:34:36.417] result() for MulticoreFuture ... done
[13:34:36.418] result() for MulticoreFuture ...
[13:34:36.418] result() for MulticoreFuture ... done
[13:34:36.418]  - Number of value chunks collected: 2
[13:34:36.418] Resolving 2 futures (chunks) ... DONE
[13:34:36.418] Reducing values from 2 chunks ...
[13:34:36.418]  - Number of values collected after concatenation: 5
[13:34:36.418]  - Number of values expected: 5
[13:34:36.419] Reducing values from 2 chunks ... DONE
[13:34:36.419] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[13:34:36.419] future_mapply() ...
[13:34:36.423] Number of chunks: 1
[13:34:36.423] getGlobalsAndPackagesXApply() ...
[13:34:36.423]  - future.globals: TRUE
[13:34:36.424] getGlobalsAndPackages() ...
[13:34:36.424] Searching for globals...
[13:34:36.425] - globals found: [1] ‘FUN’
[13:34:36.425] Searching for globals ... DONE
[13:34:36.425] Resolving globals: FALSE
[13:34:36.426] The total size of the 1 globals is 848 bytes (848 bytes)
[13:34:36.426] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:34:36.426] - globals: [1] ‘FUN’
[13:34:36.426] 
[13:34:36.426] getGlobalsAndPackages() ... DONE
[13:34:36.427]  - globals found/used: [n=1] ‘FUN’
[13:34:36.427]  - needed namespaces: [n=0] 
[13:34:36.427] Finding globals ... DONE
[13:34:36.427] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:36.427] List of 2
[13:34:36.427]  $ ...future.FUN:function (x)  
[13:34:36.427]  $ MoreArgs     : NULL
[13:34:36.427]  - attr(*, "where")=List of 2
[13:34:36.427]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:36.427]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:36.427]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.427]  - attr(*, "resolved")= logi FALSE
[13:34:36.427]  - attr(*, "total_size")= num NA
[13:34:36.430] Packages to be attached in all futures: [n=0] 
[13:34:36.430] getGlobalsAndPackagesXApply() ... DONE
[13:34:36.430] Number of futures (= number of chunks): 1
[13:34:36.430] Launching 1 futures (chunks) ...
[13:34:36.431] Chunk #1 of 1 ...
[13:34:36.431]  - Finding globals in '...' for chunk #1 ...
[13:34:36.431] getGlobalsAndPackages() ...
[13:34:36.431] Searching for globals...
[13:34:36.431] 
[13:34:36.431] Searching for globals ... DONE
[13:34:36.431] - globals: [0] <none>
[13:34:36.431] getGlobalsAndPackages() ... DONE
[13:34:36.431]    + additional globals found: [n=0] 
[13:34:36.432]    + additional namespaces needed: [n=0] 
[13:34:36.432]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:36.432]  - seeds: <none>
[13:34:36.432]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.432] getGlobalsAndPackages() ...
[13:34:36.432] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.432] Resolving globals: FALSE
[13:34:36.433] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[13:34:36.433] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:36.433] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.433] 
[13:34:36.433] getGlobalsAndPackages() ... DONE
[13:34:36.434] run() for ‘Future’ ...
[13:34:36.434] - state: ‘created’
[13:34:36.434] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.437] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.438] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.438]   - Field: ‘label’
[13:34:36.438]   - Field: ‘local’
[13:34:36.438]   - Field: ‘owner’
[13:34:36.438]   - Field: ‘envir’
[13:34:36.438]   - Field: ‘workers’
[13:34:36.438]   - Field: ‘packages’
[13:34:36.438]   - Field: ‘gc’
[13:34:36.438]   - Field: ‘job’
[13:34:36.438]   - Field: ‘conditions’
[13:34:36.439]   - Field: ‘expr’
[13:34:36.439]   - Field: ‘uuid’
[13:34:36.441]   - Field: ‘seed’
[13:34:36.441]   - Field: ‘version’
[13:34:36.441]   - Field: ‘result’
[13:34:36.441]   - Field: ‘asynchronous’
[13:34:36.441]   - Field: ‘calls’
[13:34:36.441]   - Field: ‘globals’
[13:34:36.442]   - Field: ‘stdout’
[13:34:36.442]   - Field: ‘earlySignal’
[13:34:36.442]   - Field: ‘lazy’
[13:34:36.442]   - Field: ‘state’
[13:34:36.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.442] - Launch lazy future ...
[13:34:36.442] Packages needed by the future expression (n = 0): <none>
[13:34:36.442] Packages needed by future strategies (n = 0): <none>
[13:34:36.443] {
[13:34:36.443]     {
[13:34:36.443]         {
[13:34:36.443]             ...future.startTime <- base::Sys.time()
[13:34:36.443]             {
[13:34:36.443]                 {
[13:34:36.443]                   {
[13:34:36.443]                     {
[13:34:36.443]                       base::local({
[13:34:36.443]                         has_future <- base::requireNamespace("future", 
[13:34:36.443]                           quietly = TRUE)
[13:34:36.443]                         if (has_future) {
[13:34:36.443]                           ns <- base::getNamespace("future")
[13:34:36.443]                           version <- ns[[".package"]][["version"]]
[13:34:36.443]                           if (is.null(version)) 
[13:34:36.443]                             version <- utils::packageVersion("future")
[13:34:36.443]                         }
[13:34:36.443]                         else {
[13:34:36.443]                           version <- NULL
[13:34:36.443]                         }
[13:34:36.443]                         if (!has_future || version < "1.8.0") {
[13:34:36.443]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.443]                             "", base::R.version$version.string), 
[13:34:36.443]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.443]                               "release", "version")], collapse = " "), 
[13:34:36.443]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.443]                             info)
[13:34:36.443]                           info <- base::paste(info, collapse = "; ")
[13:34:36.443]                           if (!has_future) {
[13:34:36.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.443]                               info)
[13:34:36.443]                           }
[13:34:36.443]                           else {
[13:34:36.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.443]                               info, version)
[13:34:36.443]                           }
[13:34:36.443]                           base::stop(msg)
[13:34:36.443]                         }
[13:34:36.443]                       })
[13:34:36.443]                     }
[13:34:36.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.443]                     base::options(mc.cores = 1L)
[13:34:36.443]                   }
[13:34:36.443]                   ...future.strategy.old <- future::plan("list")
[13:34:36.443]                   options(future.plan = NULL)
[13:34:36.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.443]                 }
[13:34:36.443]                 ...future.workdir <- getwd()
[13:34:36.443]             }
[13:34:36.443]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.443]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.443]         }
[13:34:36.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:36.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.443]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.443]             base::names(...future.oldOptions))
[13:34:36.443]     }
[13:34:36.443]     if (FALSE) {
[13:34:36.443]     }
[13:34:36.443]     else {
[13:34:36.443]         if (TRUE) {
[13:34:36.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.443]                 open = "w")
[13:34:36.443]         }
[13:34:36.443]         else {
[13:34:36.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.443]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.443]         }
[13:34:36.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.443]             base::sink(type = "output", split = FALSE)
[13:34:36.443]             base::close(...future.stdout)
[13:34:36.443]         }, add = TRUE)
[13:34:36.443]     }
[13:34:36.443]     ...future.frame <- base::sys.nframe()
[13:34:36.443]     ...future.conditions <- base::list()
[13:34:36.443]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.443]     if (FALSE) {
[13:34:36.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.443]     }
[13:34:36.443]     ...future.result <- base::tryCatch({
[13:34:36.443]         base::withCallingHandlers({
[13:34:36.443]             ...future.value <- base::withVisible(base::local({
[13:34:36.443]                 withCallingHandlers({
[13:34:36.443]                   {
[13:34:36.443]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.443]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.443]                       ...future.globals.maxSize)) {
[13:34:36.443]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.443]                       on.exit(options(oopts), add = TRUE)
[13:34:36.443]                     }
[13:34:36.443]                     {
[13:34:36.443]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.443]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.443]                         USE.NAMES = FALSE)
[13:34:36.443]                       do.call(mapply, args = args)
[13:34:36.443]                     }
[13:34:36.443]                   }
[13:34:36.443]                 }, immediateCondition = function(cond) {
[13:34:36.443]                   save_rds <- function (object, pathname, ...) 
[13:34:36.443]                   {
[13:34:36.443]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.443]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.443]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.443]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.443]                         fi_tmp[["mtime"]])
[13:34:36.443]                     }
[13:34:36.443]                     tryCatch({
[13:34:36.443]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.443]                     }, error = function(ex) {
[13:34:36.443]                       msg <- conditionMessage(ex)
[13:34:36.443]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.443]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.443]                         fi_tmp[["mtime"]], msg)
[13:34:36.443]                       ex$message <- msg
[13:34:36.443]                       stop(ex)
[13:34:36.443]                     })
[13:34:36.443]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.443]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.443]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.443]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.443]                       fi <- file.info(pathname)
[13:34:36.443]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.443]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.443]                         fi[["size"]], fi[["mtime"]])
[13:34:36.443]                       stop(msg)
[13:34:36.443]                     }
[13:34:36.443]                     invisible(pathname)
[13:34:36.443]                   }
[13:34:36.443]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.443]                     rootPath = tempdir()) 
[13:34:36.443]                   {
[13:34:36.443]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.443]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.443]                       tmpdir = path, fileext = ".rds")
[13:34:36.443]                     save_rds(obj, file)
[13:34:36.443]                   }
[13:34:36.443]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.443]                   {
[13:34:36.443]                     inherits <- base::inherits
[13:34:36.443]                     invokeRestart <- base::invokeRestart
[13:34:36.443]                     is.null <- base::is.null
[13:34:36.443]                     muffled <- FALSE
[13:34:36.443]                     if (inherits(cond, "message")) {
[13:34:36.443]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.443]                       if (muffled) 
[13:34:36.443]                         invokeRestart("muffleMessage")
[13:34:36.443]                     }
[13:34:36.443]                     else if (inherits(cond, "warning")) {
[13:34:36.443]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.443]                       if (muffled) 
[13:34:36.443]                         invokeRestart("muffleWarning")
[13:34:36.443]                     }
[13:34:36.443]                     else if (inherits(cond, "condition")) {
[13:34:36.443]                       if (!is.null(pattern)) {
[13:34:36.443]                         computeRestarts <- base::computeRestarts
[13:34:36.443]                         grepl <- base::grepl
[13:34:36.443]                         restarts <- computeRestarts(cond)
[13:34:36.443]                         for (restart in restarts) {
[13:34:36.443]                           name <- restart$name
[13:34:36.443]                           if (is.null(name)) 
[13:34:36.443]                             next
[13:34:36.443]                           if (!grepl(pattern, name)) 
[13:34:36.443]                             next
[13:34:36.443]                           invokeRestart(restart)
[13:34:36.443]                           muffled <- TRUE
[13:34:36.443]                           break
[13:34:36.443]                         }
[13:34:36.443]                       }
[13:34:36.443]                     }
[13:34:36.443]                     invisible(muffled)
[13:34:36.443]                   }
[13:34:36.443]                   muffleCondition(cond)
[13:34:36.443]                 })
[13:34:36.443]             }))
[13:34:36.443]             future::FutureResult(value = ...future.value$value, 
[13:34:36.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.443]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.443]                     ...future.globalenv.names))
[13:34:36.443]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.443]         }, condition = base::local({
[13:34:36.443]             c <- base::c
[13:34:36.443]             inherits <- base::inherits
[13:34:36.443]             invokeRestart <- base::invokeRestart
[13:34:36.443]             length <- base::length
[13:34:36.443]             list <- base::list
[13:34:36.443]             seq.int <- base::seq.int
[13:34:36.443]             signalCondition <- base::signalCondition
[13:34:36.443]             sys.calls <- base::sys.calls
[13:34:36.443]             `[[` <- base::`[[`
[13:34:36.443]             `+` <- base::`+`
[13:34:36.443]             `<<-` <- base::`<<-`
[13:34:36.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.443]                   3L)]
[13:34:36.443]             }
[13:34:36.443]             function(cond) {
[13:34:36.443]                 is_error <- inherits(cond, "error")
[13:34:36.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.443]                   NULL)
[13:34:36.443]                 if (is_error) {
[13:34:36.443]                   sessionInformation <- function() {
[13:34:36.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.443]                       search = base::search(), system = base::Sys.info())
[13:34:36.443]                   }
[13:34:36.443]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.443]                     cond$call), session = sessionInformation(), 
[13:34:36.443]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.443]                   signalCondition(cond)
[13:34:36.443]                 }
[13:34:36.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.443]                 "immediateCondition"))) {
[13:34:36.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.443]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.443]                   if (TRUE && !signal) {
[13:34:36.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.443]                     {
[13:34:36.443]                       inherits <- base::inherits
[13:34:36.443]                       invokeRestart <- base::invokeRestart
[13:34:36.443]                       is.null <- base::is.null
[13:34:36.443]                       muffled <- FALSE
[13:34:36.443]                       if (inherits(cond, "message")) {
[13:34:36.443]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.443]                         if (muffled) 
[13:34:36.443]                           invokeRestart("muffleMessage")
[13:34:36.443]                       }
[13:34:36.443]                       else if (inherits(cond, "warning")) {
[13:34:36.443]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.443]                         if (muffled) 
[13:34:36.443]                           invokeRestart("muffleWarning")
[13:34:36.443]                       }
[13:34:36.443]                       else if (inherits(cond, "condition")) {
[13:34:36.443]                         if (!is.null(pattern)) {
[13:34:36.443]                           computeRestarts <- base::computeRestarts
[13:34:36.443]                           grepl <- base::grepl
[13:34:36.443]                           restarts <- computeRestarts(cond)
[13:34:36.443]                           for (restart in restarts) {
[13:34:36.443]                             name <- restart$name
[13:34:36.443]                             if (is.null(name)) 
[13:34:36.443]                               next
[13:34:36.443]                             if (!grepl(pattern, name)) 
[13:34:36.443]                               next
[13:34:36.443]                             invokeRestart(restart)
[13:34:36.443]                             muffled <- TRUE
[13:34:36.443]                             break
[13:34:36.443]                           }
[13:34:36.443]                         }
[13:34:36.443]                       }
[13:34:36.443]                       invisible(muffled)
[13:34:36.443]                     }
[13:34:36.443]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.443]                   }
[13:34:36.443]                 }
[13:34:36.443]                 else {
[13:34:36.443]                   if (TRUE) {
[13:34:36.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.443]                     {
[13:34:36.443]                       inherits <- base::inherits
[13:34:36.443]                       invokeRestart <- base::invokeRestart
[13:34:36.443]                       is.null <- base::is.null
[13:34:36.443]                       muffled <- FALSE
[13:34:36.443]                       if (inherits(cond, "message")) {
[13:34:36.443]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.443]                         if (muffled) 
[13:34:36.443]                           invokeRestart("muffleMessage")
[13:34:36.443]                       }
[13:34:36.443]                       else if (inherits(cond, "warning")) {
[13:34:36.443]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.443]                         if (muffled) 
[13:34:36.443]                           invokeRestart("muffleWarning")
[13:34:36.443]                       }
[13:34:36.443]                       else if (inherits(cond, "condition")) {
[13:34:36.443]                         if (!is.null(pattern)) {
[13:34:36.443]                           computeRestarts <- base::computeRestarts
[13:34:36.443]                           grepl <- base::grepl
[13:34:36.443]                           restarts <- computeRestarts(cond)
[13:34:36.443]                           for (restart in restarts) {
[13:34:36.443]                             name <- restart$name
[13:34:36.443]                             if (is.null(name)) 
[13:34:36.443]                               next
[13:34:36.443]                             if (!grepl(pattern, name)) 
[13:34:36.443]                               next
[13:34:36.443]                             invokeRestart(restart)
[13:34:36.443]                             muffled <- TRUE
[13:34:36.443]                             break
[13:34:36.443]                           }
[13:34:36.443]                         }
[13:34:36.443]                       }
[13:34:36.443]                       invisible(muffled)
[13:34:36.443]                     }
[13:34:36.443]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.443]                   }
[13:34:36.443]                 }
[13:34:36.443]             }
[13:34:36.443]         }))
[13:34:36.443]     }, error = function(ex) {
[13:34:36.443]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.443]                 ...future.rng), started = ...future.startTime, 
[13:34:36.443]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.443]             version = "1.8"), class = "FutureResult")
[13:34:36.443]     }, finally = {
[13:34:36.443]         if (!identical(...future.workdir, getwd())) 
[13:34:36.443]             setwd(...future.workdir)
[13:34:36.443]         {
[13:34:36.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.443]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.443]             }
[13:34:36.443]             base::options(...future.oldOptions)
[13:34:36.443]             if (.Platform$OS.type == "windows") {
[13:34:36.443]                 old_names <- names(...future.oldEnvVars)
[13:34:36.443]                 envs <- base::Sys.getenv()
[13:34:36.443]                 names <- names(envs)
[13:34:36.443]                 common <- intersect(names, old_names)
[13:34:36.443]                 added <- setdiff(names, old_names)
[13:34:36.443]                 removed <- setdiff(old_names, names)
[13:34:36.443]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.443]                   envs[common]]
[13:34:36.443]                 NAMES <- toupper(changed)
[13:34:36.443]                 args <- list()
[13:34:36.443]                 for (kk in seq_along(NAMES)) {
[13:34:36.443]                   name <- changed[[kk]]
[13:34:36.443]                   NAME <- NAMES[[kk]]
[13:34:36.443]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.443]                     next
[13:34:36.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.443]                 }
[13:34:36.443]                 NAMES <- toupper(added)
[13:34:36.443]                 for (kk in seq_along(NAMES)) {
[13:34:36.443]                   name <- added[[kk]]
[13:34:36.443]                   NAME <- NAMES[[kk]]
[13:34:36.443]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.443]                     next
[13:34:36.443]                   args[[name]] <- ""
[13:34:36.443]                 }
[13:34:36.443]                 NAMES <- toupper(removed)
[13:34:36.443]                 for (kk in seq_along(NAMES)) {
[13:34:36.443]                   name <- removed[[kk]]
[13:34:36.443]                   NAME <- NAMES[[kk]]
[13:34:36.443]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.443]                     next
[13:34:36.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.443]                 }
[13:34:36.443]                 if (length(args) > 0) 
[13:34:36.443]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.443]             }
[13:34:36.443]             else {
[13:34:36.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.443]             }
[13:34:36.443]             {
[13:34:36.443]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.443]                   0L) {
[13:34:36.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.443]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.443]                   base::options(opts)
[13:34:36.443]                 }
[13:34:36.443]                 {
[13:34:36.443]                   {
[13:34:36.443]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.443]                     NULL
[13:34:36.443]                   }
[13:34:36.443]                   options(future.plan = NULL)
[13:34:36.443]                   if (is.na(NA_character_)) 
[13:34:36.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.443]                     .init = FALSE)
[13:34:36.443]                 }
[13:34:36.443]             }
[13:34:36.443]         }
[13:34:36.443]     })
[13:34:36.443]     if (TRUE) {
[13:34:36.443]         base::sink(type = "output", split = FALSE)
[13:34:36.443]         if (TRUE) {
[13:34:36.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.443]         }
[13:34:36.443]         else {
[13:34:36.443]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.443]         }
[13:34:36.443]         base::close(...future.stdout)
[13:34:36.443]         ...future.stdout <- NULL
[13:34:36.443]     }
[13:34:36.443]     ...future.result$conditions <- ...future.conditions
[13:34:36.443]     ...future.result$finished <- base::Sys.time()
[13:34:36.443]     ...future.result
[13:34:36.443] }
[13:34:36.445] assign_globals() ...
[13:34:36.445] List of 5
[13:34:36.445]  $ ...future.FUN            :function (x)  
[13:34:36.445]  $ MoreArgs                 : NULL
[13:34:36.445]  $ ...future.elements_ii    :List of 1
[13:34:36.445]   ..$ :List of 1
[13:34:36.445]   .. ..$ : Date[1:1], format: "2018-06-01"
[13:34:36.445]  $ ...future.seeds_ii       : NULL
[13:34:36.445]  $ ...future.globals.maxSize: NULL
[13:34:36.445]  - attr(*, "where")=List of 5
[13:34:36.445]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.445]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.445]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.445]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.445]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.445]  - attr(*, "resolved")= logi FALSE
[13:34:36.445]  - attr(*, "total_size")= num 1128
[13:34:36.445]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.445]  - attr(*, "already-done")= logi TRUE
[13:34:36.450] - copied ‘...future.FUN’ to environment
[13:34:36.450] - copied ‘MoreArgs’ to environment
[13:34:36.451] - copied ‘...future.elements_ii’ to environment
[13:34:36.451] - copied ‘...future.seeds_ii’ to environment
[13:34:36.451] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.451] assign_globals() ... done
[13:34:36.451] requestCore(): workers = 2
[13:34:36.453] MulticoreFuture started
[13:34:36.453] - Launch lazy future ... done
[13:34:36.454] run() for ‘MulticoreFuture’ ... done
[13:34:36.454] Created future:
[13:34:36.454] plan(): Setting new future strategy stack:
[13:34:36.454] List of future strategies:
[13:34:36.454] 1. sequential:
[13:34:36.454]    - args: function (..., envir = parent.frame())
[13:34:36.454]    - tweaked: FALSE
[13:34:36.454]    - call: NULL
[13:34:36.455] plan(): nbrOfWorkers() = 1
[13:34:36.458] plan(): Setting new future strategy stack:
[13:34:36.458] List of future strategies:
[13:34:36.458] 1. multicore:
[13:34:36.458]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.458]    - tweaked: FALSE
[13:34:36.458]    - call: plan(strategy)
[13:34:36.464] plan(): nbrOfWorkers() = 2
[13:34:36.454] MulticoreFuture:
[13:34:36.454] Label: ‘future_mapply-1’
[13:34:36.454] Expression:
[13:34:36.454] {
[13:34:36.454]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.454]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.454]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.454]         on.exit(options(oopts), add = TRUE)
[13:34:36.454]     }
[13:34:36.454]     {
[13:34:36.454]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.454]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.454]         do.call(mapply, args = args)
[13:34:36.454]     }
[13:34:36.454] }
[13:34:36.454] Lazy evaluation: FALSE
[13:34:36.454] Asynchronous evaluation: TRUE
[13:34:36.454] Local evaluation: TRUE
[13:34:36.454] Environment: R_GlobalEnv
[13:34:36.454] Capture standard output: TRUE
[13:34:36.454] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.454] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.454] Packages: <none>
[13:34:36.454] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.454] Resolved: TRUE
[13:34:36.454] Value: <not collected>
[13:34:36.454] Conditions captured: <none>
[13:34:36.454] Early signaling: FALSE
[13:34:36.454] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.454] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.465] Chunk #1 of 1 ... DONE
[13:34:36.465] Launching 1 futures (chunks) ... DONE
[13:34:36.465] Resolving 1 futures (chunks) ...
[13:34:36.465] resolve() on list ...
[13:34:36.465]  recursive: 0
[13:34:36.466]  length: 1
[13:34:36.466] 
[13:34:36.466] Future #1
[13:34:36.466] result() for MulticoreFuture ...
[13:34:36.467] result() for MulticoreFuture ...
[13:34:36.467] result() for MulticoreFuture ... done
[13:34:36.467] result() for MulticoreFuture ... done
[13:34:36.468] result() for MulticoreFuture ...
[13:34:36.468] result() for MulticoreFuture ... done
[13:34:36.468] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:36.468] - nx: 1
[13:34:36.468] - relay: TRUE
[13:34:36.468] - stdout: TRUE
[13:34:36.468] - signal: TRUE
[13:34:36.469] - resignal: FALSE
[13:34:36.469] - force: TRUE
[13:34:36.469] - relayed: [n=1] FALSE
[13:34:36.469] - queued futures: [n=1] FALSE
[13:34:36.469]  - until=1
[13:34:36.469]  - relaying element #1
[13:34:36.469] result() for MulticoreFuture ...
[13:34:36.469] result() for MulticoreFuture ... done
[13:34:36.469] result() for MulticoreFuture ...
[13:34:36.470] result() for MulticoreFuture ... done
[13:34:36.470] result() for MulticoreFuture ...
[13:34:36.470] result() for MulticoreFuture ... done
[13:34:36.470] result() for MulticoreFuture ...
[13:34:36.470] result() for MulticoreFuture ... done
[13:34:36.470] - relayed: [n=1] TRUE
[13:34:36.470] - queued futures: [n=1] TRUE
[13:34:36.470] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:36.471]  length: 0 (resolved future 1)
[13:34:36.471] Relaying remaining futures
[13:34:36.471] signalConditionsASAP(NULL, pos=0) ...
[13:34:36.471] - nx: 1
[13:34:36.471] - relay: TRUE
[13:34:36.471] - stdout: TRUE
[13:34:36.471] - signal: TRUE
[13:34:36.471] - resignal: FALSE
[13:34:36.471] - force: TRUE
[13:34:36.472] - relayed: [n=1] TRUE
[13:34:36.472] - queued futures: [n=1] TRUE
 - flush all
[13:34:36.472] - relayed: [n=1] TRUE
[13:34:36.472] - queued futures: [n=1] TRUE
[13:34:36.472] signalConditionsASAP(NULL, pos=0) ... done
[13:34:36.472] resolve() on list ... DONE
[13:34:36.472] result() for MulticoreFuture ...
[13:34:36.472] result() for MulticoreFuture ... done
[13:34:36.473] result() for MulticoreFuture ...
[13:34:36.473] result() for MulticoreFuture ... done
[13:34:36.473]  - Number of value chunks collected: 1
[13:34:36.473] Resolving 1 futures (chunks) ... DONE
[13:34:36.473] Reducing values from 1 chunks ...
[13:34:36.473]  - Number of values collected after concatenation: 1
[13:34:36.473]  - Number of values expected: 1
[13:34:36.473] Reducing values from 1 chunks ... DONE
[13:34:36.474] future_mapply() ... DONE
[13:34:36.474] future_mapply() ...
[13:34:36.478] Number of chunks: 1
[13:34:36.478] getGlobalsAndPackagesXApply() ...
[13:34:36.478]  - future.globals: TRUE
[13:34:36.478] getGlobalsAndPackages() ...
[13:34:36.478] Searching for globals...
[13:34:36.482] - globals found: [1] ‘FUN’
[13:34:36.482] Searching for globals ... DONE
[13:34:36.483] Resolving globals: FALSE
[13:34:36.483] The total size of the 1 globals is 848 bytes (848 bytes)
[13:34:36.483] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:34:36.484] - globals: [1] ‘FUN’
[13:34:36.484] 
[13:34:36.484] getGlobalsAndPackages() ... DONE
[13:34:36.484]  - globals found/used: [n=1] ‘FUN’
[13:34:36.484]  - needed namespaces: [n=0] 
[13:34:36.484] Finding globals ... DONE
[13:34:36.485] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:36.485] List of 2
[13:34:36.485]  $ ...future.FUN:function (x)  
[13:34:36.485]  $ MoreArgs     : list()
[13:34:36.485]  - attr(*, "where")=List of 2
[13:34:36.485]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:36.485]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:36.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.485]  - attr(*, "resolved")= logi FALSE
[13:34:36.485]  - attr(*, "total_size")= num NA
[13:34:36.488] Packages to be attached in all futures: [n=0] 
[13:34:36.488] getGlobalsAndPackagesXApply() ... DONE
[13:34:36.489] Number of futures (= number of chunks): 1
[13:34:36.489] Launching 1 futures (chunks) ...
[13:34:36.489] Chunk #1 of 1 ...
[13:34:36.489]  - Finding globals in '...' for chunk #1 ...
[13:34:36.489] getGlobalsAndPackages() ...
[13:34:36.489] Searching for globals...
[13:34:36.490] 
[13:34:36.490] Searching for globals ... DONE
[13:34:36.490] - globals: [0] <none>
[13:34:36.490] getGlobalsAndPackages() ... DONE
[13:34:36.490]    + additional globals found: [n=0] 
[13:34:36.490]    + additional namespaces needed: [n=0] 
[13:34:36.491]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:36.491]  - seeds: <none>
[13:34:36.491]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.491] getGlobalsAndPackages() ...
[13:34:36.491] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.491] Resolving globals: FALSE
[13:34:36.492] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[13:34:36.492] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:36.492] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.492] 
[13:34:36.492] getGlobalsAndPackages() ... DONE
[13:34:36.493] run() for ‘Future’ ...
[13:34:36.493] - state: ‘created’
[13:34:36.493] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.497] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.497] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.497]   - Field: ‘label’
[13:34:36.497]   - Field: ‘local’
[13:34:36.497]   - Field: ‘owner’
[13:34:36.497]   - Field: ‘envir’
[13:34:36.497]   - Field: ‘workers’
[13:34:36.498]   - Field: ‘packages’
[13:34:36.498]   - Field: ‘gc’
[13:34:36.498]   - Field: ‘job’
[13:34:36.498]   - Field: ‘conditions’
[13:34:36.498]   - Field: ‘expr’
[13:34:36.498]   - Field: ‘uuid’
[13:34:36.498]   - Field: ‘seed’
[13:34:36.498]   - Field: ‘version’
[13:34:36.498]   - Field: ‘result’
[13:34:36.498]   - Field: ‘asynchronous’
[13:34:36.498]   - Field: ‘calls’
[13:34:36.499]   - Field: ‘globals’
[13:34:36.499]   - Field: ‘stdout’
[13:34:36.499]   - Field: ‘earlySignal’
[13:34:36.499]   - Field: ‘lazy’
[13:34:36.499]   - Field: ‘state’
[13:34:36.499] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.499] - Launch lazy future ...
[13:34:36.499] Packages needed by the future expression (n = 0): <none>
[13:34:36.499] Packages needed by future strategies (n = 0): <none>
[13:34:36.500] {
[13:34:36.500]     {
[13:34:36.500]         {
[13:34:36.500]             ...future.startTime <- base::Sys.time()
[13:34:36.500]             {
[13:34:36.500]                 {
[13:34:36.500]                   {
[13:34:36.500]                     {
[13:34:36.500]                       base::local({
[13:34:36.500]                         has_future <- base::requireNamespace("future", 
[13:34:36.500]                           quietly = TRUE)
[13:34:36.500]                         if (has_future) {
[13:34:36.500]                           ns <- base::getNamespace("future")
[13:34:36.500]                           version <- ns[[".package"]][["version"]]
[13:34:36.500]                           if (is.null(version)) 
[13:34:36.500]                             version <- utils::packageVersion("future")
[13:34:36.500]                         }
[13:34:36.500]                         else {
[13:34:36.500]                           version <- NULL
[13:34:36.500]                         }
[13:34:36.500]                         if (!has_future || version < "1.8.0") {
[13:34:36.500]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.500]                             "", base::R.version$version.string), 
[13:34:36.500]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.500]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.500]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.500]                               "release", "version")], collapse = " "), 
[13:34:36.500]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.500]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.500]                             info)
[13:34:36.500]                           info <- base::paste(info, collapse = "; ")
[13:34:36.500]                           if (!has_future) {
[13:34:36.500]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.500]                               info)
[13:34:36.500]                           }
[13:34:36.500]                           else {
[13:34:36.500]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.500]                               info, version)
[13:34:36.500]                           }
[13:34:36.500]                           base::stop(msg)
[13:34:36.500]                         }
[13:34:36.500]                       })
[13:34:36.500]                     }
[13:34:36.500]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.500]                     base::options(mc.cores = 1L)
[13:34:36.500]                   }
[13:34:36.500]                   ...future.strategy.old <- future::plan("list")
[13:34:36.500]                   options(future.plan = NULL)
[13:34:36.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.500]                 }
[13:34:36.500]                 ...future.workdir <- getwd()
[13:34:36.500]             }
[13:34:36.500]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.500]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.500]         }
[13:34:36.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.500]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:36.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.500]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.500]             base::names(...future.oldOptions))
[13:34:36.500]     }
[13:34:36.500]     if (FALSE) {
[13:34:36.500]     }
[13:34:36.500]     else {
[13:34:36.500]         if (TRUE) {
[13:34:36.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.500]                 open = "w")
[13:34:36.500]         }
[13:34:36.500]         else {
[13:34:36.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.500]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.500]         }
[13:34:36.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.500]             base::sink(type = "output", split = FALSE)
[13:34:36.500]             base::close(...future.stdout)
[13:34:36.500]         }, add = TRUE)
[13:34:36.500]     }
[13:34:36.500]     ...future.frame <- base::sys.nframe()
[13:34:36.500]     ...future.conditions <- base::list()
[13:34:36.500]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.500]     if (FALSE) {
[13:34:36.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.500]     }
[13:34:36.500]     ...future.result <- base::tryCatch({
[13:34:36.500]         base::withCallingHandlers({
[13:34:36.500]             ...future.value <- base::withVisible(base::local({
[13:34:36.500]                 withCallingHandlers({
[13:34:36.500]                   {
[13:34:36.500]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.500]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.500]                       ...future.globals.maxSize)) {
[13:34:36.500]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.500]                       on.exit(options(oopts), add = TRUE)
[13:34:36.500]                     }
[13:34:36.500]                     {
[13:34:36.500]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.500]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.500]                         USE.NAMES = FALSE)
[13:34:36.500]                       do.call(mapply, args = args)
[13:34:36.500]                     }
[13:34:36.500]                   }
[13:34:36.500]                 }, immediateCondition = function(cond) {
[13:34:36.500]                   save_rds <- function (object, pathname, ...) 
[13:34:36.500]                   {
[13:34:36.500]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.500]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.500]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.500]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.500]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.500]                         fi_tmp[["mtime"]])
[13:34:36.500]                     }
[13:34:36.500]                     tryCatch({
[13:34:36.500]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.500]                     }, error = function(ex) {
[13:34:36.500]                       msg <- conditionMessage(ex)
[13:34:36.500]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.500]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.500]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.500]                         fi_tmp[["mtime"]], msg)
[13:34:36.500]                       ex$message <- msg
[13:34:36.500]                       stop(ex)
[13:34:36.500]                     })
[13:34:36.500]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.500]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.500]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.500]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.500]                       fi <- file.info(pathname)
[13:34:36.500]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.500]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.500]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.500]                         fi[["size"]], fi[["mtime"]])
[13:34:36.500]                       stop(msg)
[13:34:36.500]                     }
[13:34:36.500]                     invisible(pathname)
[13:34:36.500]                   }
[13:34:36.500]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.500]                     rootPath = tempdir()) 
[13:34:36.500]                   {
[13:34:36.500]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.500]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.500]                       tmpdir = path, fileext = ".rds")
[13:34:36.500]                     save_rds(obj, file)
[13:34:36.500]                   }
[13:34:36.500]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.500]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.500]                   {
[13:34:36.500]                     inherits <- base::inherits
[13:34:36.500]                     invokeRestart <- base::invokeRestart
[13:34:36.500]                     is.null <- base::is.null
[13:34:36.500]                     muffled <- FALSE
[13:34:36.500]                     if (inherits(cond, "message")) {
[13:34:36.500]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.500]                       if (muffled) 
[13:34:36.500]                         invokeRestart("muffleMessage")
[13:34:36.500]                     }
[13:34:36.500]                     else if (inherits(cond, "warning")) {
[13:34:36.500]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.500]                       if (muffled) 
[13:34:36.500]                         invokeRestart("muffleWarning")
[13:34:36.500]                     }
[13:34:36.500]                     else if (inherits(cond, "condition")) {
[13:34:36.500]                       if (!is.null(pattern)) {
[13:34:36.500]                         computeRestarts <- base::computeRestarts
[13:34:36.500]                         grepl <- base::grepl
[13:34:36.500]                         restarts <- computeRestarts(cond)
[13:34:36.500]                         for (restart in restarts) {
[13:34:36.500]                           name <- restart$name
[13:34:36.500]                           if (is.null(name)) 
[13:34:36.500]                             next
[13:34:36.500]                           if (!grepl(pattern, name)) 
[13:34:36.500]                             next
[13:34:36.500]                           invokeRestart(restart)
[13:34:36.500]                           muffled <- TRUE
[13:34:36.500]                           break
[13:34:36.500]                         }
[13:34:36.500]                       }
[13:34:36.500]                     }
[13:34:36.500]                     invisible(muffled)
[13:34:36.500]                   }
[13:34:36.500]                   muffleCondition(cond)
[13:34:36.500]                 })
[13:34:36.500]             }))
[13:34:36.500]             future::FutureResult(value = ...future.value$value, 
[13:34:36.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.500]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.500]                     ...future.globalenv.names))
[13:34:36.500]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.500]         }, condition = base::local({
[13:34:36.500]             c <- base::c
[13:34:36.500]             inherits <- base::inherits
[13:34:36.500]             invokeRestart <- base::invokeRestart
[13:34:36.500]             length <- base::length
[13:34:36.500]             list <- base::list
[13:34:36.500]             seq.int <- base::seq.int
[13:34:36.500]             signalCondition <- base::signalCondition
[13:34:36.500]             sys.calls <- base::sys.calls
[13:34:36.500]             `[[` <- base::`[[`
[13:34:36.500]             `+` <- base::`+`
[13:34:36.500]             `<<-` <- base::`<<-`
[13:34:36.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.500]                   3L)]
[13:34:36.500]             }
[13:34:36.500]             function(cond) {
[13:34:36.500]                 is_error <- inherits(cond, "error")
[13:34:36.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.500]                   NULL)
[13:34:36.500]                 if (is_error) {
[13:34:36.500]                   sessionInformation <- function() {
[13:34:36.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.500]                       search = base::search(), system = base::Sys.info())
[13:34:36.500]                   }
[13:34:36.500]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.500]                     cond$call), session = sessionInformation(), 
[13:34:36.500]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.500]                   signalCondition(cond)
[13:34:36.500]                 }
[13:34:36.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.500]                 "immediateCondition"))) {
[13:34:36.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.500]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.500]                   if (TRUE && !signal) {
[13:34:36.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.500]                     {
[13:34:36.500]                       inherits <- base::inherits
[13:34:36.500]                       invokeRestart <- base::invokeRestart
[13:34:36.500]                       is.null <- base::is.null
[13:34:36.500]                       muffled <- FALSE
[13:34:36.500]                       if (inherits(cond, "message")) {
[13:34:36.500]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.500]                         if (muffled) 
[13:34:36.500]                           invokeRestart("muffleMessage")
[13:34:36.500]                       }
[13:34:36.500]                       else if (inherits(cond, "warning")) {
[13:34:36.500]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.500]                         if (muffled) 
[13:34:36.500]                           invokeRestart("muffleWarning")
[13:34:36.500]                       }
[13:34:36.500]                       else if (inherits(cond, "condition")) {
[13:34:36.500]                         if (!is.null(pattern)) {
[13:34:36.500]                           computeRestarts <- base::computeRestarts
[13:34:36.500]                           grepl <- base::grepl
[13:34:36.500]                           restarts <- computeRestarts(cond)
[13:34:36.500]                           for (restart in restarts) {
[13:34:36.500]                             name <- restart$name
[13:34:36.500]                             if (is.null(name)) 
[13:34:36.500]                               next
[13:34:36.500]                             if (!grepl(pattern, name)) 
[13:34:36.500]                               next
[13:34:36.500]                             invokeRestart(restart)
[13:34:36.500]                             muffled <- TRUE
[13:34:36.500]                             break
[13:34:36.500]                           }
[13:34:36.500]                         }
[13:34:36.500]                       }
[13:34:36.500]                       invisible(muffled)
[13:34:36.500]                     }
[13:34:36.500]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.500]                   }
[13:34:36.500]                 }
[13:34:36.500]                 else {
[13:34:36.500]                   if (TRUE) {
[13:34:36.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.500]                     {
[13:34:36.500]                       inherits <- base::inherits
[13:34:36.500]                       invokeRestart <- base::invokeRestart
[13:34:36.500]                       is.null <- base::is.null
[13:34:36.500]                       muffled <- FALSE
[13:34:36.500]                       if (inherits(cond, "message")) {
[13:34:36.500]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.500]                         if (muffled) 
[13:34:36.500]                           invokeRestart("muffleMessage")
[13:34:36.500]                       }
[13:34:36.500]                       else if (inherits(cond, "warning")) {
[13:34:36.500]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.500]                         if (muffled) 
[13:34:36.500]                           invokeRestart("muffleWarning")
[13:34:36.500]                       }
[13:34:36.500]                       else if (inherits(cond, "condition")) {
[13:34:36.500]                         if (!is.null(pattern)) {
[13:34:36.500]                           computeRestarts <- base::computeRestarts
[13:34:36.500]                           grepl <- base::grepl
[13:34:36.500]                           restarts <- computeRestarts(cond)
[13:34:36.500]                           for (restart in restarts) {
[13:34:36.500]                             name <- restart$name
[13:34:36.500]                             if (is.null(name)) 
[13:34:36.500]                               next
[13:34:36.500]                             if (!grepl(pattern, name)) 
[13:34:36.500]                               next
[13:34:36.500]                             invokeRestart(restart)
[13:34:36.500]                             muffled <- TRUE
[13:34:36.500]                             break
[13:34:36.500]                           }
[13:34:36.500]                         }
[13:34:36.500]                       }
[13:34:36.500]                       invisible(muffled)
[13:34:36.500]                     }
[13:34:36.500]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.500]                   }
[13:34:36.500]                 }
[13:34:36.500]             }
[13:34:36.500]         }))
[13:34:36.500]     }, error = function(ex) {
[13:34:36.500]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.500]                 ...future.rng), started = ...future.startTime, 
[13:34:36.500]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.500]             version = "1.8"), class = "FutureResult")
[13:34:36.500]     }, finally = {
[13:34:36.500]         if (!identical(...future.workdir, getwd())) 
[13:34:36.500]             setwd(...future.workdir)
[13:34:36.500]         {
[13:34:36.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.500]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.500]             }
[13:34:36.500]             base::options(...future.oldOptions)
[13:34:36.500]             if (.Platform$OS.type == "windows") {
[13:34:36.500]                 old_names <- names(...future.oldEnvVars)
[13:34:36.500]                 envs <- base::Sys.getenv()
[13:34:36.500]                 names <- names(envs)
[13:34:36.500]                 common <- intersect(names, old_names)
[13:34:36.500]                 added <- setdiff(names, old_names)
[13:34:36.500]                 removed <- setdiff(old_names, names)
[13:34:36.500]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.500]                   envs[common]]
[13:34:36.500]                 NAMES <- toupper(changed)
[13:34:36.500]                 args <- list()
[13:34:36.500]                 for (kk in seq_along(NAMES)) {
[13:34:36.500]                   name <- changed[[kk]]
[13:34:36.500]                   NAME <- NAMES[[kk]]
[13:34:36.500]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.500]                     next
[13:34:36.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.500]                 }
[13:34:36.500]                 NAMES <- toupper(added)
[13:34:36.500]                 for (kk in seq_along(NAMES)) {
[13:34:36.500]                   name <- added[[kk]]
[13:34:36.500]                   NAME <- NAMES[[kk]]
[13:34:36.500]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.500]                     next
[13:34:36.500]                   args[[name]] <- ""
[13:34:36.500]                 }
[13:34:36.500]                 NAMES <- toupper(removed)
[13:34:36.500]                 for (kk in seq_along(NAMES)) {
[13:34:36.500]                   name <- removed[[kk]]
[13:34:36.500]                   NAME <- NAMES[[kk]]
[13:34:36.500]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.500]                     next
[13:34:36.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.500]                 }
[13:34:36.500]                 if (length(args) > 0) 
[13:34:36.500]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.500]             }
[13:34:36.500]             else {
[13:34:36.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.500]             }
[13:34:36.500]             {
[13:34:36.500]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.500]                   0L) {
[13:34:36.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.500]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.500]                   base::options(opts)
[13:34:36.500]                 }
[13:34:36.500]                 {
[13:34:36.500]                   {
[13:34:36.500]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.500]                     NULL
[13:34:36.500]                   }
[13:34:36.500]                   options(future.plan = NULL)
[13:34:36.500]                   if (is.na(NA_character_)) 
[13:34:36.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.500]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.500]                     .init = FALSE)
[13:34:36.500]                 }
[13:34:36.500]             }
[13:34:36.500]         }
[13:34:36.500]     })
[13:34:36.500]     if (TRUE) {
[13:34:36.500]         base::sink(type = "output", split = FALSE)
[13:34:36.500]         if (TRUE) {
[13:34:36.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.500]         }
[13:34:36.500]         else {
[13:34:36.500]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.500]         }
[13:34:36.500]         base::close(...future.stdout)
[13:34:36.500]         ...future.stdout <- NULL
[13:34:36.500]     }
[13:34:36.500]     ...future.result$conditions <- ...future.conditions
[13:34:36.500]     ...future.result$finished <- base::Sys.time()
[13:34:36.500]     ...future.result
[13:34:36.500] }
[13:34:36.502] assign_globals() ...
[13:34:36.502] List of 5
[13:34:36.502]  $ ...future.FUN            :function (x)  
[13:34:36.502]  $ MoreArgs                 : list()
[13:34:36.502]  $ ...future.elements_ii    :List of 1
[13:34:36.502]   ..$ :List of 1
[13:34:36.502]   .. ..$ : Date[1:1], format: "2018-06-01"
[13:34:36.502]  $ ...future.seeds_ii       : NULL
[13:34:36.502]  $ ...future.globals.maxSize: NULL
[13:34:36.502]  - attr(*, "where")=List of 5
[13:34:36.502]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.502]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.502]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.502]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.502]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.502]  - attr(*, "resolved")= logi FALSE
[13:34:36.502]  - attr(*, "total_size")= num 1128
[13:34:36.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.502]  - attr(*, "already-done")= logi TRUE
[13:34:36.507] - copied ‘...future.FUN’ to environment
[13:34:36.509] - copied ‘MoreArgs’ to environment
[13:34:36.509] - copied ‘...future.elements_ii’ to environment
[13:34:36.509] - copied ‘...future.seeds_ii’ to environment
[13:34:36.509] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.510] assign_globals() ... done
[13:34:36.510] requestCore(): workers = 2
[13:34:36.512] MulticoreFuture started
[13:34:36.512] - Launch lazy future ... done
[13:34:36.513] plan(): Setting new future strategy stack:
[13:34:36.513] run() for ‘MulticoreFuture’ ... done
[13:34:36.514] Created future:
[13:34:36.513] List of future strategies:
[13:34:36.513] 1. sequential:
[13:34:36.513]    - args: function (..., envir = parent.frame())
[13:34:36.513]    - tweaked: FALSE
[13:34:36.513]    - call: NULL
[13:34:36.515] plan(): nbrOfWorkers() = 1
[13:34:36.518] plan(): Setting new future strategy stack:
[13:34:36.518] List of future strategies:
[13:34:36.518] 1. multicore:
[13:34:36.518]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.518]    - tweaked: FALSE
[13:34:36.518]    - call: plan(strategy)
[13:34:36.525] plan(): nbrOfWorkers() = 2
[13:34:36.514] MulticoreFuture:
[13:34:36.514] Label: ‘future_.mapply-1’
[13:34:36.514] Expression:
[13:34:36.514] {
[13:34:36.514]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.514]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.514]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.514]         on.exit(options(oopts), add = TRUE)
[13:34:36.514]     }
[13:34:36.514]     {
[13:34:36.514]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.514]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.514]         do.call(mapply, args = args)
[13:34:36.514]     }
[13:34:36.514] }
[13:34:36.514] Lazy evaluation: FALSE
[13:34:36.514] Asynchronous evaluation: TRUE
[13:34:36.514] Local evaluation: TRUE
[13:34:36.514] Environment: R_GlobalEnv
[13:34:36.514] Capture standard output: TRUE
[13:34:36.514] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.514] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.514] Packages: <none>
[13:34:36.514] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.514] Resolved: TRUE
[13:34:36.514] Value: <not collected>
[13:34:36.514] Conditions captured: <none>
[13:34:36.514] Early signaling: FALSE
[13:34:36.514] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.514] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.526] Chunk #1 of 1 ... DONE
[13:34:36.527] Launching 1 futures (chunks) ... DONE
[13:34:36.527] Resolving 1 futures (chunks) ...
[13:34:36.527] resolve() on list ...
[13:34:36.527]  recursive: 0
[13:34:36.528]  length: 1
[13:34:36.528] 
[13:34:36.528] Future #1
[13:34:36.528] result() for MulticoreFuture ...
[13:34:36.529] result() for MulticoreFuture ...
[13:34:36.530] result() for MulticoreFuture ... done
[13:34:36.530] result() for MulticoreFuture ... done
[13:34:36.530] result() for MulticoreFuture ...
[13:34:36.530] result() for MulticoreFuture ... done
[13:34:36.531] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:36.531] - nx: 1
[13:34:36.531] - relay: TRUE
[13:34:36.531] - stdout: TRUE
[13:34:36.531] - signal: TRUE
[13:34:36.531] - resignal: FALSE
[13:34:36.532] - force: TRUE
[13:34:36.532] - relayed: [n=1] FALSE
[13:34:36.532] - queued futures: [n=1] FALSE
[13:34:36.532]  - until=1
[13:34:36.532]  - relaying element #1
[13:34:36.532] result() for MulticoreFuture ...
[13:34:36.532] result() for MulticoreFuture ... done
[13:34:36.533] result() for MulticoreFuture ...
[13:34:36.533] result() for MulticoreFuture ... done
[13:34:36.533] result() for MulticoreFuture ...
[13:34:36.533] result() for MulticoreFuture ... done
[13:34:36.533] result() for MulticoreFuture ...
[13:34:36.533] result() for MulticoreFuture ... done
[13:34:36.534] - relayed: [n=1] TRUE
[13:34:36.534] - queued futures: [n=1] TRUE
[13:34:36.534] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:36.534]  length: 0 (resolved future 1)
[13:34:36.534] Relaying remaining futures
[13:34:36.534] signalConditionsASAP(NULL, pos=0) ...
[13:34:36.534] - nx: 1
[13:34:36.534] - relay: TRUE
[13:34:36.535] - stdout: TRUE
[13:34:36.535] - signal: TRUE
[13:34:36.535] - resignal: FALSE
[13:34:36.535] - force: TRUE
[13:34:36.535] - relayed: [n=1] TRUE
[13:34:36.535] - queued futures: [n=1] TRUE
 - flush all
[13:34:36.535] - relayed: [n=1] TRUE
[13:34:36.535] - queued futures: [n=1] TRUE
[13:34:36.535] signalConditionsASAP(NULL, pos=0) ... done
[13:34:36.536] resolve() on list ... DONE
[13:34:36.536] result() for MulticoreFuture ...
[13:34:36.536] result() for MulticoreFuture ... done
[13:34:36.536] result() for MulticoreFuture ...
[13:34:36.536] result() for MulticoreFuture ... done
[13:34:36.536]  - Number of value chunks collected: 1
[13:34:36.536] Resolving 1 futures (chunks) ... DONE
[13:34:36.537] Reducing values from 1 chunks ...
[13:34:36.537]  - Number of values collected after concatenation: 1
[13:34:36.537]  - Number of values expected: 1
[13:34:36.537] Reducing values from 1 chunks ... DONE
[13:34:36.537] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[13:34:36.537] future_mapply() ...
[13:34:36.541] Number of chunks: 2
[13:34:36.542] getGlobalsAndPackagesXApply() ...
[13:34:36.542]  - future.globals: TRUE
[13:34:36.542] getGlobalsAndPackages() ...
[13:34:36.542] Searching for globals...
[13:34:36.543] - globals found: [1] ‘FUN’
[13:34:36.543] Searching for globals ... DONE
[13:34:36.543] Resolving globals: FALSE
[13:34:36.544] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[13:34:36.544] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[13:34:36.544] - globals: [1] ‘FUN’
[13:34:36.544] 
[13:34:36.544] getGlobalsAndPackages() ... DONE
[13:34:36.545]  - globals found/used: [n=1] ‘FUN’
[13:34:36.545]  - needed namespaces: [n=0] 
[13:34:36.545] Finding globals ... DONE
[13:34:36.545] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:36.545] List of 2
[13:34:36.545]  $ ...future.FUN:function (x, y)  
[13:34:36.545]  $ MoreArgs     :List of 1
[13:34:36.545]   ..$ y: int [1:2] 3 4
[13:34:36.545]  - attr(*, "where")=List of 2
[13:34:36.545]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:36.545]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:36.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.545]  - attr(*, "resolved")= logi FALSE
[13:34:36.545]  - attr(*, "total_size")= num NA
[13:34:36.548] Packages to be attached in all futures: [n=0] 
[13:34:36.548] getGlobalsAndPackagesXApply() ... DONE
[13:34:36.549] Number of futures (= number of chunks): 2
[13:34:36.549] Launching 2 futures (chunks) ...
[13:34:36.549] Chunk #1 of 2 ...
[13:34:36.549]  - Finding globals in '...' for chunk #1 ...
[13:34:36.549] getGlobalsAndPackages() ...
[13:34:36.549] Searching for globals...
[13:34:36.549] 
[13:34:36.550] Searching for globals ... DONE
[13:34:36.550] - globals: [0] <none>
[13:34:36.550] getGlobalsAndPackages() ... DONE
[13:34:36.550]    + additional globals found: [n=0] 
[13:34:36.550]    + additional namespaces needed: [n=0] 
[13:34:36.550]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:36.550]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.550]  - seeds: <none>
[13:34:36.550]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.551] getGlobalsAndPackages() ...
[13:34:36.551] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.553] Resolving globals: FALSE
[13:34:36.554] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[13:34:36.554] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[13:34:36.555] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.555] 
[13:34:36.555] getGlobalsAndPackages() ... DONE
[13:34:36.555] run() for ‘Future’ ...
[13:34:36.555] - state: ‘created’
[13:34:36.555] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.559] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.559]   - Field: ‘label’
[13:34:36.560]   - Field: ‘local’
[13:34:36.560]   - Field: ‘owner’
[13:34:36.560]   - Field: ‘envir’
[13:34:36.560]   - Field: ‘workers’
[13:34:36.560]   - Field: ‘packages’
[13:34:36.560]   - Field: ‘gc’
[13:34:36.560]   - Field: ‘job’
[13:34:36.560]   - Field: ‘conditions’
[13:34:36.560]   - Field: ‘expr’
[13:34:36.561]   - Field: ‘uuid’
[13:34:36.561]   - Field: ‘seed’
[13:34:36.561]   - Field: ‘version’
[13:34:36.561]   - Field: ‘result’
[13:34:36.561]   - Field: ‘asynchronous’
[13:34:36.561]   - Field: ‘calls’
[13:34:36.561]   - Field: ‘globals’
[13:34:36.561]   - Field: ‘stdout’
[13:34:36.561]   - Field: ‘earlySignal’
[13:34:36.561]   - Field: ‘lazy’
[13:34:36.562]   - Field: ‘state’
[13:34:36.562] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.562] - Launch lazy future ...
[13:34:36.562] Packages needed by the future expression (n = 0): <none>
[13:34:36.562] Packages needed by future strategies (n = 0): <none>
[13:34:36.563] {
[13:34:36.563]     {
[13:34:36.563]         {
[13:34:36.563]             ...future.startTime <- base::Sys.time()
[13:34:36.563]             {
[13:34:36.563]                 {
[13:34:36.563]                   {
[13:34:36.563]                     {
[13:34:36.563]                       base::local({
[13:34:36.563]                         has_future <- base::requireNamespace("future", 
[13:34:36.563]                           quietly = TRUE)
[13:34:36.563]                         if (has_future) {
[13:34:36.563]                           ns <- base::getNamespace("future")
[13:34:36.563]                           version <- ns[[".package"]][["version"]]
[13:34:36.563]                           if (is.null(version)) 
[13:34:36.563]                             version <- utils::packageVersion("future")
[13:34:36.563]                         }
[13:34:36.563]                         else {
[13:34:36.563]                           version <- NULL
[13:34:36.563]                         }
[13:34:36.563]                         if (!has_future || version < "1.8.0") {
[13:34:36.563]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.563]                             "", base::R.version$version.string), 
[13:34:36.563]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.563]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.563]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.563]                               "release", "version")], collapse = " "), 
[13:34:36.563]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.563]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.563]                             info)
[13:34:36.563]                           info <- base::paste(info, collapse = "; ")
[13:34:36.563]                           if (!has_future) {
[13:34:36.563]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.563]                               info)
[13:34:36.563]                           }
[13:34:36.563]                           else {
[13:34:36.563]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.563]                               info, version)
[13:34:36.563]                           }
[13:34:36.563]                           base::stop(msg)
[13:34:36.563]                         }
[13:34:36.563]                       })
[13:34:36.563]                     }
[13:34:36.563]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.563]                     base::options(mc.cores = 1L)
[13:34:36.563]                   }
[13:34:36.563]                   ...future.strategy.old <- future::plan("list")
[13:34:36.563]                   options(future.plan = NULL)
[13:34:36.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.563]                 }
[13:34:36.563]                 ...future.workdir <- getwd()
[13:34:36.563]             }
[13:34:36.563]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.563]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.563]         }
[13:34:36.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.563]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.563]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.563]             base::names(...future.oldOptions))
[13:34:36.563]     }
[13:34:36.563]     if (FALSE) {
[13:34:36.563]     }
[13:34:36.563]     else {
[13:34:36.563]         if (TRUE) {
[13:34:36.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.563]                 open = "w")
[13:34:36.563]         }
[13:34:36.563]         else {
[13:34:36.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.563]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.563]         }
[13:34:36.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.563]             base::sink(type = "output", split = FALSE)
[13:34:36.563]             base::close(...future.stdout)
[13:34:36.563]         }, add = TRUE)
[13:34:36.563]     }
[13:34:36.563]     ...future.frame <- base::sys.nframe()
[13:34:36.563]     ...future.conditions <- base::list()
[13:34:36.563]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.563]     if (FALSE) {
[13:34:36.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.563]     }
[13:34:36.563]     ...future.result <- base::tryCatch({
[13:34:36.563]         base::withCallingHandlers({
[13:34:36.563]             ...future.value <- base::withVisible(base::local({
[13:34:36.563]                 withCallingHandlers({
[13:34:36.563]                   {
[13:34:36.563]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.563]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.563]                       ...future.globals.maxSize)) {
[13:34:36.563]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.563]                       on.exit(options(oopts), add = TRUE)
[13:34:36.563]                     }
[13:34:36.563]                     {
[13:34:36.563]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.563]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.563]                         USE.NAMES = FALSE)
[13:34:36.563]                       do.call(mapply, args = args)
[13:34:36.563]                     }
[13:34:36.563]                   }
[13:34:36.563]                 }, immediateCondition = function(cond) {
[13:34:36.563]                   save_rds <- function (object, pathname, ...) 
[13:34:36.563]                   {
[13:34:36.563]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.563]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.563]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.563]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.563]                         fi_tmp[["mtime"]])
[13:34:36.563]                     }
[13:34:36.563]                     tryCatch({
[13:34:36.563]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.563]                     }, error = function(ex) {
[13:34:36.563]                       msg <- conditionMessage(ex)
[13:34:36.563]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.563]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.563]                         fi_tmp[["mtime"]], msg)
[13:34:36.563]                       ex$message <- msg
[13:34:36.563]                       stop(ex)
[13:34:36.563]                     })
[13:34:36.563]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.563]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.563]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.563]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.563]                       fi <- file.info(pathname)
[13:34:36.563]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.563]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.563]                         fi[["size"]], fi[["mtime"]])
[13:34:36.563]                       stop(msg)
[13:34:36.563]                     }
[13:34:36.563]                     invisible(pathname)
[13:34:36.563]                   }
[13:34:36.563]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.563]                     rootPath = tempdir()) 
[13:34:36.563]                   {
[13:34:36.563]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.563]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.563]                       tmpdir = path, fileext = ".rds")
[13:34:36.563]                     save_rds(obj, file)
[13:34:36.563]                   }
[13:34:36.563]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.563]                   {
[13:34:36.563]                     inherits <- base::inherits
[13:34:36.563]                     invokeRestart <- base::invokeRestart
[13:34:36.563]                     is.null <- base::is.null
[13:34:36.563]                     muffled <- FALSE
[13:34:36.563]                     if (inherits(cond, "message")) {
[13:34:36.563]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.563]                       if (muffled) 
[13:34:36.563]                         invokeRestart("muffleMessage")
[13:34:36.563]                     }
[13:34:36.563]                     else if (inherits(cond, "warning")) {
[13:34:36.563]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.563]                       if (muffled) 
[13:34:36.563]                         invokeRestart("muffleWarning")
[13:34:36.563]                     }
[13:34:36.563]                     else if (inherits(cond, "condition")) {
[13:34:36.563]                       if (!is.null(pattern)) {
[13:34:36.563]                         computeRestarts <- base::computeRestarts
[13:34:36.563]                         grepl <- base::grepl
[13:34:36.563]                         restarts <- computeRestarts(cond)
[13:34:36.563]                         for (restart in restarts) {
[13:34:36.563]                           name <- restart$name
[13:34:36.563]                           if (is.null(name)) 
[13:34:36.563]                             next
[13:34:36.563]                           if (!grepl(pattern, name)) 
[13:34:36.563]                             next
[13:34:36.563]                           invokeRestart(restart)
[13:34:36.563]                           muffled <- TRUE
[13:34:36.563]                           break
[13:34:36.563]                         }
[13:34:36.563]                       }
[13:34:36.563]                     }
[13:34:36.563]                     invisible(muffled)
[13:34:36.563]                   }
[13:34:36.563]                   muffleCondition(cond)
[13:34:36.563]                 })
[13:34:36.563]             }))
[13:34:36.563]             future::FutureResult(value = ...future.value$value, 
[13:34:36.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.563]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.563]                     ...future.globalenv.names))
[13:34:36.563]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.563]         }, condition = base::local({
[13:34:36.563]             c <- base::c
[13:34:36.563]             inherits <- base::inherits
[13:34:36.563]             invokeRestart <- base::invokeRestart
[13:34:36.563]             length <- base::length
[13:34:36.563]             list <- base::list
[13:34:36.563]             seq.int <- base::seq.int
[13:34:36.563]             signalCondition <- base::signalCondition
[13:34:36.563]             sys.calls <- base::sys.calls
[13:34:36.563]             `[[` <- base::`[[`
[13:34:36.563]             `+` <- base::`+`
[13:34:36.563]             `<<-` <- base::`<<-`
[13:34:36.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.563]                   3L)]
[13:34:36.563]             }
[13:34:36.563]             function(cond) {
[13:34:36.563]                 is_error <- inherits(cond, "error")
[13:34:36.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.563]                   NULL)
[13:34:36.563]                 if (is_error) {
[13:34:36.563]                   sessionInformation <- function() {
[13:34:36.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.563]                       search = base::search(), system = base::Sys.info())
[13:34:36.563]                   }
[13:34:36.563]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.563]                     cond$call), session = sessionInformation(), 
[13:34:36.563]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.563]                   signalCondition(cond)
[13:34:36.563]                 }
[13:34:36.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.563]                 "immediateCondition"))) {
[13:34:36.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.563]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.563]                   if (TRUE && !signal) {
[13:34:36.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.563]                     {
[13:34:36.563]                       inherits <- base::inherits
[13:34:36.563]                       invokeRestart <- base::invokeRestart
[13:34:36.563]                       is.null <- base::is.null
[13:34:36.563]                       muffled <- FALSE
[13:34:36.563]                       if (inherits(cond, "message")) {
[13:34:36.563]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.563]                         if (muffled) 
[13:34:36.563]                           invokeRestart("muffleMessage")
[13:34:36.563]                       }
[13:34:36.563]                       else if (inherits(cond, "warning")) {
[13:34:36.563]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.563]                         if (muffled) 
[13:34:36.563]                           invokeRestart("muffleWarning")
[13:34:36.563]                       }
[13:34:36.563]                       else if (inherits(cond, "condition")) {
[13:34:36.563]                         if (!is.null(pattern)) {
[13:34:36.563]                           computeRestarts <- base::computeRestarts
[13:34:36.563]                           grepl <- base::grepl
[13:34:36.563]                           restarts <- computeRestarts(cond)
[13:34:36.563]                           for (restart in restarts) {
[13:34:36.563]                             name <- restart$name
[13:34:36.563]                             if (is.null(name)) 
[13:34:36.563]                               next
[13:34:36.563]                             if (!grepl(pattern, name)) 
[13:34:36.563]                               next
[13:34:36.563]                             invokeRestart(restart)
[13:34:36.563]                             muffled <- TRUE
[13:34:36.563]                             break
[13:34:36.563]                           }
[13:34:36.563]                         }
[13:34:36.563]                       }
[13:34:36.563]                       invisible(muffled)
[13:34:36.563]                     }
[13:34:36.563]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.563]                   }
[13:34:36.563]                 }
[13:34:36.563]                 else {
[13:34:36.563]                   if (TRUE) {
[13:34:36.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.563]                     {
[13:34:36.563]                       inherits <- base::inherits
[13:34:36.563]                       invokeRestart <- base::invokeRestart
[13:34:36.563]                       is.null <- base::is.null
[13:34:36.563]                       muffled <- FALSE
[13:34:36.563]                       if (inherits(cond, "message")) {
[13:34:36.563]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.563]                         if (muffled) 
[13:34:36.563]                           invokeRestart("muffleMessage")
[13:34:36.563]                       }
[13:34:36.563]                       else if (inherits(cond, "warning")) {
[13:34:36.563]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.563]                         if (muffled) 
[13:34:36.563]                           invokeRestart("muffleWarning")
[13:34:36.563]                       }
[13:34:36.563]                       else if (inherits(cond, "condition")) {
[13:34:36.563]                         if (!is.null(pattern)) {
[13:34:36.563]                           computeRestarts <- base::computeRestarts
[13:34:36.563]                           grepl <- base::grepl
[13:34:36.563]                           restarts <- computeRestarts(cond)
[13:34:36.563]                           for (restart in restarts) {
[13:34:36.563]                             name <- restart$name
[13:34:36.563]                             if (is.null(name)) 
[13:34:36.563]                               next
[13:34:36.563]                             if (!grepl(pattern, name)) 
[13:34:36.563]                               next
[13:34:36.563]                             invokeRestart(restart)
[13:34:36.563]                             muffled <- TRUE
[13:34:36.563]                             break
[13:34:36.563]                           }
[13:34:36.563]                         }
[13:34:36.563]                       }
[13:34:36.563]                       invisible(muffled)
[13:34:36.563]                     }
[13:34:36.563]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.563]                   }
[13:34:36.563]                 }
[13:34:36.563]             }
[13:34:36.563]         }))
[13:34:36.563]     }, error = function(ex) {
[13:34:36.563]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.563]                 ...future.rng), started = ...future.startTime, 
[13:34:36.563]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.563]             version = "1.8"), class = "FutureResult")
[13:34:36.563]     }, finally = {
[13:34:36.563]         if (!identical(...future.workdir, getwd())) 
[13:34:36.563]             setwd(...future.workdir)
[13:34:36.563]         {
[13:34:36.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.563]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.563]             }
[13:34:36.563]             base::options(...future.oldOptions)
[13:34:36.563]             if (.Platform$OS.type == "windows") {
[13:34:36.563]                 old_names <- names(...future.oldEnvVars)
[13:34:36.563]                 envs <- base::Sys.getenv()
[13:34:36.563]                 names <- names(envs)
[13:34:36.563]                 common <- intersect(names, old_names)
[13:34:36.563]                 added <- setdiff(names, old_names)
[13:34:36.563]                 removed <- setdiff(old_names, names)
[13:34:36.563]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.563]                   envs[common]]
[13:34:36.563]                 NAMES <- toupper(changed)
[13:34:36.563]                 args <- list()
[13:34:36.563]                 for (kk in seq_along(NAMES)) {
[13:34:36.563]                   name <- changed[[kk]]
[13:34:36.563]                   NAME <- NAMES[[kk]]
[13:34:36.563]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.563]                     next
[13:34:36.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.563]                 }
[13:34:36.563]                 NAMES <- toupper(added)
[13:34:36.563]                 for (kk in seq_along(NAMES)) {
[13:34:36.563]                   name <- added[[kk]]
[13:34:36.563]                   NAME <- NAMES[[kk]]
[13:34:36.563]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.563]                     next
[13:34:36.563]                   args[[name]] <- ""
[13:34:36.563]                 }
[13:34:36.563]                 NAMES <- toupper(removed)
[13:34:36.563]                 for (kk in seq_along(NAMES)) {
[13:34:36.563]                   name <- removed[[kk]]
[13:34:36.563]                   NAME <- NAMES[[kk]]
[13:34:36.563]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.563]                     next
[13:34:36.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.563]                 }
[13:34:36.563]                 if (length(args) > 0) 
[13:34:36.563]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.563]             }
[13:34:36.563]             else {
[13:34:36.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.563]             }
[13:34:36.563]             {
[13:34:36.563]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.563]                   0L) {
[13:34:36.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.563]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.563]                   base::options(opts)
[13:34:36.563]                 }
[13:34:36.563]                 {
[13:34:36.563]                   {
[13:34:36.563]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.563]                     NULL
[13:34:36.563]                   }
[13:34:36.563]                   options(future.plan = NULL)
[13:34:36.563]                   if (is.na(NA_character_)) 
[13:34:36.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.563]                     .init = FALSE)
[13:34:36.563]                 }
[13:34:36.563]             }
[13:34:36.563]         }
[13:34:36.563]     })
[13:34:36.563]     if (TRUE) {
[13:34:36.563]         base::sink(type = "output", split = FALSE)
[13:34:36.563]         if (TRUE) {
[13:34:36.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.563]         }
[13:34:36.563]         else {
[13:34:36.563]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.563]         }
[13:34:36.563]         base::close(...future.stdout)
[13:34:36.563]         ...future.stdout <- NULL
[13:34:36.563]     }
[13:34:36.563]     ...future.result$conditions <- ...future.conditions
[13:34:36.563]     ...future.result$finished <- base::Sys.time()
[13:34:36.563]     ...future.result
[13:34:36.563] }
[13:34:36.565] assign_globals() ...
[13:34:36.565] List of 5
[13:34:36.565]  $ ...future.FUN            :function (x, y)  
[13:34:36.565]  $ MoreArgs                 :List of 1
[13:34:36.565]   ..$ y: int [1:2] 3 4
[13:34:36.565]  $ ...future.elements_ii    :List of 1
[13:34:36.565]   ..$ x:List of 1
[13:34:36.565]   .. ..$ : int 1
[13:34:36.565]  $ ...future.seeds_ii       : NULL
[13:34:36.565]  $ ...future.globals.maxSize: NULL
[13:34:36.565]  - attr(*, "where")=List of 5
[13:34:36.565]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.565]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.565]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.565]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.565]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.565]  - attr(*, "resolved")= logi FALSE
[13:34:36.565]  - attr(*, "total_size")= num 1816
[13:34:36.565]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.565]  - attr(*, "already-done")= logi TRUE
[13:34:36.570] - reassign environment for ‘...future.FUN’
[13:34:36.570] - copied ‘...future.FUN’ to environment
[13:34:36.571] - copied ‘MoreArgs’ to environment
[13:34:36.571] - copied ‘...future.elements_ii’ to environment
[13:34:36.571] - copied ‘...future.seeds_ii’ to environment
[13:34:36.571] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.571] assign_globals() ... done
[13:34:36.571] requestCore(): workers = 2
[13:34:36.573] MulticoreFuture started
[13:34:36.573] - Launch lazy future ... done
[13:34:36.574] run() for ‘MulticoreFuture’ ... done
[13:34:36.574] Created future:
[13:34:36.574] plan(): Setting new future strategy stack:
[13:34:36.574] List of future strategies:
[13:34:36.574] 1. sequential:
[13:34:36.574]    - args: function (..., envir = parent.frame())
[13:34:36.574]    - tweaked: FALSE
[13:34:36.574]    - call: NULL
[13:34:36.575] plan(): nbrOfWorkers() = 1
[13:34:36.577] plan(): Setting new future strategy stack:
[13:34:36.577] List of future strategies:
[13:34:36.577] 1. multicore:
[13:34:36.577]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.577]    - tweaked: FALSE
[13:34:36.577]    - call: plan(strategy)
[13:34:36.583] plan(): nbrOfWorkers() = 2
[13:34:36.574] MulticoreFuture:
[13:34:36.574] Label: ‘future_mapply-1’
[13:34:36.574] Expression:
[13:34:36.574] {
[13:34:36.574]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.574]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.574]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.574]         on.exit(options(oopts), add = TRUE)
[13:34:36.574]     }
[13:34:36.574]     {
[13:34:36.574]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.574]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.574]         do.call(mapply, args = args)
[13:34:36.574]     }
[13:34:36.574] }
[13:34:36.574] Lazy evaluation: FALSE
[13:34:36.574] Asynchronous evaluation: TRUE
[13:34:36.574] Local evaluation: TRUE
[13:34:36.574] Environment: R_GlobalEnv
[13:34:36.574] Capture standard output: TRUE
[13:34:36.574] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.574] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.574] Packages: <none>
[13:34:36.574] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.574] Resolved: TRUE
[13:34:36.574] Value: <not collected>
[13:34:36.574] Conditions captured: <none>
[13:34:36.574] Early signaling: FALSE
[13:34:36.574] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.574] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.583] Chunk #1 of 2 ... DONE
[13:34:36.584] Chunk #2 of 2 ...
[13:34:36.584]  - Finding globals in '...' for chunk #2 ...
[13:34:36.584] getGlobalsAndPackages() ...
[13:34:36.584] Searching for globals...
[13:34:36.585] 
[13:34:36.585] Searching for globals ... DONE
[13:34:36.585] - globals: [0] <none>
[13:34:36.585] getGlobalsAndPackages() ... DONE
[13:34:36.585]    + additional globals found: [n=0] 
[13:34:36.585]    + additional namespaces needed: [n=0] 
[13:34:36.586]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:36.586]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.586]  - seeds: <none>
[13:34:36.586]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.586] getGlobalsAndPackages() ...
[13:34:36.586] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.587] Resolving globals: FALSE
[13:34:36.587] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[13:34:36.588] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[13:34:36.588] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.589] 
[13:34:36.589] getGlobalsAndPackages() ... DONE
[13:34:36.589] run() for ‘Future’ ...
[13:34:36.590] - state: ‘created’
[13:34:36.590] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.599] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.600]   - Field: ‘label’
[13:34:36.600]   - Field: ‘local’
[13:34:36.600]   - Field: ‘owner’
[13:34:36.601]   - Field: ‘envir’
[13:34:36.601]   - Field: ‘workers’
[13:34:36.601]   - Field: ‘packages’
[13:34:36.602]   - Field: ‘gc’
[13:34:36.602]   - Field: ‘job’
[13:34:36.602]   - Field: ‘conditions’
[13:34:36.602]   - Field: ‘expr’
[13:34:36.603]   - Field: ‘uuid’
[13:34:36.603]   - Field: ‘seed’
[13:34:36.603]   - Field: ‘version’
[13:34:36.603]   - Field: ‘result’
[13:34:36.604]   - Field: ‘asynchronous’
[13:34:36.604]   - Field: ‘calls’
[13:34:36.604]   - Field: ‘globals’
[13:34:36.604]   - Field: ‘stdout’
[13:34:36.604]   - Field: ‘earlySignal’
[13:34:36.605]   - Field: ‘lazy’
[13:34:36.605]   - Field: ‘state’
[13:34:36.605] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.605] - Launch lazy future ...
[13:34:36.606] Packages needed by the future expression (n = 0): <none>
[13:34:36.606] Packages needed by future strategies (n = 0): <none>
[13:34:36.607] {
[13:34:36.607]     {
[13:34:36.607]         {
[13:34:36.607]             ...future.startTime <- base::Sys.time()
[13:34:36.607]             {
[13:34:36.607]                 {
[13:34:36.607]                   {
[13:34:36.607]                     {
[13:34:36.607]                       base::local({
[13:34:36.607]                         has_future <- base::requireNamespace("future", 
[13:34:36.607]                           quietly = TRUE)
[13:34:36.607]                         if (has_future) {
[13:34:36.607]                           ns <- base::getNamespace("future")
[13:34:36.607]                           version <- ns[[".package"]][["version"]]
[13:34:36.607]                           if (is.null(version)) 
[13:34:36.607]                             version <- utils::packageVersion("future")
[13:34:36.607]                         }
[13:34:36.607]                         else {
[13:34:36.607]                           version <- NULL
[13:34:36.607]                         }
[13:34:36.607]                         if (!has_future || version < "1.8.0") {
[13:34:36.607]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.607]                             "", base::R.version$version.string), 
[13:34:36.607]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.607]                               "release", "version")], collapse = " "), 
[13:34:36.607]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.607]                             info)
[13:34:36.607]                           info <- base::paste(info, collapse = "; ")
[13:34:36.607]                           if (!has_future) {
[13:34:36.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.607]                               info)
[13:34:36.607]                           }
[13:34:36.607]                           else {
[13:34:36.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.607]                               info, version)
[13:34:36.607]                           }
[13:34:36.607]                           base::stop(msg)
[13:34:36.607]                         }
[13:34:36.607]                       })
[13:34:36.607]                     }
[13:34:36.607]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.607]                     base::options(mc.cores = 1L)
[13:34:36.607]                   }
[13:34:36.607]                   ...future.strategy.old <- future::plan("list")
[13:34:36.607]                   options(future.plan = NULL)
[13:34:36.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.607]                 }
[13:34:36.607]                 ...future.workdir <- getwd()
[13:34:36.607]             }
[13:34:36.607]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.607]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.607]         }
[13:34:36.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.607]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.607]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.607]             base::names(...future.oldOptions))
[13:34:36.607]     }
[13:34:36.607]     if (FALSE) {
[13:34:36.607]     }
[13:34:36.607]     else {
[13:34:36.607]         if (TRUE) {
[13:34:36.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.607]                 open = "w")
[13:34:36.607]         }
[13:34:36.607]         else {
[13:34:36.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.607]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.607]         }
[13:34:36.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.607]             base::sink(type = "output", split = FALSE)
[13:34:36.607]             base::close(...future.stdout)
[13:34:36.607]         }, add = TRUE)
[13:34:36.607]     }
[13:34:36.607]     ...future.frame <- base::sys.nframe()
[13:34:36.607]     ...future.conditions <- base::list()
[13:34:36.607]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.607]     if (FALSE) {
[13:34:36.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.607]     }
[13:34:36.607]     ...future.result <- base::tryCatch({
[13:34:36.607]         base::withCallingHandlers({
[13:34:36.607]             ...future.value <- base::withVisible(base::local({
[13:34:36.607]                 withCallingHandlers({
[13:34:36.607]                   {
[13:34:36.607]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.607]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.607]                       ...future.globals.maxSize)) {
[13:34:36.607]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.607]                       on.exit(options(oopts), add = TRUE)
[13:34:36.607]                     }
[13:34:36.607]                     {
[13:34:36.607]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.607]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.607]                         USE.NAMES = FALSE)
[13:34:36.607]                       do.call(mapply, args = args)
[13:34:36.607]                     }
[13:34:36.607]                   }
[13:34:36.607]                 }, immediateCondition = function(cond) {
[13:34:36.607]                   save_rds <- function (object, pathname, ...) 
[13:34:36.607]                   {
[13:34:36.607]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.607]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.607]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.607]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.607]                         fi_tmp[["mtime"]])
[13:34:36.607]                     }
[13:34:36.607]                     tryCatch({
[13:34:36.607]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.607]                     }, error = function(ex) {
[13:34:36.607]                       msg <- conditionMessage(ex)
[13:34:36.607]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.607]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.607]                         fi_tmp[["mtime"]], msg)
[13:34:36.607]                       ex$message <- msg
[13:34:36.607]                       stop(ex)
[13:34:36.607]                     })
[13:34:36.607]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.607]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.607]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.607]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.607]                       fi <- file.info(pathname)
[13:34:36.607]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.607]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.607]                         fi[["size"]], fi[["mtime"]])
[13:34:36.607]                       stop(msg)
[13:34:36.607]                     }
[13:34:36.607]                     invisible(pathname)
[13:34:36.607]                   }
[13:34:36.607]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.607]                     rootPath = tempdir()) 
[13:34:36.607]                   {
[13:34:36.607]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.607]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.607]                       tmpdir = path, fileext = ".rds")
[13:34:36.607]                     save_rds(obj, file)
[13:34:36.607]                   }
[13:34:36.607]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.607]                   {
[13:34:36.607]                     inherits <- base::inherits
[13:34:36.607]                     invokeRestart <- base::invokeRestart
[13:34:36.607]                     is.null <- base::is.null
[13:34:36.607]                     muffled <- FALSE
[13:34:36.607]                     if (inherits(cond, "message")) {
[13:34:36.607]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.607]                       if (muffled) 
[13:34:36.607]                         invokeRestart("muffleMessage")
[13:34:36.607]                     }
[13:34:36.607]                     else if (inherits(cond, "warning")) {
[13:34:36.607]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.607]                       if (muffled) 
[13:34:36.607]                         invokeRestart("muffleWarning")
[13:34:36.607]                     }
[13:34:36.607]                     else if (inherits(cond, "condition")) {
[13:34:36.607]                       if (!is.null(pattern)) {
[13:34:36.607]                         computeRestarts <- base::computeRestarts
[13:34:36.607]                         grepl <- base::grepl
[13:34:36.607]                         restarts <- computeRestarts(cond)
[13:34:36.607]                         for (restart in restarts) {
[13:34:36.607]                           name <- restart$name
[13:34:36.607]                           if (is.null(name)) 
[13:34:36.607]                             next
[13:34:36.607]                           if (!grepl(pattern, name)) 
[13:34:36.607]                             next
[13:34:36.607]                           invokeRestart(restart)
[13:34:36.607]                           muffled <- TRUE
[13:34:36.607]                           break
[13:34:36.607]                         }
[13:34:36.607]                       }
[13:34:36.607]                     }
[13:34:36.607]                     invisible(muffled)
[13:34:36.607]                   }
[13:34:36.607]                   muffleCondition(cond)
[13:34:36.607]                 })
[13:34:36.607]             }))
[13:34:36.607]             future::FutureResult(value = ...future.value$value, 
[13:34:36.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.607]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.607]                     ...future.globalenv.names))
[13:34:36.607]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.607]         }, condition = base::local({
[13:34:36.607]             c <- base::c
[13:34:36.607]             inherits <- base::inherits
[13:34:36.607]             invokeRestart <- base::invokeRestart
[13:34:36.607]             length <- base::length
[13:34:36.607]             list <- base::list
[13:34:36.607]             seq.int <- base::seq.int
[13:34:36.607]             signalCondition <- base::signalCondition
[13:34:36.607]             sys.calls <- base::sys.calls
[13:34:36.607]             `[[` <- base::`[[`
[13:34:36.607]             `+` <- base::`+`
[13:34:36.607]             `<<-` <- base::`<<-`
[13:34:36.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.607]                   3L)]
[13:34:36.607]             }
[13:34:36.607]             function(cond) {
[13:34:36.607]                 is_error <- inherits(cond, "error")
[13:34:36.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.607]                   NULL)
[13:34:36.607]                 if (is_error) {
[13:34:36.607]                   sessionInformation <- function() {
[13:34:36.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.607]                       search = base::search(), system = base::Sys.info())
[13:34:36.607]                   }
[13:34:36.607]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.607]                     cond$call), session = sessionInformation(), 
[13:34:36.607]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.607]                   signalCondition(cond)
[13:34:36.607]                 }
[13:34:36.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.607]                 "immediateCondition"))) {
[13:34:36.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.607]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.607]                   if (TRUE && !signal) {
[13:34:36.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.607]                     {
[13:34:36.607]                       inherits <- base::inherits
[13:34:36.607]                       invokeRestart <- base::invokeRestart
[13:34:36.607]                       is.null <- base::is.null
[13:34:36.607]                       muffled <- FALSE
[13:34:36.607]                       if (inherits(cond, "message")) {
[13:34:36.607]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.607]                         if (muffled) 
[13:34:36.607]                           invokeRestart("muffleMessage")
[13:34:36.607]                       }
[13:34:36.607]                       else if (inherits(cond, "warning")) {
[13:34:36.607]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.607]                         if (muffled) 
[13:34:36.607]                           invokeRestart("muffleWarning")
[13:34:36.607]                       }
[13:34:36.607]                       else if (inherits(cond, "condition")) {
[13:34:36.607]                         if (!is.null(pattern)) {
[13:34:36.607]                           computeRestarts <- base::computeRestarts
[13:34:36.607]                           grepl <- base::grepl
[13:34:36.607]                           restarts <- computeRestarts(cond)
[13:34:36.607]                           for (restart in restarts) {
[13:34:36.607]                             name <- restart$name
[13:34:36.607]                             if (is.null(name)) 
[13:34:36.607]                               next
[13:34:36.607]                             if (!grepl(pattern, name)) 
[13:34:36.607]                               next
[13:34:36.607]                             invokeRestart(restart)
[13:34:36.607]                             muffled <- TRUE
[13:34:36.607]                             break
[13:34:36.607]                           }
[13:34:36.607]                         }
[13:34:36.607]                       }
[13:34:36.607]                       invisible(muffled)
[13:34:36.607]                     }
[13:34:36.607]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.607]                   }
[13:34:36.607]                 }
[13:34:36.607]                 else {
[13:34:36.607]                   if (TRUE) {
[13:34:36.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.607]                     {
[13:34:36.607]                       inherits <- base::inherits
[13:34:36.607]                       invokeRestart <- base::invokeRestart
[13:34:36.607]                       is.null <- base::is.null
[13:34:36.607]                       muffled <- FALSE
[13:34:36.607]                       if (inherits(cond, "message")) {
[13:34:36.607]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.607]                         if (muffled) 
[13:34:36.607]                           invokeRestart("muffleMessage")
[13:34:36.607]                       }
[13:34:36.607]                       else if (inherits(cond, "warning")) {
[13:34:36.607]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.607]                         if (muffled) 
[13:34:36.607]                           invokeRestart("muffleWarning")
[13:34:36.607]                       }
[13:34:36.607]                       else if (inherits(cond, "condition")) {
[13:34:36.607]                         if (!is.null(pattern)) {
[13:34:36.607]                           computeRestarts <- base::computeRestarts
[13:34:36.607]                           grepl <- base::grepl
[13:34:36.607]                           restarts <- computeRestarts(cond)
[13:34:36.607]                           for (restart in restarts) {
[13:34:36.607]                             name <- restart$name
[13:34:36.607]                             if (is.null(name)) 
[13:34:36.607]                               next
[13:34:36.607]                             if (!grepl(pattern, name)) 
[13:34:36.607]                               next
[13:34:36.607]                             invokeRestart(restart)
[13:34:36.607]                             muffled <- TRUE
[13:34:36.607]                             break
[13:34:36.607]                           }
[13:34:36.607]                         }
[13:34:36.607]                       }
[13:34:36.607]                       invisible(muffled)
[13:34:36.607]                     }
[13:34:36.607]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.607]                   }
[13:34:36.607]                 }
[13:34:36.607]             }
[13:34:36.607]         }))
[13:34:36.607]     }, error = function(ex) {
[13:34:36.607]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.607]                 ...future.rng), started = ...future.startTime, 
[13:34:36.607]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.607]             version = "1.8"), class = "FutureResult")
[13:34:36.607]     }, finally = {
[13:34:36.607]         if (!identical(...future.workdir, getwd())) 
[13:34:36.607]             setwd(...future.workdir)
[13:34:36.607]         {
[13:34:36.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.607]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.607]             }
[13:34:36.607]             base::options(...future.oldOptions)
[13:34:36.607]             if (.Platform$OS.type == "windows") {
[13:34:36.607]                 old_names <- names(...future.oldEnvVars)
[13:34:36.607]                 envs <- base::Sys.getenv()
[13:34:36.607]                 names <- names(envs)
[13:34:36.607]                 common <- intersect(names, old_names)
[13:34:36.607]                 added <- setdiff(names, old_names)
[13:34:36.607]                 removed <- setdiff(old_names, names)
[13:34:36.607]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.607]                   envs[common]]
[13:34:36.607]                 NAMES <- toupper(changed)
[13:34:36.607]                 args <- list()
[13:34:36.607]                 for (kk in seq_along(NAMES)) {
[13:34:36.607]                   name <- changed[[kk]]
[13:34:36.607]                   NAME <- NAMES[[kk]]
[13:34:36.607]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.607]                     next
[13:34:36.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.607]                 }
[13:34:36.607]                 NAMES <- toupper(added)
[13:34:36.607]                 for (kk in seq_along(NAMES)) {
[13:34:36.607]                   name <- added[[kk]]
[13:34:36.607]                   NAME <- NAMES[[kk]]
[13:34:36.607]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.607]                     next
[13:34:36.607]                   args[[name]] <- ""
[13:34:36.607]                 }
[13:34:36.607]                 NAMES <- toupper(removed)
[13:34:36.607]                 for (kk in seq_along(NAMES)) {
[13:34:36.607]                   name <- removed[[kk]]
[13:34:36.607]                   NAME <- NAMES[[kk]]
[13:34:36.607]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.607]                     next
[13:34:36.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.607]                 }
[13:34:36.607]                 if (length(args) > 0) 
[13:34:36.607]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.607]             }
[13:34:36.607]             else {
[13:34:36.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.607]             }
[13:34:36.607]             {
[13:34:36.607]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.607]                   0L) {
[13:34:36.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.607]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.607]                   base::options(opts)
[13:34:36.607]                 }
[13:34:36.607]                 {
[13:34:36.607]                   {
[13:34:36.607]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.607]                     NULL
[13:34:36.607]                   }
[13:34:36.607]                   options(future.plan = NULL)
[13:34:36.607]                   if (is.na(NA_character_)) 
[13:34:36.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.607]                     .init = FALSE)
[13:34:36.607]                 }
[13:34:36.607]             }
[13:34:36.607]         }
[13:34:36.607]     })
[13:34:36.607]     if (TRUE) {
[13:34:36.607]         base::sink(type = "output", split = FALSE)
[13:34:36.607]         if (TRUE) {
[13:34:36.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.607]         }
[13:34:36.607]         else {
[13:34:36.607]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.607]         }
[13:34:36.607]         base::close(...future.stdout)
[13:34:36.607]         ...future.stdout <- NULL
[13:34:36.607]     }
[13:34:36.607]     ...future.result$conditions <- ...future.conditions
[13:34:36.607]     ...future.result$finished <- base::Sys.time()
[13:34:36.607]     ...future.result
[13:34:36.607] }
[13:34:36.610] assign_globals() ...
[13:34:36.610] List of 5
[13:34:36.610]  $ ...future.FUN            :function (x, y)  
[13:34:36.610]  $ MoreArgs                 :List of 1
[13:34:36.610]   ..$ y: int [1:2] 3 4
[13:34:36.610]  $ ...future.elements_ii    :List of 1
[13:34:36.610]   ..$ x:List of 1
[13:34:36.610]   .. ..$ : int 2
[13:34:36.610]  $ ...future.seeds_ii       : NULL
[13:34:36.610]  $ ...future.globals.maxSize: NULL
[13:34:36.610]  - attr(*, "where")=List of 5
[13:34:36.610]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.610]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.610]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.610]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.610]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.610]  - attr(*, "resolved")= logi FALSE
[13:34:36.610]  - attr(*, "total_size")= num 1816
[13:34:36.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.610]  - attr(*, "already-done")= logi TRUE
[13:34:36.618] - reassign environment for ‘...future.FUN’
[13:34:36.618] - copied ‘...future.FUN’ to environment
[13:34:36.619] - copied ‘MoreArgs’ to environment
[13:34:36.619] - copied ‘...future.elements_ii’ to environment
[13:34:36.619] - copied ‘...future.seeds_ii’ to environment
[13:34:36.619] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.619] assign_globals() ... done
[13:34:36.619] requestCore(): workers = 2
[13:34:36.621] MulticoreFuture started
[13:34:36.622] - Launch lazy future ... done
[13:34:36.622] run() for ‘MulticoreFuture’ ... done
[13:34:36.622] Created future:
[13:34:36.623] plan(): Setting new future strategy stack:
[13:34:36.623] List of future strategies:
[13:34:36.623] 1. sequential:
[13:34:36.623]    - args: function (..., envir = parent.frame())
[13:34:36.623]    - tweaked: FALSE
[13:34:36.623]    - call: NULL
[13:34:36.624] plan(): nbrOfWorkers() = 1
[13:34:36.626] plan(): Setting new future strategy stack:
[13:34:36.626] List of future strategies:
[13:34:36.626] 1. multicore:
[13:34:36.626]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.626]    - tweaked: FALSE
[13:34:36.626]    - call: plan(strategy)
[13:34:36.631] plan(): nbrOfWorkers() = 2
[13:34:36.623] MulticoreFuture:
[13:34:36.623] Label: ‘future_mapply-2’
[13:34:36.623] Expression:
[13:34:36.623] {
[13:34:36.623]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.623]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.623]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.623]         on.exit(options(oopts), add = TRUE)
[13:34:36.623]     }
[13:34:36.623]     {
[13:34:36.623]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.623]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.623]         do.call(mapply, args = args)
[13:34:36.623]     }
[13:34:36.623] }
[13:34:36.623] Lazy evaluation: FALSE
[13:34:36.623] Asynchronous evaluation: TRUE
[13:34:36.623] Local evaluation: TRUE
[13:34:36.623] Environment: R_GlobalEnv
[13:34:36.623] Capture standard output: TRUE
[13:34:36.623] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.623] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.623] Packages: <none>
[13:34:36.623] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.623] Resolved: TRUE
[13:34:36.623] Value: <not collected>
[13:34:36.623] Conditions captured: <none>
[13:34:36.623] Early signaling: FALSE
[13:34:36.623] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.623] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.632] Chunk #2 of 2 ... DONE
[13:34:36.632] Launching 2 futures (chunks) ... DONE
[13:34:36.632] Resolving 2 futures (chunks) ...
[13:34:36.633] resolve() on list ...
[13:34:36.633]  recursive: 0
[13:34:36.633]  length: 2
[13:34:36.633] 
[13:34:36.633] Future #1
[13:34:36.634] result() for MulticoreFuture ...
[13:34:36.635] result() for MulticoreFuture ...
[13:34:36.635] result() for MulticoreFuture ... done
[13:34:36.635] result() for MulticoreFuture ... done
[13:34:36.635] result() for MulticoreFuture ...
[13:34:36.635] result() for MulticoreFuture ... done
[13:34:36.636] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:36.636] - nx: 2
[13:34:36.636] - relay: TRUE
[13:34:36.636] - stdout: TRUE
[13:34:36.637] - signal: TRUE
[13:34:36.637] - resignal: FALSE
[13:34:36.637] - force: TRUE
[13:34:36.637] - relayed: [n=2] FALSE, FALSE
[13:34:36.637] - queued futures: [n=2] FALSE, FALSE
[13:34:36.638]  - until=1
[13:34:36.638]  - relaying element #1
[13:34:36.638] result() for MulticoreFuture ...
[13:34:36.638] result() for MulticoreFuture ... done
[13:34:36.638] result() for MulticoreFuture ...
[13:34:36.639] result() for MulticoreFuture ... done
[13:34:36.639] result() for MulticoreFuture ...
[13:34:36.639] result() for MulticoreFuture ... done
[13:34:36.639] result() for MulticoreFuture ...
[13:34:36.639] result() for MulticoreFuture ... done
[13:34:36.639] - relayed: [n=2] TRUE, FALSE
[13:34:36.640] - queued futures: [n=2] TRUE, FALSE
[13:34:36.640] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:36.640]  length: 1 (resolved future 1)
[13:34:36.640] Future #2
[13:34:36.641] result() for MulticoreFuture ...
[13:34:36.641] result() for MulticoreFuture ...
[13:34:36.641] result() for MulticoreFuture ... done
[13:34:36.642] result() for MulticoreFuture ... done
[13:34:36.642] result() for MulticoreFuture ...
[13:34:36.642] result() for MulticoreFuture ... done
[13:34:36.642] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:36.642] - nx: 2
[13:34:36.642] - relay: TRUE
[13:34:36.643] - stdout: TRUE
[13:34:36.643] - signal: TRUE
[13:34:36.643] - resignal: FALSE
[13:34:36.646] - force: TRUE
[13:34:36.646] - relayed: [n=2] TRUE, FALSE
[13:34:36.647] - queued futures: [n=2] TRUE, FALSE
[13:34:36.647]  - until=2
[13:34:36.647]  - relaying element #2
[13:34:36.647] result() for MulticoreFuture ...
[13:34:36.647] result() for MulticoreFuture ... done
[13:34:36.647] result() for MulticoreFuture ...
[13:34:36.648] result() for MulticoreFuture ... done
[13:34:36.648] result() for MulticoreFuture ...
[13:34:36.648] result() for MulticoreFuture ... done
[13:34:36.648] result() for MulticoreFuture ...
[13:34:36.648] result() for MulticoreFuture ... done
[13:34:36.648] - relayed: [n=2] TRUE, TRUE
[13:34:36.649] - queued futures: [n=2] TRUE, TRUE
[13:34:36.649] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:36.649]  length: 0 (resolved future 2)
[13:34:36.649] Relaying remaining futures
[13:34:36.649] signalConditionsASAP(NULL, pos=0) ...
[13:34:36.649] - nx: 2
[13:34:36.649] - relay: TRUE
[13:34:36.650] - stdout: TRUE
[13:34:36.650] - signal: TRUE
[13:34:36.650] - resignal: FALSE
[13:34:36.650] - force: TRUE
[13:34:36.650] - relayed: [n=2] TRUE, TRUE
[13:34:36.650] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:36.651] - relayed: [n=2] TRUE, TRUE
[13:34:36.651] - queued futures: [n=2] TRUE, TRUE
[13:34:36.651] signalConditionsASAP(NULL, pos=0) ... done
[13:34:36.651] resolve() on list ... DONE
[13:34:36.651] result() for MulticoreFuture ...
[13:34:36.651] result() for MulticoreFuture ... done
[13:34:36.651] result() for MulticoreFuture ...
[13:34:36.651] result() for MulticoreFuture ... done
[13:34:36.652] result() for MulticoreFuture ...
[13:34:36.652] result() for MulticoreFuture ... done
[13:34:36.652] result() for MulticoreFuture ...
[13:34:36.652] result() for MulticoreFuture ... done
[13:34:36.652]  - Number of value chunks collected: 2
[13:34:36.652] Resolving 2 futures (chunks) ... DONE
[13:34:36.653] Reducing values from 2 chunks ...
[13:34:36.653]  - Number of values collected after concatenation: 2
[13:34:36.653]  - Number of values expected: 2
[13:34:36.653] Reducing values from 2 chunks ... DONE
[13:34:36.653] future_mapply() ... DONE
[13:34:36.653] future_mapply() ...
[13:34:36.654] Generating random seeds ...
[13:34:36.654] Generating random seed streams for 2 elements ...
[13:34:36.654] Generating random seed streams for 2 elements ... DONE
[13:34:36.654] Generating random seeds ... DONE
[13:34:36.654] Will set RNG state on exit: 10407, -1942091459, 78618118, -932647314, 1218846117, -1798020483, 1965014997
[13:34:36.658] Number of chunks: 2
[13:34:36.658] getGlobalsAndPackagesXApply() ...
[13:34:36.658]  - future.globals: TRUE
[13:34:36.659] getGlobalsAndPackages() ...
[13:34:36.659] Searching for globals...
[13:34:36.660] - globals found: [1] ‘FUN’
[13:34:36.660] Searching for globals ... DONE
[13:34:36.660] Resolving globals: FALSE
[13:34:36.661] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[13:34:36.661] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[13:34:36.661] - globals: [1] ‘FUN’
[13:34:36.661] 
[13:34:36.661] getGlobalsAndPackages() ... DONE
[13:34:36.662]  - globals found/used: [n=1] ‘FUN’
[13:34:36.662]  - needed namespaces: [n=0] 
[13:34:36.662] Finding globals ... DONE
[13:34:36.662] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:36.662] List of 2
[13:34:36.662]  $ ...future.FUN:function (x, y)  
[13:34:36.662]  $ MoreArgs     :List of 1
[13:34:36.662]   ..$ y: int [1:2] 3 4
[13:34:36.662]  - attr(*, "where")=List of 2
[13:34:36.662]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:36.662]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:36.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.662]  - attr(*, "resolved")= logi FALSE
[13:34:36.662]  - attr(*, "total_size")= num NA
[13:34:36.665] Packages to be attached in all futures: [n=0] 
[13:34:36.665] getGlobalsAndPackagesXApply() ... DONE
[13:34:36.666] Number of futures (= number of chunks): 2
[13:34:36.666] Launching 2 futures (chunks) ...
[13:34:36.666] Chunk #1 of 2 ...
[13:34:36.666]  - Finding globals in '...' for chunk #1 ...
[13:34:36.666] getGlobalsAndPackages() ...
[13:34:36.666] Searching for globals...
[13:34:36.666] 
[13:34:36.667] Searching for globals ... DONE
[13:34:36.667] - globals: [0] <none>
[13:34:36.667] getGlobalsAndPackages() ... DONE
[13:34:36.667]    + additional globals found: [n=0] 
[13:34:36.667]    + additional namespaces needed: [n=0] 
[13:34:36.667]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:36.667]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.667]  - seeds: [1] <seeds>
[13:34:36.667]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.667] getGlobalsAndPackages() ...
[13:34:36.668] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.668] Resolving globals: FALSE
[13:34:36.668] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[13:34:36.669] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[13:34:36.669] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.669] 
[13:34:36.669] getGlobalsAndPackages() ... DONE
[13:34:36.669] run() for ‘Future’ ...
[13:34:36.669] - state: ‘created’
[13:34:36.670] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.673] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.676]   - Field: ‘label’
[13:34:36.676]   - Field: ‘local’
[13:34:36.676]   - Field: ‘owner’
[13:34:36.676]   - Field: ‘envir’
[13:34:36.676]   - Field: ‘workers’
[13:34:36.676]   - Field: ‘packages’
[13:34:36.677]   - Field: ‘gc’
[13:34:36.677]   - Field: ‘job’
[13:34:36.677]   - Field: ‘conditions’
[13:34:36.677]   - Field: ‘expr’
[13:34:36.677]   - Field: ‘uuid’
[13:34:36.677]   - Field: ‘seed’
[13:34:36.677]   - Field: ‘version’
[13:34:36.677]   - Field: ‘result’
[13:34:36.677]   - Field: ‘asynchronous’
[13:34:36.677]   - Field: ‘calls’
[13:34:36.678]   - Field: ‘globals’
[13:34:36.678]   - Field: ‘stdout’
[13:34:36.678]   - Field: ‘earlySignal’
[13:34:36.678]   - Field: ‘lazy’
[13:34:36.678]   - Field: ‘state’
[13:34:36.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.678] - Launch lazy future ...
[13:34:36.678] Packages needed by the future expression (n = 0): <none>
[13:34:36.679] Packages needed by future strategies (n = 0): <none>
[13:34:36.679] {
[13:34:36.679]     {
[13:34:36.679]         {
[13:34:36.679]             ...future.startTime <- base::Sys.time()
[13:34:36.679]             {
[13:34:36.679]                 {
[13:34:36.679]                   {
[13:34:36.679]                     {
[13:34:36.679]                       base::local({
[13:34:36.679]                         has_future <- base::requireNamespace("future", 
[13:34:36.679]                           quietly = TRUE)
[13:34:36.679]                         if (has_future) {
[13:34:36.679]                           ns <- base::getNamespace("future")
[13:34:36.679]                           version <- ns[[".package"]][["version"]]
[13:34:36.679]                           if (is.null(version)) 
[13:34:36.679]                             version <- utils::packageVersion("future")
[13:34:36.679]                         }
[13:34:36.679]                         else {
[13:34:36.679]                           version <- NULL
[13:34:36.679]                         }
[13:34:36.679]                         if (!has_future || version < "1.8.0") {
[13:34:36.679]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.679]                             "", base::R.version$version.string), 
[13:34:36.679]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.679]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.679]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.679]                               "release", "version")], collapse = " "), 
[13:34:36.679]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.679]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.679]                             info)
[13:34:36.679]                           info <- base::paste(info, collapse = "; ")
[13:34:36.679]                           if (!has_future) {
[13:34:36.679]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.679]                               info)
[13:34:36.679]                           }
[13:34:36.679]                           else {
[13:34:36.679]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.679]                               info, version)
[13:34:36.679]                           }
[13:34:36.679]                           base::stop(msg)
[13:34:36.679]                         }
[13:34:36.679]                       })
[13:34:36.679]                     }
[13:34:36.679]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.679]                     base::options(mc.cores = 1L)
[13:34:36.679]                   }
[13:34:36.679]                   ...future.strategy.old <- future::plan("list")
[13:34:36.679]                   options(future.plan = NULL)
[13:34:36.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.679]                 }
[13:34:36.679]                 ...future.workdir <- getwd()
[13:34:36.679]             }
[13:34:36.679]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.679]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.679]         }
[13:34:36.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.679]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.679]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.679]             base::names(...future.oldOptions))
[13:34:36.679]     }
[13:34:36.679]     if (FALSE) {
[13:34:36.679]     }
[13:34:36.679]     else {
[13:34:36.679]         if (TRUE) {
[13:34:36.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.679]                 open = "w")
[13:34:36.679]         }
[13:34:36.679]         else {
[13:34:36.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.679]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.679]         }
[13:34:36.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.679]             base::sink(type = "output", split = FALSE)
[13:34:36.679]             base::close(...future.stdout)
[13:34:36.679]         }, add = TRUE)
[13:34:36.679]     }
[13:34:36.679]     ...future.frame <- base::sys.nframe()
[13:34:36.679]     ...future.conditions <- base::list()
[13:34:36.679]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.679]     if (FALSE) {
[13:34:36.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.679]     }
[13:34:36.679]     ...future.result <- base::tryCatch({
[13:34:36.679]         base::withCallingHandlers({
[13:34:36.679]             ...future.value <- base::withVisible(base::local({
[13:34:36.679]                 withCallingHandlers({
[13:34:36.679]                   {
[13:34:36.679]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.679]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.679]                       ...future.globals.maxSize)) {
[13:34:36.679]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.679]                       on.exit(options(oopts), add = TRUE)
[13:34:36.679]                     }
[13:34:36.679]                     {
[13:34:36.679]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:36.679]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[13:34:36.679]                           envir = globalenv(), inherits = FALSE)
[13:34:36.679]                         ...future.FUN(...)
[13:34:36.679]                       }
[13:34:36.679]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:36.679]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:36.679]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.679]                         USE.NAMES = FALSE)
[13:34:36.679]                       do.call(mapply, args = args)
[13:34:36.679]                     }
[13:34:36.679]                   }
[13:34:36.679]                 }, immediateCondition = function(cond) {
[13:34:36.679]                   save_rds <- function (object, pathname, ...) 
[13:34:36.679]                   {
[13:34:36.679]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.679]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.679]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.679]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.679]                         fi_tmp[["mtime"]])
[13:34:36.679]                     }
[13:34:36.679]                     tryCatch({
[13:34:36.679]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.679]                     }, error = function(ex) {
[13:34:36.679]                       msg <- conditionMessage(ex)
[13:34:36.679]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.679]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.679]                         fi_tmp[["mtime"]], msg)
[13:34:36.679]                       ex$message <- msg
[13:34:36.679]                       stop(ex)
[13:34:36.679]                     })
[13:34:36.679]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.679]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.679]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.679]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.679]                       fi <- file.info(pathname)
[13:34:36.679]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.679]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.679]                         fi[["size"]], fi[["mtime"]])
[13:34:36.679]                       stop(msg)
[13:34:36.679]                     }
[13:34:36.679]                     invisible(pathname)
[13:34:36.679]                   }
[13:34:36.679]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.679]                     rootPath = tempdir()) 
[13:34:36.679]                   {
[13:34:36.679]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.679]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.679]                       tmpdir = path, fileext = ".rds")
[13:34:36.679]                     save_rds(obj, file)
[13:34:36.679]                   }
[13:34:36.679]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.679]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.679]                   {
[13:34:36.679]                     inherits <- base::inherits
[13:34:36.679]                     invokeRestart <- base::invokeRestart
[13:34:36.679]                     is.null <- base::is.null
[13:34:36.679]                     muffled <- FALSE
[13:34:36.679]                     if (inherits(cond, "message")) {
[13:34:36.679]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.679]                       if (muffled) 
[13:34:36.679]                         invokeRestart("muffleMessage")
[13:34:36.679]                     }
[13:34:36.679]                     else if (inherits(cond, "warning")) {
[13:34:36.679]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.679]                       if (muffled) 
[13:34:36.679]                         invokeRestart("muffleWarning")
[13:34:36.679]                     }
[13:34:36.679]                     else if (inherits(cond, "condition")) {
[13:34:36.679]                       if (!is.null(pattern)) {
[13:34:36.679]                         computeRestarts <- base::computeRestarts
[13:34:36.679]                         grepl <- base::grepl
[13:34:36.679]                         restarts <- computeRestarts(cond)
[13:34:36.679]                         for (restart in restarts) {
[13:34:36.679]                           name <- restart$name
[13:34:36.679]                           if (is.null(name)) 
[13:34:36.679]                             next
[13:34:36.679]                           if (!grepl(pattern, name)) 
[13:34:36.679]                             next
[13:34:36.679]                           invokeRestart(restart)
[13:34:36.679]                           muffled <- TRUE
[13:34:36.679]                           break
[13:34:36.679]                         }
[13:34:36.679]                       }
[13:34:36.679]                     }
[13:34:36.679]                     invisible(muffled)
[13:34:36.679]                   }
[13:34:36.679]                   muffleCondition(cond)
[13:34:36.679]                 })
[13:34:36.679]             }))
[13:34:36.679]             future::FutureResult(value = ...future.value$value, 
[13:34:36.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.679]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.679]                     ...future.globalenv.names))
[13:34:36.679]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.679]         }, condition = base::local({
[13:34:36.679]             c <- base::c
[13:34:36.679]             inherits <- base::inherits
[13:34:36.679]             invokeRestart <- base::invokeRestart
[13:34:36.679]             length <- base::length
[13:34:36.679]             list <- base::list
[13:34:36.679]             seq.int <- base::seq.int
[13:34:36.679]             signalCondition <- base::signalCondition
[13:34:36.679]             sys.calls <- base::sys.calls
[13:34:36.679]             `[[` <- base::`[[`
[13:34:36.679]             `+` <- base::`+`
[13:34:36.679]             `<<-` <- base::`<<-`
[13:34:36.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.679]                   3L)]
[13:34:36.679]             }
[13:34:36.679]             function(cond) {
[13:34:36.679]                 is_error <- inherits(cond, "error")
[13:34:36.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.679]                   NULL)
[13:34:36.679]                 if (is_error) {
[13:34:36.679]                   sessionInformation <- function() {
[13:34:36.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.679]                       search = base::search(), system = base::Sys.info())
[13:34:36.679]                   }
[13:34:36.679]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.679]                     cond$call), session = sessionInformation(), 
[13:34:36.679]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.679]                   signalCondition(cond)
[13:34:36.679]                 }
[13:34:36.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.679]                 "immediateCondition"))) {
[13:34:36.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.679]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.679]                   if (TRUE && !signal) {
[13:34:36.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.679]                     {
[13:34:36.679]                       inherits <- base::inherits
[13:34:36.679]                       invokeRestart <- base::invokeRestart
[13:34:36.679]                       is.null <- base::is.null
[13:34:36.679]                       muffled <- FALSE
[13:34:36.679]                       if (inherits(cond, "message")) {
[13:34:36.679]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.679]                         if (muffled) 
[13:34:36.679]                           invokeRestart("muffleMessage")
[13:34:36.679]                       }
[13:34:36.679]                       else if (inherits(cond, "warning")) {
[13:34:36.679]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.679]                         if (muffled) 
[13:34:36.679]                           invokeRestart("muffleWarning")
[13:34:36.679]                       }
[13:34:36.679]                       else if (inherits(cond, "condition")) {
[13:34:36.679]                         if (!is.null(pattern)) {
[13:34:36.679]                           computeRestarts <- base::computeRestarts
[13:34:36.679]                           grepl <- base::grepl
[13:34:36.679]                           restarts <- computeRestarts(cond)
[13:34:36.679]                           for (restart in restarts) {
[13:34:36.679]                             name <- restart$name
[13:34:36.679]                             if (is.null(name)) 
[13:34:36.679]                               next
[13:34:36.679]                             if (!grepl(pattern, name)) 
[13:34:36.679]                               next
[13:34:36.679]                             invokeRestart(restart)
[13:34:36.679]                             muffled <- TRUE
[13:34:36.679]                             break
[13:34:36.679]                           }
[13:34:36.679]                         }
[13:34:36.679]                       }
[13:34:36.679]                       invisible(muffled)
[13:34:36.679]                     }
[13:34:36.679]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.679]                   }
[13:34:36.679]                 }
[13:34:36.679]                 else {
[13:34:36.679]                   if (TRUE) {
[13:34:36.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.679]                     {
[13:34:36.679]                       inherits <- base::inherits
[13:34:36.679]                       invokeRestart <- base::invokeRestart
[13:34:36.679]                       is.null <- base::is.null
[13:34:36.679]                       muffled <- FALSE
[13:34:36.679]                       if (inherits(cond, "message")) {
[13:34:36.679]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.679]                         if (muffled) 
[13:34:36.679]                           invokeRestart("muffleMessage")
[13:34:36.679]                       }
[13:34:36.679]                       else if (inherits(cond, "warning")) {
[13:34:36.679]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.679]                         if (muffled) 
[13:34:36.679]                           invokeRestart("muffleWarning")
[13:34:36.679]                       }
[13:34:36.679]                       else if (inherits(cond, "condition")) {
[13:34:36.679]                         if (!is.null(pattern)) {
[13:34:36.679]                           computeRestarts <- base::computeRestarts
[13:34:36.679]                           grepl <- base::grepl
[13:34:36.679]                           restarts <- computeRestarts(cond)
[13:34:36.679]                           for (restart in restarts) {
[13:34:36.679]                             name <- restart$name
[13:34:36.679]                             if (is.null(name)) 
[13:34:36.679]                               next
[13:34:36.679]                             if (!grepl(pattern, name)) 
[13:34:36.679]                               next
[13:34:36.679]                             invokeRestart(restart)
[13:34:36.679]                             muffled <- TRUE
[13:34:36.679]                             break
[13:34:36.679]                           }
[13:34:36.679]                         }
[13:34:36.679]                       }
[13:34:36.679]                       invisible(muffled)
[13:34:36.679]                     }
[13:34:36.679]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.679]                   }
[13:34:36.679]                 }
[13:34:36.679]             }
[13:34:36.679]         }))
[13:34:36.679]     }, error = function(ex) {
[13:34:36.679]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.679]                 ...future.rng), started = ...future.startTime, 
[13:34:36.679]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.679]             version = "1.8"), class = "FutureResult")
[13:34:36.679]     }, finally = {
[13:34:36.679]         if (!identical(...future.workdir, getwd())) 
[13:34:36.679]             setwd(...future.workdir)
[13:34:36.679]         {
[13:34:36.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.679]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.679]             }
[13:34:36.679]             base::options(...future.oldOptions)
[13:34:36.679]             if (.Platform$OS.type == "windows") {
[13:34:36.679]                 old_names <- names(...future.oldEnvVars)
[13:34:36.679]                 envs <- base::Sys.getenv()
[13:34:36.679]                 names <- names(envs)
[13:34:36.679]                 common <- intersect(names, old_names)
[13:34:36.679]                 added <- setdiff(names, old_names)
[13:34:36.679]                 removed <- setdiff(old_names, names)
[13:34:36.679]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.679]                   envs[common]]
[13:34:36.679]                 NAMES <- toupper(changed)
[13:34:36.679]                 args <- list()
[13:34:36.679]                 for (kk in seq_along(NAMES)) {
[13:34:36.679]                   name <- changed[[kk]]
[13:34:36.679]                   NAME <- NAMES[[kk]]
[13:34:36.679]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.679]                     next
[13:34:36.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.679]                 }
[13:34:36.679]                 NAMES <- toupper(added)
[13:34:36.679]                 for (kk in seq_along(NAMES)) {
[13:34:36.679]                   name <- added[[kk]]
[13:34:36.679]                   NAME <- NAMES[[kk]]
[13:34:36.679]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.679]                     next
[13:34:36.679]                   args[[name]] <- ""
[13:34:36.679]                 }
[13:34:36.679]                 NAMES <- toupper(removed)
[13:34:36.679]                 for (kk in seq_along(NAMES)) {
[13:34:36.679]                   name <- removed[[kk]]
[13:34:36.679]                   NAME <- NAMES[[kk]]
[13:34:36.679]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.679]                     next
[13:34:36.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.679]                 }
[13:34:36.679]                 if (length(args) > 0) 
[13:34:36.679]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.679]             }
[13:34:36.679]             else {
[13:34:36.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.679]             }
[13:34:36.679]             {
[13:34:36.679]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.679]                   0L) {
[13:34:36.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.679]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.679]                   base::options(opts)
[13:34:36.679]                 }
[13:34:36.679]                 {
[13:34:36.679]                   {
[13:34:36.679]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.679]                     NULL
[13:34:36.679]                   }
[13:34:36.679]                   options(future.plan = NULL)
[13:34:36.679]                   if (is.na(NA_character_)) 
[13:34:36.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.679]                     .init = FALSE)
[13:34:36.679]                 }
[13:34:36.679]             }
[13:34:36.679]         }
[13:34:36.679]     })
[13:34:36.679]     if (TRUE) {
[13:34:36.679]         base::sink(type = "output", split = FALSE)
[13:34:36.679]         if (TRUE) {
[13:34:36.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.679]         }
[13:34:36.679]         else {
[13:34:36.679]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.679]         }
[13:34:36.679]         base::close(...future.stdout)
[13:34:36.679]         ...future.stdout <- NULL
[13:34:36.679]     }
[13:34:36.679]     ...future.result$conditions <- ...future.conditions
[13:34:36.679]     ...future.result$finished <- base::Sys.time()
[13:34:36.679]     ...future.result
[13:34:36.679] }
[13:34:36.681] assign_globals() ...
[13:34:36.682] List of 5
[13:34:36.682]  $ ...future.FUN            :function (x, y)  
[13:34:36.682]  $ MoreArgs                 :List of 1
[13:34:36.682]   ..$ y: int [1:2] 3 4
[13:34:36.682]  $ ...future.elements_ii    :List of 1
[13:34:36.682]   ..$ x:List of 1
[13:34:36.682]   .. ..$ : int 1
[13:34:36.682]  $ ...future.seeds_ii       :List of 1
[13:34:36.682]   ..$ : int [1:7] 10407 1327609295 -1608865290 -674997933 -1111932150 -1044475649 1942502516
[13:34:36.682]  $ ...future.globals.maxSize: NULL
[13:34:36.682]  - attr(*, "where")=List of 5
[13:34:36.682]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.682]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.682]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.682]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.682]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.682]  - attr(*, "resolved")= logi FALSE
[13:34:36.682]  - attr(*, "total_size")= num 1896
[13:34:36.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.682]  - attr(*, "already-done")= logi TRUE
[13:34:36.687] - reassign environment for ‘...future.FUN’
[13:34:36.687] - copied ‘...future.FUN’ to environment
[13:34:36.687] - copied ‘MoreArgs’ to environment
[13:34:36.687] - copied ‘...future.elements_ii’ to environment
[13:34:36.688] - copied ‘...future.seeds_ii’ to environment
[13:34:36.688] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.688] assign_globals() ... done
[13:34:36.688] requestCore(): workers = 2
[13:34:36.690] MulticoreFuture started
[13:34:36.690] - Launch lazy future ... done
[13:34:36.691] run() for ‘MulticoreFuture’ ... done
[13:34:36.691] Created future:
[13:34:36.691] plan(): Setting new future strategy stack:
[13:34:36.691] List of future strategies:
[13:34:36.691] 1. sequential:
[13:34:36.691]    - args: function (..., envir = parent.frame())
[13:34:36.691]    - tweaked: FALSE
[13:34:36.691]    - call: NULL
[13:34:36.692] plan(): nbrOfWorkers() = 1
[13:34:36.694] plan(): Setting new future strategy stack:
[13:34:36.694] List of future strategies:
[13:34:36.694] 1. multicore:
[13:34:36.694]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.694]    - tweaked: FALSE
[13:34:36.694]    - call: plan(strategy)
[13:34:36.700] plan(): nbrOfWorkers() = 2
[13:34:36.691] MulticoreFuture:
[13:34:36.691] Label: ‘future_mapply-1’
[13:34:36.691] Expression:
[13:34:36.691] {
[13:34:36.691]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.691]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.691]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.691]         on.exit(options(oopts), add = TRUE)
[13:34:36.691]     }
[13:34:36.691]     {
[13:34:36.691]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:36.691]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[13:34:36.691]                 inherits = FALSE)
[13:34:36.691]             ...future.FUN(...)
[13:34:36.691]         }
[13:34:36.691]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:36.691]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:36.691]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.691]         do.call(mapply, args = args)
[13:34:36.691]     }
[13:34:36.691] }
[13:34:36.691] Lazy evaluation: FALSE
[13:34:36.691] Asynchronous evaluation: TRUE
[13:34:36.691] Local evaluation: TRUE
[13:34:36.691] Environment: R_GlobalEnv
[13:34:36.691] Capture standard output: TRUE
[13:34:36.691] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.691] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.691] Packages: <none>
[13:34:36.691] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:34:36.691] Resolved: TRUE
[13:34:36.691] Value: <not collected>
[13:34:36.691] Conditions captured: <none>
[13:34:36.691] Early signaling: FALSE
[13:34:36.691] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.691] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.701] Chunk #1 of 2 ... DONE
[13:34:36.701] Chunk #2 of 2 ...
[13:34:36.701]  - Finding globals in '...' for chunk #2 ...
[13:34:36.701] getGlobalsAndPackages() ...
[13:34:36.702] Searching for globals...
[13:34:36.702] 
[13:34:36.702] Searching for globals ... DONE
[13:34:36.702] - globals: [0] <none>
[13:34:36.702] getGlobalsAndPackages() ... DONE
[13:34:36.703]    + additional globals found: [n=0] 
[13:34:36.703]    + additional namespaces needed: [n=0] 
[13:34:36.703]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:36.703]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.703]  - seeds: [1] <seeds>
[13:34:36.703]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.704] getGlobalsAndPackages() ...
[13:34:36.704] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.704] Resolving globals: FALSE
[13:34:36.705] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[13:34:36.706] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[13:34:36.706] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.706] 
[13:34:36.706] getGlobalsAndPackages() ... DONE
[13:34:36.707] run() for ‘Future’ ...
[13:34:36.707] - state: ‘created’
[13:34:36.707] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.712] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.712] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.712]   - Field: ‘label’
[13:34:36.713]   - Field: ‘local’
[13:34:36.713]   - Field: ‘owner’
[13:34:36.713]   - Field: ‘envir’
[13:34:36.713]   - Field: ‘workers’
[13:34:36.713]   - Field: ‘packages’
[13:34:36.713]   - Field: ‘gc’
[13:34:36.713]   - Field: ‘job’
[13:34:36.714]   - Field: ‘conditions’
[13:34:36.714]   - Field: ‘expr’
[13:34:36.714]   - Field: ‘uuid’
[13:34:36.718]   - Field: ‘seed’
[13:34:36.718]   - Field: ‘version’
[13:34:36.719]   - Field: ‘result’
[13:34:36.719]   - Field: ‘asynchronous’
[13:34:36.720]   - Field: ‘calls’
[13:34:36.720]   - Field: ‘globals’
[13:34:36.720]   - Field: ‘stdout’
[13:34:36.720]   - Field: ‘earlySignal’
[13:34:36.721]   - Field: ‘lazy’
[13:34:36.721]   - Field: ‘state’
[13:34:36.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.722] - Launch lazy future ...
[13:34:36.723] Packages needed by the future expression (n = 0): <none>
[13:34:36.723] Packages needed by future strategies (n = 0): <none>
[13:34:36.724] {
[13:34:36.724]     {
[13:34:36.724]         {
[13:34:36.724]             ...future.startTime <- base::Sys.time()
[13:34:36.724]             {
[13:34:36.724]                 {
[13:34:36.724]                   {
[13:34:36.724]                     {
[13:34:36.724]                       base::local({
[13:34:36.724]                         has_future <- base::requireNamespace("future", 
[13:34:36.724]                           quietly = TRUE)
[13:34:36.724]                         if (has_future) {
[13:34:36.724]                           ns <- base::getNamespace("future")
[13:34:36.724]                           version <- ns[[".package"]][["version"]]
[13:34:36.724]                           if (is.null(version)) 
[13:34:36.724]                             version <- utils::packageVersion("future")
[13:34:36.724]                         }
[13:34:36.724]                         else {
[13:34:36.724]                           version <- NULL
[13:34:36.724]                         }
[13:34:36.724]                         if (!has_future || version < "1.8.0") {
[13:34:36.724]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.724]                             "", base::R.version$version.string), 
[13:34:36.724]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.724]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.724]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.724]                               "release", "version")], collapse = " "), 
[13:34:36.724]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.724]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.724]                             info)
[13:34:36.724]                           info <- base::paste(info, collapse = "; ")
[13:34:36.724]                           if (!has_future) {
[13:34:36.724]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.724]                               info)
[13:34:36.724]                           }
[13:34:36.724]                           else {
[13:34:36.724]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.724]                               info, version)
[13:34:36.724]                           }
[13:34:36.724]                           base::stop(msg)
[13:34:36.724]                         }
[13:34:36.724]                       })
[13:34:36.724]                     }
[13:34:36.724]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.724]                     base::options(mc.cores = 1L)
[13:34:36.724]                   }
[13:34:36.724]                   ...future.strategy.old <- future::plan("list")
[13:34:36.724]                   options(future.plan = NULL)
[13:34:36.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.724]                 }
[13:34:36.724]                 ...future.workdir <- getwd()
[13:34:36.724]             }
[13:34:36.724]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.724]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.724]         }
[13:34:36.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.724]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.724]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.724]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.724]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.724]             base::names(...future.oldOptions))
[13:34:36.724]     }
[13:34:36.724]     if (FALSE) {
[13:34:36.724]     }
[13:34:36.724]     else {
[13:34:36.724]         if (TRUE) {
[13:34:36.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.724]                 open = "w")
[13:34:36.724]         }
[13:34:36.724]         else {
[13:34:36.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.724]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.724]         }
[13:34:36.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.724]             base::sink(type = "output", split = FALSE)
[13:34:36.724]             base::close(...future.stdout)
[13:34:36.724]         }, add = TRUE)
[13:34:36.724]     }
[13:34:36.724]     ...future.frame <- base::sys.nframe()
[13:34:36.724]     ...future.conditions <- base::list()
[13:34:36.724]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.724]     if (FALSE) {
[13:34:36.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.724]     }
[13:34:36.724]     ...future.result <- base::tryCatch({
[13:34:36.724]         base::withCallingHandlers({
[13:34:36.724]             ...future.value <- base::withVisible(base::local({
[13:34:36.724]                 withCallingHandlers({
[13:34:36.724]                   {
[13:34:36.724]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.724]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.724]                       ...future.globals.maxSize)) {
[13:34:36.724]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.724]                       on.exit(options(oopts), add = TRUE)
[13:34:36.724]                     }
[13:34:36.724]                     {
[13:34:36.724]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:36.724]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[13:34:36.724]                           envir = globalenv(), inherits = FALSE)
[13:34:36.724]                         ...future.FUN(...)
[13:34:36.724]                       }
[13:34:36.724]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:36.724]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:36.724]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.724]                         USE.NAMES = FALSE)
[13:34:36.724]                       do.call(mapply, args = args)
[13:34:36.724]                     }
[13:34:36.724]                   }
[13:34:36.724]                 }, immediateCondition = function(cond) {
[13:34:36.724]                   save_rds <- function (object, pathname, ...) 
[13:34:36.724]                   {
[13:34:36.724]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.724]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.724]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.724]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.724]                         fi_tmp[["mtime"]])
[13:34:36.724]                     }
[13:34:36.724]                     tryCatch({
[13:34:36.724]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.724]                     }, error = function(ex) {
[13:34:36.724]                       msg <- conditionMessage(ex)
[13:34:36.724]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.724]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.724]                         fi_tmp[["mtime"]], msg)
[13:34:36.724]                       ex$message <- msg
[13:34:36.724]                       stop(ex)
[13:34:36.724]                     })
[13:34:36.724]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.724]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.724]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.724]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.724]                       fi <- file.info(pathname)
[13:34:36.724]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.724]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.724]                         fi[["size"]], fi[["mtime"]])
[13:34:36.724]                       stop(msg)
[13:34:36.724]                     }
[13:34:36.724]                     invisible(pathname)
[13:34:36.724]                   }
[13:34:36.724]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.724]                     rootPath = tempdir()) 
[13:34:36.724]                   {
[13:34:36.724]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.724]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.724]                       tmpdir = path, fileext = ".rds")
[13:34:36.724]                     save_rds(obj, file)
[13:34:36.724]                   }
[13:34:36.724]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.724]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.724]                   {
[13:34:36.724]                     inherits <- base::inherits
[13:34:36.724]                     invokeRestart <- base::invokeRestart
[13:34:36.724]                     is.null <- base::is.null
[13:34:36.724]                     muffled <- FALSE
[13:34:36.724]                     if (inherits(cond, "message")) {
[13:34:36.724]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.724]                       if (muffled) 
[13:34:36.724]                         invokeRestart("muffleMessage")
[13:34:36.724]                     }
[13:34:36.724]                     else if (inherits(cond, "warning")) {
[13:34:36.724]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.724]                       if (muffled) 
[13:34:36.724]                         invokeRestart("muffleWarning")
[13:34:36.724]                     }
[13:34:36.724]                     else if (inherits(cond, "condition")) {
[13:34:36.724]                       if (!is.null(pattern)) {
[13:34:36.724]                         computeRestarts <- base::computeRestarts
[13:34:36.724]                         grepl <- base::grepl
[13:34:36.724]                         restarts <- computeRestarts(cond)
[13:34:36.724]                         for (restart in restarts) {
[13:34:36.724]                           name <- restart$name
[13:34:36.724]                           if (is.null(name)) 
[13:34:36.724]                             next
[13:34:36.724]                           if (!grepl(pattern, name)) 
[13:34:36.724]                             next
[13:34:36.724]                           invokeRestart(restart)
[13:34:36.724]                           muffled <- TRUE
[13:34:36.724]                           break
[13:34:36.724]                         }
[13:34:36.724]                       }
[13:34:36.724]                     }
[13:34:36.724]                     invisible(muffled)
[13:34:36.724]                   }
[13:34:36.724]                   muffleCondition(cond)
[13:34:36.724]                 })
[13:34:36.724]             }))
[13:34:36.724]             future::FutureResult(value = ...future.value$value, 
[13:34:36.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.724]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.724]                     ...future.globalenv.names))
[13:34:36.724]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.724]         }, condition = base::local({
[13:34:36.724]             c <- base::c
[13:34:36.724]             inherits <- base::inherits
[13:34:36.724]             invokeRestart <- base::invokeRestart
[13:34:36.724]             length <- base::length
[13:34:36.724]             list <- base::list
[13:34:36.724]             seq.int <- base::seq.int
[13:34:36.724]             signalCondition <- base::signalCondition
[13:34:36.724]             sys.calls <- base::sys.calls
[13:34:36.724]             `[[` <- base::`[[`
[13:34:36.724]             `+` <- base::`+`
[13:34:36.724]             `<<-` <- base::`<<-`
[13:34:36.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.724]                   3L)]
[13:34:36.724]             }
[13:34:36.724]             function(cond) {
[13:34:36.724]                 is_error <- inherits(cond, "error")
[13:34:36.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.724]                   NULL)
[13:34:36.724]                 if (is_error) {
[13:34:36.724]                   sessionInformation <- function() {
[13:34:36.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.724]                       search = base::search(), system = base::Sys.info())
[13:34:36.724]                   }
[13:34:36.724]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.724]                     cond$call), session = sessionInformation(), 
[13:34:36.724]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.724]                   signalCondition(cond)
[13:34:36.724]                 }
[13:34:36.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.724]                 "immediateCondition"))) {
[13:34:36.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.724]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.724]                   if (TRUE && !signal) {
[13:34:36.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.724]                     {
[13:34:36.724]                       inherits <- base::inherits
[13:34:36.724]                       invokeRestart <- base::invokeRestart
[13:34:36.724]                       is.null <- base::is.null
[13:34:36.724]                       muffled <- FALSE
[13:34:36.724]                       if (inherits(cond, "message")) {
[13:34:36.724]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.724]                         if (muffled) 
[13:34:36.724]                           invokeRestart("muffleMessage")
[13:34:36.724]                       }
[13:34:36.724]                       else if (inherits(cond, "warning")) {
[13:34:36.724]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.724]                         if (muffled) 
[13:34:36.724]                           invokeRestart("muffleWarning")
[13:34:36.724]                       }
[13:34:36.724]                       else if (inherits(cond, "condition")) {
[13:34:36.724]                         if (!is.null(pattern)) {
[13:34:36.724]                           computeRestarts <- base::computeRestarts
[13:34:36.724]                           grepl <- base::grepl
[13:34:36.724]                           restarts <- computeRestarts(cond)
[13:34:36.724]                           for (restart in restarts) {
[13:34:36.724]                             name <- restart$name
[13:34:36.724]                             if (is.null(name)) 
[13:34:36.724]                               next
[13:34:36.724]                             if (!grepl(pattern, name)) 
[13:34:36.724]                               next
[13:34:36.724]                             invokeRestart(restart)
[13:34:36.724]                             muffled <- TRUE
[13:34:36.724]                             break
[13:34:36.724]                           }
[13:34:36.724]                         }
[13:34:36.724]                       }
[13:34:36.724]                       invisible(muffled)
[13:34:36.724]                     }
[13:34:36.724]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.724]                   }
[13:34:36.724]                 }
[13:34:36.724]                 else {
[13:34:36.724]                   if (TRUE) {
[13:34:36.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.724]                     {
[13:34:36.724]                       inherits <- base::inherits
[13:34:36.724]                       invokeRestart <- base::invokeRestart
[13:34:36.724]                       is.null <- base::is.null
[13:34:36.724]                       muffled <- FALSE
[13:34:36.724]                       if (inherits(cond, "message")) {
[13:34:36.724]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.724]                         if (muffled) 
[13:34:36.724]                           invokeRestart("muffleMessage")
[13:34:36.724]                       }
[13:34:36.724]                       else if (inherits(cond, "warning")) {
[13:34:36.724]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.724]                         if (muffled) 
[13:34:36.724]                           invokeRestart("muffleWarning")
[13:34:36.724]                       }
[13:34:36.724]                       else if (inherits(cond, "condition")) {
[13:34:36.724]                         if (!is.null(pattern)) {
[13:34:36.724]                           computeRestarts <- base::computeRestarts
[13:34:36.724]                           grepl <- base::grepl
[13:34:36.724]                           restarts <- computeRestarts(cond)
[13:34:36.724]                           for (restart in restarts) {
[13:34:36.724]                             name <- restart$name
[13:34:36.724]                             if (is.null(name)) 
[13:34:36.724]                               next
[13:34:36.724]                             if (!grepl(pattern, name)) 
[13:34:36.724]                               next
[13:34:36.724]                             invokeRestart(restart)
[13:34:36.724]                             muffled <- TRUE
[13:34:36.724]                             break
[13:34:36.724]                           }
[13:34:36.724]                         }
[13:34:36.724]                       }
[13:34:36.724]                       invisible(muffled)
[13:34:36.724]                     }
[13:34:36.724]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.724]                   }
[13:34:36.724]                 }
[13:34:36.724]             }
[13:34:36.724]         }))
[13:34:36.724]     }, error = function(ex) {
[13:34:36.724]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.724]                 ...future.rng), started = ...future.startTime, 
[13:34:36.724]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.724]             version = "1.8"), class = "FutureResult")
[13:34:36.724]     }, finally = {
[13:34:36.724]         if (!identical(...future.workdir, getwd())) 
[13:34:36.724]             setwd(...future.workdir)
[13:34:36.724]         {
[13:34:36.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.724]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.724]             }
[13:34:36.724]             base::options(...future.oldOptions)
[13:34:36.724]             if (.Platform$OS.type == "windows") {
[13:34:36.724]                 old_names <- names(...future.oldEnvVars)
[13:34:36.724]                 envs <- base::Sys.getenv()
[13:34:36.724]                 names <- names(envs)
[13:34:36.724]                 common <- intersect(names, old_names)
[13:34:36.724]                 added <- setdiff(names, old_names)
[13:34:36.724]                 removed <- setdiff(old_names, names)
[13:34:36.724]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.724]                   envs[common]]
[13:34:36.724]                 NAMES <- toupper(changed)
[13:34:36.724]                 args <- list()
[13:34:36.724]                 for (kk in seq_along(NAMES)) {
[13:34:36.724]                   name <- changed[[kk]]
[13:34:36.724]                   NAME <- NAMES[[kk]]
[13:34:36.724]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.724]                     next
[13:34:36.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.724]                 }
[13:34:36.724]                 NAMES <- toupper(added)
[13:34:36.724]                 for (kk in seq_along(NAMES)) {
[13:34:36.724]                   name <- added[[kk]]
[13:34:36.724]                   NAME <- NAMES[[kk]]
[13:34:36.724]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.724]                     next
[13:34:36.724]                   args[[name]] <- ""
[13:34:36.724]                 }
[13:34:36.724]                 NAMES <- toupper(removed)
[13:34:36.724]                 for (kk in seq_along(NAMES)) {
[13:34:36.724]                   name <- removed[[kk]]
[13:34:36.724]                   NAME <- NAMES[[kk]]
[13:34:36.724]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.724]                     next
[13:34:36.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.724]                 }
[13:34:36.724]                 if (length(args) > 0) 
[13:34:36.724]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.724]             }
[13:34:36.724]             else {
[13:34:36.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.724]             }
[13:34:36.724]             {
[13:34:36.724]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.724]                   0L) {
[13:34:36.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.724]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.724]                   base::options(opts)
[13:34:36.724]                 }
[13:34:36.724]                 {
[13:34:36.724]                   {
[13:34:36.724]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.724]                     NULL
[13:34:36.724]                   }
[13:34:36.724]                   options(future.plan = NULL)
[13:34:36.724]                   if (is.na(NA_character_)) 
[13:34:36.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.724]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.724]                     .init = FALSE)
[13:34:36.724]                 }
[13:34:36.724]             }
[13:34:36.724]         }
[13:34:36.724]     })
[13:34:36.724]     if (TRUE) {
[13:34:36.724]         base::sink(type = "output", split = FALSE)
[13:34:36.724]         if (TRUE) {
[13:34:36.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.724]         }
[13:34:36.724]         else {
[13:34:36.724]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.724]         }
[13:34:36.724]         base::close(...future.stdout)
[13:34:36.724]         ...future.stdout <- NULL
[13:34:36.724]     }
[13:34:36.724]     ...future.result$conditions <- ...future.conditions
[13:34:36.724]     ...future.result$finished <- base::Sys.time()
[13:34:36.724]     ...future.result
[13:34:36.724] }
[13:34:36.728] assign_globals() ...
[13:34:36.728] List of 5
[13:34:36.728]  $ ...future.FUN            :function (x, y)  
[13:34:36.728]  $ MoreArgs                 :List of 1
[13:34:36.728]   ..$ y: int [1:2] 3 4
[13:34:36.728]  $ ...future.elements_ii    :List of 1
[13:34:36.728]   ..$ x:List of 1
[13:34:36.728]   .. ..$ : int 2
[13:34:36.728]  $ ...future.seeds_ii       :List of 1
[13:34:36.728]   ..$ : int [1:7] 10407 -298214764 366709136 763068684 -1406532155 -746185351 35637647
[13:34:36.728]  $ ...future.globals.maxSize: NULL
[13:34:36.728]  - attr(*, "where")=List of 5
[13:34:36.728]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.728]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.728]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.728]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.728]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.728]  - attr(*, "resolved")= logi FALSE
[13:34:36.728]  - attr(*, "total_size")= num 1896
[13:34:36.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.728]  - attr(*, "already-done")= logi TRUE
[13:34:36.739] - reassign environment for ‘...future.FUN’
[13:34:36.740] - copied ‘...future.FUN’ to environment
[13:34:36.740] - copied ‘MoreArgs’ to environment
[13:34:36.740] - copied ‘...future.elements_ii’ to environment
[13:34:36.740] - copied ‘...future.seeds_ii’ to environment
[13:34:36.740] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.740] assign_globals() ... done
[13:34:36.741] requestCore(): workers = 2
[13:34:36.743] MulticoreFuture started
[13:34:36.744] - Launch lazy future ... done
[13:34:36.745] plan(): Setting new future strategy stack:
[13:34:36.745] run() for ‘MulticoreFuture’ ... done
[13:34:36.745] Created future:
[13:34:36.745] List of future strategies:
[13:34:36.745] 1. sequential:
[13:34:36.745]    - args: function (..., envir = parent.frame())
[13:34:36.745]    - tweaked: FALSE
[13:34:36.745]    - call: NULL
[13:34:36.746] plan(): nbrOfWorkers() = 1
[13:34:36.748] plan(): Setting new future strategy stack:
[13:34:36.748] List of future strategies:
[13:34:36.748] 1. multicore:
[13:34:36.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.748]    - tweaked: FALSE
[13:34:36.748]    - call: plan(strategy)
[13:34:36.754] plan(): nbrOfWorkers() = 2
[13:34:36.745] MulticoreFuture:
[13:34:36.745] Label: ‘future_mapply-2’
[13:34:36.745] Expression:
[13:34:36.745] {
[13:34:36.745]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.745]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.745]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.745]         on.exit(options(oopts), add = TRUE)
[13:34:36.745]     }
[13:34:36.745]     {
[13:34:36.745]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:36.745]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[13:34:36.745]                 inherits = FALSE)
[13:34:36.745]             ...future.FUN(...)
[13:34:36.745]         }
[13:34:36.745]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:36.745]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:36.745]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.745]         do.call(mapply, args = args)
[13:34:36.745]     }
[13:34:36.745] }
[13:34:36.745] Lazy evaluation: FALSE
[13:34:36.745] Asynchronous evaluation: TRUE
[13:34:36.745] Local evaluation: TRUE
[13:34:36.745] Environment: R_GlobalEnv
[13:34:36.745] Capture standard output: TRUE
[13:34:36.745] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.745] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.745] Packages: <none>
[13:34:36.745] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:34:36.745] Resolved: TRUE
[13:34:36.745] Value: <not collected>
[13:34:36.745] Conditions captured: <none>
[13:34:36.745] Early signaling: FALSE
[13:34:36.745] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.745] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.755] Chunk #2 of 2 ... DONE
[13:34:36.755] Launching 2 futures (chunks) ... DONE
[13:34:36.755] Resolving 2 futures (chunks) ...
[13:34:36.755] resolve() on list ...
[13:34:36.755]  recursive: 0
[13:34:36.756]  length: 2
[13:34:36.756] 
[13:34:36.756] Future #1
[13:34:36.756] result() for MulticoreFuture ...
[13:34:36.757] result() for MulticoreFuture ...
[13:34:36.757] result() for MulticoreFuture ... done
[13:34:36.757] result() for MulticoreFuture ... done
[13:34:36.758] result() for MulticoreFuture ...
[13:34:36.758] result() for MulticoreFuture ... done
[13:34:36.758] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:36.758] - nx: 2
[13:34:36.759] - relay: TRUE
[13:34:36.759] - stdout: TRUE
[13:34:36.759] - signal: TRUE
[13:34:36.759] - resignal: FALSE
[13:34:36.759] - force: TRUE
[13:34:36.759] - relayed: [n=2] FALSE, FALSE
[13:34:36.760] - queued futures: [n=2] FALSE, FALSE
[13:34:36.760]  - until=1
[13:34:36.760]  - relaying element #1
[13:34:36.760] result() for MulticoreFuture ...
[13:34:36.761] result() for MulticoreFuture ... done
[13:34:36.761] result() for MulticoreFuture ...
[13:34:36.761] result() for MulticoreFuture ... done
[13:34:36.761] result() for MulticoreFuture ...
[13:34:36.761] result() for MulticoreFuture ... done
[13:34:36.762] result() for MulticoreFuture ...
[13:34:36.762] result() for MulticoreFuture ... done
[13:34:36.762] - relayed: [n=2] TRUE, FALSE
[13:34:36.762] - queued futures: [n=2] TRUE, FALSE
[13:34:36.762] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:36.762]  length: 1 (resolved future 1)
[13:34:36.763] Future #2
[13:34:36.763] result() for MulticoreFuture ...
[13:34:36.764] result() for MulticoreFuture ...
[13:34:36.764] result() for MulticoreFuture ... done
[13:34:36.764] result() for MulticoreFuture ... done
[13:34:36.764] result() for MulticoreFuture ...
[13:34:36.764] result() for MulticoreFuture ... done
[13:34:36.764] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:36.765] - nx: 2
[13:34:36.765] - relay: TRUE
[13:34:36.765] - stdout: TRUE
[13:34:36.765] - signal: TRUE
[13:34:36.765] - resignal: FALSE
[13:34:36.765] - force: TRUE
[13:34:36.765] - relayed: [n=2] TRUE, FALSE
[13:34:36.765] - queued futures: [n=2] TRUE, FALSE
[13:34:36.765]  - until=2
[13:34:36.766]  - relaying element #2
[13:34:36.766] result() for MulticoreFuture ...
[13:34:36.766] result() for MulticoreFuture ... done
[13:34:36.766] result() for MulticoreFuture ...
[13:34:36.766] result() for MulticoreFuture ... done
[13:34:36.766] result() for MulticoreFuture ...
[13:34:36.766] result() for MulticoreFuture ... done
[13:34:36.767] result() for MulticoreFuture ...
[13:34:36.767] result() for MulticoreFuture ... done
[13:34:36.767] - relayed: [n=2] TRUE, TRUE
[13:34:36.767] - queued futures: [n=2] TRUE, TRUE
[13:34:36.770] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:36.770]  length: 0 (resolved future 2)
[13:34:36.770] Relaying remaining futures
[13:34:36.771] signalConditionsASAP(NULL, pos=0) ...
[13:34:36.771] - nx: 2
[13:34:36.771] - relay: TRUE
[13:34:36.771] - stdout: TRUE
[13:34:36.771] - signal: TRUE
[13:34:36.771] - resignal: FALSE
[13:34:36.771] - force: TRUE
[13:34:36.772] - relayed: [n=2] TRUE, TRUE
[13:34:36.772] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:36.772] - relayed: [n=2] TRUE, TRUE
[13:34:36.772] - queued futures: [n=2] TRUE, TRUE
[13:34:36.772] signalConditionsASAP(NULL, pos=0) ... done
[13:34:36.772] resolve() on list ... DONE
[13:34:36.773] result() for MulticoreFuture ...
[13:34:36.773] result() for MulticoreFuture ... done
[13:34:36.773] result() for MulticoreFuture ...
[13:34:36.773] result() for MulticoreFuture ... done
[13:34:36.773] result() for MulticoreFuture ...
[13:34:36.773] result() for MulticoreFuture ... done
[13:34:36.773] result() for MulticoreFuture ...
[13:34:36.774] result() for MulticoreFuture ... done
[13:34:36.774]  - Number of value chunks collected: 2
[13:34:36.774] Resolving 2 futures (chunks) ... DONE
[13:34:36.774] Reducing values from 2 chunks ...
[13:34:36.774]  - Number of values collected after concatenation: 2
[13:34:36.774]  - Number of values expected: 2
[13:34:36.775] Reducing values from 2 chunks ... DONE
[13:34:36.775] future_mapply() ... DONE
[13:34:36.775] future_mapply() ...
[13:34:36.779] Number of chunks: 2
[13:34:36.779] getGlobalsAndPackagesXApply() ...
[13:34:36.780]  - future.globals: TRUE
[13:34:36.780] getGlobalsAndPackages() ...
[13:34:36.780] Searching for globals...
[13:34:36.781] - globals found: [1] ‘FUN’
[13:34:36.782] Searching for globals ... DONE
[13:34:36.782] Resolving globals: FALSE
[13:34:36.782] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[13:34:36.782] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[13:34:36.783] - globals: [1] ‘FUN’
[13:34:36.783] 
[13:34:36.783] getGlobalsAndPackages() ... DONE
[13:34:36.783]  - globals found/used: [n=1] ‘FUN’
[13:34:36.783]  - needed namespaces: [n=0] 
[13:34:36.783] Finding globals ... DONE
[13:34:36.783] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:36.783] List of 2
[13:34:36.783]  $ ...future.FUN:function (x, y)  
[13:34:36.783]  $ MoreArgs     :List of 1
[13:34:36.783]   ..$ y: int [1:2] 3 4
[13:34:36.783]  - attr(*, "where")=List of 2
[13:34:36.783]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:36.783]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:36.783]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.783]  - attr(*, "resolved")= logi FALSE
[13:34:36.783]  - attr(*, "total_size")= num NA
[13:34:36.787] Packages to be attached in all futures: [n=0] 
[13:34:36.787] getGlobalsAndPackagesXApply() ... DONE
[13:34:36.787] Number of futures (= number of chunks): 2
[13:34:36.787] Launching 2 futures (chunks) ...
[13:34:36.787] Chunk #1 of 2 ...
[13:34:36.787]  - Finding globals in '...' for chunk #1 ...
[13:34:36.787] getGlobalsAndPackages() ...
[13:34:36.788] Searching for globals...
[13:34:36.788] 
[13:34:36.788] Searching for globals ... DONE
[13:34:36.788] - globals: [0] <none>
[13:34:36.788] getGlobalsAndPackages() ... DONE
[13:34:36.788]    + additional globals found: [n=0] 
[13:34:36.788]    + additional namespaces needed: [n=0] 
[13:34:36.788]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:36.789]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.789]  - seeds: <none>
[13:34:36.789]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.789] getGlobalsAndPackages() ...
[13:34:36.789] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.789] Resolving globals: FALSE
[13:34:36.790] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[13:34:36.790] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[13:34:36.790] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.790] 
[13:34:36.790] getGlobalsAndPackages() ... DONE
[13:34:36.791] run() for ‘Future’ ...
[13:34:36.791] - state: ‘created’
[13:34:36.791] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.794] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.795] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.795]   - Field: ‘label’
[13:34:36.795]   - Field: ‘local’
[13:34:36.795]   - Field: ‘owner’
[13:34:36.795]   - Field: ‘envir’
[13:34:36.795]   - Field: ‘workers’
[13:34:36.795]   - Field: ‘packages’
[13:34:36.795]   - Field: ‘gc’
[13:34:36.795]   - Field: ‘job’
[13:34:36.795]   - Field: ‘conditions’
[13:34:36.796]   - Field: ‘expr’
[13:34:36.796]   - Field: ‘uuid’
[13:34:36.796]   - Field: ‘seed’
[13:34:36.796]   - Field: ‘version’
[13:34:36.796]   - Field: ‘result’
[13:34:36.796]   - Field: ‘asynchronous’
[13:34:36.796]   - Field: ‘calls’
[13:34:36.799]   - Field: ‘globals’
[13:34:36.799]   - Field: ‘stdout’
[13:34:36.799]   - Field: ‘earlySignal’
[13:34:36.799]   - Field: ‘lazy’
[13:34:36.799]   - Field: ‘state’
[13:34:36.799] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.799] - Launch lazy future ...
[13:34:36.799] Packages needed by the future expression (n = 0): <none>
[13:34:36.800] Packages needed by future strategies (n = 0): <none>
[13:34:36.800] {
[13:34:36.800]     {
[13:34:36.800]         {
[13:34:36.800]             ...future.startTime <- base::Sys.time()
[13:34:36.800]             {
[13:34:36.800]                 {
[13:34:36.800]                   {
[13:34:36.800]                     {
[13:34:36.800]                       base::local({
[13:34:36.800]                         has_future <- base::requireNamespace("future", 
[13:34:36.800]                           quietly = TRUE)
[13:34:36.800]                         if (has_future) {
[13:34:36.800]                           ns <- base::getNamespace("future")
[13:34:36.800]                           version <- ns[[".package"]][["version"]]
[13:34:36.800]                           if (is.null(version)) 
[13:34:36.800]                             version <- utils::packageVersion("future")
[13:34:36.800]                         }
[13:34:36.800]                         else {
[13:34:36.800]                           version <- NULL
[13:34:36.800]                         }
[13:34:36.800]                         if (!has_future || version < "1.8.0") {
[13:34:36.800]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.800]                             "", base::R.version$version.string), 
[13:34:36.800]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.800]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.800]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.800]                               "release", "version")], collapse = " "), 
[13:34:36.800]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.800]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.800]                             info)
[13:34:36.800]                           info <- base::paste(info, collapse = "; ")
[13:34:36.800]                           if (!has_future) {
[13:34:36.800]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.800]                               info)
[13:34:36.800]                           }
[13:34:36.800]                           else {
[13:34:36.800]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.800]                               info, version)
[13:34:36.800]                           }
[13:34:36.800]                           base::stop(msg)
[13:34:36.800]                         }
[13:34:36.800]                       })
[13:34:36.800]                     }
[13:34:36.800]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.800]                     base::options(mc.cores = 1L)
[13:34:36.800]                   }
[13:34:36.800]                   ...future.strategy.old <- future::plan("list")
[13:34:36.800]                   options(future.plan = NULL)
[13:34:36.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.800]                 }
[13:34:36.800]                 ...future.workdir <- getwd()
[13:34:36.800]             }
[13:34:36.800]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.800]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.800]         }
[13:34:36.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.800]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.800]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.800]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.800]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.800]             base::names(...future.oldOptions))
[13:34:36.800]     }
[13:34:36.800]     if (FALSE) {
[13:34:36.800]     }
[13:34:36.800]     else {
[13:34:36.800]         if (TRUE) {
[13:34:36.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.800]                 open = "w")
[13:34:36.800]         }
[13:34:36.800]         else {
[13:34:36.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.800]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.800]         }
[13:34:36.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.800]             base::sink(type = "output", split = FALSE)
[13:34:36.800]             base::close(...future.stdout)
[13:34:36.800]         }, add = TRUE)
[13:34:36.800]     }
[13:34:36.800]     ...future.frame <- base::sys.nframe()
[13:34:36.800]     ...future.conditions <- base::list()
[13:34:36.800]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.800]     if (FALSE) {
[13:34:36.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.800]     }
[13:34:36.800]     ...future.result <- base::tryCatch({
[13:34:36.800]         base::withCallingHandlers({
[13:34:36.800]             ...future.value <- base::withVisible(base::local({
[13:34:36.800]                 withCallingHandlers({
[13:34:36.800]                   {
[13:34:36.800]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.800]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.800]                       ...future.globals.maxSize)) {
[13:34:36.800]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.800]                       on.exit(options(oopts), add = TRUE)
[13:34:36.800]                     }
[13:34:36.800]                     {
[13:34:36.800]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.800]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.800]                         USE.NAMES = FALSE)
[13:34:36.800]                       do.call(mapply, args = args)
[13:34:36.800]                     }
[13:34:36.800]                   }
[13:34:36.800]                 }, immediateCondition = function(cond) {
[13:34:36.800]                   save_rds <- function (object, pathname, ...) 
[13:34:36.800]                   {
[13:34:36.800]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.800]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.800]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.800]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.800]                         fi_tmp[["mtime"]])
[13:34:36.800]                     }
[13:34:36.800]                     tryCatch({
[13:34:36.800]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.800]                     }, error = function(ex) {
[13:34:36.800]                       msg <- conditionMessage(ex)
[13:34:36.800]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.800]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.800]                         fi_tmp[["mtime"]], msg)
[13:34:36.800]                       ex$message <- msg
[13:34:36.800]                       stop(ex)
[13:34:36.800]                     })
[13:34:36.800]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.800]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.800]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.800]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.800]                       fi <- file.info(pathname)
[13:34:36.800]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.800]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.800]                         fi[["size"]], fi[["mtime"]])
[13:34:36.800]                       stop(msg)
[13:34:36.800]                     }
[13:34:36.800]                     invisible(pathname)
[13:34:36.800]                   }
[13:34:36.800]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.800]                     rootPath = tempdir()) 
[13:34:36.800]                   {
[13:34:36.800]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.800]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.800]                       tmpdir = path, fileext = ".rds")
[13:34:36.800]                     save_rds(obj, file)
[13:34:36.800]                   }
[13:34:36.800]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.800]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.800]                   {
[13:34:36.800]                     inherits <- base::inherits
[13:34:36.800]                     invokeRestart <- base::invokeRestart
[13:34:36.800]                     is.null <- base::is.null
[13:34:36.800]                     muffled <- FALSE
[13:34:36.800]                     if (inherits(cond, "message")) {
[13:34:36.800]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.800]                       if (muffled) 
[13:34:36.800]                         invokeRestart("muffleMessage")
[13:34:36.800]                     }
[13:34:36.800]                     else if (inherits(cond, "warning")) {
[13:34:36.800]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.800]                       if (muffled) 
[13:34:36.800]                         invokeRestart("muffleWarning")
[13:34:36.800]                     }
[13:34:36.800]                     else if (inherits(cond, "condition")) {
[13:34:36.800]                       if (!is.null(pattern)) {
[13:34:36.800]                         computeRestarts <- base::computeRestarts
[13:34:36.800]                         grepl <- base::grepl
[13:34:36.800]                         restarts <- computeRestarts(cond)
[13:34:36.800]                         for (restart in restarts) {
[13:34:36.800]                           name <- restart$name
[13:34:36.800]                           if (is.null(name)) 
[13:34:36.800]                             next
[13:34:36.800]                           if (!grepl(pattern, name)) 
[13:34:36.800]                             next
[13:34:36.800]                           invokeRestart(restart)
[13:34:36.800]                           muffled <- TRUE
[13:34:36.800]                           break
[13:34:36.800]                         }
[13:34:36.800]                       }
[13:34:36.800]                     }
[13:34:36.800]                     invisible(muffled)
[13:34:36.800]                   }
[13:34:36.800]                   muffleCondition(cond)
[13:34:36.800]                 })
[13:34:36.800]             }))
[13:34:36.800]             future::FutureResult(value = ...future.value$value, 
[13:34:36.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.800]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.800]                     ...future.globalenv.names))
[13:34:36.800]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.800]         }, condition = base::local({
[13:34:36.800]             c <- base::c
[13:34:36.800]             inherits <- base::inherits
[13:34:36.800]             invokeRestart <- base::invokeRestart
[13:34:36.800]             length <- base::length
[13:34:36.800]             list <- base::list
[13:34:36.800]             seq.int <- base::seq.int
[13:34:36.800]             signalCondition <- base::signalCondition
[13:34:36.800]             sys.calls <- base::sys.calls
[13:34:36.800]             `[[` <- base::`[[`
[13:34:36.800]             `+` <- base::`+`
[13:34:36.800]             `<<-` <- base::`<<-`
[13:34:36.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.800]                   3L)]
[13:34:36.800]             }
[13:34:36.800]             function(cond) {
[13:34:36.800]                 is_error <- inherits(cond, "error")
[13:34:36.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.800]                   NULL)
[13:34:36.800]                 if (is_error) {
[13:34:36.800]                   sessionInformation <- function() {
[13:34:36.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.800]                       search = base::search(), system = base::Sys.info())
[13:34:36.800]                   }
[13:34:36.800]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.800]                     cond$call), session = sessionInformation(), 
[13:34:36.800]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.800]                   signalCondition(cond)
[13:34:36.800]                 }
[13:34:36.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.800]                 "immediateCondition"))) {
[13:34:36.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.800]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.800]                   if (TRUE && !signal) {
[13:34:36.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.800]                     {
[13:34:36.800]                       inherits <- base::inherits
[13:34:36.800]                       invokeRestart <- base::invokeRestart
[13:34:36.800]                       is.null <- base::is.null
[13:34:36.800]                       muffled <- FALSE
[13:34:36.800]                       if (inherits(cond, "message")) {
[13:34:36.800]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.800]                         if (muffled) 
[13:34:36.800]                           invokeRestart("muffleMessage")
[13:34:36.800]                       }
[13:34:36.800]                       else if (inherits(cond, "warning")) {
[13:34:36.800]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.800]                         if (muffled) 
[13:34:36.800]                           invokeRestart("muffleWarning")
[13:34:36.800]                       }
[13:34:36.800]                       else if (inherits(cond, "condition")) {
[13:34:36.800]                         if (!is.null(pattern)) {
[13:34:36.800]                           computeRestarts <- base::computeRestarts
[13:34:36.800]                           grepl <- base::grepl
[13:34:36.800]                           restarts <- computeRestarts(cond)
[13:34:36.800]                           for (restart in restarts) {
[13:34:36.800]                             name <- restart$name
[13:34:36.800]                             if (is.null(name)) 
[13:34:36.800]                               next
[13:34:36.800]                             if (!grepl(pattern, name)) 
[13:34:36.800]                               next
[13:34:36.800]                             invokeRestart(restart)
[13:34:36.800]                             muffled <- TRUE
[13:34:36.800]                             break
[13:34:36.800]                           }
[13:34:36.800]                         }
[13:34:36.800]                       }
[13:34:36.800]                       invisible(muffled)
[13:34:36.800]                     }
[13:34:36.800]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.800]                   }
[13:34:36.800]                 }
[13:34:36.800]                 else {
[13:34:36.800]                   if (TRUE) {
[13:34:36.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.800]                     {
[13:34:36.800]                       inherits <- base::inherits
[13:34:36.800]                       invokeRestart <- base::invokeRestart
[13:34:36.800]                       is.null <- base::is.null
[13:34:36.800]                       muffled <- FALSE
[13:34:36.800]                       if (inherits(cond, "message")) {
[13:34:36.800]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.800]                         if (muffled) 
[13:34:36.800]                           invokeRestart("muffleMessage")
[13:34:36.800]                       }
[13:34:36.800]                       else if (inherits(cond, "warning")) {
[13:34:36.800]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.800]                         if (muffled) 
[13:34:36.800]                           invokeRestart("muffleWarning")
[13:34:36.800]                       }
[13:34:36.800]                       else if (inherits(cond, "condition")) {
[13:34:36.800]                         if (!is.null(pattern)) {
[13:34:36.800]                           computeRestarts <- base::computeRestarts
[13:34:36.800]                           grepl <- base::grepl
[13:34:36.800]                           restarts <- computeRestarts(cond)
[13:34:36.800]                           for (restart in restarts) {
[13:34:36.800]                             name <- restart$name
[13:34:36.800]                             if (is.null(name)) 
[13:34:36.800]                               next
[13:34:36.800]                             if (!grepl(pattern, name)) 
[13:34:36.800]                               next
[13:34:36.800]                             invokeRestart(restart)
[13:34:36.800]                             muffled <- TRUE
[13:34:36.800]                             break
[13:34:36.800]                           }
[13:34:36.800]                         }
[13:34:36.800]                       }
[13:34:36.800]                       invisible(muffled)
[13:34:36.800]                     }
[13:34:36.800]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.800]                   }
[13:34:36.800]                 }
[13:34:36.800]             }
[13:34:36.800]         }))
[13:34:36.800]     }, error = function(ex) {
[13:34:36.800]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.800]                 ...future.rng), started = ...future.startTime, 
[13:34:36.800]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.800]             version = "1.8"), class = "FutureResult")
[13:34:36.800]     }, finally = {
[13:34:36.800]         if (!identical(...future.workdir, getwd())) 
[13:34:36.800]             setwd(...future.workdir)
[13:34:36.800]         {
[13:34:36.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.800]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.800]             }
[13:34:36.800]             base::options(...future.oldOptions)
[13:34:36.800]             if (.Platform$OS.type == "windows") {
[13:34:36.800]                 old_names <- names(...future.oldEnvVars)
[13:34:36.800]                 envs <- base::Sys.getenv()
[13:34:36.800]                 names <- names(envs)
[13:34:36.800]                 common <- intersect(names, old_names)
[13:34:36.800]                 added <- setdiff(names, old_names)
[13:34:36.800]                 removed <- setdiff(old_names, names)
[13:34:36.800]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.800]                   envs[common]]
[13:34:36.800]                 NAMES <- toupper(changed)
[13:34:36.800]                 args <- list()
[13:34:36.800]                 for (kk in seq_along(NAMES)) {
[13:34:36.800]                   name <- changed[[kk]]
[13:34:36.800]                   NAME <- NAMES[[kk]]
[13:34:36.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.800]                     next
[13:34:36.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.800]                 }
[13:34:36.800]                 NAMES <- toupper(added)
[13:34:36.800]                 for (kk in seq_along(NAMES)) {
[13:34:36.800]                   name <- added[[kk]]
[13:34:36.800]                   NAME <- NAMES[[kk]]
[13:34:36.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.800]                     next
[13:34:36.800]                   args[[name]] <- ""
[13:34:36.800]                 }
[13:34:36.800]                 NAMES <- toupper(removed)
[13:34:36.800]                 for (kk in seq_along(NAMES)) {
[13:34:36.800]                   name <- removed[[kk]]
[13:34:36.800]                   NAME <- NAMES[[kk]]
[13:34:36.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.800]                     next
[13:34:36.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.800]                 }
[13:34:36.800]                 if (length(args) > 0) 
[13:34:36.800]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.800]             }
[13:34:36.800]             else {
[13:34:36.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.800]             }
[13:34:36.800]             {
[13:34:36.800]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.800]                   0L) {
[13:34:36.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.800]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.800]                   base::options(opts)
[13:34:36.800]                 }
[13:34:36.800]                 {
[13:34:36.800]                   {
[13:34:36.800]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.800]                     NULL
[13:34:36.800]                   }
[13:34:36.800]                   options(future.plan = NULL)
[13:34:36.800]                   if (is.na(NA_character_)) 
[13:34:36.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.800]                     .init = FALSE)
[13:34:36.800]                 }
[13:34:36.800]             }
[13:34:36.800]         }
[13:34:36.800]     })
[13:34:36.800]     if (TRUE) {
[13:34:36.800]         base::sink(type = "output", split = FALSE)
[13:34:36.800]         if (TRUE) {
[13:34:36.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.800]         }
[13:34:36.800]         else {
[13:34:36.800]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.800]         }
[13:34:36.800]         base::close(...future.stdout)
[13:34:36.800]         ...future.stdout <- NULL
[13:34:36.800]     }
[13:34:36.800]     ...future.result$conditions <- ...future.conditions
[13:34:36.800]     ...future.result$finished <- base::Sys.time()
[13:34:36.800]     ...future.result
[13:34:36.800] }
[13:34:36.803] assign_globals() ...
[13:34:36.803] List of 5
[13:34:36.803]  $ ...future.FUN            :function (x, y)  
[13:34:36.803]  $ MoreArgs                 :List of 1
[13:34:36.803]   ..$ y: int [1:2] 3 4
[13:34:36.803]  $ ...future.elements_ii    :List of 1
[13:34:36.803]   ..$ x:List of 1
[13:34:36.803]   .. ..$ : int 1
[13:34:36.803]  $ ...future.seeds_ii       : NULL
[13:34:36.803]  $ ...future.globals.maxSize: NULL
[13:34:36.803]  - attr(*, "where")=List of 5
[13:34:36.803]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.803]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.803]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.803]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.803]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.803]  - attr(*, "resolved")= logi FALSE
[13:34:36.803]  - attr(*, "total_size")= num 1816
[13:34:36.803]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.803]  - attr(*, "already-done")= logi TRUE
[13:34:36.808] - reassign environment for ‘...future.FUN’
[13:34:36.808] - copied ‘...future.FUN’ to environment
[13:34:36.808] - copied ‘MoreArgs’ to environment
[13:34:36.808] - copied ‘...future.elements_ii’ to environment
[13:34:36.808] - copied ‘...future.seeds_ii’ to environment
[13:34:36.809] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.809] assign_globals() ... done
[13:34:36.809] requestCore(): workers = 2
[13:34:36.811] MulticoreFuture started
[13:34:36.811] - Launch lazy future ... done
[13:34:36.811] run() for ‘MulticoreFuture’ ... done
[13:34:36.812] Created future:
[13:34:36.812] plan(): Setting new future strategy stack:
[13:34:36.812] List of future strategies:
[13:34:36.812] 1. sequential:
[13:34:36.812]    - args: function (..., envir = parent.frame())
[13:34:36.812]    - tweaked: FALSE
[13:34:36.812]    - call: NULL
[13:34:36.813] plan(): nbrOfWorkers() = 1
[13:34:36.815] plan(): Setting new future strategy stack:
[13:34:36.816] List of future strategies:
[13:34:36.816] 1. multicore:
[13:34:36.816]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.816]    - tweaked: FALSE
[13:34:36.816]    - call: plan(strategy)
[13:34:36.821] plan(): nbrOfWorkers() = 2
[13:34:36.812] MulticoreFuture:
[13:34:36.812] Label: ‘future_.mapply-1’
[13:34:36.812] Expression:
[13:34:36.812] {
[13:34:36.812]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.812]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.812]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.812]         on.exit(options(oopts), add = TRUE)
[13:34:36.812]     }
[13:34:36.812]     {
[13:34:36.812]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.812]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.812]         do.call(mapply, args = args)
[13:34:36.812]     }
[13:34:36.812] }
[13:34:36.812] Lazy evaluation: FALSE
[13:34:36.812] Asynchronous evaluation: TRUE
[13:34:36.812] Local evaluation: TRUE
[13:34:36.812] Environment: R_GlobalEnv
[13:34:36.812] Capture standard output: TRUE
[13:34:36.812] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.812] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.812] Packages: <none>
[13:34:36.812] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.812] Resolved: TRUE
[13:34:36.812] Value: <not collected>
[13:34:36.812] Conditions captured: <none>
[13:34:36.812] Early signaling: FALSE
[13:34:36.812] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.812] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.822] Chunk #1 of 2 ... DONE
[13:34:36.822] Chunk #2 of 2 ...
[13:34:36.823]  - Finding globals in '...' for chunk #2 ...
[13:34:36.823] getGlobalsAndPackages() ...
[13:34:36.823] Searching for globals...
[13:34:36.824] 
[13:34:36.824] Searching for globals ... DONE
[13:34:36.824] - globals: [0] <none>
[13:34:36.824] getGlobalsAndPackages() ... DONE
[13:34:36.824]    + additional globals found: [n=0] 
[13:34:36.825]    + additional namespaces needed: [n=0] 
[13:34:36.825]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:36.825]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.825]  - seeds: <none>
[13:34:36.825]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.825] getGlobalsAndPackages() ...
[13:34:36.825] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.826] Resolving globals: FALSE
[13:34:36.826] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[13:34:36.827] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[13:34:36.827] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.828] 
[13:34:36.828] getGlobalsAndPackages() ... DONE
[13:34:36.828] run() for ‘Future’ ...
[13:34:36.828] - state: ‘created’
[13:34:36.829] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.833] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.834] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.834]   - Field: ‘label’
[13:34:36.834]   - Field: ‘local’
[13:34:36.834]   - Field: ‘owner’
[13:34:36.834]   - Field: ‘envir’
[13:34:36.835]   - Field: ‘workers’
[13:34:36.835]   - Field: ‘packages’
[13:34:36.835]   - Field: ‘gc’
[13:34:36.835]   - Field: ‘job’
[13:34:36.835]   - Field: ‘conditions’
[13:34:36.835]   - Field: ‘expr’
[13:34:36.835]   - Field: ‘uuid’
[13:34:36.836]   - Field: ‘seed’
[13:34:36.836]   - Field: ‘version’
[13:34:36.836]   - Field: ‘result’
[13:34:36.836]   - Field: ‘asynchronous’
[13:34:36.836]   - Field: ‘calls’
[13:34:36.836]   - Field: ‘globals’
[13:34:36.837]   - Field: ‘stdout’
[13:34:36.837]   - Field: ‘earlySignal’
[13:34:36.837]   - Field: ‘lazy’
[13:34:36.837]   - Field: ‘state’
[13:34:36.837] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.837] - Launch lazy future ...
[13:34:36.838] Packages needed by the future expression (n = 0): <none>
[13:34:36.838] Packages needed by future strategies (n = 0): <none>
[13:34:36.842] {
[13:34:36.842]     {
[13:34:36.842]         {
[13:34:36.842]             ...future.startTime <- base::Sys.time()
[13:34:36.842]             {
[13:34:36.842]                 {
[13:34:36.842]                   {
[13:34:36.842]                     {
[13:34:36.842]                       base::local({
[13:34:36.842]                         has_future <- base::requireNamespace("future", 
[13:34:36.842]                           quietly = TRUE)
[13:34:36.842]                         if (has_future) {
[13:34:36.842]                           ns <- base::getNamespace("future")
[13:34:36.842]                           version <- ns[[".package"]][["version"]]
[13:34:36.842]                           if (is.null(version)) 
[13:34:36.842]                             version <- utils::packageVersion("future")
[13:34:36.842]                         }
[13:34:36.842]                         else {
[13:34:36.842]                           version <- NULL
[13:34:36.842]                         }
[13:34:36.842]                         if (!has_future || version < "1.8.0") {
[13:34:36.842]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.842]                             "", base::R.version$version.string), 
[13:34:36.842]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.842]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.842]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.842]                               "release", "version")], collapse = " "), 
[13:34:36.842]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.842]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.842]                             info)
[13:34:36.842]                           info <- base::paste(info, collapse = "; ")
[13:34:36.842]                           if (!has_future) {
[13:34:36.842]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.842]                               info)
[13:34:36.842]                           }
[13:34:36.842]                           else {
[13:34:36.842]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.842]                               info, version)
[13:34:36.842]                           }
[13:34:36.842]                           base::stop(msg)
[13:34:36.842]                         }
[13:34:36.842]                       })
[13:34:36.842]                     }
[13:34:36.842]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.842]                     base::options(mc.cores = 1L)
[13:34:36.842]                   }
[13:34:36.842]                   ...future.strategy.old <- future::plan("list")
[13:34:36.842]                   options(future.plan = NULL)
[13:34:36.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.842]                 }
[13:34:36.842]                 ...future.workdir <- getwd()
[13:34:36.842]             }
[13:34:36.842]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.842]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.842]         }
[13:34:36.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.842]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.842]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.842]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.842]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.842]             base::names(...future.oldOptions))
[13:34:36.842]     }
[13:34:36.842]     if (FALSE) {
[13:34:36.842]     }
[13:34:36.842]     else {
[13:34:36.842]         if (TRUE) {
[13:34:36.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.842]                 open = "w")
[13:34:36.842]         }
[13:34:36.842]         else {
[13:34:36.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.842]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.842]         }
[13:34:36.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.842]             base::sink(type = "output", split = FALSE)
[13:34:36.842]             base::close(...future.stdout)
[13:34:36.842]         }, add = TRUE)
[13:34:36.842]     }
[13:34:36.842]     ...future.frame <- base::sys.nframe()
[13:34:36.842]     ...future.conditions <- base::list()
[13:34:36.842]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.842]     if (FALSE) {
[13:34:36.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.842]     }
[13:34:36.842]     ...future.result <- base::tryCatch({
[13:34:36.842]         base::withCallingHandlers({
[13:34:36.842]             ...future.value <- base::withVisible(base::local({
[13:34:36.842]                 withCallingHandlers({
[13:34:36.842]                   {
[13:34:36.842]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.842]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.842]                       ...future.globals.maxSize)) {
[13:34:36.842]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.842]                       on.exit(options(oopts), add = TRUE)
[13:34:36.842]                     }
[13:34:36.842]                     {
[13:34:36.842]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.842]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.842]                         USE.NAMES = FALSE)
[13:34:36.842]                       do.call(mapply, args = args)
[13:34:36.842]                     }
[13:34:36.842]                   }
[13:34:36.842]                 }, immediateCondition = function(cond) {
[13:34:36.842]                   save_rds <- function (object, pathname, ...) 
[13:34:36.842]                   {
[13:34:36.842]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.842]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.842]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.842]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.842]                         fi_tmp[["mtime"]])
[13:34:36.842]                     }
[13:34:36.842]                     tryCatch({
[13:34:36.842]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.842]                     }, error = function(ex) {
[13:34:36.842]                       msg <- conditionMessage(ex)
[13:34:36.842]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.842]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.842]                         fi_tmp[["mtime"]], msg)
[13:34:36.842]                       ex$message <- msg
[13:34:36.842]                       stop(ex)
[13:34:36.842]                     })
[13:34:36.842]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.842]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.842]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.842]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.842]                       fi <- file.info(pathname)
[13:34:36.842]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.842]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.842]                         fi[["size"]], fi[["mtime"]])
[13:34:36.842]                       stop(msg)
[13:34:36.842]                     }
[13:34:36.842]                     invisible(pathname)
[13:34:36.842]                   }
[13:34:36.842]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.842]                     rootPath = tempdir()) 
[13:34:36.842]                   {
[13:34:36.842]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.842]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.842]                       tmpdir = path, fileext = ".rds")
[13:34:36.842]                     save_rds(obj, file)
[13:34:36.842]                   }
[13:34:36.842]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.842]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.842]                   {
[13:34:36.842]                     inherits <- base::inherits
[13:34:36.842]                     invokeRestart <- base::invokeRestart
[13:34:36.842]                     is.null <- base::is.null
[13:34:36.842]                     muffled <- FALSE
[13:34:36.842]                     if (inherits(cond, "message")) {
[13:34:36.842]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.842]                       if (muffled) 
[13:34:36.842]                         invokeRestart("muffleMessage")
[13:34:36.842]                     }
[13:34:36.842]                     else if (inherits(cond, "warning")) {
[13:34:36.842]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.842]                       if (muffled) 
[13:34:36.842]                         invokeRestart("muffleWarning")
[13:34:36.842]                     }
[13:34:36.842]                     else if (inherits(cond, "condition")) {
[13:34:36.842]                       if (!is.null(pattern)) {
[13:34:36.842]                         computeRestarts <- base::computeRestarts
[13:34:36.842]                         grepl <- base::grepl
[13:34:36.842]                         restarts <- computeRestarts(cond)
[13:34:36.842]                         for (restart in restarts) {
[13:34:36.842]                           name <- restart$name
[13:34:36.842]                           if (is.null(name)) 
[13:34:36.842]                             next
[13:34:36.842]                           if (!grepl(pattern, name)) 
[13:34:36.842]                             next
[13:34:36.842]                           invokeRestart(restart)
[13:34:36.842]                           muffled <- TRUE
[13:34:36.842]                           break
[13:34:36.842]                         }
[13:34:36.842]                       }
[13:34:36.842]                     }
[13:34:36.842]                     invisible(muffled)
[13:34:36.842]                   }
[13:34:36.842]                   muffleCondition(cond)
[13:34:36.842]                 })
[13:34:36.842]             }))
[13:34:36.842]             future::FutureResult(value = ...future.value$value, 
[13:34:36.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.842]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.842]                     ...future.globalenv.names))
[13:34:36.842]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.842]         }, condition = base::local({
[13:34:36.842]             c <- base::c
[13:34:36.842]             inherits <- base::inherits
[13:34:36.842]             invokeRestart <- base::invokeRestart
[13:34:36.842]             length <- base::length
[13:34:36.842]             list <- base::list
[13:34:36.842]             seq.int <- base::seq.int
[13:34:36.842]             signalCondition <- base::signalCondition
[13:34:36.842]             sys.calls <- base::sys.calls
[13:34:36.842]             `[[` <- base::`[[`
[13:34:36.842]             `+` <- base::`+`
[13:34:36.842]             `<<-` <- base::`<<-`
[13:34:36.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.842]                   3L)]
[13:34:36.842]             }
[13:34:36.842]             function(cond) {
[13:34:36.842]                 is_error <- inherits(cond, "error")
[13:34:36.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.842]                   NULL)
[13:34:36.842]                 if (is_error) {
[13:34:36.842]                   sessionInformation <- function() {
[13:34:36.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.842]                       search = base::search(), system = base::Sys.info())
[13:34:36.842]                   }
[13:34:36.842]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.842]                     cond$call), session = sessionInformation(), 
[13:34:36.842]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.842]                   signalCondition(cond)
[13:34:36.842]                 }
[13:34:36.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.842]                 "immediateCondition"))) {
[13:34:36.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.842]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.842]                   if (TRUE && !signal) {
[13:34:36.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.842]                     {
[13:34:36.842]                       inherits <- base::inherits
[13:34:36.842]                       invokeRestart <- base::invokeRestart
[13:34:36.842]                       is.null <- base::is.null
[13:34:36.842]                       muffled <- FALSE
[13:34:36.842]                       if (inherits(cond, "message")) {
[13:34:36.842]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.842]                         if (muffled) 
[13:34:36.842]                           invokeRestart("muffleMessage")
[13:34:36.842]                       }
[13:34:36.842]                       else if (inherits(cond, "warning")) {
[13:34:36.842]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.842]                         if (muffled) 
[13:34:36.842]                           invokeRestart("muffleWarning")
[13:34:36.842]                       }
[13:34:36.842]                       else if (inherits(cond, "condition")) {
[13:34:36.842]                         if (!is.null(pattern)) {
[13:34:36.842]                           computeRestarts <- base::computeRestarts
[13:34:36.842]                           grepl <- base::grepl
[13:34:36.842]                           restarts <- computeRestarts(cond)
[13:34:36.842]                           for (restart in restarts) {
[13:34:36.842]                             name <- restart$name
[13:34:36.842]                             if (is.null(name)) 
[13:34:36.842]                               next
[13:34:36.842]                             if (!grepl(pattern, name)) 
[13:34:36.842]                               next
[13:34:36.842]                             invokeRestart(restart)
[13:34:36.842]                             muffled <- TRUE
[13:34:36.842]                             break
[13:34:36.842]                           }
[13:34:36.842]                         }
[13:34:36.842]                       }
[13:34:36.842]                       invisible(muffled)
[13:34:36.842]                     }
[13:34:36.842]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.842]                   }
[13:34:36.842]                 }
[13:34:36.842]                 else {
[13:34:36.842]                   if (TRUE) {
[13:34:36.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.842]                     {
[13:34:36.842]                       inherits <- base::inherits
[13:34:36.842]                       invokeRestart <- base::invokeRestart
[13:34:36.842]                       is.null <- base::is.null
[13:34:36.842]                       muffled <- FALSE
[13:34:36.842]                       if (inherits(cond, "message")) {
[13:34:36.842]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.842]                         if (muffled) 
[13:34:36.842]                           invokeRestart("muffleMessage")
[13:34:36.842]                       }
[13:34:36.842]                       else if (inherits(cond, "warning")) {
[13:34:36.842]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.842]                         if (muffled) 
[13:34:36.842]                           invokeRestart("muffleWarning")
[13:34:36.842]                       }
[13:34:36.842]                       else if (inherits(cond, "condition")) {
[13:34:36.842]                         if (!is.null(pattern)) {
[13:34:36.842]                           computeRestarts <- base::computeRestarts
[13:34:36.842]                           grepl <- base::grepl
[13:34:36.842]                           restarts <- computeRestarts(cond)
[13:34:36.842]                           for (restart in restarts) {
[13:34:36.842]                             name <- restart$name
[13:34:36.842]                             if (is.null(name)) 
[13:34:36.842]                               next
[13:34:36.842]                             if (!grepl(pattern, name)) 
[13:34:36.842]                               next
[13:34:36.842]                             invokeRestart(restart)
[13:34:36.842]                             muffled <- TRUE
[13:34:36.842]                             break
[13:34:36.842]                           }
[13:34:36.842]                         }
[13:34:36.842]                       }
[13:34:36.842]                       invisible(muffled)
[13:34:36.842]                     }
[13:34:36.842]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.842]                   }
[13:34:36.842]                 }
[13:34:36.842]             }
[13:34:36.842]         }))
[13:34:36.842]     }, error = function(ex) {
[13:34:36.842]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.842]                 ...future.rng), started = ...future.startTime, 
[13:34:36.842]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.842]             version = "1.8"), class = "FutureResult")
[13:34:36.842]     }, finally = {
[13:34:36.842]         if (!identical(...future.workdir, getwd())) 
[13:34:36.842]             setwd(...future.workdir)
[13:34:36.842]         {
[13:34:36.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.842]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.842]             }
[13:34:36.842]             base::options(...future.oldOptions)
[13:34:36.842]             if (.Platform$OS.type == "windows") {
[13:34:36.842]                 old_names <- names(...future.oldEnvVars)
[13:34:36.842]                 envs <- base::Sys.getenv()
[13:34:36.842]                 names <- names(envs)
[13:34:36.842]                 common <- intersect(names, old_names)
[13:34:36.842]                 added <- setdiff(names, old_names)
[13:34:36.842]                 removed <- setdiff(old_names, names)
[13:34:36.842]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.842]                   envs[common]]
[13:34:36.842]                 NAMES <- toupper(changed)
[13:34:36.842]                 args <- list()
[13:34:36.842]                 for (kk in seq_along(NAMES)) {
[13:34:36.842]                   name <- changed[[kk]]
[13:34:36.842]                   NAME <- NAMES[[kk]]
[13:34:36.842]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.842]                     next
[13:34:36.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.842]                 }
[13:34:36.842]                 NAMES <- toupper(added)
[13:34:36.842]                 for (kk in seq_along(NAMES)) {
[13:34:36.842]                   name <- added[[kk]]
[13:34:36.842]                   NAME <- NAMES[[kk]]
[13:34:36.842]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.842]                     next
[13:34:36.842]                   args[[name]] <- ""
[13:34:36.842]                 }
[13:34:36.842]                 NAMES <- toupper(removed)
[13:34:36.842]                 for (kk in seq_along(NAMES)) {
[13:34:36.842]                   name <- removed[[kk]]
[13:34:36.842]                   NAME <- NAMES[[kk]]
[13:34:36.842]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.842]                     next
[13:34:36.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.842]                 }
[13:34:36.842]                 if (length(args) > 0) 
[13:34:36.842]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.842]             }
[13:34:36.842]             else {
[13:34:36.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.842]             }
[13:34:36.842]             {
[13:34:36.842]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.842]                   0L) {
[13:34:36.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.842]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.842]                   base::options(opts)
[13:34:36.842]                 }
[13:34:36.842]                 {
[13:34:36.842]                   {
[13:34:36.842]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.842]                     NULL
[13:34:36.842]                   }
[13:34:36.842]                   options(future.plan = NULL)
[13:34:36.842]                   if (is.na(NA_character_)) 
[13:34:36.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.842]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.842]                     .init = FALSE)
[13:34:36.842]                 }
[13:34:36.842]             }
[13:34:36.842]         }
[13:34:36.842]     })
[13:34:36.842]     if (TRUE) {
[13:34:36.842]         base::sink(type = "output", split = FALSE)
[13:34:36.842]         if (TRUE) {
[13:34:36.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.842]         }
[13:34:36.842]         else {
[13:34:36.842]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.842]         }
[13:34:36.842]         base::close(...future.stdout)
[13:34:36.842]         ...future.stdout <- NULL
[13:34:36.842]     }
[13:34:36.842]     ...future.result$conditions <- ...future.conditions
[13:34:36.842]     ...future.result$finished <- base::Sys.time()
[13:34:36.842]     ...future.result
[13:34:36.842] }
[13:34:36.846] assign_globals() ...
[13:34:36.846] List of 5
[13:34:36.846]  $ ...future.FUN            :function (x, y)  
[13:34:36.846]  $ MoreArgs                 :List of 1
[13:34:36.846]   ..$ y: int [1:2] 3 4
[13:34:36.846]  $ ...future.elements_ii    :List of 1
[13:34:36.846]   ..$ x:List of 1
[13:34:36.846]   .. ..$ : int 2
[13:34:36.846]  $ ...future.seeds_ii       : NULL
[13:34:36.846]  $ ...future.globals.maxSize: NULL
[13:34:36.846]  - attr(*, "where")=List of 5
[13:34:36.846]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.846]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.846]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.846]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.846]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.846]  - attr(*, "resolved")= logi FALSE
[13:34:36.846]  - attr(*, "total_size")= num 1816
[13:34:36.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.846]  - attr(*, "already-done")= logi TRUE
[13:34:36.856] - reassign environment for ‘...future.FUN’
[13:34:36.856] - copied ‘...future.FUN’ to environment
[13:34:36.856] - copied ‘MoreArgs’ to environment
[13:34:36.856] - copied ‘...future.elements_ii’ to environment
[13:34:36.856] - copied ‘...future.seeds_ii’ to environment
[13:34:36.856] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.857] assign_globals() ... done
[13:34:36.857] requestCore(): workers = 2
[13:34:36.859] MulticoreFuture started
[13:34:36.859] - Launch lazy future ... done
[13:34:36.860] run() for ‘MulticoreFuture’ ... done
[13:34:36.860] plan(): Setting new future strategy stack:
[13:34:36.860] Created future:
[13:34:36.860] List of future strategies:
[13:34:36.860] 1. sequential:
[13:34:36.860]    - args: function (..., envir = parent.frame())
[13:34:36.860]    - tweaked: FALSE
[13:34:36.860]    - call: NULL
[13:34:36.861] plan(): nbrOfWorkers() = 1
[13:34:36.864] plan(): Setting new future strategy stack:
[13:34:36.864] List of future strategies:
[13:34:36.864] 1. multicore:
[13:34:36.864]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.864]    - tweaked: FALSE
[13:34:36.864]    - call: plan(strategy)
[13:34:36.870] plan(): nbrOfWorkers() = 2
[13:34:36.861] MulticoreFuture:
[13:34:36.861] Label: ‘future_.mapply-2’
[13:34:36.861] Expression:
[13:34:36.861] {
[13:34:36.861]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.861]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.861]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.861]         on.exit(options(oopts), add = TRUE)
[13:34:36.861]     }
[13:34:36.861]     {
[13:34:36.861]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.861]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.861]         do.call(mapply, args = args)
[13:34:36.861]     }
[13:34:36.861] }
[13:34:36.861] Lazy evaluation: FALSE
[13:34:36.861] Asynchronous evaluation: TRUE
[13:34:36.861] Local evaluation: TRUE
[13:34:36.861] Environment: R_GlobalEnv
[13:34:36.861] Capture standard output: TRUE
[13:34:36.861] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.861] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.861] Packages: <none>
[13:34:36.861] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.861] Resolved: TRUE
[13:34:36.861] Value: <not collected>
[13:34:36.861] Conditions captured: <none>
[13:34:36.861] Early signaling: FALSE
[13:34:36.861] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.861] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.871] Chunk #2 of 2 ... DONE
[13:34:36.871] Launching 2 futures (chunks) ... DONE
[13:34:36.871] Resolving 2 futures (chunks) ...
[13:34:36.872] resolve() on list ...
[13:34:36.872]  recursive: 0
[13:34:36.872]  length: 2
[13:34:36.872] 
[13:34:36.872] Future #1
[13:34:36.873] result() for MulticoreFuture ...
[13:34:36.874] result() for MulticoreFuture ...
[13:34:36.874] result() for MulticoreFuture ... done
[13:34:36.874] result() for MulticoreFuture ... done
[13:34:36.874] result() for MulticoreFuture ...
[13:34:36.875] result() for MulticoreFuture ... done
[13:34:36.875] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:36.875] - nx: 2
[13:34:36.875] - relay: TRUE
[13:34:36.875] - stdout: TRUE
[13:34:36.876] - signal: TRUE
[13:34:36.876] - resignal: FALSE
[13:34:36.876] - force: TRUE
[13:34:36.876] - relayed: [n=2] FALSE, FALSE
[13:34:36.877] - queued futures: [n=2] FALSE, FALSE
[13:34:36.877]  - until=1
[13:34:36.877]  - relaying element #1
[13:34:36.877] result() for MulticoreFuture ...
[13:34:36.877] result() for MulticoreFuture ... done
[13:34:36.878] result() for MulticoreFuture ...
[13:34:36.878] result() for MulticoreFuture ... done
[13:34:36.878] result() for MulticoreFuture ...
[13:34:36.878] result() for MulticoreFuture ... done
[13:34:36.878] result() for MulticoreFuture ...
[13:34:36.878] result() for MulticoreFuture ... done
[13:34:36.879] - relayed: [n=2] TRUE, FALSE
[13:34:36.879] - queued futures: [n=2] TRUE, FALSE
[13:34:36.879] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:36.879]  length: 1 (resolved future 1)
[13:34:36.879] Future #2
[13:34:36.880] result() for MulticoreFuture ...
[13:34:36.880] result() for MulticoreFuture ...
[13:34:36.880] result() for MulticoreFuture ... done
[13:34:36.881] result() for MulticoreFuture ... done
[13:34:36.881] result() for MulticoreFuture ...
[13:34:36.881] result() for MulticoreFuture ... done
[13:34:36.881] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:36.881] - nx: 2
[13:34:36.881] - relay: TRUE
[13:34:36.882] - stdout: TRUE
[13:34:36.882] - signal: TRUE
[13:34:36.882] - resignal: FALSE
[13:34:36.882] - force: TRUE
[13:34:36.882] - relayed: [n=2] TRUE, FALSE
[13:34:36.882] - queued futures: [n=2] TRUE, FALSE
[13:34:36.882]  - until=2
[13:34:36.882]  - relaying element #2
[13:34:36.883] result() for MulticoreFuture ...
[13:34:36.883] result() for MulticoreFuture ... done
[13:34:36.883] result() for MulticoreFuture ...
[13:34:36.883] result() for MulticoreFuture ... done
[13:34:36.883] result() for MulticoreFuture ...
[13:34:36.883] result() for MulticoreFuture ... done
[13:34:36.883] result() for MulticoreFuture ...
[13:34:36.883] result() for MulticoreFuture ... done
[13:34:36.883] - relayed: [n=2] TRUE, TRUE
[13:34:36.884] - queued futures: [n=2] TRUE, TRUE
[13:34:36.884] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:36.884]  length: 0 (resolved future 2)
[13:34:36.884] Relaying remaining futures
[13:34:36.884] signalConditionsASAP(NULL, pos=0) ...
[13:34:36.884] - nx: 2
[13:34:36.884] - relay: TRUE
[13:34:36.884] - stdout: TRUE
[13:34:36.885] - signal: TRUE
[13:34:36.885] - resignal: FALSE
[13:34:36.885] - force: TRUE
[13:34:36.885] - relayed: [n=2] TRUE, TRUE
[13:34:36.885] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:36.885] - relayed: [n=2] TRUE, TRUE
[13:34:36.885] - queued futures: [n=2] TRUE, TRUE
[13:34:36.885] signalConditionsASAP(NULL, pos=0) ... done
[13:34:36.885] resolve() on list ... DONE
[13:34:36.886] result() for MulticoreFuture ...
[13:34:36.886] result() for MulticoreFuture ... done
[13:34:36.886] result() for MulticoreFuture ...
[13:34:36.889] result() for MulticoreFuture ... done
[13:34:36.889] result() for MulticoreFuture ...
[13:34:36.889] result() for MulticoreFuture ... done
[13:34:36.890] result() for MulticoreFuture ...
[13:34:36.890] result() for MulticoreFuture ... done
[13:34:36.890]  - Number of value chunks collected: 2
[13:34:36.890] Resolving 2 futures (chunks) ... DONE
[13:34:36.890] Reducing values from 2 chunks ...
[13:34:36.890]  - Number of values collected after concatenation: 2
[13:34:36.890]  - Number of values expected: 2
[13:34:36.891] Reducing values from 2 chunks ... DONE
[13:34:36.891] future_mapply() ... DONE
- Recycle arguments to same length ...
[13:34:36.891] future_mapply() ...
[13:34:36.896] Number of chunks: 2
[13:34:36.896] getGlobalsAndPackagesXApply() ...
[13:34:36.896]  - future.globals: TRUE
[13:34:36.896] getGlobalsAndPackages() ...
[13:34:36.896] Searching for globals...
[13:34:36.897] - globals found: [1] ‘FUN’
[13:34:36.897] Searching for globals ... DONE
[13:34:36.897] Resolving globals: FALSE
[13:34:36.898] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:36.898] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:36.898] - globals: [1] ‘FUN’
[13:34:36.899] 
[13:34:36.899] getGlobalsAndPackages() ... DONE
[13:34:36.899]  - globals found/used: [n=1] ‘FUN’
[13:34:36.899]  - needed namespaces: [n=0] 
[13:34:36.899] Finding globals ... DONE
[13:34:36.899] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:36.900] List of 2
[13:34:36.900]  $ ...future.FUN:function (x, ...)  
[13:34:36.900]  $ MoreArgs     : NULL
[13:34:36.900]  - attr(*, "where")=List of 2
[13:34:36.900]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:36.900]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:36.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.900]  - attr(*, "resolved")= logi FALSE
[13:34:36.900]  - attr(*, "total_size")= num NA
[13:34:36.903] Packages to be attached in all futures: [n=0] 
[13:34:36.903] getGlobalsAndPackagesXApply() ... DONE
[13:34:36.903] Number of futures (= number of chunks): 2
[13:34:36.903] Launching 2 futures (chunks) ...
[13:34:36.903] Chunk #1 of 2 ...
[13:34:36.903]  - Finding globals in '...' for chunk #1 ...
[13:34:36.903] getGlobalsAndPackages() ...
[13:34:36.903] Searching for globals...
[13:34:36.904] 
[13:34:36.904] Searching for globals ... DONE
[13:34:36.904] - globals: [0] <none>
[13:34:36.904] getGlobalsAndPackages() ... DONE
[13:34:36.904]    + additional globals found: [n=0] 
[13:34:36.904]    + additional namespaces needed: [n=0] 
[13:34:36.904]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:36.904]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.905]  - seeds: <none>
[13:34:36.905]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.905] getGlobalsAndPackages() ...
[13:34:36.905] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.905] Resolving globals: FALSE
[13:34:36.905] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:36.906] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:36.906] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.906] 
[13:34:36.906] getGlobalsAndPackages() ... DONE
[13:34:36.907] run() for ‘Future’ ...
[13:34:36.907] - state: ‘created’
[13:34:36.907] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.910] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.911] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.911]   - Field: ‘label’
[13:34:36.911]   - Field: ‘local’
[13:34:36.911]   - Field: ‘owner’
[13:34:36.911]   - Field: ‘envir’
[13:34:36.911]   - Field: ‘workers’
[13:34:36.911]   - Field: ‘packages’
[13:34:36.911]   - Field: ‘gc’
[13:34:36.911]   - Field: ‘job’
[13:34:36.911]   - Field: ‘conditions’
[13:34:36.912]   - Field: ‘expr’
[13:34:36.912]   - Field: ‘uuid’
[13:34:36.912]   - Field: ‘seed’
[13:34:36.912]   - Field: ‘version’
[13:34:36.912]   - Field: ‘result’
[13:34:36.912]   - Field: ‘asynchronous’
[13:34:36.912]   - Field: ‘calls’
[13:34:36.912]   - Field: ‘globals’
[13:34:36.912]   - Field: ‘stdout’
[13:34:36.912]   - Field: ‘earlySignal’
[13:34:36.912]   - Field: ‘lazy’
[13:34:36.913]   - Field: ‘state’
[13:34:36.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.913] - Launch lazy future ...
[13:34:36.913] Packages needed by the future expression (n = 0): <none>
[13:34:36.913] Packages needed by future strategies (n = 0): <none>
[13:34:36.914] {
[13:34:36.914]     {
[13:34:36.914]         {
[13:34:36.914]             ...future.startTime <- base::Sys.time()
[13:34:36.914]             {
[13:34:36.914]                 {
[13:34:36.914]                   {
[13:34:36.914]                     {
[13:34:36.914]                       base::local({
[13:34:36.914]                         has_future <- base::requireNamespace("future", 
[13:34:36.914]                           quietly = TRUE)
[13:34:36.914]                         if (has_future) {
[13:34:36.914]                           ns <- base::getNamespace("future")
[13:34:36.914]                           version <- ns[[".package"]][["version"]]
[13:34:36.914]                           if (is.null(version)) 
[13:34:36.914]                             version <- utils::packageVersion("future")
[13:34:36.914]                         }
[13:34:36.914]                         else {
[13:34:36.914]                           version <- NULL
[13:34:36.914]                         }
[13:34:36.914]                         if (!has_future || version < "1.8.0") {
[13:34:36.914]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.914]                             "", base::R.version$version.string), 
[13:34:36.914]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.914]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.914]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.914]                               "release", "version")], collapse = " "), 
[13:34:36.914]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.914]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.914]                             info)
[13:34:36.914]                           info <- base::paste(info, collapse = "; ")
[13:34:36.914]                           if (!has_future) {
[13:34:36.914]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.914]                               info)
[13:34:36.914]                           }
[13:34:36.914]                           else {
[13:34:36.914]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.914]                               info, version)
[13:34:36.914]                           }
[13:34:36.914]                           base::stop(msg)
[13:34:36.914]                         }
[13:34:36.914]                       })
[13:34:36.914]                     }
[13:34:36.914]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.914]                     base::options(mc.cores = 1L)
[13:34:36.914]                   }
[13:34:36.914]                   ...future.strategy.old <- future::plan("list")
[13:34:36.914]                   options(future.plan = NULL)
[13:34:36.914]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.914]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.914]                 }
[13:34:36.914]                 ...future.workdir <- getwd()
[13:34:36.914]             }
[13:34:36.914]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.914]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.914]         }
[13:34:36.914]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.914]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.914]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.914]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.914]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.914]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.914]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.914]             base::names(...future.oldOptions))
[13:34:36.914]     }
[13:34:36.914]     if (FALSE) {
[13:34:36.914]     }
[13:34:36.914]     else {
[13:34:36.914]         if (TRUE) {
[13:34:36.914]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.914]                 open = "w")
[13:34:36.914]         }
[13:34:36.914]         else {
[13:34:36.914]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.914]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.914]         }
[13:34:36.914]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.914]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.914]             base::sink(type = "output", split = FALSE)
[13:34:36.914]             base::close(...future.stdout)
[13:34:36.914]         }, add = TRUE)
[13:34:36.914]     }
[13:34:36.914]     ...future.frame <- base::sys.nframe()
[13:34:36.914]     ...future.conditions <- base::list()
[13:34:36.914]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.914]     if (FALSE) {
[13:34:36.914]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.914]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.914]     }
[13:34:36.914]     ...future.result <- base::tryCatch({
[13:34:36.914]         base::withCallingHandlers({
[13:34:36.914]             ...future.value <- base::withVisible(base::local({
[13:34:36.914]                 withCallingHandlers({
[13:34:36.914]                   {
[13:34:36.914]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.914]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.914]                       ...future.globals.maxSize)) {
[13:34:36.914]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.914]                       on.exit(options(oopts), add = TRUE)
[13:34:36.914]                     }
[13:34:36.914]                     {
[13:34:36.914]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.914]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.914]                         USE.NAMES = FALSE)
[13:34:36.914]                       do.call(mapply, args = args)
[13:34:36.914]                     }
[13:34:36.914]                   }
[13:34:36.914]                 }, immediateCondition = function(cond) {
[13:34:36.914]                   save_rds <- function (object, pathname, ...) 
[13:34:36.914]                   {
[13:34:36.914]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.914]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.914]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.914]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.914]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.914]                         fi_tmp[["mtime"]])
[13:34:36.914]                     }
[13:34:36.914]                     tryCatch({
[13:34:36.914]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.914]                     }, error = function(ex) {
[13:34:36.914]                       msg <- conditionMessage(ex)
[13:34:36.914]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.914]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.914]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.914]                         fi_tmp[["mtime"]], msg)
[13:34:36.914]                       ex$message <- msg
[13:34:36.914]                       stop(ex)
[13:34:36.914]                     })
[13:34:36.914]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.914]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.914]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.914]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.914]                       fi <- file.info(pathname)
[13:34:36.914]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.914]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.914]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.914]                         fi[["size"]], fi[["mtime"]])
[13:34:36.914]                       stop(msg)
[13:34:36.914]                     }
[13:34:36.914]                     invisible(pathname)
[13:34:36.914]                   }
[13:34:36.914]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.914]                     rootPath = tempdir()) 
[13:34:36.914]                   {
[13:34:36.914]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.914]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.914]                       tmpdir = path, fileext = ".rds")
[13:34:36.914]                     save_rds(obj, file)
[13:34:36.914]                   }
[13:34:36.914]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.914]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.914]                   {
[13:34:36.914]                     inherits <- base::inherits
[13:34:36.914]                     invokeRestart <- base::invokeRestart
[13:34:36.914]                     is.null <- base::is.null
[13:34:36.914]                     muffled <- FALSE
[13:34:36.914]                     if (inherits(cond, "message")) {
[13:34:36.914]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.914]                       if (muffled) 
[13:34:36.914]                         invokeRestart("muffleMessage")
[13:34:36.914]                     }
[13:34:36.914]                     else if (inherits(cond, "warning")) {
[13:34:36.914]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.914]                       if (muffled) 
[13:34:36.914]                         invokeRestart("muffleWarning")
[13:34:36.914]                     }
[13:34:36.914]                     else if (inherits(cond, "condition")) {
[13:34:36.914]                       if (!is.null(pattern)) {
[13:34:36.914]                         computeRestarts <- base::computeRestarts
[13:34:36.914]                         grepl <- base::grepl
[13:34:36.914]                         restarts <- computeRestarts(cond)
[13:34:36.914]                         for (restart in restarts) {
[13:34:36.914]                           name <- restart$name
[13:34:36.914]                           if (is.null(name)) 
[13:34:36.914]                             next
[13:34:36.914]                           if (!grepl(pattern, name)) 
[13:34:36.914]                             next
[13:34:36.914]                           invokeRestart(restart)
[13:34:36.914]                           muffled <- TRUE
[13:34:36.914]                           break
[13:34:36.914]                         }
[13:34:36.914]                       }
[13:34:36.914]                     }
[13:34:36.914]                     invisible(muffled)
[13:34:36.914]                   }
[13:34:36.914]                   muffleCondition(cond)
[13:34:36.914]                 })
[13:34:36.914]             }))
[13:34:36.914]             future::FutureResult(value = ...future.value$value, 
[13:34:36.914]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.914]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.914]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.914]                     ...future.globalenv.names))
[13:34:36.914]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.914]         }, condition = base::local({
[13:34:36.914]             c <- base::c
[13:34:36.914]             inherits <- base::inherits
[13:34:36.914]             invokeRestart <- base::invokeRestart
[13:34:36.914]             length <- base::length
[13:34:36.914]             list <- base::list
[13:34:36.914]             seq.int <- base::seq.int
[13:34:36.914]             signalCondition <- base::signalCondition
[13:34:36.914]             sys.calls <- base::sys.calls
[13:34:36.914]             `[[` <- base::`[[`
[13:34:36.914]             `+` <- base::`+`
[13:34:36.914]             `<<-` <- base::`<<-`
[13:34:36.914]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.914]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.914]                   3L)]
[13:34:36.914]             }
[13:34:36.914]             function(cond) {
[13:34:36.914]                 is_error <- inherits(cond, "error")
[13:34:36.914]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.914]                   NULL)
[13:34:36.914]                 if (is_error) {
[13:34:36.914]                   sessionInformation <- function() {
[13:34:36.914]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.914]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.914]                       search = base::search(), system = base::Sys.info())
[13:34:36.914]                   }
[13:34:36.914]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.914]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.914]                     cond$call), session = sessionInformation(), 
[13:34:36.914]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.914]                   signalCondition(cond)
[13:34:36.914]                 }
[13:34:36.914]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.914]                 "immediateCondition"))) {
[13:34:36.914]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.914]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.914]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.914]                   if (TRUE && !signal) {
[13:34:36.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.914]                     {
[13:34:36.914]                       inherits <- base::inherits
[13:34:36.914]                       invokeRestart <- base::invokeRestart
[13:34:36.914]                       is.null <- base::is.null
[13:34:36.914]                       muffled <- FALSE
[13:34:36.914]                       if (inherits(cond, "message")) {
[13:34:36.914]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.914]                         if (muffled) 
[13:34:36.914]                           invokeRestart("muffleMessage")
[13:34:36.914]                       }
[13:34:36.914]                       else if (inherits(cond, "warning")) {
[13:34:36.914]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.914]                         if (muffled) 
[13:34:36.914]                           invokeRestart("muffleWarning")
[13:34:36.914]                       }
[13:34:36.914]                       else if (inherits(cond, "condition")) {
[13:34:36.914]                         if (!is.null(pattern)) {
[13:34:36.914]                           computeRestarts <- base::computeRestarts
[13:34:36.914]                           grepl <- base::grepl
[13:34:36.914]                           restarts <- computeRestarts(cond)
[13:34:36.914]                           for (restart in restarts) {
[13:34:36.914]                             name <- restart$name
[13:34:36.914]                             if (is.null(name)) 
[13:34:36.914]                               next
[13:34:36.914]                             if (!grepl(pattern, name)) 
[13:34:36.914]                               next
[13:34:36.914]                             invokeRestart(restart)
[13:34:36.914]                             muffled <- TRUE
[13:34:36.914]                             break
[13:34:36.914]                           }
[13:34:36.914]                         }
[13:34:36.914]                       }
[13:34:36.914]                       invisible(muffled)
[13:34:36.914]                     }
[13:34:36.914]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.914]                   }
[13:34:36.914]                 }
[13:34:36.914]                 else {
[13:34:36.914]                   if (TRUE) {
[13:34:36.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.914]                     {
[13:34:36.914]                       inherits <- base::inherits
[13:34:36.914]                       invokeRestart <- base::invokeRestart
[13:34:36.914]                       is.null <- base::is.null
[13:34:36.914]                       muffled <- FALSE
[13:34:36.914]                       if (inherits(cond, "message")) {
[13:34:36.914]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.914]                         if (muffled) 
[13:34:36.914]                           invokeRestart("muffleMessage")
[13:34:36.914]                       }
[13:34:36.914]                       else if (inherits(cond, "warning")) {
[13:34:36.914]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.914]                         if (muffled) 
[13:34:36.914]                           invokeRestart("muffleWarning")
[13:34:36.914]                       }
[13:34:36.914]                       else if (inherits(cond, "condition")) {
[13:34:36.914]                         if (!is.null(pattern)) {
[13:34:36.914]                           computeRestarts <- base::computeRestarts
[13:34:36.914]                           grepl <- base::grepl
[13:34:36.914]                           restarts <- computeRestarts(cond)
[13:34:36.914]                           for (restart in restarts) {
[13:34:36.914]                             name <- restart$name
[13:34:36.914]                             if (is.null(name)) 
[13:34:36.914]                               next
[13:34:36.914]                             if (!grepl(pattern, name)) 
[13:34:36.914]                               next
[13:34:36.914]                             invokeRestart(restart)
[13:34:36.914]                             muffled <- TRUE
[13:34:36.914]                             break
[13:34:36.914]                           }
[13:34:36.914]                         }
[13:34:36.914]                       }
[13:34:36.914]                       invisible(muffled)
[13:34:36.914]                     }
[13:34:36.914]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.914]                   }
[13:34:36.914]                 }
[13:34:36.914]             }
[13:34:36.914]         }))
[13:34:36.914]     }, error = function(ex) {
[13:34:36.914]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.914]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.914]                 ...future.rng), started = ...future.startTime, 
[13:34:36.914]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.914]             version = "1.8"), class = "FutureResult")
[13:34:36.914]     }, finally = {
[13:34:36.914]         if (!identical(...future.workdir, getwd())) 
[13:34:36.914]             setwd(...future.workdir)
[13:34:36.914]         {
[13:34:36.914]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.914]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.914]             }
[13:34:36.914]             base::options(...future.oldOptions)
[13:34:36.914]             if (.Platform$OS.type == "windows") {
[13:34:36.914]                 old_names <- names(...future.oldEnvVars)
[13:34:36.914]                 envs <- base::Sys.getenv()
[13:34:36.914]                 names <- names(envs)
[13:34:36.914]                 common <- intersect(names, old_names)
[13:34:36.914]                 added <- setdiff(names, old_names)
[13:34:36.914]                 removed <- setdiff(old_names, names)
[13:34:36.914]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.914]                   envs[common]]
[13:34:36.914]                 NAMES <- toupper(changed)
[13:34:36.914]                 args <- list()
[13:34:36.914]                 for (kk in seq_along(NAMES)) {
[13:34:36.914]                   name <- changed[[kk]]
[13:34:36.914]                   NAME <- NAMES[[kk]]
[13:34:36.914]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.914]                     next
[13:34:36.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.914]                 }
[13:34:36.914]                 NAMES <- toupper(added)
[13:34:36.914]                 for (kk in seq_along(NAMES)) {
[13:34:36.914]                   name <- added[[kk]]
[13:34:36.914]                   NAME <- NAMES[[kk]]
[13:34:36.914]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.914]                     next
[13:34:36.914]                   args[[name]] <- ""
[13:34:36.914]                 }
[13:34:36.914]                 NAMES <- toupper(removed)
[13:34:36.914]                 for (kk in seq_along(NAMES)) {
[13:34:36.914]                   name <- removed[[kk]]
[13:34:36.914]                   NAME <- NAMES[[kk]]
[13:34:36.914]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.914]                     next
[13:34:36.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.914]                 }
[13:34:36.914]                 if (length(args) > 0) 
[13:34:36.914]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.914]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.914]             }
[13:34:36.914]             else {
[13:34:36.914]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.914]             }
[13:34:36.914]             {
[13:34:36.914]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.914]                   0L) {
[13:34:36.914]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.914]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.914]                   base::options(opts)
[13:34:36.914]                 }
[13:34:36.914]                 {
[13:34:36.914]                   {
[13:34:36.914]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.914]                     NULL
[13:34:36.914]                   }
[13:34:36.914]                   options(future.plan = NULL)
[13:34:36.914]                   if (is.na(NA_character_)) 
[13:34:36.914]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.914]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.914]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.914]                     .init = FALSE)
[13:34:36.914]                 }
[13:34:36.914]             }
[13:34:36.914]         }
[13:34:36.914]     })
[13:34:36.914]     if (TRUE) {
[13:34:36.914]         base::sink(type = "output", split = FALSE)
[13:34:36.914]         if (TRUE) {
[13:34:36.914]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.914]         }
[13:34:36.914]         else {
[13:34:36.914]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.914]         }
[13:34:36.914]         base::close(...future.stdout)
[13:34:36.914]         ...future.stdout <- NULL
[13:34:36.914]     }
[13:34:36.914]     ...future.result$conditions <- ...future.conditions
[13:34:36.914]     ...future.result$finished <- base::Sys.time()
[13:34:36.914]     ...future.result
[13:34:36.914] }
[13:34:36.916] assign_globals() ...
[13:34:36.916] List of 5
[13:34:36.916]  $ ...future.FUN            :function (x, ...)  
[13:34:36.916]  $ MoreArgs                 : NULL
[13:34:36.916]  $ ...future.elements_ii    :List of 2
[13:34:36.916]   ..$ :List of 2
[13:34:36.916]   .. ..$ : int 1
[13:34:36.916]   .. ..$ : int 2
[13:34:36.916]   ..$ :List of 2
[13:34:36.916]   .. ..$ : int 2
[13:34:36.916]   .. ..$ : int 1
[13:34:36.916]  $ ...future.seeds_ii       : NULL
[13:34:36.916]  $ ...future.globals.maxSize: NULL
[13:34:36.916]  - attr(*, "where")=List of 5
[13:34:36.916]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.916]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.916]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.916]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.916]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.916]  - attr(*, "resolved")= logi FALSE
[13:34:36.916]  - attr(*, "total_size")= num 280
[13:34:36.916]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.916]  - attr(*, "already-done")= logi TRUE
[13:34:36.925] - copied ‘...future.FUN’ to environment
[13:34:36.925] - copied ‘MoreArgs’ to environment
[13:34:36.925] - copied ‘...future.elements_ii’ to environment
[13:34:36.925] - copied ‘...future.seeds_ii’ to environment
[13:34:36.925] - copied ‘...future.globals.maxSize’ to environment
[13:34:36.926] assign_globals() ... done
[13:34:36.926] requestCore(): workers = 2
[13:34:36.928] MulticoreFuture started
[13:34:36.928] - Launch lazy future ... done
[13:34:36.929] run() for ‘MulticoreFuture’ ... done
[13:34:36.929] plan(): Setting new future strategy stack:
[13:34:36.929] Created future:
[13:34:36.929] List of future strategies:
[13:34:36.929] 1. sequential:
[13:34:36.929]    - args: function (..., envir = parent.frame())
[13:34:36.929]    - tweaked: FALSE
[13:34:36.929]    - call: NULL
[13:34:36.930] plan(): nbrOfWorkers() = 1
[13:34:36.933] plan(): Setting new future strategy stack:
[13:34:36.933] List of future strategies:
[13:34:36.933] 1. multicore:
[13:34:36.933]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:36.933]    - tweaked: FALSE
[13:34:36.933]    - call: plan(strategy)
[13:34:36.939] plan(): nbrOfWorkers() = 2
[13:34:36.929] MulticoreFuture:
[13:34:36.929] Label: ‘future_mapply-1’
[13:34:36.929] Expression:
[13:34:36.929] {
[13:34:36.929]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.929]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:36.929]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.929]         on.exit(options(oopts), add = TRUE)
[13:34:36.929]     }
[13:34:36.929]     {
[13:34:36.929]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.929]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:36.929]         do.call(mapply, args = args)
[13:34:36.929]     }
[13:34:36.929] }
[13:34:36.929] Lazy evaluation: FALSE
[13:34:36.929] Asynchronous evaluation: TRUE
[13:34:36.929] Local evaluation: TRUE
[13:34:36.929] Environment: R_GlobalEnv
[13:34:36.929] Capture standard output: TRUE
[13:34:36.929] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:36.929] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:36.929] Packages: <none>
[13:34:36.929] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:36.929] Resolved: TRUE
[13:34:36.929] Value: <not collected>
[13:34:36.929] Conditions captured: <none>
[13:34:36.929] Early signaling: FALSE
[13:34:36.929] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:36.929] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.940] Chunk #1 of 2 ... DONE
[13:34:36.940] Chunk #2 of 2 ...
[13:34:36.940]  - Finding globals in '...' for chunk #2 ...
[13:34:36.941] getGlobalsAndPackages() ...
[13:34:36.941] Searching for globals...
[13:34:36.941] 
[13:34:36.942] Searching for globals ... DONE
[13:34:36.942] - globals: [0] <none>
[13:34:36.942] getGlobalsAndPackages() ... DONE
[13:34:36.942]    + additional globals found: [n=0] 
[13:34:36.942]    + additional namespaces needed: [n=0] 
[13:34:36.942]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:36.943]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:36.943]  - seeds: <none>
[13:34:36.943]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.943] getGlobalsAndPackages() ...
[13:34:36.943] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.944] Resolving globals: FALSE
[13:34:36.944] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:36.945] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:36.945] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:36.946] 
[13:34:36.946] getGlobalsAndPackages() ... DONE
[13:34:36.946] run() for ‘Future’ ...
[13:34:36.946] - state: ‘created’
[13:34:36.947] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:36.951] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:36.951] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:36.952]   - Field: ‘label’
[13:34:36.952]   - Field: ‘local’
[13:34:36.952]   - Field: ‘owner’
[13:34:36.952]   - Field: ‘envir’
[13:34:36.952]   - Field: ‘workers’
[13:34:36.952]   - Field: ‘packages’
[13:34:36.953]   - Field: ‘gc’
[13:34:36.953]   - Field: ‘job’
[13:34:36.953]   - Field: ‘conditions’
[13:34:36.953]   - Field: ‘expr’
[13:34:36.953]   - Field: ‘uuid’
[13:34:36.953]   - Field: ‘seed’
[13:34:36.954]   - Field: ‘version’
[13:34:36.954]   - Field: ‘result’
[13:34:36.954]   - Field: ‘asynchronous’
[13:34:36.954]   - Field: ‘calls’
[13:34:36.954]   - Field: ‘globals’
[13:34:36.954]   - Field: ‘stdout’
[13:34:36.954]   - Field: ‘earlySignal’
[13:34:36.955]   - Field: ‘lazy’
[13:34:36.955]   - Field: ‘state’
[13:34:36.955] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:36.955] - Launch lazy future ...
[13:34:36.956] Packages needed by the future expression (n = 0): <none>
[13:34:36.956] Packages needed by future strategies (n = 0): <none>
[13:34:36.956] {
[13:34:36.956]     {
[13:34:36.956]         {
[13:34:36.956]             ...future.startTime <- base::Sys.time()
[13:34:36.956]             {
[13:34:36.956]                 {
[13:34:36.956]                   {
[13:34:36.956]                     {
[13:34:36.956]                       base::local({
[13:34:36.956]                         has_future <- base::requireNamespace("future", 
[13:34:36.956]                           quietly = TRUE)
[13:34:36.956]                         if (has_future) {
[13:34:36.956]                           ns <- base::getNamespace("future")
[13:34:36.956]                           version <- ns[[".package"]][["version"]]
[13:34:36.956]                           if (is.null(version)) 
[13:34:36.956]                             version <- utils::packageVersion("future")
[13:34:36.956]                         }
[13:34:36.956]                         else {
[13:34:36.956]                           version <- NULL
[13:34:36.956]                         }
[13:34:36.956]                         if (!has_future || version < "1.8.0") {
[13:34:36.956]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:36.956]                             "", base::R.version$version.string), 
[13:34:36.956]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:36.956]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:36.956]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:36.956]                               "release", "version")], collapse = " "), 
[13:34:36.956]                             hostname = base::Sys.info()[["nodename"]])
[13:34:36.956]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:36.956]                             info)
[13:34:36.956]                           info <- base::paste(info, collapse = "; ")
[13:34:36.956]                           if (!has_future) {
[13:34:36.956]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:36.956]                               info)
[13:34:36.956]                           }
[13:34:36.956]                           else {
[13:34:36.956]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:36.956]                               info, version)
[13:34:36.956]                           }
[13:34:36.956]                           base::stop(msg)
[13:34:36.956]                         }
[13:34:36.956]                       })
[13:34:36.956]                     }
[13:34:36.956]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:36.956]                     base::options(mc.cores = 1L)
[13:34:36.956]                   }
[13:34:36.956]                   ...future.strategy.old <- future::plan("list")
[13:34:36.956]                   options(future.plan = NULL)
[13:34:36.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:36.956]                 }
[13:34:36.956]                 ...future.workdir <- getwd()
[13:34:36.956]             }
[13:34:36.956]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:36.956]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:36.956]         }
[13:34:36.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:36.956]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:36.956]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:36.956]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:36.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:36.956]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:36.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:36.956]             base::names(...future.oldOptions))
[13:34:36.956]     }
[13:34:36.956]     if (FALSE) {
[13:34:36.956]     }
[13:34:36.956]     else {
[13:34:36.956]         if (TRUE) {
[13:34:36.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:36.956]                 open = "w")
[13:34:36.956]         }
[13:34:36.956]         else {
[13:34:36.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:36.956]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:36.956]         }
[13:34:36.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:36.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:36.956]             base::sink(type = "output", split = FALSE)
[13:34:36.956]             base::close(...future.stdout)
[13:34:36.956]         }, add = TRUE)
[13:34:36.956]     }
[13:34:36.956]     ...future.frame <- base::sys.nframe()
[13:34:36.956]     ...future.conditions <- base::list()
[13:34:36.956]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:36.956]     if (FALSE) {
[13:34:36.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:36.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:36.956]     }
[13:34:36.956]     ...future.result <- base::tryCatch({
[13:34:36.956]         base::withCallingHandlers({
[13:34:36.956]             ...future.value <- base::withVisible(base::local({
[13:34:36.956]                 withCallingHandlers({
[13:34:36.956]                   {
[13:34:36.956]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:36.956]                     if (!identical(...future.globals.maxSize.org, 
[13:34:36.956]                       ...future.globals.maxSize)) {
[13:34:36.956]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:36.956]                       on.exit(options(oopts), add = TRUE)
[13:34:36.956]                     }
[13:34:36.956]                     {
[13:34:36.956]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:36.956]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:36.956]                         USE.NAMES = FALSE)
[13:34:36.956]                       do.call(mapply, args = args)
[13:34:36.956]                     }
[13:34:36.956]                   }
[13:34:36.956]                 }, immediateCondition = function(cond) {
[13:34:36.956]                   save_rds <- function (object, pathname, ...) 
[13:34:36.956]                   {
[13:34:36.956]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:36.956]                     if (file_test("-f", pathname_tmp)) {
[13:34:36.956]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.956]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:36.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.956]                         fi_tmp[["mtime"]])
[13:34:36.956]                     }
[13:34:36.956]                     tryCatch({
[13:34:36.956]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:36.956]                     }, error = function(ex) {
[13:34:36.956]                       msg <- conditionMessage(ex)
[13:34:36.956]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.956]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:36.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.956]                         fi_tmp[["mtime"]], msg)
[13:34:36.956]                       ex$message <- msg
[13:34:36.956]                       stop(ex)
[13:34:36.956]                     })
[13:34:36.956]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:36.956]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:36.956]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:36.956]                       fi_tmp <- file.info(pathname_tmp)
[13:34:36.956]                       fi <- file.info(pathname)
[13:34:36.956]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:36.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:36.956]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:36.956]                         fi[["size"]], fi[["mtime"]])
[13:34:36.956]                       stop(msg)
[13:34:36.956]                     }
[13:34:36.956]                     invisible(pathname)
[13:34:36.956]                   }
[13:34:36.956]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:36.956]                     rootPath = tempdir()) 
[13:34:36.956]                   {
[13:34:36.956]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:36.956]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:36.956]                       tmpdir = path, fileext = ".rds")
[13:34:36.956]                     save_rds(obj, file)
[13:34:36.956]                   }
[13:34:36.956]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:36.956]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.956]                   {
[13:34:36.956]                     inherits <- base::inherits
[13:34:36.956]                     invokeRestart <- base::invokeRestart
[13:34:36.956]                     is.null <- base::is.null
[13:34:36.956]                     muffled <- FALSE
[13:34:36.956]                     if (inherits(cond, "message")) {
[13:34:36.956]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:36.956]                       if (muffled) 
[13:34:36.956]                         invokeRestart("muffleMessage")
[13:34:36.956]                     }
[13:34:36.956]                     else if (inherits(cond, "warning")) {
[13:34:36.956]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:36.956]                       if (muffled) 
[13:34:36.956]                         invokeRestart("muffleWarning")
[13:34:36.956]                     }
[13:34:36.956]                     else if (inherits(cond, "condition")) {
[13:34:36.956]                       if (!is.null(pattern)) {
[13:34:36.956]                         computeRestarts <- base::computeRestarts
[13:34:36.956]                         grepl <- base::grepl
[13:34:36.956]                         restarts <- computeRestarts(cond)
[13:34:36.956]                         for (restart in restarts) {
[13:34:36.956]                           name <- restart$name
[13:34:36.956]                           if (is.null(name)) 
[13:34:36.956]                             next
[13:34:36.956]                           if (!grepl(pattern, name)) 
[13:34:36.956]                             next
[13:34:36.956]                           invokeRestart(restart)
[13:34:36.956]                           muffled <- TRUE
[13:34:36.956]                           break
[13:34:36.956]                         }
[13:34:36.956]                       }
[13:34:36.956]                     }
[13:34:36.956]                     invisible(muffled)
[13:34:36.956]                   }
[13:34:36.956]                   muffleCondition(cond)
[13:34:36.956]                 })
[13:34:36.956]             }))
[13:34:36.956]             future::FutureResult(value = ...future.value$value, 
[13:34:36.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.956]                   ...future.rng), globalenv = if (FALSE) 
[13:34:36.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:36.956]                     ...future.globalenv.names))
[13:34:36.956]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:36.956]         }, condition = base::local({
[13:34:36.956]             c <- base::c
[13:34:36.956]             inherits <- base::inherits
[13:34:36.956]             invokeRestart <- base::invokeRestart
[13:34:36.956]             length <- base::length
[13:34:36.956]             list <- base::list
[13:34:36.956]             seq.int <- base::seq.int
[13:34:36.956]             signalCondition <- base::signalCondition
[13:34:36.956]             sys.calls <- base::sys.calls
[13:34:36.956]             `[[` <- base::`[[`
[13:34:36.956]             `+` <- base::`+`
[13:34:36.956]             `<<-` <- base::`<<-`
[13:34:36.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:36.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:36.956]                   3L)]
[13:34:36.956]             }
[13:34:36.956]             function(cond) {
[13:34:36.956]                 is_error <- inherits(cond, "error")
[13:34:36.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:36.956]                   NULL)
[13:34:36.956]                 if (is_error) {
[13:34:36.956]                   sessionInformation <- function() {
[13:34:36.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:36.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:36.956]                       search = base::search(), system = base::Sys.info())
[13:34:36.956]                   }
[13:34:36.956]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:36.956]                     cond$call), session = sessionInformation(), 
[13:34:36.956]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:36.956]                   signalCondition(cond)
[13:34:36.956]                 }
[13:34:36.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:36.956]                 "immediateCondition"))) {
[13:34:36.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:36.956]                   ...future.conditions[[length(...future.conditions) + 
[13:34:36.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:36.956]                   if (TRUE && !signal) {
[13:34:36.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.956]                     {
[13:34:36.956]                       inherits <- base::inherits
[13:34:36.956]                       invokeRestart <- base::invokeRestart
[13:34:36.956]                       is.null <- base::is.null
[13:34:36.956]                       muffled <- FALSE
[13:34:36.956]                       if (inherits(cond, "message")) {
[13:34:36.956]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.956]                         if (muffled) 
[13:34:36.956]                           invokeRestart("muffleMessage")
[13:34:36.956]                       }
[13:34:36.956]                       else if (inherits(cond, "warning")) {
[13:34:36.956]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.956]                         if (muffled) 
[13:34:36.956]                           invokeRestart("muffleWarning")
[13:34:36.956]                       }
[13:34:36.956]                       else if (inherits(cond, "condition")) {
[13:34:36.956]                         if (!is.null(pattern)) {
[13:34:36.956]                           computeRestarts <- base::computeRestarts
[13:34:36.956]                           grepl <- base::grepl
[13:34:36.956]                           restarts <- computeRestarts(cond)
[13:34:36.956]                           for (restart in restarts) {
[13:34:36.956]                             name <- restart$name
[13:34:36.956]                             if (is.null(name)) 
[13:34:36.956]                               next
[13:34:36.956]                             if (!grepl(pattern, name)) 
[13:34:36.956]                               next
[13:34:36.956]                             invokeRestart(restart)
[13:34:36.956]                             muffled <- TRUE
[13:34:36.956]                             break
[13:34:36.956]                           }
[13:34:36.956]                         }
[13:34:36.956]                       }
[13:34:36.956]                       invisible(muffled)
[13:34:36.956]                     }
[13:34:36.956]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.956]                   }
[13:34:36.956]                 }
[13:34:36.956]                 else {
[13:34:36.956]                   if (TRUE) {
[13:34:36.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:36.956]                     {
[13:34:36.956]                       inherits <- base::inherits
[13:34:36.956]                       invokeRestart <- base::invokeRestart
[13:34:36.956]                       is.null <- base::is.null
[13:34:36.956]                       muffled <- FALSE
[13:34:36.956]                       if (inherits(cond, "message")) {
[13:34:36.956]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:36.956]                         if (muffled) 
[13:34:36.956]                           invokeRestart("muffleMessage")
[13:34:36.956]                       }
[13:34:36.956]                       else if (inherits(cond, "warning")) {
[13:34:36.956]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:36.956]                         if (muffled) 
[13:34:36.956]                           invokeRestart("muffleWarning")
[13:34:36.956]                       }
[13:34:36.956]                       else if (inherits(cond, "condition")) {
[13:34:36.956]                         if (!is.null(pattern)) {
[13:34:36.956]                           computeRestarts <- base::computeRestarts
[13:34:36.956]                           grepl <- base::grepl
[13:34:36.956]                           restarts <- computeRestarts(cond)
[13:34:36.956]                           for (restart in restarts) {
[13:34:36.956]                             name <- restart$name
[13:34:36.956]                             if (is.null(name)) 
[13:34:36.956]                               next
[13:34:36.956]                             if (!grepl(pattern, name)) 
[13:34:36.956]                               next
[13:34:36.956]                             invokeRestart(restart)
[13:34:36.956]                             muffled <- TRUE
[13:34:36.956]                             break
[13:34:36.956]                           }
[13:34:36.956]                         }
[13:34:36.956]                       }
[13:34:36.956]                       invisible(muffled)
[13:34:36.956]                     }
[13:34:36.956]                     muffleCondition(cond, pattern = "^muffle")
[13:34:36.956]                   }
[13:34:36.956]                 }
[13:34:36.956]             }
[13:34:36.956]         }))
[13:34:36.956]     }, error = function(ex) {
[13:34:36.956]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:36.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:36.956]                 ...future.rng), started = ...future.startTime, 
[13:34:36.956]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:36.956]             version = "1.8"), class = "FutureResult")
[13:34:36.956]     }, finally = {
[13:34:36.956]         if (!identical(...future.workdir, getwd())) 
[13:34:36.956]             setwd(...future.workdir)
[13:34:36.956]         {
[13:34:36.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:36.956]                 ...future.oldOptions$nwarnings <- NULL
[13:34:36.956]             }
[13:34:36.956]             base::options(...future.oldOptions)
[13:34:36.956]             if (.Platform$OS.type == "windows") {
[13:34:36.956]                 old_names <- names(...future.oldEnvVars)
[13:34:36.956]                 envs <- base::Sys.getenv()
[13:34:36.956]                 names <- names(envs)
[13:34:36.956]                 common <- intersect(names, old_names)
[13:34:36.956]                 added <- setdiff(names, old_names)
[13:34:36.956]                 removed <- setdiff(old_names, names)
[13:34:36.956]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:36.956]                   envs[common]]
[13:34:36.956]                 NAMES <- toupper(changed)
[13:34:36.956]                 args <- list()
[13:34:36.956]                 for (kk in seq_along(NAMES)) {
[13:34:36.956]                   name <- changed[[kk]]
[13:34:36.956]                   NAME <- NAMES[[kk]]
[13:34:36.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.956]                     next
[13:34:36.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.956]                 }
[13:34:36.956]                 NAMES <- toupper(added)
[13:34:36.956]                 for (kk in seq_along(NAMES)) {
[13:34:36.956]                   name <- added[[kk]]
[13:34:36.956]                   NAME <- NAMES[[kk]]
[13:34:36.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.956]                     next
[13:34:36.956]                   args[[name]] <- ""
[13:34:36.956]                 }
[13:34:36.956]                 NAMES <- toupper(removed)
[13:34:36.956]                 for (kk in seq_along(NAMES)) {
[13:34:36.956]                   name <- removed[[kk]]
[13:34:36.956]                   NAME <- NAMES[[kk]]
[13:34:36.956]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:36.956]                     next
[13:34:36.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:36.956]                 }
[13:34:36.956]                 if (length(args) > 0) 
[13:34:36.956]                   base::do.call(base::Sys.setenv, args = args)
[13:34:36.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:36.956]             }
[13:34:36.956]             else {
[13:34:36.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:36.956]             }
[13:34:36.956]             {
[13:34:36.956]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:36.956]                   0L) {
[13:34:36.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:36.956]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:36.956]                   base::options(opts)
[13:34:36.956]                 }
[13:34:36.956]                 {
[13:34:36.956]                   {
[13:34:36.956]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:36.956]                     NULL
[13:34:36.956]                   }
[13:34:36.956]                   options(future.plan = NULL)
[13:34:36.956]                   if (is.na(NA_character_)) 
[13:34:36.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:36.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:36.956]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:36.956]                     .init = FALSE)
[13:34:36.956]                 }
[13:34:36.956]             }
[13:34:36.956]         }
[13:34:36.956]     })
[13:34:36.956]     if (TRUE) {
[13:34:36.956]         base::sink(type = "output", split = FALSE)
[13:34:36.956]         if (TRUE) {
[13:34:36.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:36.956]         }
[13:34:36.956]         else {
[13:34:36.956]             ...future.result["stdout"] <- base::list(NULL)
[13:34:36.956]         }
[13:34:36.956]         base::close(...future.stdout)
[13:34:36.956]         ...future.stdout <- NULL
[13:34:36.956]     }
[13:34:36.956]     ...future.result$conditions <- ...future.conditions
[13:34:36.956]     ...future.result$finished <- base::Sys.time()
[13:34:36.956]     ...future.result
[13:34:36.956] }
[13:34:36.960] assign_globals() ...
[13:34:36.960] List of 5
[13:34:36.960]  $ ...future.FUN            :function (x, ...)  
[13:34:36.960]  $ MoreArgs                 : NULL
[13:34:36.960]  $ ...future.elements_ii    :List of 2
[13:34:36.960]   ..$ :List of 2
[13:34:36.960]   .. ..$ : int 3
[13:34:36.960]   .. ..$ : int 4
[13:34:36.960]   ..$ :List of 2
[13:34:36.960]   .. ..$ : int 2
[13:34:36.960]   .. ..$ : int 1
[13:34:36.960]  $ ...future.seeds_ii       : NULL
[13:34:36.960]  $ ...future.globals.maxSize: NULL
[13:34:36.960]  - attr(*, "where")=List of 5
[13:34:36.960]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:36.960]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:36.960]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:36.960]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:36.960]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:36.960]  - attr(*, "resolved")= logi FALSE
[13:34:36.960]  - attr(*, "total_size")= num 280
[13:34:36.960]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:36.960]  - attr(*, "already-done")= logi TRUE
[13:34:37.010] - copied ‘...future.FUN’ to environment
[13:34:37.011] - copied ‘MoreArgs’ to environment
[13:34:37.011] - copied ‘...future.elements_ii’ to environment
[13:34:37.011] - copied ‘...future.seeds_ii’ to environment
[13:34:37.011] - copied ‘...future.globals.maxSize’ to environment
[13:34:37.011] assign_globals() ... done
[13:34:37.011] requestCore(): workers = 2
[13:34:37.013] MulticoreFuture started
[13:34:37.014] - Launch lazy future ... done
[13:34:37.014] run() for ‘MulticoreFuture’ ... done
[13:34:37.014] Created future:
[13:34:37.015] plan(): Setting new future strategy stack:
[13:34:37.015] List of future strategies:
[13:34:37.015] 1. sequential:
[13:34:37.015]    - args: function (..., envir = parent.frame())
[13:34:37.015]    - tweaked: FALSE
[13:34:37.015]    - call: NULL
[13:34:37.016] plan(): nbrOfWorkers() = 1
[13:34:37.018] plan(): Setting new future strategy stack:
[13:34:37.018] List of future strategies:
[13:34:37.018] 1. multicore:
[13:34:37.018]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:37.018]    - tweaked: FALSE
[13:34:37.018]    - call: plan(strategy)
[13:34:37.023] plan(): nbrOfWorkers() = 2
[13:34:37.014] MulticoreFuture:
[13:34:37.014] Label: ‘future_mapply-2’
[13:34:37.014] Expression:
[13:34:37.014] {
[13:34:37.014]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.014]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:37.014]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.014]         on.exit(options(oopts), add = TRUE)
[13:34:37.014]     }
[13:34:37.014]     {
[13:34:37.014]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.014]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:37.014]         do.call(mapply, args = args)
[13:34:37.014]     }
[13:34:37.014] }
[13:34:37.014] Lazy evaluation: FALSE
[13:34:37.014] Asynchronous evaluation: TRUE
[13:34:37.014] Local evaluation: TRUE
[13:34:37.014] Environment: R_GlobalEnv
[13:34:37.014] Capture standard output: TRUE
[13:34:37.014] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:37.014] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:37.014] Packages: <none>
[13:34:37.014] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:37.014] Resolved: TRUE
[13:34:37.014] Value: <not collected>
[13:34:37.014] Conditions captured: <none>
[13:34:37.014] Early signaling: FALSE
[13:34:37.014] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:37.014] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.024] Chunk #2 of 2 ... DONE
[13:34:37.024] Launching 2 futures (chunks) ... DONE
[13:34:37.024] Resolving 2 futures (chunks) ...
[13:34:37.024] resolve() on list ...
[13:34:37.025]  recursive: 0
[13:34:37.025]  length: 2
[13:34:37.025] 
[13:34:37.025] Future #1
[13:34:37.025] result() for MulticoreFuture ...
[13:34:37.026] result() for MulticoreFuture ...
[13:34:37.026] result() for MulticoreFuture ... done
[13:34:37.027] result() for MulticoreFuture ... done
[13:34:37.027] result() for MulticoreFuture ...
[13:34:37.027] result() for MulticoreFuture ... done
[13:34:37.027] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:37.027] - nx: 2
[13:34:37.027] - relay: TRUE
[13:34:37.027] - stdout: TRUE
[13:34:37.028] - signal: TRUE
[13:34:37.028] - resignal: FALSE
[13:34:37.028] - force: TRUE
[13:34:37.028] - relayed: [n=2] FALSE, FALSE
[13:34:37.028] - queued futures: [n=2] FALSE, FALSE
[13:34:37.028]  - until=1
[13:34:37.028]  - relaying element #1
[13:34:37.028] result() for MulticoreFuture ...
[13:34:37.029] result() for MulticoreFuture ... done
[13:34:37.029] result() for MulticoreFuture ...
[13:34:37.029] result() for MulticoreFuture ... done
[13:34:37.029] result() for MulticoreFuture ...
[13:34:37.029] result() for MulticoreFuture ... done
[13:34:37.030] result() for MulticoreFuture ...
[13:34:37.030] result() for MulticoreFuture ... done
[13:34:37.030] - relayed: [n=2] TRUE, FALSE
[13:34:37.030] - queued futures: [n=2] TRUE, FALSE
[13:34:37.030] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:37.030]  length: 1 (resolved future 1)
[13:34:37.031] Future #2
[13:34:37.031] result() for MulticoreFuture ...
[13:34:37.032] result() for MulticoreFuture ...
[13:34:37.032] result() for MulticoreFuture ... done
[13:34:37.032] result() for MulticoreFuture ... done
[13:34:37.032] result() for MulticoreFuture ...
[13:34:37.032] result() for MulticoreFuture ... done
[13:34:37.032] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:37.032] - nx: 2
[13:34:37.033] - relay: TRUE
[13:34:37.033] - stdout: TRUE
[13:34:37.033] - signal: TRUE
[13:34:37.033] - resignal: FALSE
[13:34:37.033] - force: TRUE
[13:34:37.033] - relayed: [n=2] TRUE, FALSE
[13:34:37.033] - queued futures: [n=2] TRUE, FALSE
[13:34:37.033]  - until=2
[13:34:37.033]  - relaying element #2
[13:34:37.034] result() for MulticoreFuture ...
[13:34:37.034] result() for MulticoreFuture ... done
[13:34:37.034] result() for MulticoreFuture ...
[13:34:37.034] result() for MulticoreFuture ... done
[13:34:37.034] result() for MulticoreFuture ...
[13:34:37.034] result() for MulticoreFuture ... done
[13:34:37.034] result() for MulticoreFuture ...
[13:34:37.034] result() for MulticoreFuture ... done
[13:34:37.035] - relayed: [n=2] TRUE, TRUE
[13:34:37.035] - queued futures: [n=2] TRUE, TRUE
[13:34:37.035] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:37.035]  length: 0 (resolved future 2)
[13:34:37.035] Relaying remaining futures
[13:34:37.035] signalConditionsASAP(NULL, pos=0) ...
[13:34:37.035] - nx: 2
[13:34:37.035] - relay: TRUE
[13:34:37.035] - stdout: TRUE
[13:34:37.036] - signal: TRUE
[13:34:37.036] - resignal: FALSE
[13:34:37.036] - force: TRUE
[13:34:37.036] - relayed: [n=2] TRUE, TRUE
[13:34:37.036] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:37.036] - relayed: [n=2] TRUE, TRUE
[13:34:37.036] - queued futures: [n=2] TRUE, TRUE
[13:34:37.036] signalConditionsASAP(NULL, pos=0) ... done
[13:34:37.036] resolve() on list ... DONE
[13:34:37.037] result() for MulticoreFuture ...
[13:34:37.037] result() for MulticoreFuture ... done
[13:34:37.037] result() for MulticoreFuture ...
[13:34:37.037] result() for MulticoreFuture ... done
[13:34:37.037] result() for MulticoreFuture ...
[13:34:37.037] result() for MulticoreFuture ... done
[13:34:37.037] result() for MulticoreFuture ...
[13:34:37.037] result() for MulticoreFuture ... done
[13:34:37.037]  - Number of value chunks collected: 2
[13:34:37.038] Resolving 2 futures (chunks) ... DONE
[13:34:37.038] Reducing values from 2 chunks ...
[13:34:37.038]  - Number of values collected after concatenation: 4
[13:34:37.038]  - Number of values expected: 4
[13:34:37.038] Reducing values from 2 chunks ... DONE
[13:34:37.038] future_mapply() ... DONE
- Parallel RNG ...
[13:34:37.038] future_mapply() ...
[13:34:37.039] Generating random seeds ...
[13:34:37.039] Generating random seed streams for 4 elements ...
[13:34:37.039] Generating random seed streams for 4 elements ... DONE
[13:34:37.039] Generating random seeds ... DONE
[13:34:37.039] Will set RNG state on exit: 10407, -932647314, -885698651, 416943658, 1965014997, -996180636, 1641818560
[13:34:37.043] Number of chunks: 2
[13:34:37.044] getGlobalsAndPackagesXApply() ...
[13:34:37.044]  - future.globals: TRUE
[13:34:37.044] getGlobalsAndPackages() ...
[13:34:37.044] Searching for globals...
[13:34:37.046] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[13:34:37.046] Searching for globals ... DONE
[13:34:37.046] Resolving globals: FALSE
[13:34:37.046] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[13:34:37.047] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[13:34:37.047] - globals: [1] ‘FUN’
[13:34:37.047] - packages: [1] ‘stats’
[13:34:37.047] getGlobalsAndPackages() ... DONE
[13:34:37.048]  - globals found/used: [n=1] ‘FUN’
[13:34:37.048]  - needed namespaces: [n=1] ‘stats’
[13:34:37.048] Finding globals ... DONE
[13:34:37.048] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:37.048] List of 2
[13:34:37.048]  $ ...future.FUN:function (n, min = 0, max = 1)  
[13:34:37.048]  $ MoreArgs     :List of 1
[13:34:37.048]   ..$ min: num 1
[13:34:37.048]  - attr(*, "where")=List of 2
[13:34:37.048]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:37.048]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:37.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.048]  - attr(*, "resolved")= logi FALSE
[13:34:37.048]  - attr(*, "total_size")= num NA
[13:34:37.052] Packages to be attached in all futures: [n=1] ‘stats’
[13:34:37.052] getGlobalsAndPackagesXApply() ... DONE
[13:34:37.052] Number of futures (= number of chunks): 2
[13:34:37.052] Launching 2 futures (chunks) ...
[13:34:37.053] Chunk #1 of 2 ...
[13:34:37.053]  - Finding globals in '...' for chunk #1 ...
[13:34:37.053] getGlobalsAndPackages() ...
[13:34:37.053] Searching for globals...
[13:34:37.053] 
[13:34:37.053] Searching for globals ... DONE
[13:34:37.054] - globals: [0] <none>
[13:34:37.054] getGlobalsAndPackages() ... DONE
[13:34:37.054]    + additional globals found: [n=0] 
[13:34:37.054]    + additional namespaces needed: [n=0] 
[13:34:37.054]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:37.054]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:37.054]  - seeds: [2] <seeds>
[13:34:37.054]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.055] getGlobalsAndPackages() ...
[13:34:37.055] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.055] Resolving globals: FALSE
[13:34:37.055] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[13:34:37.056] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[13:34:37.056] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.056] - packages: [1] ‘stats’
[13:34:37.056] getGlobalsAndPackages() ... DONE
[13:34:37.057] run() for ‘Future’ ...
[13:34:37.057] - state: ‘created’
[13:34:37.057] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:37.061] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.061] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:37.061]   - Field: ‘label’
[13:34:37.061]   - Field: ‘local’
[13:34:37.061]   - Field: ‘owner’
[13:34:37.061]   - Field: ‘envir’
[13:34:37.061]   - Field: ‘workers’
[13:34:37.062]   - Field: ‘packages’
[13:34:37.062]   - Field: ‘gc’
[13:34:37.062]   - Field: ‘job’
[13:34:37.062]   - Field: ‘conditions’
[13:34:37.062]   - Field: ‘expr’
[13:34:37.062]   - Field: ‘uuid’
[13:34:37.062]   - Field: ‘seed’
[13:34:37.062]   - Field: ‘version’
[13:34:37.062]   - Field: ‘result’
[13:34:37.063]   - Field: ‘asynchronous’
[13:34:37.063]   - Field: ‘calls’
[13:34:37.063]   - Field: ‘globals’
[13:34:37.063]   - Field: ‘stdout’
[13:34:37.063]   - Field: ‘earlySignal’
[13:34:37.063]   - Field: ‘lazy’
[13:34:37.063]   - Field: ‘state’
[13:34:37.063] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:37.063] - Launch lazy future ...
[13:34:37.064] Packages needed by the future expression (n = 1): ‘stats’
[13:34:37.064] Packages needed by future strategies (n = 0): <none>
[13:34:37.064] {
[13:34:37.064]     {
[13:34:37.064]         {
[13:34:37.064]             ...future.startTime <- base::Sys.time()
[13:34:37.064]             {
[13:34:37.064]                 {
[13:34:37.064]                   {
[13:34:37.064]                     {
[13:34:37.064]                       {
[13:34:37.064]                         base::local({
[13:34:37.064]                           has_future <- base::requireNamespace("future", 
[13:34:37.064]                             quietly = TRUE)
[13:34:37.064]                           if (has_future) {
[13:34:37.064]                             ns <- base::getNamespace("future")
[13:34:37.064]                             version <- ns[[".package"]][["version"]]
[13:34:37.064]                             if (is.null(version)) 
[13:34:37.064]                               version <- utils::packageVersion("future")
[13:34:37.064]                           }
[13:34:37.064]                           else {
[13:34:37.064]                             version <- NULL
[13:34:37.064]                           }
[13:34:37.064]                           if (!has_future || version < "1.8.0") {
[13:34:37.064]                             info <- base::c(r_version = base::gsub("R version ", 
[13:34:37.064]                               "", base::R.version$version.string), 
[13:34:37.064]                               platform = base::sprintf("%s (%s-bit)", 
[13:34:37.064]                                 base::R.version$platform, 8 * 
[13:34:37.064]                                   base::.Machine$sizeof.pointer), 
[13:34:37.064]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:37.064]                                 "release", "version")], collapse = " "), 
[13:34:37.064]                               hostname = base::Sys.info()[["nodename"]])
[13:34:37.064]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:34:37.064]                               info)
[13:34:37.064]                             info <- base::paste(info, collapse = "; ")
[13:34:37.064]                             if (!has_future) {
[13:34:37.064]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:37.064]                                 info)
[13:34:37.064]                             }
[13:34:37.064]                             else {
[13:34:37.064]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:37.064]                                 info, version)
[13:34:37.064]                             }
[13:34:37.064]                             base::stop(msg)
[13:34:37.064]                           }
[13:34:37.064]                         })
[13:34:37.064]                       }
[13:34:37.064]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:37.064]                       base::options(mc.cores = 1L)
[13:34:37.064]                     }
[13:34:37.064]                     base::local({
[13:34:37.064]                       for (pkg in "stats") {
[13:34:37.064]                         base::loadNamespace(pkg)
[13:34:37.064]                         base::library(pkg, character.only = TRUE)
[13:34:37.064]                       }
[13:34:37.064]                     })
[13:34:37.064]                   }
[13:34:37.064]                   ...future.strategy.old <- future::plan("list")
[13:34:37.064]                   options(future.plan = NULL)
[13:34:37.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:37.064]                 }
[13:34:37.064]                 ...future.workdir <- getwd()
[13:34:37.064]             }
[13:34:37.064]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:37.064]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:37.064]         }
[13:34:37.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:37.064]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:37.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:37.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:37.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:37.064]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:37.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:37.064]             base::names(...future.oldOptions))
[13:34:37.064]     }
[13:34:37.064]     if (FALSE) {
[13:34:37.064]     }
[13:34:37.064]     else {
[13:34:37.064]         if (TRUE) {
[13:34:37.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:37.064]                 open = "w")
[13:34:37.064]         }
[13:34:37.064]         else {
[13:34:37.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:37.064]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:37.064]         }
[13:34:37.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:37.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:37.064]             base::sink(type = "output", split = FALSE)
[13:34:37.064]             base::close(...future.stdout)
[13:34:37.064]         }, add = TRUE)
[13:34:37.064]     }
[13:34:37.064]     ...future.frame <- base::sys.nframe()
[13:34:37.064]     ...future.conditions <- base::list()
[13:34:37.064]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:37.064]     if (FALSE) {
[13:34:37.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:37.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:37.064]     }
[13:34:37.064]     ...future.result <- base::tryCatch({
[13:34:37.064]         base::withCallingHandlers({
[13:34:37.064]             ...future.value <- base::withVisible(base::local({
[13:34:37.064]                 withCallingHandlers({
[13:34:37.064]                   {
[13:34:37.064]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.064]                     if (!identical(...future.globals.maxSize.org, 
[13:34:37.064]                       ...future.globals.maxSize)) {
[13:34:37.064]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.064]                       on.exit(options(oopts), add = TRUE)
[13:34:37.064]                     }
[13:34:37.064]                     {
[13:34:37.064]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:37.064]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[13:34:37.064]                           envir = globalenv(), inherits = FALSE)
[13:34:37.064]                         ...future.FUN(...)
[13:34:37.064]                       }
[13:34:37.064]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:37.064]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:37.064]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:37.064]                         USE.NAMES = FALSE)
[13:34:37.064]                       do.call(mapply, args = args)
[13:34:37.064]                     }
[13:34:37.064]                   }
[13:34:37.064]                 }, immediateCondition = function(cond) {
[13:34:37.064]                   save_rds <- function (object, pathname, ...) 
[13:34:37.064]                   {
[13:34:37.064]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:37.064]                     if (file_test("-f", pathname_tmp)) {
[13:34:37.064]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.064]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:37.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.064]                         fi_tmp[["mtime"]])
[13:34:37.064]                     }
[13:34:37.064]                     tryCatch({
[13:34:37.064]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:37.064]                     }, error = function(ex) {
[13:34:37.064]                       msg <- conditionMessage(ex)
[13:34:37.064]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.064]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:37.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.064]                         fi_tmp[["mtime"]], msg)
[13:34:37.064]                       ex$message <- msg
[13:34:37.064]                       stop(ex)
[13:34:37.064]                     })
[13:34:37.064]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:37.064]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:37.064]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:37.064]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.064]                       fi <- file.info(pathname)
[13:34:37.064]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:37.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.064]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:37.064]                         fi[["size"]], fi[["mtime"]])
[13:34:37.064]                       stop(msg)
[13:34:37.064]                     }
[13:34:37.064]                     invisible(pathname)
[13:34:37.064]                   }
[13:34:37.064]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:37.064]                     rootPath = tempdir()) 
[13:34:37.064]                   {
[13:34:37.064]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:37.064]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:37.064]                       tmpdir = path, fileext = ".rds")
[13:34:37.064]                     save_rds(obj, file)
[13:34:37.064]                   }
[13:34:37.064]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:37.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.064]                   {
[13:34:37.064]                     inherits <- base::inherits
[13:34:37.064]                     invokeRestart <- base::invokeRestart
[13:34:37.064]                     is.null <- base::is.null
[13:34:37.064]                     muffled <- FALSE
[13:34:37.064]                     if (inherits(cond, "message")) {
[13:34:37.064]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:37.064]                       if (muffled) 
[13:34:37.064]                         invokeRestart("muffleMessage")
[13:34:37.064]                     }
[13:34:37.064]                     else if (inherits(cond, "warning")) {
[13:34:37.064]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:37.064]                       if (muffled) 
[13:34:37.064]                         invokeRestart("muffleWarning")
[13:34:37.064]                     }
[13:34:37.064]                     else if (inherits(cond, "condition")) {
[13:34:37.064]                       if (!is.null(pattern)) {
[13:34:37.064]                         computeRestarts <- base::computeRestarts
[13:34:37.064]                         grepl <- base::grepl
[13:34:37.064]                         restarts <- computeRestarts(cond)
[13:34:37.064]                         for (restart in restarts) {
[13:34:37.064]                           name <- restart$name
[13:34:37.064]                           if (is.null(name)) 
[13:34:37.064]                             next
[13:34:37.064]                           if (!grepl(pattern, name)) 
[13:34:37.064]                             next
[13:34:37.064]                           invokeRestart(restart)
[13:34:37.064]                           muffled <- TRUE
[13:34:37.064]                           break
[13:34:37.064]                         }
[13:34:37.064]                       }
[13:34:37.064]                     }
[13:34:37.064]                     invisible(muffled)
[13:34:37.064]                   }
[13:34:37.064]                   muffleCondition(cond)
[13:34:37.064]                 })
[13:34:37.064]             }))
[13:34:37.064]             future::FutureResult(value = ...future.value$value, 
[13:34:37.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.064]                   ...future.rng), globalenv = if (FALSE) 
[13:34:37.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:37.064]                     ...future.globalenv.names))
[13:34:37.064]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:37.064]         }, condition = base::local({
[13:34:37.064]             c <- base::c
[13:34:37.064]             inherits <- base::inherits
[13:34:37.064]             invokeRestart <- base::invokeRestart
[13:34:37.064]             length <- base::length
[13:34:37.064]             list <- base::list
[13:34:37.064]             seq.int <- base::seq.int
[13:34:37.064]             signalCondition <- base::signalCondition
[13:34:37.064]             sys.calls <- base::sys.calls
[13:34:37.064]             `[[` <- base::`[[`
[13:34:37.064]             `+` <- base::`+`
[13:34:37.064]             `<<-` <- base::`<<-`
[13:34:37.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:37.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:37.064]                   3L)]
[13:34:37.064]             }
[13:34:37.064]             function(cond) {
[13:34:37.064]                 is_error <- inherits(cond, "error")
[13:34:37.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:37.064]                   NULL)
[13:34:37.064]                 if (is_error) {
[13:34:37.064]                   sessionInformation <- function() {
[13:34:37.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:37.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:37.064]                       search = base::search(), system = base::Sys.info())
[13:34:37.064]                   }
[13:34:37.064]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:37.064]                     cond$call), session = sessionInformation(), 
[13:34:37.064]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:37.064]                   signalCondition(cond)
[13:34:37.064]                 }
[13:34:37.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:37.064]                 "immediateCondition"))) {
[13:34:37.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:37.064]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:37.064]                   if (TRUE && !signal) {
[13:34:37.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.064]                     {
[13:34:37.064]                       inherits <- base::inherits
[13:34:37.064]                       invokeRestart <- base::invokeRestart
[13:34:37.064]                       is.null <- base::is.null
[13:34:37.064]                       muffled <- FALSE
[13:34:37.064]                       if (inherits(cond, "message")) {
[13:34:37.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.064]                         if (muffled) 
[13:34:37.064]                           invokeRestart("muffleMessage")
[13:34:37.064]                       }
[13:34:37.064]                       else if (inherits(cond, "warning")) {
[13:34:37.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.064]                         if (muffled) 
[13:34:37.064]                           invokeRestart("muffleWarning")
[13:34:37.064]                       }
[13:34:37.064]                       else if (inherits(cond, "condition")) {
[13:34:37.064]                         if (!is.null(pattern)) {
[13:34:37.064]                           computeRestarts <- base::computeRestarts
[13:34:37.064]                           grepl <- base::grepl
[13:34:37.064]                           restarts <- computeRestarts(cond)
[13:34:37.064]                           for (restart in restarts) {
[13:34:37.064]                             name <- restart$name
[13:34:37.064]                             if (is.null(name)) 
[13:34:37.064]                               next
[13:34:37.064]                             if (!grepl(pattern, name)) 
[13:34:37.064]                               next
[13:34:37.064]                             invokeRestart(restart)
[13:34:37.064]                             muffled <- TRUE
[13:34:37.064]                             break
[13:34:37.064]                           }
[13:34:37.064]                         }
[13:34:37.064]                       }
[13:34:37.064]                       invisible(muffled)
[13:34:37.064]                     }
[13:34:37.064]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.064]                   }
[13:34:37.064]                 }
[13:34:37.064]                 else {
[13:34:37.064]                   if (TRUE) {
[13:34:37.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.064]                     {
[13:34:37.064]                       inherits <- base::inherits
[13:34:37.064]                       invokeRestart <- base::invokeRestart
[13:34:37.064]                       is.null <- base::is.null
[13:34:37.064]                       muffled <- FALSE
[13:34:37.064]                       if (inherits(cond, "message")) {
[13:34:37.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.064]                         if (muffled) 
[13:34:37.064]                           invokeRestart("muffleMessage")
[13:34:37.064]                       }
[13:34:37.064]                       else if (inherits(cond, "warning")) {
[13:34:37.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.064]                         if (muffled) 
[13:34:37.064]                           invokeRestart("muffleWarning")
[13:34:37.064]                       }
[13:34:37.064]                       else if (inherits(cond, "condition")) {
[13:34:37.064]                         if (!is.null(pattern)) {
[13:34:37.064]                           computeRestarts <- base::computeRestarts
[13:34:37.064]                           grepl <- base::grepl
[13:34:37.064]                           restarts <- computeRestarts(cond)
[13:34:37.064]                           for (restart in restarts) {
[13:34:37.064]                             name <- restart$name
[13:34:37.064]                             if (is.null(name)) 
[13:34:37.064]                               next
[13:34:37.064]                             if (!grepl(pattern, name)) 
[13:34:37.064]                               next
[13:34:37.064]                             invokeRestart(restart)
[13:34:37.064]                             muffled <- TRUE
[13:34:37.064]                             break
[13:34:37.064]                           }
[13:34:37.064]                         }
[13:34:37.064]                       }
[13:34:37.064]                       invisible(muffled)
[13:34:37.064]                     }
[13:34:37.064]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.064]                   }
[13:34:37.064]                 }
[13:34:37.064]             }
[13:34:37.064]         }))
[13:34:37.064]     }, error = function(ex) {
[13:34:37.064]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:37.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.064]                 ...future.rng), started = ...future.startTime, 
[13:34:37.064]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:37.064]             version = "1.8"), class = "FutureResult")
[13:34:37.064]     }, finally = {
[13:34:37.064]         if (!identical(...future.workdir, getwd())) 
[13:34:37.064]             setwd(...future.workdir)
[13:34:37.064]         {
[13:34:37.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:37.064]                 ...future.oldOptions$nwarnings <- NULL
[13:34:37.064]             }
[13:34:37.064]             base::options(...future.oldOptions)
[13:34:37.064]             if (.Platform$OS.type == "windows") {
[13:34:37.064]                 old_names <- names(...future.oldEnvVars)
[13:34:37.064]                 envs <- base::Sys.getenv()
[13:34:37.064]                 names <- names(envs)
[13:34:37.064]                 common <- intersect(names, old_names)
[13:34:37.064]                 added <- setdiff(names, old_names)
[13:34:37.064]                 removed <- setdiff(old_names, names)
[13:34:37.064]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:37.064]                   envs[common]]
[13:34:37.064]                 NAMES <- toupper(changed)
[13:34:37.064]                 args <- list()
[13:34:37.064]                 for (kk in seq_along(NAMES)) {
[13:34:37.064]                   name <- changed[[kk]]
[13:34:37.064]                   NAME <- NAMES[[kk]]
[13:34:37.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.064]                     next
[13:34:37.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.064]                 }
[13:34:37.064]                 NAMES <- toupper(added)
[13:34:37.064]                 for (kk in seq_along(NAMES)) {
[13:34:37.064]                   name <- added[[kk]]
[13:34:37.064]                   NAME <- NAMES[[kk]]
[13:34:37.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.064]                     next
[13:34:37.064]                   args[[name]] <- ""
[13:34:37.064]                 }
[13:34:37.064]                 NAMES <- toupper(removed)
[13:34:37.064]                 for (kk in seq_along(NAMES)) {
[13:34:37.064]                   name <- removed[[kk]]
[13:34:37.064]                   NAME <- NAMES[[kk]]
[13:34:37.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.064]                     next
[13:34:37.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.064]                 }
[13:34:37.064]                 if (length(args) > 0) 
[13:34:37.064]                   base::do.call(base::Sys.setenv, args = args)
[13:34:37.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:37.064]             }
[13:34:37.064]             else {
[13:34:37.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:37.064]             }
[13:34:37.064]             {
[13:34:37.064]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:37.064]                   0L) {
[13:34:37.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:37.064]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:37.064]                   base::options(opts)
[13:34:37.064]                 }
[13:34:37.064]                 {
[13:34:37.064]                   {
[13:34:37.064]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:37.064]                     NULL
[13:34:37.064]                   }
[13:34:37.064]                   options(future.plan = NULL)
[13:34:37.064]                   if (is.na(NA_character_)) 
[13:34:37.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:37.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:37.064]                     .init = FALSE)
[13:34:37.064]                 }
[13:34:37.064]             }
[13:34:37.064]         }
[13:34:37.064]     })
[13:34:37.064]     if (TRUE) {
[13:34:37.064]         base::sink(type = "output", split = FALSE)
[13:34:37.064]         if (TRUE) {
[13:34:37.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:37.064]         }
[13:34:37.064]         else {
[13:34:37.064]             ...future.result["stdout"] <- base::list(NULL)
[13:34:37.064]         }
[13:34:37.064]         base::close(...future.stdout)
[13:34:37.064]         ...future.stdout <- NULL
[13:34:37.064]     }
[13:34:37.064]     ...future.result$conditions <- ...future.conditions
[13:34:37.064]     ...future.result$finished <- base::Sys.time()
[13:34:37.064]     ...future.result
[13:34:37.064] }
[13:34:37.067] assign_globals() ...
[13:34:37.067] List of 5
[13:34:37.067]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[13:34:37.067]  $ MoreArgs                 :List of 1
[13:34:37.067]   ..$ min: num 1
[13:34:37.067]  $ ...future.elements_ii    :List of 2
[13:34:37.067]   ..$ n  :List of 2
[13:34:37.067]   .. ..$ : int 1
[13:34:37.067]   .. ..$ : int 2
[13:34:37.067]   ..$ max:List of 2
[13:34:37.067]   .. ..$ : int 2
[13:34:37.067]   .. ..$ : int 3
[13:34:37.067]  $ ...future.seeds_ii       :List of 2
[13:34:37.067]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[13:34:37.067]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[13:34:37.067]  $ ...future.globals.maxSize: NULL
[13:34:37.067]  - attr(*, "where")=List of 5
[13:34:37.067]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:37.067]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:37.067]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:37.067]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:37.067]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:37.067]  - attr(*, "resolved")= logi FALSE
[13:34:37.067]  - attr(*, "total_size")= num 2528
[13:34:37.067]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.067]  - attr(*, "already-done")= logi TRUE
[13:34:37.075] - copied ‘...future.FUN’ to environment
[13:34:37.076] - copied ‘MoreArgs’ to environment
[13:34:37.076] - copied ‘...future.elements_ii’ to environment
[13:34:37.076] - copied ‘...future.seeds_ii’ to environment
[13:34:37.076] - copied ‘...future.globals.maxSize’ to environment
[13:34:37.076] assign_globals() ... done
[13:34:37.076] requestCore(): workers = 2
[13:34:37.078] MulticoreFuture started
[13:34:37.079] - Launch lazy future ... done
[13:34:37.079] run() for ‘MulticoreFuture’ ... done
[13:34:37.079] Created future:
[13:34:37.080] plan(): Setting new future strategy stack:
[13:34:37.080] List of future strategies:
[13:34:37.080] 1. sequential:
[13:34:37.080]    - args: function (..., envir = parent.frame())
[13:34:37.080]    - tweaked: FALSE
[13:34:37.080]    - call: NULL
[13:34:37.081] plan(): nbrOfWorkers() = 1
[13:34:37.083] plan(): Setting new future strategy stack:
[13:34:37.083] List of future strategies:
[13:34:37.083] 1. multicore:
[13:34:37.083]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:37.083]    - tweaked: FALSE
[13:34:37.083]    - call: plan(strategy)
[13:34:37.088] plan(): nbrOfWorkers() = 2
[13:34:37.079] MulticoreFuture:
[13:34:37.079] Label: ‘future_mapply-1’
[13:34:37.079] Expression:
[13:34:37.079] {
[13:34:37.079]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.079]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:37.079]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.079]         on.exit(options(oopts), add = TRUE)
[13:34:37.079]     }
[13:34:37.079]     {
[13:34:37.079]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:37.079]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[13:34:37.079]                 inherits = FALSE)
[13:34:37.079]             ...future.FUN(...)
[13:34:37.079]         }
[13:34:37.079]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:37.079]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:37.079]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:37.079]         do.call(mapply, args = args)
[13:34:37.079]     }
[13:34:37.079] }
[13:34:37.079] Lazy evaluation: FALSE
[13:34:37.079] Asynchronous evaluation: TRUE
[13:34:37.079] Local evaluation: TRUE
[13:34:37.079] Environment: R_GlobalEnv
[13:34:37.079] Capture standard output: TRUE
[13:34:37.079] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:37.079] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:37.079] Packages: 1 packages (‘stats’)
[13:34:37.079] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:34:37.079] Resolved: TRUE
[13:34:37.079] Value: <not collected>
[13:34:37.079] Conditions captured: <none>
[13:34:37.079] Early signaling: FALSE
[13:34:37.079] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:37.079] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.089] Chunk #1 of 2 ... DONE
[13:34:37.089] Chunk #2 of 2 ...
[13:34:37.090]  - Finding globals in '...' for chunk #2 ...
[13:34:37.090] getGlobalsAndPackages() ...
[13:34:37.090] Searching for globals...
[13:34:37.090] 
[13:34:37.091] Searching for globals ... DONE
[13:34:37.091] - globals: [0] <none>
[13:34:37.091] getGlobalsAndPackages() ... DONE
[13:34:37.091]    + additional globals found: [n=0] 
[13:34:37.091]    + additional namespaces needed: [n=0] 
[13:34:37.091]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:37.091]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:37.092]  - seeds: [2] <seeds>
[13:34:37.092]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.092] getGlobalsAndPackages() ...
[13:34:37.092] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.092] Resolving globals: FALSE
[13:34:37.093] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[13:34:37.094] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[13:34:37.094] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.094] - packages: [1] ‘stats’
[13:34:37.094] getGlobalsAndPackages() ... DONE
[13:34:37.095] run() for ‘Future’ ...
[13:34:37.095] - state: ‘created’
[13:34:37.095] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:37.100] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.100] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:37.100]   - Field: ‘label’
[13:34:37.100]   - Field: ‘local’
[13:34:37.100]   - Field: ‘owner’
[13:34:37.100]   - Field: ‘envir’
[13:34:37.100]   - Field: ‘workers’
[13:34:37.101]   - Field: ‘packages’
[13:34:37.101]   - Field: ‘gc’
[13:34:37.101]   - Field: ‘job’
[13:34:37.101]   - Field: ‘conditions’
[13:34:37.101]   - Field: ‘expr’
[13:34:37.101]   - Field: ‘uuid’
[13:34:37.101]   - Field: ‘seed’
[13:34:37.101]   - Field: ‘version’
[13:34:37.102]   - Field: ‘result’
[13:34:37.102]   - Field: ‘asynchronous’
[13:34:37.102]   - Field: ‘calls’
[13:34:37.102]   - Field: ‘globals’
[13:34:37.102]   - Field: ‘stdout’
[13:34:37.102]   - Field: ‘earlySignal’
[13:34:37.102]   - Field: ‘lazy’
[13:34:37.103]   - Field: ‘state’
[13:34:37.103] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:37.103] - Launch lazy future ...
[13:34:37.103] Packages needed by the future expression (n = 1): ‘stats’
[13:34:37.103] Packages needed by future strategies (n = 0): <none>
[13:34:37.104] {
[13:34:37.104]     {
[13:34:37.104]         {
[13:34:37.104]             ...future.startTime <- base::Sys.time()
[13:34:37.104]             {
[13:34:37.104]                 {
[13:34:37.104]                   {
[13:34:37.104]                     {
[13:34:37.104]                       {
[13:34:37.104]                         base::local({
[13:34:37.104]                           has_future <- base::requireNamespace("future", 
[13:34:37.104]                             quietly = TRUE)
[13:34:37.104]                           if (has_future) {
[13:34:37.104]                             ns <- base::getNamespace("future")
[13:34:37.104]                             version <- ns[[".package"]][["version"]]
[13:34:37.104]                             if (is.null(version)) 
[13:34:37.104]                               version <- utils::packageVersion("future")
[13:34:37.104]                           }
[13:34:37.104]                           else {
[13:34:37.104]                             version <- NULL
[13:34:37.104]                           }
[13:34:37.104]                           if (!has_future || version < "1.8.0") {
[13:34:37.104]                             info <- base::c(r_version = base::gsub("R version ", 
[13:34:37.104]                               "", base::R.version$version.string), 
[13:34:37.104]                               platform = base::sprintf("%s (%s-bit)", 
[13:34:37.104]                                 base::R.version$platform, 8 * 
[13:34:37.104]                                   base::.Machine$sizeof.pointer), 
[13:34:37.104]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:37.104]                                 "release", "version")], collapse = " "), 
[13:34:37.104]                               hostname = base::Sys.info()[["nodename"]])
[13:34:37.104]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:34:37.104]                               info)
[13:34:37.104]                             info <- base::paste(info, collapse = "; ")
[13:34:37.104]                             if (!has_future) {
[13:34:37.104]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:37.104]                                 info)
[13:34:37.104]                             }
[13:34:37.104]                             else {
[13:34:37.104]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:37.104]                                 info, version)
[13:34:37.104]                             }
[13:34:37.104]                             base::stop(msg)
[13:34:37.104]                           }
[13:34:37.104]                         })
[13:34:37.104]                       }
[13:34:37.104]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:37.104]                       base::options(mc.cores = 1L)
[13:34:37.104]                     }
[13:34:37.104]                     base::local({
[13:34:37.104]                       for (pkg in "stats") {
[13:34:37.104]                         base::loadNamespace(pkg)
[13:34:37.104]                         base::library(pkg, character.only = TRUE)
[13:34:37.104]                       }
[13:34:37.104]                     })
[13:34:37.104]                   }
[13:34:37.104]                   ...future.strategy.old <- future::plan("list")
[13:34:37.104]                   options(future.plan = NULL)
[13:34:37.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:37.104]                 }
[13:34:37.104]                 ...future.workdir <- getwd()
[13:34:37.104]             }
[13:34:37.104]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:37.104]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:37.104]         }
[13:34:37.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:37.104]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:37.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:37.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:37.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:37.104]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:37.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:37.104]             base::names(...future.oldOptions))
[13:34:37.104]     }
[13:34:37.104]     if (FALSE) {
[13:34:37.104]     }
[13:34:37.104]     else {
[13:34:37.104]         if (TRUE) {
[13:34:37.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:37.104]                 open = "w")
[13:34:37.104]         }
[13:34:37.104]         else {
[13:34:37.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:37.104]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:37.104]         }
[13:34:37.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:37.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:37.104]             base::sink(type = "output", split = FALSE)
[13:34:37.104]             base::close(...future.stdout)
[13:34:37.104]         }, add = TRUE)
[13:34:37.104]     }
[13:34:37.104]     ...future.frame <- base::sys.nframe()
[13:34:37.104]     ...future.conditions <- base::list()
[13:34:37.104]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:37.104]     if (FALSE) {
[13:34:37.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:37.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:37.104]     }
[13:34:37.104]     ...future.result <- base::tryCatch({
[13:34:37.104]         base::withCallingHandlers({
[13:34:37.104]             ...future.value <- base::withVisible(base::local({
[13:34:37.104]                 withCallingHandlers({
[13:34:37.104]                   {
[13:34:37.104]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.104]                     if (!identical(...future.globals.maxSize.org, 
[13:34:37.104]                       ...future.globals.maxSize)) {
[13:34:37.104]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.104]                       on.exit(options(oopts), add = TRUE)
[13:34:37.104]                     }
[13:34:37.104]                     {
[13:34:37.104]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:37.104]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[13:34:37.104]                           envir = globalenv(), inherits = FALSE)
[13:34:37.104]                         ...future.FUN(...)
[13:34:37.104]                       }
[13:34:37.104]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:37.104]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:37.104]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:37.104]                         USE.NAMES = FALSE)
[13:34:37.104]                       do.call(mapply, args = args)
[13:34:37.104]                     }
[13:34:37.104]                   }
[13:34:37.104]                 }, immediateCondition = function(cond) {
[13:34:37.104]                   save_rds <- function (object, pathname, ...) 
[13:34:37.104]                   {
[13:34:37.104]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:37.104]                     if (file_test("-f", pathname_tmp)) {
[13:34:37.104]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.104]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:37.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.104]                         fi_tmp[["mtime"]])
[13:34:37.104]                     }
[13:34:37.104]                     tryCatch({
[13:34:37.104]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:37.104]                     }, error = function(ex) {
[13:34:37.104]                       msg <- conditionMessage(ex)
[13:34:37.104]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.104]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:37.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.104]                         fi_tmp[["mtime"]], msg)
[13:34:37.104]                       ex$message <- msg
[13:34:37.104]                       stop(ex)
[13:34:37.104]                     })
[13:34:37.104]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:37.104]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:37.104]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:37.104]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.104]                       fi <- file.info(pathname)
[13:34:37.104]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:37.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.104]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:37.104]                         fi[["size"]], fi[["mtime"]])
[13:34:37.104]                       stop(msg)
[13:34:37.104]                     }
[13:34:37.104]                     invisible(pathname)
[13:34:37.104]                   }
[13:34:37.104]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:37.104]                     rootPath = tempdir()) 
[13:34:37.104]                   {
[13:34:37.104]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:37.104]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:37.104]                       tmpdir = path, fileext = ".rds")
[13:34:37.104]                     save_rds(obj, file)
[13:34:37.104]                   }
[13:34:37.104]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:37.104]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.104]                   {
[13:34:37.104]                     inherits <- base::inherits
[13:34:37.104]                     invokeRestart <- base::invokeRestart
[13:34:37.104]                     is.null <- base::is.null
[13:34:37.104]                     muffled <- FALSE
[13:34:37.104]                     if (inherits(cond, "message")) {
[13:34:37.104]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:37.104]                       if (muffled) 
[13:34:37.104]                         invokeRestart("muffleMessage")
[13:34:37.104]                     }
[13:34:37.104]                     else if (inherits(cond, "warning")) {
[13:34:37.104]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:37.104]                       if (muffled) 
[13:34:37.104]                         invokeRestart("muffleWarning")
[13:34:37.104]                     }
[13:34:37.104]                     else if (inherits(cond, "condition")) {
[13:34:37.104]                       if (!is.null(pattern)) {
[13:34:37.104]                         computeRestarts <- base::computeRestarts
[13:34:37.104]                         grepl <- base::grepl
[13:34:37.104]                         restarts <- computeRestarts(cond)
[13:34:37.104]                         for (restart in restarts) {
[13:34:37.104]                           name <- restart$name
[13:34:37.104]                           if (is.null(name)) 
[13:34:37.104]                             next
[13:34:37.104]                           if (!grepl(pattern, name)) 
[13:34:37.104]                             next
[13:34:37.104]                           invokeRestart(restart)
[13:34:37.104]                           muffled <- TRUE
[13:34:37.104]                           break
[13:34:37.104]                         }
[13:34:37.104]                       }
[13:34:37.104]                     }
[13:34:37.104]                     invisible(muffled)
[13:34:37.104]                   }
[13:34:37.104]                   muffleCondition(cond)
[13:34:37.104]                 })
[13:34:37.104]             }))
[13:34:37.104]             future::FutureResult(value = ...future.value$value, 
[13:34:37.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.104]                   ...future.rng), globalenv = if (FALSE) 
[13:34:37.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:37.104]                     ...future.globalenv.names))
[13:34:37.104]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:37.104]         }, condition = base::local({
[13:34:37.104]             c <- base::c
[13:34:37.104]             inherits <- base::inherits
[13:34:37.104]             invokeRestart <- base::invokeRestart
[13:34:37.104]             length <- base::length
[13:34:37.104]             list <- base::list
[13:34:37.104]             seq.int <- base::seq.int
[13:34:37.104]             signalCondition <- base::signalCondition
[13:34:37.104]             sys.calls <- base::sys.calls
[13:34:37.104]             `[[` <- base::`[[`
[13:34:37.104]             `+` <- base::`+`
[13:34:37.104]             `<<-` <- base::`<<-`
[13:34:37.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:37.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:37.104]                   3L)]
[13:34:37.104]             }
[13:34:37.104]             function(cond) {
[13:34:37.104]                 is_error <- inherits(cond, "error")
[13:34:37.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:37.104]                   NULL)
[13:34:37.104]                 if (is_error) {
[13:34:37.104]                   sessionInformation <- function() {
[13:34:37.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:37.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:37.104]                       search = base::search(), system = base::Sys.info())
[13:34:37.104]                   }
[13:34:37.104]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:37.104]                     cond$call), session = sessionInformation(), 
[13:34:37.104]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:37.104]                   signalCondition(cond)
[13:34:37.104]                 }
[13:34:37.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:37.104]                 "immediateCondition"))) {
[13:34:37.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:37.104]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:37.104]                   if (TRUE && !signal) {
[13:34:37.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.104]                     {
[13:34:37.104]                       inherits <- base::inherits
[13:34:37.104]                       invokeRestart <- base::invokeRestart
[13:34:37.104]                       is.null <- base::is.null
[13:34:37.104]                       muffled <- FALSE
[13:34:37.104]                       if (inherits(cond, "message")) {
[13:34:37.104]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.104]                         if (muffled) 
[13:34:37.104]                           invokeRestart("muffleMessage")
[13:34:37.104]                       }
[13:34:37.104]                       else if (inherits(cond, "warning")) {
[13:34:37.104]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.104]                         if (muffled) 
[13:34:37.104]                           invokeRestart("muffleWarning")
[13:34:37.104]                       }
[13:34:37.104]                       else if (inherits(cond, "condition")) {
[13:34:37.104]                         if (!is.null(pattern)) {
[13:34:37.104]                           computeRestarts <- base::computeRestarts
[13:34:37.104]                           grepl <- base::grepl
[13:34:37.104]                           restarts <- computeRestarts(cond)
[13:34:37.104]                           for (restart in restarts) {
[13:34:37.104]                             name <- restart$name
[13:34:37.104]                             if (is.null(name)) 
[13:34:37.104]                               next
[13:34:37.104]                             if (!grepl(pattern, name)) 
[13:34:37.104]                               next
[13:34:37.104]                             invokeRestart(restart)
[13:34:37.104]                             muffled <- TRUE
[13:34:37.104]                             break
[13:34:37.104]                           }
[13:34:37.104]                         }
[13:34:37.104]                       }
[13:34:37.104]                       invisible(muffled)
[13:34:37.104]                     }
[13:34:37.104]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.104]                   }
[13:34:37.104]                 }
[13:34:37.104]                 else {
[13:34:37.104]                   if (TRUE) {
[13:34:37.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.104]                     {
[13:34:37.104]                       inherits <- base::inherits
[13:34:37.104]                       invokeRestart <- base::invokeRestart
[13:34:37.104]                       is.null <- base::is.null
[13:34:37.104]                       muffled <- FALSE
[13:34:37.104]                       if (inherits(cond, "message")) {
[13:34:37.104]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.104]                         if (muffled) 
[13:34:37.104]                           invokeRestart("muffleMessage")
[13:34:37.104]                       }
[13:34:37.104]                       else if (inherits(cond, "warning")) {
[13:34:37.104]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.104]                         if (muffled) 
[13:34:37.104]                           invokeRestart("muffleWarning")
[13:34:37.104]                       }
[13:34:37.104]                       else if (inherits(cond, "condition")) {
[13:34:37.104]                         if (!is.null(pattern)) {
[13:34:37.104]                           computeRestarts <- base::computeRestarts
[13:34:37.104]                           grepl <- base::grepl
[13:34:37.104]                           restarts <- computeRestarts(cond)
[13:34:37.104]                           for (restart in restarts) {
[13:34:37.104]                             name <- restart$name
[13:34:37.104]                             if (is.null(name)) 
[13:34:37.104]                               next
[13:34:37.104]                             if (!grepl(pattern, name)) 
[13:34:37.104]                               next
[13:34:37.104]                             invokeRestart(restart)
[13:34:37.104]                             muffled <- TRUE
[13:34:37.104]                             break
[13:34:37.104]                           }
[13:34:37.104]                         }
[13:34:37.104]                       }
[13:34:37.104]                       invisible(muffled)
[13:34:37.104]                     }
[13:34:37.104]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.104]                   }
[13:34:37.104]                 }
[13:34:37.104]             }
[13:34:37.104]         }))
[13:34:37.104]     }, error = function(ex) {
[13:34:37.104]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:37.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.104]                 ...future.rng), started = ...future.startTime, 
[13:34:37.104]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:37.104]             version = "1.8"), class = "FutureResult")
[13:34:37.104]     }, finally = {
[13:34:37.104]         if (!identical(...future.workdir, getwd())) 
[13:34:37.104]             setwd(...future.workdir)
[13:34:37.104]         {
[13:34:37.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:37.104]                 ...future.oldOptions$nwarnings <- NULL
[13:34:37.104]             }
[13:34:37.104]             base::options(...future.oldOptions)
[13:34:37.104]             if (.Platform$OS.type == "windows") {
[13:34:37.104]                 old_names <- names(...future.oldEnvVars)
[13:34:37.104]                 envs <- base::Sys.getenv()
[13:34:37.104]                 names <- names(envs)
[13:34:37.104]                 common <- intersect(names, old_names)
[13:34:37.104]                 added <- setdiff(names, old_names)
[13:34:37.104]                 removed <- setdiff(old_names, names)
[13:34:37.104]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:37.104]                   envs[common]]
[13:34:37.104]                 NAMES <- toupper(changed)
[13:34:37.104]                 args <- list()
[13:34:37.104]                 for (kk in seq_along(NAMES)) {
[13:34:37.104]                   name <- changed[[kk]]
[13:34:37.104]                   NAME <- NAMES[[kk]]
[13:34:37.104]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.104]                     next
[13:34:37.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.104]                 }
[13:34:37.104]                 NAMES <- toupper(added)
[13:34:37.104]                 for (kk in seq_along(NAMES)) {
[13:34:37.104]                   name <- added[[kk]]
[13:34:37.104]                   NAME <- NAMES[[kk]]
[13:34:37.104]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.104]                     next
[13:34:37.104]                   args[[name]] <- ""
[13:34:37.104]                 }
[13:34:37.104]                 NAMES <- toupper(removed)
[13:34:37.104]                 for (kk in seq_along(NAMES)) {
[13:34:37.104]                   name <- removed[[kk]]
[13:34:37.104]                   NAME <- NAMES[[kk]]
[13:34:37.104]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.104]                     next
[13:34:37.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.104]                 }
[13:34:37.104]                 if (length(args) > 0) 
[13:34:37.104]                   base::do.call(base::Sys.setenv, args = args)
[13:34:37.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:37.104]             }
[13:34:37.104]             else {
[13:34:37.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:37.104]             }
[13:34:37.104]             {
[13:34:37.104]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:37.104]                   0L) {
[13:34:37.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:37.104]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:37.104]                   base::options(opts)
[13:34:37.104]                 }
[13:34:37.104]                 {
[13:34:37.104]                   {
[13:34:37.104]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:37.104]                     NULL
[13:34:37.104]                   }
[13:34:37.104]                   options(future.plan = NULL)
[13:34:37.104]                   if (is.na(NA_character_)) 
[13:34:37.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:37.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:37.104]                     .init = FALSE)
[13:34:37.104]                 }
[13:34:37.104]             }
[13:34:37.104]         }
[13:34:37.104]     })
[13:34:37.104]     if (TRUE) {
[13:34:37.104]         base::sink(type = "output", split = FALSE)
[13:34:37.104]         if (TRUE) {
[13:34:37.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:37.104]         }
[13:34:37.104]         else {
[13:34:37.104]             ...future.result["stdout"] <- base::list(NULL)
[13:34:37.104]         }
[13:34:37.104]         base::close(...future.stdout)
[13:34:37.104]         ...future.stdout <- NULL
[13:34:37.104]     }
[13:34:37.104]     ...future.result$conditions <- ...future.conditions
[13:34:37.104]     ...future.result$finished <- base::Sys.time()
[13:34:37.104]     ...future.result
[13:34:37.104] }
[13:34:37.108] assign_globals() ...
[13:34:37.108] List of 5
[13:34:37.108]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[13:34:37.108]  $ MoreArgs                 :List of 1
[13:34:37.108]   ..$ min: num 1
[13:34:37.108]  $ ...future.elements_ii    :List of 2
[13:34:37.108]   ..$ n  :List of 2
[13:34:37.108]   .. ..$ : int 3
[13:34:37.108]   .. ..$ : int 4
[13:34:37.108]   ..$ max:List of 2
[13:34:37.108]   .. ..$ : int 4
[13:34:37.108]   .. ..$ : int 5
[13:34:37.108]  $ ...future.seeds_ii       :List of 2
[13:34:37.108]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[13:34:37.108]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[13:34:37.108]  $ ...future.globals.maxSize: NULL
[13:34:37.108]  - attr(*, "where")=List of 5
[13:34:37.108]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:37.108]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:37.108]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:37.108]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:37.108]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:37.108]  - attr(*, "resolved")= logi FALSE
[13:34:37.108]  - attr(*, "total_size")= num 2528
[13:34:37.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.108]  - attr(*, "already-done")= logi TRUE
[13:34:37.117] - copied ‘...future.FUN’ to environment
[13:34:37.117] - copied ‘MoreArgs’ to environment
[13:34:37.118] - copied ‘...future.elements_ii’ to environment
[13:34:37.118] - copied ‘...future.seeds_ii’ to environment
[13:34:37.118] - copied ‘...future.globals.maxSize’ to environment
[13:34:37.118] assign_globals() ... done
[13:34:37.118] requestCore(): workers = 2
[13:34:37.121] MulticoreFuture started
[13:34:37.121] - Launch lazy future ... done
[13:34:37.121] run() for ‘MulticoreFuture’ ... done
[13:34:37.121] Created future:
[13:34:37.122] plan(): Setting new future strategy stack:
[13:34:37.122] List of future strategies:
[13:34:37.122] 1. sequential:
[13:34:37.122]    - args: function (..., envir = parent.frame())
[13:34:37.122]    - tweaked: FALSE
[13:34:37.122]    - call: NULL
[13:34:37.123] plan(): nbrOfWorkers() = 1
[13:34:37.125] plan(): Setting new future strategy stack:
[13:34:37.125] List of future strategies:
[13:34:37.125] 1. multicore:
[13:34:37.125]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:37.125]    - tweaked: FALSE
[13:34:37.125]    - call: plan(strategy)
[13:34:37.130] plan(): nbrOfWorkers() = 2
[13:34:37.121] MulticoreFuture:
[13:34:37.121] Label: ‘future_mapply-2’
[13:34:37.121] Expression:
[13:34:37.121] {
[13:34:37.121]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.121]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:37.121]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.121]         on.exit(options(oopts), add = TRUE)
[13:34:37.121]     }
[13:34:37.121]     {
[13:34:37.121]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:37.121]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[13:34:37.121]                 inherits = FALSE)
[13:34:37.121]             ...future.FUN(...)
[13:34:37.121]         }
[13:34:37.121]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:37.121]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:37.121]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:37.121]         do.call(mapply, args = args)
[13:34:37.121]     }
[13:34:37.121] }
[13:34:37.121] Lazy evaluation: FALSE
[13:34:37.121] Asynchronous evaluation: TRUE
[13:34:37.121] Local evaluation: TRUE
[13:34:37.121] Environment: R_GlobalEnv
[13:34:37.121] Capture standard output: TRUE
[13:34:37.121] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:37.121] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:37.121] Packages: 1 packages (‘stats’)
[13:34:37.121] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:34:37.121] Resolved: TRUE
[13:34:37.121] Value: <not collected>
[13:34:37.121] Conditions captured: <none>
[13:34:37.121] Early signaling: FALSE
[13:34:37.121] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:37.121] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.131] Chunk #2 of 2 ... DONE
[13:34:37.131] Launching 2 futures (chunks) ... DONE
[13:34:37.132] Resolving 2 futures (chunks) ...
[13:34:37.132] resolve() on list ...
[13:34:37.132]  recursive: 0
[13:34:37.132]  length: 2
[13:34:37.132] 
[13:34:37.132] Future #1
[13:34:37.133] result() for MulticoreFuture ...
[13:34:37.134] result() for MulticoreFuture ...
[13:34:37.134] result() for MulticoreFuture ... done
[13:34:37.134] result() for MulticoreFuture ... done
[13:34:37.134] result() for MulticoreFuture ...
[13:34:37.134] result() for MulticoreFuture ... done
[13:34:37.134] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:37.135] - nx: 2
[13:34:37.135] - relay: TRUE
[13:34:37.135] - stdout: TRUE
[13:34:37.135] - signal: TRUE
[13:34:37.135] - resignal: FALSE
[13:34:37.135] - force: TRUE
[13:34:37.135] - relayed: [n=2] FALSE, FALSE
[13:34:37.135] - queued futures: [n=2] FALSE, FALSE
[13:34:37.136]  - until=1
[13:34:37.136]  - relaying element #1
[13:34:37.136] result() for MulticoreFuture ...
[13:34:37.136] result() for MulticoreFuture ... done
[13:34:37.136] result() for MulticoreFuture ...
[13:34:37.136] result() for MulticoreFuture ... done
[13:34:37.136] result() for MulticoreFuture ...
[13:34:37.136] result() for MulticoreFuture ... done
[13:34:37.137] result() for MulticoreFuture ...
[13:34:37.137] result() for MulticoreFuture ... done
[13:34:37.137] - relayed: [n=2] TRUE, FALSE
[13:34:37.137] - queued futures: [n=2] TRUE, FALSE
[13:34:37.137] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:37.137]  length: 1 (resolved future 1)
[13:34:37.137] Future #2
[13:34:37.138] result() for MulticoreFuture ...
[13:34:37.138] result() for MulticoreFuture ...
[13:34:37.138] result() for MulticoreFuture ... done
[13:34:37.139] result() for MulticoreFuture ... done
[13:34:37.139] result() for MulticoreFuture ...
[13:34:37.139] result() for MulticoreFuture ... done
[13:34:37.139] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:37.139] - nx: 2
[13:34:37.139] - relay: TRUE
[13:34:37.139] - stdout: TRUE
[13:34:37.139] - signal: TRUE
[13:34:37.139] - resignal: FALSE
[13:34:37.140] - force: TRUE
[13:34:37.140] - relayed: [n=2] TRUE, FALSE
[13:34:37.140] - queued futures: [n=2] TRUE, FALSE
[13:34:37.140]  - until=2
[13:34:37.140]  - relaying element #2
[13:34:37.140] result() for MulticoreFuture ...
[13:34:37.140] result() for MulticoreFuture ... done
[13:34:37.140] result() for MulticoreFuture ...
[13:34:37.141] result() for MulticoreFuture ... done
[13:34:37.141] result() for MulticoreFuture ...
[13:34:37.141] result() for MulticoreFuture ... done
[13:34:37.141] result() for MulticoreFuture ...
[13:34:37.141] result() for MulticoreFuture ... done
[13:34:37.141] - relayed: [n=2] TRUE, TRUE
[13:34:37.141] - queued futures: [n=2] TRUE, TRUE
[13:34:37.141] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:37.142]  length: 0 (resolved future 2)
[13:34:37.142] Relaying remaining futures
[13:34:37.142] signalConditionsASAP(NULL, pos=0) ...
[13:34:37.142] - nx: 2
[13:34:37.142] - relay: TRUE
[13:34:37.142] - stdout: TRUE
[13:34:37.142] - signal: TRUE
[13:34:37.142] - resignal: FALSE
[13:34:37.142] - force: TRUE
[13:34:37.143] - relayed: [n=2] TRUE, TRUE
[13:34:37.143] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:37.143] - relayed: [n=2] TRUE, TRUE
[13:34:37.143] - queued futures: [n=2] TRUE, TRUE
[13:34:37.143] signalConditionsASAP(NULL, pos=0) ... done
[13:34:37.143] resolve() on list ... DONE
[13:34:37.143] result() for MulticoreFuture ...
[13:34:37.143] result() for MulticoreFuture ... done
[13:34:37.144] result() for MulticoreFuture ...
[13:34:37.144] result() for MulticoreFuture ... done
[13:34:37.144] result() for MulticoreFuture ...
[13:34:37.144] result() for MulticoreFuture ... done
[13:34:37.144] result() for MulticoreFuture ...
[13:34:37.147] result() for MulticoreFuture ... done
[13:34:37.147]  - Number of value chunks collected: 2
[13:34:37.147] Resolving 2 futures (chunks) ... DONE
[13:34:37.148] Reducing values from 2 chunks ...
[13:34:37.148]  - Number of values collected after concatenation: 4
[13:34:37.148]  - Number of values expected: 4
[13:34:37.148] Reducing values from 2 chunks ... DONE
[13:34:37.148] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[13:34:37.149] future_mapply() ...
[13:34:37.153] Number of chunks: 2
[13:34:37.153] getGlobalsAndPackagesXApply() ...
[13:34:37.153]  - future.globals: TRUE
[13:34:37.153] getGlobalsAndPackages() ...
[13:34:37.153] Searching for globals...
[13:34:37.154] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:34:37.155] Searching for globals ... DONE
[13:34:37.155] Resolving globals: FALSE
[13:34:37.155] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[13:34:37.156] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[13:34:37.156] - globals: [1] ‘FUN’
[13:34:37.156] - packages: [1] ‘stats’
[13:34:37.156] getGlobalsAndPackages() ... DONE
[13:34:37.156]  - globals found/used: [n=1] ‘FUN’
[13:34:37.156]  - needed namespaces: [n=1] ‘stats’
[13:34:37.156] Finding globals ... DONE
[13:34:37.157] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:37.157] List of 2
[13:34:37.157]  $ ...future.FUN:function (x, w, ...)  
[13:34:37.157]  $ MoreArgs     : NULL
[13:34:37.157]  - attr(*, "where")=List of 2
[13:34:37.157]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:37.157]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:37.157]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.157]  - attr(*, "resolved")= logi FALSE
[13:34:37.157]  - attr(*, "total_size")= num NA
[13:34:37.160] Packages to be attached in all futures: [n=1] ‘stats’
[13:34:37.160] getGlobalsAndPackagesXApply() ... DONE
[13:34:37.160] Number of futures (= number of chunks): 2
[13:34:37.160] Launching 2 futures (chunks) ...
[13:34:37.160] Chunk #1 of 2 ...
[13:34:37.160]  - Finding globals in '...' for chunk #1 ...
[13:34:37.160] getGlobalsAndPackages() ...
[13:34:37.161] Searching for globals...
[13:34:37.161] 
[13:34:37.161] Searching for globals ... DONE
[13:34:37.161] - globals: [0] <none>
[13:34:37.161] getGlobalsAndPackages() ... DONE
[13:34:37.161]    + additional globals found: [n=0] 
[13:34:37.161]    + additional namespaces needed: [n=0] 
[13:34:37.162]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:37.162]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:37.162]  - seeds: <none>
[13:34:37.162]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.162] getGlobalsAndPackages() ...
[13:34:37.162] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.162] Resolving globals: FALSE
[13:34:37.163] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[13:34:37.163] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:37.163] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.164] - packages: [1] ‘stats’
[13:34:37.164] getGlobalsAndPackages() ... DONE
[13:34:37.164] run() for ‘Future’ ...
[13:34:37.164] - state: ‘created’
[13:34:37.164] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:37.168] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.168] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:37.168]   - Field: ‘label’
[13:34:37.169]   - Field: ‘local’
[13:34:37.169]   - Field: ‘owner’
[13:34:37.169]   - Field: ‘envir’
[13:34:37.169]   - Field: ‘workers’
[13:34:37.169]   - Field: ‘packages’
[13:34:37.169]   - Field: ‘gc’
[13:34:37.169]   - Field: ‘job’
[13:34:37.169]   - Field: ‘conditions’
[13:34:37.169]   - Field: ‘expr’
[13:34:37.170]   - Field: ‘uuid’
[13:34:37.170]   - Field: ‘seed’
[13:34:37.170]   - Field: ‘version’
[13:34:37.170]   - Field: ‘result’
[13:34:37.170]   - Field: ‘asynchronous’
[13:34:37.170]   - Field: ‘calls’
[13:34:37.170]   - Field: ‘globals’
[13:34:37.170]   - Field: ‘stdout’
[13:34:37.170]   - Field: ‘earlySignal’
[13:34:37.171]   - Field: ‘lazy’
[13:34:37.171]   - Field: ‘state’
[13:34:37.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:37.171] - Launch lazy future ...
[13:34:37.171] Packages needed by the future expression (n = 1): ‘stats’
[13:34:37.171] Packages needed by future strategies (n = 0): <none>
[13:34:37.172] {
[13:34:37.172]     {
[13:34:37.172]         {
[13:34:37.172]             ...future.startTime <- base::Sys.time()
[13:34:37.172]             {
[13:34:37.172]                 {
[13:34:37.172]                   {
[13:34:37.172]                     {
[13:34:37.172]                       {
[13:34:37.172]                         base::local({
[13:34:37.172]                           has_future <- base::requireNamespace("future", 
[13:34:37.172]                             quietly = TRUE)
[13:34:37.172]                           if (has_future) {
[13:34:37.172]                             ns <- base::getNamespace("future")
[13:34:37.172]                             version <- ns[[".package"]][["version"]]
[13:34:37.172]                             if (is.null(version)) 
[13:34:37.172]                               version <- utils::packageVersion("future")
[13:34:37.172]                           }
[13:34:37.172]                           else {
[13:34:37.172]                             version <- NULL
[13:34:37.172]                           }
[13:34:37.172]                           if (!has_future || version < "1.8.0") {
[13:34:37.172]                             info <- base::c(r_version = base::gsub("R version ", 
[13:34:37.172]                               "", base::R.version$version.string), 
[13:34:37.172]                               platform = base::sprintf("%s (%s-bit)", 
[13:34:37.172]                                 base::R.version$platform, 8 * 
[13:34:37.172]                                   base::.Machine$sizeof.pointer), 
[13:34:37.172]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:37.172]                                 "release", "version")], collapse = " "), 
[13:34:37.172]                               hostname = base::Sys.info()[["nodename"]])
[13:34:37.172]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:34:37.172]                               info)
[13:34:37.172]                             info <- base::paste(info, collapse = "; ")
[13:34:37.172]                             if (!has_future) {
[13:34:37.172]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:37.172]                                 info)
[13:34:37.172]                             }
[13:34:37.172]                             else {
[13:34:37.172]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:37.172]                                 info, version)
[13:34:37.172]                             }
[13:34:37.172]                             base::stop(msg)
[13:34:37.172]                           }
[13:34:37.172]                         })
[13:34:37.172]                       }
[13:34:37.172]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:37.172]                       base::options(mc.cores = 1L)
[13:34:37.172]                     }
[13:34:37.172]                     base::local({
[13:34:37.172]                       for (pkg in "stats") {
[13:34:37.172]                         base::loadNamespace(pkg)
[13:34:37.172]                         base::library(pkg, character.only = TRUE)
[13:34:37.172]                       }
[13:34:37.172]                     })
[13:34:37.172]                   }
[13:34:37.172]                   ...future.strategy.old <- future::plan("list")
[13:34:37.172]                   options(future.plan = NULL)
[13:34:37.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:37.172]                 }
[13:34:37.172]                 ...future.workdir <- getwd()
[13:34:37.172]             }
[13:34:37.172]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:37.172]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:37.172]         }
[13:34:37.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:37.172]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:37.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:37.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:37.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:37.172]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:37.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:37.172]             base::names(...future.oldOptions))
[13:34:37.172]     }
[13:34:37.172]     if (FALSE) {
[13:34:37.172]     }
[13:34:37.172]     else {
[13:34:37.172]         if (TRUE) {
[13:34:37.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:37.172]                 open = "w")
[13:34:37.172]         }
[13:34:37.172]         else {
[13:34:37.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:37.172]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:37.172]         }
[13:34:37.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:37.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:37.172]             base::sink(type = "output", split = FALSE)
[13:34:37.172]             base::close(...future.stdout)
[13:34:37.172]         }, add = TRUE)
[13:34:37.172]     }
[13:34:37.172]     ...future.frame <- base::sys.nframe()
[13:34:37.172]     ...future.conditions <- base::list()
[13:34:37.172]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:37.172]     if (FALSE) {
[13:34:37.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:37.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:37.172]     }
[13:34:37.172]     ...future.result <- base::tryCatch({
[13:34:37.172]         base::withCallingHandlers({
[13:34:37.172]             ...future.value <- base::withVisible(base::local({
[13:34:37.172]                 withCallingHandlers({
[13:34:37.172]                   {
[13:34:37.172]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.172]                     if (!identical(...future.globals.maxSize.org, 
[13:34:37.172]                       ...future.globals.maxSize)) {
[13:34:37.172]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.172]                       on.exit(options(oopts), add = TRUE)
[13:34:37.172]                     }
[13:34:37.172]                     {
[13:34:37.172]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.172]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:37.172]                         USE.NAMES = FALSE)
[13:34:37.172]                       do.call(mapply, args = args)
[13:34:37.172]                     }
[13:34:37.172]                   }
[13:34:37.172]                 }, immediateCondition = function(cond) {
[13:34:37.172]                   save_rds <- function (object, pathname, ...) 
[13:34:37.172]                   {
[13:34:37.172]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:37.172]                     if (file_test("-f", pathname_tmp)) {
[13:34:37.172]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.172]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:37.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.172]                         fi_tmp[["mtime"]])
[13:34:37.172]                     }
[13:34:37.172]                     tryCatch({
[13:34:37.172]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:37.172]                     }, error = function(ex) {
[13:34:37.172]                       msg <- conditionMessage(ex)
[13:34:37.172]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.172]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:37.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.172]                         fi_tmp[["mtime"]], msg)
[13:34:37.172]                       ex$message <- msg
[13:34:37.172]                       stop(ex)
[13:34:37.172]                     })
[13:34:37.172]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:37.172]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:37.172]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:37.172]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.172]                       fi <- file.info(pathname)
[13:34:37.172]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:37.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.172]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:37.172]                         fi[["size"]], fi[["mtime"]])
[13:34:37.172]                       stop(msg)
[13:34:37.172]                     }
[13:34:37.172]                     invisible(pathname)
[13:34:37.172]                   }
[13:34:37.172]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:37.172]                     rootPath = tempdir()) 
[13:34:37.172]                   {
[13:34:37.172]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:37.172]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:37.172]                       tmpdir = path, fileext = ".rds")
[13:34:37.172]                     save_rds(obj, file)
[13:34:37.172]                   }
[13:34:37.172]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:37.172]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.172]                   {
[13:34:37.172]                     inherits <- base::inherits
[13:34:37.172]                     invokeRestart <- base::invokeRestart
[13:34:37.172]                     is.null <- base::is.null
[13:34:37.172]                     muffled <- FALSE
[13:34:37.172]                     if (inherits(cond, "message")) {
[13:34:37.172]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:37.172]                       if (muffled) 
[13:34:37.172]                         invokeRestart("muffleMessage")
[13:34:37.172]                     }
[13:34:37.172]                     else if (inherits(cond, "warning")) {
[13:34:37.172]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:37.172]                       if (muffled) 
[13:34:37.172]                         invokeRestart("muffleWarning")
[13:34:37.172]                     }
[13:34:37.172]                     else if (inherits(cond, "condition")) {
[13:34:37.172]                       if (!is.null(pattern)) {
[13:34:37.172]                         computeRestarts <- base::computeRestarts
[13:34:37.172]                         grepl <- base::grepl
[13:34:37.172]                         restarts <- computeRestarts(cond)
[13:34:37.172]                         for (restart in restarts) {
[13:34:37.172]                           name <- restart$name
[13:34:37.172]                           if (is.null(name)) 
[13:34:37.172]                             next
[13:34:37.172]                           if (!grepl(pattern, name)) 
[13:34:37.172]                             next
[13:34:37.172]                           invokeRestart(restart)
[13:34:37.172]                           muffled <- TRUE
[13:34:37.172]                           break
[13:34:37.172]                         }
[13:34:37.172]                       }
[13:34:37.172]                     }
[13:34:37.172]                     invisible(muffled)
[13:34:37.172]                   }
[13:34:37.172]                   muffleCondition(cond)
[13:34:37.172]                 })
[13:34:37.172]             }))
[13:34:37.172]             future::FutureResult(value = ...future.value$value, 
[13:34:37.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.172]                   ...future.rng), globalenv = if (FALSE) 
[13:34:37.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:37.172]                     ...future.globalenv.names))
[13:34:37.172]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:37.172]         }, condition = base::local({
[13:34:37.172]             c <- base::c
[13:34:37.172]             inherits <- base::inherits
[13:34:37.172]             invokeRestart <- base::invokeRestart
[13:34:37.172]             length <- base::length
[13:34:37.172]             list <- base::list
[13:34:37.172]             seq.int <- base::seq.int
[13:34:37.172]             signalCondition <- base::signalCondition
[13:34:37.172]             sys.calls <- base::sys.calls
[13:34:37.172]             `[[` <- base::`[[`
[13:34:37.172]             `+` <- base::`+`
[13:34:37.172]             `<<-` <- base::`<<-`
[13:34:37.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:37.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:37.172]                   3L)]
[13:34:37.172]             }
[13:34:37.172]             function(cond) {
[13:34:37.172]                 is_error <- inherits(cond, "error")
[13:34:37.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:37.172]                   NULL)
[13:34:37.172]                 if (is_error) {
[13:34:37.172]                   sessionInformation <- function() {
[13:34:37.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:37.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:37.172]                       search = base::search(), system = base::Sys.info())
[13:34:37.172]                   }
[13:34:37.172]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:37.172]                     cond$call), session = sessionInformation(), 
[13:34:37.172]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:37.172]                   signalCondition(cond)
[13:34:37.172]                 }
[13:34:37.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:37.172]                 "immediateCondition"))) {
[13:34:37.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:37.172]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:37.172]                   if (TRUE && !signal) {
[13:34:37.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.172]                     {
[13:34:37.172]                       inherits <- base::inherits
[13:34:37.172]                       invokeRestart <- base::invokeRestart
[13:34:37.172]                       is.null <- base::is.null
[13:34:37.172]                       muffled <- FALSE
[13:34:37.172]                       if (inherits(cond, "message")) {
[13:34:37.172]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.172]                         if (muffled) 
[13:34:37.172]                           invokeRestart("muffleMessage")
[13:34:37.172]                       }
[13:34:37.172]                       else if (inherits(cond, "warning")) {
[13:34:37.172]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.172]                         if (muffled) 
[13:34:37.172]                           invokeRestart("muffleWarning")
[13:34:37.172]                       }
[13:34:37.172]                       else if (inherits(cond, "condition")) {
[13:34:37.172]                         if (!is.null(pattern)) {
[13:34:37.172]                           computeRestarts <- base::computeRestarts
[13:34:37.172]                           grepl <- base::grepl
[13:34:37.172]                           restarts <- computeRestarts(cond)
[13:34:37.172]                           for (restart in restarts) {
[13:34:37.172]                             name <- restart$name
[13:34:37.172]                             if (is.null(name)) 
[13:34:37.172]                               next
[13:34:37.172]                             if (!grepl(pattern, name)) 
[13:34:37.172]                               next
[13:34:37.172]                             invokeRestart(restart)
[13:34:37.172]                             muffled <- TRUE
[13:34:37.172]                             break
[13:34:37.172]                           }
[13:34:37.172]                         }
[13:34:37.172]                       }
[13:34:37.172]                       invisible(muffled)
[13:34:37.172]                     }
[13:34:37.172]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.172]                   }
[13:34:37.172]                 }
[13:34:37.172]                 else {
[13:34:37.172]                   if (TRUE) {
[13:34:37.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.172]                     {
[13:34:37.172]                       inherits <- base::inherits
[13:34:37.172]                       invokeRestart <- base::invokeRestart
[13:34:37.172]                       is.null <- base::is.null
[13:34:37.172]                       muffled <- FALSE
[13:34:37.172]                       if (inherits(cond, "message")) {
[13:34:37.172]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.172]                         if (muffled) 
[13:34:37.172]                           invokeRestart("muffleMessage")
[13:34:37.172]                       }
[13:34:37.172]                       else if (inherits(cond, "warning")) {
[13:34:37.172]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.172]                         if (muffled) 
[13:34:37.172]                           invokeRestart("muffleWarning")
[13:34:37.172]                       }
[13:34:37.172]                       else if (inherits(cond, "condition")) {
[13:34:37.172]                         if (!is.null(pattern)) {
[13:34:37.172]                           computeRestarts <- base::computeRestarts
[13:34:37.172]                           grepl <- base::grepl
[13:34:37.172]                           restarts <- computeRestarts(cond)
[13:34:37.172]                           for (restart in restarts) {
[13:34:37.172]                             name <- restart$name
[13:34:37.172]                             if (is.null(name)) 
[13:34:37.172]                               next
[13:34:37.172]                             if (!grepl(pattern, name)) 
[13:34:37.172]                               next
[13:34:37.172]                             invokeRestart(restart)
[13:34:37.172]                             muffled <- TRUE
[13:34:37.172]                             break
[13:34:37.172]                           }
[13:34:37.172]                         }
[13:34:37.172]                       }
[13:34:37.172]                       invisible(muffled)
[13:34:37.172]                     }
[13:34:37.172]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.172]                   }
[13:34:37.172]                 }
[13:34:37.172]             }
[13:34:37.172]         }))
[13:34:37.172]     }, error = function(ex) {
[13:34:37.172]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:37.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.172]                 ...future.rng), started = ...future.startTime, 
[13:34:37.172]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:37.172]             version = "1.8"), class = "FutureResult")
[13:34:37.172]     }, finally = {
[13:34:37.172]         if (!identical(...future.workdir, getwd())) 
[13:34:37.172]             setwd(...future.workdir)
[13:34:37.172]         {
[13:34:37.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:37.172]                 ...future.oldOptions$nwarnings <- NULL
[13:34:37.172]             }
[13:34:37.172]             base::options(...future.oldOptions)
[13:34:37.172]             if (.Platform$OS.type == "windows") {
[13:34:37.172]                 old_names <- names(...future.oldEnvVars)
[13:34:37.172]                 envs <- base::Sys.getenv()
[13:34:37.172]                 names <- names(envs)
[13:34:37.172]                 common <- intersect(names, old_names)
[13:34:37.172]                 added <- setdiff(names, old_names)
[13:34:37.172]                 removed <- setdiff(old_names, names)
[13:34:37.172]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:37.172]                   envs[common]]
[13:34:37.172]                 NAMES <- toupper(changed)
[13:34:37.172]                 args <- list()
[13:34:37.172]                 for (kk in seq_along(NAMES)) {
[13:34:37.172]                   name <- changed[[kk]]
[13:34:37.172]                   NAME <- NAMES[[kk]]
[13:34:37.172]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.172]                     next
[13:34:37.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.172]                 }
[13:34:37.172]                 NAMES <- toupper(added)
[13:34:37.172]                 for (kk in seq_along(NAMES)) {
[13:34:37.172]                   name <- added[[kk]]
[13:34:37.172]                   NAME <- NAMES[[kk]]
[13:34:37.172]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.172]                     next
[13:34:37.172]                   args[[name]] <- ""
[13:34:37.172]                 }
[13:34:37.172]                 NAMES <- toupper(removed)
[13:34:37.172]                 for (kk in seq_along(NAMES)) {
[13:34:37.172]                   name <- removed[[kk]]
[13:34:37.172]                   NAME <- NAMES[[kk]]
[13:34:37.172]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.172]                     next
[13:34:37.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.172]                 }
[13:34:37.172]                 if (length(args) > 0) 
[13:34:37.172]                   base::do.call(base::Sys.setenv, args = args)
[13:34:37.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:37.172]             }
[13:34:37.172]             else {
[13:34:37.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:37.172]             }
[13:34:37.172]             {
[13:34:37.172]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:37.172]                   0L) {
[13:34:37.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:37.172]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:37.172]                   base::options(opts)
[13:34:37.172]                 }
[13:34:37.172]                 {
[13:34:37.172]                   {
[13:34:37.172]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:37.172]                     NULL
[13:34:37.172]                   }
[13:34:37.172]                   options(future.plan = NULL)
[13:34:37.172]                   if (is.na(NA_character_)) 
[13:34:37.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:37.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:37.172]                     .init = FALSE)
[13:34:37.172]                 }
[13:34:37.172]             }
[13:34:37.172]         }
[13:34:37.172]     })
[13:34:37.172]     if (TRUE) {
[13:34:37.172]         base::sink(type = "output", split = FALSE)
[13:34:37.172]         if (TRUE) {
[13:34:37.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:37.172]         }
[13:34:37.172]         else {
[13:34:37.172]             ...future.result["stdout"] <- base::list(NULL)
[13:34:37.172]         }
[13:34:37.172]         base::close(...future.stdout)
[13:34:37.172]         ...future.stdout <- NULL
[13:34:37.172]     }
[13:34:37.172]     ...future.result$conditions <- ...future.conditions
[13:34:37.172]     ...future.result$finished <- base::Sys.time()
[13:34:37.172]     ...future.result
[13:34:37.172] }
[13:34:37.174] assign_globals() ...
[13:34:37.174] List of 5
[13:34:37.174]  $ ...future.FUN            :function (x, w, ...)  
[13:34:37.174]  $ MoreArgs                 : NULL
[13:34:37.174]  $ ...future.elements_ii    :List of 2
[13:34:37.174]   ..$ :List of 2
[13:34:37.174]   .. ..$ : num [1:10] 0.8369 0.2929 0.6381 0.0904 0.7696 ...
[13:34:37.174]   .. ..$ : num [1:10] 0.3664 0.8813 0.0551 0.5838 0.2858 ...
[13:34:37.174]   ..$ :List of 2
[13:34:37.174]   .. ..$ : num [1:10] 7 5 4 8 7 10 5 4 6 2
[13:34:37.174]   .. ..$ : num [1:10] 7 6 5 7 6 6 6 4 8 7
[13:34:37.174]  $ ...future.seeds_ii       : NULL
[13:34:37.174]  $ ...future.globals.maxSize: NULL
[13:34:37.174]  - attr(*, "where")=List of 5
[13:34:37.174]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:37.174]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:37.174]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:37.174]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:37.174]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:37.174]  - attr(*, "resolved")= logi FALSE
[13:34:37.174]  - attr(*, "total_size")= num 2120
[13:34:37.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.174]  - attr(*, "already-done")= logi TRUE
[13:34:37.181] - copied ‘...future.FUN’ to environment
[13:34:37.181] - copied ‘MoreArgs’ to environment
[13:34:37.181] - copied ‘...future.elements_ii’ to environment
[13:34:37.182] - copied ‘...future.seeds_ii’ to environment
[13:34:37.182] - copied ‘...future.globals.maxSize’ to environment
[13:34:37.182] assign_globals() ... done
[13:34:37.182] requestCore(): workers = 2
[13:34:37.184] MulticoreFuture started
[13:34:37.184] - Launch lazy future ... done
[13:34:37.185] run() for ‘MulticoreFuture’ ... done
[13:34:37.185] Created future:
[13:34:37.185] plan(): Setting new future strategy stack:
[13:34:37.186] List of future strategies:
[13:34:37.186] 1. sequential:
[13:34:37.186]    - args: function (..., envir = parent.frame())
[13:34:37.186]    - tweaked: FALSE
[13:34:37.186]    - call: NULL
[13:34:37.186] plan(): nbrOfWorkers() = 1
[13:34:37.188] plan(): Setting new future strategy stack:
[13:34:37.189] List of future strategies:
[13:34:37.189] 1. multicore:
[13:34:37.189]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:37.189]    - tweaked: FALSE
[13:34:37.189]    - call: plan(strategy)
[13:34:37.194] plan(): nbrOfWorkers() = 2
[13:34:37.185] MulticoreFuture:
[13:34:37.185] Label: ‘future_Map-1’
[13:34:37.185] Expression:
[13:34:37.185] {
[13:34:37.185]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.185]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:37.185]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.185]         on.exit(options(oopts), add = TRUE)
[13:34:37.185]     }
[13:34:37.185]     {
[13:34:37.185]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.185]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:37.185]         do.call(mapply, args = args)
[13:34:37.185]     }
[13:34:37.185] }
[13:34:37.185] Lazy evaluation: FALSE
[13:34:37.185] Asynchronous evaluation: TRUE
[13:34:37.185] Local evaluation: TRUE
[13:34:37.185] Environment: R_GlobalEnv
[13:34:37.185] Capture standard output: TRUE
[13:34:37.185] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:37.185] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:37.185] Packages: 1 packages (‘stats’)
[13:34:37.185] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:37.185] Resolved: TRUE
[13:34:37.185] Value: <not collected>
[13:34:37.185] Conditions captured: <none>
[13:34:37.185] Early signaling: FALSE
[13:34:37.185] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:37.185] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.195] Chunk #1 of 2 ... DONE
[13:34:37.196] Chunk #2 of 2 ...
[13:34:37.196]  - Finding globals in '...' for chunk #2 ...
[13:34:37.196] getGlobalsAndPackages() ...
[13:34:37.196] Searching for globals...
[13:34:37.197] 
[13:34:37.197] Searching for globals ... DONE
[13:34:37.197] - globals: [0] <none>
[13:34:37.197] getGlobalsAndPackages() ... DONE
[13:34:37.197]    + additional globals found: [n=0] 
[13:34:37.198]    + additional namespaces needed: [n=0] 
[13:34:37.198]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:37.198]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:37.198]  - seeds: <none>
[13:34:37.198]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.198] getGlobalsAndPackages() ...
[13:34:37.198] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.199] Resolving globals: FALSE
[13:34:37.200] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[13:34:37.200] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:37.201] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.201] - packages: [1] ‘stats’
[13:34:37.201] getGlobalsAndPackages() ... DONE
[13:34:37.201] run() for ‘Future’ ...
[13:34:37.202] - state: ‘created’
[13:34:37.202] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:37.206] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.206] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:37.206]   - Field: ‘label’
[13:34:37.207]   - Field: ‘local’
[13:34:37.207]   - Field: ‘owner’
[13:34:37.207]   - Field: ‘envir’
[13:34:37.207]   - Field: ‘workers’
[13:34:37.207]   - Field: ‘packages’
[13:34:37.207]   - Field: ‘gc’
[13:34:37.207]   - Field: ‘job’
[13:34:37.208]   - Field: ‘conditions’
[13:34:37.208]   - Field: ‘expr’
[13:34:37.208]   - Field: ‘uuid’
[13:34:37.208]   - Field: ‘seed’
[13:34:37.208]   - Field: ‘version’
[13:34:37.208]   - Field: ‘result’
[13:34:37.208]   - Field: ‘asynchronous’
[13:34:37.208]   - Field: ‘calls’
[13:34:37.209]   - Field: ‘globals’
[13:34:37.209]   - Field: ‘stdout’
[13:34:37.209]   - Field: ‘earlySignal’
[13:34:37.209]   - Field: ‘lazy’
[13:34:37.209]   - Field: ‘state’
[13:34:37.209] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:37.209] - Launch lazy future ...
[13:34:37.210] Packages needed by the future expression (n = 1): ‘stats’
[13:34:37.210] Packages needed by future strategies (n = 0): <none>
[13:34:37.211] {
[13:34:37.211]     {
[13:34:37.211]         {
[13:34:37.211]             ...future.startTime <- base::Sys.time()
[13:34:37.211]             {
[13:34:37.211]                 {
[13:34:37.211]                   {
[13:34:37.211]                     {
[13:34:37.211]                       {
[13:34:37.211]                         base::local({
[13:34:37.211]                           has_future <- base::requireNamespace("future", 
[13:34:37.211]                             quietly = TRUE)
[13:34:37.211]                           if (has_future) {
[13:34:37.211]                             ns <- base::getNamespace("future")
[13:34:37.211]                             version <- ns[[".package"]][["version"]]
[13:34:37.211]                             if (is.null(version)) 
[13:34:37.211]                               version <- utils::packageVersion("future")
[13:34:37.211]                           }
[13:34:37.211]                           else {
[13:34:37.211]                             version <- NULL
[13:34:37.211]                           }
[13:34:37.211]                           if (!has_future || version < "1.8.0") {
[13:34:37.211]                             info <- base::c(r_version = base::gsub("R version ", 
[13:34:37.211]                               "", base::R.version$version.string), 
[13:34:37.211]                               platform = base::sprintf("%s (%s-bit)", 
[13:34:37.211]                                 base::R.version$platform, 8 * 
[13:34:37.211]                                   base::.Machine$sizeof.pointer), 
[13:34:37.211]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:37.211]                                 "release", "version")], collapse = " "), 
[13:34:37.211]                               hostname = base::Sys.info()[["nodename"]])
[13:34:37.211]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:34:37.211]                               info)
[13:34:37.211]                             info <- base::paste(info, collapse = "; ")
[13:34:37.211]                             if (!has_future) {
[13:34:37.211]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:37.211]                                 info)
[13:34:37.211]                             }
[13:34:37.211]                             else {
[13:34:37.211]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:37.211]                                 info, version)
[13:34:37.211]                             }
[13:34:37.211]                             base::stop(msg)
[13:34:37.211]                           }
[13:34:37.211]                         })
[13:34:37.211]                       }
[13:34:37.211]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:37.211]                       base::options(mc.cores = 1L)
[13:34:37.211]                     }
[13:34:37.211]                     base::local({
[13:34:37.211]                       for (pkg in "stats") {
[13:34:37.211]                         base::loadNamespace(pkg)
[13:34:37.211]                         base::library(pkg, character.only = TRUE)
[13:34:37.211]                       }
[13:34:37.211]                     })
[13:34:37.211]                   }
[13:34:37.211]                   ...future.strategy.old <- future::plan("list")
[13:34:37.211]                   options(future.plan = NULL)
[13:34:37.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:37.211]                 }
[13:34:37.211]                 ...future.workdir <- getwd()
[13:34:37.211]             }
[13:34:37.211]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:37.211]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:37.211]         }
[13:34:37.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:37.211]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:37.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:37.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:37.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:37.211]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:37.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:37.211]             base::names(...future.oldOptions))
[13:34:37.211]     }
[13:34:37.211]     if (FALSE) {
[13:34:37.211]     }
[13:34:37.211]     else {
[13:34:37.211]         if (TRUE) {
[13:34:37.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:37.211]                 open = "w")
[13:34:37.211]         }
[13:34:37.211]         else {
[13:34:37.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:37.211]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:37.211]         }
[13:34:37.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:37.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:37.211]             base::sink(type = "output", split = FALSE)
[13:34:37.211]             base::close(...future.stdout)
[13:34:37.211]         }, add = TRUE)
[13:34:37.211]     }
[13:34:37.211]     ...future.frame <- base::sys.nframe()
[13:34:37.211]     ...future.conditions <- base::list()
[13:34:37.211]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:37.211]     if (FALSE) {
[13:34:37.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:37.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:37.211]     }
[13:34:37.211]     ...future.result <- base::tryCatch({
[13:34:37.211]         base::withCallingHandlers({
[13:34:37.211]             ...future.value <- base::withVisible(base::local({
[13:34:37.211]                 withCallingHandlers({
[13:34:37.211]                   {
[13:34:37.211]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.211]                     if (!identical(...future.globals.maxSize.org, 
[13:34:37.211]                       ...future.globals.maxSize)) {
[13:34:37.211]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.211]                       on.exit(options(oopts), add = TRUE)
[13:34:37.211]                     }
[13:34:37.211]                     {
[13:34:37.211]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.211]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:37.211]                         USE.NAMES = FALSE)
[13:34:37.211]                       do.call(mapply, args = args)
[13:34:37.211]                     }
[13:34:37.211]                   }
[13:34:37.211]                 }, immediateCondition = function(cond) {
[13:34:37.211]                   save_rds <- function (object, pathname, ...) 
[13:34:37.211]                   {
[13:34:37.211]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:37.211]                     if (file_test("-f", pathname_tmp)) {
[13:34:37.211]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.211]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:37.211]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.211]                         fi_tmp[["mtime"]])
[13:34:37.211]                     }
[13:34:37.211]                     tryCatch({
[13:34:37.211]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:37.211]                     }, error = function(ex) {
[13:34:37.211]                       msg <- conditionMessage(ex)
[13:34:37.211]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.211]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:37.211]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.211]                         fi_tmp[["mtime"]], msg)
[13:34:37.211]                       ex$message <- msg
[13:34:37.211]                       stop(ex)
[13:34:37.211]                     })
[13:34:37.211]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:37.211]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:37.211]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:37.211]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.211]                       fi <- file.info(pathname)
[13:34:37.211]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:37.211]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.211]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:37.211]                         fi[["size"]], fi[["mtime"]])
[13:34:37.211]                       stop(msg)
[13:34:37.211]                     }
[13:34:37.211]                     invisible(pathname)
[13:34:37.211]                   }
[13:34:37.211]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:37.211]                     rootPath = tempdir()) 
[13:34:37.211]                   {
[13:34:37.211]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:37.211]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:37.211]                       tmpdir = path, fileext = ".rds")
[13:34:37.211]                     save_rds(obj, file)
[13:34:37.211]                   }
[13:34:37.211]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:37.211]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.211]                   {
[13:34:37.211]                     inherits <- base::inherits
[13:34:37.211]                     invokeRestart <- base::invokeRestart
[13:34:37.211]                     is.null <- base::is.null
[13:34:37.211]                     muffled <- FALSE
[13:34:37.211]                     if (inherits(cond, "message")) {
[13:34:37.211]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:37.211]                       if (muffled) 
[13:34:37.211]                         invokeRestart("muffleMessage")
[13:34:37.211]                     }
[13:34:37.211]                     else if (inherits(cond, "warning")) {
[13:34:37.211]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:37.211]                       if (muffled) 
[13:34:37.211]                         invokeRestart("muffleWarning")
[13:34:37.211]                     }
[13:34:37.211]                     else if (inherits(cond, "condition")) {
[13:34:37.211]                       if (!is.null(pattern)) {
[13:34:37.211]                         computeRestarts <- base::computeRestarts
[13:34:37.211]                         grepl <- base::grepl
[13:34:37.211]                         restarts <- computeRestarts(cond)
[13:34:37.211]                         for (restart in restarts) {
[13:34:37.211]                           name <- restart$name
[13:34:37.211]                           if (is.null(name)) 
[13:34:37.211]                             next
[13:34:37.211]                           if (!grepl(pattern, name)) 
[13:34:37.211]                             next
[13:34:37.211]                           invokeRestart(restart)
[13:34:37.211]                           muffled <- TRUE
[13:34:37.211]                           break
[13:34:37.211]                         }
[13:34:37.211]                       }
[13:34:37.211]                     }
[13:34:37.211]                     invisible(muffled)
[13:34:37.211]                   }
[13:34:37.211]                   muffleCondition(cond)
[13:34:37.211]                 })
[13:34:37.211]             }))
[13:34:37.211]             future::FutureResult(value = ...future.value$value, 
[13:34:37.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.211]                   ...future.rng), globalenv = if (FALSE) 
[13:34:37.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:37.211]                     ...future.globalenv.names))
[13:34:37.211]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:37.211]         }, condition = base::local({
[13:34:37.211]             c <- base::c
[13:34:37.211]             inherits <- base::inherits
[13:34:37.211]             invokeRestart <- base::invokeRestart
[13:34:37.211]             length <- base::length
[13:34:37.211]             list <- base::list
[13:34:37.211]             seq.int <- base::seq.int
[13:34:37.211]             signalCondition <- base::signalCondition
[13:34:37.211]             sys.calls <- base::sys.calls
[13:34:37.211]             `[[` <- base::`[[`
[13:34:37.211]             `+` <- base::`+`
[13:34:37.211]             `<<-` <- base::`<<-`
[13:34:37.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:37.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:37.211]                   3L)]
[13:34:37.211]             }
[13:34:37.211]             function(cond) {
[13:34:37.211]                 is_error <- inherits(cond, "error")
[13:34:37.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:37.211]                   NULL)
[13:34:37.211]                 if (is_error) {
[13:34:37.211]                   sessionInformation <- function() {
[13:34:37.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:37.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:37.211]                       search = base::search(), system = base::Sys.info())
[13:34:37.211]                   }
[13:34:37.211]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:37.211]                     cond$call), session = sessionInformation(), 
[13:34:37.211]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:37.211]                   signalCondition(cond)
[13:34:37.211]                 }
[13:34:37.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:37.211]                 "immediateCondition"))) {
[13:34:37.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:37.211]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:37.211]                   if (TRUE && !signal) {
[13:34:37.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.211]                     {
[13:34:37.211]                       inherits <- base::inherits
[13:34:37.211]                       invokeRestart <- base::invokeRestart
[13:34:37.211]                       is.null <- base::is.null
[13:34:37.211]                       muffled <- FALSE
[13:34:37.211]                       if (inherits(cond, "message")) {
[13:34:37.211]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.211]                         if (muffled) 
[13:34:37.211]                           invokeRestart("muffleMessage")
[13:34:37.211]                       }
[13:34:37.211]                       else if (inherits(cond, "warning")) {
[13:34:37.211]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.211]                         if (muffled) 
[13:34:37.211]                           invokeRestart("muffleWarning")
[13:34:37.211]                       }
[13:34:37.211]                       else if (inherits(cond, "condition")) {
[13:34:37.211]                         if (!is.null(pattern)) {
[13:34:37.211]                           computeRestarts <- base::computeRestarts
[13:34:37.211]                           grepl <- base::grepl
[13:34:37.211]                           restarts <- computeRestarts(cond)
[13:34:37.211]                           for (restart in restarts) {
[13:34:37.211]                             name <- restart$name
[13:34:37.211]                             if (is.null(name)) 
[13:34:37.211]                               next
[13:34:37.211]                             if (!grepl(pattern, name)) 
[13:34:37.211]                               next
[13:34:37.211]                             invokeRestart(restart)
[13:34:37.211]                             muffled <- TRUE
[13:34:37.211]                             break
[13:34:37.211]                           }
[13:34:37.211]                         }
[13:34:37.211]                       }
[13:34:37.211]                       invisible(muffled)
[13:34:37.211]                     }
[13:34:37.211]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.211]                   }
[13:34:37.211]                 }
[13:34:37.211]                 else {
[13:34:37.211]                   if (TRUE) {
[13:34:37.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.211]                     {
[13:34:37.211]                       inherits <- base::inherits
[13:34:37.211]                       invokeRestart <- base::invokeRestart
[13:34:37.211]                       is.null <- base::is.null
[13:34:37.211]                       muffled <- FALSE
[13:34:37.211]                       if (inherits(cond, "message")) {
[13:34:37.211]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.211]                         if (muffled) 
[13:34:37.211]                           invokeRestart("muffleMessage")
[13:34:37.211]                       }
[13:34:37.211]                       else if (inherits(cond, "warning")) {
[13:34:37.211]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.211]                         if (muffled) 
[13:34:37.211]                           invokeRestart("muffleWarning")
[13:34:37.211]                       }
[13:34:37.211]                       else if (inherits(cond, "condition")) {
[13:34:37.211]                         if (!is.null(pattern)) {
[13:34:37.211]                           computeRestarts <- base::computeRestarts
[13:34:37.211]                           grepl <- base::grepl
[13:34:37.211]                           restarts <- computeRestarts(cond)
[13:34:37.211]                           for (restart in restarts) {
[13:34:37.211]                             name <- restart$name
[13:34:37.211]                             if (is.null(name)) 
[13:34:37.211]                               next
[13:34:37.211]                             if (!grepl(pattern, name)) 
[13:34:37.211]                               next
[13:34:37.211]                             invokeRestart(restart)
[13:34:37.211]                             muffled <- TRUE
[13:34:37.211]                             break
[13:34:37.211]                           }
[13:34:37.211]                         }
[13:34:37.211]                       }
[13:34:37.211]                       invisible(muffled)
[13:34:37.211]                     }
[13:34:37.211]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.211]                   }
[13:34:37.211]                 }
[13:34:37.211]             }
[13:34:37.211]         }))
[13:34:37.211]     }, error = function(ex) {
[13:34:37.211]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:37.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.211]                 ...future.rng), started = ...future.startTime, 
[13:34:37.211]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:37.211]             version = "1.8"), class = "FutureResult")
[13:34:37.211]     }, finally = {
[13:34:37.211]         if (!identical(...future.workdir, getwd())) 
[13:34:37.211]             setwd(...future.workdir)
[13:34:37.211]         {
[13:34:37.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:37.211]                 ...future.oldOptions$nwarnings <- NULL
[13:34:37.211]             }
[13:34:37.211]             base::options(...future.oldOptions)
[13:34:37.211]             if (.Platform$OS.type == "windows") {
[13:34:37.211]                 old_names <- names(...future.oldEnvVars)
[13:34:37.211]                 envs <- base::Sys.getenv()
[13:34:37.211]                 names <- names(envs)
[13:34:37.211]                 common <- intersect(names, old_names)
[13:34:37.211]                 added <- setdiff(names, old_names)
[13:34:37.211]                 removed <- setdiff(old_names, names)
[13:34:37.211]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:37.211]                   envs[common]]
[13:34:37.211]                 NAMES <- toupper(changed)
[13:34:37.211]                 args <- list()
[13:34:37.211]                 for (kk in seq_along(NAMES)) {
[13:34:37.211]                   name <- changed[[kk]]
[13:34:37.211]                   NAME <- NAMES[[kk]]
[13:34:37.211]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.211]                     next
[13:34:37.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.211]                 }
[13:34:37.211]                 NAMES <- toupper(added)
[13:34:37.211]                 for (kk in seq_along(NAMES)) {
[13:34:37.211]                   name <- added[[kk]]
[13:34:37.211]                   NAME <- NAMES[[kk]]
[13:34:37.211]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.211]                     next
[13:34:37.211]                   args[[name]] <- ""
[13:34:37.211]                 }
[13:34:37.211]                 NAMES <- toupper(removed)
[13:34:37.211]                 for (kk in seq_along(NAMES)) {
[13:34:37.211]                   name <- removed[[kk]]
[13:34:37.211]                   NAME <- NAMES[[kk]]
[13:34:37.211]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.211]                     next
[13:34:37.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.211]                 }
[13:34:37.211]                 if (length(args) > 0) 
[13:34:37.211]                   base::do.call(base::Sys.setenv, args = args)
[13:34:37.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:37.211]             }
[13:34:37.211]             else {
[13:34:37.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:37.211]             }
[13:34:37.211]             {
[13:34:37.211]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:37.211]                   0L) {
[13:34:37.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:37.211]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:37.211]                   base::options(opts)
[13:34:37.211]                 }
[13:34:37.211]                 {
[13:34:37.211]                   {
[13:34:37.211]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:37.211]                     NULL
[13:34:37.211]                   }
[13:34:37.211]                   options(future.plan = NULL)
[13:34:37.211]                   if (is.na(NA_character_)) 
[13:34:37.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:37.211]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:37.211]                     .init = FALSE)
[13:34:37.211]                 }
[13:34:37.211]             }
[13:34:37.211]         }
[13:34:37.211]     })
[13:34:37.211]     if (TRUE) {
[13:34:37.211]         base::sink(type = "output", split = FALSE)
[13:34:37.211]         if (TRUE) {
[13:34:37.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:37.211]         }
[13:34:37.211]         else {
[13:34:37.211]             ...future.result["stdout"] <- base::list(NULL)
[13:34:37.211]         }
[13:34:37.211]         base::close(...future.stdout)
[13:34:37.211]         ...future.stdout <- NULL
[13:34:37.211]     }
[13:34:37.211]     ...future.result$conditions <- ...future.conditions
[13:34:37.211]     ...future.result$finished <- base::Sys.time()
[13:34:37.211]     ...future.result
[13:34:37.211] }
[13:34:37.214] assign_globals() ...
[13:34:37.214] List of 5
[13:34:37.214]  $ ...future.FUN            :function (x, w, ...)  
[13:34:37.214]  $ MoreArgs                 : NULL
[13:34:37.214]  $ ...future.elements_ii    :List of 2
[13:34:37.214]   ..$ :List of 3
[13:34:37.214]   .. ..$ : num [1:10] 0.282 0.505 0.639 0.204 0.498 ...
[13:34:37.214]   .. ..$ : num [1:10] 0.3346 0.0523 0.191 0.4382 0.6103 ...
[13:34:37.214]   .. ..$ : num [1:10] 0.4681 0.0151 0.3602 0.8806 0.5646 ...
[13:34:37.214]   ..$ :List of 3
[13:34:37.214]   .. ..$ : num [1:10] 7 7 4 5 7 8 8 5 8 9
[13:34:37.214]   .. ..$ : num [1:10] 4 5 3 5 5 2 9 6 3 6
[13:34:37.214]   .. ..$ : num [1:10] 7 5 10 8 9 6 7 5 6 8
[13:34:37.214]  $ ...future.seeds_ii       : NULL
[13:34:37.214]  $ ...future.globals.maxSize: NULL
[13:34:37.214]  - attr(*, "where")=List of 5
[13:34:37.214]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:37.214]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:37.214]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:37.214]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:37.214]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:37.214]  - attr(*, "resolved")= logi FALSE
[13:34:37.214]  - attr(*, "total_size")= num 2472
[13:34:37.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.214]  - attr(*, "already-done")= logi TRUE
[13:34:37.224] - copied ‘...future.FUN’ to environment
[13:34:37.224] - copied ‘MoreArgs’ to environment
[13:34:37.224] - copied ‘...future.elements_ii’ to environment
[13:34:37.224] - copied ‘...future.seeds_ii’ to environment
[13:34:37.224] - copied ‘...future.globals.maxSize’ to environment
[13:34:37.224] assign_globals() ... done
[13:34:37.225] requestCore(): workers = 2
[13:34:37.227] MulticoreFuture started
[13:34:37.227] - Launch lazy future ... done
[13:34:37.227] run() for ‘MulticoreFuture’ ... done
[13:34:37.227] Created future:
[13:34:37.228] plan(): Setting new future strategy stack:
[13:34:37.229] List of future strategies:
[13:34:37.229] 1. sequential:
[13:34:37.229]    - args: function (..., envir = parent.frame())
[13:34:37.229]    - tweaked: FALSE
[13:34:37.229]    - call: NULL
[13:34:37.229] plan(): nbrOfWorkers() = 1
[13:34:37.231] plan(): Setting new future strategy stack:
[13:34:37.231] List of future strategies:
[13:34:37.231] 1. multicore:
[13:34:37.231]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:37.231]    - tweaked: FALSE
[13:34:37.231]    - call: plan(strategy)
[13:34:37.237] plan(): nbrOfWorkers() = 2
[13:34:37.228] MulticoreFuture:
[13:34:37.228] Label: ‘future_Map-2’
[13:34:37.228] Expression:
[13:34:37.228] {
[13:34:37.228]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.228]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:37.228]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.228]         on.exit(options(oopts), add = TRUE)
[13:34:37.228]     }
[13:34:37.228]     {
[13:34:37.228]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.228]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:37.228]         do.call(mapply, args = args)
[13:34:37.228]     }
[13:34:37.228] }
[13:34:37.228] Lazy evaluation: FALSE
[13:34:37.228] Asynchronous evaluation: TRUE
[13:34:37.228] Local evaluation: TRUE
[13:34:37.228] Environment: R_GlobalEnv
[13:34:37.228] Capture standard output: TRUE
[13:34:37.228] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:37.228] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:37.228] Packages: 1 packages (‘stats’)
[13:34:37.228] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:37.228] Resolved: TRUE
[13:34:37.228] Value: <not collected>
[13:34:37.228] Conditions captured: <none>
[13:34:37.228] Early signaling: FALSE
[13:34:37.228] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:37.228] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.237] Chunk #2 of 2 ... DONE
[13:34:37.238] Launching 2 futures (chunks) ... DONE
[13:34:37.238] Resolving 2 futures (chunks) ...
[13:34:37.238] resolve() on list ...
[13:34:37.238]  recursive: 0
[13:34:37.238]  length: 2
[13:34:37.238] 
[13:34:37.239] Future #1
[13:34:37.239] result() for MulticoreFuture ...
[13:34:37.240] result() for MulticoreFuture ...
[13:34:37.240] result() for MulticoreFuture ... done
[13:34:37.240] result() for MulticoreFuture ... done
[13:34:37.240] result() for MulticoreFuture ...
[13:34:37.240] result() for MulticoreFuture ... done
[13:34:37.241] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:37.241] - nx: 2
[13:34:37.241] - relay: TRUE
[13:34:37.241] - stdout: TRUE
[13:34:37.241] - signal: TRUE
[13:34:37.241] - resignal: FALSE
[13:34:37.241] - force: TRUE
[13:34:37.241] - relayed: [n=2] FALSE, FALSE
[13:34:37.241] - queued futures: [n=2] FALSE, FALSE
[13:34:37.242]  - until=1
[13:34:37.242]  - relaying element #1
[13:34:37.242] result() for MulticoreFuture ...
[13:34:37.242] result() for MulticoreFuture ... done
[13:34:37.242] result() for MulticoreFuture ...
[13:34:37.242] result() for MulticoreFuture ... done
[13:34:37.242] result() for MulticoreFuture ...
[13:34:37.243] result() for MulticoreFuture ... done
[13:34:37.243] result() for MulticoreFuture ...
[13:34:37.243] result() for MulticoreFuture ... done
[13:34:37.243] - relayed: [n=2] TRUE, FALSE
[13:34:37.243] - queued futures: [n=2] TRUE, FALSE
[13:34:37.243] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:37.243]  length: 1 (resolved future 1)
[13:34:37.244] Future #2
[13:34:37.244] result() for MulticoreFuture ...
[13:34:37.245] result() for MulticoreFuture ...
[13:34:37.245] result() for MulticoreFuture ... done
[13:34:37.245] result() for MulticoreFuture ... done
[13:34:37.245] result() for MulticoreFuture ...
[13:34:37.245] result() for MulticoreFuture ... done
[13:34:37.245] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:37.245] - nx: 2
[13:34:37.245] - relay: TRUE
[13:34:37.246] - stdout: TRUE
[13:34:37.246] - signal: TRUE
[13:34:37.246] - resignal: FALSE
[13:34:37.246] - force: TRUE
[13:34:37.246] - relayed: [n=2] TRUE, FALSE
[13:34:37.246] - queued futures: [n=2] TRUE, FALSE
[13:34:37.246]  - until=2
[13:34:37.246]  - relaying element #2
[13:34:37.247] result() for MulticoreFuture ...
[13:34:37.247] result() for MulticoreFuture ... done
[13:34:37.247] result() for MulticoreFuture ...
[13:34:37.247] result() for MulticoreFuture ... done
[13:34:37.247] result() for MulticoreFuture ...
[13:34:37.247] result() for MulticoreFuture ... done
[13:34:37.247] result() for MulticoreFuture ...
[13:34:37.247] result() for MulticoreFuture ... done
[13:34:37.248] - relayed: [n=2] TRUE, TRUE
[13:34:37.248] - queued futures: [n=2] TRUE, TRUE
[13:34:37.248] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:37.248]  length: 0 (resolved future 2)
[13:34:37.248] Relaying remaining futures
[13:34:37.248] signalConditionsASAP(NULL, pos=0) ...
[13:34:37.248] - nx: 2
[13:34:37.248] - relay: TRUE
[13:34:37.248] - stdout: TRUE
[13:34:37.248] - signal: TRUE
[13:34:37.249] - resignal: FALSE
[13:34:37.249] - force: TRUE
[13:34:37.249] - relayed: [n=2] TRUE, TRUE
[13:34:37.249] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:37.249] - relayed: [n=2] TRUE, TRUE
[13:34:37.249] - queued futures: [n=2] TRUE, TRUE
[13:34:37.249] signalConditionsASAP(NULL, pos=0) ... done
[13:34:37.249] resolve() on list ... DONE
[13:34:37.249] result() for MulticoreFuture ...
[13:34:37.250] result() for MulticoreFuture ... done
[13:34:37.250] result() for MulticoreFuture ...
[13:34:37.250] result() for MulticoreFuture ... done
[13:34:37.250] result() for MulticoreFuture ...
[13:34:37.250] result() for MulticoreFuture ... done
[13:34:37.250] result() for MulticoreFuture ...
[13:34:37.250] result() for MulticoreFuture ... done
[13:34:37.250]  - Number of value chunks collected: 2
[13:34:37.251] Resolving 2 futures (chunks) ... DONE
[13:34:37.251] Reducing values from 2 chunks ...
[13:34:37.251]  - Number of values collected after concatenation: 5
[13:34:37.251]  - Number of values expected: 5
[13:34:37.251] Reducing values from 2 chunks ... DONE
[13:34:37.251] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[13:34:37.253] future_mapply() ...
[13:34:37.257] Number of chunks: 2
[13:34:37.257] getGlobalsAndPackagesXApply() ...
[13:34:37.257]  - future.globals: TRUE
[13:34:37.258] getGlobalsAndPackages() ...
[13:34:37.258] Searching for globals...
[13:34:37.258] - globals found: [1] ‘FUN’
[13:34:37.259] Searching for globals ... DONE
[13:34:37.259] Resolving globals: FALSE
[13:34:37.259] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:37.259] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:37.260] - globals: [1] ‘FUN’
[13:34:37.260] 
[13:34:37.260] getGlobalsAndPackages() ... DONE
[13:34:37.260]  - globals found/used: [n=1] ‘FUN’
[13:34:37.260]  - needed namespaces: [n=0] 
[13:34:37.260] Finding globals ... DONE
[13:34:37.260] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:37.260] List of 2
[13:34:37.260]  $ ...future.FUN:function (e1, e2)  
[13:34:37.260]  $ MoreArgs     : NULL
[13:34:37.260]  - attr(*, "where")=List of 2
[13:34:37.260]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:37.260]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:37.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.260]  - attr(*, "resolved")= logi FALSE
[13:34:37.260]  - attr(*, "total_size")= num NA
[13:34:37.263] Packages to be attached in all futures: [n=0] 
[13:34:37.264] getGlobalsAndPackagesXApply() ... DONE
[13:34:37.264] Number of futures (= number of chunks): 2
[13:34:37.264] Launching 2 futures (chunks) ...
[13:34:37.264] Chunk #1 of 2 ...
[13:34:37.264]  - Finding globals in '...' for chunk #1 ...
[13:34:37.264] getGlobalsAndPackages() ...
[13:34:37.264] Searching for globals...
[13:34:37.265] 
[13:34:37.265] Searching for globals ... DONE
[13:34:37.265] - globals: [0] <none>
[13:34:37.265] getGlobalsAndPackages() ... DONE
[13:34:37.265]    + additional globals found: [n=0] 
[13:34:37.265]    + additional namespaces needed: [n=0] 
[13:34:37.265]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:37.266]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:37.266]  - seeds: <none>
[13:34:37.266]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.266] getGlobalsAndPackages() ...
[13:34:37.266] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.266] Resolving globals: FALSE
[13:34:37.267] The total size of the 5 globals is 168 bytes (168 bytes)
[13:34:37.267] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:37.267] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.267] 
[13:34:37.267] getGlobalsAndPackages() ... DONE
[13:34:37.268] run() for ‘Future’ ...
[13:34:37.268] - state: ‘created’
[13:34:37.268] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:37.272] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:37.272]   - Field: ‘label’
[13:34:37.272]   - Field: ‘local’
[13:34:37.272]   - Field: ‘owner’
[13:34:37.272]   - Field: ‘envir’
[13:34:37.273]   - Field: ‘workers’
[13:34:37.273]   - Field: ‘packages’
[13:34:37.273]   - Field: ‘gc’
[13:34:37.273]   - Field: ‘job’
[13:34:37.273]   - Field: ‘conditions’
[13:34:37.273]   - Field: ‘expr’
[13:34:37.273]   - Field: ‘uuid’
[13:34:37.273]   - Field: ‘seed’
[13:34:37.273]   - Field: ‘version’
[13:34:37.274]   - Field: ‘result’
[13:34:37.274]   - Field: ‘asynchronous’
[13:34:37.274]   - Field: ‘calls’
[13:34:37.274]   - Field: ‘globals’
[13:34:37.274]   - Field: ‘stdout’
[13:34:37.274]   - Field: ‘earlySignal’
[13:34:37.274]   - Field: ‘lazy’
[13:34:37.274]   - Field: ‘state’
[13:34:37.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:37.275] - Launch lazy future ...
[13:34:37.275] Packages needed by the future expression (n = 0): <none>
[13:34:37.275] Packages needed by future strategies (n = 0): <none>
[13:34:37.275] {
[13:34:37.275]     {
[13:34:37.275]         {
[13:34:37.275]             ...future.startTime <- base::Sys.time()
[13:34:37.275]             {
[13:34:37.275]                 {
[13:34:37.275]                   {
[13:34:37.275]                     {
[13:34:37.275]                       base::local({
[13:34:37.275]                         has_future <- base::requireNamespace("future", 
[13:34:37.275]                           quietly = TRUE)
[13:34:37.275]                         if (has_future) {
[13:34:37.275]                           ns <- base::getNamespace("future")
[13:34:37.275]                           version <- ns[[".package"]][["version"]]
[13:34:37.275]                           if (is.null(version)) 
[13:34:37.275]                             version <- utils::packageVersion("future")
[13:34:37.275]                         }
[13:34:37.275]                         else {
[13:34:37.275]                           version <- NULL
[13:34:37.275]                         }
[13:34:37.275]                         if (!has_future || version < "1.8.0") {
[13:34:37.275]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:37.275]                             "", base::R.version$version.string), 
[13:34:37.275]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:37.275]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:37.275]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:37.275]                               "release", "version")], collapse = " "), 
[13:34:37.275]                             hostname = base::Sys.info()[["nodename"]])
[13:34:37.275]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:37.275]                             info)
[13:34:37.275]                           info <- base::paste(info, collapse = "; ")
[13:34:37.275]                           if (!has_future) {
[13:34:37.275]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:37.275]                               info)
[13:34:37.275]                           }
[13:34:37.275]                           else {
[13:34:37.275]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:37.275]                               info, version)
[13:34:37.275]                           }
[13:34:37.275]                           base::stop(msg)
[13:34:37.275]                         }
[13:34:37.275]                       })
[13:34:37.275]                     }
[13:34:37.275]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:37.275]                     base::options(mc.cores = 1L)
[13:34:37.275]                   }
[13:34:37.275]                   ...future.strategy.old <- future::plan("list")
[13:34:37.275]                   options(future.plan = NULL)
[13:34:37.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:37.275]                 }
[13:34:37.275]                 ...future.workdir <- getwd()
[13:34:37.275]             }
[13:34:37.275]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:37.275]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:37.275]         }
[13:34:37.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:37.275]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:37.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:37.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:37.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:37.275]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:37.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:37.275]             base::names(...future.oldOptions))
[13:34:37.275]     }
[13:34:37.275]     if (FALSE) {
[13:34:37.275]     }
[13:34:37.275]     else {
[13:34:37.275]         if (TRUE) {
[13:34:37.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:37.275]                 open = "w")
[13:34:37.275]         }
[13:34:37.275]         else {
[13:34:37.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:37.275]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:37.275]         }
[13:34:37.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:37.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:37.275]             base::sink(type = "output", split = FALSE)
[13:34:37.275]             base::close(...future.stdout)
[13:34:37.275]         }, add = TRUE)
[13:34:37.275]     }
[13:34:37.275]     ...future.frame <- base::sys.nframe()
[13:34:37.275]     ...future.conditions <- base::list()
[13:34:37.275]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:37.275]     if (FALSE) {
[13:34:37.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:37.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:37.275]     }
[13:34:37.275]     ...future.result <- base::tryCatch({
[13:34:37.275]         base::withCallingHandlers({
[13:34:37.275]             ...future.value <- base::withVisible(base::local({
[13:34:37.275]                 withCallingHandlers({
[13:34:37.275]                   {
[13:34:37.275]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.275]                     if (!identical(...future.globals.maxSize.org, 
[13:34:37.275]                       ...future.globals.maxSize)) {
[13:34:37.275]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.275]                       on.exit(options(oopts), add = TRUE)
[13:34:37.275]                     }
[13:34:37.275]                     {
[13:34:37.275]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.275]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:37.275]                         USE.NAMES = FALSE)
[13:34:37.275]                       do.call(mapply, args = args)
[13:34:37.275]                     }
[13:34:37.275]                   }
[13:34:37.275]                 }, immediateCondition = function(cond) {
[13:34:37.275]                   save_rds <- function (object, pathname, ...) 
[13:34:37.275]                   {
[13:34:37.275]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:37.275]                     if (file_test("-f", pathname_tmp)) {
[13:34:37.275]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.275]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:37.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.275]                         fi_tmp[["mtime"]])
[13:34:37.275]                     }
[13:34:37.275]                     tryCatch({
[13:34:37.275]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:37.275]                     }, error = function(ex) {
[13:34:37.275]                       msg <- conditionMessage(ex)
[13:34:37.275]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.275]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:37.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.275]                         fi_tmp[["mtime"]], msg)
[13:34:37.275]                       ex$message <- msg
[13:34:37.275]                       stop(ex)
[13:34:37.275]                     })
[13:34:37.275]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:37.275]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:37.275]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:37.275]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.275]                       fi <- file.info(pathname)
[13:34:37.275]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:37.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.275]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:37.275]                         fi[["size"]], fi[["mtime"]])
[13:34:37.275]                       stop(msg)
[13:34:37.275]                     }
[13:34:37.275]                     invisible(pathname)
[13:34:37.275]                   }
[13:34:37.275]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:37.275]                     rootPath = tempdir()) 
[13:34:37.275]                   {
[13:34:37.275]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:37.275]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:37.275]                       tmpdir = path, fileext = ".rds")
[13:34:37.275]                     save_rds(obj, file)
[13:34:37.275]                   }
[13:34:37.275]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:37.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.275]                   {
[13:34:37.275]                     inherits <- base::inherits
[13:34:37.275]                     invokeRestart <- base::invokeRestart
[13:34:37.275]                     is.null <- base::is.null
[13:34:37.275]                     muffled <- FALSE
[13:34:37.275]                     if (inherits(cond, "message")) {
[13:34:37.275]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:37.275]                       if (muffled) 
[13:34:37.275]                         invokeRestart("muffleMessage")
[13:34:37.275]                     }
[13:34:37.275]                     else if (inherits(cond, "warning")) {
[13:34:37.275]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:37.275]                       if (muffled) 
[13:34:37.275]                         invokeRestart("muffleWarning")
[13:34:37.275]                     }
[13:34:37.275]                     else if (inherits(cond, "condition")) {
[13:34:37.275]                       if (!is.null(pattern)) {
[13:34:37.275]                         computeRestarts <- base::computeRestarts
[13:34:37.275]                         grepl <- base::grepl
[13:34:37.275]                         restarts <- computeRestarts(cond)
[13:34:37.275]                         for (restart in restarts) {
[13:34:37.275]                           name <- restart$name
[13:34:37.275]                           if (is.null(name)) 
[13:34:37.275]                             next
[13:34:37.275]                           if (!grepl(pattern, name)) 
[13:34:37.275]                             next
[13:34:37.275]                           invokeRestart(restart)
[13:34:37.275]                           muffled <- TRUE
[13:34:37.275]                           break
[13:34:37.275]                         }
[13:34:37.275]                       }
[13:34:37.275]                     }
[13:34:37.275]                     invisible(muffled)
[13:34:37.275]                   }
[13:34:37.275]                   muffleCondition(cond)
[13:34:37.275]                 })
[13:34:37.275]             }))
[13:34:37.275]             future::FutureResult(value = ...future.value$value, 
[13:34:37.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.275]                   ...future.rng), globalenv = if (FALSE) 
[13:34:37.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:37.275]                     ...future.globalenv.names))
[13:34:37.275]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:37.275]         }, condition = base::local({
[13:34:37.275]             c <- base::c
[13:34:37.275]             inherits <- base::inherits
[13:34:37.275]             invokeRestart <- base::invokeRestart
[13:34:37.275]             length <- base::length
[13:34:37.275]             list <- base::list
[13:34:37.275]             seq.int <- base::seq.int
[13:34:37.275]             signalCondition <- base::signalCondition
[13:34:37.275]             sys.calls <- base::sys.calls
[13:34:37.275]             `[[` <- base::`[[`
[13:34:37.275]             `+` <- base::`+`
[13:34:37.275]             `<<-` <- base::`<<-`
[13:34:37.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:37.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:37.275]                   3L)]
[13:34:37.275]             }
[13:34:37.275]             function(cond) {
[13:34:37.275]                 is_error <- inherits(cond, "error")
[13:34:37.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:37.275]                   NULL)
[13:34:37.275]                 if (is_error) {
[13:34:37.275]                   sessionInformation <- function() {
[13:34:37.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:37.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:37.275]                       search = base::search(), system = base::Sys.info())
[13:34:37.275]                   }
[13:34:37.275]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:37.275]                     cond$call), session = sessionInformation(), 
[13:34:37.275]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:37.275]                   signalCondition(cond)
[13:34:37.275]                 }
[13:34:37.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:37.275]                 "immediateCondition"))) {
[13:34:37.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:37.275]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:37.275]                   if (TRUE && !signal) {
[13:34:37.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.275]                     {
[13:34:37.275]                       inherits <- base::inherits
[13:34:37.275]                       invokeRestart <- base::invokeRestart
[13:34:37.275]                       is.null <- base::is.null
[13:34:37.275]                       muffled <- FALSE
[13:34:37.275]                       if (inherits(cond, "message")) {
[13:34:37.275]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.275]                         if (muffled) 
[13:34:37.275]                           invokeRestart("muffleMessage")
[13:34:37.275]                       }
[13:34:37.275]                       else if (inherits(cond, "warning")) {
[13:34:37.275]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.275]                         if (muffled) 
[13:34:37.275]                           invokeRestart("muffleWarning")
[13:34:37.275]                       }
[13:34:37.275]                       else if (inherits(cond, "condition")) {
[13:34:37.275]                         if (!is.null(pattern)) {
[13:34:37.275]                           computeRestarts <- base::computeRestarts
[13:34:37.275]                           grepl <- base::grepl
[13:34:37.275]                           restarts <- computeRestarts(cond)
[13:34:37.275]                           for (restart in restarts) {
[13:34:37.275]                             name <- restart$name
[13:34:37.275]                             if (is.null(name)) 
[13:34:37.275]                               next
[13:34:37.275]                             if (!grepl(pattern, name)) 
[13:34:37.275]                               next
[13:34:37.275]                             invokeRestart(restart)
[13:34:37.275]                             muffled <- TRUE
[13:34:37.275]                             break
[13:34:37.275]                           }
[13:34:37.275]                         }
[13:34:37.275]                       }
[13:34:37.275]                       invisible(muffled)
[13:34:37.275]                     }
[13:34:37.275]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.275]                   }
[13:34:37.275]                 }
[13:34:37.275]                 else {
[13:34:37.275]                   if (TRUE) {
[13:34:37.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.275]                     {
[13:34:37.275]                       inherits <- base::inherits
[13:34:37.275]                       invokeRestart <- base::invokeRestart
[13:34:37.275]                       is.null <- base::is.null
[13:34:37.275]                       muffled <- FALSE
[13:34:37.275]                       if (inherits(cond, "message")) {
[13:34:37.275]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.275]                         if (muffled) 
[13:34:37.275]                           invokeRestart("muffleMessage")
[13:34:37.275]                       }
[13:34:37.275]                       else if (inherits(cond, "warning")) {
[13:34:37.275]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.275]                         if (muffled) 
[13:34:37.275]                           invokeRestart("muffleWarning")
[13:34:37.275]                       }
[13:34:37.275]                       else if (inherits(cond, "condition")) {
[13:34:37.275]                         if (!is.null(pattern)) {
[13:34:37.275]                           computeRestarts <- base::computeRestarts
[13:34:37.275]                           grepl <- base::grepl
[13:34:37.275]                           restarts <- computeRestarts(cond)
[13:34:37.275]                           for (restart in restarts) {
[13:34:37.275]                             name <- restart$name
[13:34:37.275]                             if (is.null(name)) 
[13:34:37.275]                               next
[13:34:37.275]                             if (!grepl(pattern, name)) 
[13:34:37.275]                               next
[13:34:37.275]                             invokeRestart(restart)
[13:34:37.275]                             muffled <- TRUE
[13:34:37.275]                             break
[13:34:37.275]                           }
[13:34:37.275]                         }
[13:34:37.275]                       }
[13:34:37.275]                       invisible(muffled)
[13:34:37.275]                     }
[13:34:37.275]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.275]                   }
[13:34:37.275]                 }
[13:34:37.275]             }
[13:34:37.275]         }))
[13:34:37.275]     }, error = function(ex) {
[13:34:37.275]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:37.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.275]                 ...future.rng), started = ...future.startTime, 
[13:34:37.275]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:37.275]             version = "1.8"), class = "FutureResult")
[13:34:37.275]     }, finally = {
[13:34:37.275]         if (!identical(...future.workdir, getwd())) 
[13:34:37.275]             setwd(...future.workdir)
[13:34:37.275]         {
[13:34:37.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:37.275]                 ...future.oldOptions$nwarnings <- NULL
[13:34:37.275]             }
[13:34:37.275]             base::options(...future.oldOptions)
[13:34:37.275]             if (.Platform$OS.type == "windows") {
[13:34:37.275]                 old_names <- names(...future.oldEnvVars)
[13:34:37.275]                 envs <- base::Sys.getenv()
[13:34:37.275]                 names <- names(envs)
[13:34:37.275]                 common <- intersect(names, old_names)
[13:34:37.275]                 added <- setdiff(names, old_names)
[13:34:37.275]                 removed <- setdiff(old_names, names)
[13:34:37.275]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:37.275]                   envs[common]]
[13:34:37.275]                 NAMES <- toupper(changed)
[13:34:37.275]                 args <- list()
[13:34:37.275]                 for (kk in seq_along(NAMES)) {
[13:34:37.275]                   name <- changed[[kk]]
[13:34:37.275]                   NAME <- NAMES[[kk]]
[13:34:37.275]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.275]                     next
[13:34:37.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.275]                 }
[13:34:37.275]                 NAMES <- toupper(added)
[13:34:37.275]                 for (kk in seq_along(NAMES)) {
[13:34:37.275]                   name <- added[[kk]]
[13:34:37.275]                   NAME <- NAMES[[kk]]
[13:34:37.275]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.275]                     next
[13:34:37.275]                   args[[name]] <- ""
[13:34:37.275]                 }
[13:34:37.275]                 NAMES <- toupper(removed)
[13:34:37.275]                 for (kk in seq_along(NAMES)) {
[13:34:37.275]                   name <- removed[[kk]]
[13:34:37.275]                   NAME <- NAMES[[kk]]
[13:34:37.275]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.275]                     next
[13:34:37.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.275]                 }
[13:34:37.275]                 if (length(args) > 0) 
[13:34:37.275]                   base::do.call(base::Sys.setenv, args = args)
[13:34:37.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:37.275]             }
[13:34:37.275]             else {
[13:34:37.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:37.275]             }
[13:34:37.275]             {
[13:34:37.275]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:37.275]                   0L) {
[13:34:37.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:37.275]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:37.275]                   base::options(opts)
[13:34:37.275]                 }
[13:34:37.275]                 {
[13:34:37.275]                   {
[13:34:37.275]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:37.275]                     NULL
[13:34:37.275]                   }
[13:34:37.275]                   options(future.plan = NULL)
[13:34:37.275]                   if (is.na(NA_character_)) 
[13:34:37.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:37.275]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:37.275]                     .init = FALSE)
[13:34:37.275]                 }
[13:34:37.275]             }
[13:34:37.275]         }
[13:34:37.275]     })
[13:34:37.275]     if (TRUE) {
[13:34:37.275]         base::sink(type = "output", split = FALSE)
[13:34:37.275]         if (TRUE) {
[13:34:37.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:37.275]         }
[13:34:37.275]         else {
[13:34:37.275]             ...future.result["stdout"] <- base::list(NULL)
[13:34:37.275]         }
[13:34:37.275]         base::close(...future.stdout)
[13:34:37.275]         ...future.stdout <- NULL
[13:34:37.275]     }
[13:34:37.275]     ...future.result$conditions <- ...future.conditions
[13:34:37.275]     ...future.result$finished <- base::Sys.time()
[13:34:37.275]     ...future.result
[13:34:37.275] }
[13:34:37.278] assign_globals() ...
[13:34:37.278] List of 5
[13:34:37.278]  $ ...future.FUN            :function (e1, e2)  
[13:34:37.278]  $ MoreArgs                 : NULL
[13:34:37.278]  $ ...future.elements_ii    :List of 2
[13:34:37.278]   ..$ :List of 1
[13:34:37.278]   .. ..$ : num 1
[13:34:37.278]   ..$ :List of 1
[13:34:37.278]   .. ..$ : int 1
[13:34:37.278]  $ ...future.seeds_ii       : NULL
[13:34:37.278]  $ ...future.globals.maxSize: NULL
[13:34:37.278]  - attr(*, "where")=List of 5
[13:34:37.278]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:37.278]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:37.278]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:37.278]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:37.278]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:37.278]  - attr(*, "resolved")= logi FALSE
[13:34:37.278]  - attr(*, "total_size")= num 168
[13:34:37.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.278]  - attr(*, "already-done")= logi TRUE
[13:34:37.286] - copied ‘...future.FUN’ to environment
[13:34:37.287] - copied ‘MoreArgs’ to environment
[13:34:37.287] - copied ‘...future.elements_ii’ to environment
[13:34:37.287] - copied ‘...future.seeds_ii’ to environment
[13:34:37.287] - copied ‘...future.globals.maxSize’ to environment
[13:34:37.287] assign_globals() ... done
[13:34:37.287] requestCore(): workers = 2
[13:34:37.289] MulticoreFuture started
[13:34:37.290] - Launch lazy future ... done
[13:34:37.290] run() for ‘MulticoreFuture’ ... done
[13:34:37.290] Created future:
[13:34:37.290] plan(): Setting new future strategy stack:
[13:34:37.291] List of future strategies:
[13:34:37.291] 1. sequential:
[13:34:37.291]    - args: function (..., envir = parent.frame())
[13:34:37.291]    - tweaked: FALSE
[13:34:37.291]    - call: NULL
[13:34:37.291] plan(): nbrOfWorkers() = 1
[13:34:37.293] plan(): Setting new future strategy stack:
[13:34:37.293] List of future strategies:
[13:34:37.293] 1. multicore:
[13:34:37.293]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:37.293]    - tweaked: FALSE
[13:34:37.293]    - call: plan(strategy)
[13:34:37.298] plan(): nbrOfWorkers() = 2
[13:34:37.290] MulticoreFuture:
[13:34:37.290] Label: ‘future_Map-1’
[13:34:37.290] Expression:
[13:34:37.290] {
[13:34:37.290]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.290]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:37.290]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.290]         on.exit(options(oopts), add = TRUE)
[13:34:37.290]     }
[13:34:37.290]     {
[13:34:37.290]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.290]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:37.290]         do.call(mapply, args = args)
[13:34:37.290]     }
[13:34:37.290] }
[13:34:37.290] Lazy evaluation: FALSE
[13:34:37.290] Asynchronous evaluation: TRUE
[13:34:37.290] Local evaluation: TRUE
[13:34:37.290] Environment: R_GlobalEnv
[13:34:37.290] Capture standard output: TRUE
[13:34:37.290] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:37.290] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:37.290] Packages: <none>
[13:34:37.290] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:37.290] Resolved: TRUE
[13:34:37.290] Value: <not collected>
[13:34:37.290] Conditions captured: <none>
[13:34:37.290] Early signaling: FALSE
[13:34:37.290] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:37.290] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.300] Chunk #1 of 2 ... DONE
[13:34:37.300] Chunk #2 of 2 ...
[13:34:37.300]  - Finding globals in '...' for chunk #2 ...
[13:34:37.300] getGlobalsAndPackages() ...
[13:34:37.300] Searching for globals...
[13:34:37.301] 
[13:34:37.301] Searching for globals ... DONE
[13:34:37.301] - globals: [0] <none>
[13:34:37.301] getGlobalsAndPackages() ... DONE
[13:34:37.301]    + additional globals found: [n=0] 
[13:34:37.301]    + additional namespaces needed: [n=0] 
[13:34:37.302]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:37.302]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:37.302]  - seeds: <none>
[13:34:37.302]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.302] getGlobalsAndPackages() ...
[13:34:37.302] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.303] Resolving globals: FALSE
[13:34:37.303] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:37.304] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:37.304] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.304] 
[13:34:37.305] getGlobalsAndPackages() ... DONE
[13:34:37.305] run() for ‘Future’ ...
[13:34:37.305] - state: ‘created’
[13:34:37.305] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:37.311] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.311] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:37.311]   - Field: ‘label’
[13:34:37.311]   - Field: ‘local’
[13:34:37.311]   - Field: ‘owner’
[13:34:37.311]   - Field: ‘envir’
[13:34:37.312]   - Field: ‘workers’
[13:34:37.312]   - Field: ‘packages’
[13:34:37.312]   - Field: ‘gc’
[13:34:37.312]   - Field: ‘job’
[13:34:37.312]   - Field: ‘conditions’
[13:34:37.312]   - Field: ‘expr’
[13:34:37.313]   - Field: ‘uuid’
[13:34:37.313]   - Field: ‘seed’
[13:34:37.313]   - Field: ‘version’
[13:34:37.313]   - Field: ‘result’
[13:34:37.313]   - Field: ‘asynchronous’
[13:34:37.313]   - Field: ‘calls’
[13:34:37.314]   - Field: ‘globals’
[13:34:37.314]   - Field: ‘stdout’
[13:34:37.314]   - Field: ‘earlySignal’
[13:34:37.314]   - Field: ‘lazy’
[13:34:37.314]   - Field: ‘state’
[13:34:37.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:37.315] - Launch lazy future ...
[13:34:37.315] Packages needed by the future expression (n = 0): <none>
[13:34:37.315] Packages needed by future strategies (n = 0): <none>
[13:34:37.316] {
[13:34:37.316]     {
[13:34:37.316]         {
[13:34:37.316]             ...future.startTime <- base::Sys.time()
[13:34:37.316]             {
[13:34:37.316]                 {
[13:34:37.316]                   {
[13:34:37.316]                     {
[13:34:37.316]                       base::local({
[13:34:37.316]                         has_future <- base::requireNamespace("future", 
[13:34:37.316]                           quietly = TRUE)
[13:34:37.316]                         if (has_future) {
[13:34:37.316]                           ns <- base::getNamespace("future")
[13:34:37.316]                           version <- ns[[".package"]][["version"]]
[13:34:37.316]                           if (is.null(version)) 
[13:34:37.316]                             version <- utils::packageVersion("future")
[13:34:37.316]                         }
[13:34:37.316]                         else {
[13:34:37.316]                           version <- NULL
[13:34:37.316]                         }
[13:34:37.316]                         if (!has_future || version < "1.8.0") {
[13:34:37.316]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:37.316]                             "", base::R.version$version.string), 
[13:34:37.316]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:37.316]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:37.316]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:37.316]                               "release", "version")], collapse = " "), 
[13:34:37.316]                             hostname = base::Sys.info()[["nodename"]])
[13:34:37.316]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:37.316]                             info)
[13:34:37.316]                           info <- base::paste(info, collapse = "; ")
[13:34:37.316]                           if (!has_future) {
[13:34:37.316]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:37.316]                               info)
[13:34:37.316]                           }
[13:34:37.316]                           else {
[13:34:37.316]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:37.316]                               info, version)
[13:34:37.316]                           }
[13:34:37.316]                           base::stop(msg)
[13:34:37.316]                         }
[13:34:37.316]                       })
[13:34:37.316]                     }
[13:34:37.316]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:37.316]                     base::options(mc.cores = 1L)
[13:34:37.316]                   }
[13:34:37.316]                   ...future.strategy.old <- future::plan("list")
[13:34:37.316]                   options(future.plan = NULL)
[13:34:37.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:37.316]                 }
[13:34:37.316]                 ...future.workdir <- getwd()
[13:34:37.316]             }
[13:34:37.316]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:37.316]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:37.316]         }
[13:34:37.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:37.316]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:37.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:37.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:37.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:37.316]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:37.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:37.316]             base::names(...future.oldOptions))
[13:34:37.316]     }
[13:34:37.316]     if (FALSE) {
[13:34:37.316]     }
[13:34:37.316]     else {
[13:34:37.316]         if (TRUE) {
[13:34:37.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:37.316]                 open = "w")
[13:34:37.316]         }
[13:34:37.316]         else {
[13:34:37.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:37.316]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:37.316]         }
[13:34:37.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:37.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:37.316]             base::sink(type = "output", split = FALSE)
[13:34:37.316]             base::close(...future.stdout)
[13:34:37.316]         }, add = TRUE)
[13:34:37.316]     }
[13:34:37.316]     ...future.frame <- base::sys.nframe()
[13:34:37.316]     ...future.conditions <- base::list()
[13:34:37.316]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:37.316]     if (FALSE) {
[13:34:37.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:37.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:37.316]     }
[13:34:37.316]     ...future.result <- base::tryCatch({
[13:34:37.316]         base::withCallingHandlers({
[13:34:37.316]             ...future.value <- base::withVisible(base::local({
[13:34:37.316]                 withCallingHandlers({
[13:34:37.316]                   {
[13:34:37.316]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.316]                     if (!identical(...future.globals.maxSize.org, 
[13:34:37.316]                       ...future.globals.maxSize)) {
[13:34:37.316]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.316]                       on.exit(options(oopts), add = TRUE)
[13:34:37.316]                     }
[13:34:37.316]                     {
[13:34:37.316]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.316]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:37.316]                         USE.NAMES = FALSE)
[13:34:37.316]                       do.call(mapply, args = args)
[13:34:37.316]                     }
[13:34:37.316]                   }
[13:34:37.316]                 }, immediateCondition = function(cond) {
[13:34:37.316]                   save_rds <- function (object, pathname, ...) 
[13:34:37.316]                   {
[13:34:37.316]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:37.316]                     if (file_test("-f", pathname_tmp)) {
[13:34:37.316]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.316]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:37.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.316]                         fi_tmp[["mtime"]])
[13:34:37.316]                     }
[13:34:37.316]                     tryCatch({
[13:34:37.316]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:37.316]                     }, error = function(ex) {
[13:34:37.316]                       msg <- conditionMessage(ex)
[13:34:37.316]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.316]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:37.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.316]                         fi_tmp[["mtime"]], msg)
[13:34:37.316]                       ex$message <- msg
[13:34:37.316]                       stop(ex)
[13:34:37.316]                     })
[13:34:37.316]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:37.316]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:37.316]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:37.316]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.316]                       fi <- file.info(pathname)
[13:34:37.316]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:37.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.316]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:37.316]                         fi[["size"]], fi[["mtime"]])
[13:34:37.316]                       stop(msg)
[13:34:37.316]                     }
[13:34:37.316]                     invisible(pathname)
[13:34:37.316]                   }
[13:34:37.316]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:37.316]                     rootPath = tempdir()) 
[13:34:37.316]                   {
[13:34:37.316]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:37.316]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:37.316]                       tmpdir = path, fileext = ".rds")
[13:34:37.316]                     save_rds(obj, file)
[13:34:37.316]                   }
[13:34:37.316]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:37.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.316]                   {
[13:34:37.316]                     inherits <- base::inherits
[13:34:37.316]                     invokeRestart <- base::invokeRestart
[13:34:37.316]                     is.null <- base::is.null
[13:34:37.316]                     muffled <- FALSE
[13:34:37.316]                     if (inherits(cond, "message")) {
[13:34:37.316]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:37.316]                       if (muffled) 
[13:34:37.316]                         invokeRestart("muffleMessage")
[13:34:37.316]                     }
[13:34:37.316]                     else if (inherits(cond, "warning")) {
[13:34:37.316]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:37.316]                       if (muffled) 
[13:34:37.316]                         invokeRestart("muffleWarning")
[13:34:37.316]                     }
[13:34:37.316]                     else if (inherits(cond, "condition")) {
[13:34:37.316]                       if (!is.null(pattern)) {
[13:34:37.316]                         computeRestarts <- base::computeRestarts
[13:34:37.316]                         grepl <- base::grepl
[13:34:37.316]                         restarts <- computeRestarts(cond)
[13:34:37.316]                         for (restart in restarts) {
[13:34:37.316]                           name <- restart$name
[13:34:37.316]                           if (is.null(name)) 
[13:34:37.316]                             next
[13:34:37.316]                           if (!grepl(pattern, name)) 
[13:34:37.316]                             next
[13:34:37.316]                           invokeRestart(restart)
[13:34:37.316]                           muffled <- TRUE
[13:34:37.316]                           break
[13:34:37.316]                         }
[13:34:37.316]                       }
[13:34:37.316]                     }
[13:34:37.316]                     invisible(muffled)
[13:34:37.316]                   }
[13:34:37.316]                   muffleCondition(cond)
[13:34:37.316]                 })
[13:34:37.316]             }))
[13:34:37.316]             future::FutureResult(value = ...future.value$value, 
[13:34:37.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.316]                   ...future.rng), globalenv = if (FALSE) 
[13:34:37.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:37.316]                     ...future.globalenv.names))
[13:34:37.316]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:37.316]         }, condition = base::local({
[13:34:37.316]             c <- base::c
[13:34:37.316]             inherits <- base::inherits
[13:34:37.316]             invokeRestart <- base::invokeRestart
[13:34:37.316]             length <- base::length
[13:34:37.316]             list <- base::list
[13:34:37.316]             seq.int <- base::seq.int
[13:34:37.316]             signalCondition <- base::signalCondition
[13:34:37.316]             sys.calls <- base::sys.calls
[13:34:37.316]             `[[` <- base::`[[`
[13:34:37.316]             `+` <- base::`+`
[13:34:37.316]             `<<-` <- base::`<<-`
[13:34:37.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:37.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:37.316]                   3L)]
[13:34:37.316]             }
[13:34:37.316]             function(cond) {
[13:34:37.316]                 is_error <- inherits(cond, "error")
[13:34:37.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:37.316]                   NULL)
[13:34:37.316]                 if (is_error) {
[13:34:37.316]                   sessionInformation <- function() {
[13:34:37.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:37.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:37.316]                       search = base::search(), system = base::Sys.info())
[13:34:37.316]                   }
[13:34:37.316]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:37.316]                     cond$call), session = sessionInformation(), 
[13:34:37.316]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:37.316]                   signalCondition(cond)
[13:34:37.316]                 }
[13:34:37.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:37.316]                 "immediateCondition"))) {
[13:34:37.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:37.316]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:37.316]                   if (TRUE && !signal) {
[13:34:37.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.316]                     {
[13:34:37.316]                       inherits <- base::inherits
[13:34:37.316]                       invokeRestart <- base::invokeRestart
[13:34:37.316]                       is.null <- base::is.null
[13:34:37.316]                       muffled <- FALSE
[13:34:37.316]                       if (inherits(cond, "message")) {
[13:34:37.316]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.316]                         if (muffled) 
[13:34:37.316]                           invokeRestart("muffleMessage")
[13:34:37.316]                       }
[13:34:37.316]                       else if (inherits(cond, "warning")) {
[13:34:37.316]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.316]                         if (muffled) 
[13:34:37.316]                           invokeRestart("muffleWarning")
[13:34:37.316]                       }
[13:34:37.316]                       else if (inherits(cond, "condition")) {
[13:34:37.316]                         if (!is.null(pattern)) {
[13:34:37.316]                           computeRestarts <- base::computeRestarts
[13:34:37.316]                           grepl <- base::grepl
[13:34:37.316]                           restarts <- computeRestarts(cond)
[13:34:37.316]                           for (restart in restarts) {
[13:34:37.316]                             name <- restart$name
[13:34:37.316]                             if (is.null(name)) 
[13:34:37.316]                               next
[13:34:37.316]                             if (!grepl(pattern, name)) 
[13:34:37.316]                               next
[13:34:37.316]                             invokeRestart(restart)
[13:34:37.316]                             muffled <- TRUE
[13:34:37.316]                             break
[13:34:37.316]                           }
[13:34:37.316]                         }
[13:34:37.316]                       }
[13:34:37.316]                       invisible(muffled)
[13:34:37.316]                     }
[13:34:37.316]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.316]                   }
[13:34:37.316]                 }
[13:34:37.316]                 else {
[13:34:37.316]                   if (TRUE) {
[13:34:37.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.316]                     {
[13:34:37.316]                       inherits <- base::inherits
[13:34:37.316]                       invokeRestart <- base::invokeRestart
[13:34:37.316]                       is.null <- base::is.null
[13:34:37.316]                       muffled <- FALSE
[13:34:37.316]                       if (inherits(cond, "message")) {
[13:34:37.316]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.316]                         if (muffled) 
[13:34:37.316]                           invokeRestart("muffleMessage")
[13:34:37.316]                       }
[13:34:37.316]                       else if (inherits(cond, "warning")) {
[13:34:37.316]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.316]                         if (muffled) 
[13:34:37.316]                           invokeRestart("muffleWarning")
[13:34:37.316]                       }
[13:34:37.316]                       else if (inherits(cond, "condition")) {
[13:34:37.316]                         if (!is.null(pattern)) {
[13:34:37.316]                           computeRestarts <- base::computeRestarts
[13:34:37.316]                           grepl <- base::grepl
[13:34:37.316]                           restarts <- computeRestarts(cond)
[13:34:37.316]                           for (restart in restarts) {
[13:34:37.316]                             name <- restart$name
[13:34:37.316]                             if (is.null(name)) 
[13:34:37.316]                               next
[13:34:37.316]                             if (!grepl(pattern, name)) 
[13:34:37.316]                               next
[13:34:37.316]                             invokeRestart(restart)
[13:34:37.316]                             muffled <- TRUE
[13:34:37.316]                             break
[13:34:37.316]                           }
[13:34:37.316]                         }
[13:34:37.316]                       }
[13:34:37.316]                       invisible(muffled)
[13:34:37.316]                     }
[13:34:37.316]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.316]                   }
[13:34:37.316]                 }
[13:34:37.316]             }
[13:34:37.316]         }))
[13:34:37.316]     }, error = function(ex) {
[13:34:37.316]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:37.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.316]                 ...future.rng), started = ...future.startTime, 
[13:34:37.316]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:37.316]             version = "1.8"), class = "FutureResult")
[13:34:37.316]     }, finally = {
[13:34:37.316]         if (!identical(...future.workdir, getwd())) 
[13:34:37.316]             setwd(...future.workdir)
[13:34:37.316]         {
[13:34:37.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:37.316]                 ...future.oldOptions$nwarnings <- NULL
[13:34:37.316]             }
[13:34:37.316]             base::options(...future.oldOptions)
[13:34:37.316]             if (.Platform$OS.type == "windows") {
[13:34:37.316]                 old_names <- names(...future.oldEnvVars)
[13:34:37.316]                 envs <- base::Sys.getenv()
[13:34:37.316]                 names <- names(envs)
[13:34:37.316]                 common <- intersect(names, old_names)
[13:34:37.316]                 added <- setdiff(names, old_names)
[13:34:37.316]                 removed <- setdiff(old_names, names)
[13:34:37.316]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:37.316]                   envs[common]]
[13:34:37.316]                 NAMES <- toupper(changed)
[13:34:37.316]                 args <- list()
[13:34:37.316]                 for (kk in seq_along(NAMES)) {
[13:34:37.316]                   name <- changed[[kk]]
[13:34:37.316]                   NAME <- NAMES[[kk]]
[13:34:37.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.316]                     next
[13:34:37.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.316]                 }
[13:34:37.316]                 NAMES <- toupper(added)
[13:34:37.316]                 for (kk in seq_along(NAMES)) {
[13:34:37.316]                   name <- added[[kk]]
[13:34:37.316]                   NAME <- NAMES[[kk]]
[13:34:37.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.316]                     next
[13:34:37.316]                   args[[name]] <- ""
[13:34:37.316]                 }
[13:34:37.316]                 NAMES <- toupper(removed)
[13:34:37.316]                 for (kk in seq_along(NAMES)) {
[13:34:37.316]                   name <- removed[[kk]]
[13:34:37.316]                   NAME <- NAMES[[kk]]
[13:34:37.316]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.316]                     next
[13:34:37.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.316]                 }
[13:34:37.316]                 if (length(args) > 0) 
[13:34:37.316]                   base::do.call(base::Sys.setenv, args = args)
[13:34:37.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:37.316]             }
[13:34:37.316]             else {
[13:34:37.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:37.316]             }
[13:34:37.316]             {
[13:34:37.316]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:37.316]                   0L) {
[13:34:37.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:37.316]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:37.316]                   base::options(opts)
[13:34:37.316]                 }
[13:34:37.316]                 {
[13:34:37.316]                   {
[13:34:37.316]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:37.316]                     NULL
[13:34:37.316]                   }
[13:34:37.316]                   options(future.plan = NULL)
[13:34:37.316]                   if (is.na(NA_character_)) 
[13:34:37.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:37.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:37.316]                     .init = FALSE)
[13:34:37.316]                 }
[13:34:37.316]             }
[13:34:37.316]         }
[13:34:37.316]     })
[13:34:37.316]     if (TRUE) {
[13:34:37.316]         base::sink(type = "output", split = FALSE)
[13:34:37.316]         if (TRUE) {
[13:34:37.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:37.316]         }
[13:34:37.316]         else {
[13:34:37.316]             ...future.result["stdout"] <- base::list(NULL)
[13:34:37.316]         }
[13:34:37.316]         base::close(...future.stdout)
[13:34:37.316]         ...future.stdout <- NULL
[13:34:37.316]     }
[13:34:37.316]     ...future.result$conditions <- ...future.conditions
[13:34:37.316]     ...future.result$finished <- base::Sys.time()
[13:34:37.316]     ...future.result
[13:34:37.316] }
[13:34:37.319] assign_globals() ...
[13:34:37.320] List of 5
[13:34:37.320]  $ ...future.FUN            :function (e1, e2)  
[13:34:37.320]  $ MoreArgs                 : NULL
[13:34:37.320]  $ ...future.elements_ii    :List of 2
[13:34:37.320]   ..$ :List of 2
[13:34:37.320]   .. ..$ : num 1
[13:34:37.320]   .. ..$ : num 1
[13:34:37.320]   ..$ :List of 2
[13:34:37.320]   .. ..$ : int 2
[13:34:37.320]   .. ..$ : int 3
[13:34:37.320]  $ ...future.seeds_ii       : NULL
[13:34:37.320]  $ ...future.globals.maxSize: NULL
[13:34:37.320]  - attr(*, "where")=List of 5
[13:34:37.320]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:37.320]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:37.320]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:37.320]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:37.320]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:37.320]  - attr(*, "resolved")= logi FALSE
[13:34:37.320]  - attr(*, "total_size")= num 280
[13:34:37.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.320]  - attr(*, "already-done")= logi TRUE
[13:34:37.329] - copied ‘...future.FUN’ to environment
[13:34:37.329] - copied ‘MoreArgs’ to environment
[13:34:37.330] - copied ‘...future.elements_ii’ to environment
[13:34:37.330] - copied ‘...future.seeds_ii’ to environment
[13:34:37.330] - copied ‘...future.globals.maxSize’ to environment
[13:34:37.330] assign_globals() ... done
[13:34:37.330] requestCore(): workers = 2
[13:34:37.333] MulticoreFuture started
[13:34:37.333] - Launch lazy future ... done
[13:34:37.334] run() for ‘MulticoreFuture’ ... done
[13:34:37.334] Created future:
[13:34:37.334] plan(): Setting new future strategy stack:
[13:34:37.335] List of future strategies:
[13:34:37.335] 1. sequential:
[13:34:37.335]    - args: function (..., envir = parent.frame())
[13:34:37.335]    - tweaked: FALSE
[13:34:37.335]    - call: NULL
[13:34:37.336] plan(): nbrOfWorkers() = 1
[13:34:37.338] plan(): Setting new future strategy stack:
[13:34:37.338] List of future strategies:
[13:34:37.338] 1. multicore:
[13:34:37.338]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:37.338]    - tweaked: FALSE
[13:34:37.338]    - call: plan(strategy)
[13:34:37.344] plan(): nbrOfWorkers() = 2
[13:34:37.334] MulticoreFuture:
[13:34:37.334] Label: ‘future_Map-2’
[13:34:37.334] Expression:
[13:34:37.334] {
[13:34:37.334]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.334]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:37.334]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.334]         on.exit(options(oopts), add = TRUE)
[13:34:37.334]     }
[13:34:37.334]     {
[13:34:37.334]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.334]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:37.334]         do.call(mapply, args = args)
[13:34:37.334]     }
[13:34:37.334] }
[13:34:37.334] Lazy evaluation: FALSE
[13:34:37.334] Asynchronous evaluation: TRUE
[13:34:37.334] Local evaluation: TRUE
[13:34:37.334] Environment: R_GlobalEnv
[13:34:37.334] Capture standard output: TRUE
[13:34:37.334] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:37.334] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:37.334] Packages: <none>
[13:34:37.334] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:37.334] Resolved: TRUE
[13:34:37.334] Value: <not collected>
[13:34:37.334] Conditions captured: <none>
[13:34:37.334] Early signaling: FALSE
[13:34:37.334] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:37.334] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.345] Chunk #2 of 2 ... DONE
[13:34:37.345] Launching 2 futures (chunks) ... DONE
[13:34:37.345] Resolving 2 futures (chunks) ...
[13:34:37.345] resolve() on list ...
[13:34:37.346]  recursive: 0
[13:34:37.346]  length: 2
[13:34:37.346] 
[13:34:37.346] Future #1
[13:34:37.346] result() for MulticoreFuture ...
[13:34:37.347] result() for MulticoreFuture ...
[13:34:37.348] result() for MulticoreFuture ... done
[13:34:37.348] result() for MulticoreFuture ... done
[13:34:37.348] result() for MulticoreFuture ...
[13:34:37.348] result() for MulticoreFuture ... done
[13:34:37.348] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:37.348] - nx: 2
[13:34:37.349] - relay: TRUE
[13:34:37.349] - stdout: TRUE
[13:34:37.349] - signal: TRUE
[13:34:37.349] - resignal: FALSE
[13:34:37.349] - force: TRUE
[13:34:37.349] - relayed: [n=2] FALSE, FALSE
[13:34:37.349] - queued futures: [n=2] FALSE, FALSE
[13:34:37.350]  - until=1
[13:34:37.350]  - relaying element #1
[13:34:37.350] result() for MulticoreFuture ...
[13:34:37.350] result() for MulticoreFuture ... done
[13:34:37.350] result() for MulticoreFuture ...
[13:34:37.350] result() for MulticoreFuture ... done
[13:34:37.351] result() for MulticoreFuture ...
[13:34:37.351] result() for MulticoreFuture ... done
[13:34:37.351] result() for MulticoreFuture ...
[13:34:37.351] result() for MulticoreFuture ... done
[13:34:37.351] - relayed: [n=2] TRUE, FALSE
[13:34:37.351] - queued futures: [n=2] TRUE, FALSE
[13:34:37.351] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:37.352]  length: 1 (resolved future 1)
[13:34:37.352] Future #2
[13:34:37.352] result() for MulticoreFuture ...
[13:34:37.353] result() for MulticoreFuture ...
[13:34:37.354] result() for MulticoreFuture ... done
[13:34:37.354] result() for MulticoreFuture ... done
[13:34:37.354] result() for MulticoreFuture ...
[13:34:37.354] result() for MulticoreFuture ... done
[13:34:37.354] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:37.354] - nx: 2
[13:34:37.355] - relay: TRUE
[13:34:37.355] - stdout: TRUE
[13:34:37.355] - signal: TRUE
[13:34:37.355] - resignal: FALSE
[13:34:37.355] - force: TRUE
[13:34:37.355] - relayed: [n=2] TRUE, FALSE
[13:34:37.355] - queued futures: [n=2] TRUE, FALSE
[13:34:37.355]  - until=2
[13:34:37.356]  - relaying element #2
[13:34:37.356] result() for MulticoreFuture ...
[13:34:37.356] result() for MulticoreFuture ... done
[13:34:37.356] result() for MulticoreFuture ...
[13:34:37.356] result() for MulticoreFuture ... done
[13:34:37.356] result() for MulticoreFuture ...
[13:34:37.356] result() for MulticoreFuture ... done
[13:34:37.356] result() for MulticoreFuture ...
[13:34:37.357] result() for MulticoreFuture ... done
[13:34:37.357] - relayed: [n=2] TRUE, TRUE
[13:34:37.357] - queued futures: [n=2] TRUE, TRUE
[13:34:37.357] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:37.357]  length: 0 (resolved future 2)
[13:34:37.357] Relaying remaining futures
[13:34:37.357] signalConditionsASAP(NULL, pos=0) ...
[13:34:37.357] - nx: 2
[13:34:37.357] - relay: TRUE
[13:34:37.358] - stdout: TRUE
[13:34:37.358] - signal: TRUE
[13:34:37.358] - resignal: FALSE
[13:34:37.358] - force: TRUE
[13:34:37.358] - relayed: [n=2] TRUE, TRUE
[13:34:37.358] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:37.358] - relayed: [n=2] TRUE, TRUE
[13:34:37.358] - queued futures: [n=2] TRUE, TRUE
[13:34:37.359] signalConditionsASAP(NULL, pos=0) ... done
[13:34:37.359] resolve() on list ... DONE
[13:34:37.359] result() for MulticoreFuture ...
[13:34:37.359] result() for MulticoreFuture ... done
[13:34:37.359] result() for MulticoreFuture ...
[13:34:37.359] result() for MulticoreFuture ... done
[13:34:37.359] result() for MulticoreFuture ...
[13:34:37.359] result() for MulticoreFuture ... done
[13:34:37.359] result() for MulticoreFuture ...
[13:34:37.360] result() for MulticoreFuture ... done
[13:34:37.360]  - Number of value chunks collected: 2
[13:34:37.360] Resolving 2 futures (chunks) ... DONE
[13:34:37.360] Reducing values from 2 chunks ...
[13:34:37.360]  - Number of values collected after concatenation: 3
[13:34:37.360]  - Number of values expected: 3
[13:34:37.360] Reducing values from 2 chunks ... DONE
[13:34:37.360] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[13:34:37.361] future_mapply() ...
[13:34:37.365] Number of chunks: 2
[13:34:37.365] getGlobalsAndPackagesXApply() ...
[13:34:37.365]  - future.globals: TRUE
[13:34:37.365] getGlobalsAndPackages() ...
[13:34:37.365] Searching for globals...
[13:34:37.367] - globals found: [1] ‘FUN’
[13:34:37.367] Searching for globals ... DONE
[13:34:37.367] Resolving globals: FALSE
[13:34:37.368] The total size of the 1 globals is 848 bytes (848 bytes)
[13:34:37.368] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:34:37.368] - globals: [1] ‘FUN’
[13:34:37.368] 
[13:34:37.368] getGlobalsAndPackages() ... DONE
[13:34:37.368]  - globals found/used: [n=1] ‘FUN’
[13:34:37.368]  - needed namespaces: [n=0] 
[13:34:37.369] Finding globals ... DONE
[13:34:37.369] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:37.369] List of 2
[13:34:37.369]  $ ...future.FUN:function (x)  
[13:34:37.369]  $ MoreArgs     : NULL
[13:34:37.369]  - attr(*, "where")=List of 2
[13:34:37.369]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:37.369]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:37.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.369]  - attr(*, "resolved")= logi FALSE
[13:34:37.369]  - attr(*, "total_size")= num NA
[13:34:37.372] Packages to be attached in all futures: [n=0] 
[13:34:37.372] getGlobalsAndPackagesXApply() ... DONE
[13:34:37.372] Number of futures (= number of chunks): 2
[13:34:37.373] Launching 2 futures (chunks) ...
[13:34:37.373] Chunk #1 of 2 ...
[13:34:37.373]  - Finding globals in '...' for chunk #1 ...
[13:34:37.373] getGlobalsAndPackages() ...
[13:34:37.373] Searching for globals...
[13:34:37.373] 
[13:34:37.373] Searching for globals ... DONE
[13:34:37.374] - globals: [0] <none>
[13:34:37.374] getGlobalsAndPackages() ... DONE
[13:34:37.374]    + additional globals found: [n=0] 
[13:34:37.374]    + additional namespaces needed: [n=0] 
[13:34:37.374]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:37.374]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:37.374]  - seeds: <none>
[13:34:37.374]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.375] getGlobalsAndPackages() ...
[13:34:37.375] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.375] Resolving globals: FALSE
[13:34:37.375] The total size of the 5 globals is 904 bytes (904 bytes)
[13:34:37.376] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:37.376] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.376] 
[13:34:37.376] getGlobalsAndPackages() ... DONE
[13:34:37.377] run() for ‘Future’ ...
[13:34:37.377] - state: ‘created’
[13:34:37.377] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:37.381] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.381] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:37.381]   - Field: ‘label’
[13:34:37.381]   - Field: ‘local’
[13:34:37.381]   - Field: ‘owner’
[13:34:37.381]   - Field: ‘envir’
[13:34:37.381]   - Field: ‘workers’
[13:34:37.382]   - Field: ‘packages’
[13:34:37.382]   - Field: ‘gc’
[13:34:37.382]   - Field: ‘job’
[13:34:37.382]   - Field: ‘conditions’
[13:34:37.382]   - Field: ‘expr’
[13:34:37.382]   - Field: ‘uuid’
[13:34:37.382]   - Field: ‘seed’
[13:34:37.383]   - Field: ‘version’
[13:34:37.383]   - Field: ‘result’
[13:34:37.383]   - Field: ‘asynchronous’
[13:34:37.383]   - Field: ‘calls’
[13:34:37.383]   - Field: ‘globals’
[13:34:37.383]   - Field: ‘stdout’
[13:34:37.383]   - Field: ‘earlySignal’
[13:34:37.383]   - Field: ‘lazy’
[13:34:37.383]   - Field: ‘state’
[13:34:37.384] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:37.384] - Launch lazy future ...
[13:34:37.384] Packages needed by the future expression (n = 0): <none>
[13:34:37.384] Packages needed by future strategies (n = 0): <none>
[13:34:37.385] {
[13:34:37.385]     {
[13:34:37.385]         {
[13:34:37.385]             ...future.startTime <- base::Sys.time()
[13:34:37.385]             {
[13:34:37.385]                 {
[13:34:37.385]                   {
[13:34:37.385]                     {
[13:34:37.385]                       base::local({
[13:34:37.385]                         has_future <- base::requireNamespace("future", 
[13:34:37.385]                           quietly = TRUE)
[13:34:37.385]                         if (has_future) {
[13:34:37.385]                           ns <- base::getNamespace("future")
[13:34:37.385]                           version <- ns[[".package"]][["version"]]
[13:34:37.385]                           if (is.null(version)) 
[13:34:37.385]                             version <- utils::packageVersion("future")
[13:34:37.385]                         }
[13:34:37.385]                         else {
[13:34:37.385]                           version <- NULL
[13:34:37.385]                         }
[13:34:37.385]                         if (!has_future || version < "1.8.0") {
[13:34:37.385]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:37.385]                             "", base::R.version$version.string), 
[13:34:37.385]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:37.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:37.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:37.385]                               "release", "version")], collapse = " "), 
[13:34:37.385]                             hostname = base::Sys.info()[["nodename"]])
[13:34:37.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:37.385]                             info)
[13:34:37.385]                           info <- base::paste(info, collapse = "; ")
[13:34:37.385]                           if (!has_future) {
[13:34:37.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:37.385]                               info)
[13:34:37.385]                           }
[13:34:37.385]                           else {
[13:34:37.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:37.385]                               info, version)
[13:34:37.385]                           }
[13:34:37.385]                           base::stop(msg)
[13:34:37.385]                         }
[13:34:37.385]                       })
[13:34:37.385]                     }
[13:34:37.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:37.385]                     base::options(mc.cores = 1L)
[13:34:37.385]                   }
[13:34:37.385]                   ...future.strategy.old <- future::plan("list")
[13:34:37.385]                   options(future.plan = NULL)
[13:34:37.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:37.385]                 }
[13:34:37.385]                 ...future.workdir <- getwd()
[13:34:37.385]             }
[13:34:37.385]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:37.385]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:37.385]         }
[13:34:37.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:37.385]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:37.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:37.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:37.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:37.385]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:37.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:37.385]             base::names(...future.oldOptions))
[13:34:37.385]     }
[13:34:37.385]     if (FALSE) {
[13:34:37.385]     }
[13:34:37.385]     else {
[13:34:37.385]         if (TRUE) {
[13:34:37.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:37.385]                 open = "w")
[13:34:37.385]         }
[13:34:37.385]         else {
[13:34:37.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:37.385]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:37.385]         }
[13:34:37.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:37.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:37.385]             base::sink(type = "output", split = FALSE)
[13:34:37.385]             base::close(...future.stdout)
[13:34:37.385]         }, add = TRUE)
[13:34:37.385]     }
[13:34:37.385]     ...future.frame <- base::sys.nframe()
[13:34:37.385]     ...future.conditions <- base::list()
[13:34:37.385]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:37.385]     if (FALSE) {
[13:34:37.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:37.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:37.385]     }
[13:34:37.385]     ...future.result <- base::tryCatch({
[13:34:37.385]         base::withCallingHandlers({
[13:34:37.385]             ...future.value <- base::withVisible(base::local({
[13:34:37.385]                 withCallingHandlers({
[13:34:37.385]                   {
[13:34:37.385]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.385]                     if (!identical(...future.globals.maxSize.org, 
[13:34:37.385]                       ...future.globals.maxSize)) {
[13:34:37.385]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.385]                       on.exit(options(oopts), add = TRUE)
[13:34:37.385]                     }
[13:34:37.385]                     {
[13:34:37.385]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.385]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:37.385]                         USE.NAMES = FALSE)
[13:34:37.385]                       do.call(mapply, args = args)
[13:34:37.385]                     }
[13:34:37.385]                   }
[13:34:37.385]                 }, immediateCondition = function(cond) {
[13:34:37.385]                   save_rds <- function (object, pathname, ...) 
[13:34:37.385]                   {
[13:34:37.385]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:37.385]                     if (file_test("-f", pathname_tmp)) {
[13:34:37.385]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.385]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:37.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.385]                         fi_tmp[["mtime"]])
[13:34:37.385]                     }
[13:34:37.385]                     tryCatch({
[13:34:37.385]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:37.385]                     }, error = function(ex) {
[13:34:37.385]                       msg <- conditionMessage(ex)
[13:34:37.385]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.385]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:37.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.385]                         fi_tmp[["mtime"]], msg)
[13:34:37.385]                       ex$message <- msg
[13:34:37.385]                       stop(ex)
[13:34:37.385]                     })
[13:34:37.385]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:37.385]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:37.385]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:37.385]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.385]                       fi <- file.info(pathname)
[13:34:37.385]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:37.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.385]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:37.385]                         fi[["size"]], fi[["mtime"]])
[13:34:37.385]                       stop(msg)
[13:34:37.385]                     }
[13:34:37.385]                     invisible(pathname)
[13:34:37.385]                   }
[13:34:37.385]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:37.385]                     rootPath = tempdir()) 
[13:34:37.385]                   {
[13:34:37.385]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:37.385]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:37.385]                       tmpdir = path, fileext = ".rds")
[13:34:37.385]                     save_rds(obj, file)
[13:34:37.385]                   }
[13:34:37.385]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:37.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.385]                   {
[13:34:37.385]                     inherits <- base::inherits
[13:34:37.385]                     invokeRestart <- base::invokeRestart
[13:34:37.385]                     is.null <- base::is.null
[13:34:37.385]                     muffled <- FALSE
[13:34:37.385]                     if (inherits(cond, "message")) {
[13:34:37.385]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:37.385]                       if (muffled) 
[13:34:37.385]                         invokeRestart("muffleMessage")
[13:34:37.385]                     }
[13:34:37.385]                     else if (inherits(cond, "warning")) {
[13:34:37.385]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:37.385]                       if (muffled) 
[13:34:37.385]                         invokeRestart("muffleWarning")
[13:34:37.385]                     }
[13:34:37.385]                     else if (inherits(cond, "condition")) {
[13:34:37.385]                       if (!is.null(pattern)) {
[13:34:37.385]                         computeRestarts <- base::computeRestarts
[13:34:37.385]                         grepl <- base::grepl
[13:34:37.385]                         restarts <- computeRestarts(cond)
[13:34:37.385]                         for (restart in restarts) {
[13:34:37.385]                           name <- restart$name
[13:34:37.385]                           if (is.null(name)) 
[13:34:37.385]                             next
[13:34:37.385]                           if (!grepl(pattern, name)) 
[13:34:37.385]                             next
[13:34:37.385]                           invokeRestart(restart)
[13:34:37.385]                           muffled <- TRUE
[13:34:37.385]                           break
[13:34:37.385]                         }
[13:34:37.385]                       }
[13:34:37.385]                     }
[13:34:37.385]                     invisible(muffled)
[13:34:37.385]                   }
[13:34:37.385]                   muffleCondition(cond)
[13:34:37.385]                 })
[13:34:37.385]             }))
[13:34:37.385]             future::FutureResult(value = ...future.value$value, 
[13:34:37.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.385]                   ...future.rng), globalenv = if (FALSE) 
[13:34:37.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:37.385]                     ...future.globalenv.names))
[13:34:37.385]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:37.385]         }, condition = base::local({
[13:34:37.385]             c <- base::c
[13:34:37.385]             inherits <- base::inherits
[13:34:37.385]             invokeRestart <- base::invokeRestart
[13:34:37.385]             length <- base::length
[13:34:37.385]             list <- base::list
[13:34:37.385]             seq.int <- base::seq.int
[13:34:37.385]             signalCondition <- base::signalCondition
[13:34:37.385]             sys.calls <- base::sys.calls
[13:34:37.385]             `[[` <- base::`[[`
[13:34:37.385]             `+` <- base::`+`
[13:34:37.385]             `<<-` <- base::`<<-`
[13:34:37.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:37.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:37.385]                   3L)]
[13:34:37.385]             }
[13:34:37.385]             function(cond) {
[13:34:37.385]                 is_error <- inherits(cond, "error")
[13:34:37.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:37.385]                   NULL)
[13:34:37.385]                 if (is_error) {
[13:34:37.385]                   sessionInformation <- function() {
[13:34:37.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:37.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:37.385]                       search = base::search(), system = base::Sys.info())
[13:34:37.385]                   }
[13:34:37.385]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:37.385]                     cond$call), session = sessionInformation(), 
[13:34:37.385]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:37.385]                   signalCondition(cond)
[13:34:37.385]                 }
[13:34:37.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:37.385]                 "immediateCondition"))) {
[13:34:37.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:37.385]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:37.385]                   if (TRUE && !signal) {
[13:34:37.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.385]                     {
[13:34:37.385]                       inherits <- base::inherits
[13:34:37.385]                       invokeRestart <- base::invokeRestart
[13:34:37.385]                       is.null <- base::is.null
[13:34:37.385]                       muffled <- FALSE
[13:34:37.385]                       if (inherits(cond, "message")) {
[13:34:37.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.385]                         if (muffled) 
[13:34:37.385]                           invokeRestart("muffleMessage")
[13:34:37.385]                       }
[13:34:37.385]                       else if (inherits(cond, "warning")) {
[13:34:37.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.385]                         if (muffled) 
[13:34:37.385]                           invokeRestart("muffleWarning")
[13:34:37.385]                       }
[13:34:37.385]                       else if (inherits(cond, "condition")) {
[13:34:37.385]                         if (!is.null(pattern)) {
[13:34:37.385]                           computeRestarts <- base::computeRestarts
[13:34:37.385]                           grepl <- base::grepl
[13:34:37.385]                           restarts <- computeRestarts(cond)
[13:34:37.385]                           for (restart in restarts) {
[13:34:37.385]                             name <- restart$name
[13:34:37.385]                             if (is.null(name)) 
[13:34:37.385]                               next
[13:34:37.385]                             if (!grepl(pattern, name)) 
[13:34:37.385]                               next
[13:34:37.385]                             invokeRestart(restart)
[13:34:37.385]                             muffled <- TRUE
[13:34:37.385]                             break
[13:34:37.385]                           }
[13:34:37.385]                         }
[13:34:37.385]                       }
[13:34:37.385]                       invisible(muffled)
[13:34:37.385]                     }
[13:34:37.385]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.385]                   }
[13:34:37.385]                 }
[13:34:37.385]                 else {
[13:34:37.385]                   if (TRUE) {
[13:34:37.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.385]                     {
[13:34:37.385]                       inherits <- base::inherits
[13:34:37.385]                       invokeRestart <- base::invokeRestart
[13:34:37.385]                       is.null <- base::is.null
[13:34:37.385]                       muffled <- FALSE
[13:34:37.385]                       if (inherits(cond, "message")) {
[13:34:37.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.385]                         if (muffled) 
[13:34:37.385]                           invokeRestart("muffleMessage")
[13:34:37.385]                       }
[13:34:37.385]                       else if (inherits(cond, "warning")) {
[13:34:37.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.385]                         if (muffled) 
[13:34:37.385]                           invokeRestart("muffleWarning")
[13:34:37.385]                       }
[13:34:37.385]                       else if (inherits(cond, "condition")) {
[13:34:37.385]                         if (!is.null(pattern)) {
[13:34:37.385]                           computeRestarts <- base::computeRestarts
[13:34:37.385]                           grepl <- base::grepl
[13:34:37.385]                           restarts <- computeRestarts(cond)
[13:34:37.385]                           for (restart in restarts) {
[13:34:37.385]                             name <- restart$name
[13:34:37.385]                             if (is.null(name)) 
[13:34:37.385]                               next
[13:34:37.385]                             if (!grepl(pattern, name)) 
[13:34:37.385]                               next
[13:34:37.385]                             invokeRestart(restart)
[13:34:37.385]                             muffled <- TRUE
[13:34:37.385]                             break
[13:34:37.385]                           }
[13:34:37.385]                         }
[13:34:37.385]                       }
[13:34:37.385]                       invisible(muffled)
[13:34:37.385]                     }
[13:34:37.385]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.385]                   }
[13:34:37.385]                 }
[13:34:37.385]             }
[13:34:37.385]         }))
[13:34:37.385]     }, error = function(ex) {
[13:34:37.385]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:37.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.385]                 ...future.rng), started = ...future.startTime, 
[13:34:37.385]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:37.385]             version = "1.8"), class = "FutureResult")
[13:34:37.385]     }, finally = {
[13:34:37.385]         if (!identical(...future.workdir, getwd())) 
[13:34:37.385]             setwd(...future.workdir)
[13:34:37.385]         {
[13:34:37.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:37.385]                 ...future.oldOptions$nwarnings <- NULL
[13:34:37.385]             }
[13:34:37.385]             base::options(...future.oldOptions)
[13:34:37.385]             if (.Platform$OS.type == "windows") {
[13:34:37.385]                 old_names <- names(...future.oldEnvVars)
[13:34:37.385]                 envs <- base::Sys.getenv()
[13:34:37.385]                 names <- names(envs)
[13:34:37.385]                 common <- intersect(names, old_names)
[13:34:37.385]                 added <- setdiff(names, old_names)
[13:34:37.385]                 removed <- setdiff(old_names, names)
[13:34:37.385]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:37.385]                   envs[common]]
[13:34:37.385]                 NAMES <- toupper(changed)
[13:34:37.385]                 args <- list()
[13:34:37.385]                 for (kk in seq_along(NAMES)) {
[13:34:37.385]                   name <- changed[[kk]]
[13:34:37.385]                   NAME <- NAMES[[kk]]
[13:34:37.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.385]                     next
[13:34:37.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.385]                 }
[13:34:37.385]                 NAMES <- toupper(added)
[13:34:37.385]                 for (kk in seq_along(NAMES)) {
[13:34:37.385]                   name <- added[[kk]]
[13:34:37.385]                   NAME <- NAMES[[kk]]
[13:34:37.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.385]                     next
[13:34:37.385]                   args[[name]] <- ""
[13:34:37.385]                 }
[13:34:37.385]                 NAMES <- toupper(removed)
[13:34:37.385]                 for (kk in seq_along(NAMES)) {
[13:34:37.385]                   name <- removed[[kk]]
[13:34:37.385]                   NAME <- NAMES[[kk]]
[13:34:37.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.385]                     next
[13:34:37.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.385]                 }
[13:34:37.385]                 if (length(args) > 0) 
[13:34:37.385]                   base::do.call(base::Sys.setenv, args = args)
[13:34:37.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:37.385]             }
[13:34:37.385]             else {
[13:34:37.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:37.385]             }
[13:34:37.385]             {
[13:34:37.385]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:37.385]                   0L) {
[13:34:37.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:37.385]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:37.385]                   base::options(opts)
[13:34:37.385]                 }
[13:34:37.385]                 {
[13:34:37.385]                   {
[13:34:37.385]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:37.385]                     NULL
[13:34:37.385]                   }
[13:34:37.385]                   options(future.plan = NULL)
[13:34:37.385]                   if (is.na(NA_character_)) 
[13:34:37.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:37.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:37.385]                     .init = FALSE)
[13:34:37.385]                 }
[13:34:37.385]             }
[13:34:37.385]         }
[13:34:37.385]     })
[13:34:37.385]     if (TRUE) {
[13:34:37.385]         base::sink(type = "output", split = FALSE)
[13:34:37.385]         if (TRUE) {
[13:34:37.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:37.385]         }
[13:34:37.385]         else {
[13:34:37.385]             ...future.result["stdout"] <- base::list(NULL)
[13:34:37.385]         }
[13:34:37.385]         base::close(...future.stdout)
[13:34:37.385]         ...future.stdout <- NULL
[13:34:37.385]     }
[13:34:37.385]     ...future.result$conditions <- ...future.conditions
[13:34:37.385]     ...future.result$finished <- base::Sys.time()
[13:34:37.385]     ...future.result
[13:34:37.385] }
[13:34:37.387] assign_globals() ...
[13:34:37.387] List of 5
[13:34:37.387]  $ ...future.FUN            :function (x)  
[13:34:37.387]  $ MoreArgs                 : NULL
[13:34:37.387]  $ ...future.elements_ii    :List of 1
[13:34:37.387]   ..$ :List of 1
[13:34:37.387]   .. ..$ a: num 0
[13:34:37.387]  $ ...future.seeds_ii       : NULL
[13:34:37.387]  $ ...future.globals.maxSize: NULL
[13:34:37.387]  - attr(*, "where")=List of 5
[13:34:37.387]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:37.387]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:37.387]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:37.387]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:37.387]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:37.387]  - attr(*, "resolved")= logi FALSE
[13:34:37.387]  - attr(*, "total_size")= num 904
[13:34:37.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.387]  - attr(*, "already-done")= logi TRUE
[13:34:37.393] - copied ‘...future.FUN’ to environment
[13:34:37.393] - copied ‘MoreArgs’ to environment
[13:34:37.393] - copied ‘...future.elements_ii’ to environment
[13:34:37.393] - copied ‘...future.seeds_ii’ to environment
[13:34:37.393] - copied ‘...future.globals.maxSize’ to environment
[13:34:37.393] assign_globals() ... done
[13:34:37.393] requestCore(): workers = 2
[13:34:37.396] MulticoreFuture started
[13:34:37.396] - Launch lazy future ... done
[13:34:37.397] run() for ‘MulticoreFuture’ ... done
[13:34:37.397] Created future:
[13:34:37.397] plan(): Setting new future strategy stack:
[13:34:37.398] List of future strategies:
[13:34:37.398] 1. sequential:
[13:34:37.398]    - args: function (..., envir = parent.frame())
[13:34:37.398]    - tweaked: FALSE
[13:34:37.398]    - call: NULL
[13:34:37.399] plan(): nbrOfWorkers() = 1
[13:34:37.401] plan(): Setting new future strategy stack:
[13:34:37.401] List of future strategies:
[13:34:37.401] 1. multicore:
[13:34:37.401]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:37.401]    - tweaked: FALSE
[13:34:37.401]    - call: plan(strategy)
[13:34:37.407] plan(): nbrOfWorkers() = 2
[13:34:37.397] MulticoreFuture:
[13:34:37.397] Label: ‘future_mapply-1’
[13:34:37.397] Expression:
[13:34:37.397] {
[13:34:37.397]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.397]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:37.397]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.397]         on.exit(options(oopts), add = TRUE)
[13:34:37.397]     }
[13:34:37.397]     {
[13:34:37.397]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.397]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:37.397]         do.call(mapply, args = args)
[13:34:37.397]     }
[13:34:37.397] }
[13:34:37.397] Lazy evaluation: FALSE
[13:34:37.397] Asynchronous evaluation: TRUE
[13:34:37.397] Local evaluation: TRUE
[13:34:37.397] Environment: R_GlobalEnv
[13:34:37.397] Capture standard output: TRUE
[13:34:37.397] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:37.397] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:37.397] Packages: <none>
[13:34:37.397] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:37.397] Resolved: TRUE
[13:34:37.397] Value: <not collected>
[13:34:37.397] Conditions captured: <none>
[13:34:37.397] Early signaling: FALSE
[13:34:37.397] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:37.397] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.408] Chunk #1 of 2 ... DONE
[13:34:37.408] Chunk #2 of 2 ...
[13:34:37.409]  - Finding globals in '...' for chunk #2 ...
[13:34:37.409] getGlobalsAndPackages() ...
[13:34:37.409] Searching for globals...
[13:34:37.410] 
[13:34:37.410] Searching for globals ... DONE
[13:34:37.410] - globals: [0] <none>
[13:34:37.410] getGlobalsAndPackages() ... DONE
[13:34:37.410]    + additional globals found: [n=0] 
[13:34:37.410]    + additional namespaces needed: [n=0] 
[13:34:37.410]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:37.411]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:37.411]  - seeds: <none>
[13:34:37.411]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.411] getGlobalsAndPackages() ...
[13:34:37.411] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.411] Resolving globals: FALSE
[13:34:37.412] The total size of the 5 globals is 904 bytes (904 bytes)
[13:34:37.413] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:37.413] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:37.413] 
[13:34:37.413] getGlobalsAndPackages() ... DONE
[13:34:37.414] run() for ‘Future’ ...
[13:34:37.414] - state: ‘created’
[13:34:37.414] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:34:37.419] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.419] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:34:37.419]   - Field: ‘label’
[13:34:37.419]   - Field: ‘local’
[13:34:37.419]   - Field: ‘owner’
[13:34:37.419]   - Field: ‘envir’
[13:34:37.419]   - Field: ‘workers’
[13:34:37.420]   - Field: ‘packages’
[13:34:37.420]   - Field: ‘gc’
[13:34:37.420]   - Field: ‘job’
[13:34:37.420]   - Field: ‘conditions’
[13:34:37.420]   - Field: ‘expr’
[13:34:37.421]   - Field: ‘uuid’
[13:34:37.421]   - Field: ‘seed’
[13:34:37.421]   - Field: ‘version’
[13:34:37.421]   - Field: ‘result’
[13:34:37.421]   - Field: ‘asynchronous’
[13:34:37.421]   - Field: ‘calls’
[13:34:37.421]   - Field: ‘globals’
[13:34:37.422]   - Field: ‘stdout’
[13:34:37.422]   - Field: ‘earlySignal’
[13:34:37.422]   - Field: ‘lazy’
[13:34:37.422]   - Field: ‘state’
[13:34:37.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:34:37.423] - Launch lazy future ...
[13:34:37.423] Packages needed by the future expression (n = 0): <none>
[13:34:37.423] Packages needed by future strategies (n = 0): <none>
[13:34:37.424] {
[13:34:37.424]     {
[13:34:37.424]         {
[13:34:37.424]             ...future.startTime <- base::Sys.time()
[13:34:37.424]             {
[13:34:37.424]                 {
[13:34:37.424]                   {
[13:34:37.424]                     {
[13:34:37.424]                       base::local({
[13:34:37.424]                         has_future <- base::requireNamespace("future", 
[13:34:37.424]                           quietly = TRUE)
[13:34:37.424]                         if (has_future) {
[13:34:37.424]                           ns <- base::getNamespace("future")
[13:34:37.424]                           version <- ns[[".package"]][["version"]]
[13:34:37.424]                           if (is.null(version)) 
[13:34:37.424]                             version <- utils::packageVersion("future")
[13:34:37.424]                         }
[13:34:37.424]                         else {
[13:34:37.424]                           version <- NULL
[13:34:37.424]                         }
[13:34:37.424]                         if (!has_future || version < "1.8.0") {
[13:34:37.424]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:37.424]                             "", base::R.version$version.string), 
[13:34:37.424]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:37.424]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:37.424]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:37.424]                               "release", "version")], collapse = " "), 
[13:34:37.424]                             hostname = base::Sys.info()[["nodename"]])
[13:34:37.424]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:37.424]                             info)
[13:34:37.424]                           info <- base::paste(info, collapse = "; ")
[13:34:37.424]                           if (!has_future) {
[13:34:37.424]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:37.424]                               info)
[13:34:37.424]                           }
[13:34:37.424]                           else {
[13:34:37.424]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:37.424]                               info, version)
[13:34:37.424]                           }
[13:34:37.424]                           base::stop(msg)
[13:34:37.424]                         }
[13:34:37.424]                       })
[13:34:37.424]                     }
[13:34:37.424]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:37.424]                     base::options(mc.cores = 1L)
[13:34:37.424]                   }
[13:34:37.424]                   ...future.strategy.old <- future::plan("list")
[13:34:37.424]                   options(future.plan = NULL)
[13:34:37.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:37.424]                 }
[13:34:37.424]                 ...future.workdir <- getwd()
[13:34:37.424]             }
[13:34:37.424]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:37.424]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:37.424]         }
[13:34:37.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:37.424]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:37.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:37.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:37.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:37.424]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:37.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:37.424]             base::names(...future.oldOptions))
[13:34:37.424]     }
[13:34:37.424]     if (FALSE) {
[13:34:37.424]     }
[13:34:37.424]     else {
[13:34:37.424]         if (TRUE) {
[13:34:37.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:37.424]                 open = "w")
[13:34:37.424]         }
[13:34:37.424]         else {
[13:34:37.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:37.424]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:37.424]         }
[13:34:37.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:37.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:37.424]             base::sink(type = "output", split = FALSE)
[13:34:37.424]             base::close(...future.stdout)
[13:34:37.424]         }, add = TRUE)
[13:34:37.424]     }
[13:34:37.424]     ...future.frame <- base::sys.nframe()
[13:34:37.424]     ...future.conditions <- base::list()
[13:34:37.424]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:37.424]     if (FALSE) {
[13:34:37.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:37.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:37.424]     }
[13:34:37.424]     ...future.result <- base::tryCatch({
[13:34:37.424]         base::withCallingHandlers({
[13:34:37.424]             ...future.value <- base::withVisible(base::local({
[13:34:37.424]                 withCallingHandlers({
[13:34:37.424]                   {
[13:34:37.424]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.424]                     if (!identical(...future.globals.maxSize.org, 
[13:34:37.424]                       ...future.globals.maxSize)) {
[13:34:37.424]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.424]                       on.exit(options(oopts), add = TRUE)
[13:34:37.424]                     }
[13:34:37.424]                     {
[13:34:37.424]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.424]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:37.424]                         USE.NAMES = FALSE)
[13:34:37.424]                       do.call(mapply, args = args)
[13:34:37.424]                     }
[13:34:37.424]                   }
[13:34:37.424]                 }, immediateCondition = function(cond) {
[13:34:37.424]                   save_rds <- function (object, pathname, ...) 
[13:34:37.424]                   {
[13:34:37.424]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:34:37.424]                     if (file_test("-f", pathname_tmp)) {
[13:34:37.424]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.424]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:34:37.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.424]                         fi_tmp[["mtime"]])
[13:34:37.424]                     }
[13:34:37.424]                     tryCatch({
[13:34:37.424]                       saveRDS(object, file = pathname_tmp, ...)
[13:34:37.424]                     }, error = function(ex) {
[13:34:37.424]                       msg <- conditionMessage(ex)
[13:34:37.424]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.424]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:34:37.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.424]                         fi_tmp[["mtime"]], msg)
[13:34:37.424]                       ex$message <- msg
[13:34:37.424]                       stop(ex)
[13:34:37.424]                     })
[13:34:37.424]                     stopifnot(file_test("-f", pathname_tmp))
[13:34:37.424]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:34:37.424]                     if (!res || file_test("-f", pathname_tmp)) {
[13:34:37.424]                       fi_tmp <- file.info(pathname_tmp)
[13:34:37.424]                       fi <- file.info(pathname)
[13:34:37.424]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:34:37.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:34:37.424]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:34:37.424]                         fi[["size"]], fi[["mtime"]])
[13:34:37.424]                       stop(msg)
[13:34:37.424]                     }
[13:34:37.424]                     invisible(pathname)
[13:34:37.424]                   }
[13:34:37.424]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:34:37.424]                     rootPath = tempdir()) 
[13:34:37.424]                   {
[13:34:37.424]                     obj <- list(time = Sys.time(), condition = cond)
[13:34:37.424]                     file <- tempfile(pattern = class(cond)[1], 
[13:34:37.424]                       tmpdir = path, fileext = ".rds")
[13:34:37.424]                     save_rds(obj, file)
[13:34:37.424]                   }
[13:34:37.424]                   saveImmediateCondition(cond, path = "/tmp/RtmpRDZRiT/.future/immediateConditions")
[13:34:37.424]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.424]                   {
[13:34:37.424]                     inherits <- base::inherits
[13:34:37.424]                     invokeRestart <- base::invokeRestart
[13:34:37.424]                     is.null <- base::is.null
[13:34:37.424]                     muffled <- FALSE
[13:34:37.424]                     if (inherits(cond, "message")) {
[13:34:37.424]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:37.424]                       if (muffled) 
[13:34:37.424]                         invokeRestart("muffleMessage")
[13:34:37.424]                     }
[13:34:37.424]                     else if (inherits(cond, "warning")) {
[13:34:37.424]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:37.424]                       if (muffled) 
[13:34:37.424]                         invokeRestart("muffleWarning")
[13:34:37.424]                     }
[13:34:37.424]                     else if (inherits(cond, "condition")) {
[13:34:37.424]                       if (!is.null(pattern)) {
[13:34:37.424]                         computeRestarts <- base::computeRestarts
[13:34:37.424]                         grepl <- base::grepl
[13:34:37.424]                         restarts <- computeRestarts(cond)
[13:34:37.424]                         for (restart in restarts) {
[13:34:37.424]                           name <- restart$name
[13:34:37.424]                           if (is.null(name)) 
[13:34:37.424]                             next
[13:34:37.424]                           if (!grepl(pattern, name)) 
[13:34:37.424]                             next
[13:34:37.424]                           invokeRestart(restart)
[13:34:37.424]                           muffled <- TRUE
[13:34:37.424]                           break
[13:34:37.424]                         }
[13:34:37.424]                       }
[13:34:37.424]                     }
[13:34:37.424]                     invisible(muffled)
[13:34:37.424]                   }
[13:34:37.424]                   muffleCondition(cond)
[13:34:37.424]                 })
[13:34:37.424]             }))
[13:34:37.424]             future::FutureResult(value = ...future.value$value, 
[13:34:37.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.424]                   ...future.rng), globalenv = if (FALSE) 
[13:34:37.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:37.424]                     ...future.globalenv.names))
[13:34:37.424]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:37.424]         }, condition = base::local({
[13:34:37.424]             c <- base::c
[13:34:37.424]             inherits <- base::inherits
[13:34:37.424]             invokeRestart <- base::invokeRestart
[13:34:37.424]             length <- base::length
[13:34:37.424]             list <- base::list
[13:34:37.424]             seq.int <- base::seq.int
[13:34:37.424]             signalCondition <- base::signalCondition
[13:34:37.424]             sys.calls <- base::sys.calls
[13:34:37.424]             `[[` <- base::`[[`
[13:34:37.424]             `+` <- base::`+`
[13:34:37.424]             `<<-` <- base::`<<-`
[13:34:37.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:37.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:37.424]                   3L)]
[13:34:37.424]             }
[13:34:37.424]             function(cond) {
[13:34:37.424]                 is_error <- inherits(cond, "error")
[13:34:37.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:37.424]                   NULL)
[13:34:37.424]                 if (is_error) {
[13:34:37.424]                   sessionInformation <- function() {
[13:34:37.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:37.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:37.424]                       search = base::search(), system = base::Sys.info())
[13:34:37.424]                   }
[13:34:37.424]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:37.424]                     cond$call), session = sessionInformation(), 
[13:34:37.424]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:37.424]                   signalCondition(cond)
[13:34:37.424]                 }
[13:34:37.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:37.424]                 "immediateCondition"))) {
[13:34:37.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:37.424]                   ...future.conditions[[length(...future.conditions) + 
[13:34:37.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:37.424]                   if (TRUE && !signal) {
[13:34:37.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.424]                     {
[13:34:37.424]                       inherits <- base::inherits
[13:34:37.424]                       invokeRestart <- base::invokeRestart
[13:34:37.424]                       is.null <- base::is.null
[13:34:37.424]                       muffled <- FALSE
[13:34:37.424]                       if (inherits(cond, "message")) {
[13:34:37.424]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.424]                         if (muffled) 
[13:34:37.424]                           invokeRestart("muffleMessage")
[13:34:37.424]                       }
[13:34:37.424]                       else if (inherits(cond, "warning")) {
[13:34:37.424]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.424]                         if (muffled) 
[13:34:37.424]                           invokeRestart("muffleWarning")
[13:34:37.424]                       }
[13:34:37.424]                       else if (inherits(cond, "condition")) {
[13:34:37.424]                         if (!is.null(pattern)) {
[13:34:37.424]                           computeRestarts <- base::computeRestarts
[13:34:37.424]                           grepl <- base::grepl
[13:34:37.424]                           restarts <- computeRestarts(cond)
[13:34:37.424]                           for (restart in restarts) {
[13:34:37.424]                             name <- restart$name
[13:34:37.424]                             if (is.null(name)) 
[13:34:37.424]                               next
[13:34:37.424]                             if (!grepl(pattern, name)) 
[13:34:37.424]                               next
[13:34:37.424]                             invokeRestart(restart)
[13:34:37.424]                             muffled <- TRUE
[13:34:37.424]                             break
[13:34:37.424]                           }
[13:34:37.424]                         }
[13:34:37.424]                       }
[13:34:37.424]                       invisible(muffled)
[13:34:37.424]                     }
[13:34:37.424]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.424]                   }
[13:34:37.424]                 }
[13:34:37.424]                 else {
[13:34:37.424]                   if (TRUE) {
[13:34:37.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:37.424]                     {
[13:34:37.424]                       inherits <- base::inherits
[13:34:37.424]                       invokeRestart <- base::invokeRestart
[13:34:37.424]                       is.null <- base::is.null
[13:34:37.424]                       muffled <- FALSE
[13:34:37.424]                       if (inherits(cond, "message")) {
[13:34:37.424]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:37.424]                         if (muffled) 
[13:34:37.424]                           invokeRestart("muffleMessage")
[13:34:37.424]                       }
[13:34:37.424]                       else if (inherits(cond, "warning")) {
[13:34:37.424]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:37.424]                         if (muffled) 
[13:34:37.424]                           invokeRestart("muffleWarning")
[13:34:37.424]                       }
[13:34:37.424]                       else if (inherits(cond, "condition")) {
[13:34:37.424]                         if (!is.null(pattern)) {
[13:34:37.424]                           computeRestarts <- base::computeRestarts
[13:34:37.424]                           grepl <- base::grepl
[13:34:37.424]                           restarts <- computeRestarts(cond)
[13:34:37.424]                           for (restart in restarts) {
[13:34:37.424]                             name <- restart$name
[13:34:37.424]                             if (is.null(name)) 
[13:34:37.424]                               next
[13:34:37.424]                             if (!grepl(pattern, name)) 
[13:34:37.424]                               next
[13:34:37.424]                             invokeRestart(restart)
[13:34:37.424]                             muffled <- TRUE
[13:34:37.424]                             break
[13:34:37.424]                           }
[13:34:37.424]                         }
[13:34:37.424]                       }
[13:34:37.424]                       invisible(muffled)
[13:34:37.424]                     }
[13:34:37.424]                     muffleCondition(cond, pattern = "^muffle")
[13:34:37.424]                   }
[13:34:37.424]                 }
[13:34:37.424]             }
[13:34:37.424]         }))
[13:34:37.424]     }, error = function(ex) {
[13:34:37.424]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:37.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:37.424]                 ...future.rng), started = ...future.startTime, 
[13:34:37.424]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:37.424]             version = "1.8"), class = "FutureResult")
[13:34:37.424]     }, finally = {
[13:34:37.424]         if (!identical(...future.workdir, getwd())) 
[13:34:37.424]             setwd(...future.workdir)
[13:34:37.424]         {
[13:34:37.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:37.424]                 ...future.oldOptions$nwarnings <- NULL
[13:34:37.424]             }
[13:34:37.424]             base::options(...future.oldOptions)
[13:34:37.424]             if (.Platform$OS.type == "windows") {
[13:34:37.424]                 old_names <- names(...future.oldEnvVars)
[13:34:37.424]                 envs <- base::Sys.getenv()
[13:34:37.424]                 names <- names(envs)
[13:34:37.424]                 common <- intersect(names, old_names)
[13:34:37.424]                 added <- setdiff(names, old_names)
[13:34:37.424]                 removed <- setdiff(old_names, names)
[13:34:37.424]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:37.424]                   envs[common]]
[13:34:37.424]                 NAMES <- toupper(changed)
[13:34:37.424]                 args <- list()
[13:34:37.424]                 for (kk in seq_along(NAMES)) {
[13:34:37.424]                   name <- changed[[kk]]
[13:34:37.424]                   NAME <- NAMES[[kk]]
[13:34:37.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.424]                     next
[13:34:37.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.424]                 }
[13:34:37.424]                 NAMES <- toupper(added)
[13:34:37.424]                 for (kk in seq_along(NAMES)) {
[13:34:37.424]                   name <- added[[kk]]
[13:34:37.424]                   NAME <- NAMES[[kk]]
[13:34:37.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.424]                     next
[13:34:37.424]                   args[[name]] <- ""
[13:34:37.424]                 }
[13:34:37.424]                 NAMES <- toupper(removed)
[13:34:37.424]                 for (kk in seq_along(NAMES)) {
[13:34:37.424]                   name <- removed[[kk]]
[13:34:37.424]                   NAME <- NAMES[[kk]]
[13:34:37.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:37.424]                     next
[13:34:37.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:37.424]                 }
[13:34:37.424]                 if (length(args) > 0) 
[13:34:37.424]                   base::do.call(base::Sys.setenv, args = args)
[13:34:37.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:37.424]             }
[13:34:37.424]             else {
[13:34:37.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:37.424]             }
[13:34:37.424]             {
[13:34:37.424]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:37.424]                   0L) {
[13:34:37.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:37.424]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:37.424]                   base::options(opts)
[13:34:37.424]                 }
[13:34:37.424]                 {
[13:34:37.424]                   {
[13:34:37.424]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:37.424]                     NULL
[13:34:37.424]                   }
[13:34:37.424]                   options(future.plan = NULL)
[13:34:37.424]                   if (is.na(NA_character_)) 
[13:34:37.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:37.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:37.424]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:37.424]                     .init = FALSE)
[13:34:37.424]                 }
[13:34:37.424]             }
[13:34:37.424]         }
[13:34:37.424]     })
[13:34:37.424]     if (TRUE) {
[13:34:37.424]         base::sink(type = "output", split = FALSE)
[13:34:37.424]         if (TRUE) {
[13:34:37.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:37.424]         }
[13:34:37.424]         else {
[13:34:37.424]             ...future.result["stdout"] <- base::list(NULL)
[13:34:37.424]         }
[13:34:37.424]         base::close(...future.stdout)
[13:34:37.424]         ...future.stdout <- NULL
[13:34:37.424]     }
[13:34:37.424]     ...future.result$conditions <- ...future.conditions
[13:34:37.424]     ...future.result$finished <- base::Sys.time()
[13:34:37.424]     ...future.result
[13:34:37.424] }
[13:34:37.427] assign_globals() ...
[13:34:37.427] List of 5
[13:34:37.427]  $ ...future.FUN            :function (x)  
[13:34:37.427]  $ MoreArgs                 : NULL
[13:34:37.427]  $ ...future.elements_ii    :List of 1
[13:34:37.427]   ..$ :List of 1
[13:34:37.427]   .. ..$ b: num 0
[13:34:37.427]  $ ...future.seeds_ii       : NULL
[13:34:37.427]  $ ...future.globals.maxSize: NULL
[13:34:37.427]  - attr(*, "where")=List of 5
[13:34:37.427]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:34:37.427]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:34:37.427]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:34:37.427]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:34:37.427]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:34:37.427]  - attr(*, "resolved")= logi FALSE
[13:34:37.427]  - attr(*, "total_size")= num 904
[13:34:37.427]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:37.427]  - attr(*, "already-done")= logi TRUE
[13:34:37.434] - copied ‘...future.FUN’ to environment
[13:34:37.434] - copied ‘MoreArgs’ to environment
[13:34:37.434] - copied ‘...future.elements_ii’ to environment
[13:34:37.434] - copied ‘...future.seeds_ii’ to environment
[13:34:37.435] - copied ‘...future.globals.maxSize’ to environment
[13:34:37.435] assign_globals() ... done
[13:34:37.435] requestCore(): workers = 2
[13:34:37.439] MulticoreFuture started
[13:34:37.439] - Launch lazy future ... done
[13:34:37.440] run() for ‘MulticoreFuture’ ... done
[13:34:37.440] Created future:
[13:34:37.440] plan(): Setting new future strategy stack:
[13:34:37.440] List of future strategies:
[13:34:37.440] 1. sequential:
[13:34:37.440]    - args: function (..., envir = parent.frame())
[13:34:37.440]    - tweaked: FALSE
[13:34:37.440]    - call: NULL
[13:34:37.441] plan(): nbrOfWorkers() = 1
[13:34:37.440] MulticoreFuture:
[13:34:37.440] Label: ‘future_mapply-2’
[13:34:37.440] Expression:
[13:34:37.440] {
[13:34:37.440]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:37.440]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:37.440]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:37.440]         on.exit(options(oopts), add = TRUE)
[13:34:37.440]     }
[13:34:37.440]     {
[13:34:37.440]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:37.440]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:37.440]         do.call(mapply, args = args)
[13:34:37.440]     }
[13:34:37.440] }
[13:34:37.440] Lazy evaluation: FALSE
[13:34:37.440] Asynchronous evaluation: TRUE
[13:34:37.440] Local evaluation: TRUE
[13:34:37.440] Environment: R_GlobalEnv
[13:34:37.440] Capture standard output: TRUE
[13:34:37.440] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:37.440] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:37.440] Packages: <none>
[13:34:37.440] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:37.440] Resolved: FALSE
[13:34:37.440] Value: <not collected>
[13:34:37.440] Conditions captured: <none>
[13:34:37.440] Early signaling: FALSE
[13:34:37.440] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:37.440] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:37.454] Chunk #2 of 2 ... DONE
[13:34:37.454] Launching 2 futures (chunks) ... DONE
[13:34:37.454] Resolving 2 futures (chunks) ...
[13:34:37.455] plan(): Setting new future strategy stack:
[13:34:37.455] resolve() on list ...
[13:34:37.455]  recursive: 0
[13:34:37.455] List of future strategies:
[13:34:37.455] 1. multicore:
[13:34:37.455]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:34:37.455]    - tweaked: FALSE
[13:34:37.455]    - call: plan(strategy)
[13:34:37.455]  length: 2
[13:34:37.463] 
[13:34:37.464] Future #1
[13:34:37.464] result() for MulticoreFuture ...
[13:34:37.465] result() for MulticoreFuture ...
[13:34:37.466] result() for MulticoreFuture ... done
[13:34:37.466] result() for MulticoreFuture ... done
[13:34:37.466] result() for MulticoreFuture ...
[13:34:37.466] result() for MulticoreFuture ... done
[13:34:37.466] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:34:37.467] - nx: 2
[13:34:37.467] - relay: TRUE
[13:34:37.467] - stdout: TRUE
[13:34:37.467] - signal: TRUE
[13:34:37.467] - resignal: FALSE
[13:34:37.467] - force: TRUE
[13:34:37.467] plan(): nbrOfWorkers() = 2
[13:34:37.468] - relayed: [n=2] FALSE, FALSE
[13:34:37.468] - queued futures: [n=2] FALSE, FALSE
[13:34:37.468]  - until=1
[13:34:37.468]  - relaying element #1
[13:34:37.468] result() for MulticoreFuture ...
[13:34:37.468] result() for MulticoreFuture ... done
[13:34:37.469] result() for MulticoreFuture ...
[13:34:37.469] result() for MulticoreFuture ... done
[13:34:37.469] result() for MulticoreFuture ...
[13:34:37.469] result() for MulticoreFuture ... done
[13:34:37.469] result() for MulticoreFuture ...
[13:34:37.470] result() for MulticoreFuture ... done
[13:34:37.470] - relayed: [n=2] TRUE, FALSE
[13:34:37.470] - queued futures: [n=2] TRUE, FALSE
[13:34:37.470] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:34:37.470]  length: 1 (resolved future 1)
[13:34:37.471] Future #2
[13:34:37.471] result() for MulticoreFuture ...
[13:34:37.472] result() for MulticoreFuture ...
[13:34:37.472] result() for MulticoreFuture ... done
[13:34:37.472] result() for MulticoreFuture ... done
[13:34:37.472] result() for MulticoreFuture ...
[13:34:37.472] result() for MulticoreFuture ... done
[13:34:37.472] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:34:37.473] - nx: 2
[13:34:37.473] - relay: TRUE
[13:34:37.473] - stdout: TRUE
[13:34:37.473] - signal: TRUE
[13:34:37.473] - resignal: FALSE
[13:34:37.473] - force: TRUE
[13:34:37.473] - relayed: [n=2] TRUE, FALSE
[13:34:37.473] - queued futures: [n=2] TRUE, FALSE
[13:34:37.474]  - until=2
[13:34:37.474]  - relaying element #2
[13:34:37.474] result() for MulticoreFuture ...
[13:34:37.474] result() for MulticoreFuture ... done
[13:34:37.474] result() for MulticoreFuture ...
[13:34:37.474] result() for MulticoreFuture ... done
[13:34:37.474] result() for MulticoreFuture ...
[13:34:37.474] result() for MulticoreFuture ... done
[13:34:37.475] result() for MulticoreFuture ...
[13:34:37.475] result() for MulticoreFuture ... done
[13:34:37.475] - relayed: [n=2] TRUE, TRUE
[13:34:37.475] - queued futures: [n=2] TRUE, TRUE
[13:34:37.475] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:34:37.475]  length: 0 (resolved future 2)
[13:34:37.475] Relaying remaining futures
[13:34:37.475] signalConditionsASAP(NULL, pos=0) ...
[13:34:37.475] - nx: 2
[13:34:37.476] - relay: TRUE
[13:34:37.476] - stdout: TRUE
[13:34:37.476] - signal: TRUE
[13:34:37.476] - resignal: FALSE
[13:34:37.476] - force: TRUE
[13:34:37.476] - relayed: [n=2] TRUE, TRUE
[13:34:37.476] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:37.476] - relayed: [n=2] TRUE, TRUE
[13:34:37.476] - queued futures: [n=2] TRUE, TRUE
[13:34:37.477] signalConditionsASAP(NULL, pos=0) ... done
[13:34:37.477] resolve() on list ... DONE
[13:34:37.477] result() for MulticoreFuture ...
[13:34:37.477] result() for MulticoreFuture ... done
[13:34:37.477] result() for MulticoreFuture ...
[13:34:37.477] result() for MulticoreFuture ... done
[13:34:37.477] result() for MulticoreFuture ...
[13:34:37.477] result() for MulticoreFuture ... done
[13:34:37.477] result() for MulticoreFuture ...
[13:34:37.477] result() for MulticoreFuture ... done
[13:34:37.478]  - Number of value chunks collected: 2
[13:34:37.478] Resolving 2 futures (chunks) ... DONE
[13:34:37.478] Reducing values from 2 chunks ...
[13:34:37.478]  - Number of values collected after concatenation: 2
[13:34:37.478]  - Number of values expected: 2
[13:34:37.478] Reducing values from 2 chunks ... DONE
[13:34:37.478] future_mapply() ... DONE
[13:34:37.479] plan(): Setting new future strategy stack:
[13:34:37.479] List of future strategies:
[13:34:37.479] 1. sequential:
[13:34:37.479]    - args: function (..., envir = parent.frame())
[13:34:37.479]    - tweaked: FALSE
[13:34:37.479]    - call: plan(sequential)
[13:34:37.479] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[13:34:37.480] plan(): Setting new future strategy stack:
[13:34:37.480] List of future strategies:
[13:34:37.480] 1. multisession:
[13:34:37.480]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:34:37.480]    - tweaked: FALSE
[13:34:37.480]    - call: plan(strategy)
[13:34:37.480] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:34:37.480] multisession:
[13:34:37.480] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:34:37.480] - tweaked: FALSE
[13:34:37.480] - call: plan(strategy)
[13:34:37.487] getGlobalsAndPackages() ...
[13:34:37.487] Not searching for globals
[13:34:37.487] - globals: [0] <none>
[13:34:37.487] getGlobalsAndPackages() ... DONE
[13:34:37.488] [local output] makeClusterPSOCK() ...
[13:34:37.538] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:34:37.540] [local output] Base port: 11956
[13:34:37.540] [local output] Getting setup options for 2 cluster nodes ...
[13:34:37.540] [local output]  - Node 1 of 2 ...
[13:34:37.540] [local output] localMachine=TRUE => revtunnel=FALSE

[13:34:37.541] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpRDZRiT/worker.rank=1.parallelly.parent=74932.124b448504197.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpRDZRiT/worker.rank=1.parallelly.parent=74932.124b448504197.pid")'’
[13:34:37.732] - Possible to infer worker's PID: TRUE
[13:34:37.732] [local output] Rscript port: 11956

[13:34:37.732] [local output]  - Node 2 of 2 ...
[13:34:37.733] [local output] localMachine=TRUE => revtunnel=FALSE

[13:34:37.733] [local output] Rscript port: 11956

[13:34:37.733] [local output] Getting setup options for 2 cluster nodes ... done
[13:34:37.734] [local output]  - Parallel setup requested for some PSOCK nodes
[13:34:37.734] [local output] Setting up PSOCK nodes in parallel
[13:34:37.734] List of 36
[13:34:37.734]  $ worker          : chr "localhost"
[13:34:37.734]   ..- attr(*, "localhost")= logi TRUE
[13:34:37.734]  $ master          : chr "localhost"
[13:34:37.734]  $ port            : int 11956
[13:34:37.734]  $ connectTimeout  : num 120
[13:34:37.734]  $ timeout         : num 2592000
[13:34:37.734]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:34:37.734]  $ homogeneous     : logi TRUE
[13:34:37.734]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:34:37.734]  $ rscript_envs    : NULL
[13:34:37.734]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:34:37.734]  $ rscript_startup : NULL
[13:34:37.734]  $ rscript_sh      : chr "sh"
[13:34:37.734]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:34:37.734]  $ methods         : logi TRUE
[13:34:37.734]  $ socketOptions   : chr "no-delay"
[13:34:37.734]  $ useXDR          : logi FALSE
[13:34:37.734]  $ outfile         : chr "/dev/null"
[13:34:37.734]  $ renice          : int NA
[13:34:37.734]  $ rshcmd          : NULL
[13:34:37.734]  $ user            : chr(0) 
[13:34:37.734]  $ revtunnel       : logi FALSE
[13:34:37.734]  $ rshlogfile      : NULL
[13:34:37.734]  $ rshopts         : chr(0) 
[13:34:37.734]  $ rank            : int 1
[13:34:37.734]  $ manual          : logi FALSE
[13:34:37.734]  $ dryrun          : logi FALSE
[13:34:37.734]  $ quiet           : logi FALSE
[13:34:37.734]  $ setup_strategy  : chr "parallel"
[13:34:37.734]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:34:37.734]  $ pidfile         : chr "/tmp/RtmpRDZRiT/worker.rank=1.parallelly.parent=74932.124b448504197.pid"
[13:34:37.734]  $ rshcmd_label    : NULL
[13:34:37.734]  $ rsh_call        : NULL
[13:34:37.734]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:34:37.734]  $ localMachine    : logi TRUE
[13:34:37.734]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:34:37.734]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:34:37.734]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:34:37.734]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:34:37.734]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:34:37.734]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:34:37.734]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:34:37.734]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:34:37.734]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:34:37.734]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:34:37.734]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:34:37.734]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:34:37.734]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:34:37.734]  $ arguments       :List of 28
[13:34:37.734]   ..$ worker          : chr "localhost"
[13:34:37.734]   ..$ master          : NULL
[13:34:37.734]   ..$ port            : int 11956
[13:34:37.734]   ..$ connectTimeout  : num 120
[13:34:37.734]   ..$ timeout         : num 2592000
[13:34:37.734]   ..$ rscript         : NULL
[13:34:37.734]   ..$ homogeneous     : NULL
[13:34:37.734]   ..$ rscript_args    : NULL
[13:34:37.734]   ..$ rscript_envs    : NULL
[13:34:37.734]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:34:37.734]   ..$ rscript_startup : NULL
[13:34:37.734]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:34:37.734]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:34:37.734]   ..$ methods         : logi TRUE
[13:34:37.734]   ..$ socketOptions   : chr "no-delay"
[13:34:37.734]   ..$ useXDR          : logi FALSE
[13:34:37.734]   ..$ outfile         : chr "/dev/null"
[13:34:37.734]   ..$ renice          : int NA
[13:34:37.734]   ..$ rshcmd          : NULL
[13:34:37.734]   ..$ user            : NULL
[13:34:37.734]   ..$ revtunnel       : logi NA
[13:34:37.734]   ..$ rshlogfile      : NULL
[13:34:37.734]   ..$ rshopts         : NULL
[13:34:37.734]   ..$ rank            : int 1
[13:34:37.734]   ..$ manual          : logi FALSE
[13:34:37.734]   ..$ dryrun          : logi FALSE
[13:34:37.734]   ..$ quiet           : logi FALSE
[13:34:37.734]   ..$ setup_strategy  : chr "parallel"
[13:34:37.734]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:34:37.750] [local output] System call to launch all workers:
[13:34:37.750] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpRDZRiT/worker.rank=1.parallelly.parent=74932.124b448504197.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11956 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:34:37.751] [local output] Starting PSOCK main server
[13:34:37.756] [local output] Workers launched
[13:34:37.756] [local output] Waiting for workers to connect back
[13:34:37.756]  - [local output] 0 workers out of 2 ready
[13:34:38.006]  - [local output] 0 workers out of 2 ready
[13:34:38.006]  - [local output] 1 workers out of 2 ready
[13:34:38.007]  - [local output] 2 workers out of 2 ready
[13:34:38.007] [local output] Launching of workers completed
[13:34:38.007] [local output] Collecting session information from workers
[13:34:38.008] [local output]  - Worker #1 of 2
[13:34:38.008] [local output]  - Worker #2 of 2
[13:34:38.008] [local output] makeClusterPSOCK() ... done
[13:34:38.019] Packages needed by the future expression (n = 0): <none>
[13:34:38.020] Packages needed by future strategies (n = 0): <none>
[13:34:38.020] {
[13:34:38.020]     {
[13:34:38.020]         {
[13:34:38.020]             ...future.startTime <- base::Sys.time()
[13:34:38.020]             {
[13:34:38.020]                 {
[13:34:38.020]                   {
[13:34:38.020]                     {
[13:34:38.020]                       base::local({
[13:34:38.020]                         has_future <- base::requireNamespace("future", 
[13:34:38.020]                           quietly = TRUE)
[13:34:38.020]                         if (has_future) {
[13:34:38.020]                           ns <- base::getNamespace("future")
[13:34:38.020]                           version <- ns[[".package"]][["version"]]
[13:34:38.020]                           if (is.null(version)) 
[13:34:38.020]                             version <- utils::packageVersion("future")
[13:34:38.020]                         }
[13:34:38.020]                         else {
[13:34:38.020]                           version <- NULL
[13:34:38.020]                         }
[13:34:38.020]                         if (!has_future || version < "1.8.0") {
[13:34:38.020]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.020]                             "", base::R.version$version.string), 
[13:34:38.020]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.020]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.020]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.020]                               "release", "version")], collapse = " "), 
[13:34:38.020]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.020]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.020]                             info)
[13:34:38.020]                           info <- base::paste(info, collapse = "; ")
[13:34:38.020]                           if (!has_future) {
[13:34:38.020]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.020]                               info)
[13:34:38.020]                           }
[13:34:38.020]                           else {
[13:34:38.020]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.020]                               info, version)
[13:34:38.020]                           }
[13:34:38.020]                           base::stop(msg)
[13:34:38.020]                         }
[13:34:38.020]                       })
[13:34:38.020]                     }
[13:34:38.020]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.020]                     base::options(mc.cores = 1L)
[13:34:38.020]                   }
[13:34:38.020]                   ...future.strategy.old <- future::plan("list")
[13:34:38.020]                   options(future.plan = NULL)
[13:34:38.020]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.020]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.020]                 }
[13:34:38.020]                 ...future.workdir <- getwd()
[13:34:38.020]             }
[13:34:38.020]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.020]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.020]         }
[13:34:38.020]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.020]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:38.020]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.020]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.020]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.020]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.020]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.020]             base::names(...future.oldOptions))
[13:34:38.020]     }
[13:34:38.020]     if (FALSE) {
[13:34:38.020]     }
[13:34:38.020]     else {
[13:34:38.020]         if (TRUE) {
[13:34:38.020]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.020]                 open = "w")
[13:34:38.020]         }
[13:34:38.020]         else {
[13:34:38.020]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.020]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.020]         }
[13:34:38.020]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.020]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.020]             base::sink(type = "output", split = FALSE)
[13:34:38.020]             base::close(...future.stdout)
[13:34:38.020]         }, add = TRUE)
[13:34:38.020]     }
[13:34:38.020]     ...future.frame <- base::sys.nframe()
[13:34:38.020]     ...future.conditions <- base::list()
[13:34:38.020]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.020]     if (FALSE) {
[13:34:38.020]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.020]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.020]     }
[13:34:38.020]     ...future.result <- base::tryCatch({
[13:34:38.020]         base::withCallingHandlers({
[13:34:38.020]             ...future.value <- base::withVisible(base::local({
[13:34:38.020]                 ...future.makeSendCondition <- base::local({
[13:34:38.020]                   sendCondition <- NULL
[13:34:38.020]                   function(frame = 1L) {
[13:34:38.020]                     if (is.function(sendCondition)) 
[13:34:38.020]                       return(sendCondition)
[13:34:38.020]                     ns <- getNamespace("parallel")
[13:34:38.020]                     if (exists("sendData", mode = "function", 
[13:34:38.020]                       envir = ns)) {
[13:34:38.020]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.020]                         envir = ns)
[13:34:38.020]                       envir <- sys.frame(frame)
[13:34:38.020]                       master <- NULL
[13:34:38.020]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.020]                         !identical(envir, emptyenv())) {
[13:34:38.020]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.020]                           inherits = FALSE)) {
[13:34:38.020]                           master <- get("master", mode = "list", 
[13:34:38.020]                             envir = envir, inherits = FALSE)
[13:34:38.020]                           if (inherits(master, c("SOCKnode", 
[13:34:38.020]                             "SOCK0node"))) {
[13:34:38.020]                             sendCondition <<- function(cond) {
[13:34:38.020]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.020]                                 success = TRUE)
[13:34:38.020]                               parallel_sendData(master, data)
[13:34:38.020]                             }
[13:34:38.020]                             return(sendCondition)
[13:34:38.020]                           }
[13:34:38.020]                         }
[13:34:38.020]                         frame <- frame + 1L
[13:34:38.020]                         envir <- sys.frame(frame)
[13:34:38.020]                       }
[13:34:38.020]                     }
[13:34:38.020]                     sendCondition <<- function(cond) NULL
[13:34:38.020]                   }
[13:34:38.020]                 })
[13:34:38.020]                 withCallingHandlers({
[13:34:38.020]                   NA
[13:34:38.020]                 }, immediateCondition = function(cond) {
[13:34:38.020]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.020]                   sendCondition(cond)
[13:34:38.020]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.020]                   {
[13:34:38.020]                     inherits <- base::inherits
[13:34:38.020]                     invokeRestart <- base::invokeRestart
[13:34:38.020]                     is.null <- base::is.null
[13:34:38.020]                     muffled <- FALSE
[13:34:38.020]                     if (inherits(cond, "message")) {
[13:34:38.020]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.020]                       if (muffled) 
[13:34:38.020]                         invokeRestart("muffleMessage")
[13:34:38.020]                     }
[13:34:38.020]                     else if (inherits(cond, "warning")) {
[13:34:38.020]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.020]                       if (muffled) 
[13:34:38.020]                         invokeRestart("muffleWarning")
[13:34:38.020]                     }
[13:34:38.020]                     else if (inherits(cond, "condition")) {
[13:34:38.020]                       if (!is.null(pattern)) {
[13:34:38.020]                         computeRestarts <- base::computeRestarts
[13:34:38.020]                         grepl <- base::grepl
[13:34:38.020]                         restarts <- computeRestarts(cond)
[13:34:38.020]                         for (restart in restarts) {
[13:34:38.020]                           name <- restart$name
[13:34:38.020]                           if (is.null(name)) 
[13:34:38.020]                             next
[13:34:38.020]                           if (!grepl(pattern, name)) 
[13:34:38.020]                             next
[13:34:38.020]                           invokeRestart(restart)
[13:34:38.020]                           muffled <- TRUE
[13:34:38.020]                           break
[13:34:38.020]                         }
[13:34:38.020]                       }
[13:34:38.020]                     }
[13:34:38.020]                     invisible(muffled)
[13:34:38.020]                   }
[13:34:38.020]                   muffleCondition(cond)
[13:34:38.020]                 })
[13:34:38.020]             }))
[13:34:38.020]             future::FutureResult(value = ...future.value$value, 
[13:34:38.020]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.020]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.020]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.020]                     ...future.globalenv.names))
[13:34:38.020]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.020]         }, condition = base::local({
[13:34:38.020]             c <- base::c
[13:34:38.020]             inherits <- base::inherits
[13:34:38.020]             invokeRestart <- base::invokeRestart
[13:34:38.020]             length <- base::length
[13:34:38.020]             list <- base::list
[13:34:38.020]             seq.int <- base::seq.int
[13:34:38.020]             signalCondition <- base::signalCondition
[13:34:38.020]             sys.calls <- base::sys.calls
[13:34:38.020]             `[[` <- base::`[[`
[13:34:38.020]             `+` <- base::`+`
[13:34:38.020]             `<<-` <- base::`<<-`
[13:34:38.020]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.020]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.020]                   3L)]
[13:34:38.020]             }
[13:34:38.020]             function(cond) {
[13:34:38.020]                 is_error <- inherits(cond, "error")
[13:34:38.020]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.020]                   NULL)
[13:34:38.020]                 if (is_error) {
[13:34:38.020]                   sessionInformation <- function() {
[13:34:38.020]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.020]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.020]                       search = base::search(), system = base::Sys.info())
[13:34:38.020]                   }
[13:34:38.020]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.020]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.020]                     cond$call), session = sessionInformation(), 
[13:34:38.020]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.020]                   signalCondition(cond)
[13:34:38.020]                 }
[13:34:38.020]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.020]                 "immediateCondition"))) {
[13:34:38.020]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.020]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.020]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.020]                   if (TRUE && !signal) {
[13:34:38.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.020]                     {
[13:34:38.020]                       inherits <- base::inherits
[13:34:38.020]                       invokeRestart <- base::invokeRestart
[13:34:38.020]                       is.null <- base::is.null
[13:34:38.020]                       muffled <- FALSE
[13:34:38.020]                       if (inherits(cond, "message")) {
[13:34:38.020]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.020]                         if (muffled) 
[13:34:38.020]                           invokeRestart("muffleMessage")
[13:34:38.020]                       }
[13:34:38.020]                       else if (inherits(cond, "warning")) {
[13:34:38.020]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.020]                         if (muffled) 
[13:34:38.020]                           invokeRestart("muffleWarning")
[13:34:38.020]                       }
[13:34:38.020]                       else if (inherits(cond, "condition")) {
[13:34:38.020]                         if (!is.null(pattern)) {
[13:34:38.020]                           computeRestarts <- base::computeRestarts
[13:34:38.020]                           grepl <- base::grepl
[13:34:38.020]                           restarts <- computeRestarts(cond)
[13:34:38.020]                           for (restart in restarts) {
[13:34:38.020]                             name <- restart$name
[13:34:38.020]                             if (is.null(name)) 
[13:34:38.020]                               next
[13:34:38.020]                             if (!grepl(pattern, name)) 
[13:34:38.020]                               next
[13:34:38.020]                             invokeRestart(restart)
[13:34:38.020]                             muffled <- TRUE
[13:34:38.020]                             break
[13:34:38.020]                           }
[13:34:38.020]                         }
[13:34:38.020]                       }
[13:34:38.020]                       invisible(muffled)
[13:34:38.020]                     }
[13:34:38.020]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.020]                   }
[13:34:38.020]                 }
[13:34:38.020]                 else {
[13:34:38.020]                   if (TRUE) {
[13:34:38.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.020]                     {
[13:34:38.020]                       inherits <- base::inherits
[13:34:38.020]                       invokeRestart <- base::invokeRestart
[13:34:38.020]                       is.null <- base::is.null
[13:34:38.020]                       muffled <- FALSE
[13:34:38.020]                       if (inherits(cond, "message")) {
[13:34:38.020]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.020]                         if (muffled) 
[13:34:38.020]                           invokeRestart("muffleMessage")
[13:34:38.020]                       }
[13:34:38.020]                       else if (inherits(cond, "warning")) {
[13:34:38.020]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.020]                         if (muffled) 
[13:34:38.020]                           invokeRestart("muffleWarning")
[13:34:38.020]                       }
[13:34:38.020]                       else if (inherits(cond, "condition")) {
[13:34:38.020]                         if (!is.null(pattern)) {
[13:34:38.020]                           computeRestarts <- base::computeRestarts
[13:34:38.020]                           grepl <- base::grepl
[13:34:38.020]                           restarts <- computeRestarts(cond)
[13:34:38.020]                           for (restart in restarts) {
[13:34:38.020]                             name <- restart$name
[13:34:38.020]                             if (is.null(name)) 
[13:34:38.020]                               next
[13:34:38.020]                             if (!grepl(pattern, name)) 
[13:34:38.020]                               next
[13:34:38.020]                             invokeRestart(restart)
[13:34:38.020]                             muffled <- TRUE
[13:34:38.020]                             break
[13:34:38.020]                           }
[13:34:38.020]                         }
[13:34:38.020]                       }
[13:34:38.020]                       invisible(muffled)
[13:34:38.020]                     }
[13:34:38.020]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.020]                   }
[13:34:38.020]                 }
[13:34:38.020]             }
[13:34:38.020]         }))
[13:34:38.020]     }, error = function(ex) {
[13:34:38.020]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.020]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.020]                 ...future.rng), started = ...future.startTime, 
[13:34:38.020]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.020]             version = "1.8"), class = "FutureResult")
[13:34:38.020]     }, finally = {
[13:34:38.020]         if (!identical(...future.workdir, getwd())) 
[13:34:38.020]             setwd(...future.workdir)
[13:34:38.020]         {
[13:34:38.020]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.020]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.020]             }
[13:34:38.020]             base::options(...future.oldOptions)
[13:34:38.020]             if (.Platform$OS.type == "windows") {
[13:34:38.020]                 old_names <- names(...future.oldEnvVars)
[13:34:38.020]                 envs <- base::Sys.getenv()
[13:34:38.020]                 names <- names(envs)
[13:34:38.020]                 common <- intersect(names, old_names)
[13:34:38.020]                 added <- setdiff(names, old_names)
[13:34:38.020]                 removed <- setdiff(old_names, names)
[13:34:38.020]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.020]                   envs[common]]
[13:34:38.020]                 NAMES <- toupper(changed)
[13:34:38.020]                 args <- list()
[13:34:38.020]                 for (kk in seq_along(NAMES)) {
[13:34:38.020]                   name <- changed[[kk]]
[13:34:38.020]                   NAME <- NAMES[[kk]]
[13:34:38.020]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.020]                     next
[13:34:38.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.020]                 }
[13:34:38.020]                 NAMES <- toupper(added)
[13:34:38.020]                 for (kk in seq_along(NAMES)) {
[13:34:38.020]                   name <- added[[kk]]
[13:34:38.020]                   NAME <- NAMES[[kk]]
[13:34:38.020]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.020]                     next
[13:34:38.020]                   args[[name]] <- ""
[13:34:38.020]                 }
[13:34:38.020]                 NAMES <- toupper(removed)
[13:34:38.020]                 for (kk in seq_along(NAMES)) {
[13:34:38.020]                   name <- removed[[kk]]
[13:34:38.020]                   NAME <- NAMES[[kk]]
[13:34:38.020]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.020]                     next
[13:34:38.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.020]                 }
[13:34:38.020]                 if (length(args) > 0) 
[13:34:38.020]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.020]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.020]             }
[13:34:38.020]             else {
[13:34:38.020]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.020]             }
[13:34:38.020]             {
[13:34:38.020]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.020]                   0L) {
[13:34:38.020]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.020]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.020]                   base::options(opts)
[13:34:38.020]                 }
[13:34:38.020]                 {
[13:34:38.020]                   {
[13:34:38.020]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.020]                     NULL
[13:34:38.020]                   }
[13:34:38.020]                   options(future.plan = NULL)
[13:34:38.020]                   if (is.na(NA_character_)) 
[13:34:38.020]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.020]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.020]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.020]                     .init = FALSE)
[13:34:38.020]                 }
[13:34:38.020]             }
[13:34:38.020]         }
[13:34:38.020]     })
[13:34:38.020]     if (TRUE) {
[13:34:38.020]         base::sink(type = "output", split = FALSE)
[13:34:38.020]         if (TRUE) {
[13:34:38.020]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.020]         }
[13:34:38.020]         else {
[13:34:38.020]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.020]         }
[13:34:38.020]         base::close(...future.stdout)
[13:34:38.020]         ...future.stdout <- NULL
[13:34:38.020]     }
[13:34:38.020]     ...future.result$conditions <- ...future.conditions
[13:34:38.020]     ...future.result$finished <- base::Sys.time()
[13:34:38.020]     ...future.result
[13:34:38.020] }
[13:34:38.073] MultisessionFuture started
[13:34:38.073] result() for ClusterFuture ...
[13:34:38.074] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.074] - Validating connection of MultisessionFuture
[13:34:38.107] - received message: FutureResult
[13:34:38.107] - Received FutureResult
[13:34:38.107] - Erased future from FutureRegistry
[13:34:38.107] result() for ClusterFuture ...
[13:34:38.107] - result already collected: FutureResult
[13:34:38.107] result() for ClusterFuture ... done
[13:34:38.107] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.107] result() for ClusterFuture ... done
[13:34:38.107] result() for ClusterFuture ...
[13:34:38.108] - result already collected: FutureResult
[13:34:38.108] result() for ClusterFuture ... done
[13:34:38.108] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:34:38.112] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[13:34:38.112] future_mapply() ...
[13:34:38.115] Number of chunks: 2
[13:34:38.115] getGlobalsAndPackagesXApply() ...
[13:34:38.115]  - future.globals: TRUE
[13:34:38.116] getGlobalsAndPackages() ...
[13:34:38.116] Searching for globals...
[13:34:38.116] - globals found: [1] ‘FUN’
[13:34:38.116] Searching for globals ... DONE
[13:34:38.116] Resolving globals: FALSE
[13:34:38.117] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:38.117] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:38.117] - globals: [1] ‘FUN’
[13:34:38.117] 
[13:34:38.117] getGlobalsAndPackages() ... DONE
[13:34:38.118]  - globals found/used: [n=1] ‘FUN’
[13:34:38.118]  - needed namespaces: [n=0] 
[13:34:38.118] Finding globals ... DONE
[13:34:38.118] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:38.118] List of 2
[13:34:38.118]  $ ...future.FUN:function (x, ...)  
[13:34:38.118]  $ MoreArgs     : NULL
[13:34:38.118]  - attr(*, "where")=List of 2
[13:34:38.118]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:38.118]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:38.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:38.118]  - attr(*, "resolved")= logi FALSE
[13:34:38.118]  - attr(*, "total_size")= num NA
[13:34:38.121] Packages to be attached in all futures: [n=0] 
[13:34:38.121] getGlobalsAndPackagesXApply() ... DONE
[13:34:38.121] Number of futures (= number of chunks): 2
[13:34:38.121] Launching 2 futures (chunks) ...
[13:34:38.121] Chunk #1 of 2 ...
[13:34:38.121]  - Finding globals in '...' for chunk #1 ...
[13:34:38.121] getGlobalsAndPackages() ...
[13:34:38.121] Searching for globals...
[13:34:38.122] 
[13:34:38.122] Searching for globals ... DONE
[13:34:38.122] - globals: [0] <none>
[13:34:38.122] getGlobalsAndPackages() ... DONE
[13:34:38.122]    + additional globals found: [n=0] 
[13:34:38.122]    + additional namespaces needed: [n=0] 
[13:34:38.122]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:38.122]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.122]  - seeds: <none>
[13:34:38.122]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.123] getGlobalsAndPackages() ...
[13:34:38.123] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.123] Resolving globals: FALSE
[13:34:38.123] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:38.124] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:38.124] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.124] 
[13:34:38.124] getGlobalsAndPackages() ... DONE
[13:34:38.124] run() for ‘Future’ ...
[13:34:38.124] - state: ‘created’
[13:34:38.125] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.138] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.138] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.138]   - Field: ‘node’
[13:34:38.138]   - Field: ‘label’
[13:34:38.139]   - Field: ‘local’
[13:34:38.139]   - Field: ‘owner’
[13:34:38.139]   - Field: ‘envir’
[13:34:38.139]   - Field: ‘workers’
[13:34:38.139]   - Field: ‘packages’
[13:34:38.139]   - Field: ‘gc’
[13:34:38.139]   - Field: ‘conditions’
[13:34:38.139]   - Field: ‘persistent’
[13:34:38.139]   - Field: ‘expr’
[13:34:38.139]   - Field: ‘uuid’
[13:34:38.139]   - Field: ‘seed’
[13:34:38.140]   - Field: ‘version’
[13:34:38.140]   - Field: ‘result’
[13:34:38.140]   - Field: ‘asynchronous’
[13:34:38.140]   - Field: ‘calls’
[13:34:38.140]   - Field: ‘globals’
[13:34:38.140]   - Field: ‘stdout’
[13:34:38.140]   - Field: ‘earlySignal’
[13:34:38.140]   - Field: ‘lazy’
[13:34:38.140]   - Field: ‘state’
[13:34:38.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.140] - Launch lazy future ...
[13:34:38.141] Packages needed by the future expression (n = 0): <none>
[13:34:38.141] Packages needed by future strategies (n = 0): <none>
[13:34:38.141] {
[13:34:38.141]     {
[13:34:38.141]         {
[13:34:38.141]             ...future.startTime <- base::Sys.time()
[13:34:38.141]             {
[13:34:38.141]                 {
[13:34:38.141]                   {
[13:34:38.141]                     {
[13:34:38.141]                       base::local({
[13:34:38.141]                         has_future <- base::requireNamespace("future", 
[13:34:38.141]                           quietly = TRUE)
[13:34:38.141]                         if (has_future) {
[13:34:38.141]                           ns <- base::getNamespace("future")
[13:34:38.141]                           version <- ns[[".package"]][["version"]]
[13:34:38.141]                           if (is.null(version)) 
[13:34:38.141]                             version <- utils::packageVersion("future")
[13:34:38.141]                         }
[13:34:38.141]                         else {
[13:34:38.141]                           version <- NULL
[13:34:38.141]                         }
[13:34:38.141]                         if (!has_future || version < "1.8.0") {
[13:34:38.141]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.141]                             "", base::R.version$version.string), 
[13:34:38.141]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.141]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.141]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.141]                               "release", "version")], collapse = " "), 
[13:34:38.141]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.141]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.141]                             info)
[13:34:38.141]                           info <- base::paste(info, collapse = "; ")
[13:34:38.141]                           if (!has_future) {
[13:34:38.141]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.141]                               info)
[13:34:38.141]                           }
[13:34:38.141]                           else {
[13:34:38.141]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.141]                               info, version)
[13:34:38.141]                           }
[13:34:38.141]                           base::stop(msg)
[13:34:38.141]                         }
[13:34:38.141]                       })
[13:34:38.141]                     }
[13:34:38.141]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.141]                     base::options(mc.cores = 1L)
[13:34:38.141]                   }
[13:34:38.141]                   ...future.strategy.old <- future::plan("list")
[13:34:38.141]                   options(future.plan = NULL)
[13:34:38.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.141]                 }
[13:34:38.141]                 ...future.workdir <- getwd()
[13:34:38.141]             }
[13:34:38.141]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.141]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.141]         }
[13:34:38.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.141]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.141]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.141]             base::names(...future.oldOptions))
[13:34:38.141]     }
[13:34:38.141]     if (FALSE) {
[13:34:38.141]     }
[13:34:38.141]     else {
[13:34:38.141]         if (TRUE) {
[13:34:38.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.141]                 open = "w")
[13:34:38.141]         }
[13:34:38.141]         else {
[13:34:38.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.141]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.141]         }
[13:34:38.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.141]             base::sink(type = "output", split = FALSE)
[13:34:38.141]             base::close(...future.stdout)
[13:34:38.141]         }, add = TRUE)
[13:34:38.141]     }
[13:34:38.141]     ...future.frame <- base::sys.nframe()
[13:34:38.141]     ...future.conditions <- base::list()
[13:34:38.141]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.141]     if (FALSE) {
[13:34:38.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.141]     }
[13:34:38.141]     ...future.result <- base::tryCatch({
[13:34:38.141]         base::withCallingHandlers({
[13:34:38.141]             ...future.value <- base::withVisible(base::local({
[13:34:38.141]                 ...future.makeSendCondition <- base::local({
[13:34:38.141]                   sendCondition <- NULL
[13:34:38.141]                   function(frame = 1L) {
[13:34:38.141]                     if (is.function(sendCondition)) 
[13:34:38.141]                       return(sendCondition)
[13:34:38.141]                     ns <- getNamespace("parallel")
[13:34:38.141]                     if (exists("sendData", mode = "function", 
[13:34:38.141]                       envir = ns)) {
[13:34:38.141]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.141]                         envir = ns)
[13:34:38.141]                       envir <- sys.frame(frame)
[13:34:38.141]                       master <- NULL
[13:34:38.141]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.141]                         !identical(envir, emptyenv())) {
[13:34:38.141]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.141]                           inherits = FALSE)) {
[13:34:38.141]                           master <- get("master", mode = "list", 
[13:34:38.141]                             envir = envir, inherits = FALSE)
[13:34:38.141]                           if (inherits(master, c("SOCKnode", 
[13:34:38.141]                             "SOCK0node"))) {
[13:34:38.141]                             sendCondition <<- function(cond) {
[13:34:38.141]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.141]                                 success = TRUE)
[13:34:38.141]                               parallel_sendData(master, data)
[13:34:38.141]                             }
[13:34:38.141]                             return(sendCondition)
[13:34:38.141]                           }
[13:34:38.141]                         }
[13:34:38.141]                         frame <- frame + 1L
[13:34:38.141]                         envir <- sys.frame(frame)
[13:34:38.141]                       }
[13:34:38.141]                     }
[13:34:38.141]                     sendCondition <<- function(cond) NULL
[13:34:38.141]                   }
[13:34:38.141]                 })
[13:34:38.141]                 withCallingHandlers({
[13:34:38.141]                   {
[13:34:38.141]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.141]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.141]                       ...future.globals.maxSize)) {
[13:34:38.141]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.141]                       on.exit(options(oopts), add = TRUE)
[13:34:38.141]                     }
[13:34:38.141]                     {
[13:34:38.141]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.141]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.141]                         USE.NAMES = FALSE)
[13:34:38.141]                       do.call(mapply, args = args)
[13:34:38.141]                     }
[13:34:38.141]                   }
[13:34:38.141]                 }, immediateCondition = function(cond) {
[13:34:38.141]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.141]                   sendCondition(cond)
[13:34:38.141]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.141]                   {
[13:34:38.141]                     inherits <- base::inherits
[13:34:38.141]                     invokeRestart <- base::invokeRestart
[13:34:38.141]                     is.null <- base::is.null
[13:34:38.141]                     muffled <- FALSE
[13:34:38.141]                     if (inherits(cond, "message")) {
[13:34:38.141]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.141]                       if (muffled) 
[13:34:38.141]                         invokeRestart("muffleMessage")
[13:34:38.141]                     }
[13:34:38.141]                     else if (inherits(cond, "warning")) {
[13:34:38.141]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.141]                       if (muffled) 
[13:34:38.141]                         invokeRestart("muffleWarning")
[13:34:38.141]                     }
[13:34:38.141]                     else if (inherits(cond, "condition")) {
[13:34:38.141]                       if (!is.null(pattern)) {
[13:34:38.141]                         computeRestarts <- base::computeRestarts
[13:34:38.141]                         grepl <- base::grepl
[13:34:38.141]                         restarts <- computeRestarts(cond)
[13:34:38.141]                         for (restart in restarts) {
[13:34:38.141]                           name <- restart$name
[13:34:38.141]                           if (is.null(name)) 
[13:34:38.141]                             next
[13:34:38.141]                           if (!grepl(pattern, name)) 
[13:34:38.141]                             next
[13:34:38.141]                           invokeRestart(restart)
[13:34:38.141]                           muffled <- TRUE
[13:34:38.141]                           break
[13:34:38.141]                         }
[13:34:38.141]                       }
[13:34:38.141]                     }
[13:34:38.141]                     invisible(muffled)
[13:34:38.141]                   }
[13:34:38.141]                   muffleCondition(cond)
[13:34:38.141]                 })
[13:34:38.141]             }))
[13:34:38.141]             future::FutureResult(value = ...future.value$value, 
[13:34:38.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.141]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.141]                     ...future.globalenv.names))
[13:34:38.141]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.141]         }, condition = base::local({
[13:34:38.141]             c <- base::c
[13:34:38.141]             inherits <- base::inherits
[13:34:38.141]             invokeRestart <- base::invokeRestart
[13:34:38.141]             length <- base::length
[13:34:38.141]             list <- base::list
[13:34:38.141]             seq.int <- base::seq.int
[13:34:38.141]             signalCondition <- base::signalCondition
[13:34:38.141]             sys.calls <- base::sys.calls
[13:34:38.141]             `[[` <- base::`[[`
[13:34:38.141]             `+` <- base::`+`
[13:34:38.141]             `<<-` <- base::`<<-`
[13:34:38.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.141]                   3L)]
[13:34:38.141]             }
[13:34:38.141]             function(cond) {
[13:34:38.141]                 is_error <- inherits(cond, "error")
[13:34:38.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.141]                   NULL)
[13:34:38.141]                 if (is_error) {
[13:34:38.141]                   sessionInformation <- function() {
[13:34:38.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.141]                       search = base::search(), system = base::Sys.info())
[13:34:38.141]                   }
[13:34:38.141]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.141]                     cond$call), session = sessionInformation(), 
[13:34:38.141]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.141]                   signalCondition(cond)
[13:34:38.141]                 }
[13:34:38.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.141]                 "immediateCondition"))) {
[13:34:38.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.141]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.141]                   if (TRUE && !signal) {
[13:34:38.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.141]                     {
[13:34:38.141]                       inherits <- base::inherits
[13:34:38.141]                       invokeRestart <- base::invokeRestart
[13:34:38.141]                       is.null <- base::is.null
[13:34:38.141]                       muffled <- FALSE
[13:34:38.141]                       if (inherits(cond, "message")) {
[13:34:38.141]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.141]                         if (muffled) 
[13:34:38.141]                           invokeRestart("muffleMessage")
[13:34:38.141]                       }
[13:34:38.141]                       else if (inherits(cond, "warning")) {
[13:34:38.141]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.141]                         if (muffled) 
[13:34:38.141]                           invokeRestart("muffleWarning")
[13:34:38.141]                       }
[13:34:38.141]                       else if (inherits(cond, "condition")) {
[13:34:38.141]                         if (!is.null(pattern)) {
[13:34:38.141]                           computeRestarts <- base::computeRestarts
[13:34:38.141]                           grepl <- base::grepl
[13:34:38.141]                           restarts <- computeRestarts(cond)
[13:34:38.141]                           for (restart in restarts) {
[13:34:38.141]                             name <- restart$name
[13:34:38.141]                             if (is.null(name)) 
[13:34:38.141]                               next
[13:34:38.141]                             if (!grepl(pattern, name)) 
[13:34:38.141]                               next
[13:34:38.141]                             invokeRestart(restart)
[13:34:38.141]                             muffled <- TRUE
[13:34:38.141]                             break
[13:34:38.141]                           }
[13:34:38.141]                         }
[13:34:38.141]                       }
[13:34:38.141]                       invisible(muffled)
[13:34:38.141]                     }
[13:34:38.141]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.141]                   }
[13:34:38.141]                 }
[13:34:38.141]                 else {
[13:34:38.141]                   if (TRUE) {
[13:34:38.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.141]                     {
[13:34:38.141]                       inherits <- base::inherits
[13:34:38.141]                       invokeRestart <- base::invokeRestart
[13:34:38.141]                       is.null <- base::is.null
[13:34:38.141]                       muffled <- FALSE
[13:34:38.141]                       if (inherits(cond, "message")) {
[13:34:38.141]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.141]                         if (muffled) 
[13:34:38.141]                           invokeRestart("muffleMessage")
[13:34:38.141]                       }
[13:34:38.141]                       else if (inherits(cond, "warning")) {
[13:34:38.141]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.141]                         if (muffled) 
[13:34:38.141]                           invokeRestart("muffleWarning")
[13:34:38.141]                       }
[13:34:38.141]                       else if (inherits(cond, "condition")) {
[13:34:38.141]                         if (!is.null(pattern)) {
[13:34:38.141]                           computeRestarts <- base::computeRestarts
[13:34:38.141]                           grepl <- base::grepl
[13:34:38.141]                           restarts <- computeRestarts(cond)
[13:34:38.141]                           for (restart in restarts) {
[13:34:38.141]                             name <- restart$name
[13:34:38.141]                             if (is.null(name)) 
[13:34:38.141]                               next
[13:34:38.141]                             if (!grepl(pattern, name)) 
[13:34:38.141]                               next
[13:34:38.141]                             invokeRestart(restart)
[13:34:38.141]                             muffled <- TRUE
[13:34:38.141]                             break
[13:34:38.141]                           }
[13:34:38.141]                         }
[13:34:38.141]                       }
[13:34:38.141]                       invisible(muffled)
[13:34:38.141]                     }
[13:34:38.141]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.141]                   }
[13:34:38.141]                 }
[13:34:38.141]             }
[13:34:38.141]         }))
[13:34:38.141]     }, error = function(ex) {
[13:34:38.141]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.141]                 ...future.rng), started = ...future.startTime, 
[13:34:38.141]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.141]             version = "1.8"), class = "FutureResult")
[13:34:38.141]     }, finally = {
[13:34:38.141]         if (!identical(...future.workdir, getwd())) 
[13:34:38.141]             setwd(...future.workdir)
[13:34:38.141]         {
[13:34:38.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.141]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.141]             }
[13:34:38.141]             base::options(...future.oldOptions)
[13:34:38.141]             if (.Platform$OS.type == "windows") {
[13:34:38.141]                 old_names <- names(...future.oldEnvVars)
[13:34:38.141]                 envs <- base::Sys.getenv()
[13:34:38.141]                 names <- names(envs)
[13:34:38.141]                 common <- intersect(names, old_names)
[13:34:38.141]                 added <- setdiff(names, old_names)
[13:34:38.141]                 removed <- setdiff(old_names, names)
[13:34:38.141]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.141]                   envs[common]]
[13:34:38.141]                 NAMES <- toupper(changed)
[13:34:38.141]                 args <- list()
[13:34:38.141]                 for (kk in seq_along(NAMES)) {
[13:34:38.141]                   name <- changed[[kk]]
[13:34:38.141]                   NAME <- NAMES[[kk]]
[13:34:38.141]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.141]                     next
[13:34:38.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.141]                 }
[13:34:38.141]                 NAMES <- toupper(added)
[13:34:38.141]                 for (kk in seq_along(NAMES)) {
[13:34:38.141]                   name <- added[[kk]]
[13:34:38.141]                   NAME <- NAMES[[kk]]
[13:34:38.141]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.141]                     next
[13:34:38.141]                   args[[name]] <- ""
[13:34:38.141]                 }
[13:34:38.141]                 NAMES <- toupper(removed)
[13:34:38.141]                 for (kk in seq_along(NAMES)) {
[13:34:38.141]                   name <- removed[[kk]]
[13:34:38.141]                   NAME <- NAMES[[kk]]
[13:34:38.141]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.141]                     next
[13:34:38.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.141]                 }
[13:34:38.141]                 if (length(args) > 0) 
[13:34:38.141]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.141]             }
[13:34:38.141]             else {
[13:34:38.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.141]             }
[13:34:38.141]             {
[13:34:38.141]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.141]                   0L) {
[13:34:38.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.141]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.141]                   base::options(opts)
[13:34:38.141]                 }
[13:34:38.141]                 {
[13:34:38.141]                   {
[13:34:38.141]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.141]                     NULL
[13:34:38.141]                   }
[13:34:38.141]                   options(future.plan = NULL)
[13:34:38.141]                   if (is.na(NA_character_)) 
[13:34:38.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.141]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.141]                     .init = FALSE)
[13:34:38.141]                 }
[13:34:38.141]             }
[13:34:38.141]         }
[13:34:38.141]     })
[13:34:38.141]     if (TRUE) {
[13:34:38.141]         base::sink(type = "output", split = FALSE)
[13:34:38.141]         if (TRUE) {
[13:34:38.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.141]         }
[13:34:38.141]         else {
[13:34:38.141]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.141]         }
[13:34:38.141]         base::close(...future.stdout)
[13:34:38.141]         ...future.stdout <- NULL
[13:34:38.141]     }
[13:34:38.141]     ...future.result$conditions <- ...future.conditions
[13:34:38.141]     ...future.result$finished <- base::Sys.time()
[13:34:38.141]     ...future.result
[13:34:38.141] }
[13:34:38.144] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[13:34:38.144] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[13:34:38.144] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[13:34:38.145] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:38.145] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.145] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[13:34:38.145] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[13:34:38.146] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:38.146] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.146] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:38.147] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.147] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[13:34:38.147] MultisessionFuture started
[13:34:38.147] - Launch lazy future ... done
[13:34:38.148] run() for ‘MultisessionFuture’ ... done
[13:34:38.148] Created future:
[13:34:38.148] MultisessionFuture:
[13:34:38.148] Label: ‘future_mapply-1’
[13:34:38.148] Expression:
[13:34:38.148] {
[13:34:38.148]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.148]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.148]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.148]         on.exit(options(oopts), add = TRUE)
[13:34:38.148]     }
[13:34:38.148]     {
[13:34:38.148]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.148]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.148]         do.call(mapply, args = args)
[13:34:38.148]     }
[13:34:38.148] }
[13:34:38.148] Lazy evaluation: FALSE
[13:34:38.148] Asynchronous evaluation: TRUE
[13:34:38.148] Local evaluation: TRUE
[13:34:38.148] Environment: R_GlobalEnv
[13:34:38.148] Capture standard output: TRUE
[13:34:38.148] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.148] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.148] Packages: <none>
[13:34:38.148] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.148] Resolved: FALSE
[13:34:38.148] Value: <not collected>
[13:34:38.148] Conditions captured: <none>
[13:34:38.148] Early signaling: FALSE
[13:34:38.148] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.148] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.159] Chunk #1 of 2 ... DONE
[13:34:38.160] Chunk #2 of 2 ...
[13:34:38.160]  - Finding globals in '...' for chunk #2 ...
[13:34:38.160] getGlobalsAndPackages() ...
[13:34:38.160] Searching for globals...
[13:34:38.160] 
[13:34:38.160] Searching for globals ... DONE
[13:34:38.160] - globals: [0] <none>
[13:34:38.160] getGlobalsAndPackages() ... DONE
[13:34:38.161]    + additional globals found: [n=0] 
[13:34:38.161]    + additional namespaces needed: [n=0] 
[13:34:38.161]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:38.161]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.161]  - seeds: <none>
[13:34:38.161]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.161] getGlobalsAndPackages() ...
[13:34:38.161] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.161] Resolving globals: FALSE
[13:34:38.162] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:38.162] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:38.162] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.163] 
[13:34:38.163] getGlobalsAndPackages() ... DONE
[13:34:38.163] run() for ‘Future’ ...
[13:34:38.163] - state: ‘created’
[13:34:38.163] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.177] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.177] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.177]   - Field: ‘node’
[13:34:38.177]   - Field: ‘label’
[13:34:38.177]   - Field: ‘local’
[13:34:38.177]   - Field: ‘owner’
[13:34:38.177]   - Field: ‘envir’
[13:34:38.178]   - Field: ‘workers’
[13:34:38.178]   - Field: ‘packages’
[13:34:38.178]   - Field: ‘gc’
[13:34:38.178]   - Field: ‘conditions’
[13:34:38.178]   - Field: ‘persistent’
[13:34:38.178]   - Field: ‘expr’
[13:34:38.178]   - Field: ‘uuid’
[13:34:38.178]   - Field: ‘seed’
[13:34:38.178]   - Field: ‘version’
[13:34:38.178]   - Field: ‘result’
[13:34:38.179]   - Field: ‘asynchronous’
[13:34:38.179]   - Field: ‘calls’
[13:34:38.179]   - Field: ‘globals’
[13:34:38.179]   - Field: ‘stdout’
[13:34:38.179]   - Field: ‘earlySignal’
[13:34:38.179]   - Field: ‘lazy’
[13:34:38.179]   - Field: ‘state’
[13:34:38.179] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.179] - Launch lazy future ...
[13:34:38.180] Packages needed by the future expression (n = 0): <none>
[13:34:38.180] Packages needed by future strategies (n = 0): <none>
[13:34:38.180] {
[13:34:38.180]     {
[13:34:38.180]         {
[13:34:38.180]             ...future.startTime <- base::Sys.time()
[13:34:38.180]             {
[13:34:38.180]                 {
[13:34:38.180]                   {
[13:34:38.180]                     {
[13:34:38.180]                       base::local({
[13:34:38.180]                         has_future <- base::requireNamespace("future", 
[13:34:38.180]                           quietly = TRUE)
[13:34:38.180]                         if (has_future) {
[13:34:38.180]                           ns <- base::getNamespace("future")
[13:34:38.180]                           version <- ns[[".package"]][["version"]]
[13:34:38.180]                           if (is.null(version)) 
[13:34:38.180]                             version <- utils::packageVersion("future")
[13:34:38.180]                         }
[13:34:38.180]                         else {
[13:34:38.180]                           version <- NULL
[13:34:38.180]                         }
[13:34:38.180]                         if (!has_future || version < "1.8.0") {
[13:34:38.180]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.180]                             "", base::R.version$version.string), 
[13:34:38.180]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.180]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.180]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.180]                               "release", "version")], collapse = " "), 
[13:34:38.180]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.180]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.180]                             info)
[13:34:38.180]                           info <- base::paste(info, collapse = "; ")
[13:34:38.180]                           if (!has_future) {
[13:34:38.180]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.180]                               info)
[13:34:38.180]                           }
[13:34:38.180]                           else {
[13:34:38.180]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.180]                               info, version)
[13:34:38.180]                           }
[13:34:38.180]                           base::stop(msg)
[13:34:38.180]                         }
[13:34:38.180]                       })
[13:34:38.180]                     }
[13:34:38.180]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.180]                     base::options(mc.cores = 1L)
[13:34:38.180]                   }
[13:34:38.180]                   ...future.strategy.old <- future::plan("list")
[13:34:38.180]                   options(future.plan = NULL)
[13:34:38.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.180]                 }
[13:34:38.180]                 ...future.workdir <- getwd()
[13:34:38.180]             }
[13:34:38.180]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.180]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.180]         }
[13:34:38.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.180]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.180]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.180]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.180]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.180]             base::names(...future.oldOptions))
[13:34:38.180]     }
[13:34:38.180]     if (FALSE) {
[13:34:38.180]     }
[13:34:38.180]     else {
[13:34:38.180]         if (TRUE) {
[13:34:38.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.180]                 open = "w")
[13:34:38.180]         }
[13:34:38.180]         else {
[13:34:38.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.180]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.180]         }
[13:34:38.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.180]             base::sink(type = "output", split = FALSE)
[13:34:38.180]             base::close(...future.stdout)
[13:34:38.180]         }, add = TRUE)
[13:34:38.180]     }
[13:34:38.180]     ...future.frame <- base::sys.nframe()
[13:34:38.180]     ...future.conditions <- base::list()
[13:34:38.180]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.180]     if (FALSE) {
[13:34:38.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.180]     }
[13:34:38.180]     ...future.result <- base::tryCatch({
[13:34:38.180]         base::withCallingHandlers({
[13:34:38.180]             ...future.value <- base::withVisible(base::local({
[13:34:38.180]                 ...future.makeSendCondition <- base::local({
[13:34:38.180]                   sendCondition <- NULL
[13:34:38.180]                   function(frame = 1L) {
[13:34:38.180]                     if (is.function(sendCondition)) 
[13:34:38.180]                       return(sendCondition)
[13:34:38.180]                     ns <- getNamespace("parallel")
[13:34:38.180]                     if (exists("sendData", mode = "function", 
[13:34:38.180]                       envir = ns)) {
[13:34:38.180]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.180]                         envir = ns)
[13:34:38.180]                       envir <- sys.frame(frame)
[13:34:38.180]                       master <- NULL
[13:34:38.180]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.180]                         !identical(envir, emptyenv())) {
[13:34:38.180]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.180]                           inherits = FALSE)) {
[13:34:38.180]                           master <- get("master", mode = "list", 
[13:34:38.180]                             envir = envir, inherits = FALSE)
[13:34:38.180]                           if (inherits(master, c("SOCKnode", 
[13:34:38.180]                             "SOCK0node"))) {
[13:34:38.180]                             sendCondition <<- function(cond) {
[13:34:38.180]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.180]                                 success = TRUE)
[13:34:38.180]                               parallel_sendData(master, data)
[13:34:38.180]                             }
[13:34:38.180]                             return(sendCondition)
[13:34:38.180]                           }
[13:34:38.180]                         }
[13:34:38.180]                         frame <- frame + 1L
[13:34:38.180]                         envir <- sys.frame(frame)
[13:34:38.180]                       }
[13:34:38.180]                     }
[13:34:38.180]                     sendCondition <<- function(cond) NULL
[13:34:38.180]                   }
[13:34:38.180]                 })
[13:34:38.180]                 withCallingHandlers({
[13:34:38.180]                   {
[13:34:38.180]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.180]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.180]                       ...future.globals.maxSize)) {
[13:34:38.180]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.180]                       on.exit(options(oopts), add = TRUE)
[13:34:38.180]                     }
[13:34:38.180]                     {
[13:34:38.180]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.180]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.180]                         USE.NAMES = FALSE)
[13:34:38.180]                       do.call(mapply, args = args)
[13:34:38.180]                     }
[13:34:38.180]                   }
[13:34:38.180]                 }, immediateCondition = function(cond) {
[13:34:38.180]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.180]                   sendCondition(cond)
[13:34:38.180]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.180]                   {
[13:34:38.180]                     inherits <- base::inherits
[13:34:38.180]                     invokeRestart <- base::invokeRestart
[13:34:38.180]                     is.null <- base::is.null
[13:34:38.180]                     muffled <- FALSE
[13:34:38.180]                     if (inherits(cond, "message")) {
[13:34:38.180]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.180]                       if (muffled) 
[13:34:38.180]                         invokeRestart("muffleMessage")
[13:34:38.180]                     }
[13:34:38.180]                     else if (inherits(cond, "warning")) {
[13:34:38.180]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.180]                       if (muffled) 
[13:34:38.180]                         invokeRestart("muffleWarning")
[13:34:38.180]                     }
[13:34:38.180]                     else if (inherits(cond, "condition")) {
[13:34:38.180]                       if (!is.null(pattern)) {
[13:34:38.180]                         computeRestarts <- base::computeRestarts
[13:34:38.180]                         grepl <- base::grepl
[13:34:38.180]                         restarts <- computeRestarts(cond)
[13:34:38.180]                         for (restart in restarts) {
[13:34:38.180]                           name <- restart$name
[13:34:38.180]                           if (is.null(name)) 
[13:34:38.180]                             next
[13:34:38.180]                           if (!grepl(pattern, name)) 
[13:34:38.180]                             next
[13:34:38.180]                           invokeRestart(restart)
[13:34:38.180]                           muffled <- TRUE
[13:34:38.180]                           break
[13:34:38.180]                         }
[13:34:38.180]                       }
[13:34:38.180]                     }
[13:34:38.180]                     invisible(muffled)
[13:34:38.180]                   }
[13:34:38.180]                   muffleCondition(cond)
[13:34:38.180]                 })
[13:34:38.180]             }))
[13:34:38.180]             future::FutureResult(value = ...future.value$value, 
[13:34:38.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.180]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.180]                     ...future.globalenv.names))
[13:34:38.180]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.180]         }, condition = base::local({
[13:34:38.180]             c <- base::c
[13:34:38.180]             inherits <- base::inherits
[13:34:38.180]             invokeRestart <- base::invokeRestart
[13:34:38.180]             length <- base::length
[13:34:38.180]             list <- base::list
[13:34:38.180]             seq.int <- base::seq.int
[13:34:38.180]             signalCondition <- base::signalCondition
[13:34:38.180]             sys.calls <- base::sys.calls
[13:34:38.180]             `[[` <- base::`[[`
[13:34:38.180]             `+` <- base::`+`
[13:34:38.180]             `<<-` <- base::`<<-`
[13:34:38.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.180]                   3L)]
[13:34:38.180]             }
[13:34:38.180]             function(cond) {
[13:34:38.180]                 is_error <- inherits(cond, "error")
[13:34:38.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.180]                   NULL)
[13:34:38.180]                 if (is_error) {
[13:34:38.180]                   sessionInformation <- function() {
[13:34:38.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.180]                       search = base::search(), system = base::Sys.info())
[13:34:38.180]                   }
[13:34:38.180]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.180]                     cond$call), session = sessionInformation(), 
[13:34:38.180]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.180]                   signalCondition(cond)
[13:34:38.180]                 }
[13:34:38.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.180]                 "immediateCondition"))) {
[13:34:38.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.180]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.180]                   if (TRUE && !signal) {
[13:34:38.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.180]                     {
[13:34:38.180]                       inherits <- base::inherits
[13:34:38.180]                       invokeRestart <- base::invokeRestart
[13:34:38.180]                       is.null <- base::is.null
[13:34:38.180]                       muffled <- FALSE
[13:34:38.180]                       if (inherits(cond, "message")) {
[13:34:38.180]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.180]                         if (muffled) 
[13:34:38.180]                           invokeRestart("muffleMessage")
[13:34:38.180]                       }
[13:34:38.180]                       else if (inherits(cond, "warning")) {
[13:34:38.180]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.180]                         if (muffled) 
[13:34:38.180]                           invokeRestart("muffleWarning")
[13:34:38.180]                       }
[13:34:38.180]                       else if (inherits(cond, "condition")) {
[13:34:38.180]                         if (!is.null(pattern)) {
[13:34:38.180]                           computeRestarts <- base::computeRestarts
[13:34:38.180]                           grepl <- base::grepl
[13:34:38.180]                           restarts <- computeRestarts(cond)
[13:34:38.180]                           for (restart in restarts) {
[13:34:38.180]                             name <- restart$name
[13:34:38.180]                             if (is.null(name)) 
[13:34:38.180]                               next
[13:34:38.180]                             if (!grepl(pattern, name)) 
[13:34:38.180]                               next
[13:34:38.180]                             invokeRestart(restart)
[13:34:38.180]                             muffled <- TRUE
[13:34:38.180]                             break
[13:34:38.180]                           }
[13:34:38.180]                         }
[13:34:38.180]                       }
[13:34:38.180]                       invisible(muffled)
[13:34:38.180]                     }
[13:34:38.180]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.180]                   }
[13:34:38.180]                 }
[13:34:38.180]                 else {
[13:34:38.180]                   if (TRUE) {
[13:34:38.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.180]                     {
[13:34:38.180]                       inherits <- base::inherits
[13:34:38.180]                       invokeRestart <- base::invokeRestart
[13:34:38.180]                       is.null <- base::is.null
[13:34:38.180]                       muffled <- FALSE
[13:34:38.180]                       if (inherits(cond, "message")) {
[13:34:38.180]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.180]                         if (muffled) 
[13:34:38.180]                           invokeRestart("muffleMessage")
[13:34:38.180]                       }
[13:34:38.180]                       else if (inherits(cond, "warning")) {
[13:34:38.180]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.180]                         if (muffled) 
[13:34:38.180]                           invokeRestart("muffleWarning")
[13:34:38.180]                       }
[13:34:38.180]                       else if (inherits(cond, "condition")) {
[13:34:38.180]                         if (!is.null(pattern)) {
[13:34:38.180]                           computeRestarts <- base::computeRestarts
[13:34:38.180]                           grepl <- base::grepl
[13:34:38.180]                           restarts <- computeRestarts(cond)
[13:34:38.180]                           for (restart in restarts) {
[13:34:38.180]                             name <- restart$name
[13:34:38.180]                             if (is.null(name)) 
[13:34:38.180]                               next
[13:34:38.180]                             if (!grepl(pattern, name)) 
[13:34:38.180]                               next
[13:34:38.180]                             invokeRestart(restart)
[13:34:38.180]                             muffled <- TRUE
[13:34:38.180]                             break
[13:34:38.180]                           }
[13:34:38.180]                         }
[13:34:38.180]                       }
[13:34:38.180]                       invisible(muffled)
[13:34:38.180]                     }
[13:34:38.180]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.180]                   }
[13:34:38.180]                 }
[13:34:38.180]             }
[13:34:38.180]         }))
[13:34:38.180]     }, error = function(ex) {
[13:34:38.180]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.180]                 ...future.rng), started = ...future.startTime, 
[13:34:38.180]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.180]             version = "1.8"), class = "FutureResult")
[13:34:38.180]     }, finally = {
[13:34:38.180]         if (!identical(...future.workdir, getwd())) 
[13:34:38.180]             setwd(...future.workdir)
[13:34:38.180]         {
[13:34:38.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.180]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.180]             }
[13:34:38.180]             base::options(...future.oldOptions)
[13:34:38.180]             if (.Platform$OS.type == "windows") {
[13:34:38.180]                 old_names <- names(...future.oldEnvVars)
[13:34:38.180]                 envs <- base::Sys.getenv()
[13:34:38.180]                 names <- names(envs)
[13:34:38.180]                 common <- intersect(names, old_names)
[13:34:38.180]                 added <- setdiff(names, old_names)
[13:34:38.180]                 removed <- setdiff(old_names, names)
[13:34:38.180]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.180]                   envs[common]]
[13:34:38.180]                 NAMES <- toupper(changed)
[13:34:38.180]                 args <- list()
[13:34:38.180]                 for (kk in seq_along(NAMES)) {
[13:34:38.180]                   name <- changed[[kk]]
[13:34:38.180]                   NAME <- NAMES[[kk]]
[13:34:38.180]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.180]                     next
[13:34:38.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.180]                 }
[13:34:38.180]                 NAMES <- toupper(added)
[13:34:38.180]                 for (kk in seq_along(NAMES)) {
[13:34:38.180]                   name <- added[[kk]]
[13:34:38.180]                   NAME <- NAMES[[kk]]
[13:34:38.180]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.180]                     next
[13:34:38.180]                   args[[name]] <- ""
[13:34:38.180]                 }
[13:34:38.180]                 NAMES <- toupper(removed)
[13:34:38.180]                 for (kk in seq_along(NAMES)) {
[13:34:38.180]                   name <- removed[[kk]]
[13:34:38.180]                   NAME <- NAMES[[kk]]
[13:34:38.180]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.180]                     next
[13:34:38.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.180]                 }
[13:34:38.180]                 if (length(args) > 0) 
[13:34:38.180]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.180]             }
[13:34:38.180]             else {
[13:34:38.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.180]             }
[13:34:38.180]             {
[13:34:38.180]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.180]                   0L) {
[13:34:38.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.180]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.180]                   base::options(opts)
[13:34:38.180]                 }
[13:34:38.180]                 {
[13:34:38.180]                   {
[13:34:38.180]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.180]                     NULL
[13:34:38.180]                   }
[13:34:38.180]                   options(future.plan = NULL)
[13:34:38.180]                   if (is.na(NA_character_)) 
[13:34:38.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.180]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.180]                     .init = FALSE)
[13:34:38.180]                 }
[13:34:38.180]             }
[13:34:38.180]         }
[13:34:38.180]     })
[13:34:38.180]     if (TRUE) {
[13:34:38.180]         base::sink(type = "output", split = FALSE)
[13:34:38.180]         if (TRUE) {
[13:34:38.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.180]         }
[13:34:38.180]         else {
[13:34:38.180]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.180]         }
[13:34:38.180]         base::close(...future.stdout)
[13:34:38.180]         ...future.stdout <- NULL
[13:34:38.180]     }
[13:34:38.180]     ...future.result$conditions <- ...future.conditions
[13:34:38.180]     ...future.result$finished <- base::Sys.time()
[13:34:38.180]     ...future.result
[13:34:38.180] }
[13:34:38.234] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[13:34:38.234] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[13:34:38.234] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[13:34:38.235] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:38.235] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.235] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[13:34:38.235] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[13:34:38.236] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:38.236] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.236] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:38.236] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.236] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[13:34:38.237] MultisessionFuture started
[13:34:38.237] - Launch lazy future ... done
[13:34:38.237] run() for ‘MultisessionFuture’ ... done
[13:34:38.237] Created future:
[13:34:38.237] MultisessionFuture:
[13:34:38.237] Label: ‘future_mapply-2’
[13:34:38.237] Expression:
[13:34:38.237] {
[13:34:38.237]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.237]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.237]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.237]         on.exit(options(oopts), add = TRUE)
[13:34:38.237]     }
[13:34:38.237]     {
[13:34:38.237]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.237]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.237]         do.call(mapply, args = args)
[13:34:38.237]     }
[13:34:38.237] }
[13:34:38.237] Lazy evaluation: FALSE
[13:34:38.237] Asynchronous evaluation: TRUE
[13:34:38.237] Local evaluation: TRUE
[13:34:38.237] Environment: R_GlobalEnv
[13:34:38.237] Capture standard output: TRUE
[13:34:38.237] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.237] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.237] Packages: <none>
[13:34:38.237] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.237] Resolved: FALSE
[13:34:38.237] Value: <not collected>
[13:34:38.237] Conditions captured: <none>
[13:34:38.237] Early signaling: FALSE
[13:34:38.237] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.237] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.249] Chunk #2 of 2 ... DONE
[13:34:38.249] Launching 2 futures (chunks) ... DONE
[13:34:38.249] Resolving 2 futures (chunks) ...
[13:34:38.249] resolve() on list ...
[13:34:38.249]  recursive: 0
[13:34:38.250]  length: 2
[13:34:38.250] 
[13:34:38.250] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.250] - Validating connection of MultisessionFuture
[13:34:38.250] - received message: FutureResult
[13:34:38.251] - Received FutureResult
[13:34:38.251] - Erased future from FutureRegistry
[13:34:38.251] result() for ClusterFuture ...
[13:34:38.251] - result already collected: FutureResult
[13:34:38.251] result() for ClusterFuture ... done
[13:34:38.251] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.251] Future #1
[13:34:38.251] result() for ClusterFuture ...
[13:34:38.251] - result already collected: FutureResult
[13:34:38.251] result() for ClusterFuture ... done
[13:34:38.252] result() for ClusterFuture ...
[13:34:38.252] - result already collected: FutureResult
[13:34:38.252] result() for ClusterFuture ... done
[13:34:38.252] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:38.252] - nx: 2
[13:34:38.252] - relay: TRUE
[13:34:38.252] - stdout: TRUE
[13:34:38.252] - signal: TRUE
[13:34:38.252] - resignal: FALSE
[13:34:38.252] - force: TRUE
[13:34:38.252] - relayed: [n=2] FALSE, FALSE
[13:34:38.253] - queued futures: [n=2] FALSE, FALSE
[13:34:38.253]  - until=1
[13:34:38.253]  - relaying element #1
[13:34:38.253] result() for ClusterFuture ...
[13:34:38.253] - result already collected: FutureResult
[13:34:38.253] result() for ClusterFuture ... done
[13:34:38.253] result() for ClusterFuture ...
[13:34:38.253] - result already collected: FutureResult
[13:34:38.256] result() for ClusterFuture ... done
[13:34:38.256] result() for ClusterFuture ...
[13:34:38.256] - result already collected: FutureResult
[13:34:38.256] result() for ClusterFuture ... done
[13:34:38.256] result() for ClusterFuture ...
[13:34:38.256] - result already collected: FutureResult
[13:34:38.256] result() for ClusterFuture ... done
[13:34:38.256] - relayed: [n=2] TRUE, FALSE
[13:34:38.257] - queued futures: [n=2] TRUE, FALSE
[13:34:38.257] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:38.257]  length: 1 (resolved future 1)
[13:34:38.319] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.319] - Validating connection of MultisessionFuture
[13:34:38.319] - received message: FutureResult
[13:34:38.320] - Received FutureResult
[13:34:38.320] - Erased future from FutureRegistry
[13:34:38.320] result() for ClusterFuture ...
[13:34:38.320] - result already collected: FutureResult
[13:34:38.320] result() for ClusterFuture ... done
[13:34:38.320] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.320] Future #2
[13:34:38.320] result() for ClusterFuture ...
[13:34:38.320] - result already collected: FutureResult
[13:34:38.320] result() for ClusterFuture ... done
[13:34:38.320] result() for ClusterFuture ...
[13:34:38.320] - result already collected: FutureResult
[13:34:38.321] result() for ClusterFuture ... done
[13:34:38.321] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:38.321] - nx: 2
[13:34:38.321] - relay: TRUE
[13:34:38.321] - stdout: TRUE
[13:34:38.321] - signal: TRUE
[13:34:38.321] - resignal: FALSE
[13:34:38.321] - force: TRUE
[13:34:38.321] - relayed: [n=2] TRUE, FALSE
[13:34:38.321] - queued futures: [n=2] TRUE, FALSE
[13:34:38.321]  - until=2
[13:34:38.321]  - relaying element #2
[13:34:38.322] result() for ClusterFuture ...
[13:34:38.322] - result already collected: FutureResult
[13:34:38.322] result() for ClusterFuture ... done
[13:34:38.322] result() for ClusterFuture ...
[13:34:38.322] - result already collected: FutureResult
[13:34:38.322] result() for ClusterFuture ... done
[13:34:38.322] result() for ClusterFuture ...
[13:34:38.322] - result already collected: FutureResult
[13:34:38.322] result() for ClusterFuture ... done
[13:34:38.322] result() for ClusterFuture ...
[13:34:38.323] - result already collected: FutureResult
[13:34:38.323] result() for ClusterFuture ... done
[13:34:38.323] - relayed: [n=2] TRUE, TRUE
[13:34:38.323] - queued futures: [n=2] TRUE, TRUE
[13:34:38.323] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:38.323]  length: 0 (resolved future 2)
[13:34:38.323] Relaying remaining futures
[13:34:38.323] signalConditionsASAP(NULL, pos=0) ...
[13:34:38.323] - nx: 2
[13:34:38.323] - relay: TRUE
[13:34:38.323] - stdout: TRUE
[13:34:38.323] - signal: TRUE
[13:34:38.323] - resignal: FALSE
[13:34:38.324] - force: TRUE
[13:34:38.324] - relayed: [n=2] TRUE, TRUE
[13:34:38.324] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:38.324] - relayed: [n=2] TRUE, TRUE
[13:34:38.324] - queued futures: [n=2] TRUE, TRUE
[13:34:38.324] signalConditionsASAP(NULL, pos=0) ... done
[13:34:38.324] resolve() on list ... DONE
[13:34:38.324] result() for ClusterFuture ...
[13:34:38.324] - result already collected: FutureResult
[13:34:38.324] result() for ClusterFuture ... done
[13:34:38.324] result() for ClusterFuture ...
[13:34:38.325] - result already collected: FutureResult
[13:34:38.325] result() for ClusterFuture ... done
[13:34:38.325] result() for ClusterFuture ...
[13:34:38.325] - result already collected: FutureResult
[13:34:38.325] result() for ClusterFuture ... done
[13:34:38.325] result() for ClusterFuture ...
[13:34:38.325] - result already collected: FutureResult
[13:34:38.325] result() for ClusterFuture ... done
[13:34:38.325]  - Number of value chunks collected: 2
[13:34:38.325] Resolving 2 futures (chunks) ... DONE
[13:34:38.325] Reducing values from 2 chunks ...
[13:34:38.325]  - Number of values collected after concatenation: 4
[13:34:38.326]  - Number of values expected: 4
[13:34:38.326] Reducing values from 2 chunks ... DONE
[13:34:38.326] future_mapply() ... DONE
[13:34:38.326] future_mapply() ...
[13:34:38.330] Number of chunks: 2
[13:34:38.330] getGlobalsAndPackagesXApply() ...
[13:34:38.330]  - future.globals: TRUE
[13:34:38.330] getGlobalsAndPackages() ...
[13:34:38.330] Searching for globals...
[13:34:38.331] - globals found: [1] ‘FUN’
[13:34:38.331] Searching for globals ... DONE
[13:34:38.331] Resolving globals: FALSE
[13:34:38.331] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:38.332] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:38.332] - globals: [1] ‘FUN’
[13:34:38.332] 
[13:34:38.332] getGlobalsAndPackages() ... DONE
[13:34:38.332]  - globals found/used: [n=1] ‘FUN’
[13:34:38.332]  - needed namespaces: [n=0] 
[13:34:38.332] Finding globals ... DONE
[13:34:38.332] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:38.332] List of 2
[13:34:38.332]  $ ...future.FUN:function (x, ...)  
[13:34:38.332]  $ MoreArgs     : NULL
[13:34:38.332]  - attr(*, "where")=List of 2
[13:34:38.332]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:38.332]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:38.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:38.332]  - attr(*, "resolved")= logi FALSE
[13:34:38.332]  - attr(*, "total_size")= num NA
[13:34:38.335] Packages to be attached in all futures: [n=0] 
[13:34:38.335] getGlobalsAndPackagesXApply() ... DONE
[13:34:38.335] Number of futures (= number of chunks): 2
[13:34:38.335] Launching 2 futures (chunks) ...
[13:34:38.335] Chunk #1 of 2 ...
[13:34:38.336]  - Finding globals in '...' for chunk #1 ...
[13:34:38.336] getGlobalsAndPackages() ...
[13:34:38.336] Searching for globals...
[13:34:38.336] 
[13:34:38.336] Searching for globals ... DONE
[13:34:38.336] - globals: [0] <none>
[13:34:38.336] getGlobalsAndPackages() ... DONE
[13:34:38.336]    + additional globals found: [n=0] 
[13:34:38.336]    + additional namespaces needed: [n=0] 
[13:34:38.337]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:38.337]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.337]  - seeds: <none>
[13:34:38.337]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.337] getGlobalsAndPackages() ...
[13:34:38.337] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.337] Resolving globals: FALSE
[13:34:38.338] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:38.338] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:38.338] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.338] 
[13:34:38.338] getGlobalsAndPackages() ... DONE
[13:34:38.339] run() for ‘Future’ ...
[13:34:38.339] - state: ‘created’
[13:34:38.339] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.352] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.352] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.352]   - Field: ‘node’
[13:34:38.353]   - Field: ‘label’
[13:34:38.353]   - Field: ‘local’
[13:34:38.353]   - Field: ‘owner’
[13:34:38.353]   - Field: ‘envir’
[13:34:38.353]   - Field: ‘workers’
[13:34:38.353]   - Field: ‘packages’
[13:34:38.353]   - Field: ‘gc’
[13:34:38.353]   - Field: ‘conditions’
[13:34:38.353]   - Field: ‘persistent’
[13:34:38.353]   - Field: ‘expr’
[13:34:38.353]   - Field: ‘uuid’
[13:34:38.354]   - Field: ‘seed’
[13:34:38.354]   - Field: ‘version’
[13:34:38.354]   - Field: ‘result’
[13:34:38.354]   - Field: ‘asynchronous’
[13:34:38.354]   - Field: ‘calls’
[13:34:38.354]   - Field: ‘globals’
[13:34:38.354]   - Field: ‘stdout’
[13:34:38.354]   - Field: ‘earlySignal’
[13:34:38.354]   - Field: ‘lazy’
[13:34:38.354]   - Field: ‘state’
[13:34:38.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.355] - Launch lazy future ...
[13:34:38.355] Packages needed by the future expression (n = 0): <none>
[13:34:38.355] Packages needed by future strategies (n = 0): <none>
[13:34:38.355] {
[13:34:38.355]     {
[13:34:38.355]         {
[13:34:38.355]             ...future.startTime <- base::Sys.time()
[13:34:38.355]             {
[13:34:38.355]                 {
[13:34:38.355]                   {
[13:34:38.355]                     {
[13:34:38.355]                       base::local({
[13:34:38.355]                         has_future <- base::requireNamespace("future", 
[13:34:38.355]                           quietly = TRUE)
[13:34:38.355]                         if (has_future) {
[13:34:38.355]                           ns <- base::getNamespace("future")
[13:34:38.355]                           version <- ns[[".package"]][["version"]]
[13:34:38.355]                           if (is.null(version)) 
[13:34:38.355]                             version <- utils::packageVersion("future")
[13:34:38.355]                         }
[13:34:38.355]                         else {
[13:34:38.355]                           version <- NULL
[13:34:38.355]                         }
[13:34:38.355]                         if (!has_future || version < "1.8.0") {
[13:34:38.355]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.355]                             "", base::R.version$version.string), 
[13:34:38.355]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.355]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.355]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.355]                               "release", "version")], collapse = " "), 
[13:34:38.355]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.355]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.355]                             info)
[13:34:38.355]                           info <- base::paste(info, collapse = "; ")
[13:34:38.355]                           if (!has_future) {
[13:34:38.355]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.355]                               info)
[13:34:38.355]                           }
[13:34:38.355]                           else {
[13:34:38.355]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.355]                               info, version)
[13:34:38.355]                           }
[13:34:38.355]                           base::stop(msg)
[13:34:38.355]                         }
[13:34:38.355]                       })
[13:34:38.355]                     }
[13:34:38.355]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.355]                     base::options(mc.cores = 1L)
[13:34:38.355]                   }
[13:34:38.355]                   ...future.strategy.old <- future::plan("list")
[13:34:38.355]                   options(future.plan = NULL)
[13:34:38.355]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.355]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.355]                 }
[13:34:38.355]                 ...future.workdir <- getwd()
[13:34:38.355]             }
[13:34:38.355]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.355]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.355]         }
[13:34:38.355]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.355]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.355]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.355]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.355]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.355]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.355]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.355]             base::names(...future.oldOptions))
[13:34:38.355]     }
[13:34:38.355]     if (FALSE) {
[13:34:38.355]     }
[13:34:38.355]     else {
[13:34:38.355]         if (TRUE) {
[13:34:38.355]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.355]                 open = "w")
[13:34:38.355]         }
[13:34:38.355]         else {
[13:34:38.355]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.355]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.355]         }
[13:34:38.355]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.355]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.355]             base::sink(type = "output", split = FALSE)
[13:34:38.355]             base::close(...future.stdout)
[13:34:38.355]         }, add = TRUE)
[13:34:38.355]     }
[13:34:38.355]     ...future.frame <- base::sys.nframe()
[13:34:38.355]     ...future.conditions <- base::list()
[13:34:38.355]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.355]     if (FALSE) {
[13:34:38.355]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.355]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.355]     }
[13:34:38.355]     ...future.result <- base::tryCatch({
[13:34:38.355]         base::withCallingHandlers({
[13:34:38.355]             ...future.value <- base::withVisible(base::local({
[13:34:38.355]                 ...future.makeSendCondition <- base::local({
[13:34:38.355]                   sendCondition <- NULL
[13:34:38.355]                   function(frame = 1L) {
[13:34:38.355]                     if (is.function(sendCondition)) 
[13:34:38.355]                       return(sendCondition)
[13:34:38.355]                     ns <- getNamespace("parallel")
[13:34:38.355]                     if (exists("sendData", mode = "function", 
[13:34:38.355]                       envir = ns)) {
[13:34:38.355]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.355]                         envir = ns)
[13:34:38.355]                       envir <- sys.frame(frame)
[13:34:38.355]                       master <- NULL
[13:34:38.355]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.355]                         !identical(envir, emptyenv())) {
[13:34:38.355]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.355]                           inherits = FALSE)) {
[13:34:38.355]                           master <- get("master", mode = "list", 
[13:34:38.355]                             envir = envir, inherits = FALSE)
[13:34:38.355]                           if (inherits(master, c("SOCKnode", 
[13:34:38.355]                             "SOCK0node"))) {
[13:34:38.355]                             sendCondition <<- function(cond) {
[13:34:38.355]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.355]                                 success = TRUE)
[13:34:38.355]                               parallel_sendData(master, data)
[13:34:38.355]                             }
[13:34:38.355]                             return(sendCondition)
[13:34:38.355]                           }
[13:34:38.355]                         }
[13:34:38.355]                         frame <- frame + 1L
[13:34:38.355]                         envir <- sys.frame(frame)
[13:34:38.355]                       }
[13:34:38.355]                     }
[13:34:38.355]                     sendCondition <<- function(cond) NULL
[13:34:38.355]                   }
[13:34:38.355]                 })
[13:34:38.355]                 withCallingHandlers({
[13:34:38.355]                   {
[13:34:38.355]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.355]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.355]                       ...future.globals.maxSize)) {
[13:34:38.355]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.355]                       on.exit(options(oopts), add = TRUE)
[13:34:38.355]                     }
[13:34:38.355]                     {
[13:34:38.355]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.355]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.355]                         USE.NAMES = FALSE)
[13:34:38.355]                       do.call(mapply, args = args)
[13:34:38.355]                     }
[13:34:38.355]                   }
[13:34:38.355]                 }, immediateCondition = function(cond) {
[13:34:38.355]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.355]                   sendCondition(cond)
[13:34:38.355]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.355]                   {
[13:34:38.355]                     inherits <- base::inherits
[13:34:38.355]                     invokeRestart <- base::invokeRestart
[13:34:38.355]                     is.null <- base::is.null
[13:34:38.355]                     muffled <- FALSE
[13:34:38.355]                     if (inherits(cond, "message")) {
[13:34:38.355]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.355]                       if (muffled) 
[13:34:38.355]                         invokeRestart("muffleMessage")
[13:34:38.355]                     }
[13:34:38.355]                     else if (inherits(cond, "warning")) {
[13:34:38.355]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.355]                       if (muffled) 
[13:34:38.355]                         invokeRestart("muffleWarning")
[13:34:38.355]                     }
[13:34:38.355]                     else if (inherits(cond, "condition")) {
[13:34:38.355]                       if (!is.null(pattern)) {
[13:34:38.355]                         computeRestarts <- base::computeRestarts
[13:34:38.355]                         grepl <- base::grepl
[13:34:38.355]                         restarts <- computeRestarts(cond)
[13:34:38.355]                         for (restart in restarts) {
[13:34:38.355]                           name <- restart$name
[13:34:38.355]                           if (is.null(name)) 
[13:34:38.355]                             next
[13:34:38.355]                           if (!grepl(pattern, name)) 
[13:34:38.355]                             next
[13:34:38.355]                           invokeRestart(restart)
[13:34:38.355]                           muffled <- TRUE
[13:34:38.355]                           break
[13:34:38.355]                         }
[13:34:38.355]                       }
[13:34:38.355]                     }
[13:34:38.355]                     invisible(muffled)
[13:34:38.355]                   }
[13:34:38.355]                   muffleCondition(cond)
[13:34:38.355]                 })
[13:34:38.355]             }))
[13:34:38.355]             future::FutureResult(value = ...future.value$value, 
[13:34:38.355]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.355]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.355]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.355]                     ...future.globalenv.names))
[13:34:38.355]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.355]         }, condition = base::local({
[13:34:38.355]             c <- base::c
[13:34:38.355]             inherits <- base::inherits
[13:34:38.355]             invokeRestart <- base::invokeRestart
[13:34:38.355]             length <- base::length
[13:34:38.355]             list <- base::list
[13:34:38.355]             seq.int <- base::seq.int
[13:34:38.355]             signalCondition <- base::signalCondition
[13:34:38.355]             sys.calls <- base::sys.calls
[13:34:38.355]             `[[` <- base::`[[`
[13:34:38.355]             `+` <- base::`+`
[13:34:38.355]             `<<-` <- base::`<<-`
[13:34:38.355]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.355]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.355]                   3L)]
[13:34:38.355]             }
[13:34:38.355]             function(cond) {
[13:34:38.355]                 is_error <- inherits(cond, "error")
[13:34:38.355]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.355]                   NULL)
[13:34:38.355]                 if (is_error) {
[13:34:38.355]                   sessionInformation <- function() {
[13:34:38.355]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.355]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.355]                       search = base::search(), system = base::Sys.info())
[13:34:38.355]                   }
[13:34:38.355]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.355]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.355]                     cond$call), session = sessionInformation(), 
[13:34:38.355]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.355]                   signalCondition(cond)
[13:34:38.355]                 }
[13:34:38.355]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.355]                 "immediateCondition"))) {
[13:34:38.355]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.355]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.355]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.355]                   if (TRUE && !signal) {
[13:34:38.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.355]                     {
[13:34:38.355]                       inherits <- base::inherits
[13:34:38.355]                       invokeRestart <- base::invokeRestart
[13:34:38.355]                       is.null <- base::is.null
[13:34:38.355]                       muffled <- FALSE
[13:34:38.355]                       if (inherits(cond, "message")) {
[13:34:38.355]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.355]                         if (muffled) 
[13:34:38.355]                           invokeRestart("muffleMessage")
[13:34:38.355]                       }
[13:34:38.355]                       else if (inherits(cond, "warning")) {
[13:34:38.355]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.355]                         if (muffled) 
[13:34:38.355]                           invokeRestart("muffleWarning")
[13:34:38.355]                       }
[13:34:38.355]                       else if (inherits(cond, "condition")) {
[13:34:38.355]                         if (!is.null(pattern)) {
[13:34:38.355]                           computeRestarts <- base::computeRestarts
[13:34:38.355]                           grepl <- base::grepl
[13:34:38.355]                           restarts <- computeRestarts(cond)
[13:34:38.355]                           for (restart in restarts) {
[13:34:38.355]                             name <- restart$name
[13:34:38.355]                             if (is.null(name)) 
[13:34:38.355]                               next
[13:34:38.355]                             if (!grepl(pattern, name)) 
[13:34:38.355]                               next
[13:34:38.355]                             invokeRestart(restart)
[13:34:38.355]                             muffled <- TRUE
[13:34:38.355]                             break
[13:34:38.355]                           }
[13:34:38.355]                         }
[13:34:38.355]                       }
[13:34:38.355]                       invisible(muffled)
[13:34:38.355]                     }
[13:34:38.355]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.355]                   }
[13:34:38.355]                 }
[13:34:38.355]                 else {
[13:34:38.355]                   if (TRUE) {
[13:34:38.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.355]                     {
[13:34:38.355]                       inherits <- base::inherits
[13:34:38.355]                       invokeRestart <- base::invokeRestart
[13:34:38.355]                       is.null <- base::is.null
[13:34:38.355]                       muffled <- FALSE
[13:34:38.355]                       if (inherits(cond, "message")) {
[13:34:38.355]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.355]                         if (muffled) 
[13:34:38.355]                           invokeRestart("muffleMessage")
[13:34:38.355]                       }
[13:34:38.355]                       else if (inherits(cond, "warning")) {
[13:34:38.355]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.355]                         if (muffled) 
[13:34:38.355]                           invokeRestart("muffleWarning")
[13:34:38.355]                       }
[13:34:38.355]                       else if (inherits(cond, "condition")) {
[13:34:38.355]                         if (!is.null(pattern)) {
[13:34:38.355]                           computeRestarts <- base::computeRestarts
[13:34:38.355]                           grepl <- base::grepl
[13:34:38.355]                           restarts <- computeRestarts(cond)
[13:34:38.355]                           for (restart in restarts) {
[13:34:38.355]                             name <- restart$name
[13:34:38.355]                             if (is.null(name)) 
[13:34:38.355]                               next
[13:34:38.355]                             if (!grepl(pattern, name)) 
[13:34:38.355]                               next
[13:34:38.355]                             invokeRestart(restart)
[13:34:38.355]                             muffled <- TRUE
[13:34:38.355]                             break
[13:34:38.355]                           }
[13:34:38.355]                         }
[13:34:38.355]                       }
[13:34:38.355]                       invisible(muffled)
[13:34:38.355]                     }
[13:34:38.355]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.355]                   }
[13:34:38.355]                 }
[13:34:38.355]             }
[13:34:38.355]         }))
[13:34:38.355]     }, error = function(ex) {
[13:34:38.355]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.355]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.355]                 ...future.rng), started = ...future.startTime, 
[13:34:38.355]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.355]             version = "1.8"), class = "FutureResult")
[13:34:38.355]     }, finally = {
[13:34:38.355]         if (!identical(...future.workdir, getwd())) 
[13:34:38.355]             setwd(...future.workdir)
[13:34:38.355]         {
[13:34:38.355]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.355]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.355]             }
[13:34:38.355]             base::options(...future.oldOptions)
[13:34:38.355]             if (.Platform$OS.type == "windows") {
[13:34:38.355]                 old_names <- names(...future.oldEnvVars)
[13:34:38.355]                 envs <- base::Sys.getenv()
[13:34:38.355]                 names <- names(envs)
[13:34:38.355]                 common <- intersect(names, old_names)
[13:34:38.355]                 added <- setdiff(names, old_names)
[13:34:38.355]                 removed <- setdiff(old_names, names)
[13:34:38.355]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.355]                   envs[common]]
[13:34:38.355]                 NAMES <- toupper(changed)
[13:34:38.355]                 args <- list()
[13:34:38.355]                 for (kk in seq_along(NAMES)) {
[13:34:38.355]                   name <- changed[[kk]]
[13:34:38.355]                   NAME <- NAMES[[kk]]
[13:34:38.355]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.355]                     next
[13:34:38.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.355]                 }
[13:34:38.355]                 NAMES <- toupper(added)
[13:34:38.355]                 for (kk in seq_along(NAMES)) {
[13:34:38.355]                   name <- added[[kk]]
[13:34:38.355]                   NAME <- NAMES[[kk]]
[13:34:38.355]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.355]                     next
[13:34:38.355]                   args[[name]] <- ""
[13:34:38.355]                 }
[13:34:38.355]                 NAMES <- toupper(removed)
[13:34:38.355]                 for (kk in seq_along(NAMES)) {
[13:34:38.355]                   name <- removed[[kk]]
[13:34:38.355]                   NAME <- NAMES[[kk]]
[13:34:38.355]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.355]                     next
[13:34:38.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.355]                 }
[13:34:38.355]                 if (length(args) > 0) 
[13:34:38.355]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.355]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.355]             }
[13:34:38.355]             else {
[13:34:38.355]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.355]             }
[13:34:38.355]             {
[13:34:38.355]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.355]                   0L) {
[13:34:38.355]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.355]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.355]                   base::options(opts)
[13:34:38.355]                 }
[13:34:38.355]                 {
[13:34:38.355]                   {
[13:34:38.355]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.355]                     NULL
[13:34:38.355]                   }
[13:34:38.355]                   options(future.plan = NULL)
[13:34:38.355]                   if (is.na(NA_character_)) 
[13:34:38.355]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.355]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.355]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.355]                     .init = FALSE)
[13:34:38.355]                 }
[13:34:38.355]             }
[13:34:38.355]         }
[13:34:38.355]     })
[13:34:38.355]     if (TRUE) {
[13:34:38.355]         base::sink(type = "output", split = FALSE)
[13:34:38.355]         if (TRUE) {
[13:34:38.355]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.355]         }
[13:34:38.355]         else {
[13:34:38.355]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.355]         }
[13:34:38.355]         base::close(...future.stdout)
[13:34:38.355]         ...future.stdout <- NULL
[13:34:38.355]     }
[13:34:38.355]     ...future.result$conditions <- ...future.conditions
[13:34:38.355]     ...future.result$finished <- base::Sys.time()
[13:34:38.355]     ...future.result
[13:34:38.355] }
[13:34:38.358] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[13:34:38.358] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[13:34:38.358] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[13:34:38.359] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:38.359] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.359] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[13:34:38.359] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[13:34:38.359] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:38.360] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.360] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:38.360] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.360] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[13:34:38.361] MultisessionFuture started
[13:34:38.361] - Launch lazy future ... done
[13:34:38.361] run() for ‘MultisessionFuture’ ... done
[13:34:38.361] Created future:
[13:34:38.361] MultisessionFuture:
[13:34:38.361] Label: ‘future_mapply-1’
[13:34:38.361] Expression:
[13:34:38.361] {
[13:34:38.361]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.361]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.361]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.361]         on.exit(options(oopts), add = TRUE)
[13:34:38.361]     }
[13:34:38.361]     {
[13:34:38.361]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.361]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.361]         do.call(mapply, args = args)
[13:34:38.361]     }
[13:34:38.361] }
[13:34:38.361] Lazy evaluation: FALSE
[13:34:38.361] Asynchronous evaluation: TRUE
[13:34:38.361] Local evaluation: TRUE
[13:34:38.361] Environment: R_GlobalEnv
[13:34:38.361] Capture standard output: TRUE
[13:34:38.361] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.361] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.361] Packages: <none>
[13:34:38.361] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.361] Resolved: FALSE
[13:34:38.361] Value: <not collected>
[13:34:38.361] Conditions captured: <none>
[13:34:38.361] Early signaling: FALSE
[13:34:38.361] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.361] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.372] Chunk #1 of 2 ... DONE
[13:34:38.372] Chunk #2 of 2 ...
[13:34:38.373]  - Finding globals in '...' for chunk #2 ...
[13:34:38.373] getGlobalsAndPackages() ...
[13:34:38.373] Searching for globals...
[13:34:38.373] 
[13:34:38.373] Searching for globals ... DONE
[13:34:38.374] - globals: [0] <none>
[13:34:38.374] getGlobalsAndPackages() ... DONE
[13:34:38.374]    + additional globals found: [n=0] 
[13:34:38.374]    + additional namespaces needed: [n=0] 
[13:34:38.374]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:38.374]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.374]  - seeds: <none>
[13:34:38.374]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.374] getGlobalsAndPackages() ...
[13:34:38.374] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.374] Resolving globals: FALSE
[13:34:38.375] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:38.375] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:38.375] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.376] 
[13:34:38.376] getGlobalsAndPackages() ... DONE
[13:34:38.376] run() for ‘Future’ ...
[13:34:38.376] - state: ‘created’
[13:34:38.376] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.389] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.390]   - Field: ‘node’
[13:34:38.390]   - Field: ‘label’
[13:34:38.390]   - Field: ‘local’
[13:34:38.390]   - Field: ‘owner’
[13:34:38.390]   - Field: ‘envir’
[13:34:38.390]   - Field: ‘workers’
[13:34:38.390]   - Field: ‘packages’
[13:34:38.390]   - Field: ‘gc’
[13:34:38.390]   - Field: ‘conditions’
[13:34:38.390]   - Field: ‘persistent’
[13:34:38.390]   - Field: ‘expr’
[13:34:38.391]   - Field: ‘uuid’
[13:34:38.391]   - Field: ‘seed’
[13:34:38.391]   - Field: ‘version’
[13:34:38.391]   - Field: ‘result’
[13:34:38.391]   - Field: ‘asynchronous’
[13:34:38.391]   - Field: ‘calls’
[13:34:38.391]   - Field: ‘globals’
[13:34:38.391]   - Field: ‘stdout’
[13:34:38.391]   - Field: ‘earlySignal’
[13:34:38.391]   - Field: ‘lazy’
[13:34:38.391]   - Field: ‘state’
[13:34:38.391] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.392] - Launch lazy future ...
[13:34:38.392] Packages needed by the future expression (n = 0): <none>
[13:34:38.392] Packages needed by future strategies (n = 0): <none>
[13:34:38.392] {
[13:34:38.392]     {
[13:34:38.392]         {
[13:34:38.392]             ...future.startTime <- base::Sys.time()
[13:34:38.392]             {
[13:34:38.392]                 {
[13:34:38.392]                   {
[13:34:38.392]                     {
[13:34:38.392]                       base::local({
[13:34:38.392]                         has_future <- base::requireNamespace("future", 
[13:34:38.392]                           quietly = TRUE)
[13:34:38.392]                         if (has_future) {
[13:34:38.392]                           ns <- base::getNamespace("future")
[13:34:38.392]                           version <- ns[[".package"]][["version"]]
[13:34:38.392]                           if (is.null(version)) 
[13:34:38.392]                             version <- utils::packageVersion("future")
[13:34:38.392]                         }
[13:34:38.392]                         else {
[13:34:38.392]                           version <- NULL
[13:34:38.392]                         }
[13:34:38.392]                         if (!has_future || version < "1.8.0") {
[13:34:38.392]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.392]                             "", base::R.version$version.string), 
[13:34:38.392]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.392]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.392]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.392]                               "release", "version")], collapse = " "), 
[13:34:38.392]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.392]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.392]                             info)
[13:34:38.392]                           info <- base::paste(info, collapse = "; ")
[13:34:38.392]                           if (!has_future) {
[13:34:38.392]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.392]                               info)
[13:34:38.392]                           }
[13:34:38.392]                           else {
[13:34:38.392]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.392]                               info, version)
[13:34:38.392]                           }
[13:34:38.392]                           base::stop(msg)
[13:34:38.392]                         }
[13:34:38.392]                       })
[13:34:38.392]                     }
[13:34:38.392]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.392]                     base::options(mc.cores = 1L)
[13:34:38.392]                   }
[13:34:38.392]                   ...future.strategy.old <- future::plan("list")
[13:34:38.392]                   options(future.plan = NULL)
[13:34:38.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.392]                 }
[13:34:38.392]                 ...future.workdir <- getwd()
[13:34:38.392]             }
[13:34:38.392]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.392]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.392]         }
[13:34:38.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.392]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.392]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.392]             base::names(...future.oldOptions))
[13:34:38.392]     }
[13:34:38.392]     if (FALSE) {
[13:34:38.392]     }
[13:34:38.392]     else {
[13:34:38.392]         if (TRUE) {
[13:34:38.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.392]                 open = "w")
[13:34:38.392]         }
[13:34:38.392]         else {
[13:34:38.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.392]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.392]         }
[13:34:38.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.392]             base::sink(type = "output", split = FALSE)
[13:34:38.392]             base::close(...future.stdout)
[13:34:38.392]         }, add = TRUE)
[13:34:38.392]     }
[13:34:38.392]     ...future.frame <- base::sys.nframe()
[13:34:38.392]     ...future.conditions <- base::list()
[13:34:38.392]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.392]     if (FALSE) {
[13:34:38.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.392]     }
[13:34:38.392]     ...future.result <- base::tryCatch({
[13:34:38.392]         base::withCallingHandlers({
[13:34:38.392]             ...future.value <- base::withVisible(base::local({
[13:34:38.392]                 ...future.makeSendCondition <- base::local({
[13:34:38.392]                   sendCondition <- NULL
[13:34:38.392]                   function(frame = 1L) {
[13:34:38.392]                     if (is.function(sendCondition)) 
[13:34:38.392]                       return(sendCondition)
[13:34:38.392]                     ns <- getNamespace("parallel")
[13:34:38.392]                     if (exists("sendData", mode = "function", 
[13:34:38.392]                       envir = ns)) {
[13:34:38.392]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.392]                         envir = ns)
[13:34:38.392]                       envir <- sys.frame(frame)
[13:34:38.392]                       master <- NULL
[13:34:38.392]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.392]                         !identical(envir, emptyenv())) {
[13:34:38.392]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.392]                           inherits = FALSE)) {
[13:34:38.392]                           master <- get("master", mode = "list", 
[13:34:38.392]                             envir = envir, inherits = FALSE)
[13:34:38.392]                           if (inherits(master, c("SOCKnode", 
[13:34:38.392]                             "SOCK0node"))) {
[13:34:38.392]                             sendCondition <<- function(cond) {
[13:34:38.392]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.392]                                 success = TRUE)
[13:34:38.392]                               parallel_sendData(master, data)
[13:34:38.392]                             }
[13:34:38.392]                             return(sendCondition)
[13:34:38.392]                           }
[13:34:38.392]                         }
[13:34:38.392]                         frame <- frame + 1L
[13:34:38.392]                         envir <- sys.frame(frame)
[13:34:38.392]                       }
[13:34:38.392]                     }
[13:34:38.392]                     sendCondition <<- function(cond) NULL
[13:34:38.392]                   }
[13:34:38.392]                 })
[13:34:38.392]                 withCallingHandlers({
[13:34:38.392]                   {
[13:34:38.392]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.392]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.392]                       ...future.globals.maxSize)) {
[13:34:38.392]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.392]                       on.exit(options(oopts), add = TRUE)
[13:34:38.392]                     }
[13:34:38.392]                     {
[13:34:38.392]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.392]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.392]                         USE.NAMES = FALSE)
[13:34:38.392]                       do.call(mapply, args = args)
[13:34:38.392]                     }
[13:34:38.392]                   }
[13:34:38.392]                 }, immediateCondition = function(cond) {
[13:34:38.392]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.392]                   sendCondition(cond)
[13:34:38.392]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.392]                   {
[13:34:38.392]                     inherits <- base::inherits
[13:34:38.392]                     invokeRestart <- base::invokeRestart
[13:34:38.392]                     is.null <- base::is.null
[13:34:38.392]                     muffled <- FALSE
[13:34:38.392]                     if (inherits(cond, "message")) {
[13:34:38.392]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.392]                       if (muffled) 
[13:34:38.392]                         invokeRestart("muffleMessage")
[13:34:38.392]                     }
[13:34:38.392]                     else if (inherits(cond, "warning")) {
[13:34:38.392]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.392]                       if (muffled) 
[13:34:38.392]                         invokeRestart("muffleWarning")
[13:34:38.392]                     }
[13:34:38.392]                     else if (inherits(cond, "condition")) {
[13:34:38.392]                       if (!is.null(pattern)) {
[13:34:38.392]                         computeRestarts <- base::computeRestarts
[13:34:38.392]                         grepl <- base::grepl
[13:34:38.392]                         restarts <- computeRestarts(cond)
[13:34:38.392]                         for (restart in restarts) {
[13:34:38.392]                           name <- restart$name
[13:34:38.392]                           if (is.null(name)) 
[13:34:38.392]                             next
[13:34:38.392]                           if (!grepl(pattern, name)) 
[13:34:38.392]                             next
[13:34:38.392]                           invokeRestart(restart)
[13:34:38.392]                           muffled <- TRUE
[13:34:38.392]                           break
[13:34:38.392]                         }
[13:34:38.392]                       }
[13:34:38.392]                     }
[13:34:38.392]                     invisible(muffled)
[13:34:38.392]                   }
[13:34:38.392]                   muffleCondition(cond)
[13:34:38.392]                 })
[13:34:38.392]             }))
[13:34:38.392]             future::FutureResult(value = ...future.value$value, 
[13:34:38.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.392]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.392]                     ...future.globalenv.names))
[13:34:38.392]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.392]         }, condition = base::local({
[13:34:38.392]             c <- base::c
[13:34:38.392]             inherits <- base::inherits
[13:34:38.392]             invokeRestart <- base::invokeRestart
[13:34:38.392]             length <- base::length
[13:34:38.392]             list <- base::list
[13:34:38.392]             seq.int <- base::seq.int
[13:34:38.392]             signalCondition <- base::signalCondition
[13:34:38.392]             sys.calls <- base::sys.calls
[13:34:38.392]             `[[` <- base::`[[`
[13:34:38.392]             `+` <- base::`+`
[13:34:38.392]             `<<-` <- base::`<<-`
[13:34:38.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.392]                   3L)]
[13:34:38.392]             }
[13:34:38.392]             function(cond) {
[13:34:38.392]                 is_error <- inherits(cond, "error")
[13:34:38.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.392]                   NULL)
[13:34:38.392]                 if (is_error) {
[13:34:38.392]                   sessionInformation <- function() {
[13:34:38.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.392]                       search = base::search(), system = base::Sys.info())
[13:34:38.392]                   }
[13:34:38.392]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.392]                     cond$call), session = sessionInformation(), 
[13:34:38.392]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.392]                   signalCondition(cond)
[13:34:38.392]                 }
[13:34:38.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.392]                 "immediateCondition"))) {
[13:34:38.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.392]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.392]                   if (TRUE && !signal) {
[13:34:38.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.392]                     {
[13:34:38.392]                       inherits <- base::inherits
[13:34:38.392]                       invokeRestart <- base::invokeRestart
[13:34:38.392]                       is.null <- base::is.null
[13:34:38.392]                       muffled <- FALSE
[13:34:38.392]                       if (inherits(cond, "message")) {
[13:34:38.392]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.392]                         if (muffled) 
[13:34:38.392]                           invokeRestart("muffleMessage")
[13:34:38.392]                       }
[13:34:38.392]                       else if (inherits(cond, "warning")) {
[13:34:38.392]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.392]                         if (muffled) 
[13:34:38.392]                           invokeRestart("muffleWarning")
[13:34:38.392]                       }
[13:34:38.392]                       else if (inherits(cond, "condition")) {
[13:34:38.392]                         if (!is.null(pattern)) {
[13:34:38.392]                           computeRestarts <- base::computeRestarts
[13:34:38.392]                           grepl <- base::grepl
[13:34:38.392]                           restarts <- computeRestarts(cond)
[13:34:38.392]                           for (restart in restarts) {
[13:34:38.392]                             name <- restart$name
[13:34:38.392]                             if (is.null(name)) 
[13:34:38.392]                               next
[13:34:38.392]                             if (!grepl(pattern, name)) 
[13:34:38.392]                               next
[13:34:38.392]                             invokeRestart(restart)
[13:34:38.392]                             muffled <- TRUE
[13:34:38.392]                             break
[13:34:38.392]                           }
[13:34:38.392]                         }
[13:34:38.392]                       }
[13:34:38.392]                       invisible(muffled)
[13:34:38.392]                     }
[13:34:38.392]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.392]                   }
[13:34:38.392]                 }
[13:34:38.392]                 else {
[13:34:38.392]                   if (TRUE) {
[13:34:38.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.392]                     {
[13:34:38.392]                       inherits <- base::inherits
[13:34:38.392]                       invokeRestart <- base::invokeRestart
[13:34:38.392]                       is.null <- base::is.null
[13:34:38.392]                       muffled <- FALSE
[13:34:38.392]                       if (inherits(cond, "message")) {
[13:34:38.392]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.392]                         if (muffled) 
[13:34:38.392]                           invokeRestart("muffleMessage")
[13:34:38.392]                       }
[13:34:38.392]                       else if (inherits(cond, "warning")) {
[13:34:38.392]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.392]                         if (muffled) 
[13:34:38.392]                           invokeRestart("muffleWarning")
[13:34:38.392]                       }
[13:34:38.392]                       else if (inherits(cond, "condition")) {
[13:34:38.392]                         if (!is.null(pattern)) {
[13:34:38.392]                           computeRestarts <- base::computeRestarts
[13:34:38.392]                           grepl <- base::grepl
[13:34:38.392]                           restarts <- computeRestarts(cond)
[13:34:38.392]                           for (restart in restarts) {
[13:34:38.392]                             name <- restart$name
[13:34:38.392]                             if (is.null(name)) 
[13:34:38.392]                               next
[13:34:38.392]                             if (!grepl(pattern, name)) 
[13:34:38.392]                               next
[13:34:38.392]                             invokeRestart(restart)
[13:34:38.392]                             muffled <- TRUE
[13:34:38.392]                             break
[13:34:38.392]                           }
[13:34:38.392]                         }
[13:34:38.392]                       }
[13:34:38.392]                       invisible(muffled)
[13:34:38.392]                     }
[13:34:38.392]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.392]                   }
[13:34:38.392]                 }
[13:34:38.392]             }
[13:34:38.392]         }))
[13:34:38.392]     }, error = function(ex) {
[13:34:38.392]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.392]                 ...future.rng), started = ...future.startTime, 
[13:34:38.392]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.392]             version = "1.8"), class = "FutureResult")
[13:34:38.392]     }, finally = {
[13:34:38.392]         if (!identical(...future.workdir, getwd())) 
[13:34:38.392]             setwd(...future.workdir)
[13:34:38.392]         {
[13:34:38.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.392]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.392]             }
[13:34:38.392]             base::options(...future.oldOptions)
[13:34:38.392]             if (.Platform$OS.type == "windows") {
[13:34:38.392]                 old_names <- names(...future.oldEnvVars)
[13:34:38.392]                 envs <- base::Sys.getenv()
[13:34:38.392]                 names <- names(envs)
[13:34:38.392]                 common <- intersect(names, old_names)
[13:34:38.392]                 added <- setdiff(names, old_names)
[13:34:38.392]                 removed <- setdiff(old_names, names)
[13:34:38.392]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.392]                   envs[common]]
[13:34:38.392]                 NAMES <- toupper(changed)
[13:34:38.392]                 args <- list()
[13:34:38.392]                 for (kk in seq_along(NAMES)) {
[13:34:38.392]                   name <- changed[[kk]]
[13:34:38.392]                   NAME <- NAMES[[kk]]
[13:34:38.392]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.392]                     next
[13:34:38.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.392]                 }
[13:34:38.392]                 NAMES <- toupper(added)
[13:34:38.392]                 for (kk in seq_along(NAMES)) {
[13:34:38.392]                   name <- added[[kk]]
[13:34:38.392]                   NAME <- NAMES[[kk]]
[13:34:38.392]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.392]                     next
[13:34:38.392]                   args[[name]] <- ""
[13:34:38.392]                 }
[13:34:38.392]                 NAMES <- toupper(removed)
[13:34:38.392]                 for (kk in seq_along(NAMES)) {
[13:34:38.392]                   name <- removed[[kk]]
[13:34:38.392]                   NAME <- NAMES[[kk]]
[13:34:38.392]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.392]                     next
[13:34:38.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.392]                 }
[13:34:38.392]                 if (length(args) > 0) 
[13:34:38.392]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.392]             }
[13:34:38.392]             else {
[13:34:38.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.392]             }
[13:34:38.392]             {
[13:34:38.392]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.392]                   0L) {
[13:34:38.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.392]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.392]                   base::options(opts)
[13:34:38.392]                 }
[13:34:38.392]                 {
[13:34:38.392]                   {
[13:34:38.392]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.392]                     NULL
[13:34:38.392]                   }
[13:34:38.392]                   options(future.plan = NULL)
[13:34:38.392]                   if (is.na(NA_character_)) 
[13:34:38.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.392]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.392]                     .init = FALSE)
[13:34:38.392]                 }
[13:34:38.392]             }
[13:34:38.392]         }
[13:34:38.392]     })
[13:34:38.392]     if (TRUE) {
[13:34:38.392]         base::sink(type = "output", split = FALSE)
[13:34:38.392]         if (TRUE) {
[13:34:38.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.392]         }
[13:34:38.392]         else {
[13:34:38.392]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.392]         }
[13:34:38.392]         base::close(...future.stdout)
[13:34:38.392]         ...future.stdout <- NULL
[13:34:38.392]     }
[13:34:38.392]     ...future.result$conditions <- ...future.conditions
[13:34:38.392]     ...future.result$finished <- base::Sys.time()
[13:34:38.392]     ...future.result
[13:34:38.392] }
[13:34:38.395] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[13:34:38.395] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[13:34:38.395] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[13:34:38.395] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:38.396] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.396] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[13:34:38.396] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[13:34:38.396] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:38.397] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.397] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:38.401] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.401] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[13:34:38.401] MultisessionFuture started
[13:34:38.402] - Launch lazy future ... done
[13:34:38.402] run() for ‘MultisessionFuture’ ... done
[13:34:38.402] Created future:
[13:34:38.402] MultisessionFuture:
[13:34:38.402] Label: ‘future_mapply-2’
[13:34:38.402] Expression:
[13:34:38.402] {
[13:34:38.402]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.402]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.402]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.402]         on.exit(options(oopts), add = TRUE)
[13:34:38.402]     }
[13:34:38.402]     {
[13:34:38.402]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.402]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.402]         do.call(mapply, args = args)
[13:34:38.402]     }
[13:34:38.402] }
[13:34:38.402] Lazy evaluation: FALSE
[13:34:38.402] Asynchronous evaluation: TRUE
[13:34:38.402] Local evaluation: TRUE
[13:34:38.402] Environment: R_GlobalEnv
[13:34:38.402] Capture standard output: TRUE
[13:34:38.402] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.402] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.402] Packages: <none>
[13:34:38.402] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.402] Resolved: FALSE
[13:34:38.402] Value: <not collected>
[13:34:38.402] Conditions captured: <none>
[13:34:38.402] Early signaling: FALSE
[13:34:38.402] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.402] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.413] Chunk #2 of 2 ... DONE
[13:34:38.413] Launching 2 futures (chunks) ... DONE
[13:34:38.413] Resolving 2 futures (chunks) ...
[13:34:38.414] resolve() on list ...
[13:34:38.414]  recursive: 0
[13:34:38.414]  length: 2
[13:34:38.414] 
[13:34:38.414] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.414] - Validating connection of MultisessionFuture
[13:34:38.415] - received message: FutureResult
[13:34:38.415] - Received FutureResult
[13:34:38.415] - Erased future from FutureRegistry
[13:34:38.415] result() for ClusterFuture ...
[13:34:38.415] - result already collected: FutureResult
[13:34:38.415] result() for ClusterFuture ... done
[13:34:38.415] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.415] Future #1
[13:34:38.415] result() for ClusterFuture ...
[13:34:38.415] - result already collected: FutureResult
[13:34:38.415] result() for ClusterFuture ... done
[13:34:38.416] result() for ClusterFuture ...
[13:34:38.416] - result already collected: FutureResult
[13:34:38.416] result() for ClusterFuture ... done
[13:34:38.416] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:38.416] - nx: 2
[13:34:38.416] - relay: TRUE
[13:34:38.416] - stdout: TRUE
[13:34:38.416] - signal: TRUE
[13:34:38.416] - resignal: FALSE
[13:34:38.416] - force: TRUE
[13:34:38.416] - relayed: [n=2] FALSE, FALSE
[13:34:38.416] - queued futures: [n=2] FALSE, FALSE
[13:34:38.417]  - until=1
[13:34:38.417]  - relaying element #1
[13:34:38.417] result() for ClusterFuture ...
[13:34:38.417] - result already collected: FutureResult
[13:34:38.417] result() for ClusterFuture ... done
[13:34:38.417] result() for ClusterFuture ...
[13:34:38.417] - result already collected: FutureResult
[13:34:38.417] result() for ClusterFuture ... done
[13:34:38.417] result() for ClusterFuture ...
[13:34:38.417] - result already collected: FutureResult
[13:34:38.418] result() for ClusterFuture ... done
[13:34:38.418] result() for ClusterFuture ...
[13:34:38.418] - result already collected: FutureResult
[13:34:38.418] result() for ClusterFuture ... done
[13:34:38.418] - relayed: [n=2] TRUE, FALSE
[13:34:38.418] - queued futures: [n=2] TRUE, FALSE
[13:34:38.418] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:38.418]  length: 1 (resolved future 1)
[13:34:38.444] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.444] - Validating connection of MultisessionFuture
[13:34:38.444] - received message: FutureResult
[13:34:38.444] - Received FutureResult
[13:34:38.444] - Erased future from FutureRegistry
[13:34:38.444] result() for ClusterFuture ...
[13:34:38.444] - result already collected: FutureResult
[13:34:38.444] result() for ClusterFuture ... done
[13:34:38.444] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.445] Future #2
[13:34:38.445] result() for ClusterFuture ...
[13:34:38.445] - result already collected: FutureResult
[13:34:38.445] result() for ClusterFuture ... done
[13:34:38.445] result() for ClusterFuture ...
[13:34:38.445] - result already collected: FutureResult
[13:34:38.445] result() for ClusterFuture ... done
[13:34:38.445] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:38.445] - nx: 2
[13:34:38.445] - relay: TRUE
[13:34:38.445] - stdout: TRUE
[13:34:38.445] - signal: TRUE
[13:34:38.446] - resignal: FALSE
[13:34:38.446] - force: TRUE
[13:34:38.446] - relayed: [n=2] TRUE, FALSE
[13:34:38.446] - queued futures: [n=2] TRUE, FALSE
[13:34:38.446]  - until=2
[13:34:38.446]  - relaying element #2
[13:34:38.446] result() for ClusterFuture ...
[13:34:38.446] - result already collected: FutureResult
[13:34:38.446] result() for ClusterFuture ... done
[13:34:38.446] result() for ClusterFuture ...
[13:34:38.446] - result already collected: FutureResult
[13:34:38.446] result() for ClusterFuture ... done
[13:34:38.447] result() for ClusterFuture ...
[13:34:38.447] - result already collected: FutureResult
[13:34:38.447] result() for ClusterFuture ... done
[13:34:38.447] result() for ClusterFuture ...
[13:34:38.447] - result already collected: FutureResult
[13:34:38.447] result() for ClusterFuture ... done
[13:34:38.447] - relayed: [n=2] TRUE, TRUE
[13:34:38.447] - queued futures: [n=2] TRUE, TRUE
[13:34:38.447] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:38.447]  length: 0 (resolved future 2)
[13:34:38.448] Relaying remaining futures
[13:34:38.448] signalConditionsASAP(NULL, pos=0) ...
[13:34:38.448] - nx: 2
[13:34:38.448] - relay: TRUE
[13:34:38.448] - stdout: TRUE
[13:34:38.448] - signal: TRUE
[13:34:38.448] - resignal: FALSE
[13:34:38.448] - force: TRUE
[13:34:38.448] - relayed: [n=2] TRUE, TRUE
[13:34:38.448] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:38.448] - relayed: [n=2] TRUE, TRUE
[13:34:38.449] - queued futures: [n=2] TRUE, TRUE
[13:34:38.449] signalConditionsASAP(NULL, pos=0) ... done
[13:34:38.449] resolve() on list ... DONE
[13:34:38.449] result() for ClusterFuture ...
[13:34:38.449] - result already collected: FutureResult
[13:34:38.449] result() for ClusterFuture ... done
[13:34:38.449] result() for ClusterFuture ...
[13:34:38.449] - result already collected: FutureResult
[13:34:38.449] result() for ClusterFuture ... done
[13:34:38.449] result() for ClusterFuture ...
[13:34:38.449] - result already collected: FutureResult
[13:34:38.449] result() for ClusterFuture ... done
[13:34:38.450] result() for ClusterFuture ...
[13:34:38.450] - result already collected: FutureResult
[13:34:38.450] result() for ClusterFuture ... done
[13:34:38.450]  - Number of value chunks collected: 2
[13:34:38.450] Resolving 2 futures (chunks) ... DONE
[13:34:38.450] Reducing values from 2 chunks ...
[13:34:38.450]  - Number of values collected after concatenation: 4
[13:34:38.450]  - Number of values expected: 4
[13:34:38.450] Reducing values from 2 chunks ... DONE
[13:34:38.450] future_mapply() ... DONE
[13:34:38.451] future_mapply() ...
[13:34:38.454] Number of chunks: 2
[13:34:38.454] getGlobalsAndPackagesXApply() ...
[13:34:38.454]  - future.globals: TRUE
[13:34:38.455] getGlobalsAndPackages() ...
[13:34:38.455] Searching for globals...
[13:34:38.455] - globals found: [1] ‘FUN’
[13:34:38.455] Searching for globals ... DONE
[13:34:38.456] Resolving globals: FALSE
[13:34:38.456] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:38.456] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:38.456] - globals: [1] ‘FUN’
[13:34:38.456] 
[13:34:38.456] getGlobalsAndPackages() ... DONE
[13:34:38.457]  - globals found/used: [n=1] ‘FUN’
[13:34:38.457]  - needed namespaces: [n=0] 
[13:34:38.457] Finding globals ... DONE
[13:34:38.457] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:38.457] List of 2
[13:34:38.457]  $ ...future.FUN:function (x, ...)  
[13:34:38.457]  $ MoreArgs     : NULL
[13:34:38.457]  - attr(*, "where")=List of 2
[13:34:38.457]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:38.457]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:38.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:38.457]  - attr(*, "resolved")= logi FALSE
[13:34:38.457]  - attr(*, "total_size")= num NA
[13:34:38.460] Packages to be attached in all futures: [n=0] 
[13:34:38.460] getGlobalsAndPackagesXApply() ... DONE
[13:34:38.460] Number of futures (= number of chunks): 2
[13:34:38.460] Launching 2 futures (chunks) ...
[13:34:38.460] Chunk #1 of 2 ...
[13:34:38.460]  - Finding globals in '...' for chunk #1 ...
[13:34:38.460] getGlobalsAndPackages() ...
[13:34:38.460] Searching for globals...
[13:34:38.461] 
[13:34:38.461] Searching for globals ... DONE
[13:34:38.461] - globals: [0] <none>
[13:34:38.461] getGlobalsAndPackages() ... DONE
[13:34:38.461]    + additional globals found: [n=0] 
[13:34:38.461]    + additional namespaces needed: [n=0] 
[13:34:38.461]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:38.461]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.461]  - seeds: <none>
[13:34:38.462]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.462] getGlobalsAndPackages() ...
[13:34:38.462] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.462] Resolving globals: FALSE
[13:34:38.462] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:38.463] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:38.463] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.463] 
[13:34:38.463] getGlobalsAndPackages() ... DONE
[13:34:38.463] run() for ‘Future’ ...
[13:34:38.463] - state: ‘created’
[13:34:38.464] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.478] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.478]   - Field: ‘node’
[13:34:38.478]   - Field: ‘label’
[13:34:38.479]   - Field: ‘local’
[13:34:38.479]   - Field: ‘owner’
[13:34:38.479]   - Field: ‘envir’
[13:34:38.479]   - Field: ‘workers’
[13:34:38.481]   - Field: ‘packages’
[13:34:38.481]   - Field: ‘gc’
[13:34:38.481]   - Field: ‘conditions’
[13:34:38.481]   - Field: ‘persistent’
[13:34:38.481]   - Field: ‘expr’
[13:34:38.481]   - Field: ‘uuid’
[13:34:38.482]   - Field: ‘seed’
[13:34:38.482]   - Field: ‘version’
[13:34:38.482]   - Field: ‘result’
[13:34:38.482]   - Field: ‘asynchronous’
[13:34:38.482]   - Field: ‘calls’
[13:34:38.482]   - Field: ‘globals’
[13:34:38.482]   - Field: ‘stdout’
[13:34:38.482]   - Field: ‘earlySignal’
[13:34:38.482]   - Field: ‘lazy’
[13:34:38.482]   - Field: ‘state’
[13:34:38.482] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.483] - Launch lazy future ...
[13:34:38.483] Packages needed by the future expression (n = 0): <none>
[13:34:38.483] Packages needed by future strategies (n = 0): <none>
[13:34:38.483] {
[13:34:38.483]     {
[13:34:38.483]         {
[13:34:38.483]             ...future.startTime <- base::Sys.time()
[13:34:38.483]             {
[13:34:38.483]                 {
[13:34:38.483]                   {
[13:34:38.483]                     {
[13:34:38.483]                       base::local({
[13:34:38.483]                         has_future <- base::requireNamespace("future", 
[13:34:38.483]                           quietly = TRUE)
[13:34:38.483]                         if (has_future) {
[13:34:38.483]                           ns <- base::getNamespace("future")
[13:34:38.483]                           version <- ns[[".package"]][["version"]]
[13:34:38.483]                           if (is.null(version)) 
[13:34:38.483]                             version <- utils::packageVersion("future")
[13:34:38.483]                         }
[13:34:38.483]                         else {
[13:34:38.483]                           version <- NULL
[13:34:38.483]                         }
[13:34:38.483]                         if (!has_future || version < "1.8.0") {
[13:34:38.483]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.483]                             "", base::R.version$version.string), 
[13:34:38.483]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.483]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.483]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.483]                               "release", "version")], collapse = " "), 
[13:34:38.483]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.483]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.483]                             info)
[13:34:38.483]                           info <- base::paste(info, collapse = "; ")
[13:34:38.483]                           if (!has_future) {
[13:34:38.483]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.483]                               info)
[13:34:38.483]                           }
[13:34:38.483]                           else {
[13:34:38.483]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.483]                               info, version)
[13:34:38.483]                           }
[13:34:38.483]                           base::stop(msg)
[13:34:38.483]                         }
[13:34:38.483]                       })
[13:34:38.483]                     }
[13:34:38.483]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.483]                     base::options(mc.cores = 1L)
[13:34:38.483]                   }
[13:34:38.483]                   ...future.strategy.old <- future::plan("list")
[13:34:38.483]                   options(future.plan = NULL)
[13:34:38.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.483]                 }
[13:34:38.483]                 ...future.workdir <- getwd()
[13:34:38.483]             }
[13:34:38.483]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.483]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.483]         }
[13:34:38.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.483]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.483]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.483]             base::names(...future.oldOptions))
[13:34:38.483]     }
[13:34:38.483]     if (FALSE) {
[13:34:38.483]     }
[13:34:38.483]     else {
[13:34:38.483]         if (TRUE) {
[13:34:38.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.483]                 open = "w")
[13:34:38.483]         }
[13:34:38.483]         else {
[13:34:38.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.483]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.483]         }
[13:34:38.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.483]             base::sink(type = "output", split = FALSE)
[13:34:38.483]             base::close(...future.stdout)
[13:34:38.483]         }, add = TRUE)
[13:34:38.483]     }
[13:34:38.483]     ...future.frame <- base::sys.nframe()
[13:34:38.483]     ...future.conditions <- base::list()
[13:34:38.483]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.483]     if (FALSE) {
[13:34:38.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.483]     }
[13:34:38.483]     ...future.result <- base::tryCatch({
[13:34:38.483]         base::withCallingHandlers({
[13:34:38.483]             ...future.value <- base::withVisible(base::local({
[13:34:38.483]                 ...future.makeSendCondition <- base::local({
[13:34:38.483]                   sendCondition <- NULL
[13:34:38.483]                   function(frame = 1L) {
[13:34:38.483]                     if (is.function(sendCondition)) 
[13:34:38.483]                       return(sendCondition)
[13:34:38.483]                     ns <- getNamespace("parallel")
[13:34:38.483]                     if (exists("sendData", mode = "function", 
[13:34:38.483]                       envir = ns)) {
[13:34:38.483]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.483]                         envir = ns)
[13:34:38.483]                       envir <- sys.frame(frame)
[13:34:38.483]                       master <- NULL
[13:34:38.483]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.483]                         !identical(envir, emptyenv())) {
[13:34:38.483]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.483]                           inherits = FALSE)) {
[13:34:38.483]                           master <- get("master", mode = "list", 
[13:34:38.483]                             envir = envir, inherits = FALSE)
[13:34:38.483]                           if (inherits(master, c("SOCKnode", 
[13:34:38.483]                             "SOCK0node"))) {
[13:34:38.483]                             sendCondition <<- function(cond) {
[13:34:38.483]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.483]                                 success = TRUE)
[13:34:38.483]                               parallel_sendData(master, data)
[13:34:38.483]                             }
[13:34:38.483]                             return(sendCondition)
[13:34:38.483]                           }
[13:34:38.483]                         }
[13:34:38.483]                         frame <- frame + 1L
[13:34:38.483]                         envir <- sys.frame(frame)
[13:34:38.483]                       }
[13:34:38.483]                     }
[13:34:38.483]                     sendCondition <<- function(cond) NULL
[13:34:38.483]                   }
[13:34:38.483]                 })
[13:34:38.483]                 withCallingHandlers({
[13:34:38.483]                   {
[13:34:38.483]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.483]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.483]                       ...future.globals.maxSize)) {
[13:34:38.483]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.483]                       on.exit(options(oopts), add = TRUE)
[13:34:38.483]                     }
[13:34:38.483]                     {
[13:34:38.483]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.483]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.483]                         USE.NAMES = FALSE)
[13:34:38.483]                       do.call(mapply, args = args)
[13:34:38.483]                     }
[13:34:38.483]                   }
[13:34:38.483]                 }, immediateCondition = function(cond) {
[13:34:38.483]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.483]                   sendCondition(cond)
[13:34:38.483]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.483]                   {
[13:34:38.483]                     inherits <- base::inherits
[13:34:38.483]                     invokeRestart <- base::invokeRestart
[13:34:38.483]                     is.null <- base::is.null
[13:34:38.483]                     muffled <- FALSE
[13:34:38.483]                     if (inherits(cond, "message")) {
[13:34:38.483]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.483]                       if (muffled) 
[13:34:38.483]                         invokeRestart("muffleMessage")
[13:34:38.483]                     }
[13:34:38.483]                     else if (inherits(cond, "warning")) {
[13:34:38.483]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.483]                       if (muffled) 
[13:34:38.483]                         invokeRestart("muffleWarning")
[13:34:38.483]                     }
[13:34:38.483]                     else if (inherits(cond, "condition")) {
[13:34:38.483]                       if (!is.null(pattern)) {
[13:34:38.483]                         computeRestarts <- base::computeRestarts
[13:34:38.483]                         grepl <- base::grepl
[13:34:38.483]                         restarts <- computeRestarts(cond)
[13:34:38.483]                         for (restart in restarts) {
[13:34:38.483]                           name <- restart$name
[13:34:38.483]                           if (is.null(name)) 
[13:34:38.483]                             next
[13:34:38.483]                           if (!grepl(pattern, name)) 
[13:34:38.483]                             next
[13:34:38.483]                           invokeRestart(restart)
[13:34:38.483]                           muffled <- TRUE
[13:34:38.483]                           break
[13:34:38.483]                         }
[13:34:38.483]                       }
[13:34:38.483]                     }
[13:34:38.483]                     invisible(muffled)
[13:34:38.483]                   }
[13:34:38.483]                   muffleCondition(cond)
[13:34:38.483]                 })
[13:34:38.483]             }))
[13:34:38.483]             future::FutureResult(value = ...future.value$value, 
[13:34:38.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.483]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.483]                     ...future.globalenv.names))
[13:34:38.483]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.483]         }, condition = base::local({
[13:34:38.483]             c <- base::c
[13:34:38.483]             inherits <- base::inherits
[13:34:38.483]             invokeRestart <- base::invokeRestart
[13:34:38.483]             length <- base::length
[13:34:38.483]             list <- base::list
[13:34:38.483]             seq.int <- base::seq.int
[13:34:38.483]             signalCondition <- base::signalCondition
[13:34:38.483]             sys.calls <- base::sys.calls
[13:34:38.483]             `[[` <- base::`[[`
[13:34:38.483]             `+` <- base::`+`
[13:34:38.483]             `<<-` <- base::`<<-`
[13:34:38.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.483]                   3L)]
[13:34:38.483]             }
[13:34:38.483]             function(cond) {
[13:34:38.483]                 is_error <- inherits(cond, "error")
[13:34:38.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.483]                   NULL)
[13:34:38.483]                 if (is_error) {
[13:34:38.483]                   sessionInformation <- function() {
[13:34:38.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.483]                       search = base::search(), system = base::Sys.info())
[13:34:38.483]                   }
[13:34:38.483]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.483]                     cond$call), session = sessionInformation(), 
[13:34:38.483]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.483]                   signalCondition(cond)
[13:34:38.483]                 }
[13:34:38.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.483]                 "immediateCondition"))) {
[13:34:38.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.483]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.483]                   if (TRUE && !signal) {
[13:34:38.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.483]                     {
[13:34:38.483]                       inherits <- base::inherits
[13:34:38.483]                       invokeRestart <- base::invokeRestart
[13:34:38.483]                       is.null <- base::is.null
[13:34:38.483]                       muffled <- FALSE
[13:34:38.483]                       if (inherits(cond, "message")) {
[13:34:38.483]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.483]                         if (muffled) 
[13:34:38.483]                           invokeRestart("muffleMessage")
[13:34:38.483]                       }
[13:34:38.483]                       else if (inherits(cond, "warning")) {
[13:34:38.483]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.483]                         if (muffled) 
[13:34:38.483]                           invokeRestart("muffleWarning")
[13:34:38.483]                       }
[13:34:38.483]                       else if (inherits(cond, "condition")) {
[13:34:38.483]                         if (!is.null(pattern)) {
[13:34:38.483]                           computeRestarts <- base::computeRestarts
[13:34:38.483]                           grepl <- base::grepl
[13:34:38.483]                           restarts <- computeRestarts(cond)
[13:34:38.483]                           for (restart in restarts) {
[13:34:38.483]                             name <- restart$name
[13:34:38.483]                             if (is.null(name)) 
[13:34:38.483]                               next
[13:34:38.483]                             if (!grepl(pattern, name)) 
[13:34:38.483]                               next
[13:34:38.483]                             invokeRestart(restart)
[13:34:38.483]                             muffled <- TRUE
[13:34:38.483]                             break
[13:34:38.483]                           }
[13:34:38.483]                         }
[13:34:38.483]                       }
[13:34:38.483]                       invisible(muffled)
[13:34:38.483]                     }
[13:34:38.483]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.483]                   }
[13:34:38.483]                 }
[13:34:38.483]                 else {
[13:34:38.483]                   if (TRUE) {
[13:34:38.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.483]                     {
[13:34:38.483]                       inherits <- base::inherits
[13:34:38.483]                       invokeRestart <- base::invokeRestart
[13:34:38.483]                       is.null <- base::is.null
[13:34:38.483]                       muffled <- FALSE
[13:34:38.483]                       if (inherits(cond, "message")) {
[13:34:38.483]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.483]                         if (muffled) 
[13:34:38.483]                           invokeRestart("muffleMessage")
[13:34:38.483]                       }
[13:34:38.483]                       else if (inherits(cond, "warning")) {
[13:34:38.483]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.483]                         if (muffled) 
[13:34:38.483]                           invokeRestart("muffleWarning")
[13:34:38.483]                       }
[13:34:38.483]                       else if (inherits(cond, "condition")) {
[13:34:38.483]                         if (!is.null(pattern)) {
[13:34:38.483]                           computeRestarts <- base::computeRestarts
[13:34:38.483]                           grepl <- base::grepl
[13:34:38.483]                           restarts <- computeRestarts(cond)
[13:34:38.483]                           for (restart in restarts) {
[13:34:38.483]                             name <- restart$name
[13:34:38.483]                             if (is.null(name)) 
[13:34:38.483]                               next
[13:34:38.483]                             if (!grepl(pattern, name)) 
[13:34:38.483]                               next
[13:34:38.483]                             invokeRestart(restart)
[13:34:38.483]                             muffled <- TRUE
[13:34:38.483]                             break
[13:34:38.483]                           }
[13:34:38.483]                         }
[13:34:38.483]                       }
[13:34:38.483]                       invisible(muffled)
[13:34:38.483]                     }
[13:34:38.483]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.483]                   }
[13:34:38.483]                 }
[13:34:38.483]             }
[13:34:38.483]         }))
[13:34:38.483]     }, error = function(ex) {
[13:34:38.483]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.483]                 ...future.rng), started = ...future.startTime, 
[13:34:38.483]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.483]             version = "1.8"), class = "FutureResult")
[13:34:38.483]     }, finally = {
[13:34:38.483]         if (!identical(...future.workdir, getwd())) 
[13:34:38.483]             setwd(...future.workdir)
[13:34:38.483]         {
[13:34:38.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.483]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.483]             }
[13:34:38.483]             base::options(...future.oldOptions)
[13:34:38.483]             if (.Platform$OS.type == "windows") {
[13:34:38.483]                 old_names <- names(...future.oldEnvVars)
[13:34:38.483]                 envs <- base::Sys.getenv()
[13:34:38.483]                 names <- names(envs)
[13:34:38.483]                 common <- intersect(names, old_names)
[13:34:38.483]                 added <- setdiff(names, old_names)
[13:34:38.483]                 removed <- setdiff(old_names, names)
[13:34:38.483]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.483]                   envs[common]]
[13:34:38.483]                 NAMES <- toupper(changed)
[13:34:38.483]                 args <- list()
[13:34:38.483]                 for (kk in seq_along(NAMES)) {
[13:34:38.483]                   name <- changed[[kk]]
[13:34:38.483]                   NAME <- NAMES[[kk]]
[13:34:38.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.483]                     next
[13:34:38.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.483]                 }
[13:34:38.483]                 NAMES <- toupper(added)
[13:34:38.483]                 for (kk in seq_along(NAMES)) {
[13:34:38.483]                   name <- added[[kk]]
[13:34:38.483]                   NAME <- NAMES[[kk]]
[13:34:38.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.483]                     next
[13:34:38.483]                   args[[name]] <- ""
[13:34:38.483]                 }
[13:34:38.483]                 NAMES <- toupper(removed)
[13:34:38.483]                 for (kk in seq_along(NAMES)) {
[13:34:38.483]                   name <- removed[[kk]]
[13:34:38.483]                   NAME <- NAMES[[kk]]
[13:34:38.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.483]                     next
[13:34:38.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.483]                 }
[13:34:38.483]                 if (length(args) > 0) 
[13:34:38.483]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.483]             }
[13:34:38.483]             else {
[13:34:38.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.483]             }
[13:34:38.483]             {
[13:34:38.483]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.483]                   0L) {
[13:34:38.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.483]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.483]                   base::options(opts)
[13:34:38.483]                 }
[13:34:38.483]                 {
[13:34:38.483]                   {
[13:34:38.483]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.483]                     NULL
[13:34:38.483]                   }
[13:34:38.483]                   options(future.plan = NULL)
[13:34:38.483]                   if (is.na(NA_character_)) 
[13:34:38.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.483]                     .init = FALSE)
[13:34:38.483]                 }
[13:34:38.483]             }
[13:34:38.483]         }
[13:34:38.483]     })
[13:34:38.483]     if (TRUE) {
[13:34:38.483]         base::sink(type = "output", split = FALSE)
[13:34:38.483]         if (TRUE) {
[13:34:38.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.483]         }
[13:34:38.483]         else {
[13:34:38.483]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.483]         }
[13:34:38.483]         base::close(...future.stdout)
[13:34:38.483]         ...future.stdout <- NULL
[13:34:38.483]     }
[13:34:38.483]     ...future.result$conditions <- ...future.conditions
[13:34:38.483]     ...future.result$finished <- base::Sys.time()
[13:34:38.483]     ...future.result
[13:34:38.483] }
[13:34:38.486] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[13:34:38.486] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[13:34:38.486] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[13:34:38.487] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:38.487] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.487] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[13:34:38.487] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[13:34:38.488] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:38.488] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.488] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:38.488] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.488] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[13:34:38.489] MultisessionFuture started
[13:34:38.489] - Launch lazy future ... done
[13:34:38.489] run() for ‘MultisessionFuture’ ... done
[13:34:38.489] Created future:
[13:34:38.489] MultisessionFuture:
[13:34:38.489] Label: ‘future_mapply-1’
[13:34:38.489] Expression:
[13:34:38.489] {
[13:34:38.489]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.489]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.489]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.489]         on.exit(options(oopts), add = TRUE)
[13:34:38.489]     }
[13:34:38.489]     {
[13:34:38.489]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.489]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.489]         do.call(mapply, args = args)
[13:34:38.489]     }
[13:34:38.489] }
[13:34:38.489] Lazy evaluation: FALSE
[13:34:38.489] Asynchronous evaluation: TRUE
[13:34:38.489] Local evaluation: TRUE
[13:34:38.489] Environment: R_GlobalEnv
[13:34:38.489] Capture standard output: TRUE
[13:34:38.489] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.489] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.489] Packages: <none>
[13:34:38.489] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.489] Resolved: FALSE
[13:34:38.489] Value: <not collected>
[13:34:38.489] Conditions captured: <none>
[13:34:38.489] Early signaling: FALSE
[13:34:38.489] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.489] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.501] Chunk #1 of 2 ... DONE
[13:34:38.501] Chunk #2 of 2 ...
[13:34:38.501]  - Finding globals in '...' for chunk #2 ...
[13:34:38.501] getGlobalsAndPackages() ...
[13:34:38.501] Searching for globals...
[13:34:38.501] 
[13:34:38.501] Searching for globals ... DONE
[13:34:38.501] - globals: [0] <none>
[13:34:38.502] getGlobalsAndPackages() ... DONE
[13:34:38.502]    + additional globals found: [n=0] 
[13:34:38.502]    + additional namespaces needed: [n=0] 
[13:34:38.502]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:38.502]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.502]  - seeds: <none>
[13:34:38.502]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.502] getGlobalsAndPackages() ...
[13:34:38.502] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.502] Resolving globals: FALSE
[13:34:38.503] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:38.503] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:38.503] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.504] 
[13:34:38.504] getGlobalsAndPackages() ... DONE
[13:34:38.504] run() for ‘Future’ ...
[13:34:38.504] - state: ‘created’
[13:34:38.504] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.517] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.518]   - Field: ‘node’
[13:34:38.518]   - Field: ‘label’
[13:34:38.518]   - Field: ‘local’
[13:34:38.518]   - Field: ‘owner’
[13:34:38.518]   - Field: ‘envir’
[13:34:38.518]   - Field: ‘workers’
[13:34:38.518]   - Field: ‘packages’
[13:34:38.518]   - Field: ‘gc’
[13:34:38.518]   - Field: ‘conditions’
[13:34:38.518]   - Field: ‘persistent’
[13:34:38.518]   - Field: ‘expr’
[13:34:38.519]   - Field: ‘uuid’
[13:34:38.519]   - Field: ‘seed’
[13:34:38.519]   - Field: ‘version’
[13:34:38.519]   - Field: ‘result’
[13:34:38.519]   - Field: ‘asynchronous’
[13:34:38.519]   - Field: ‘calls’
[13:34:38.519]   - Field: ‘globals’
[13:34:38.519]   - Field: ‘stdout’
[13:34:38.519]   - Field: ‘earlySignal’
[13:34:38.519]   - Field: ‘lazy’
[13:34:38.519]   - Field: ‘state’
[13:34:38.520] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.520] - Launch lazy future ...
[13:34:38.520] Packages needed by the future expression (n = 0): <none>
[13:34:38.520] Packages needed by future strategies (n = 0): <none>
[13:34:38.520] {
[13:34:38.520]     {
[13:34:38.520]         {
[13:34:38.520]             ...future.startTime <- base::Sys.time()
[13:34:38.520]             {
[13:34:38.520]                 {
[13:34:38.520]                   {
[13:34:38.520]                     {
[13:34:38.520]                       base::local({
[13:34:38.520]                         has_future <- base::requireNamespace("future", 
[13:34:38.520]                           quietly = TRUE)
[13:34:38.520]                         if (has_future) {
[13:34:38.520]                           ns <- base::getNamespace("future")
[13:34:38.520]                           version <- ns[[".package"]][["version"]]
[13:34:38.520]                           if (is.null(version)) 
[13:34:38.520]                             version <- utils::packageVersion("future")
[13:34:38.520]                         }
[13:34:38.520]                         else {
[13:34:38.520]                           version <- NULL
[13:34:38.520]                         }
[13:34:38.520]                         if (!has_future || version < "1.8.0") {
[13:34:38.520]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.520]                             "", base::R.version$version.string), 
[13:34:38.520]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.520]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.520]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.520]                               "release", "version")], collapse = " "), 
[13:34:38.520]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.520]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.520]                             info)
[13:34:38.520]                           info <- base::paste(info, collapse = "; ")
[13:34:38.520]                           if (!has_future) {
[13:34:38.520]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.520]                               info)
[13:34:38.520]                           }
[13:34:38.520]                           else {
[13:34:38.520]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.520]                               info, version)
[13:34:38.520]                           }
[13:34:38.520]                           base::stop(msg)
[13:34:38.520]                         }
[13:34:38.520]                       })
[13:34:38.520]                     }
[13:34:38.520]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.520]                     base::options(mc.cores = 1L)
[13:34:38.520]                   }
[13:34:38.520]                   ...future.strategy.old <- future::plan("list")
[13:34:38.520]                   options(future.plan = NULL)
[13:34:38.520]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.520]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.520]                 }
[13:34:38.520]                 ...future.workdir <- getwd()
[13:34:38.520]             }
[13:34:38.520]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.520]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.520]         }
[13:34:38.520]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.520]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.520]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.520]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.520]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.520]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.520]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.520]             base::names(...future.oldOptions))
[13:34:38.520]     }
[13:34:38.520]     if (FALSE) {
[13:34:38.520]     }
[13:34:38.520]     else {
[13:34:38.520]         if (TRUE) {
[13:34:38.520]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.520]                 open = "w")
[13:34:38.520]         }
[13:34:38.520]         else {
[13:34:38.520]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.520]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.520]         }
[13:34:38.520]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.520]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.520]             base::sink(type = "output", split = FALSE)
[13:34:38.520]             base::close(...future.stdout)
[13:34:38.520]         }, add = TRUE)
[13:34:38.520]     }
[13:34:38.520]     ...future.frame <- base::sys.nframe()
[13:34:38.520]     ...future.conditions <- base::list()
[13:34:38.520]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.520]     if (FALSE) {
[13:34:38.520]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.520]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.520]     }
[13:34:38.520]     ...future.result <- base::tryCatch({
[13:34:38.520]         base::withCallingHandlers({
[13:34:38.520]             ...future.value <- base::withVisible(base::local({
[13:34:38.520]                 ...future.makeSendCondition <- base::local({
[13:34:38.520]                   sendCondition <- NULL
[13:34:38.520]                   function(frame = 1L) {
[13:34:38.520]                     if (is.function(sendCondition)) 
[13:34:38.520]                       return(sendCondition)
[13:34:38.520]                     ns <- getNamespace("parallel")
[13:34:38.520]                     if (exists("sendData", mode = "function", 
[13:34:38.520]                       envir = ns)) {
[13:34:38.520]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.520]                         envir = ns)
[13:34:38.520]                       envir <- sys.frame(frame)
[13:34:38.520]                       master <- NULL
[13:34:38.520]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.520]                         !identical(envir, emptyenv())) {
[13:34:38.520]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.520]                           inherits = FALSE)) {
[13:34:38.520]                           master <- get("master", mode = "list", 
[13:34:38.520]                             envir = envir, inherits = FALSE)
[13:34:38.520]                           if (inherits(master, c("SOCKnode", 
[13:34:38.520]                             "SOCK0node"))) {
[13:34:38.520]                             sendCondition <<- function(cond) {
[13:34:38.520]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.520]                                 success = TRUE)
[13:34:38.520]                               parallel_sendData(master, data)
[13:34:38.520]                             }
[13:34:38.520]                             return(sendCondition)
[13:34:38.520]                           }
[13:34:38.520]                         }
[13:34:38.520]                         frame <- frame + 1L
[13:34:38.520]                         envir <- sys.frame(frame)
[13:34:38.520]                       }
[13:34:38.520]                     }
[13:34:38.520]                     sendCondition <<- function(cond) NULL
[13:34:38.520]                   }
[13:34:38.520]                 })
[13:34:38.520]                 withCallingHandlers({
[13:34:38.520]                   {
[13:34:38.520]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.520]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.520]                       ...future.globals.maxSize)) {
[13:34:38.520]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.520]                       on.exit(options(oopts), add = TRUE)
[13:34:38.520]                     }
[13:34:38.520]                     {
[13:34:38.520]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.520]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.520]                         USE.NAMES = FALSE)
[13:34:38.520]                       do.call(mapply, args = args)
[13:34:38.520]                     }
[13:34:38.520]                   }
[13:34:38.520]                 }, immediateCondition = function(cond) {
[13:34:38.520]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.520]                   sendCondition(cond)
[13:34:38.520]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.520]                   {
[13:34:38.520]                     inherits <- base::inherits
[13:34:38.520]                     invokeRestart <- base::invokeRestart
[13:34:38.520]                     is.null <- base::is.null
[13:34:38.520]                     muffled <- FALSE
[13:34:38.520]                     if (inherits(cond, "message")) {
[13:34:38.520]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.520]                       if (muffled) 
[13:34:38.520]                         invokeRestart("muffleMessage")
[13:34:38.520]                     }
[13:34:38.520]                     else if (inherits(cond, "warning")) {
[13:34:38.520]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.520]                       if (muffled) 
[13:34:38.520]                         invokeRestart("muffleWarning")
[13:34:38.520]                     }
[13:34:38.520]                     else if (inherits(cond, "condition")) {
[13:34:38.520]                       if (!is.null(pattern)) {
[13:34:38.520]                         computeRestarts <- base::computeRestarts
[13:34:38.520]                         grepl <- base::grepl
[13:34:38.520]                         restarts <- computeRestarts(cond)
[13:34:38.520]                         for (restart in restarts) {
[13:34:38.520]                           name <- restart$name
[13:34:38.520]                           if (is.null(name)) 
[13:34:38.520]                             next
[13:34:38.520]                           if (!grepl(pattern, name)) 
[13:34:38.520]                             next
[13:34:38.520]                           invokeRestart(restart)
[13:34:38.520]                           muffled <- TRUE
[13:34:38.520]                           break
[13:34:38.520]                         }
[13:34:38.520]                       }
[13:34:38.520]                     }
[13:34:38.520]                     invisible(muffled)
[13:34:38.520]                   }
[13:34:38.520]                   muffleCondition(cond)
[13:34:38.520]                 })
[13:34:38.520]             }))
[13:34:38.520]             future::FutureResult(value = ...future.value$value, 
[13:34:38.520]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.520]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.520]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.520]                     ...future.globalenv.names))
[13:34:38.520]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.520]         }, condition = base::local({
[13:34:38.520]             c <- base::c
[13:34:38.520]             inherits <- base::inherits
[13:34:38.520]             invokeRestart <- base::invokeRestart
[13:34:38.520]             length <- base::length
[13:34:38.520]             list <- base::list
[13:34:38.520]             seq.int <- base::seq.int
[13:34:38.520]             signalCondition <- base::signalCondition
[13:34:38.520]             sys.calls <- base::sys.calls
[13:34:38.520]             `[[` <- base::`[[`
[13:34:38.520]             `+` <- base::`+`
[13:34:38.520]             `<<-` <- base::`<<-`
[13:34:38.520]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.520]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.520]                   3L)]
[13:34:38.520]             }
[13:34:38.520]             function(cond) {
[13:34:38.520]                 is_error <- inherits(cond, "error")
[13:34:38.520]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.520]                   NULL)
[13:34:38.520]                 if (is_error) {
[13:34:38.520]                   sessionInformation <- function() {
[13:34:38.520]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.520]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.520]                       search = base::search(), system = base::Sys.info())
[13:34:38.520]                   }
[13:34:38.520]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.520]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.520]                     cond$call), session = sessionInformation(), 
[13:34:38.520]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.520]                   signalCondition(cond)
[13:34:38.520]                 }
[13:34:38.520]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.520]                 "immediateCondition"))) {
[13:34:38.520]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.520]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.520]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.520]                   if (TRUE && !signal) {
[13:34:38.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.520]                     {
[13:34:38.520]                       inherits <- base::inherits
[13:34:38.520]                       invokeRestart <- base::invokeRestart
[13:34:38.520]                       is.null <- base::is.null
[13:34:38.520]                       muffled <- FALSE
[13:34:38.520]                       if (inherits(cond, "message")) {
[13:34:38.520]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.520]                         if (muffled) 
[13:34:38.520]                           invokeRestart("muffleMessage")
[13:34:38.520]                       }
[13:34:38.520]                       else if (inherits(cond, "warning")) {
[13:34:38.520]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.520]                         if (muffled) 
[13:34:38.520]                           invokeRestart("muffleWarning")
[13:34:38.520]                       }
[13:34:38.520]                       else if (inherits(cond, "condition")) {
[13:34:38.520]                         if (!is.null(pattern)) {
[13:34:38.520]                           computeRestarts <- base::computeRestarts
[13:34:38.520]                           grepl <- base::grepl
[13:34:38.520]                           restarts <- computeRestarts(cond)
[13:34:38.520]                           for (restart in restarts) {
[13:34:38.520]                             name <- restart$name
[13:34:38.520]                             if (is.null(name)) 
[13:34:38.520]                               next
[13:34:38.520]                             if (!grepl(pattern, name)) 
[13:34:38.520]                               next
[13:34:38.520]                             invokeRestart(restart)
[13:34:38.520]                             muffled <- TRUE
[13:34:38.520]                             break
[13:34:38.520]                           }
[13:34:38.520]                         }
[13:34:38.520]                       }
[13:34:38.520]                       invisible(muffled)
[13:34:38.520]                     }
[13:34:38.520]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.520]                   }
[13:34:38.520]                 }
[13:34:38.520]                 else {
[13:34:38.520]                   if (TRUE) {
[13:34:38.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.520]                     {
[13:34:38.520]                       inherits <- base::inherits
[13:34:38.520]                       invokeRestart <- base::invokeRestart
[13:34:38.520]                       is.null <- base::is.null
[13:34:38.520]                       muffled <- FALSE
[13:34:38.520]                       if (inherits(cond, "message")) {
[13:34:38.520]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.520]                         if (muffled) 
[13:34:38.520]                           invokeRestart("muffleMessage")
[13:34:38.520]                       }
[13:34:38.520]                       else if (inherits(cond, "warning")) {
[13:34:38.520]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.520]                         if (muffled) 
[13:34:38.520]                           invokeRestart("muffleWarning")
[13:34:38.520]                       }
[13:34:38.520]                       else if (inherits(cond, "condition")) {
[13:34:38.520]                         if (!is.null(pattern)) {
[13:34:38.520]                           computeRestarts <- base::computeRestarts
[13:34:38.520]                           grepl <- base::grepl
[13:34:38.520]                           restarts <- computeRestarts(cond)
[13:34:38.520]                           for (restart in restarts) {
[13:34:38.520]                             name <- restart$name
[13:34:38.520]                             if (is.null(name)) 
[13:34:38.520]                               next
[13:34:38.520]                             if (!grepl(pattern, name)) 
[13:34:38.520]                               next
[13:34:38.520]                             invokeRestart(restart)
[13:34:38.520]                             muffled <- TRUE
[13:34:38.520]                             break
[13:34:38.520]                           }
[13:34:38.520]                         }
[13:34:38.520]                       }
[13:34:38.520]                       invisible(muffled)
[13:34:38.520]                     }
[13:34:38.520]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.520]                   }
[13:34:38.520]                 }
[13:34:38.520]             }
[13:34:38.520]         }))
[13:34:38.520]     }, error = function(ex) {
[13:34:38.520]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.520]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.520]                 ...future.rng), started = ...future.startTime, 
[13:34:38.520]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.520]             version = "1.8"), class = "FutureResult")
[13:34:38.520]     }, finally = {
[13:34:38.520]         if (!identical(...future.workdir, getwd())) 
[13:34:38.520]             setwd(...future.workdir)
[13:34:38.520]         {
[13:34:38.520]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.520]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.520]             }
[13:34:38.520]             base::options(...future.oldOptions)
[13:34:38.520]             if (.Platform$OS.type == "windows") {
[13:34:38.520]                 old_names <- names(...future.oldEnvVars)
[13:34:38.520]                 envs <- base::Sys.getenv()
[13:34:38.520]                 names <- names(envs)
[13:34:38.520]                 common <- intersect(names, old_names)
[13:34:38.520]                 added <- setdiff(names, old_names)
[13:34:38.520]                 removed <- setdiff(old_names, names)
[13:34:38.520]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.520]                   envs[common]]
[13:34:38.520]                 NAMES <- toupper(changed)
[13:34:38.520]                 args <- list()
[13:34:38.520]                 for (kk in seq_along(NAMES)) {
[13:34:38.520]                   name <- changed[[kk]]
[13:34:38.520]                   NAME <- NAMES[[kk]]
[13:34:38.520]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.520]                     next
[13:34:38.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.520]                 }
[13:34:38.520]                 NAMES <- toupper(added)
[13:34:38.520]                 for (kk in seq_along(NAMES)) {
[13:34:38.520]                   name <- added[[kk]]
[13:34:38.520]                   NAME <- NAMES[[kk]]
[13:34:38.520]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.520]                     next
[13:34:38.520]                   args[[name]] <- ""
[13:34:38.520]                 }
[13:34:38.520]                 NAMES <- toupper(removed)
[13:34:38.520]                 for (kk in seq_along(NAMES)) {
[13:34:38.520]                   name <- removed[[kk]]
[13:34:38.520]                   NAME <- NAMES[[kk]]
[13:34:38.520]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.520]                     next
[13:34:38.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.520]                 }
[13:34:38.520]                 if (length(args) > 0) 
[13:34:38.520]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.520]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.520]             }
[13:34:38.520]             else {
[13:34:38.520]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.520]             }
[13:34:38.520]             {
[13:34:38.520]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.520]                   0L) {
[13:34:38.520]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.520]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.520]                   base::options(opts)
[13:34:38.520]                 }
[13:34:38.520]                 {
[13:34:38.520]                   {
[13:34:38.520]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.520]                     NULL
[13:34:38.520]                   }
[13:34:38.520]                   options(future.plan = NULL)
[13:34:38.520]                   if (is.na(NA_character_)) 
[13:34:38.520]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.520]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.520]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.520]                     .init = FALSE)
[13:34:38.520]                 }
[13:34:38.520]             }
[13:34:38.520]         }
[13:34:38.520]     })
[13:34:38.520]     if (TRUE) {
[13:34:38.520]         base::sink(type = "output", split = FALSE)
[13:34:38.520]         if (TRUE) {
[13:34:38.520]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.520]         }
[13:34:38.520]         else {
[13:34:38.520]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.520]         }
[13:34:38.520]         base::close(...future.stdout)
[13:34:38.520]         ...future.stdout <- NULL
[13:34:38.520]     }
[13:34:38.520]     ...future.result$conditions <- ...future.conditions
[13:34:38.520]     ...future.result$finished <- base::Sys.time()
[13:34:38.520]     ...future.result
[13:34:38.520] }
[13:34:38.523] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[13:34:38.523] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[13:34:38.523] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[13:34:38.523] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:38.524] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.524] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[13:34:38.524] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[13:34:38.524] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:38.525] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.525] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:38.525] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.525] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[13:34:38.526] MultisessionFuture started
[13:34:38.526] - Launch lazy future ... done
[13:34:38.526] run() for ‘MultisessionFuture’ ... done
[13:34:38.526] Created future:
[13:34:38.526] MultisessionFuture:
[13:34:38.526] Label: ‘future_mapply-2’
[13:34:38.526] Expression:
[13:34:38.526] {
[13:34:38.526]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.526]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.526]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.526]         on.exit(options(oopts), add = TRUE)
[13:34:38.526]     }
[13:34:38.526]     {
[13:34:38.526]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.526]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.526]         do.call(mapply, args = args)
[13:34:38.526]     }
[13:34:38.526] }
[13:34:38.526] Lazy evaluation: FALSE
[13:34:38.526] Asynchronous evaluation: TRUE
[13:34:38.526] Local evaluation: TRUE
[13:34:38.526] Environment: R_GlobalEnv
[13:34:38.526] Capture standard output: TRUE
[13:34:38.526] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.526] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.526] Packages: <none>
[13:34:38.526] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.526] Resolved: FALSE
[13:34:38.526] Value: <not collected>
[13:34:38.526] Conditions captured: <none>
[13:34:38.526] Early signaling: FALSE
[13:34:38.526] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.526] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.537] Chunk #2 of 2 ... DONE
[13:34:38.537] Launching 2 futures (chunks) ... DONE
[13:34:38.538] Resolving 2 futures (chunks) ...
[13:34:38.538] resolve() on list ...
[13:34:38.538]  recursive: 0
[13:34:38.538]  length: 2
[13:34:38.538] 
[13:34:38.538] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.539] - Validating connection of MultisessionFuture
[13:34:38.539] - received message: FutureResult
[13:34:38.539] - Received FutureResult
[13:34:38.539] - Erased future from FutureRegistry
[13:34:38.539] result() for ClusterFuture ...
[13:34:38.539] - result already collected: FutureResult
[13:34:38.539] result() for ClusterFuture ... done
[13:34:38.539] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.539] Future #1
[13:34:38.539] result() for ClusterFuture ...
[13:34:38.540] - result already collected: FutureResult
[13:34:38.540] result() for ClusterFuture ... done
[13:34:38.540] result() for ClusterFuture ...
[13:34:38.540] - result already collected: FutureResult
[13:34:38.540] result() for ClusterFuture ... done
[13:34:38.540] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:38.540] - nx: 2
[13:34:38.540] - relay: TRUE
[13:34:38.540] - stdout: TRUE
[13:34:38.540] - signal: TRUE
[13:34:38.540] - resignal: FALSE
[13:34:38.540] - force: TRUE
[13:34:38.541] - relayed: [n=2] FALSE, FALSE
[13:34:38.541] - queued futures: [n=2] FALSE, FALSE
[13:34:38.541]  - until=1
[13:34:38.541]  - relaying element #1
[13:34:38.541] result() for ClusterFuture ...
[13:34:38.541] - result already collected: FutureResult
[13:34:38.541] result() for ClusterFuture ... done
[13:34:38.541] result() for ClusterFuture ...
[13:34:38.541] - result already collected: FutureResult
[13:34:38.541] result() for ClusterFuture ... done
[13:34:38.541] result() for ClusterFuture ...
[13:34:38.541] - result already collected: FutureResult
[13:34:38.542] result() for ClusterFuture ... done
[13:34:38.542] result() for ClusterFuture ...
[13:34:38.542] - result already collected: FutureResult
[13:34:38.542] result() for ClusterFuture ... done
[13:34:38.542] - relayed: [n=2] TRUE, FALSE
[13:34:38.542] - queued futures: [n=2] TRUE, FALSE
[13:34:38.542] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:38.542]  length: 1 (resolved future 1)
[13:34:38.568] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.568] - Validating connection of MultisessionFuture
[13:34:38.568] - received message: FutureResult
[13:34:38.568] - Received FutureResult
[13:34:38.568] - Erased future from FutureRegistry
[13:34:38.568] result() for ClusterFuture ...
[13:34:38.568] - result already collected: FutureResult
[13:34:38.569] result() for ClusterFuture ... done
[13:34:38.569] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.569] Future #2
[13:34:38.569] result() for ClusterFuture ...
[13:34:38.569] - result already collected: FutureResult
[13:34:38.569] result() for ClusterFuture ... done
[13:34:38.569] result() for ClusterFuture ...
[13:34:38.569] - result already collected: FutureResult
[13:34:38.569] result() for ClusterFuture ... done
[13:34:38.569] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:38.569] - nx: 2
[13:34:38.570] - relay: TRUE
[13:34:38.570] - stdout: TRUE
[13:34:38.570] - signal: TRUE
[13:34:38.570] - resignal: FALSE
[13:34:38.570] - force: TRUE
[13:34:38.570] - relayed: [n=2] TRUE, FALSE
[13:34:38.570] - queued futures: [n=2] TRUE, FALSE
[13:34:38.570]  - until=2
[13:34:38.570]  - relaying element #2
[13:34:38.570] result() for ClusterFuture ...
[13:34:38.570] - result already collected: FutureResult
[13:34:38.570] result() for ClusterFuture ... done
[13:34:38.571] result() for ClusterFuture ...
[13:34:38.571] - result already collected: FutureResult
[13:34:38.571] result() for ClusterFuture ... done
[13:34:38.571] result() for ClusterFuture ...
[13:34:38.571] - result already collected: FutureResult
[13:34:38.571] result() for ClusterFuture ... done
[13:34:38.571] result() for ClusterFuture ...
[13:34:38.571] - result already collected: FutureResult
[13:34:38.571] result() for ClusterFuture ... done
[13:34:38.571] - relayed: [n=2] TRUE, TRUE
[13:34:38.571] - queued futures: [n=2] TRUE, TRUE
[13:34:38.571] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:38.572]  length: 0 (resolved future 2)
[13:34:38.572] Relaying remaining futures
[13:34:38.572] signalConditionsASAP(NULL, pos=0) ...
[13:34:38.572] - nx: 2
[13:34:38.572] - relay: TRUE
[13:34:38.572] - stdout: TRUE
[13:34:38.572] - signal: TRUE
[13:34:38.572] - resignal: FALSE
[13:34:38.572] - force: TRUE
[13:34:38.572] - relayed: [n=2] TRUE, TRUE
[13:34:38.572] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:38.573] - relayed: [n=2] TRUE, TRUE
[13:34:38.573] - queued futures: [n=2] TRUE, TRUE
[13:34:38.573] signalConditionsASAP(NULL, pos=0) ... done
[13:34:38.573] resolve() on list ... DONE
[13:34:38.573] result() for ClusterFuture ...
[13:34:38.573] - result already collected: FutureResult
[13:34:38.573] result() for ClusterFuture ... done
[13:34:38.573] result() for ClusterFuture ...
[13:34:38.573] - result already collected: FutureResult
[13:34:38.573] result() for ClusterFuture ... done
[13:34:38.573] result() for ClusterFuture ...
[13:34:38.573] - result already collected: FutureResult
[13:34:38.574] result() for ClusterFuture ... done
[13:34:38.574] result() for ClusterFuture ...
[13:34:38.574] - result already collected: FutureResult
[13:34:38.574] result() for ClusterFuture ... done
[13:34:38.574]  - Number of value chunks collected: 2
[13:34:38.574] Resolving 2 futures (chunks) ... DONE
[13:34:38.574] Reducing values from 2 chunks ...
[13:34:38.574]  - Number of values collected after concatenation: 4
[13:34:38.574]  - Number of values expected: 4
[13:34:38.574] Reducing values from 2 chunks ... DONE
[13:34:38.574] future_mapply() ... DONE
[13:34:38.575] future_mapply() ...
[13:34:38.578] Number of chunks: 2
[13:34:38.578] getGlobalsAndPackagesXApply() ...
[13:34:38.578]  - future.globals: TRUE
[13:34:38.578] getGlobalsAndPackages() ...
[13:34:38.578] Searching for globals...
[13:34:38.579] - globals found: [1] ‘FUN’
[13:34:38.579] Searching for globals ... DONE
[13:34:38.579] Resolving globals: FALSE
[13:34:38.579] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:38.580] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:38.580] - globals: [1] ‘FUN’
[13:34:38.580] 
[13:34:38.580] getGlobalsAndPackages() ... DONE
[13:34:38.580]  - globals found/used: [n=1] ‘FUN’
[13:34:38.580]  - needed namespaces: [n=0] 
[13:34:38.580] Finding globals ... DONE
[13:34:38.580] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:38.581] List of 2
[13:34:38.581]  $ ...future.FUN:function (x, ...)  
[13:34:38.581]  $ MoreArgs     :List of 1
[13:34:38.581]   ..$ x: num 42
[13:34:38.581]  - attr(*, "where")=List of 2
[13:34:38.581]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:38.581]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:38.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:38.581]  - attr(*, "resolved")= logi FALSE
[13:34:38.581]  - attr(*, "total_size")= num NA
[13:34:38.583] Packages to be attached in all futures: [n=0] 
[13:34:38.583] getGlobalsAndPackagesXApply() ... DONE
[13:34:38.584] Number of futures (= number of chunks): 2
[13:34:38.584] Launching 2 futures (chunks) ...
[13:34:38.584] Chunk #1 of 2 ...
[13:34:38.584]  - Finding globals in '...' for chunk #1 ...
[13:34:38.584] getGlobalsAndPackages() ...
[13:34:38.584] Searching for globals...
[13:34:38.584] 
[13:34:38.585] Searching for globals ... DONE
[13:34:38.585] - globals: [0] <none>
[13:34:38.585] getGlobalsAndPackages() ... DONE
[13:34:38.585]    + additional globals found: [n=0] 
[13:34:38.585]    + additional namespaces needed: [n=0] 
[13:34:38.585]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:38.585]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.585]  - seeds: <none>
[13:34:38.585]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.585] getGlobalsAndPackages() ...
[13:34:38.585] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.586] Resolving globals: FALSE
[13:34:38.586] The total size of the 5 globals is 224 bytes (224 bytes)
[13:34:38.586] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[13:34:38.587] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.587] 
[13:34:38.587] getGlobalsAndPackages() ... DONE
[13:34:38.587] run() for ‘Future’ ...
[13:34:38.587] - state: ‘created’
[13:34:38.587] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.600] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.601]   - Field: ‘node’
[13:34:38.601]   - Field: ‘label’
[13:34:38.601]   - Field: ‘local’
[13:34:38.601]   - Field: ‘owner’
[13:34:38.601]   - Field: ‘envir’
[13:34:38.601]   - Field: ‘workers’
[13:34:38.601]   - Field: ‘packages’
[13:34:38.601]   - Field: ‘gc’
[13:34:38.601]   - Field: ‘conditions’
[13:34:38.602]   - Field: ‘persistent’
[13:34:38.602]   - Field: ‘expr’
[13:34:38.602]   - Field: ‘uuid’
[13:34:38.602]   - Field: ‘seed’
[13:34:38.602]   - Field: ‘version’
[13:34:38.602]   - Field: ‘result’
[13:34:38.602]   - Field: ‘asynchronous’
[13:34:38.602]   - Field: ‘calls’
[13:34:38.602]   - Field: ‘globals’
[13:34:38.602]   - Field: ‘stdout’
[13:34:38.603]   - Field: ‘earlySignal’
[13:34:38.603]   - Field: ‘lazy’
[13:34:38.603]   - Field: ‘state’
[13:34:38.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.603] - Launch lazy future ...
[13:34:38.603] Packages needed by the future expression (n = 0): <none>
[13:34:38.603] Packages needed by future strategies (n = 0): <none>
[13:34:38.604] {
[13:34:38.604]     {
[13:34:38.604]         {
[13:34:38.604]             ...future.startTime <- base::Sys.time()
[13:34:38.604]             {
[13:34:38.604]                 {
[13:34:38.604]                   {
[13:34:38.604]                     {
[13:34:38.604]                       base::local({
[13:34:38.604]                         has_future <- base::requireNamespace("future", 
[13:34:38.604]                           quietly = TRUE)
[13:34:38.604]                         if (has_future) {
[13:34:38.604]                           ns <- base::getNamespace("future")
[13:34:38.604]                           version <- ns[[".package"]][["version"]]
[13:34:38.604]                           if (is.null(version)) 
[13:34:38.604]                             version <- utils::packageVersion("future")
[13:34:38.604]                         }
[13:34:38.604]                         else {
[13:34:38.604]                           version <- NULL
[13:34:38.604]                         }
[13:34:38.604]                         if (!has_future || version < "1.8.0") {
[13:34:38.604]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.604]                             "", base::R.version$version.string), 
[13:34:38.604]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.604]                               "release", "version")], collapse = " "), 
[13:34:38.604]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.604]                             info)
[13:34:38.604]                           info <- base::paste(info, collapse = "; ")
[13:34:38.604]                           if (!has_future) {
[13:34:38.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.604]                               info)
[13:34:38.604]                           }
[13:34:38.604]                           else {
[13:34:38.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.604]                               info, version)
[13:34:38.604]                           }
[13:34:38.604]                           base::stop(msg)
[13:34:38.604]                         }
[13:34:38.604]                       })
[13:34:38.604]                     }
[13:34:38.604]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.604]                     base::options(mc.cores = 1L)
[13:34:38.604]                   }
[13:34:38.604]                   ...future.strategy.old <- future::plan("list")
[13:34:38.604]                   options(future.plan = NULL)
[13:34:38.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.604]                 }
[13:34:38.604]                 ...future.workdir <- getwd()
[13:34:38.604]             }
[13:34:38.604]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.604]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.604]         }
[13:34:38.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.604]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.604]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.604]             base::names(...future.oldOptions))
[13:34:38.604]     }
[13:34:38.604]     if (FALSE) {
[13:34:38.604]     }
[13:34:38.604]     else {
[13:34:38.604]         if (TRUE) {
[13:34:38.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.604]                 open = "w")
[13:34:38.604]         }
[13:34:38.604]         else {
[13:34:38.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.604]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.604]         }
[13:34:38.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.604]             base::sink(type = "output", split = FALSE)
[13:34:38.604]             base::close(...future.stdout)
[13:34:38.604]         }, add = TRUE)
[13:34:38.604]     }
[13:34:38.604]     ...future.frame <- base::sys.nframe()
[13:34:38.604]     ...future.conditions <- base::list()
[13:34:38.604]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.604]     if (FALSE) {
[13:34:38.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.604]     }
[13:34:38.604]     ...future.result <- base::tryCatch({
[13:34:38.604]         base::withCallingHandlers({
[13:34:38.604]             ...future.value <- base::withVisible(base::local({
[13:34:38.604]                 ...future.makeSendCondition <- base::local({
[13:34:38.604]                   sendCondition <- NULL
[13:34:38.604]                   function(frame = 1L) {
[13:34:38.604]                     if (is.function(sendCondition)) 
[13:34:38.604]                       return(sendCondition)
[13:34:38.604]                     ns <- getNamespace("parallel")
[13:34:38.604]                     if (exists("sendData", mode = "function", 
[13:34:38.604]                       envir = ns)) {
[13:34:38.604]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.604]                         envir = ns)
[13:34:38.604]                       envir <- sys.frame(frame)
[13:34:38.604]                       master <- NULL
[13:34:38.604]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.604]                         !identical(envir, emptyenv())) {
[13:34:38.604]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.604]                           inherits = FALSE)) {
[13:34:38.604]                           master <- get("master", mode = "list", 
[13:34:38.604]                             envir = envir, inherits = FALSE)
[13:34:38.604]                           if (inherits(master, c("SOCKnode", 
[13:34:38.604]                             "SOCK0node"))) {
[13:34:38.604]                             sendCondition <<- function(cond) {
[13:34:38.604]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.604]                                 success = TRUE)
[13:34:38.604]                               parallel_sendData(master, data)
[13:34:38.604]                             }
[13:34:38.604]                             return(sendCondition)
[13:34:38.604]                           }
[13:34:38.604]                         }
[13:34:38.604]                         frame <- frame + 1L
[13:34:38.604]                         envir <- sys.frame(frame)
[13:34:38.604]                       }
[13:34:38.604]                     }
[13:34:38.604]                     sendCondition <<- function(cond) NULL
[13:34:38.604]                   }
[13:34:38.604]                 })
[13:34:38.604]                 withCallingHandlers({
[13:34:38.604]                   {
[13:34:38.604]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.604]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.604]                       ...future.globals.maxSize)) {
[13:34:38.604]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.604]                       on.exit(options(oopts), add = TRUE)
[13:34:38.604]                     }
[13:34:38.604]                     {
[13:34:38.604]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.604]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.604]                         USE.NAMES = FALSE)
[13:34:38.604]                       do.call(mapply, args = args)
[13:34:38.604]                     }
[13:34:38.604]                   }
[13:34:38.604]                 }, immediateCondition = function(cond) {
[13:34:38.604]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.604]                   sendCondition(cond)
[13:34:38.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.604]                   {
[13:34:38.604]                     inherits <- base::inherits
[13:34:38.604]                     invokeRestart <- base::invokeRestart
[13:34:38.604]                     is.null <- base::is.null
[13:34:38.604]                     muffled <- FALSE
[13:34:38.604]                     if (inherits(cond, "message")) {
[13:34:38.604]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.604]                       if (muffled) 
[13:34:38.604]                         invokeRestart("muffleMessage")
[13:34:38.604]                     }
[13:34:38.604]                     else if (inherits(cond, "warning")) {
[13:34:38.604]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.604]                       if (muffled) 
[13:34:38.604]                         invokeRestart("muffleWarning")
[13:34:38.604]                     }
[13:34:38.604]                     else if (inherits(cond, "condition")) {
[13:34:38.604]                       if (!is.null(pattern)) {
[13:34:38.604]                         computeRestarts <- base::computeRestarts
[13:34:38.604]                         grepl <- base::grepl
[13:34:38.604]                         restarts <- computeRestarts(cond)
[13:34:38.604]                         for (restart in restarts) {
[13:34:38.604]                           name <- restart$name
[13:34:38.604]                           if (is.null(name)) 
[13:34:38.604]                             next
[13:34:38.604]                           if (!grepl(pattern, name)) 
[13:34:38.604]                             next
[13:34:38.604]                           invokeRestart(restart)
[13:34:38.604]                           muffled <- TRUE
[13:34:38.604]                           break
[13:34:38.604]                         }
[13:34:38.604]                       }
[13:34:38.604]                     }
[13:34:38.604]                     invisible(muffled)
[13:34:38.604]                   }
[13:34:38.604]                   muffleCondition(cond)
[13:34:38.604]                 })
[13:34:38.604]             }))
[13:34:38.604]             future::FutureResult(value = ...future.value$value, 
[13:34:38.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.604]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.604]                     ...future.globalenv.names))
[13:34:38.604]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.604]         }, condition = base::local({
[13:34:38.604]             c <- base::c
[13:34:38.604]             inherits <- base::inherits
[13:34:38.604]             invokeRestart <- base::invokeRestart
[13:34:38.604]             length <- base::length
[13:34:38.604]             list <- base::list
[13:34:38.604]             seq.int <- base::seq.int
[13:34:38.604]             signalCondition <- base::signalCondition
[13:34:38.604]             sys.calls <- base::sys.calls
[13:34:38.604]             `[[` <- base::`[[`
[13:34:38.604]             `+` <- base::`+`
[13:34:38.604]             `<<-` <- base::`<<-`
[13:34:38.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.604]                   3L)]
[13:34:38.604]             }
[13:34:38.604]             function(cond) {
[13:34:38.604]                 is_error <- inherits(cond, "error")
[13:34:38.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.604]                   NULL)
[13:34:38.604]                 if (is_error) {
[13:34:38.604]                   sessionInformation <- function() {
[13:34:38.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.604]                       search = base::search(), system = base::Sys.info())
[13:34:38.604]                   }
[13:34:38.604]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.604]                     cond$call), session = sessionInformation(), 
[13:34:38.604]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.604]                   signalCondition(cond)
[13:34:38.604]                 }
[13:34:38.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.604]                 "immediateCondition"))) {
[13:34:38.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.604]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.604]                   if (TRUE && !signal) {
[13:34:38.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.604]                     {
[13:34:38.604]                       inherits <- base::inherits
[13:34:38.604]                       invokeRestart <- base::invokeRestart
[13:34:38.604]                       is.null <- base::is.null
[13:34:38.604]                       muffled <- FALSE
[13:34:38.604]                       if (inherits(cond, "message")) {
[13:34:38.604]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.604]                         if (muffled) 
[13:34:38.604]                           invokeRestart("muffleMessage")
[13:34:38.604]                       }
[13:34:38.604]                       else if (inherits(cond, "warning")) {
[13:34:38.604]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.604]                         if (muffled) 
[13:34:38.604]                           invokeRestart("muffleWarning")
[13:34:38.604]                       }
[13:34:38.604]                       else if (inherits(cond, "condition")) {
[13:34:38.604]                         if (!is.null(pattern)) {
[13:34:38.604]                           computeRestarts <- base::computeRestarts
[13:34:38.604]                           grepl <- base::grepl
[13:34:38.604]                           restarts <- computeRestarts(cond)
[13:34:38.604]                           for (restart in restarts) {
[13:34:38.604]                             name <- restart$name
[13:34:38.604]                             if (is.null(name)) 
[13:34:38.604]                               next
[13:34:38.604]                             if (!grepl(pattern, name)) 
[13:34:38.604]                               next
[13:34:38.604]                             invokeRestart(restart)
[13:34:38.604]                             muffled <- TRUE
[13:34:38.604]                             break
[13:34:38.604]                           }
[13:34:38.604]                         }
[13:34:38.604]                       }
[13:34:38.604]                       invisible(muffled)
[13:34:38.604]                     }
[13:34:38.604]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.604]                   }
[13:34:38.604]                 }
[13:34:38.604]                 else {
[13:34:38.604]                   if (TRUE) {
[13:34:38.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.604]                     {
[13:34:38.604]                       inherits <- base::inherits
[13:34:38.604]                       invokeRestart <- base::invokeRestart
[13:34:38.604]                       is.null <- base::is.null
[13:34:38.604]                       muffled <- FALSE
[13:34:38.604]                       if (inherits(cond, "message")) {
[13:34:38.604]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.604]                         if (muffled) 
[13:34:38.604]                           invokeRestart("muffleMessage")
[13:34:38.604]                       }
[13:34:38.604]                       else if (inherits(cond, "warning")) {
[13:34:38.604]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.604]                         if (muffled) 
[13:34:38.604]                           invokeRestart("muffleWarning")
[13:34:38.604]                       }
[13:34:38.604]                       else if (inherits(cond, "condition")) {
[13:34:38.604]                         if (!is.null(pattern)) {
[13:34:38.604]                           computeRestarts <- base::computeRestarts
[13:34:38.604]                           grepl <- base::grepl
[13:34:38.604]                           restarts <- computeRestarts(cond)
[13:34:38.604]                           for (restart in restarts) {
[13:34:38.604]                             name <- restart$name
[13:34:38.604]                             if (is.null(name)) 
[13:34:38.604]                               next
[13:34:38.604]                             if (!grepl(pattern, name)) 
[13:34:38.604]                               next
[13:34:38.604]                             invokeRestart(restart)
[13:34:38.604]                             muffled <- TRUE
[13:34:38.604]                             break
[13:34:38.604]                           }
[13:34:38.604]                         }
[13:34:38.604]                       }
[13:34:38.604]                       invisible(muffled)
[13:34:38.604]                     }
[13:34:38.604]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.604]                   }
[13:34:38.604]                 }
[13:34:38.604]             }
[13:34:38.604]         }))
[13:34:38.604]     }, error = function(ex) {
[13:34:38.604]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.604]                 ...future.rng), started = ...future.startTime, 
[13:34:38.604]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.604]             version = "1.8"), class = "FutureResult")
[13:34:38.604]     }, finally = {
[13:34:38.604]         if (!identical(...future.workdir, getwd())) 
[13:34:38.604]             setwd(...future.workdir)
[13:34:38.604]         {
[13:34:38.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.604]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.604]             }
[13:34:38.604]             base::options(...future.oldOptions)
[13:34:38.604]             if (.Platform$OS.type == "windows") {
[13:34:38.604]                 old_names <- names(...future.oldEnvVars)
[13:34:38.604]                 envs <- base::Sys.getenv()
[13:34:38.604]                 names <- names(envs)
[13:34:38.604]                 common <- intersect(names, old_names)
[13:34:38.604]                 added <- setdiff(names, old_names)
[13:34:38.604]                 removed <- setdiff(old_names, names)
[13:34:38.604]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.604]                   envs[common]]
[13:34:38.604]                 NAMES <- toupper(changed)
[13:34:38.604]                 args <- list()
[13:34:38.604]                 for (kk in seq_along(NAMES)) {
[13:34:38.604]                   name <- changed[[kk]]
[13:34:38.604]                   NAME <- NAMES[[kk]]
[13:34:38.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.604]                     next
[13:34:38.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.604]                 }
[13:34:38.604]                 NAMES <- toupper(added)
[13:34:38.604]                 for (kk in seq_along(NAMES)) {
[13:34:38.604]                   name <- added[[kk]]
[13:34:38.604]                   NAME <- NAMES[[kk]]
[13:34:38.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.604]                     next
[13:34:38.604]                   args[[name]] <- ""
[13:34:38.604]                 }
[13:34:38.604]                 NAMES <- toupper(removed)
[13:34:38.604]                 for (kk in seq_along(NAMES)) {
[13:34:38.604]                   name <- removed[[kk]]
[13:34:38.604]                   NAME <- NAMES[[kk]]
[13:34:38.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.604]                     next
[13:34:38.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.604]                 }
[13:34:38.604]                 if (length(args) > 0) 
[13:34:38.604]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.604]             }
[13:34:38.604]             else {
[13:34:38.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.604]             }
[13:34:38.604]             {
[13:34:38.604]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.604]                   0L) {
[13:34:38.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.604]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.604]                   base::options(opts)
[13:34:38.604]                 }
[13:34:38.604]                 {
[13:34:38.604]                   {
[13:34:38.604]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.604]                     NULL
[13:34:38.604]                   }
[13:34:38.604]                   options(future.plan = NULL)
[13:34:38.604]                   if (is.na(NA_character_)) 
[13:34:38.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.604]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.604]                     .init = FALSE)
[13:34:38.604]                 }
[13:34:38.604]             }
[13:34:38.604]         }
[13:34:38.604]     })
[13:34:38.604]     if (TRUE) {
[13:34:38.604]         base::sink(type = "output", split = FALSE)
[13:34:38.604]         if (TRUE) {
[13:34:38.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.604]         }
[13:34:38.604]         else {
[13:34:38.604]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.604]         }
[13:34:38.604]         base::close(...future.stdout)
[13:34:38.604]         ...future.stdout <- NULL
[13:34:38.604]     }
[13:34:38.604]     ...future.result$conditions <- ...future.conditions
[13:34:38.604]     ...future.result$finished <- base::Sys.time()
[13:34:38.604]     ...future.result
[13:34:38.604] }
[13:34:38.606] Exporting 5 global objects (224 bytes) to cluster node #1 ...
[13:34:38.606] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[13:34:38.607] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[13:34:38.607] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[13:34:38.607] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[13:34:38.607] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:34:38.608] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:34:38.608] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:38.608] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.608] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:38.608] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.609] Exporting 5 global objects (224 bytes) to cluster node #1 ... DONE
[13:34:38.609] MultisessionFuture started
[13:34:38.609] - Launch lazy future ... done
[13:34:38.609] run() for ‘MultisessionFuture’ ... done
[13:34:38.609] Created future:
[13:34:38.609] MultisessionFuture:
[13:34:38.609] Label: ‘future_mapply-1’
[13:34:38.609] Expression:
[13:34:38.609] {
[13:34:38.609]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.609]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.609]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.609]         on.exit(options(oopts), add = TRUE)
[13:34:38.609]     }
[13:34:38.609]     {
[13:34:38.609]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.609]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.609]         do.call(mapply, args = args)
[13:34:38.609]     }
[13:34:38.609] }
[13:34:38.609] Lazy evaluation: FALSE
[13:34:38.609] Asynchronous evaluation: TRUE
[13:34:38.609] Local evaluation: TRUE
[13:34:38.609] Environment: R_GlobalEnv
[13:34:38.609] Capture standard output: TRUE
[13:34:38.609] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.609] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.609] Packages: <none>
[13:34:38.609] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.609] Resolved: FALSE
[13:34:38.609] Value: <not collected>
[13:34:38.609] Conditions captured: <none>
[13:34:38.609] Early signaling: FALSE
[13:34:38.609] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.609] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.621] Chunk #1 of 2 ... DONE
[13:34:38.621] Chunk #2 of 2 ...
[13:34:38.621]  - Finding globals in '...' for chunk #2 ...
[13:34:38.621] getGlobalsAndPackages() ...
[13:34:38.621] Searching for globals...
[13:34:38.622] 
[13:34:38.622] Searching for globals ... DONE
[13:34:38.622] - globals: [0] <none>
[13:34:38.622] getGlobalsAndPackages() ... DONE
[13:34:38.622]    + additional globals found: [n=0] 
[13:34:38.622]    + additional namespaces needed: [n=0] 
[13:34:38.622]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:38.622]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.622]  - seeds: <none>
[13:34:38.622]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.622] getGlobalsAndPackages() ...
[13:34:38.623] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.623] Resolving globals: FALSE
[13:34:38.623] The total size of the 5 globals is 224 bytes (224 bytes)
[13:34:38.624] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[13:34:38.624] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.624] 
[13:34:38.624] getGlobalsAndPackages() ... DONE
[13:34:38.624] run() for ‘Future’ ...
[13:34:38.624] - state: ‘created’
[13:34:38.624] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.638] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.639]   - Field: ‘node’
[13:34:38.639]   - Field: ‘label’
[13:34:38.639]   - Field: ‘local’
[13:34:38.639]   - Field: ‘owner’
[13:34:38.639]   - Field: ‘envir’
[13:34:38.639]   - Field: ‘workers’
[13:34:38.639]   - Field: ‘packages’
[13:34:38.639]   - Field: ‘gc’
[13:34:38.639]   - Field: ‘conditions’
[13:34:38.640]   - Field: ‘persistent’
[13:34:38.640]   - Field: ‘expr’
[13:34:38.640]   - Field: ‘uuid’
[13:34:38.640]   - Field: ‘seed’
[13:34:38.640]   - Field: ‘version’
[13:34:38.640]   - Field: ‘result’
[13:34:38.640]   - Field: ‘asynchronous’
[13:34:38.640]   - Field: ‘calls’
[13:34:38.640]   - Field: ‘globals’
[13:34:38.640]   - Field: ‘stdout’
[13:34:38.641]   - Field: ‘earlySignal’
[13:34:38.641]   - Field: ‘lazy’
[13:34:38.641]   - Field: ‘state’
[13:34:38.641] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.641] - Launch lazy future ...
[13:34:38.641] Packages needed by the future expression (n = 0): <none>
[13:34:38.641] Packages needed by future strategies (n = 0): <none>
[13:34:38.642] {
[13:34:38.642]     {
[13:34:38.642]         {
[13:34:38.642]             ...future.startTime <- base::Sys.time()
[13:34:38.642]             {
[13:34:38.642]                 {
[13:34:38.642]                   {
[13:34:38.642]                     {
[13:34:38.642]                       base::local({
[13:34:38.642]                         has_future <- base::requireNamespace("future", 
[13:34:38.642]                           quietly = TRUE)
[13:34:38.642]                         if (has_future) {
[13:34:38.642]                           ns <- base::getNamespace("future")
[13:34:38.642]                           version <- ns[[".package"]][["version"]]
[13:34:38.642]                           if (is.null(version)) 
[13:34:38.642]                             version <- utils::packageVersion("future")
[13:34:38.642]                         }
[13:34:38.642]                         else {
[13:34:38.642]                           version <- NULL
[13:34:38.642]                         }
[13:34:38.642]                         if (!has_future || version < "1.8.0") {
[13:34:38.642]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.642]                             "", base::R.version$version.string), 
[13:34:38.642]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.642]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.642]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.642]                               "release", "version")], collapse = " "), 
[13:34:38.642]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.642]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.642]                             info)
[13:34:38.642]                           info <- base::paste(info, collapse = "; ")
[13:34:38.642]                           if (!has_future) {
[13:34:38.642]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.642]                               info)
[13:34:38.642]                           }
[13:34:38.642]                           else {
[13:34:38.642]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.642]                               info, version)
[13:34:38.642]                           }
[13:34:38.642]                           base::stop(msg)
[13:34:38.642]                         }
[13:34:38.642]                       })
[13:34:38.642]                     }
[13:34:38.642]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.642]                     base::options(mc.cores = 1L)
[13:34:38.642]                   }
[13:34:38.642]                   ...future.strategy.old <- future::plan("list")
[13:34:38.642]                   options(future.plan = NULL)
[13:34:38.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.642]                 }
[13:34:38.642]                 ...future.workdir <- getwd()
[13:34:38.642]             }
[13:34:38.642]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.642]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.642]         }
[13:34:38.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.642]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.642]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.642]             base::names(...future.oldOptions))
[13:34:38.642]     }
[13:34:38.642]     if (FALSE) {
[13:34:38.642]     }
[13:34:38.642]     else {
[13:34:38.642]         if (TRUE) {
[13:34:38.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.642]                 open = "w")
[13:34:38.642]         }
[13:34:38.642]         else {
[13:34:38.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.642]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.642]         }
[13:34:38.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.642]             base::sink(type = "output", split = FALSE)
[13:34:38.642]             base::close(...future.stdout)
[13:34:38.642]         }, add = TRUE)
[13:34:38.642]     }
[13:34:38.642]     ...future.frame <- base::sys.nframe()
[13:34:38.642]     ...future.conditions <- base::list()
[13:34:38.642]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.642]     if (FALSE) {
[13:34:38.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.642]     }
[13:34:38.642]     ...future.result <- base::tryCatch({
[13:34:38.642]         base::withCallingHandlers({
[13:34:38.642]             ...future.value <- base::withVisible(base::local({
[13:34:38.642]                 ...future.makeSendCondition <- base::local({
[13:34:38.642]                   sendCondition <- NULL
[13:34:38.642]                   function(frame = 1L) {
[13:34:38.642]                     if (is.function(sendCondition)) 
[13:34:38.642]                       return(sendCondition)
[13:34:38.642]                     ns <- getNamespace("parallel")
[13:34:38.642]                     if (exists("sendData", mode = "function", 
[13:34:38.642]                       envir = ns)) {
[13:34:38.642]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.642]                         envir = ns)
[13:34:38.642]                       envir <- sys.frame(frame)
[13:34:38.642]                       master <- NULL
[13:34:38.642]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.642]                         !identical(envir, emptyenv())) {
[13:34:38.642]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.642]                           inherits = FALSE)) {
[13:34:38.642]                           master <- get("master", mode = "list", 
[13:34:38.642]                             envir = envir, inherits = FALSE)
[13:34:38.642]                           if (inherits(master, c("SOCKnode", 
[13:34:38.642]                             "SOCK0node"))) {
[13:34:38.642]                             sendCondition <<- function(cond) {
[13:34:38.642]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.642]                                 success = TRUE)
[13:34:38.642]                               parallel_sendData(master, data)
[13:34:38.642]                             }
[13:34:38.642]                             return(sendCondition)
[13:34:38.642]                           }
[13:34:38.642]                         }
[13:34:38.642]                         frame <- frame + 1L
[13:34:38.642]                         envir <- sys.frame(frame)
[13:34:38.642]                       }
[13:34:38.642]                     }
[13:34:38.642]                     sendCondition <<- function(cond) NULL
[13:34:38.642]                   }
[13:34:38.642]                 })
[13:34:38.642]                 withCallingHandlers({
[13:34:38.642]                   {
[13:34:38.642]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.642]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.642]                       ...future.globals.maxSize)) {
[13:34:38.642]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.642]                       on.exit(options(oopts), add = TRUE)
[13:34:38.642]                     }
[13:34:38.642]                     {
[13:34:38.642]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.642]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.642]                         USE.NAMES = FALSE)
[13:34:38.642]                       do.call(mapply, args = args)
[13:34:38.642]                     }
[13:34:38.642]                   }
[13:34:38.642]                 }, immediateCondition = function(cond) {
[13:34:38.642]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.642]                   sendCondition(cond)
[13:34:38.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.642]                   {
[13:34:38.642]                     inherits <- base::inherits
[13:34:38.642]                     invokeRestart <- base::invokeRestart
[13:34:38.642]                     is.null <- base::is.null
[13:34:38.642]                     muffled <- FALSE
[13:34:38.642]                     if (inherits(cond, "message")) {
[13:34:38.642]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.642]                       if (muffled) 
[13:34:38.642]                         invokeRestart("muffleMessage")
[13:34:38.642]                     }
[13:34:38.642]                     else if (inherits(cond, "warning")) {
[13:34:38.642]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.642]                       if (muffled) 
[13:34:38.642]                         invokeRestart("muffleWarning")
[13:34:38.642]                     }
[13:34:38.642]                     else if (inherits(cond, "condition")) {
[13:34:38.642]                       if (!is.null(pattern)) {
[13:34:38.642]                         computeRestarts <- base::computeRestarts
[13:34:38.642]                         grepl <- base::grepl
[13:34:38.642]                         restarts <- computeRestarts(cond)
[13:34:38.642]                         for (restart in restarts) {
[13:34:38.642]                           name <- restart$name
[13:34:38.642]                           if (is.null(name)) 
[13:34:38.642]                             next
[13:34:38.642]                           if (!grepl(pattern, name)) 
[13:34:38.642]                             next
[13:34:38.642]                           invokeRestart(restart)
[13:34:38.642]                           muffled <- TRUE
[13:34:38.642]                           break
[13:34:38.642]                         }
[13:34:38.642]                       }
[13:34:38.642]                     }
[13:34:38.642]                     invisible(muffled)
[13:34:38.642]                   }
[13:34:38.642]                   muffleCondition(cond)
[13:34:38.642]                 })
[13:34:38.642]             }))
[13:34:38.642]             future::FutureResult(value = ...future.value$value, 
[13:34:38.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.642]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.642]                     ...future.globalenv.names))
[13:34:38.642]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.642]         }, condition = base::local({
[13:34:38.642]             c <- base::c
[13:34:38.642]             inherits <- base::inherits
[13:34:38.642]             invokeRestart <- base::invokeRestart
[13:34:38.642]             length <- base::length
[13:34:38.642]             list <- base::list
[13:34:38.642]             seq.int <- base::seq.int
[13:34:38.642]             signalCondition <- base::signalCondition
[13:34:38.642]             sys.calls <- base::sys.calls
[13:34:38.642]             `[[` <- base::`[[`
[13:34:38.642]             `+` <- base::`+`
[13:34:38.642]             `<<-` <- base::`<<-`
[13:34:38.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.642]                   3L)]
[13:34:38.642]             }
[13:34:38.642]             function(cond) {
[13:34:38.642]                 is_error <- inherits(cond, "error")
[13:34:38.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.642]                   NULL)
[13:34:38.642]                 if (is_error) {
[13:34:38.642]                   sessionInformation <- function() {
[13:34:38.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.642]                       search = base::search(), system = base::Sys.info())
[13:34:38.642]                   }
[13:34:38.642]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.642]                     cond$call), session = sessionInformation(), 
[13:34:38.642]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.642]                   signalCondition(cond)
[13:34:38.642]                 }
[13:34:38.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.642]                 "immediateCondition"))) {
[13:34:38.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.642]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.642]                   if (TRUE && !signal) {
[13:34:38.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.642]                     {
[13:34:38.642]                       inherits <- base::inherits
[13:34:38.642]                       invokeRestart <- base::invokeRestart
[13:34:38.642]                       is.null <- base::is.null
[13:34:38.642]                       muffled <- FALSE
[13:34:38.642]                       if (inherits(cond, "message")) {
[13:34:38.642]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.642]                         if (muffled) 
[13:34:38.642]                           invokeRestart("muffleMessage")
[13:34:38.642]                       }
[13:34:38.642]                       else if (inherits(cond, "warning")) {
[13:34:38.642]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.642]                         if (muffled) 
[13:34:38.642]                           invokeRestart("muffleWarning")
[13:34:38.642]                       }
[13:34:38.642]                       else if (inherits(cond, "condition")) {
[13:34:38.642]                         if (!is.null(pattern)) {
[13:34:38.642]                           computeRestarts <- base::computeRestarts
[13:34:38.642]                           grepl <- base::grepl
[13:34:38.642]                           restarts <- computeRestarts(cond)
[13:34:38.642]                           for (restart in restarts) {
[13:34:38.642]                             name <- restart$name
[13:34:38.642]                             if (is.null(name)) 
[13:34:38.642]                               next
[13:34:38.642]                             if (!grepl(pattern, name)) 
[13:34:38.642]                               next
[13:34:38.642]                             invokeRestart(restart)
[13:34:38.642]                             muffled <- TRUE
[13:34:38.642]                             break
[13:34:38.642]                           }
[13:34:38.642]                         }
[13:34:38.642]                       }
[13:34:38.642]                       invisible(muffled)
[13:34:38.642]                     }
[13:34:38.642]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.642]                   }
[13:34:38.642]                 }
[13:34:38.642]                 else {
[13:34:38.642]                   if (TRUE) {
[13:34:38.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.642]                     {
[13:34:38.642]                       inherits <- base::inherits
[13:34:38.642]                       invokeRestart <- base::invokeRestart
[13:34:38.642]                       is.null <- base::is.null
[13:34:38.642]                       muffled <- FALSE
[13:34:38.642]                       if (inherits(cond, "message")) {
[13:34:38.642]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.642]                         if (muffled) 
[13:34:38.642]                           invokeRestart("muffleMessage")
[13:34:38.642]                       }
[13:34:38.642]                       else if (inherits(cond, "warning")) {
[13:34:38.642]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.642]                         if (muffled) 
[13:34:38.642]                           invokeRestart("muffleWarning")
[13:34:38.642]                       }
[13:34:38.642]                       else if (inherits(cond, "condition")) {
[13:34:38.642]                         if (!is.null(pattern)) {
[13:34:38.642]                           computeRestarts <- base::computeRestarts
[13:34:38.642]                           grepl <- base::grepl
[13:34:38.642]                           restarts <- computeRestarts(cond)
[13:34:38.642]                           for (restart in restarts) {
[13:34:38.642]                             name <- restart$name
[13:34:38.642]                             if (is.null(name)) 
[13:34:38.642]                               next
[13:34:38.642]                             if (!grepl(pattern, name)) 
[13:34:38.642]                               next
[13:34:38.642]                             invokeRestart(restart)
[13:34:38.642]                             muffled <- TRUE
[13:34:38.642]                             break
[13:34:38.642]                           }
[13:34:38.642]                         }
[13:34:38.642]                       }
[13:34:38.642]                       invisible(muffled)
[13:34:38.642]                     }
[13:34:38.642]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.642]                   }
[13:34:38.642]                 }
[13:34:38.642]             }
[13:34:38.642]         }))
[13:34:38.642]     }, error = function(ex) {
[13:34:38.642]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.642]                 ...future.rng), started = ...future.startTime, 
[13:34:38.642]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.642]             version = "1.8"), class = "FutureResult")
[13:34:38.642]     }, finally = {
[13:34:38.642]         if (!identical(...future.workdir, getwd())) 
[13:34:38.642]             setwd(...future.workdir)
[13:34:38.642]         {
[13:34:38.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.642]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.642]             }
[13:34:38.642]             base::options(...future.oldOptions)
[13:34:38.642]             if (.Platform$OS.type == "windows") {
[13:34:38.642]                 old_names <- names(...future.oldEnvVars)
[13:34:38.642]                 envs <- base::Sys.getenv()
[13:34:38.642]                 names <- names(envs)
[13:34:38.642]                 common <- intersect(names, old_names)
[13:34:38.642]                 added <- setdiff(names, old_names)
[13:34:38.642]                 removed <- setdiff(old_names, names)
[13:34:38.642]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.642]                   envs[common]]
[13:34:38.642]                 NAMES <- toupper(changed)
[13:34:38.642]                 args <- list()
[13:34:38.642]                 for (kk in seq_along(NAMES)) {
[13:34:38.642]                   name <- changed[[kk]]
[13:34:38.642]                   NAME <- NAMES[[kk]]
[13:34:38.642]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.642]                     next
[13:34:38.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.642]                 }
[13:34:38.642]                 NAMES <- toupper(added)
[13:34:38.642]                 for (kk in seq_along(NAMES)) {
[13:34:38.642]                   name <- added[[kk]]
[13:34:38.642]                   NAME <- NAMES[[kk]]
[13:34:38.642]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.642]                     next
[13:34:38.642]                   args[[name]] <- ""
[13:34:38.642]                 }
[13:34:38.642]                 NAMES <- toupper(removed)
[13:34:38.642]                 for (kk in seq_along(NAMES)) {
[13:34:38.642]                   name <- removed[[kk]]
[13:34:38.642]                   NAME <- NAMES[[kk]]
[13:34:38.642]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.642]                     next
[13:34:38.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.642]                 }
[13:34:38.642]                 if (length(args) > 0) 
[13:34:38.642]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.642]             }
[13:34:38.642]             else {
[13:34:38.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.642]             }
[13:34:38.642]             {
[13:34:38.642]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.642]                   0L) {
[13:34:38.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.642]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.642]                   base::options(opts)
[13:34:38.642]                 }
[13:34:38.642]                 {
[13:34:38.642]                   {
[13:34:38.642]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.642]                     NULL
[13:34:38.642]                   }
[13:34:38.642]                   options(future.plan = NULL)
[13:34:38.642]                   if (is.na(NA_character_)) 
[13:34:38.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.642]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.642]                     .init = FALSE)
[13:34:38.642]                 }
[13:34:38.642]             }
[13:34:38.642]         }
[13:34:38.642]     })
[13:34:38.642]     if (TRUE) {
[13:34:38.642]         base::sink(type = "output", split = FALSE)
[13:34:38.642]         if (TRUE) {
[13:34:38.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.642]         }
[13:34:38.642]         else {
[13:34:38.642]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.642]         }
[13:34:38.642]         base::close(...future.stdout)
[13:34:38.642]         ...future.stdout <- NULL
[13:34:38.642]     }
[13:34:38.642]     ...future.result$conditions <- ...future.conditions
[13:34:38.642]     ...future.result$finished <- base::Sys.time()
[13:34:38.642]     ...future.result
[13:34:38.642] }
[13:34:38.644] Exporting 5 global objects (224 bytes) to cluster node #2 ...
[13:34:38.644] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[13:34:38.645] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[13:34:38.645] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[13:34:38.645] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[13:34:38.645] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:34:38.646] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:34:38.646] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:38.646] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.646] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:38.647] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.647] Exporting 5 global objects (224 bytes) to cluster node #2 ... DONE
[13:34:38.647] MultisessionFuture started
[13:34:38.647] - Launch lazy future ... done
[13:34:38.647] run() for ‘MultisessionFuture’ ... done
[13:34:38.647] Created future:
[13:34:38.648] MultisessionFuture:
[13:34:38.648] Label: ‘future_mapply-2’
[13:34:38.648] Expression:
[13:34:38.648] {
[13:34:38.648]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.648]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.648]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.648]         on.exit(options(oopts), add = TRUE)
[13:34:38.648]     }
[13:34:38.648]     {
[13:34:38.648]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.648]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.648]         do.call(mapply, args = args)
[13:34:38.648]     }
[13:34:38.648] }
[13:34:38.648] Lazy evaluation: FALSE
[13:34:38.648] Asynchronous evaluation: TRUE
[13:34:38.648] Local evaluation: TRUE
[13:34:38.648] Environment: R_GlobalEnv
[13:34:38.648] Capture standard output: TRUE
[13:34:38.648] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.648] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.648] Packages: <none>
[13:34:38.648] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.648] Resolved: FALSE
[13:34:38.648] Value: <not collected>
[13:34:38.648] Conditions captured: <none>
[13:34:38.648] Early signaling: FALSE
[13:34:38.648] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.648] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.659] Chunk #2 of 2 ... DONE
[13:34:38.659] Launching 2 futures (chunks) ... DONE
[13:34:38.659] Resolving 2 futures (chunks) ...
[13:34:38.659] resolve() on list ...
[13:34:38.659]  recursive: 0
[13:34:38.659]  length: 2
[13:34:38.660] 
[13:34:38.660] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.660] - Validating connection of MultisessionFuture
[13:34:38.660] - received message: FutureResult
[13:34:38.660] - Received FutureResult
[13:34:38.660] - Erased future from FutureRegistry
[13:34:38.661] result() for ClusterFuture ...
[13:34:38.661] - result already collected: FutureResult
[13:34:38.661] result() for ClusterFuture ... done
[13:34:38.661] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.661] Future #1
[13:34:38.661] result() for ClusterFuture ...
[13:34:38.661] - result already collected: FutureResult
[13:34:38.661] result() for ClusterFuture ... done
[13:34:38.661] result() for ClusterFuture ...
[13:34:38.661] - result already collected: FutureResult
[13:34:38.661] result() for ClusterFuture ... done
[13:34:38.662] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:38.662] - nx: 2
[13:34:38.662] - relay: TRUE
[13:34:38.662] - stdout: TRUE
[13:34:38.662] - signal: TRUE
[13:34:38.662] - resignal: FALSE
[13:34:38.662] - force: TRUE
[13:34:38.662] - relayed: [n=2] FALSE, FALSE
[13:34:38.665] - queued futures: [n=2] FALSE, FALSE
[13:34:38.665]  - until=1
[13:34:38.665]  - relaying element #1
[13:34:38.665] result() for ClusterFuture ...
[13:34:38.665] - result already collected: FutureResult
[13:34:38.665] result() for ClusterFuture ... done
[13:34:38.665] result() for ClusterFuture ...
[13:34:38.665] - result already collected: FutureResult
[13:34:38.665] result() for ClusterFuture ... done
[13:34:38.665] result() for ClusterFuture ...
[13:34:38.665] - result already collected: FutureResult
[13:34:38.666] result() for ClusterFuture ... done
[13:34:38.666] result() for ClusterFuture ...
[13:34:38.666] - result already collected: FutureResult
[13:34:38.666] result() for ClusterFuture ... done
[13:34:38.666] - relayed: [n=2] TRUE, FALSE
[13:34:38.666] - queued futures: [n=2] TRUE, FALSE
[13:34:38.666] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:38.666]  length: 1 (resolved future 1)
[13:34:38.692] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.692] - Validating connection of MultisessionFuture
[13:34:38.692] - received message: FutureResult
[13:34:38.692] - Received FutureResult
[13:34:38.692] - Erased future from FutureRegistry
[13:34:38.692] result() for ClusterFuture ...
[13:34:38.692] - result already collected: FutureResult
[13:34:38.693] result() for ClusterFuture ... done
[13:34:38.693] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.693] Future #2
[13:34:38.693] result() for ClusterFuture ...
[13:34:38.693] - result already collected: FutureResult
[13:34:38.693] result() for ClusterFuture ... done
[13:34:38.693] result() for ClusterFuture ...
[13:34:38.693] - result already collected: FutureResult
[13:34:38.693] result() for ClusterFuture ... done
[13:34:38.693] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:38.694] - nx: 2
[13:34:38.694] - relay: TRUE
[13:34:38.694] - stdout: TRUE
[13:34:38.694] - signal: TRUE
[13:34:38.694] - resignal: FALSE
[13:34:38.694] - force: TRUE
[13:34:38.694] - relayed: [n=2] TRUE, FALSE
[13:34:38.694] - queued futures: [n=2] TRUE, FALSE
[13:34:38.694]  - until=2
[13:34:38.694]  - relaying element #2
[13:34:38.694] result() for ClusterFuture ...
[13:34:38.694] - result already collected: FutureResult
[13:34:38.695] result() for ClusterFuture ... done
[13:34:38.695] result() for ClusterFuture ...
[13:34:38.695] - result already collected: FutureResult
[13:34:38.695] result() for ClusterFuture ... done
[13:34:38.695] result() for ClusterFuture ...
[13:34:38.695] - result already collected: FutureResult
[13:34:38.695] result() for ClusterFuture ... done
[13:34:38.695] result() for ClusterFuture ...
[13:34:38.695] - result already collected: FutureResult
[13:34:38.695] result() for ClusterFuture ... done
[13:34:38.695] - relayed: [n=2] TRUE, TRUE
[13:34:38.695] - queued futures: [n=2] TRUE, TRUE
[13:34:38.696] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:38.696]  length: 0 (resolved future 2)
[13:34:38.696] Relaying remaining futures
[13:34:38.696] signalConditionsASAP(NULL, pos=0) ...
[13:34:38.696] - nx: 2
[13:34:38.696] - relay: TRUE
[13:34:38.696] - stdout: TRUE
[13:34:38.696] - signal: TRUE
[13:34:38.696] - resignal: FALSE
[13:34:38.696] - force: TRUE
[13:34:38.696] - relayed: [n=2] TRUE, TRUE
[13:34:38.696] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:38.697] - relayed: [n=2] TRUE, TRUE
[13:34:38.697] - queued futures: [n=2] TRUE, TRUE
[13:34:38.697] signalConditionsASAP(NULL, pos=0) ... done
[13:34:38.697] resolve() on list ... DONE
[13:34:38.697] result() for ClusterFuture ...
[13:34:38.697] - result already collected: FutureResult
[13:34:38.697] result() for ClusterFuture ... done
[13:34:38.697] result() for ClusterFuture ...
[13:34:38.697] - result already collected: FutureResult
[13:34:38.697] result() for ClusterFuture ... done
[13:34:38.697] result() for ClusterFuture ...
[13:34:38.698] - result already collected: FutureResult
[13:34:38.698] result() for ClusterFuture ... done
[13:34:38.698] result() for ClusterFuture ...
[13:34:38.698] - result already collected: FutureResult
[13:34:38.698] result() for ClusterFuture ... done
[13:34:38.698]  - Number of value chunks collected: 2
[13:34:38.698] Resolving 2 futures (chunks) ... DONE
[13:34:38.698] Reducing values from 2 chunks ...
[13:34:38.698]  - Number of values collected after concatenation: 4
[13:34:38.698]  - Number of values expected: 4
[13:34:38.698] Reducing values from 2 chunks ... DONE
[13:34:38.698] future_mapply() ... DONE
[13:34:38.699] future_mapply() ...
[13:34:38.702] Number of chunks: 2
[13:34:38.702] getGlobalsAndPackagesXApply() ...
[13:34:38.702]  - future.globals: TRUE
[13:34:38.702] getGlobalsAndPackages() ...
[13:34:38.703] Searching for globals...
[13:34:38.704] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[13:34:38.704] Searching for globals ... DONE
[13:34:38.704] Resolving globals: FALSE
[13:34:38.704] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[13:34:38.705] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[13:34:38.705] - globals: [1] ‘FUN’
[13:34:38.705] 
[13:34:38.705] getGlobalsAndPackages() ... DONE
[13:34:38.705]  - globals found/used: [n=1] ‘FUN’
[13:34:38.705]  - needed namespaces: [n=0] 
[13:34:38.705] Finding globals ... DONE
[13:34:38.705] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:38.705] List of 2
[13:34:38.705]  $ ...future.FUN:function (x, y)  
[13:34:38.705]  $ MoreArgs     : NULL
[13:34:38.705]  - attr(*, "where")=List of 2
[13:34:38.705]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:38.705]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:38.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:38.705]  - attr(*, "resolved")= logi FALSE
[13:34:38.705]  - attr(*, "total_size")= num NA
[13:34:38.708] Packages to be attached in all futures: [n=0] 
[13:34:38.708] getGlobalsAndPackagesXApply() ... DONE
[13:34:38.708] Number of futures (= number of chunks): 2
[13:34:38.708] Launching 2 futures (chunks) ...
[13:34:38.708] Chunk #1 of 2 ...
[13:34:38.708]  - Finding globals in '...' for chunk #1 ...
[13:34:38.709] getGlobalsAndPackages() ...
[13:34:38.709] Searching for globals...
[13:34:38.709] 
[13:34:38.709] Searching for globals ... DONE
[13:34:38.709] - globals: [0] <none>
[13:34:38.709] getGlobalsAndPackages() ... DONE
[13:34:38.709]    + additional globals found: [n=0] 
[13:34:38.709]    + additional namespaces needed: [n=0] 
[13:34:38.709]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:38.710]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.710]  - seeds: <none>
[13:34:38.710]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.710] getGlobalsAndPackages() ...
[13:34:38.710] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.710] Resolving globals: FALSE
[13:34:38.710] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[13:34:38.711] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:38.711] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.711] 
[13:34:38.711] getGlobalsAndPackages() ... DONE
[13:34:38.711] run() for ‘Future’ ...
[13:34:38.712] - state: ‘created’
[13:34:38.712] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.725] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.725] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.725]   - Field: ‘node’
[13:34:38.725]   - Field: ‘label’
[13:34:38.725]   - Field: ‘local’
[13:34:38.725]   - Field: ‘owner’
[13:34:38.726]   - Field: ‘envir’
[13:34:38.726]   - Field: ‘workers’
[13:34:38.726]   - Field: ‘packages’
[13:34:38.726]   - Field: ‘gc’
[13:34:38.726]   - Field: ‘conditions’
[13:34:38.726]   - Field: ‘persistent’
[13:34:38.726]   - Field: ‘expr’
[13:34:38.726]   - Field: ‘uuid’
[13:34:38.726]   - Field: ‘seed’
[13:34:38.726]   - Field: ‘version’
[13:34:38.726]   - Field: ‘result’
[13:34:38.727]   - Field: ‘asynchronous’
[13:34:38.727]   - Field: ‘calls’
[13:34:38.727]   - Field: ‘globals’
[13:34:38.727]   - Field: ‘stdout’
[13:34:38.727]   - Field: ‘earlySignal’
[13:34:38.727]   - Field: ‘lazy’
[13:34:38.727]   - Field: ‘state’
[13:34:38.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.727] - Launch lazy future ...
[13:34:38.728] Packages needed by the future expression (n = 0): <none>
[13:34:38.728] Packages needed by future strategies (n = 0): <none>
[13:34:38.728] {
[13:34:38.728]     {
[13:34:38.728]         {
[13:34:38.728]             ...future.startTime <- base::Sys.time()
[13:34:38.728]             {
[13:34:38.728]                 {
[13:34:38.728]                   {
[13:34:38.728]                     {
[13:34:38.728]                       base::local({
[13:34:38.728]                         has_future <- base::requireNamespace("future", 
[13:34:38.728]                           quietly = TRUE)
[13:34:38.728]                         if (has_future) {
[13:34:38.728]                           ns <- base::getNamespace("future")
[13:34:38.728]                           version <- ns[[".package"]][["version"]]
[13:34:38.728]                           if (is.null(version)) 
[13:34:38.728]                             version <- utils::packageVersion("future")
[13:34:38.728]                         }
[13:34:38.728]                         else {
[13:34:38.728]                           version <- NULL
[13:34:38.728]                         }
[13:34:38.728]                         if (!has_future || version < "1.8.0") {
[13:34:38.728]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.728]                             "", base::R.version$version.string), 
[13:34:38.728]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.728]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.728]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.728]                               "release", "version")], collapse = " "), 
[13:34:38.728]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.728]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.728]                             info)
[13:34:38.728]                           info <- base::paste(info, collapse = "; ")
[13:34:38.728]                           if (!has_future) {
[13:34:38.728]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.728]                               info)
[13:34:38.728]                           }
[13:34:38.728]                           else {
[13:34:38.728]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.728]                               info, version)
[13:34:38.728]                           }
[13:34:38.728]                           base::stop(msg)
[13:34:38.728]                         }
[13:34:38.728]                       })
[13:34:38.728]                     }
[13:34:38.728]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.728]                     base::options(mc.cores = 1L)
[13:34:38.728]                   }
[13:34:38.728]                   ...future.strategy.old <- future::plan("list")
[13:34:38.728]                   options(future.plan = NULL)
[13:34:38.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.728]                 }
[13:34:38.728]                 ...future.workdir <- getwd()
[13:34:38.728]             }
[13:34:38.728]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.728]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.728]         }
[13:34:38.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.728]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.728]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.728]             base::names(...future.oldOptions))
[13:34:38.728]     }
[13:34:38.728]     if (FALSE) {
[13:34:38.728]     }
[13:34:38.728]     else {
[13:34:38.728]         if (TRUE) {
[13:34:38.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.728]                 open = "w")
[13:34:38.728]         }
[13:34:38.728]         else {
[13:34:38.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.728]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.728]         }
[13:34:38.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.728]             base::sink(type = "output", split = FALSE)
[13:34:38.728]             base::close(...future.stdout)
[13:34:38.728]         }, add = TRUE)
[13:34:38.728]     }
[13:34:38.728]     ...future.frame <- base::sys.nframe()
[13:34:38.728]     ...future.conditions <- base::list()
[13:34:38.728]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.728]     if (FALSE) {
[13:34:38.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.728]     }
[13:34:38.728]     ...future.result <- base::tryCatch({
[13:34:38.728]         base::withCallingHandlers({
[13:34:38.728]             ...future.value <- base::withVisible(base::local({
[13:34:38.728]                 ...future.makeSendCondition <- base::local({
[13:34:38.728]                   sendCondition <- NULL
[13:34:38.728]                   function(frame = 1L) {
[13:34:38.728]                     if (is.function(sendCondition)) 
[13:34:38.728]                       return(sendCondition)
[13:34:38.728]                     ns <- getNamespace("parallel")
[13:34:38.728]                     if (exists("sendData", mode = "function", 
[13:34:38.728]                       envir = ns)) {
[13:34:38.728]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.728]                         envir = ns)
[13:34:38.728]                       envir <- sys.frame(frame)
[13:34:38.728]                       master <- NULL
[13:34:38.728]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.728]                         !identical(envir, emptyenv())) {
[13:34:38.728]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.728]                           inherits = FALSE)) {
[13:34:38.728]                           master <- get("master", mode = "list", 
[13:34:38.728]                             envir = envir, inherits = FALSE)
[13:34:38.728]                           if (inherits(master, c("SOCKnode", 
[13:34:38.728]                             "SOCK0node"))) {
[13:34:38.728]                             sendCondition <<- function(cond) {
[13:34:38.728]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.728]                                 success = TRUE)
[13:34:38.728]                               parallel_sendData(master, data)
[13:34:38.728]                             }
[13:34:38.728]                             return(sendCondition)
[13:34:38.728]                           }
[13:34:38.728]                         }
[13:34:38.728]                         frame <- frame + 1L
[13:34:38.728]                         envir <- sys.frame(frame)
[13:34:38.728]                       }
[13:34:38.728]                     }
[13:34:38.728]                     sendCondition <<- function(cond) NULL
[13:34:38.728]                   }
[13:34:38.728]                 })
[13:34:38.728]                 withCallingHandlers({
[13:34:38.728]                   {
[13:34:38.728]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.728]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.728]                       ...future.globals.maxSize)) {
[13:34:38.728]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.728]                       on.exit(options(oopts), add = TRUE)
[13:34:38.728]                     }
[13:34:38.728]                     {
[13:34:38.728]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.728]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.728]                         USE.NAMES = FALSE)
[13:34:38.728]                       do.call(mapply, args = args)
[13:34:38.728]                     }
[13:34:38.728]                   }
[13:34:38.728]                 }, immediateCondition = function(cond) {
[13:34:38.728]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.728]                   sendCondition(cond)
[13:34:38.728]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.728]                   {
[13:34:38.728]                     inherits <- base::inherits
[13:34:38.728]                     invokeRestart <- base::invokeRestart
[13:34:38.728]                     is.null <- base::is.null
[13:34:38.728]                     muffled <- FALSE
[13:34:38.728]                     if (inherits(cond, "message")) {
[13:34:38.728]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.728]                       if (muffled) 
[13:34:38.728]                         invokeRestart("muffleMessage")
[13:34:38.728]                     }
[13:34:38.728]                     else if (inherits(cond, "warning")) {
[13:34:38.728]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.728]                       if (muffled) 
[13:34:38.728]                         invokeRestart("muffleWarning")
[13:34:38.728]                     }
[13:34:38.728]                     else if (inherits(cond, "condition")) {
[13:34:38.728]                       if (!is.null(pattern)) {
[13:34:38.728]                         computeRestarts <- base::computeRestarts
[13:34:38.728]                         grepl <- base::grepl
[13:34:38.728]                         restarts <- computeRestarts(cond)
[13:34:38.728]                         for (restart in restarts) {
[13:34:38.728]                           name <- restart$name
[13:34:38.728]                           if (is.null(name)) 
[13:34:38.728]                             next
[13:34:38.728]                           if (!grepl(pattern, name)) 
[13:34:38.728]                             next
[13:34:38.728]                           invokeRestart(restart)
[13:34:38.728]                           muffled <- TRUE
[13:34:38.728]                           break
[13:34:38.728]                         }
[13:34:38.728]                       }
[13:34:38.728]                     }
[13:34:38.728]                     invisible(muffled)
[13:34:38.728]                   }
[13:34:38.728]                   muffleCondition(cond)
[13:34:38.728]                 })
[13:34:38.728]             }))
[13:34:38.728]             future::FutureResult(value = ...future.value$value, 
[13:34:38.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.728]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.728]                     ...future.globalenv.names))
[13:34:38.728]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.728]         }, condition = base::local({
[13:34:38.728]             c <- base::c
[13:34:38.728]             inherits <- base::inherits
[13:34:38.728]             invokeRestart <- base::invokeRestart
[13:34:38.728]             length <- base::length
[13:34:38.728]             list <- base::list
[13:34:38.728]             seq.int <- base::seq.int
[13:34:38.728]             signalCondition <- base::signalCondition
[13:34:38.728]             sys.calls <- base::sys.calls
[13:34:38.728]             `[[` <- base::`[[`
[13:34:38.728]             `+` <- base::`+`
[13:34:38.728]             `<<-` <- base::`<<-`
[13:34:38.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.728]                   3L)]
[13:34:38.728]             }
[13:34:38.728]             function(cond) {
[13:34:38.728]                 is_error <- inherits(cond, "error")
[13:34:38.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.728]                   NULL)
[13:34:38.728]                 if (is_error) {
[13:34:38.728]                   sessionInformation <- function() {
[13:34:38.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.728]                       search = base::search(), system = base::Sys.info())
[13:34:38.728]                   }
[13:34:38.728]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.728]                     cond$call), session = sessionInformation(), 
[13:34:38.728]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.728]                   signalCondition(cond)
[13:34:38.728]                 }
[13:34:38.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.728]                 "immediateCondition"))) {
[13:34:38.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.728]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.728]                   if (TRUE && !signal) {
[13:34:38.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.728]                     {
[13:34:38.728]                       inherits <- base::inherits
[13:34:38.728]                       invokeRestart <- base::invokeRestart
[13:34:38.728]                       is.null <- base::is.null
[13:34:38.728]                       muffled <- FALSE
[13:34:38.728]                       if (inherits(cond, "message")) {
[13:34:38.728]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.728]                         if (muffled) 
[13:34:38.728]                           invokeRestart("muffleMessage")
[13:34:38.728]                       }
[13:34:38.728]                       else if (inherits(cond, "warning")) {
[13:34:38.728]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.728]                         if (muffled) 
[13:34:38.728]                           invokeRestart("muffleWarning")
[13:34:38.728]                       }
[13:34:38.728]                       else if (inherits(cond, "condition")) {
[13:34:38.728]                         if (!is.null(pattern)) {
[13:34:38.728]                           computeRestarts <- base::computeRestarts
[13:34:38.728]                           grepl <- base::grepl
[13:34:38.728]                           restarts <- computeRestarts(cond)
[13:34:38.728]                           for (restart in restarts) {
[13:34:38.728]                             name <- restart$name
[13:34:38.728]                             if (is.null(name)) 
[13:34:38.728]                               next
[13:34:38.728]                             if (!grepl(pattern, name)) 
[13:34:38.728]                               next
[13:34:38.728]                             invokeRestart(restart)
[13:34:38.728]                             muffled <- TRUE
[13:34:38.728]                             break
[13:34:38.728]                           }
[13:34:38.728]                         }
[13:34:38.728]                       }
[13:34:38.728]                       invisible(muffled)
[13:34:38.728]                     }
[13:34:38.728]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.728]                   }
[13:34:38.728]                 }
[13:34:38.728]                 else {
[13:34:38.728]                   if (TRUE) {
[13:34:38.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.728]                     {
[13:34:38.728]                       inherits <- base::inherits
[13:34:38.728]                       invokeRestart <- base::invokeRestart
[13:34:38.728]                       is.null <- base::is.null
[13:34:38.728]                       muffled <- FALSE
[13:34:38.728]                       if (inherits(cond, "message")) {
[13:34:38.728]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.728]                         if (muffled) 
[13:34:38.728]                           invokeRestart("muffleMessage")
[13:34:38.728]                       }
[13:34:38.728]                       else if (inherits(cond, "warning")) {
[13:34:38.728]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.728]                         if (muffled) 
[13:34:38.728]                           invokeRestart("muffleWarning")
[13:34:38.728]                       }
[13:34:38.728]                       else if (inherits(cond, "condition")) {
[13:34:38.728]                         if (!is.null(pattern)) {
[13:34:38.728]                           computeRestarts <- base::computeRestarts
[13:34:38.728]                           grepl <- base::grepl
[13:34:38.728]                           restarts <- computeRestarts(cond)
[13:34:38.728]                           for (restart in restarts) {
[13:34:38.728]                             name <- restart$name
[13:34:38.728]                             if (is.null(name)) 
[13:34:38.728]                               next
[13:34:38.728]                             if (!grepl(pattern, name)) 
[13:34:38.728]                               next
[13:34:38.728]                             invokeRestart(restart)
[13:34:38.728]                             muffled <- TRUE
[13:34:38.728]                             break
[13:34:38.728]                           }
[13:34:38.728]                         }
[13:34:38.728]                       }
[13:34:38.728]                       invisible(muffled)
[13:34:38.728]                     }
[13:34:38.728]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.728]                   }
[13:34:38.728]                 }
[13:34:38.728]             }
[13:34:38.728]         }))
[13:34:38.728]     }, error = function(ex) {
[13:34:38.728]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.728]                 ...future.rng), started = ...future.startTime, 
[13:34:38.728]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.728]             version = "1.8"), class = "FutureResult")
[13:34:38.728]     }, finally = {
[13:34:38.728]         if (!identical(...future.workdir, getwd())) 
[13:34:38.728]             setwd(...future.workdir)
[13:34:38.728]         {
[13:34:38.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.728]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.728]             }
[13:34:38.728]             base::options(...future.oldOptions)
[13:34:38.728]             if (.Platform$OS.type == "windows") {
[13:34:38.728]                 old_names <- names(...future.oldEnvVars)
[13:34:38.728]                 envs <- base::Sys.getenv()
[13:34:38.728]                 names <- names(envs)
[13:34:38.728]                 common <- intersect(names, old_names)
[13:34:38.728]                 added <- setdiff(names, old_names)
[13:34:38.728]                 removed <- setdiff(old_names, names)
[13:34:38.728]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.728]                   envs[common]]
[13:34:38.728]                 NAMES <- toupper(changed)
[13:34:38.728]                 args <- list()
[13:34:38.728]                 for (kk in seq_along(NAMES)) {
[13:34:38.728]                   name <- changed[[kk]]
[13:34:38.728]                   NAME <- NAMES[[kk]]
[13:34:38.728]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.728]                     next
[13:34:38.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.728]                 }
[13:34:38.728]                 NAMES <- toupper(added)
[13:34:38.728]                 for (kk in seq_along(NAMES)) {
[13:34:38.728]                   name <- added[[kk]]
[13:34:38.728]                   NAME <- NAMES[[kk]]
[13:34:38.728]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.728]                     next
[13:34:38.728]                   args[[name]] <- ""
[13:34:38.728]                 }
[13:34:38.728]                 NAMES <- toupper(removed)
[13:34:38.728]                 for (kk in seq_along(NAMES)) {
[13:34:38.728]                   name <- removed[[kk]]
[13:34:38.728]                   NAME <- NAMES[[kk]]
[13:34:38.728]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.728]                     next
[13:34:38.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.728]                 }
[13:34:38.728]                 if (length(args) > 0) 
[13:34:38.728]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.728]             }
[13:34:38.728]             else {
[13:34:38.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.728]             }
[13:34:38.728]             {
[13:34:38.728]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.728]                   0L) {
[13:34:38.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.728]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.728]                   base::options(opts)
[13:34:38.728]                 }
[13:34:38.728]                 {
[13:34:38.728]                   {
[13:34:38.728]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.728]                     NULL
[13:34:38.728]                   }
[13:34:38.728]                   options(future.plan = NULL)
[13:34:38.728]                   if (is.na(NA_character_)) 
[13:34:38.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.728]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.728]                     .init = FALSE)
[13:34:38.728]                 }
[13:34:38.728]             }
[13:34:38.728]         }
[13:34:38.728]     })
[13:34:38.728]     if (TRUE) {
[13:34:38.728]         base::sink(type = "output", split = FALSE)
[13:34:38.728]         if (TRUE) {
[13:34:38.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.728]         }
[13:34:38.728]         else {
[13:34:38.728]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.728]         }
[13:34:38.728]         base::close(...future.stdout)
[13:34:38.728]         ...future.stdout <- NULL
[13:34:38.728]     }
[13:34:38.728]     ...future.result$conditions <- ...future.conditions
[13:34:38.728]     ...future.result$finished <- base::Sys.time()
[13:34:38.728]     ...future.result
[13:34:38.728] }
[13:34:38.731] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[13:34:38.731] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[13:34:38.731] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[13:34:38.731] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:38.731] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.732] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:34:38.732] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:34:38.732] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:38.732] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.732] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:38.733] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.733] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[13:34:38.733] MultisessionFuture started
[13:34:38.733] - Launch lazy future ... done
[13:34:38.733] run() for ‘MultisessionFuture’ ... done
[13:34:38.734] Created future:
[13:34:38.734] MultisessionFuture:
[13:34:38.734] Label: ‘future_mapply-1’
[13:34:38.734] Expression:
[13:34:38.734] {
[13:34:38.734]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.734]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.734]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.734]         on.exit(options(oopts), add = TRUE)
[13:34:38.734]     }
[13:34:38.734]     {
[13:34:38.734]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.734]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.734]         do.call(mapply, args = args)
[13:34:38.734]     }
[13:34:38.734] }
[13:34:38.734] Lazy evaluation: FALSE
[13:34:38.734] Asynchronous evaluation: TRUE
[13:34:38.734] Local evaluation: TRUE
[13:34:38.734] Environment: R_GlobalEnv
[13:34:38.734] Capture standard output: TRUE
[13:34:38.734] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.734] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.734] Packages: <none>
[13:34:38.734] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.734] Resolved: FALSE
[13:34:38.734] Value: <not collected>
[13:34:38.734] Conditions captured: <none>
[13:34:38.734] Early signaling: FALSE
[13:34:38.734] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.734] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.745] Chunk #1 of 2 ... DONE
[13:34:38.745] Chunk #2 of 2 ...
[13:34:38.745]  - Finding globals in '...' for chunk #2 ...
[13:34:38.745] getGlobalsAndPackages() ...
[13:34:38.745] Searching for globals...
[13:34:38.746] 
[13:34:38.746] Searching for globals ... DONE
[13:34:38.746] - globals: [0] <none>
[13:34:38.746] getGlobalsAndPackages() ... DONE
[13:34:38.746]    + additional globals found: [n=0] 
[13:34:38.746]    + additional namespaces needed: [n=0] 
[13:34:38.746]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:38.746]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.746]  - seeds: <none>
[13:34:38.747]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.747] getGlobalsAndPackages() ...
[13:34:38.747] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.747] Resolving globals: FALSE
[13:34:38.747] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[13:34:38.748] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:38.748] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.748] 
[13:34:38.748] getGlobalsAndPackages() ... DONE
[13:34:38.748] run() for ‘Future’ ...
[13:34:38.748] - state: ‘created’
[13:34:38.748] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.762] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.762] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.762]   - Field: ‘node’
[13:34:38.762]   - Field: ‘label’
[13:34:38.762]   - Field: ‘local’
[13:34:38.762]   - Field: ‘owner’
[13:34:38.762]   - Field: ‘envir’
[13:34:38.762]   - Field: ‘workers’
[13:34:38.762]   - Field: ‘packages’
[13:34:38.763]   - Field: ‘gc’
[13:34:38.763]   - Field: ‘conditions’
[13:34:38.763]   - Field: ‘persistent’
[13:34:38.763]   - Field: ‘expr’
[13:34:38.763]   - Field: ‘uuid’
[13:34:38.763]   - Field: ‘seed’
[13:34:38.763]   - Field: ‘version’
[13:34:38.763]   - Field: ‘result’
[13:34:38.763]   - Field: ‘asynchronous’
[13:34:38.763]   - Field: ‘calls’
[13:34:38.763]   - Field: ‘globals’
[13:34:38.764]   - Field: ‘stdout’
[13:34:38.764]   - Field: ‘earlySignal’
[13:34:38.764]   - Field: ‘lazy’
[13:34:38.764]   - Field: ‘state’
[13:34:38.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.764] - Launch lazy future ...
[13:34:38.764] Packages needed by the future expression (n = 0): <none>
[13:34:38.764] Packages needed by future strategies (n = 0): <none>
[13:34:38.765] {
[13:34:38.765]     {
[13:34:38.765]         {
[13:34:38.765]             ...future.startTime <- base::Sys.time()
[13:34:38.765]             {
[13:34:38.765]                 {
[13:34:38.765]                   {
[13:34:38.765]                     {
[13:34:38.765]                       base::local({
[13:34:38.765]                         has_future <- base::requireNamespace("future", 
[13:34:38.765]                           quietly = TRUE)
[13:34:38.765]                         if (has_future) {
[13:34:38.765]                           ns <- base::getNamespace("future")
[13:34:38.765]                           version <- ns[[".package"]][["version"]]
[13:34:38.765]                           if (is.null(version)) 
[13:34:38.765]                             version <- utils::packageVersion("future")
[13:34:38.765]                         }
[13:34:38.765]                         else {
[13:34:38.765]                           version <- NULL
[13:34:38.765]                         }
[13:34:38.765]                         if (!has_future || version < "1.8.0") {
[13:34:38.765]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.765]                             "", base::R.version$version.string), 
[13:34:38.765]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.765]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.765]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.765]                               "release", "version")], collapse = " "), 
[13:34:38.765]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.765]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.765]                             info)
[13:34:38.765]                           info <- base::paste(info, collapse = "; ")
[13:34:38.765]                           if (!has_future) {
[13:34:38.765]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.765]                               info)
[13:34:38.765]                           }
[13:34:38.765]                           else {
[13:34:38.765]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.765]                               info, version)
[13:34:38.765]                           }
[13:34:38.765]                           base::stop(msg)
[13:34:38.765]                         }
[13:34:38.765]                       })
[13:34:38.765]                     }
[13:34:38.765]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.765]                     base::options(mc.cores = 1L)
[13:34:38.765]                   }
[13:34:38.765]                   ...future.strategy.old <- future::plan("list")
[13:34:38.765]                   options(future.plan = NULL)
[13:34:38.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.765]                 }
[13:34:38.765]                 ...future.workdir <- getwd()
[13:34:38.765]             }
[13:34:38.765]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.765]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.765]         }
[13:34:38.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.765]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.765]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.765]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.765]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.765]             base::names(...future.oldOptions))
[13:34:38.765]     }
[13:34:38.765]     if (FALSE) {
[13:34:38.765]     }
[13:34:38.765]     else {
[13:34:38.765]         if (TRUE) {
[13:34:38.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.765]                 open = "w")
[13:34:38.765]         }
[13:34:38.765]         else {
[13:34:38.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.765]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.765]         }
[13:34:38.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.765]             base::sink(type = "output", split = FALSE)
[13:34:38.765]             base::close(...future.stdout)
[13:34:38.765]         }, add = TRUE)
[13:34:38.765]     }
[13:34:38.765]     ...future.frame <- base::sys.nframe()
[13:34:38.765]     ...future.conditions <- base::list()
[13:34:38.765]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.765]     if (FALSE) {
[13:34:38.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.765]     }
[13:34:38.765]     ...future.result <- base::tryCatch({
[13:34:38.765]         base::withCallingHandlers({
[13:34:38.765]             ...future.value <- base::withVisible(base::local({
[13:34:38.765]                 ...future.makeSendCondition <- base::local({
[13:34:38.765]                   sendCondition <- NULL
[13:34:38.765]                   function(frame = 1L) {
[13:34:38.765]                     if (is.function(sendCondition)) 
[13:34:38.765]                       return(sendCondition)
[13:34:38.765]                     ns <- getNamespace("parallel")
[13:34:38.765]                     if (exists("sendData", mode = "function", 
[13:34:38.765]                       envir = ns)) {
[13:34:38.765]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.765]                         envir = ns)
[13:34:38.765]                       envir <- sys.frame(frame)
[13:34:38.765]                       master <- NULL
[13:34:38.765]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.765]                         !identical(envir, emptyenv())) {
[13:34:38.765]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.765]                           inherits = FALSE)) {
[13:34:38.765]                           master <- get("master", mode = "list", 
[13:34:38.765]                             envir = envir, inherits = FALSE)
[13:34:38.765]                           if (inherits(master, c("SOCKnode", 
[13:34:38.765]                             "SOCK0node"))) {
[13:34:38.765]                             sendCondition <<- function(cond) {
[13:34:38.765]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.765]                                 success = TRUE)
[13:34:38.765]                               parallel_sendData(master, data)
[13:34:38.765]                             }
[13:34:38.765]                             return(sendCondition)
[13:34:38.765]                           }
[13:34:38.765]                         }
[13:34:38.765]                         frame <- frame + 1L
[13:34:38.765]                         envir <- sys.frame(frame)
[13:34:38.765]                       }
[13:34:38.765]                     }
[13:34:38.765]                     sendCondition <<- function(cond) NULL
[13:34:38.765]                   }
[13:34:38.765]                 })
[13:34:38.765]                 withCallingHandlers({
[13:34:38.765]                   {
[13:34:38.765]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.765]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.765]                       ...future.globals.maxSize)) {
[13:34:38.765]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.765]                       on.exit(options(oopts), add = TRUE)
[13:34:38.765]                     }
[13:34:38.765]                     {
[13:34:38.765]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.765]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.765]                         USE.NAMES = FALSE)
[13:34:38.765]                       do.call(mapply, args = args)
[13:34:38.765]                     }
[13:34:38.765]                   }
[13:34:38.765]                 }, immediateCondition = function(cond) {
[13:34:38.765]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.765]                   sendCondition(cond)
[13:34:38.765]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.765]                   {
[13:34:38.765]                     inherits <- base::inherits
[13:34:38.765]                     invokeRestart <- base::invokeRestart
[13:34:38.765]                     is.null <- base::is.null
[13:34:38.765]                     muffled <- FALSE
[13:34:38.765]                     if (inherits(cond, "message")) {
[13:34:38.765]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.765]                       if (muffled) 
[13:34:38.765]                         invokeRestart("muffleMessage")
[13:34:38.765]                     }
[13:34:38.765]                     else if (inherits(cond, "warning")) {
[13:34:38.765]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.765]                       if (muffled) 
[13:34:38.765]                         invokeRestart("muffleWarning")
[13:34:38.765]                     }
[13:34:38.765]                     else if (inherits(cond, "condition")) {
[13:34:38.765]                       if (!is.null(pattern)) {
[13:34:38.765]                         computeRestarts <- base::computeRestarts
[13:34:38.765]                         grepl <- base::grepl
[13:34:38.765]                         restarts <- computeRestarts(cond)
[13:34:38.765]                         for (restart in restarts) {
[13:34:38.765]                           name <- restart$name
[13:34:38.765]                           if (is.null(name)) 
[13:34:38.765]                             next
[13:34:38.765]                           if (!grepl(pattern, name)) 
[13:34:38.765]                             next
[13:34:38.765]                           invokeRestart(restart)
[13:34:38.765]                           muffled <- TRUE
[13:34:38.765]                           break
[13:34:38.765]                         }
[13:34:38.765]                       }
[13:34:38.765]                     }
[13:34:38.765]                     invisible(muffled)
[13:34:38.765]                   }
[13:34:38.765]                   muffleCondition(cond)
[13:34:38.765]                 })
[13:34:38.765]             }))
[13:34:38.765]             future::FutureResult(value = ...future.value$value, 
[13:34:38.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.765]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.765]                     ...future.globalenv.names))
[13:34:38.765]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.765]         }, condition = base::local({
[13:34:38.765]             c <- base::c
[13:34:38.765]             inherits <- base::inherits
[13:34:38.765]             invokeRestart <- base::invokeRestart
[13:34:38.765]             length <- base::length
[13:34:38.765]             list <- base::list
[13:34:38.765]             seq.int <- base::seq.int
[13:34:38.765]             signalCondition <- base::signalCondition
[13:34:38.765]             sys.calls <- base::sys.calls
[13:34:38.765]             `[[` <- base::`[[`
[13:34:38.765]             `+` <- base::`+`
[13:34:38.765]             `<<-` <- base::`<<-`
[13:34:38.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.765]                   3L)]
[13:34:38.765]             }
[13:34:38.765]             function(cond) {
[13:34:38.765]                 is_error <- inherits(cond, "error")
[13:34:38.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.765]                   NULL)
[13:34:38.765]                 if (is_error) {
[13:34:38.765]                   sessionInformation <- function() {
[13:34:38.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.765]                       search = base::search(), system = base::Sys.info())
[13:34:38.765]                   }
[13:34:38.765]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.765]                     cond$call), session = sessionInformation(), 
[13:34:38.765]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.765]                   signalCondition(cond)
[13:34:38.765]                 }
[13:34:38.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.765]                 "immediateCondition"))) {
[13:34:38.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.765]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.765]                   if (TRUE && !signal) {
[13:34:38.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.765]                     {
[13:34:38.765]                       inherits <- base::inherits
[13:34:38.765]                       invokeRestart <- base::invokeRestart
[13:34:38.765]                       is.null <- base::is.null
[13:34:38.765]                       muffled <- FALSE
[13:34:38.765]                       if (inherits(cond, "message")) {
[13:34:38.765]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.765]                         if (muffled) 
[13:34:38.765]                           invokeRestart("muffleMessage")
[13:34:38.765]                       }
[13:34:38.765]                       else if (inherits(cond, "warning")) {
[13:34:38.765]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.765]                         if (muffled) 
[13:34:38.765]                           invokeRestart("muffleWarning")
[13:34:38.765]                       }
[13:34:38.765]                       else if (inherits(cond, "condition")) {
[13:34:38.765]                         if (!is.null(pattern)) {
[13:34:38.765]                           computeRestarts <- base::computeRestarts
[13:34:38.765]                           grepl <- base::grepl
[13:34:38.765]                           restarts <- computeRestarts(cond)
[13:34:38.765]                           for (restart in restarts) {
[13:34:38.765]                             name <- restart$name
[13:34:38.765]                             if (is.null(name)) 
[13:34:38.765]                               next
[13:34:38.765]                             if (!grepl(pattern, name)) 
[13:34:38.765]                               next
[13:34:38.765]                             invokeRestart(restart)
[13:34:38.765]                             muffled <- TRUE
[13:34:38.765]                             break
[13:34:38.765]                           }
[13:34:38.765]                         }
[13:34:38.765]                       }
[13:34:38.765]                       invisible(muffled)
[13:34:38.765]                     }
[13:34:38.765]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.765]                   }
[13:34:38.765]                 }
[13:34:38.765]                 else {
[13:34:38.765]                   if (TRUE) {
[13:34:38.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.765]                     {
[13:34:38.765]                       inherits <- base::inherits
[13:34:38.765]                       invokeRestart <- base::invokeRestart
[13:34:38.765]                       is.null <- base::is.null
[13:34:38.765]                       muffled <- FALSE
[13:34:38.765]                       if (inherits(cond, "message")) {
[13:34:38.765]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.765]                         if (muffled) 
[13:34:38.765]                           invokeRestart("muffleMessage")
[13:34:38.765]                       }
[13:34:38.765]                       else if (inherits(cond, "warning")) {
[13:34:38.765]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.765]                         if (muffled) 
[13:34:38.765]                           invokeRestart("muffleWarning")
[13:34:38.765]                       }
[13:34:38.765]                       else if (inherits(cond, "condition")) {
[13:34:38.765]                         if (!is.null(pattern)) {
[13:34:38.765]                           computeRestarts <- base::computeRestarts
[13:34:38.765]                           grepl <- base::grepl
[13:34:38.765]                           restarts <- computeRestarts(cond)
[13:34:38.765]                           for (restart in restarts) {
[13:34:38.765]                             name <- restart$name
[13:34:38.765]                             if (is.null(name)) 
[13:34:38.765]                               next
[13:34:38.765]                             if (!grepl(pattern, name)) 
[13:34:38.765]                               next
[13:34:38.765]                             invokeRestart(restart)
[13:34:38.765]                             muffled <- TRUE
[13:34:38.765]                             break
[13:34:38.765]                           }
[13:34:38.765]                         }
[13:34:38.765]                       }
[13:34:38.765]                       invisible(muffled)
[13:34:38.765]                     }
[13:34:38.765]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.765]                   }
[13:34:38.765]                 }
[13:34:38.765]             }
[13:34:38.765]         }))
[13:34:38.765]     }, error = function(ex) {
[13:34:38.765]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.765]                 ...future.rng), started = ...future.startTime, 
[13:34:38.765]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.765]             version = "1.8"), class = "FutureResult")
[13:34:38.765]     }, finally = {
[13:34:38.765]         if (!identical(...future.workdir, getwd())) 
[13:34:38.765]             setwd(...future.workdir)
[13:34:38.765]         {
[13:34:38.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.765]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.765]             }
[13:34:38.765]             base::options(...future.oldOptions)
[13:34:38.765]             if (.Platform$OS.type == "windows") {
[13:34:38.765]                 old_names <- names(...future.oldEnvVars)
[13:34:38.765]                 envs <- base::Sys.getenv()
[13:34:38.765]                 names <- names(envs)
[13:34:38.765]                 common <- intersect(names, old_names)
[13:34:38.765]                 added <- setdiff(names, old_names)
[13:34:38.765]                 removed <- setdiff(old_names, names)
[13:34:38.765]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.765]                   envs[common]]
[13:34:38.765]                 NAMES <- toupper(changed)
[13:34:38.765]                 args <- list()
[13:34:38.765]                 for (kk in seq_along(NAMES)) {
[13:34:38.765]                   name <- changed[[kk]]
[13:34:38.765]                   NAME <- NAMES[[kk]]
[13:34:38.765]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.765]                     next
[13:34:38.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.765]                 }
[13:34:38.765]                 NAMES <- toupper(added)
[13:34:38.765]                 for (kk in seq_along(NAMES)) {
[13:34:38.765]                   name <- added[[kk]]
[13:34:38.765]                   NAME <- NAMES[[kk]]
[13:34:38.765]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.765]                     next
[13:34:38.765]                   args[[name]] <- ""
[13:34:38.765]                 }
[13:34:38.765]                 NAMES <- toupper(removed)
[13:34:38.765]                 for (kk in seq_along(NAMES)) {
[13:34:38.765]                   name <- removed[[kk]]
[13:34:38.765]                   NAME <- NAMES[[kk]]
[13:34:38.765]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.765]                     next
[13:34:38.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.765]                 }
[13:34:38.765]                 if (length(args) > 0) 
[13:34:38.765]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.765]             }
[13:34:38.765]             else {
[13:34:38.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.765]             }
[13:34:38.765]             {
[13:34:38.765]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.765]                   0L) {
[13:34:38.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.765]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.765]                   base::options(opts)
[13:34:38.765]                 }
[13:34:38.765]                 {
[13:34:38.765]                   {
[13:34:38.765]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.765]                     NULL
[13:34:38.765]                   }
[13:34:38.765]                   options(future.plan = NULL)
[13:34:38.765]                   if (is.na(NA_character_)) 
[13:34:38.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.765]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.765]                     .init = FALSE)
[13:34:38.765]                 }
[13:34:38.765]             }
[13:34:38.765]         }
[13:34:38.765]     })
[13:34:38.765]     if (TRUE) {
[13:34:38.765]         base::sink(type = "output", split = FALSE)
[13:34:38.765]         if (TRUE) {
[13:34:38.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.765]         }
[13:34:38.765]         else {
[13:34:38.765]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.765]         }
[13:34:38.765]         base::close(...future.stdout)
[13:34:38.765]         ...future.stdout <- NULL
[13:34:38.765]     }
[13:34:38.765]     ...future.result$conditions <- ...future.conditions
[13:34:38.765]     ...future.result$finished <- base::Sys.time()
[13:34:38.765]     ...future.result
[13:34:38.765] }
[13:34:38.767] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[13:34:38.767] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[13:34:38.768] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[13:34:38.768] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:38.768] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.768] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[13:34:38.769] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[13:34:38.769] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:38.769] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.769] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:38.769] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.769] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[13:34:38.770] MultisessionFuture started
[13:34:38.770] - Launch lazy future ... done
[13:34:38.770] run() for ‘MultisessionFuture’ ... done
[13:34:38.770] Created future:
[13:34:38.770] MultisessionFuture:
[13:34:38.770] Label: ‘future_mapply-2’
[13:34:38.770] Expression:
[13:34:38.770] {
[13:34:38.770]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.770]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.770]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.770]         on.exit(options(oopts), add = TRUE)
[13:34:38.770]     }
[13:34:38.770]     {
[13:34:38.770]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.770]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.770]         do.call(mapply, args = args)
[13:34:38.770]     }
[13:34:38.770] }
[13:34:38.770] Lazy evaluation: FALSE
[13:34:38.770] Asynchronous evaluation: TRUE
[13:34:38.770] Local evaluation: TRUE
[13:34:38.770] Environment: R_GlobalEnv
[13:34:38.770] Capture standard output: TRUE
[13:34:38.770] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.770] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.770] Packages: <none>
[13:34:38.770] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.770] Resolved: FALSE
[13:34:38.770] Value: <not collected>
[13:34:38.770] Conditions captured: <none>
[13:34:38.770] Early signaling: FALSE
[13:34:38.770] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.770] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.782] Chunk #2 of 2 ... DONE
[13:34:38.782] Launching 2 futures (chunks) ... DONE
[13:34:38.782] Resolving 2 futures (chunks) ...
[13:34:38.782] resolve() on list ...
[13:34:38.782]  recursive: 0
[13:34:38.782]  length: 2
[13:34:38.782] 
[13:34:38.783] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.783] - Validating connection of MultisessionFuture
[13:34:38.783] - received message: FutureResult
[13:34:38.783] - Received FutureResult
[13:34:38.783] - Erased future from FutureRegistry
[13:34:38.783] result() for ClusterFuture ...
[13:34:38.783] - result already collected: FutureResult
[13:34:38.784] result() for ClusterFuture ... done
[13:34:38.784] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.784] Future #1
[13:34:38.784] result() for ClusterFuture ...
[13:34:38.784] - result already collected: FutureResult
[13:34:38.784] result() for ClusterFuture ... done
[13:34:38.784] result() for ClusterFuture ...
[13:34:38.784] - result already collected: FutureResult
[13:34:38.784] result() for ClusterFuture ... done
[13:34:38.784] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:38.784] - nx: 2
[13:34:38.785] - relay: TRUE
[13:34:38.785] - stdout: TRUE
[13:34:38.785] - signal: TRUE
[13:34:38.785] - resignal: FALSE
[13:34:38.785] - force: TRUE
[13:34:38.785] - relayed: [n=2] FALSE, FALSE
[13:34:38.785] - queued futures: [n=2] FALSE, FALSE
[13:34:38.785]  - until=1
[13:34:38.785]  - relaying element #1
[13:34:38.785] result() for ClusterFuture ...
[13:34:38.785] - result already collected: FutureResult
[13:34:38.785] result() for ClusterFuture ... done
[13:34:38.785] result() for ClusterFuture ...
[13:34:38.786] - result already collected: FutureResult
[13:34:38.786] result() for ClusterFuture ... done
[13:34:38.786] result() for ClusterFuture ...
[13:34:38.786] - result already collected: FutureResult
[13:34:38.786] result() for ClusterFuture ... done
[13:34:38.786] result() for ClusterFuture ...
[13:34:38.786] - result already collected: FutureResult
[13:34:38.786] result() for ClusterFuture ... done
[13:34:38.786] - relayed: [n=2] TRUE, FALSE
[13:34:38.786] - queued futures: [n=2] TRUE, FALSE
[13:34:38.787] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:38.787]  length: 1 (resolved future 1)
[13:34:38.812] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.812] - Validating connection of MultisessionFuture
[13:34:38.812] - received message: FutureResult
[13:34:38.812] - Received FutureResult
[13:34:38.812] - Erased future from FutureRegistry
[13:34:38.812] result() for ClusterFuture ...
[13:34:38.812] - result already collected: FutureResult
[13:34:38.812] result() for ClusterFuture ... done
[13:34:38.812] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.813] Future #2
[13:34:38.813] result() for ClusterFuture ...
[13:34:38.813] - result already collected: FutureResult
[13:34:38.813] result() for ClusterFuture ... done
[13:34:38.813] result() for ClusterFuture ...
[13:34:38.813] - result already collected: FutureResult
[13:34:38.813] result() for ClusterFuture ... done
[13:34:38.813] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:38.813] - nx: 2
[13:34:38.813] - relay: TRUE
[13:34:38.813] - stdout: TRUE
[13:34:38.813] - signal: TRUE
[13:34:38.814] - resignal: FALSE
[13:34:38.814] - force: TRUE
[13:34:38.814] - relayed: [n=2] TRUE, FALSE
[13:34:38.814] - queued futures: [n=2] TRUE, FALSE
[13:34:38.814]  - until=2
[13:34:38.814]  - relaying element #2
[13:34:38.814] result() for ClusterFuture ...
[13:34:38.814] - result already collected: FutureResult
[13:34:38.814] result() for ClusterFuture ... done
[13:34:38.814] result() for ClusterFuture ...
[13:34:38.814] - result already collected: FutureResult
[13:34:38.815] result() for ClusterFuture ... done
[13:34:38.815] result() for ClusterFuture ...
[13:34:38.815] - result already collected: FutureResult
[13:34:38.815] result() for ClusterFuture ... done
[13:34:38.815] result() for ClusterFuture ...
[13:34:38.815] - result already collected: FutureResult
[13:34:38.815] result() for ClusterFuture ... done
[13:34:38.815] - relayed: [n=2] TRUE, TRUE
[13:34:38.815] - queued futures: [n=2] TRUE, TRUE
[13:34:38.815] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:38.815]  length: 0 (resolved future 2)
[13:34:38.816] Relaying remaining futures
[13:34:38.816] signalConditionsASAP(NULL, pos=0) ...
[13:34:38.816] - nx: 2
[13:34:38.816] - relay: TRUE
[13:34:38.816] - stdout: TRUE
[13:34:38.816] - signal: TRUE
[13:34:38.816] - resignal: FALSE
[13:34:38.816] - force: TRUE
[13:34:38.816] - relayed: [n=2] TRUE, TRUE
[13:34:38.816] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:38.816] - relayed: [n=2] TRUE, TRUE
[13:34:38.816] - queued futures: [n=2] TRUE, TRUE
[13:34:38.817] signalConditionsASAP(NULL, pos=0) ... done
[13:34:38.817] resolve() on list ... DONE
[13:34:38.817] result() for ClusterFuture ...
[13:34:38.817] - result already collected: FutureResult
[13:34:38.817] result() for ClusterFuture ... done
[13:34:38.817] result() for ClusterFuture ...
[13:34:38.817] - result already collected: FutureResult
[13:34:38.817] result() for ClusterFuture ... done
[13:34:38.817] result() for ClusterFuture ...
[13:34:38.817] - result already collected: FutureResult
[13:34:38.817] result() for ClusterFuture ... done
[13:34:38.818] result() for ClusterFuture ...
[13:34:38.818] - result already collected: FutureResult
[13:34:38.818] result() for ClusterFuture ... done
[13:34:38.818]  - Number of value chunks collected: 2
[13:34:38.818] Resolving 2 futures (chunks) ... DONE
[13:34:38.818] Reducing values from 2 chunks ...
[13:34:38.818]  - Number of values collected after concatenation: 3
[13:34:38.818]  - Number of values expected: 3
[13:34:38.818] Reducing values from 2 chunks ... DONE
[13:34:38.818] future_mapply() ... DONE
- future_.mapply()
[13:34:38.819] future_mapply() ...
[13:34:38.822] Number of chunks: 2
[13:34:38.822] getGlobalsAndPackagesXApply() ...
[13:34:38.822]  - future.globals: TRUE
[13:34:38.822] getGlobalsAndPackages() ...
[13:34:38.822] Searching for globals...
[13:34:38.824] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[13:34:38.824] Searching for globals ... DONE
[13:34:38.824] Resolving globals: FALSE
[13:34:38.824] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[13:34:38.824] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[13:34:38.825] - globals: [1] ‘FUN’
[13:34:38.825] 
[13:34:38.825] getGlobalsAndPackages() ... DONE
[13:34:38.825]  - globals found/used: [n=1] ‘FUN’
[13:34:38.825]  - needed namespaces: [n=0] 
[13:34:38.825] Finding globals ... DONE
[13:34:38.825] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:38.825] List of 2
[13:34:38.825]  $ ...future.FUN:function (x, y)  
[13:34:38.825]  $ MoreArgs     : list()
[13:34:38.825]  - attr(*, "where")=List of 2
[13:34:38.825]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:38.825]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:38.825]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:38.825]  - attr(*, "resolved")= logi FALSE
[13:34:38.825]  - attr(*, "total_size")= num NA
[13:34:38.828] Packages to be attached in all futures: [n=0] 
[13:34:38.828] getGlobalsAndPackagesXApply() ... DONE
[13:34:38.828] Number of futures (= number of chunks): 2
[13:34:38.828] Launching 2 futures (chunks) ...
[13:34:38.828] Chunk #1 of 2 ...
[13:34:38.828]  - Finding globals in '...' for chunk #1 ...
[13:34:38.828] getGlobalsAndPackages() ...
[13:34:38.829] Searching for globals...
[13:34:38.829] 
[13:34:38.829] Searching for globals ... DONE
[13:34:38.829] - globals: [0] <none>
[13:34:38.829] getGlobalsAndPackages() ... DONE
[13:34:38.829]    + additional globals found: [n=0] 
[13:34:38.829]    + additional namespaces needed: [n=0] 
[13:34:38.829]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:38.829]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.830]  - seeds: <none>
[13:34:38.830]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.830] getGlobalsAndPackages() ...
[13:34:38.830] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.830] Resolving globals: FALSE
[13:34:38.830] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[13:34:38.831] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:38.831] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.831] 
[13:34:38.831] getGlobalsAndPackages() ... DONE
[13:34:38.831] run() for ‘Future’ ...
[13:34:38.832] - state: ‘created’
[13:34:38.832] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.847] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.847]   - Field: ‘node’
[13:34:38.848]   - Field: ‘label’
[13:34:38.848]   - Field: ‘local’
[13:34:38.848]   - Field: ‘owner’
[13:34:38.848]   - Field: ‘envir’
[13:34:38.848]   - Field: ‘workers’
[13:34:38.848]   - Field: ‘packages’
[13:34:38.848]   - Field: ‘gc’
[13:34:38.848]   - Field: ‘conditions’
[13:34:38.848]   - Field: ‘persistent’
[13:34:38.848]   - Field: ‘expr’
[13:34:38.848]   - Field: ‘uuid’
[13:34:38.849]   - Field: ‘seed’
[13:34:38.849]   - Field: ‘version’
[13:34:38.849]   - Field: ‘result’
[13:34:38.849]   - Field: ‘asynchronous’
[13:34:38.849]   - Field: ‘calls’
[13:34:38.849]   - Field: ‘globals’
[13:34:38.849]   - Field: ‘stdout’
[13:34:38.849]   - Field: ‘earlySignal’
[13:34:38.849]   - Field: ‘lazy’
[13:34:38.849]   - Field: ‘state’
[13:34:38.849] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.849] - Launch lazy future ...
[13:34:38.850] Packages needed by the future expression (n = 0): <none>
[13:34:38.850] Packages needed by future strategies (n = 0): <none>
[13:34:38.850] {
[13:34:38.850]     {
[13:34:38.850]         {
[13:34:38.850]             ...future.startTime <- base::Sys.time()
[13:34:38.850]             {
[13:34:38.850]                 {
[13:34:38.850]                   {
[13:34:38.850]                     {
[13:34:38.850]                       base::local({
[13:34:38.850]                         has_future <- base::requireNamespace("future", 
[13:34:38.850]                           quietly = TRUE)
[13:34:38.850]                         if (has_future) {
[13:34:38.850]                           ns <- base::getNamespace("future")
[13:34:38.850]                           version <- ns[[".package"]][["version"]]
[13:34:38.850]                           if (is.null(version)) 
[13:34:38.850]                             version <- utils::packageVersion("future")
[13:34:38.850]                         }
[13:34:38.850]                         else {
[13:34:38.850]                           version <- NULL
[13:34:38.850]                         }
[13:34:38.850]                         if (!has_future || version < "1.8.0") {
[13:34:38.850]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.850]                             "", base::R.version$version.string), 
[13:34:38.850]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.850]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.850]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.850]                               "release", "version")], collapse = " "), 
[13:34:38.850]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.850]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.850]                             info)
[13:34:38.850]                           info <- base::paste(info, collapse = "; ")
[13:34:38.850]                           if (!has_future) {
[13:34:38.850]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.850]                               info)
[13:34:38.850]                           }
[13:34:38.850]                           else {
[13:34:38.850]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.850]                               info, version)
[13:34:38.850]                           }
[13:34:38.850]                           base::stop(msg)
[13:34:38.850]                         }
[13:34:38.850]                       })
[13:34:38.850]                     }
[13:34:38.850]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.850]                     base::options(mc.cores = 1L)
[13:34:38.850]                   }
[13:34:38.850]                   ...future.strategy.old <- future::plan("list")
[13:34:38.850]                   options(future.plan = NULL)
[13:34:38.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.850]                 }
[13:34:38.850]                 ...future.workdir <- getwd()
[13:34:38.850]             }
[13:34:38.850]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.850]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.850]         }
[13:34:38.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.850]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.850]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.850]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.850]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.850]             base::names(...future.oldOptions))
[13:34:38.850]     }
[13:34:38.850]     if (FALSE) {
[13:34:38.850]     }
[13:34:38.850]     else {
[13:34:38.850]         if (TRUE) {
[13:34:38.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.850]                 open = "w")
[13:34:38.850]         }
[13:34:38.850]         else {
[13:34:38.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.850]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.850]         }
[13:34:38.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.850]             base::sink(type = "output", split = FALSE)
[13:34:38.850]             base::close(...future.stdout)
[13:34:38.850]         }, add = TRUE)
[13:34:38.850]     }
[13:34:38.850]     ...future.frame <- base::sys.nframe()
[13:34:38.850]     ...future.conditions <- base::list()
[13:34:38.850]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.850]     if (FALSE) {
[13:34:38.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.850]     }
[13:34:38.850]     ...future.result <- base::tryCatch({
[13:34:38.850]         base::withCallingHandlers({
[13:34:38.850]             ...future.value <- base::withVisible(base::local({
[13:34:38.850]                 ...future.makeSendCondition <- base::local({
[13:34:38.850]                   sendCondition <- NULL
[13:34:38.850]                   function(frame = 1L) {
[13:34:38.850]                     if (is.function(sendCondition)) 
[13:34:38.850]                       return(sendCondition)
[13:34:38.850]                     ns <- getNamespace("parallel")
[13:34:38.850]                     if (exists("sendData", mode = "function", 
[13:34:38.850]                       envir = ns)) {
[13:34:38.850]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.850]                         envir = ns)
[13:34:38.850]                       envir <- sys.frame(frame)
[13:34:38.850]                       master <- NULL
[13:34:38.850]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.850]                         !identical(envir, emptyenv())) {
[13:34:38.850]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.850]                           inherits = FALSE)) {
[13:34:38.850]                           master <- get("master", mode = "list", 
[13:34:38.850]                             envir = envir, inherits = FALSE)
[13:34:38.850]                           if (inherits(master, c("SOCKnode", 
[13:34:38.850]                             "SOCK0node"))) {
[13:34:38.850]                             sendCondition <<- function(cond) {
[13:34:38.850]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.850]                                 success = TRUE)
[13:34:38.850]                               parallel_sendData(master, data)
[13:34:38.850]                             }
[13:34:38.850]                             return(sendCondition)
[13:34:38.850]                           }
[13:34:38.850]                         }
[13:34:38.850]                         frame <- frame + 1L
[13:34:38.850]                         envir <- sys.frame(frame)
[13:34:38.850]                       }
[13:34:38.850]                     }
[13:34:38.850]                     sendCondition <<- function(cond) NULL
[13:34:38.850]                   }
[13:34:38.850]                 })
[13:34:38.850]                 withCallingHandlers({
[13:34:38.850]                   {
[13:34:38.850]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.850]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.850]                       ...future.globals.maxSize)) {
[13:34:38.850]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.850]                       on.exit(options(oopts), add = TRUE)
[13:34:38.850]                     }
[13:34:38.850]                     {
[13:34:38.850]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.850]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.850]                         USE.NAMES = FALSE)
[13:34:38.850]                       do.call(mapply, args = args)
[13:34:38.850]                     }
[13:34:38.850]                   }
[13:34:38.850]                 }, immediateCondition = function(cond) {
[13:34:38.850]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.850]                   sendCondition(cond)
[13:34:38.850]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.850]                   {
[13:34:38.850]                     inherits <- base::inherits
[13:34:38.850]                     invokeRestart <- base::invokeRestart
[13:34:38.850]                     is.null <- base::is.null
[13:34:38.850]                     muffled <- FALSE
[13:34:38.850]                     if (inherits(cond, "message")) {
[13:34:38.850]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.850]                       if (muffled) 
[13:34:38.850]                         invokeRestart("muffleMessage")
[13:34:38.850]                     }
[13:34:38.850]                     else if (inherits(cond, "warning")) {
[13:34:38.850]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.850]                       if (muffled) 
[13:34:38.850]                         invokeRestart("muffleWarning")
[13:34:38.850]                     }
[13:34:38.850]                     else if (inherits(cond, "condition")) {
[13:34:38.850]                       if (!is.null(pattern)) {
[13:34:38.850]                         computeRestarts <- base::computeRestarts
[13:34:38.850]                         grepl <- base::grepl
[13:34:38.850]                         restarts <- computeRestarts(cond)
[13:34:38.850]                         for (restart in restarts) {
[13:34:38.850]                           name <- restart$name
[13:34:38.850]                           if (is.null(name)) 
[13:34:38.850]                             next
[13:34:38.850]                           if (!grepl(pattern, name)) 
[13:34:38.850]                             next
[13:34:38.850]                           invokeRestart(restart)
[13:34:38.850]                           muffled <- TRUE
[13:34:38.850]                           break
[13:34:38.850]                         }
[13:34:38.850]                       }
[13:34:38.850]                     }
[13:34:38.850]                     invisible(muffled)
[13:34:38.850]                   }
[13:34:38.850]                   muffleCondition(cond)
[13:34:38.850]                 })
[13:34:38.850]             }))
[13:34:38.850]             future::FutureResult(value = ...future.value$value, 
[13:34:38.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.850]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.850]                     ...future.globalenv.names))
[13:34:38.850]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.850]         }, condition = base::local({
[13:34:38.850]             c <- base::c
[13:34:38.850]             inherits <- base::inherits
[13:34:38.850]             invokeRestart <- base::invokeRestart
[13:34:38.850]             length <- base::length
[13:34:38.850]             list <- base::list
[13:34:38.850]             seq.int <- base::seq.int
[13:34:38.850]             signalCondition <- base::signalCondition
[13:34:38.850]             sys.calls <- base::sys.calls
[13:34:38.850]             `[[` <- base::`[[`
[13:34:38.850]             `+` <- base::`+`
[13:34:38.850]             `<<-` <- base::`<<-`
[13:34:38.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.850]                   3L)]
[13:34:38.850]             }
[13:34:38.850]             function(cond) {
[13:34:38.850]                 is_error <- inherits(cond, "error")
[13:34:38.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.850]                   NULL)
[13:34:38.850]                 if (is_error) {
[13:34:38.850]                   sessionInformation <- function() {
[13:34:38.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.850]                       search = base::search(), system = base::Sys.info())
[13:34:38.850]                   }
[13:34:38.850]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.850]                     cond$call), session = sessionInformation(), 
[13:34:38.850]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.850]                   signalCondition(cond)
[13:34:38.850]                 }
[13:34:38.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.850]                 "immediateCondition"))) {
[13:34:38.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.850]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.850]                   if (TRUE && !signal) {
[13:34:38.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.850]                     {
[13:34:38.850]                       inherits <- base::inherits
[13:34:38.850]                       invokeRestart <- base::invokeRestart
[13:34:38.850]                       is.null <- base::is.null
[13:34:38.850]                       muffled <- FALSE
[13:34:38.850]                       if (inherits(cond, "message")) {
[13:34:38.850]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.850]                         if (muffled) 
[13:34:38.850]                           invokeRestart("muffleMessage")
[13:34:38.850]                       }
[13:34:38.850]                       else if (inherits(cond, "warning")) {
[13:34:38.850]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.850]                         if (muffled) 
[13:34:38.850]                           invokeRestart("muffleWarning")
[13:34:38.850]                       }
[13:34:38.850]                       else if (inherits(cond, "condition")) {
[13:34:38.850]                         if (!is.null(pattern)) {
[13:34:38.850]                           computeRestarts <- base::computeRestarts
[13:34:38.850]                           grepl <- base::grepl
[13:34:38.850]                           restarts <- computeRestarts(cond)
[13:34:38.850]                           for (restart in restarts) {
[13:34:38.850]                             name <- restart$name
[13:34:38.850]                             if (is.null(name)) 
[13:34:38.850]                               next
[13:34:38.850]                             if (!grepl(pattern, name)) 
[13:34:38.850]                               next
[13:34:38.850]                             invokeRestart(restart)
[13:34:38.850]                             muffled <- TRUE
[13:34:38.850]                             break
[13:34:38.850]                           }
[13:34:38.850]                         }
[13:34:38.850]                       }
[13:34:38.850]                       invisible(muffled)
[13:34:38.850]                     }
[13:34:38.850]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.850]                   }
[13:34:38.850]                 }
[13:34:38.850]                 else {
[13:34:38.850]                   if (TRUE) {
[13:34:38.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.850]                     {
[13:34:38.850]                       inherits <- base::inherits
[13:34:38.850]                       invokeRestart <- base::invokeRestart
[13:34:38.850]                       is.null <- base::is.null
[13:34:38.850]                       muffled <- FALSE
[13:34:38.850]                       if (inherits(cond, "message")) {
[13:34:38.850]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.850]                         if (muffled) 
[13:34:38.850]                           invokeRestart("muffleMessage")
[13:34:38.850]                       }
[13:34:38.850]                       else if (inherits(cond, "warning")) {
[13:34:38.850]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.850]                         if (muffled) 
[13:34:38.850]                           invokeRestart("muffleWarning")
[13:34:38.850]                       }
[13:34:38.850]                       else if (inherits(cond, "condition")) {
[13:34:38.850]                         if (!is.null(pattern)) {
[13:34:38.850]                           computeRestarts <- base::computeRestarts
[13:34:38.850]                           grepl <- base::grepl
[13:34:38.850]                           restarts <- computeRestarts(cond)
[13:34:38.850]                           for (restart in restarts) {
[13:34:38.850]                             name <- restart$name
[13:34:38.850]                             if (is.null(name)) 
[13:34:38.850]                               next
[13:34:38.850]                             if (!grepl(pattern, name)) 
[13:34:38.850]                               next
[13:34:38.850]                             invokeRestart(restart)
[13:34:38.850]                             muffled <- TRUE
[13:34:38.850]                             break
[13:34:38.850]                           }
[13:34:38.850]                         }
[13:34:38.850]                       }
[13:34:38.850]                       invisible(muffled)
[13:34:38.850]                     }
[13:34:38.850]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.850]                   }
[13:34:38.850]                 }
[13:34:38.850]             }
[13:34:38.850]         }))
[13:34:38.850]     }, error = function(ex) {
[13:34:38.850]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.850]                 ...future.rng), started = ...future.startTime, 
[13:34:38.850]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.850]             version = "1.8"), class = "FutureResult")
[13:34:38.850]     }, finally = {
[13:34:38.850]         if (!identical(...future.workdir, getwd())) 
[13:34:38.850]             setwd(...future.workdir)
[13:34:38.850]         {
[13:34:38.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.850]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.850]             }
[13:34:38.850]             base::options(...future.oldOptions)
[13:34:38.850]             if (.Platform$OS.type == "windows") {
[13:34:38.850]                 old_names <- names(...future.oldEnvVars)
[13:34:38.850]                 envs <- base::Sys.getenv()
[13:34:38.850]                 names <- names(envs)
[13:34:38.850]                 common <- intersect(names, old_names)
[13:34:38.850]                 added <- setdiff(names, old_names)
[13:34:38.850]                 removed <- setdiff(old_names, names)
[13:34:38.850]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.850]                   envs[common]]
[13:34:38.850]                 NAMES <- toupper(changed)
[13:34:38.850]                 args <- list()
[13:34:38.850]                 for (kk in seq_along(NAMES)) {
[13:34:38.850]                   name <- changed[[kk]]
[13:34:38.850]                   NAME <- NAMES[[kk]]
[13:34:38.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.850]                     next
[13:34:38.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.850]                 }
[13:34:38.850]                 NAMES <- toupper(added)
[13:34:38.850]                 for (kk in seq_along(NAMES)) {
[13:34:38.850]                   name <- added[[kk]]
[13:34:38.850]                   NAME <- NAMES[[kk]]
[13:34:38.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.850]                     next
[13:34:38.850]                   args[[name]] <- ""
[13:34:38.850]                 }
[13:34:38.850]                 NAMES <- toupper(removed)
[13:34:38.850]                 for (kk in seq_along(NAMES)) {
[13:34:38.850]                   name <- removed[[kk]]
[13:34:38.850]                   NAME <- NAMES[[kk]]
[13:34:38.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.850]                     next
[13:34:38.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.850]                 }
[13:34:38.850]                 if (length(args) > 0) 
[13:34:38.850]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.850]             }
[13:34:38.850]             else {
[13:34:38.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.850]             }
[13:34:38.850]             {
[13:34:38.850]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.850]                   0L) {
[13:34:38.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.850]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.850]                   base::options(opts)
[13:34:38.850]                 }
[13:34:38.850]                 {
[13:34:38.850]                   {
[13:34:38.850]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.850]                     NULL
[13:34:38.850]                   }
[13:34:38.850]                   options(future.plan = NULL)
[13:34:38.850]                   if (is.na(NA_character_)) 
[13:34:38.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.850]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.850]                     .init = FALSE)
[13:34:38.850]                 }
[13:34:38.850]             }
[13:34:38.850]         }
[13:34:38.850]     })
[13:34:38.850]     if (TRUE) {
[13:34:38.850]         base::sink(type = "output", split = FALSE)
[13:34:38.850]         if (TRUE) {
[13:34:38.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.850]         }
[13:34:38.850]         else {
[13:34:38.850]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.850]         }
[13:34:38.850]         base::close(...future.stdout)
[13:34:38.850]         ...future.stdout <- NULL
[13:34:38.850]     }
[13:34:38.850]     ...future.result$conditions <- ...future.conditions
[13:34:38.850]     ...future.result$finished <- base::Sys.time()
[13:34:38.850]     ...future.result
[13:34:38.850] }
[13:34:38.853] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[13:34:38.853] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[13:34:38.853] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[13:34:38.853] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:38.854] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.854] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:34:38.854] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:34:38.854] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:38.855] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.855] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:38.855] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.855] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[13:34:38.855] MultisessionFuture started
[13:34:38.856] - Launch lazy future ... done
[13:34:38.856] run() for ‘MultisessionFuture’ ... done
[13:34:38.856] Created future:
[13:34:38.856] MultisessionFuture:
[13:34:38.856] Label: ‘future_.mapply-1’
[13:34:38.856] Expression:
[13:34:38.856] {
[13:34:38.856]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.856]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.856]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.856]         on.exit(options(oopts), add = TRUE)
[13:34:38.856]     }
[13:34:38.856]     {
[13:34:38.856]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.856]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.856]         do.call(mapply, args = args)
[13:34:38.856]     }
[13:34:38.856] }
[13:34:38.856] Lazy evaluation: FALSE
[13:34:38.856] Asynchronous evaluation: TRUE
[13:34:38.856] Local evaluation: TRUE
[13:34:38.856] Environment: R_GlobalEnv
[13:34:38.856] Capture standard output: TRUE
[13:34:38.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.856] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.856] Packages: <none>
[13:34:38.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.856] Resolved: FALSE
[13:34:38.856] Value: <not collected>
[13:34:38.856] Conditions captured: <none>
[13:34:38.856] Early signaling: FALSE
[13:34:38.856] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.856] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.867] Chunk #1 of 2 ... DONE
[13:34:38.867] Chunk #2 of 2 ...
[13:34:38.867]  - Finding globals in '...' for chunk #2 ...
[13:34:38.868] getGlobalsAndPackages() ...
[13:34:38.868] Searching for globals...
[13:34:38.868] 
[13:34:38.868] Searching for globals ... DONE
[13:34:38.868] - globals: [0] <none>
[13:34:38.868] getGlobalsAndPackages() ... DONE
[13:34:38.868]    + additional globals found: [n=0] 
[13:34:38.868]    + additional namespaces needed: [n=0] 
[13:34:38.868]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:38.869]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:38.869]  - seeds: <none>
[13:34:38.869]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.869] getGlobalsAndPackages() ...
[13:34:38.869] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.869] Resolving globals: FALSE
[13:34:38.869] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[13:34:38.870] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:38.870] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.870] 
[13:34:38.870] getGlobalsAndPackages() ... DONE
[13:34:38.870] run() for ‘Future’ ...
[13:34:38.871] - state: ‘created’
[13:34:38.871] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.884] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.884]   - Field: ‘node’
[13:34:38.884]   - Field: ‘label’
[13:34:38.884]   - Field: ‘local’
[13:34:38.884]   - Field: ‘owner’
[13:34:38.884]   - Field: ‘envir’
[13:34:38.884]   - Field: ‘workers’
[13:34:38.885]   - Field: ‘packages’
[13:34:38.885]   - Field: ‘gc’
[13:34:38.885]   - Field: ‘conditions’
[13:34:38.885]   - Field: ‘persistent’
[13:34:38.885]   - Field: ‘expr’
[13:34:38.885]   - Field: ‘uuid’
[13:34:38.885]   - Field: ‘seed’
[13:34:38.885]   - Field: ‘version’
[13:34:38.885]   - Field: ‘result’
[13:34:38.885]   - Field: ‘asynchronous’
[13:34:38.885]   - Field: ‘calls’
[13:34:38.885]   - Field: ‘globals’
[13:34:38.886]   - Field: ‘stdout’
[13:34:38.886]   - Field: ‘earlySignal’
[13:34:38.886]   - Field: ‘lazy’
[13:34:38.886]   - Field: ‘state’
[13:34:38.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.886] - Launch lazy future ...
[13:34:38.886] Packages needed by the future expression (n = 0): <none>
[13:34:38.886] Packages needed by future strategies (n = 0): <none>
[13:34:38.887] {
[13:34:38.887]     {
[13:34:38.887]         {
[13:34:38.887]             ...future.startTime <- base::Sys.time()
[13:34:38.887]             {
[13:34:38.887]                 {
[13:34:38.887]                   {
[13:34:38.887]                     {
[13:34:38.887]                       base::local({
[13:34:38.887]                         has_future <- base::requireNamespace("future", 
[13:34:38.887]                           quietly = TRUE)
[13:34:38.887]                         if (has_future) {
[13:34:38.887]                           ns <- base::getNamespace("future")
[13:34:38.887]                           version <- ns[[".package"]][["version"]]
[13:34:38.887]                           if (is.null(version)) 
[13:34:38.887]                             version <- utils::packageVersion("future")
[13:34:38.887]                         }
[13:34:38.887]                         else {
[13:34:38.887]                           version <- NULL
[13:34:38.887]                         }
[13:34:38.887]                         if (!has_future || version < "1.8.0") {
[13:34:38.887]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.887]                             "", base::R.version$version.string), 
[13:34:38.887]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.887]                               "release", "version")], collapse = " "), 
[13:34:38.887]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.887]                             info)
[13:34:38.887]                           info <- base::paste(info, collapse = "; ")
[13:34:38.887]                           if (!has_future) {
[13:34:38.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.887]                               info)
[13:34:38.887]                           }
[13:34:38.887]                           else {
[13:34:38.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.887]                               info, version)
[13:34:38.887]                           }
[13:34:38.887]                           base::stop(msg)
[13:34:38.887]                         }
[13:34:38.887]                       })
[13:34:38.887]                     }
[13:34:38.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.887]                     base::options(mc.cores = 1L)
[13:34:38.887]                   }
[13:34:38.887]                   ...future.strategy.old <- future::plan("list")
[13:34:38.887]                   options(future.plan = NULL)
[13:34:38.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.887]                 }
[13:34:38.887]                 ...future.workdir <- getwd()
[13:34:38.887]             }
[13:34:38.887]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.887]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.887]         }
[13:34:38.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.887]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:38.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.887]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.887]             base::names(...future.oldOptions))
[13:34:38.887]     }
[13:34:38.887]     if (FALSE) {
[13:34:38.887]     }
[13:34:38.887]     else {
[13:34:38.887]         if (TRUE) {
[13:34:38.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.887]                 open = "w")
[13:34:38.887]         }
[13:34:38.887]         else {
[13:34:38.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.887]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.887]         }
[13:34:38.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.887]             base::sink(type = "output", split = FALSE)
[13:34:38.887]             base::close(...future.stdout)
[13:34:38.887]         }, add = TRUE)
[13:34:38.887]     }
[13:34:38.887]     ...future.frame <- base::sys.nframe()
[13:34:38.887]     ...future.conditions <- base::list()
[13:34:38.887]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.887]     if (FALSE) {
[13:34:38.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.887]     }
[13:34:38.887]     ...future.result <- base::tryCatch({
[13:34:38.887]         base::withCallingHandlers({
[13:34:38.887]             ...future.value <- base::withVisible(base::local({
[13:34:38.887]                 ...future.makeSendCondition <- base::local({
[13:34:38.887]                   sendCondition <- NULL
[13:34:38.887]                   function(frame = 1L) {
[13:34:38.887]                     if (is.function(sendCondition)) 
[13:34:38.887]                       return(sendCondition)
[13:34:38.887]                     ns <- getNamespace("parallel")
[13:34:38.887]                     if (exists("sendData", mode = "function", 
[13:34:38.887]                       envir = ns)) {
[13:34:38.887]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.887]                         envir = ns)
[13:34:38.887]                       envir <- sys.frame(frame)
[13:34:38.887]                       master <- NULL
[13:34:38.887]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.887]                         !identical(envir, emptyenv())) {
[13:34:38.887]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.887]                           inherits = FALSE)) {
[13:34:38.887]                           master <- get("master", mode = "list", 
[13:34:38.887]                             envir = envir, inherits = FALSE)
[13:34:38.887]                           if (inherits(master, c("SOCKnode", 
[13:34:38.887]                             "SOCK0node"))) {
[13:34:38.887]                             sendCondition <<- function(cond) {
[13:34:38.887]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.887]                                 success = TRUE)
[13:34:38.887]                               parallel_sendData(master, data)
[13:34:38.887]                             }
[13:34:38.887]                             return(sendCondition)
[13:34:38.887]                           }
[13:34:38.887]                         }
[13:34:38.887]                         frame <- frame + 1L
[13:34:38.887]                         envir <- sys.frame(frame)
[13:34:38.887]                       }
[13:34:38.887]                     }
[13:34:38.887]                     sendCondition <<- function(cond) NULL
[13:34:38.887]                   }
[13:34:38.887]                 })
[13:34:38.887]                 withCallingHandlers({
[13:34:38.887]                   {
[13:34:38.887]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.887]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.887]                       ...future.globals.maxSize)) {
[13:34:38.887]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.887]                       on.exit(options(oopts), add = TRUE)
[13:34:38.887]                     }
[13:34:38.887]                     {
[13:34:38.887]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.887]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.887]                         USE.NAMES = FALSE)
[13:34:38.887]                       do.call(mapply, args = args)
[13:34:38.887]                     }
[13:34:38.887]                   }
[13:34:38.887]                 }, immediateCondition = function(cond) {
[13:34:38.887]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.887]                   sendCondition(cond)
[13:34:38.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.887]                   {
[13:34:38.887]                     inherits <- base::inherits
[13:34:38.887]                     invokeRestart <- base::invokeRestart
[13:34:38.887]                     is.null <- base::is.null
[13:34:38.887]                     muffled <- FALSE
[13:34:38.887]                     if (inherits(cond, "message")) {
[13:34:38.887]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.887]                       if (muffled) 
[13:34:38.887]                         invokeRestart("muffleMessage")
[13:34:38.887]                     }
[13:34:38.887]                     else if (inherits(cond, "warning")) {
[13:34:38.887]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.887]                       if (muffled) 
[13:34:38.887]                         invokeRestart("muffleWarning")
[13:34:38.887]                     }
[13:34:38.887]                     else if (inherits(cond, "condition")) {
[13:34:38.887]                       if (!is.null(pattern)) {
[13:34:38.887]                         computeRestarts <- base::computeRestarts
[13:34:38.887]                         grepl <- base::grepl
[13:34:38.887]                         restarts <- computeRestarts(cond)
[13:34:38.887]                         for (restart in restarts) {
[13:34:38.887]                           name <- restart$name
[13:34:38.887]                           if (is.null(name)) 
[13:34:38.887]                             next
[13:34:38.887]                           if (!grepl(pattern, name)) 
[13:34:38.887]                             next
[13:34:38.887]                           invokeRestart(restart)
[13:34:38.887]                           muffled <- TRUE
[13:34:38.887]                           break
[13:34:38.887]                         }
[13:34:38.887]                       }
[13:34:38.887]                     }
[13:34:38.887]                     invisible(muffled)
[13:34:38.887]                   }
[13:34:38.887]                   muffleCondition(cond)
[13:34:38.887]                 })
[13:34:38.887]             }))
[13:34:38.887]             future::FutureResult(value = ...future.value$value, 
[13:34:38.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.887]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.887]                     ...future.globalenv.names))
[13:34:38.887]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.887]         }, condition = base::local({
[13:34:38.887]             c <- base::c
[13:34:38.887]             inherits <- base::inherits
[13:34:38.887]             invokeRestart <- base::invokeRestart
[13:34:38.887]             length <- base::length
[13:34:38.887]             list <- base::list
[13:34:38.887]             seq.int <- base::seq.int
[13:34:38.887]             signalCondition <- base::signalCondition
[13:34:38.887]             sys.calls <- base::sys.calls
[13:34:38.887]             `[[` <- base::`[[`
[13:34:38.887]             `+` <- base::`+`
[13:34:38.887]             `<<-` <- base::`<<-`
[13:34:38.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.887]                   3L)]
[13:34:38.887]             }
[13:34:38.887]             function(cond) {
[13:34:38.887]                 is_error <- inherits(cond, "error")
[13:34:38.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.887]                   NULL)
[13:34:38.887]                 if (is_error) {
[13:34:38.887]                   sessionInformation <- function() {
[13:34:38.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.887]                       search = base::search(), system = base::Sys.info())
[13:34:38.887]                   }
[13:34:38.887]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.887]                     cond$call), session = sessionInformation(), 
[13:34:38.887]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.887]                   signalCondition(cond)
[13:34:38.887]                 }
[13:34:38.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.887]                 "immediateCondition"))) {
[13:34:38.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.887]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.887]                   if (TRUE && !signal) {
[13:34:38.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.887]                     {
[13:34:38.887]                       inherits <- base::inherits
[13:34:38.887]                       invokeRestart <- base::invokeRestart
[13:34:38.887]                       is.null <- base::is.null
[13:34:38.887]                       muffled <- FALSE
[13:34:38.887]                       if (inherits(cond, "message")) {
[13:34:38.887]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.887]                         if (muffled) 
[13:34:38.887]                           invokeRestart("muffleMessage")
[13:34:38.887]                       }
[13:34:38.887]                       else if (inherits(cond, "warning")) {
[13:34:38.887]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.887]                         if (muffled) 
[13:34:38.887]                           invokeRestart("muffleWarning")
[13:34:38.887]                       }
[13:34:38.887]                       else if (inherits(cond, "condition")) {
[13:34:38.887]                         if (!is.null(pattern)) {
[13:34:38.887]                           computeRestarts <- base::computeRestarts
[13:34:38.887]                           grepl <- base::grepl
[13:34:38.887]                           restarts <- computeRestarts(cond)
[13:34:38.887]                           for (restart in restarts) {
[13:34:38.887]                             name <- restart$name
[13:34:38.887]                             if (is.null(name)) 
[13:34:38.887]                               next
[13:34:38.887]                             if (!grepl(pattern, name)) 
[13:34:38.887]                               next
[13:34:38.887]                             invokeRestart(restart)
[13:34:38.887]                             muffled <- TRUE
[13:34:38.887]                             break
[13:34:38.887]                           }
[13:34:38.887]                         }
[13:34:38.887]                       }
[13:34:38.887]                       invisible(muffled)
[13:34:38.887]                     }
[13:34:38.887]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.887]                   }
[13:34:38.887]                 }
[13:34:38.887]                 else {
[13:34:38.887]                   if (TRUE) {
[13:34:38.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.887]                     {
[13:34:38.887]                       inherits <- base::inherits
[13:34:38.887]                       invokeRestart <- base::invokeRestart
[13:34:38.887]                       is.null <- base::is.null
[13:34:38.887]                       muffled <- FALSE
[13:34:38.887]                       if (inherits(cond, "message")) {
[13:34:38.887]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.887]                         if (muffled) 
[13:34:38.887]                           invokeRestart("muffleMessage")
[13:34:38.887]                       }
[13:34:38.887]                       else if (inherits(cond, "warning")) {
[13:34:38.887]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.887]                         if (muffled) 
[13:34:38.887]                           invokeRestart("muffleWarning")
[13:34:38.887]                       }
[13:34:38.887]                       else if (inherits(cond, "condition")) {
[13:34:38.887]                         if (!is.null(pattern)) {
[13:34:38.887]                           computeRestarts <- base::computeRestarts
[13:34:38.887]                           grepl <- base::grepl
[13:34:38.887]                           restarts <- computeRestarts(cond)
[13:34:38.887]                           for (restart in restarts) {
[13:34:38.887]                             name <- restart$name
[13:34:38.887]                             if (is.null(name)) 
[13:34:38.887]                               next
[13:34:38.887]                             if (!grepl(pattern, name)) 
[13:34:38.887]                               next
[13:34:38.887]                             invokeRestart(restart)
[13:34:38.887]                             muffled <- TRUE
[13:34:38.887]                             break
[13:34:38.887]                           }
[13:34:38.887]                         }
[13:34:38.887]                       }
[13:34:38.887]                       invisible(muffled)
[13:34:38.887]                     }
[13:34:38.887]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.887]                   }
[13:34:38.887]                 }
[13:34:38.887]             }
[13:34:38.887]         }))
[13:34:38.887]     }, error = function(ex) {
[13:34:38.887]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.887]                 ...future.rng), started = ...future.startTime, 
[13:34:38.887]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.887]             version = "1.8"), class = "FutureResult")
[13:34:38.887]     }, finally = {
[13:34:38.887]         if (!identical(...future.workdir, getwd())) 
[13:34:38.887]             setwd(...future.workdir)
[13:34:38.887]         {
[13:34:38.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.887]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.887]             }
[13:34:38.887]             base::options(...future.oldOptions)
[13:34:38.887]             if (.Platform$OS.type == "windows") {
[13:34:38.887]                 old_names <- names(...future.oldEnvVars)
[13:34:38.887]                 envs <- base::Sys.getenv()
[13:34:38.887]                 names <- names(envs)
[13:34:38.887]                 common <- intersect(names, old_names)
[13:34:38.887]                 added <- setdiff(names, old_names)
[13:34:38.887]                 removed <- setdiff(old_names, names)
[13:34:38.887]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.887]                   envs[common]]
[13:34:38.887]                 NAMES <- toupper(changed)
[13:34:38.887]                 args <- list()
[13:34:38.887]                 for (kk in seq_along(NAMES)) {
[13:34:38.887]                   name <- changed[[kk]]
[13:34:38.887]                   NAME <- NAMES[[kk]]
[13:34:38.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.887]                     next
[13:34:38.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.887]                 }
[13:34:38.887]                 NAMES <- toupper(added)
[13:34:38.887]                 for (kk in seq_along(NAMES)) {
[13:34:38.887]                   name <- added[[kk]]
[13:34:38.887]                   NAME <- NAMES[[kk]]
[13:34:38.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.887]                     next
[13:34:38.887]                   args[[name]] <- ""
[13:34:38.887]                 }
[13:34:38.887]                 NAMES <- toupper(removed)
[13:34:38.887]                 for (kk in seq_along(NAMES)) {
[13:34:38.887]                   name <- removed[[kk]]
[13:34:38.887]                   NAME <- NAMES[[kk]]
[13:34:38.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.887]                     next
[13:34:38.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.887]                 }
[13:34:38.887]                 if (length(args) > 0) 
[13:34:38.887]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.887]             }
[13:34:38.887]             else {
[13:34:38.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.887]             }
[13:34:38.887]             {
[13:34:38.887]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.887]                   0L) {
[13:34:38.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.887]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.887]                   base::options(opts)
[13:34:38.887]                 }
[13:34:38.887]                 {
[13:34:38.887]                   {
[13:34:38.887]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.887]                     NULL
[13:34:38.887]                   }
[13:34:38.887]                   options(future.plan = NULL)
[13:34:38.887]                   if (is.na(NA_character_)) 
[13:34:38.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.887]                     .init = FALSE)
[13:34:38.887]                 }
[13:34:38.887]             }
[13:34:38.887]         }
[13:34:38.887]     })
[13:34:38.887]     if (TRUE) {
[13:34:38.887]         base::sink(type = "output", split = FALSE)
[13:34:38.887]         if (TRUE) {
[13:34:38.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.887]         }
[13:34:38.887]         else {
[13:34:38.887]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.887]         }
[13:34:38.887]         base::close(...future.stdout)
[13:34:38.887]         ...future.stdout <- NULL
[13:34:38.887]     }
[13:34:38.887]     ...future.result$conditions <- ...future.conditions
[13:34:38.887]     ...future.result$finished <- base::Sys.time()
[13:34:38.887]     ...future.result
[13:34:38.887] }
[13:34:38.889] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[13:34:38.889] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[13:34:38.890] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[13:34:38.890] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:38.890] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.890] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[13:34:38.891] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[13:34:38.891] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:38.891] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.891] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:38.891] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:38.892] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[13:34:38.892] MultisessionFuture started
[13:34:38.892] - Launch lazy future ... done
[13:34:38.892] run() for ‘MultisessionFuture’ ... done
[13:34:38.892] Created future:
[13:34:38.892] MultisessionFuture:
[13:34:38.892] Label: ‘future_.mapply-2’
[13:34:38.892] Expression:
[13:34:38.892] {
[13:34:38.892]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.892]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.892]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.892]         on.exit(options(oopts), add = TRUE)
[13:34:38.892]     }
[13:34:38.892]     {
[13:34:38.892]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.892]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.892]         do.call(mapply, args = args)
[13:34:38.892]     }
[13:34:38.892] }
[13:34:38.892] Lazy evaluation: FALSE
[13:34:38.892] Asynchronous evaluation: TRUE
[13:34:38.892] Local evaluation: TRUE
[13:34:38.892] Environment: R_GlobalEnv
[13:34:38.892] Capture standard output: TRUE
[13:34:38.892] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.892] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.892] Packages: <none>
[13:34:38.892] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.892] Resolved: FALSE
[13:34:38.892] Value: <not collected>
[13:34:38.892] Conditions captured: <none>
[13:34:38.892] Early signaling: FALSE
[13:34:38.892] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.892] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.904] Chunk #2 of 2 ... DONE
[13:34:38.904] Launching 2 futures (chunks) ... DONE
[13:34:38.904] Resolving 2 futures (chunks) ...
[13:34:38.904] resolve() on list ...
[13:34:38.904]  recursive: 0
[13:34:38.904]  length: 2
[13:34:38.904] 
[13:34:38.905] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.905] - Validating connection of MultisessionFuture
[13:34:38.905] - received message: FutureResult
[13:34:38.905] - Received FutureResult
[13:34:38.905] - Erased future from FutureRegistry
[13:34:38.905] result() for ClusterFuture ...
[13:34:38.905] - result already collected: FutureResult
[13:34:38.905] result() for ClusterFuture ... done
[13:34:38.905] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.905] Future #1
[13:34:38.906] result() for ClusterFuture ...
[13:34:38.906] - result already collected: FutureResult
[13:34:38.906] result() for ClusterFuture ... done
[13:34:38.906] result() for ClusterFuture ...
[13:34:38.906] - result already collected: FutureResult
[13:34:38.906] result() for ClusterFuture ... done
[13:34:38.906] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:38.906] - nx: 2
[13:34:38.906] - relay: TRUE
[13:34:38.906] - stdout: TRUE
[13:34:38.906] - signal: TRUE
[13:34:38.907] - resignal: FALSE
[13:34:38.907] - force: TRUE
[13:34:38.907] - relayed: [n=2] FALSE, FALSE
[13:34:38.907] - queued futures: [n=2] FALSE, FALSE
[13:34:38.907]  - until=1
[13:34:38.907]  - relaying element #1
[13:34:38.907] result() for ClusterFuture ...
[13:34:38.907] - result already collected: FutureResult
[13:34:38.907] result() for ClusterFuture ... done
[13:34:38.907] result() for ClusterFuture ...
[13:34:38.907] - result already collected: FutureResult
[13:34:38.907] result() for ClusterFuture ... done
[13:34:38.908] result() for ClusterFuture ...
[13:34:38.908] - result already collected: FutureResult
[13:34:38.908] result() for ClusterFuture ... done
[13:34:38.908] result() for ClusterFuture ...
[13:34:38.908] - result already collected: FutureResult
[13:34:38.908] result() for ClusterFuture ... done
[13:34:38.908] - relayed: [n=2] TRUE, FALSE
[13:34:38.908] - queued futures: [n=2] TRUE, FALSE
[13:34:38.908] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:38.908]  length: 1 (resolved future 1)
[13:34:38.936] receiveMessageFromWorker() for ClusterFuture ...
[13:34:38.936] - Validating connection of MultisessionFuture
[13:34:38.936] - received message: FutureResult
[13:34:38.936] - Received FutureResult
[13:34:38.936] - Erased future from FutureRegistry
[13:34:38.936] result() for ClusterFuture ...
[13:34:38.936] - result already collected: FutureResult
[13:34:38.937] result() for ClusterFuture ... done
[13:34:38.937] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:38.937] Future #2
[13:34:38.937] result() for ClusterFuture ...
[13:34:38.937] - result already collected: FutureResult
[13:34:38.937] result() for ClusterFuture ... done
[13:34:38.937] result() for ClusterFuture ...
[13:34:38.937] - result already collected: FutureResult
[13:34:38.937] result() for ClusterFuture ... done
[13:34:38.937] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:38.937] - nx: 2
[13:34:38.937] - relay: TRUE
[13:34:38.938] - stdout: TRUE
[13:34:38.938] - signal: TRUE
[13:34:38.938] - resignal: FALSE
[13:34:38.938] - force: TRUE
[13:34:38.938] - relayed: [n=2] TRUE, FALSE
[13:34:38.938] - queued futures: [n=2] TRUE, FALSE
[13:34:38.938]  - until=2
[13:34:38.938]  - relaying element #2
[13:34:38.938] result() for ClusterFuture ...
[13:34:38.938] - result already collected: FutureResult
[13:34:38.938] result() for ClusterFuture ... done
[13:34:38.939] result() for ClusterFuture ...
[13:34:38.939] - result already collected: FutureResult
[13:34:38.939] result() for ClusterFuture ... done
[13:34:38.939] result() for ClusterFuture ...
[13:34:38.939] - result already collected: FutureResult
[13:34:38.939] result() for ClusterFuture ... done
[13:34:38.939] result() for ClusterFuture ...
[13:34:38.939] - result already collected: FutureResult
[13:34:38.939] result() for ClusterFuture ... done
[13:34:38.939] - relayed: [n=2] TRUE, TRUE
[13:34:38.939] - queued futures: [n=2] TRUE, TRUE
[13:34:38.939] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:38.940]  length: 0 (resolved future 2)
[13:34:38.940] Relaying remaining futures
[13:34:38.940] signalConditionsASAP(NULL, pos=0) ...
[13:34:38.940] - nx: 2
[13:34:38.940] - relay: TRUE
[13:34:38.940] - stdout: TRUE
[13:34:38.940] - signal: TRUE
[13:34:38.940] - resignal: FALSE
[13:34:38.940] - force: TRUE
[13:34:38.940] - relayed: [n=2] TRUE, TRUE
[13:34:38.940] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:38.940] - relayed: [n=2] TRUE, TRUE
[13:34:38.941] - queued futures: [n=2] TRUE, TRUE
[13:34:38.941] signalConditionsASAP(NULL, pos=0) ... done
[13:34:38.941] resolve() on list ... DONE
[13:34:38.941] result() for ClusterFuture ...
[13:34:38.941] - result already collected: FutureResult
[13:34:38.941] result() for ClusterFuture ... done
[13:34:38.941] result() for ClusterFuture ...
[13:34:38.941] - result already collected: FutureResult
[13:34:38.941] result() for ClusterFuture ... done
[13:34:38.941] result() for ClusterFuture ...
[13:34:38.941] - result already collected: FutureResult
[13:34:38.942] result() for ClusterFuture ... done
[13:34:38.942] result() for ClusterFuture ...
[13:34:38.942] - result already collected: FutureResult
[13:34:38.942] result() for ClusterFuture ... done
[13:34:38.942]  - Number of value chunks collected: 2
[13:34:38.942] Resolving 2 futures (chunks) ... DONE
[13:34:38.942] Reducing values from 2 chunks ...
[13:34:38.942]  - Number of values collected after concatenation: 3
[13:34:38.942]  - Number of values expected: 3
[13:34:38.942] Reducing values from 2 chunks ... DONE
[13:34:38.942] future_mapply() ... DONE
[13:34:38.943] future_mapply() ...
[13:34:38.946] Number of chunks: 5
[13:34:38.946] getGlobalsAndPackagesXApply() ...
[13:34:38.946]  - future.globals: TRUE
[13:34:38.946] getGlobalsAndPackages() ...
[13:34:38.947] Searching for globals...
[13:34:38.948] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:38.948] Searching for globals ... DONE
[13:34:38.948] Resolving globals: FALSE
[13:34:38.948] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:38.949] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:38.949] - globals: [1] ‘FUN’
[13:34:38.949] 
[13:34:38.949] getGlobalsAndPackages() ... DONE
[13:34:38.949]  - globals found/used: [n=1] ‘FUN’
[13:34:38.949]  - needed namespaces: [n=0] 
[13:34:38.949] Finding globals ... DONE
[13:34:38.949] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:38.950] List of 2
[13:34:38.950]  $ ...future.FUN:function (C, k)  
[13:34:38.950]  $ MoreArgs     : NULL
[13:34:38.950]  - attr(*, "where")=List of 2
[13:34:38.950]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:38.950]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:38.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:38.950]  - attr(*, "resolved")= logi FALSE
[13:34:38.950]  - attr(*, "total_size")= num NA
[13:34:38.952] Packages to be attached in all futures: [n=0] 
[13:34:38.952] getGlobalsAndPackagesXApply() ... DONE
[13:34:38.952] Number of futures (= number of chunks): 5
[13:34:38.952] Launching 5 futures (chunks) ...
[13:34:38.952] Chunk #1 of 5 ...
[13:34:38.953]  - Finding globals in '...' for chunk #1 ...
[13:34:38.953] getGlobalsAndPackages() ...
[13:34:38.953] Searching for globals...
[13:34:38.953] 
[13:34:38.953] Searching for globals ... DONE
[13:34:38.953] - globals: [0] <none>
[13:34:38.953] getGlobalsAndPackages() ... DONE
[13:34:38.953]    + additional globals found: [n=0] 
[13:34:38.954]    + additional namespaces needed: [n=0] 
[13:34:38.954]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:38.954]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:38.954]  - seeds: <none>
[13:34:38.954]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.954] getGlobalsAndPackages() ...
[13:34:38.954] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.954] Resolving globals: FALSE
[13:34:38.955] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:38.955] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:38.955] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.955] 
[13:34:38.955] getGlobalsAndPackages() ... DONE
[13:34:38.956] run() for ‘Future’ ...
[13:34:38.956] - state: ‘created’
[13:34:38.956] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:38.970] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:38.970]   - Field: ‘node’
[13:34:38.970]   - Field: ‘label’
[13:34:38.970]   - Field: ‘local’
[13:34:38.970]   - Field: ‘owner’
[13:34:38.970]   - Field: ‘envir’
[13:34:38.970]   - Field: ‘workers’
[13:34:38.970]   - Field: ‘packages’
[13:34:38.971]   - Field: ‘gc’
[13:34:38.971]   - Field: ‘conditions’
[13:34:38.971]   - Field: ‘persistent’
[13:34:38.971]   - Field: ‘expr’
[13:34:38.971]   - Field: ‘uuid’
[13:34:38.971]   - Field: ‘seed’
[13:34:38.971]   - Field: ‘version’
[13:34:38.971]   - Field: ‘result’
[13:34:38.971]   - Field: ‘asynchronous’
[13:34:38.971]   - Field: ‘calls’
[13:34:38.971]   - Field: ‘globals’
[13:34:38.972]   - Field: ‘stdout’
[13:34:38.972]   - Field: ‘earlySignal’
[13:34:38.972]   - Field: ‘lazy’
[13:34:38.972]   - Field: ‘state’
[13:34:38.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:38.972] - Launch lazy future ...
[13:34:38.972] Packages needed by the future expression (n = 0): <none>
[13:34:38.972] Packages needed by future strategies (n = 0): <none>
[13:34:38.973] {
[13:34:38.973]     {
[13:34:38.973]         {
[13:34:38.973]             ...future.startTime <- base::Sys.time()
[13:34:38.973]             {
[13:34:38.973]                 {
[13:34:38.973]                   {
[13:34:38.973]                     {
[13:34:38.973]                       base::local({
[13:34:38.973]                         has_future <- base::requireNamespace("future", 
[13:34:38.973]                           quietly = TRUE)
[13:34:38.973]                         if (has_future) {
[13:34:38.973]                           ns <- base::getNamespace("future")
[13:34:38.973]                           version <- ns[[".package"]][["version"]]
[13:34:38.973]                           if (is.null(version)) 
[13:34:38.973]                             version <- utils::packageVersion("future")
[13:34:38.973]                         }
[13:34:38.973]                         else {
[13:34:38.973]                           version <- NULL
[13:34:38.973]                         }
[13:34:38.973]                         if (!has_future || version < "1.8.0") {
[13:34:38.973]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:38.973]                             "", base::R.version$version.string), 
[13:34:38.973]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:38.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:38.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:38.973]                               "release", "version")], collapse = " "), 
[13:34:38.973]                             hostname = base::Sys.info()[["nodename"]])
[13:34:38.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:38.973]                             info)
[13:34:38.973]                           info <- base::paste(info, collapse = "; ")
[13:34:38.973]                           if (!has_future) {
[13:34:38.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:38.973]                               info)
[13:34:38.973]                           }
[13:34:38.973]                           else {
[13:34:38.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:38.973]                               info, version)
[13:34:38.973]                           }
[13:34:38.973]                           base::stop(msg)
[13:34:38.973]                         }
[13:34:38.973]                       })
[13:34:38.973]                     }
[13:34:38.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:38.973]                     base::options(mc.cores = 1L)
[13:34:38.973]                   }
[13:34:38.973]                   ...future.strategy.old <- future::plan("list")
[13:34:38.973]                   options(future.plan = NULL)
[13:34:38.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:38.973]                 }
[13:34:38.973]                 ...future.workdir <- getwd()
[13:34:38.973]             }
[13:34:38.973]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:38.973]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:38.973]         }
[13:34:38.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:38.973]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:38.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:38.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:38.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:38.973]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:38.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:38.973]             base::names(...future.oldOptions))
[13:34:38.973]     }
[13:34:38.973]     if (FALSE) {
[13:34:38.973]     }
[13:34:38.973]     else {
[13:34:38.973]         if (TRUE) {
[13:34:38.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:38.973]                 open = "w")
[13:34:38.973]         }
[13:34:38.973]         else {
[13:34:38.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:38.973]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:38.973]         }
[13:34:38.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:38.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:38.973]             base::sink(type = "output", split = FALSE)
[13:34:38.973]             base::close(...future.stdout)
[13:34:38.973]         }, add = TRUE)
[13:34:38.973]     }
[13:34:38.973]     ...future.frame <- base::sys.nframe()
[13:34:38.973]     ...future.conditions <- base::list()
[13:34:38.973]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:38.973]     if (FALSE) {
[13:34:38.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:38.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:38.973]     }
[13:34:38.973]     ...future.result <- base::tryCatch({
[13:34:38.973]         base::withCallingHandlers({
[13:34:38.973]             ...future.value <- base::withVisible(base::local({
[13:34:38.973]                 ...future.makeSendCondition <- base::local({
[13:34:38.973]                   sendCondition <- NULL
[13:34:38.973]                   function(frame = 1L) {
[13:34:38.973]                     if (is.function(sendCondition)) 
[13:34:38.973]                       return(sendCondition)
[13:34:38.973]                     ns <- getNamespace("parallel")
[13:34:38.973]                     if (exists("sendData", mode = "function", 
[13:34:38.973]                       envir = ns)) {
[13:34:38.973]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:38.973]                         envir = ns)
[13:34:38.973]                       envir <- sys.frame(frame)
[13:34:38.973]                       master <- NULL
[13:34:38.973]                       while (!identical(envir, .GlobalEnv) && 
[13:34:38.973]                         !identical(envir, emptyenv())) {
[13:34:38.973]                         if (exists("master", mode = "list", envir = envir, 
[13:34:38.973]                           inherits = FALSE)) {
[13:34:38.973]                           master <- get("master", mode = "list", 
[13:34:38.973]                             envir = envir, inherits = FALSE)
[13:34:38.973]                           if (inherits(master, c("SOCKnode", 
[13:34:38.973]                             "SOCK0node"))) {
[13:34:38.973]                             sendCondition <<- function(cond) {
[13:34:38.973]                               data <- list(type = "VALUE", value = cond, 
[13:34:38.973]                                 success = TRUE)
[13:34:38.973]                               parallel_sendData(master, data)
[13:34:38.973]                             }
[13:34:38.973]                             return(sendCondition)
[13:34:38.973]                           }
[13:34:38.973]                         }
[13:34:38.973]                         frame <- frame + 1L
[13:34:38.973]                         envir <- sys.frame(frame)
[13:34:38.973]                       }
[13:34:38.973]                     }
[13:34:38.973]                     sendCondition <<- function(cond) NULL
[13:34:38.973]                   }
[13:34:38.973]                 })
[13:34:38.973]                 withCallingHandlers({
[13:34:38.973]                   {
[13:34:38.973]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.973]                     if (!identical(...future.globals.maxSize.org, 
[13:34:38.973]                       ...future.globals.maxSize)) {
[13:34:38.973]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.973]                       on.exit(options(oopts), add = TRUE)
[13:34:38.973]                     }
[13:34:38.973]                     {
[13:34:38.973]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.973]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:38.973]                         USE.NAMES = FALSE)
[13:34:38.973]                       do.call(mapply, args = args)
[13:34:38.973]                     }
[13:34:38.973]                   }
[13:34:38.973]                 }, immediateCondition = function(cond) {
[13:34:38.973]                   sendCondition <- ...future.makeSendCondition()
[13:34:38.973]                   sendCondition(cond)
[13:34:38.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.973]                   {
[13:34:38.973]                     inherits <- base::inherits
[13:34:38.973]                     invokeRestart <- base::invokeRestart
[13:34:38.973]                     is.null <- base::is.null
[13:34:38.973]                     muffled <- FALSE
[13:34:38.973]                     if (inherits(cond, "message")) {
[13:34:38.973]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:38.973]                       if (muffled) 
[13:34:38.973]                         invokeRestart("muffleMessage")
[13:34:38.973]                     }
[13:34:38.973]                     else if (inherits(cond, "warning")) {
[13:34:38.973]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:38.973]                       if (muffled) 
[13:34:38.973]                         invokeRestart("muffleWarning")
[13:34:38.973]                     }
[13:34:38.973]                     else if (inherits(cond, "condition")) {
[13:34:38.973]                       if (!is.null(pattern)) {
[13:34:38.973]                         computeRestarts <- base::computeRestarts
[13:34:38.973]                         grepl <- base::grepl
[13:34:38.973]                         restarts <- computeRestarts(cond)
[13:34:38.973]                         for (restart in restarts) {
[13:34:38.973]                           name <- restart$name
[13:34:38.973]                           if (is.null(name)) 
[13:34:38.973]                             next
[13:34:38.973]                           if (!grepl(pattern, name)) 
[13:34:38.973]                             next
[13:34:38.973]                           invokeRestart(restart)
[13:34:38.973]                           muffled <- TRUE
[13:34:38.973]                           break
[13:34:38.973]                         }
[13:34:38.973]                       }
[13:34:38.973]                     }
[13:34:38.973]                     invisible(muffled)
[13:34:38.973]                   }
[13:34:38.973]                   muffleCondition(cond)
[13:34:38.973]                 })
[13:34:38.973]             }))
[13:34:38.973]             future::FutureResult(value = ...future.value$value, 
[13:34:38.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.973]                   ...future.rng), globalenv = if (FALSE) 
[13:34:38.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:38.973]                     ...future.globalenv.names))
[13:34:38.973]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:38.973]         }, condition = base::local({
[13:34:38.973]             c <- base::c
[13:34:38.973]             inherits <- base::inherits
[13:34:38.973]             invokeRestart <- base::invokeRestart
[13:34:38.973]             length <- base::length
[13:34:38.973]             list <- base::list
[13:34:38.973]             seq.int <- base::seq.int
[13:34:38.973]             signalCondition <- base::signalCondition
[13:34:38.973]             sys.calls <- base::sys.calls
[13:34:38.973]             `[[` <- base::`[[`
[13:34:38.973]             `+` <- base::`+`
[13:34:38.973]             `<<-` <- base::`<<-`
[13:34:38.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:38.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:38.973]                   3L)]
[13:34:38.973]             }
[13:34:38.973]             function(cond) {
[13:34:38.973]                 is_error <- inherits(cond, "error")
[13:34:38.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:38.973]                   NULL)
[13:34:38.973]                 if (is_error) {
[13:34:38.973]                   sessionInformation <- function() {
[13:34:38.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:38.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:38.973]                       search = base::search(), system = base::Sys.info())
[13:34:38.973]                   }
[13:34:38.973]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:38.973]                     cond$call), session = sessionInformation(), 
[13:34:38.973]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:38.973]                   signalCondition(cond)
[13:34:38.973]                 }
[13:34:38.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:38.973]                 "immediateCondition"))) {
[13:34:38.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:38.973]                   ...future.conditions[[length(...future.conditions) + 
[13:34:38.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:38.973]                   if (TRUE && !signal) {
[13:34:38.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.973]                     {
[13:34:38.973]                       inherits <- base::inherits
[13:34:38.973]                       invokeRestart <- base::invokeRestart
[13:34:38.973]                       is.null <- base::is.null
[13:34:38.973]                       muffled <- FALSE
[13:34:38.973]                       if (inherits(cond, "message")) {
[13:34:38.973]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.973]                         if (muffled) 
[13:34:38.973]                           invokeRestart("muffleMessage")
[13:34:38.973]                       }
[13:34:38.973]                       else if (inherits(cond, "warning")) {
[13:34:38.973]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.973]                         if (muffled) 
[13:34:38.973]                           invokeRestart("muffleWarning")
[13:34:38.973]                       }
[13:34:38.973]                       else if (inherits(cond, "condition")) {
[13:34:38.973]                         if (!is.null(pattern)) {
[13:34:38.973]                           computeRestarts <- base::computeRestarts
[13:34:38.973]                           grepl <- base::grepl
[13:34:38.973]                           restarts <- computeRestarts(cond)
[13:34:38.973]                           for (restart in restarts) {
[13:34:38.973]                             name <- restart$name
[13:34:38.973]                             if (is.null(name)) 
[13:34:38.973]                               next
[13:34:38.973]                             if (!grepl(pattern, name)) 
[13:34:38.973]                               next
[13:34:38.973]                             invokeRestart(restart)
[13:34:38.973]                             muffled <- TRUE
[13:34:38.973]                             break
[13:34:38.973]                           }
[13:34:38.973]                         }
[13:34:38.973]                       }
[13:34:38.973]                       invisible(muffled)
[13:34:38.973]                     }
[13:34:38.973]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.973]                   }
[13:34:38.973]                 }
[13:34:38.973]                 else {
[13:34:38.973]                   if (TRUE) {
[13:34:38.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:38.973]                     {
[13:34:38.973]                       inherits <- base::inherits
[13:34:38.973]                       invokeRestart <- base::invokeRestart
[13:34:38.973]                       is.null <- base::is.null
[13:34:38.973]                       muffled <- FALSE
[13:34:38.973]                       if (inherits(cond, "message")) {
[13:34:38.973]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:38.973]                         if (muffled) 
[13:34:38.973]                           invokeRestart("muffleMessage")
[13:34:38.973]                       }
[13:34:38.973]                       else if (inherits(cond, "warning")) {
[13:34:38.973]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:38.973]                         if (muffled) 
[13:34:38.973]                           invokeRestart("muffleWarning")
[13:34:38.973]                       }
[13:34:38.973]                       else if (inherits(cond, "condition")) {
[13:34:38.973]                         if (!is.null(pattern)) {
[13:34:38.973]                           computeRestarts <- base::computeRestarts
[13:34:38.973]                           grepl <- base::grepl
[13:34:38.973]                           restarts <- computeRestarts(cond)
[13:34:38.973]                           for (restart in restarts) {
[13:34:38.973]                             name <- restart$name
[13:34:38.973]                             if (is.null(name)) 
[13:34:38.973]                               next
[13:34:38.973]                             if (!grepl(pattern, name)) 
[13:34:38.973]                               next
[13:34:38.973]                             invokeRestart(restart)
[13:34:38.973]                             muffled <- TRUE
[13:34:38.973]                             break
[13:34:38.973]                           }
[13:34:38.973]                         }
[13:34:38.973]                       }
[13:34:38.973]                       invisible(muffled)
[13:34:38.973]                     }
[13:34:38.973]                     muffleCondition(cond, pattern = "^muffle")
[13:34:38.973]                   }
[13:34:38.973]                 }
[13:34:38.973]             }
[13:34:38.973]         }))
[13:34:38.973]     }, error = function(ex) {
[13:34:38.973]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:38.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:38.973]                 ...future.rng), started = ...future.startTime, 
[13:34:38.973]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:38.973]             version = "1.8"), class = "FutureResult")
[13:34:38.973]     }, finally = {
[13:34:38.973]         if (!identical(...future.workdir, getwd())) 
[13:34:38.973]             setwd(...future.workdir)
[13:34:38.973]         {
[13:34:38.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:38.973]                 ...future.oldOptions$nwarnings <- NULL
[13:34:38.973]             }
[13:34:38.973]             base::options(...future.oldOptions)
[13:34:38.973]             if (.Platform$OS.type == "windows") {
[13:34:38.973]                 old_names <- names(...future.oldEnvVars)
[13:34:38.973]                 envs <- base::Sys.getenv()
[13:34:38.973]                 names <- names(envs)
[13:34:38.973]                 common <- intersect(names, old_names)
[13:34:38.973]                 added <- setdiff(names, old_names)
[13:34:38.973]                 removed <- setdiff(old_names, names)
[13:34:38.973]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:38.973]                   envs[common]]
[13:34:38.973]                 NAMES <- toupper(changed)
[13:34:38.973]                 args <- list()
[13:34:38.973]                 for (kk in seq_along(NAMES)) {
[13:34:38.973]                   name <- changed[[kk]]
[13:34:38.973]                   NAME <- NAMES[[kk]]
[13:34:38.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.973]                     next
[13:34:38.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.973]                 }
[13:34:38.973]                 NAMES <- toupper(added)
[13:34:38.973]                 for (kk in seq_along(NAMES)) {
[13:34:38.973]                   name <- added[[kk]]
[13:34:38.973]                   NAME <- NAMES[[kk]]
[13:34:38.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.973]                     next
[13:34:38.973]                   args[[name]] <- ""
[13:34:38.973]                 }
[13:34:38.973]                 NAMES <- toupper(removed)
[13:34:38.973]                 for (kk in seq_along(NAMES)) {
[13:34:38.973]                   name <- removed[[kk]]
[13:34:38.973]                   NAME <- NAMES[[kk]]
[13:34:38.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:38.973]                     next
[13:34:38.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:38.973]                 }
[13:34:38.973]                 if (length(args) > 0) 
[13:34:38.973]                   base::do.call(base::Sys.setenv, args = args)
[13:34:38.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:38.973]             }
[13:34:38.973]             else {
[13:34:38.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:38.973]             }
[13:34:38.973]             {
[13:34:38.973]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:38.973]                   0L) {
[13:34:38.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:38.973]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:38.973]                   base::options(opts)
[13:34:38.973]                 }
[13:34:38.973]                 {
[13:34:38.973]                   {
[13:34:38.973]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:38.973]                     NULL
[13:34:38.973]                   }
[13:34:38.973]                   options(future.plan = NULL)
[13:34:38.973]                   if (is.na(NA_character_)) 
[13:34:38.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:38.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:38.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:38.973]                     .init = FALSE)
[13:34:38.973]                 }
[13:34:38.973]             }
[13:34:38.973]         }
[13:34:38.973]     })
[13:34:38.973]     if (TRUE) {
[13:34:38.973]         base::sink(type = "output", split = FALSE)
[13:34:38.973]         if (TRUE) {
[13:34:38.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:38.973]         }
[13:34:38.973]         else {
[13:34:38.973]             ...future.result["stdout"] <- base::list(NULL)
[13:34:38.973]         }
[13:34:38.973]         base::close(...future.stdout)
[13:34:38.973]         ...future.stdout <- NULL
[13:34:38.973]     }
[13:34:38.973]     ...future.result$conditions <- ...future.conditions
[13:34:38.973]     ...future.result$finished <- base::Sys.time()
[13:34:38.973]     ...future.result
[13:34:38.973] }
[13:34:38.975] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[13:34:38.975] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[13:34:38.976] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[13:34:38.976] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:38.976] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.976] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[13:34:38.977] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[13:34:38.977] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:38.977] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.977] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:38.977] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:38.977] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[13:34:38.978] MultisessionFuture started
[13:34:38.978] - Launch lazy future ... done
[13:34:38.978] run() for ‘MultisessionFuture’ ... done
[13:34:38.978] Created future:
[13:34:38.978] MultisessionFuture:
[13:34:38.978] Label: ‘future_mapply-1’
[13:34:38.978] Expression:
[13:34:38.978] {
[13:34:38.978]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:38.978]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:38.978]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:38.978]         on.exit(options(oopts), add = TRUE)
[13:34:38.978]     }
[13:34:38.978]     {
[13:34:38.978]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:38.978]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:38.978]         do.call(mapply, args = args)
[13:34:38.978]     }
[13:34:38.978] }
[13:34:38.978] Lazy evaluation: FALSE
[13:34:38.978] Asynchronous evaluation: TRUE
[13:34:38.978] Local evaluation: TRUE
[13:34:38.978] Environment: R_GlobalEnv
[13:34:38.978] Capture standard output: TRUE
[13:34:38.978] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:38.978] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:38.978] Packages: <none>
[13:34:38.978] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:38.978] Resolved: FALSE
[13:34:38.978] Value: <not collected>
[13:34:38.978] Conditions captured: <none>
[13:34:38.978] Early signaling: FALSE
[13:34:38.978] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:38.978] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:38.990] Chunk #1 of 5 ... DONE
[13:34:38.990] Chunk #2 of 5 ...
[13:34:38.990]  - Finding globals in '...' for chunk #2 ...
[13:34:38.991] getGlobalsAndPackages() ...
[13:34:38.991] Searching for globals...
[13:34:38.991] 
[13:34:38.991] Searching for globals ... DONE
[13:34:38.991] - globals: [0] <none>
[13:34:38.991] getGlobalsAndPackages() ... DONE
[13:34:38.991]    + additional globals found: [n=0] 
[13:34:38.991]    + additional namespaces needed: [n=0] 
[13:34:38.991]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:38.992]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:38.992]  - seeds: <none>
[13:34:38.992]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.992] getGlobalsAndPackages() ...
[13:34:38.992] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.992] Resolving globals: FALSE
[13:34:38.992] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:38.993] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:38.993] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:38.993] 
[13:34:38.993] getGlobalsAndPackages() ... DONE
[13:34:38.994] run() for ‘Future’ ...
[13:34:38.994] - state: ‘created’
[13:34:38.994] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.008] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.008] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.008]   - Field: ‘node’
[13:34:39.008]   - Field: ‘label’
[13:34:39.008]   - Field: ‘local’
[13:34:39.008]   - Field: ‘owner’
[13:34:39.008]   - Field: ‘envir’
[13:34:39.008]   - Field: ‘workers’
[13:34:39.009]   - Field: ‘packages’
[13:34:39.009]   - Field: ‘gc’
[13:34:39.009]   - Field: ‘conditions’
[13:34:39.009]   - Field: ‘persistent’
[13:34:39.009]   - Field: ‘expr’
[13:34:39.009]   - Field: ‘uuid’
[13:34:39.009]   - Field: ‘seed’
[13:34:39.009]   - Field: ‘version’
[13:34:39.009]   - Field: ‘result’
[13:34:39.009]   - Field: ‘asynchronous’
[13:34:39.009]   - Field: ‘calls’
[13:34:39.010]   - Field: ‘globals’
[13:34:39.010]   - Field: ‘stdout’
[13:34:39.010]   - Field: ‘earlySignal’
[13:34:39.010]   - Field: ‘lazy’
[13:34:39.010]   - Field: ‘state’
[13:34:39.010] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.010] - Launch lazy future ...
[13:34:39.010] Packages needed by the future expression (n = 0): <none>
[13:34:39.010] Packages needed by future strategies (n = 0): <none>
[13:34:39.011] {
[13:34:39.011]     {
[13:34:39.011]         {
[13:34:39.011]             ...future.startTime <- base::Sys.time()
[13:34:39.011]             {
[13:34:39.011]                 {
[13:34:39.011]                   {
[13:34:39.011]                     {
[13:34:39.011]                       base::local({
[13:34:39.011]                         has_future <- base::requireNamespace("future", 
[13:34:39.011]                           quietly = TRUE)
[13:34:39.011]                         if (has_future) {
[13:34:39.011]                           ns <- base::getNamespace("future")
[13:34:39.011]                           version <- ns[[".package"]][["version"]]
[13:34:39.011]                           if (is.null(version)) 
[13:34:39.011]                             version <- utils::packageVersion("future")
[13:34:39.011]                         }
[13:34:39.011]                         else {
[13:34:39.011]                           version <- NULL
[13:34:39.011]                         }
[13:34:39.011]                         if (!has_future || version < "1.8.0") {
[13:34:39.011]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.011]                             "", base::R.version$version.string), 
[13:34:39.011]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.011]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.011]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.011]                               "release", "version")], collapse = " "), 
[13:34:39.011]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.011]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.011]                             info)
[13:34:39.011]                           info <- base::paste(info, collapse = "; ")
[13:34:39.011]                           if (!has_future) {
[13:34:39.011]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.011]                               info)
[13:34:39.011]                           }
[13:34:39.011]                           else {
[13:34:39.011]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.011]                               info, version)
[13:34:39.011]                           }
[13:34:39.011]                           base::stop(msg)
[13:34:39.011]                         }
[13:34:39.011]                       })
[13:34:39.011]                     }
[13:34:39.011]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.011]                     base::options(mc.cores = 1L)
[13:34:39.011]                   }
[13:34:39.011]                   ...future.strategy.old <- future::plan("list")
[13:34:39.011]                   options(future.plan = NULL)
[13:34:39.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.011]                 }
[13:34:39.011]                 ...future.workdir <- getwd()
[13:34:39.011]             }
[13:34:39.011]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.011]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.011]         }
[13:34:39.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.011]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:39.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.011]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.011]             base::names(...future.oldOptions))
[13:34:39.011]     }
[13:34:39.011]     if (FALSE) {
[13:34:39.011]     }
[13:34:39.011]     else {
[13:34:39.011]         if (TRUE) {
[13:34:39.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.011]                 open = "w")
[13:34:39.011]         }
[13:34:39.011]         else {
[13:34:39.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.011]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.011]         }
[13:34:39.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.011]             base::sink(type = "output", split = FALSE)
[13:34:39.011]             base::close(...future.stdout)
[13:34:39.011]         }, add = TRUE)
[13:34:39.011]     }
[13:34:39.011]     ...future.frame <- base::sys.nframe()
[13:34:39.011]     ...future.conditions <- base::list()
[13:34:39.011]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.011]     if (FALSE) {
[13:34:39.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.011]     }
[13:34:39.011]     ...future.result <- base::tryCatch({
[13:34:39.011]         base::withCallingHandlers({
[13:34:39.011]             ...future.value <- base::withVisible(base::local({
[13:34:39.011]                 ...future.makeSendCondition <- base::local({
[13:34:39.011]                   sendCondition <- NULL
[13:34:39.011]                   function(frame = 1L) {
[13:34:39.011]                     if (is.function(sendCondition)) 
[13:34:39.011]                       return(sendCondition)
[13:34:39.011]                     ns <- getNamespace("parallel")
[13:34:39.011]                     if (exists("sendData", mode = "function", 
[13:34:39.011]                       envir = ns)) {
[13:34:39.011]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.011]                         envir = ns)
[13:34:39.011]                       envir <- sys.frame(frame)
[13:34:39.011]                       master <- NULL
[13:34:39.011]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.011]                         !identical(envir, emptyenv())) {
[13:34:39.011]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.011]                           inherits = FALSE)) {
[13:34:39.011]                           master <- get("master", mode = "list", 
[13:34:39.011]                             envir = envir, inherits = FALSE)
[13:34:39.011]                           if (inherits(master, c("SOCKnode", 
[13:34:39.011]                             "SOCK0node"))) {
[13:34:39.011]                             sendCondition <<- function(cond) {
[13:34:39.011]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.011]                                 success = TRUE)
[13:34:39.011]                               parallel_sendData(master, data)
[13:34:39.011]                             }
[13:34:39.011]                             return(sendCondition)
[13:34:39.011]                           }
[13:34:39.011]                         }
[13:34:39.011]                         frame <- frame + 1L
[13:34:39.011]                         envir <- sys.frame(frame)
[13:34:39.011]                       }
[13:34:39.011]                     }
[13:34:39.011]                     sendCondition <<- function(cond) NULL
[13:34:39.011]                   }
[13:34:39.011]                 })
[13:34:39.011]                 withCallingHandlers({
[13:34:39.011]                   {
[13:34:39.011]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.011]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.011]                       ...future.globals.maxSize)) {
[13:34:39.011]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.011]                       on.exit(options(oopts), add = TRUE)
[13:34:39.011]                     }
[13:34:39.011]                     {
[13:34:39.011]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.011]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.011]                         USE.NAMES = FALSE)
[13:34:39.011]                       do.call(mapply, args = args)
[13:34:39.011]                     }
[13:34:39.011]                   }
[13:34:39.011]                 }, immediateCondition = function(cond) {
[13:34:39.011]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.011]                   sendCondition(cond)
[13:34:39.011]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.011]                   {
[13:34:39.011]                     inherits <- base::inherits
[13:34:39.011]                     invokeRestart <- base::invokeRestart
[13:34:39.011]                     is.null <- base::is.null
[13:34:39.011]                     muffled <- FALSE
[13:34:39.011]                     if (inherits(cond, "message")) {
[13:34:39.011]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.011]                       if (muffled) 
[13:34:39.011]                         invokeRestart("muffleMessage")
[13:34:39.011]                     }
[13:34:39.011]                     else if (inherits(cond, "warning")) {
[13:34:39.011]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.011]                       if (muffled) 
[13:34:39.011]                         invokeRestart("muffleWarning")
[13:34:39.011]                     }
[13:34:39.011]                     else if (inherits(cond, "condition")) {
[13:34:39.011]                       if (!is.null(pattern)) {
[13:34:39.011]                         computeRestarts <- base::computeRestarts
[13:34:39.011]                         grepl <- base::grepl
[13:34:39.011]                         restarts <- computeRestarts(cond)
[13:34:39.011]                         for (restart in restarts) {
[13:34:39.011]                           name <- restart$name
[13:34:39.011]                           if (is.null(name)) 
[13:34:39.011]                             next
[13:34:39.011]                           if (!grepl(pattern, name)) 
[13:34:39.011]                             next
[13:34:39.011]                           invokeRestart(restart)
[13:34:39.011]                           muffled <- TRUE
[13:34:39.011]                           break
[13:34:39.011]                         }
[13:34:39.011]                       }
[13:34:39.011]                     }
[13:34:39.011]                     invisible(muffled)
[13:34:39.011]                   }
[13:34:39.011]                   muffleCondition(cond)
[13:34:39.011]                 })
[13:34:39.011]             }))
[13:34:39.011]             future::FutureResult(value = ...future.value$value, 
[13:34:39.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.011]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.011]                     ...future.globalenv.names))
[13:34:39.011]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.011]         }, condition = base::local({
[13:34:39.011]             c <- base::c
[13:34:39.011]             inherits <- base::inherits
[13:34:39.011]             invokeRestart <- base::invokeRestart
[13:34:39.011]             length <- base::length
[13:34:39.011]             list <- base::list
[13:34:39.011]             seq.int <- base::seq.int
[13:34:39.011]             signalCondition <- base::signalCondition
[13:34:39.011]             sys.calls <- base::sys.calls
[13:34:39.011]             `[[` <- base::`[[`
[13:34:39.011]             `+` <- base::`+`
[13:34:39.011]             `<<-` <- base::`<<-`
[13:34:39.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.011]                   3L)]
[13:34:39.011]             }
[13:34:39.011]             function(cond) {
[13:34:39.011]                 is_error <- inherits(cond, "error")
[13:34:39.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.011]                   NULL)
[13:34:39.011]                 if (is_error) {
[13:34:39.011]                   sessionInformation <- function() {
[13:34:39.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.011]                       search = base::search(), system = base::Sys.info())
[13:34:39.011]                   }
[13:34:39.011]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.011]                     cond$call), session = sessionInformation(), 
[13:34:39.011]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.011]                   signalCondition(cond)
[13:34:39.011]                 }
[13:34:39.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.011]                 "immediateCondition"))) {
[13:34:39.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.011]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.011]                   if (TRUE && !signal) {
[13:34:39.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.011]                     {
[13:34:39.011]                       inherits <- base::inherits
[13:34:39.011]                       invokeRestart <- base::invokeRestart
[13:34:39.011]                       is.null <- base::is.null
[13:34:39.011]                       muffled <- FALSE
[13:34:39.011]                       if (inherits(cond, "message")) {
[13:34:39.011]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.011]                         if (muffled) 
[13:34:39.011]                           invokeRestart("muffleMessage")
[13:34:39.011]                       }
[13:34:39.011]                       else if (inherits(cond, "warning")) {
[13:34:39.011]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.011]                         if (muffled) 
[13:34:39.011]                           invokeRestart("muffleWarning")
[13:34:39.011]                       }
[13:34:39.011]                       else if (inherits(cond, "condition")) {
[13:34:39.011]                         if (!is.null(pattern)) {
[13:34:39.011]                           computeRestarts <- base::computeRestarts
[13:34:39.011]                           grepl <- base::grepl
[13:34:39.011]                           restarts <- computeRestarts(cond)
[13:34:39.011]                           for (restart in restarts) {
[13:34:39.011]                             name <- restart$name
[13:34:39.011]                             if (is.null(name)) 
[13:34:39.011]                               next
[13:34:39.011]                             if (!grepl(pattern, name)) 
[13:34:39.011]                               next
[13:34:39.011]                             invokeRestart(restart)
[13:34:39.011]                             muffled <- TRUE
[13:34:39.011]                             break
[13:34:39.011]                           }
[13:34:39.011]                         }
[13:34:39.011]                       }
[13:34:39.011]                       invisible(muffled)
[13:34:39.011]                     }
[13:34:39.011]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.011]                   }
[13:34:39.011]                 }
[13:34:39.011]                 else {
[13:34:39.011]                   if (TRUE) {
[13:34:39.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.011]                     {
[13:34:39.011]                       inherits <- base::inherits
[13:34:39.011]                       invokeRestart <- base::invokeRestart
[13:34:39.011]                       is.null <- base::is.null
[13:34:39.011]                       muffled <- FALSE
[13:34:39.011]                       if (inherits(cond, "message")) {
[13:34:39.011]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.011]                         if (muffled) 
[13:34:39.011]                           invokeRestart("muffleMessage")
[13:34:39.011]                       }
[13:34:39.011]                       else if (inherits(cond, "warning")) {
[13:34:39.011]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.011]                         if (muffled) 
[13:34:39.011]                           invokeRestart("muffleWarning")
[13:34:39.011]                       }
[13:34:39.011]                       else if (inherits(cond, "condition")) {
[13:34:39.011]                         if (!is.null(pattern)) {
[13:34:39.011]                           computeRestarts <- base::computeRestarts
[13:34:39.011]                           grepl <- base::grepl
[13:34:39.011]                           restarts <- computeRestarts(cond)
[13:34:39.011]                           for (restart in restarts) {
[13:34:39.011]                             name <- restart$name
[13:34:39.011]                             if (is.null(name)) 
[13:34:39.011]                               next
[13:34:39.011]                             if (!grepl(pattern, name)) 
[13:34:39.011]                               next
[13:34:39.011]                             invokeRestart(restart)
[13:34:39.011]                             muffled <- TRUE
[13:34:39.011]                             break
[13:34:39.011]                           }
[13:34:39.011]                         }
[13:34:39.011]                       }
[13:34:39.011]                       invisible(muffled)
[13:34:39.011]                     }
[13:34:39.011]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.011]                   }
[13:34:39.011]                 }
[13:34:39.011]             }
[13:34:39.011]         }))
[13:34:39.011]     }, error = function(ex) {
[13:34:39.011]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.011]                 ...future.rng), started = ...future.startTime, 
[13:34:39.011]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.011]             version = "1.8"), class = "FutureResult")
[13:34:39.011]     }, finally = {
[13:34:39.011]         if (!identical(...future.workdir, getwd())) 
[13:34:39.011]             setwd(...future.workdir)
[13:34:39.011]         {
[13:34:39.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.011]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.011]             }
[13:34:39.011]             base::options(...future.oldOptions)
[13:34:39.011]             if (.Platform$OS.type == "windows") {
[13:34:39.011]                 old_names <- names(...future.oldEnvVars)
[13:34:39.011]                 envs <- base::Sys.getenv()
[13:34:39.011]                 names <- names(envs)
[13:34:39.011]                 common <- intersect(names, old_names)
[13:34:39.011]                 added <- setdiff(names, old_names)
[13:34:39.011]                 removed <- setdiff(old_names, names)
[13:34:39.011]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.011]                   envs[common]]
[13:34:39.011]                 NAMES <- toupper(changed)
[13:34:39.011]                 args <- list()
[13:34:39.011]                 for (kk in seq_along(NAMES)) {
[13:34:39.011]                   name <- changed[[kk]]
[13:34:39.011]                   NAME <- NAMES[[kk]]
[13:34:39.011]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.011]                     next
[13:34:39.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.011]                 }
[13:34:39.011]                 NAMES <- toupper(added)
[13:34:39.011]                 for (kk in seq_along(NAMES)) {
[13:34:39.011]                   name <- added[[kk]]
[13:34:39.011]                   NAME <- NAMES[[kk]]
[13:34:39.011]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.011]                     next
[13:34:39.011]                   args[[name]] <- ""
[13:34:39.011]                 }
[13:34:39.011]                 NAMES <- toupper(removed)
[13:34:39.011]                 for (kk in seq_along(NAMES)) {
[13:34:39.011]                   name <- removed[[kk]]
[13:34:39.011]                   NAME <- NAMES[[kk]]
[13:34:39.011]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.011]                     next
[13:34:39.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.011]                 }
[13:34:39.011]                 if (length(args) > 0) 
[13:34:39.011]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.011]             }
[13:34:39.011]             else {
[13:34:39.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.011]             }
[13:34:39.011]             {
[13:34:39.011]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.011]                   0L) {
[13:34:39.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.011]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.011]                   base::options(opts)
[13:34:39.011]                 }
[13:34:39.011]                 {
[13:34:39.011]                   {
[13:34:39.011]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.011]                     NULL
[13:34:39.011]                   }
[13:34:39.011]                   options(future.plan = NULL)
[13:34:39.011]                   if (is.na(NA_character_)) 
[13:34:39.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.011]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.011]                     .init = FALSE)
[13:34:39.011]                 }
[13:34:39.011]             }
[13:34:39.011]         }
[13:34:39.011]     })
[13:34:39.011]     if (TRUE) {
[13:34:39.011]         base::sink(type = "output", split = FALSE)
[13:34:39.011]         if (TRUE) {
[13:34:39.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.011]         }
[13:34:39.011]         else {
[13:34:39.011]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.011]         }
[13:34:39.011]         base::close(...future.stdout)
[13:34:39.011]         ...future.stdout <- NULL
[13:34:39.011]     }
[13:34:39.011]     ...future.result$conditions <- ...future.conditions
[13:34:39.011]     ...future.result$finished <- base::Sys.time()
[13:34:39.011]     ...future.result
[13:34:39.011] }
[13:34:39.013] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[13:34:39.014] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[13:34:39.014] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[13:34:39.014] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:39.014] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.015] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[13:34:39.015] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[13:34:39.015] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:39.015] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.015] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:39.016] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.016] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[13:34:39.016] MultisessionFuture started
[13:34:39.016] - Launch lazy future ... done
[13:34:39.017] run() for ‘MultisessionFuture’ ... done
[13:34:39.017] Created future:
[13:34:39.017] MultisessionFuture:
[13:34:39.017] Label: ‘future_mapply-2’
[13:34:39.017] Expression:
[13:34:39.017] {
[13:34:39.017]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.017]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.017]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.017]         on.exit(options(oopts), add = TRUE)
[13:34:39.017]     }
[13:34:39.017]     {
[13:34:39.017]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.017]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.017]         do.call(mapply, args = args)
[13:34:39.017]     }
[13:34:39.017] }
[13:34:39.017] Lazy evaluation: FALSE
[13:34:39.017] Asynchronous evaluation: TRUE
[13:34:39.017] Local evaluation: TRUE
[13:34:39.017] Environment: R_GlobalEnv
[13:34:39.017] Capture standard output: TRUE
[13:34:39.017] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.017] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.017] Packages: <none>
[13:34:39.017] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.017] Resolved: FALSE
[13:34:39.017] Value: <not collected>
[13:34:39.017] Conditions captured: <none>
[13:34:39.017] Early signaling: FALSE
[13:34:39.017] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.017] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.035] Chunk #2 of 5 ... DONE
[13:34:39.035] Chunk #3 of 5 ...
[13:34:39.035]  - Finding globals in '...' for chunk #3 ...
[13:34:39.035] getGlobalsAndPackages() ...
[13:34:39.035] Searching for globals...
[13:34:39.035] 
[13:34:39.035] Searching for globals ... DONE
[13:34:39.036] - globals: [0] <none>
[13:34:39.036] getGlobalsAndPackages() ... DONE
[13:34:39.036]    + additional globals found: [n=0] 
[13:34:39.036]    + additional namespaces needed: [n=0] 
[13:34:39.036]  - Finding globals in '...' for chunk #3 ... DONE
[13:34:39.036]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:39.036]  - seeds: <none>
[13:34:39.036]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.036] getGlobalsAndPackages() ...
[13:34:39.036] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.036] Resolving globals: FALSE
[13:34:39.037] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:39.037] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:39.037] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.038] 
[13:34:39.038] getGlobalsAndPackages() ... DONE
[13:34:39.038] run() for ‘Future’ ...
[13:34:39.038] - state: ‘created’
[13:34:39.038] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.051] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.052]   - Field: ‘node’
[13:34:39.052]   - Field: ‘label’
[13:34:39.052]   - Field: ‘local’
[13:34:39.052]   - Field: ‘owner’
[13:34:39.052]   - Field: ‘envir’
[13:34:39.052]   - Field: ‘workers’
[13:34:39.052]   - Field: ‘packages’
[13:34:39.052]   - Field: ‘gc’
[13:34:39.052]   - Field: ‘conditions’
[13:34:39.052]   - Field: ‘persistent’
[13:34:39.053]   - Field: ‘expr’
[13:34:39.053]   - Field: ‘uuid’
[13:34:39.053]   - Field: ‘seed’
[13:34:39.053]   - Field: ‘version’
[13:34:39.053]   - Field: ‘result’
[13:34:39.053]   - Field: ‘asynchronous’
[13:34:39.053]   - Field: ‘calls’
[13:34:39.053]   - Field: ‘globals’
[13:34:39.053]   - Field: ‘stdout’
[13:34:39.053]   - Field: ‘earlySignal’
[13:34:39.053]   - Field: ‘lazy’
[13:34:39.054]   - Field: ‘state’
[13:34:39.054] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.054] - Launch lazy future ...
[13:34:39.054] Packages needed by the future expression (n = 0): <none>
[13:34:39.054] Packages needed by future strategies (n = 0): <none>
[13:34:39.054] {
[13:34:39.054]     {
[13:34:39.054]         {
[13:34:39.054]             ...future.startTime <- base::Sys.time()
[13:34:39.054]             {
[13:34:39.054]                 {
[13:34:39.054]                   {
[13:34:39.054]                     {
[13:34:39.054]                       base::local({
[13:34:39.054]                         has_future <- base::requireNamespace("future", 
[13:34:39.054]                           quietly = TRUE)
[13:34:39.054]                         if (has_future) {
[13:34:39.054]                           ns <- base::getNamespace("future")
[13:34:39.054]                           version <- ns[[".package"]][["version"]]
[13:34:39.054]                           if (is.null(version)) 
[13:34:39.054]                             version <- utils::packageVersion("future")
[13:34:39.054]                         }
[13:34:39.054]                         else {
[13:34:39.054]                           version <- NULL
[13:34:39.054]                         }
[13:34:39.054]                         if (!has_future || version < "1.8.0") {
[13:34:39.054]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.054]                             "", base::R.version$version.string), 
[13:34:39.054]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.054]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.054]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.054]                               "release", "version")], collapse = " "), 
[13:34:39.054]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.054]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.054]                             info)
[13:34:39.054]                           info <- base::paste(info, collapse = "; ")
[13:34:39.054]                           if (!has_future) {
[13:34:39.054]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.054]                               info)
[13:34:39.054]                           }
[13:34:39.054]                           else {
[13:34:39.054]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.054]                               info, version)
[13:34:39.054]                           }
[13:34:39.054]                           base::stop(msg)
[13:34:39.054]                         }
[13:34:39.054]                       })
[13:34:39.054]                     }
[13:34:39.054]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.054]                     base::options(mc.cores = 1L)
[13:34:39.054]                   }
[13:34:39.054]                   ...future.strategy.old <- future::plan("list")
[13:34:39.054]                   options(future.plan = NULL)
[13:34:39.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.054]                 }
[13:34:39.054]                 ...future.workdir <- getwd()
[13:34:39.054]             }
[13:34:39.054]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.054]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.054]         }
[13:34:39.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.054]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:39.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.054]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.054]             base::names(...future.oldOptions))
[13:34:39.054]     }
[13:34:39.054]     if (FALSE) {
[13:34:39.054]     }
[13:34:39.054]     else {
[13:34:39.054]         if (TRUE) {
[13:34:39.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.054]                 open = "w")
[13:34:39.054]         }
[13:34:39.054]         else {
[13:34:39.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.054]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.054]         }
[13:34:39.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.054]             base::sink(type = "output", split = FALSE)
[13:34:39.054]             base::close(...future.stdout)
[13:34:39.054]         }, add = TRUE)
[13:34:39.054]     }
[13:34:39.054]     ...future.frame <- base::sys.nframe()
[13:34:39.054]     ...future.conditions <- base::list()
[13:34:39.054]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.054]     if (FALSE) {
[13:34:39.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.054]     }
[13:34:39.054]     ...future.result <- base::tryCatch({
[13:34:39.054]         base::withCallingHandlers({
[13:34:39.054]             ...future.value <- base::withVisible(base::local({
[13:34:39.054]                 ...future.makeSendCondition <- base::local({
[13:34:39.054]                   sendCondition <- NULL
[13:34:39.054]                   function(frame = 1L) {
[13:34:39.054]                     if (is.function(sendCondition)) 
[13:34:39.054]                       return(sendCondition)
[13:34:39.054]                     ns <- getNamespace("parallel")
[13:34:39.054]                     if (exists("sendData", mode = "function", 
[13:34:39.054]                       envir = ns)) {
[13:34:39.054]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.054]                         envir = ns)
[13:34:39.054]                       envir <- sys.frame(frame)
[13:34:39.054]                       master <- NULL
[13:34:39.054]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.054]                         !identical(envir, emptyenv())) {
[13:34:39.054]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.054]                           inherits = FALSE)) {
[13:34:39.054]                           master <- get("master", mode = "list", 
[13:34:39.054]                             envir = envir, inherits = FALSE)
[13:34:39.054]                           if (inherits(master, c("SOCKnode", 
[13:34:39.054]                             "SOCK0node"))) {
[13:34:39.054]                             sendCondition <<- function(cond) {
[13:34:39.054]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.054]                                 success = TRUE)
[13:34:39.054]                               parallel_sendData(master, data)
[13:34:39.054]                             }
[13:34:39.054]                             return(sendCondition)
[13:34:39.054]                           }
[13:34:39.054]                         }
[13:34:39.054]                         frame <- frame + 1L
[13:34:39.054]                         envir <- sys.frame(frame)
[13:34:39.054]                       }
[13:34:39.054]                     }
[13:34:39.054]                     sendCondition <<- function(cond) NULL
[13:34:39.054]                   }
[13:34:39.054]                 })
[13:34:39.054]                 withCallingHandlers({
[13:34:39.054]                   {
[13:34:39.054]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.054]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.054]                       ...future.globals.maxSize)) {
[13:34:39.054]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.054]                       on.exit(options(oopts), add = TRUE)
[13:34:39.054]                     }
[13:34:39.054]                     {
[13:34:39.054]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.054]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.054]                         USE.NAMES = FALSE)
[13:34:39.054]                       do.call(mapply, args = args)
[13:34:39.054]                     }
[13:34:39.054]                   }
[13:34:39.054]                 }, immediateCondition = function(cond) {
[13:34:39.054]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.054]                   sendCondition(cond)
[13:34:39.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.054]                   {
[13:34:39.054]                     inherits <- base::inherits
[13:34:39.054]                     invokeRestart <- base::invokeRestart
[13:34:39.054]                     is.null <- base::is.null
[13:34:39.054]                     muffled <- FALSE
[13:34:39.054]                     if (inherits(cond, "message")) {
[13:34:39.054]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.054]                       if (muffled) 
[13:34:39.054]                         invokeRestart("muffleMessage")
[13:34:39.054]                     }
[13:34:39.054]                     else if (inherits(cond, "warning")) {
[13:34:39.054]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.054]                       if (muffled) 
[13:34:39.054]                         invokeRestart("muffleWarning")
[13:34:39.054]                     }
[13:34:39.054]                     else if (inherits(cond, "condition")) {
[13:34:39.054]                       if (!is.null(pattern)) {
[13:34:39.054]                         computeRestarts <- base::computeRestarts
[13:34:39.054]                         grepl <- base::grepl
[13:34:39.054]                         restarts <- computeRestarts(cond)
[13:34:39.054]                         for (restart in restarts) {
[13:34:39.054]                           name <- restart$name
[13:34:39.054]                           if (is.null(name)) 
[13:34:39.054]                             next
[13:34:39.054]                           if (!grepl(pattern, name)) 
[13:34:39.054]                             next
[13:34:39.054]                           invokeRestart(restart)
[13:34:39.054]                           muffled <- TRUE
[13:34:39.054]                           break
[13:34:39.054]                         }
[13:34:39.054]                       }
[13:34:39.054]                     }
[13:34:39.054]                     invisible(muffled)
[13:34:39.054]                   }
[13:34:39.054]                   muffleCondition(cond)
[13:34:39.054]                 })
[13:34:39.054]             }))
[13:34:39.054]             future::FutureResult(value = ...future.value$value, 
[13:34:39.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.054]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.054]                     ...future.globalenv.names))
[13:34:39.054]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.054]         }, condition = base::local({
[13:34:39.054]             c <- base::c
[13:34:39.054]             inherits <- base::inherits
[13:34:39.054]             invokeRestart <- base::invokeRestart
[13:34:39.054]             length <- base::length
[13:34:39.054]             list <- base::list
[13:34:39.054]             seq.int <- base::seq.int
[13:34:39.054]             signalCondition <- base::signalCondition
[13:34:39.054]             sys.calls <- base::sys.calls
[13:34:39.054]             `[[` <- base::`[[`
[13:34:39.054]             `+` <- base::`+`
[13:34:39.054]             `<<-` <- base::`<<-`
[13:34:39.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.054]                   3L)]
[13:34:39.054]             }
[13:34:39.054]             function(cond) {
[13:34:39.054]                 is_error <- inherits(cond, "error")
[13:34:39.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.054]                   NULL)
[13:34:39.054]                 if (is_error) {
[13:34:39.054]                   sessionInformation <- function() {
[13:34:39.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.054]                       search = base::search(), system = base::Sys.info())
[13:34:39.054]                   }
[13:34:39.054]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.054]                     cond$call), session = sessionInformation(), 
[13:34:39.054]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.054]                   signalCondition(cond)
[13:34:39.054]                 }
[13:34:39.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.054]                 "immediateCondition"))) {
[13:34:39.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.054]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.054]                   if (TRUE && !signal) {
[13:34:39.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.054]                     {
[13:34:39.054]                       inherits <- base::inherits
[13:34:39.054]                       invokeRestart <- base::invokeRestart
[13:34:39.054]                       is.null <- base::is.null
[13:34:39.054]                       muffled <- FALSE
[13:34:39.054]                       if (inherits(cond, "message")) {
[13:34:39.054]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.054]                         if (muffled) 
[13:34:39.054]                           invokeRestart("muffleMessage")
[13:34:39.054]                       }
[13:34:39.054]                       else if (inherits(cond, "warning")) {
[13:34:39.054]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.054]                         if (muffled) 
[13:34:39.054]                           invokeRestart("muffleWarning")
[13:34:39.054]                       }
[13:34:39.054]                       else if (inherits(cond, "condition")) {
[13:34:39.054]                         if (!is.null(pattern)) {
[13:34:39.054]                           computeRestarts <- base::computeRestarts
[13:34:39.054]                           grepl <- base::grepl
[13:34:39.054]                           restarts <- computeRestarts(cond)
[13:34:39.054]                           for (restart in restarts) {
[13:34:39.054]                             name <- restart$name
[13:34:39.054]                             if (is.null(name)) 
[13:34:39.054]                               next
[13:34:39.054]                             if (!grepl(pattern, name)) 
[13:34:39.054]                               next
[13:34:39.054]                             invokeRestart(restart)
[13:34:39.054]                             muffled <- TRUE
[13:34:39.054]                             break
[13:34:39.054]                           }
[13:34:39.054]                         }
[13:34:39.054]                       }
[13:34:39.054]                       invisible(muffled)
[13:34:39.054]                     }
[13:34:39.054]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.054]                   }
[13:34:39.054]                 }
[13:34:39.054]                 else {
[13:34:39.054]                   if (TRUE) {
[13:34:39.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.054]                     {
[13:34:39.054]                       inherits <- base::inherits
[13:34:39.054]                       invokeRestart <- base::invokeRestart
[13:34:39.054]                       is.null <- base::is.null
[13:34:39.054]                       muffled <- FALSE
[13:34:39.054]                       if (inherits(cond, "message")) {
[13:34:39.054]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.054]                         if (muffled) 
[13:34:39.054]                           invokeRestart("muffleMessage")
[13:34:39.054]                       }
[13:34:39.054]                       else if (inherits(cond, "warning")) {
[13:34:39.054]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.054]                         if (muffled) 
[13:34:39.054]                           invokeRestart("muffleWarning")
[13:34:39.054]                       }
[13:34:39.054]                       else if (inherits(cond, "condition")) {
[13:34:39.054]                         if (!is.null(pattern)) {
[13:34:39.054]                           computeRestarts <- base::computeRestarts
[13:34:39.054]                           grepl <- base::grepl
[13:34:39.054]                           restarts <- computeRestarts(cond)
[13:34:39.054]                           for (restart in restarts) {
[13:34:39.054]                             name <- restart$name
[13:34:39.054]                             if (is.null(name)) 
[13:34:39.054]                               next
[13:34:39.054]                             if (!grepl(pattern, name)) 
[13:34:39.054]                               next
[13:34:39.054]                             invokeRestart(restart)
[13:34:39.054]                             muffled <- TRUE
[13:34:39.054]                             break
[13:34:39.054]                           }
[13:34:39.054]                         }
[13:34:39.054]                       }
[13:34:39.054]                       invisible(muffled)
[13:34:39.054]                     }
[13:34:39.054]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.054]                   }
[13:34:39.054]                 }
[13:34:39.054]             }
[13:34:39.054]         }))
[13:34:39.054]     }, error = function(ex) {
[13:34:39.054]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.054]                 ...future.rng), started = ...future.startTime, 
[13:34:39.054]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.054]             version = "1.8"), class = "FutureResult")
[13:34:39.054]     }, finally = {
[13:34:39.054]         if (!identical(...future.workdir, getwd())) 
[13:34:39.054]             setwd(...future.workdir)
[13:34:39.054]         {
[13:34:39.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.054]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.054]             }
[13:34:39.054]             base::options(...future.oldOptions)
[13:34:39.054]             if (.Platform$OS.type == "windows") {
[13:34:39.054]                 old_names <- names(...future.oldEnvVars)
[13:34:39.054]                 envs <- base::Sys.getenv()
[13:34:39.054]                 names <- names(envs)
[13:34:39.054]                 common <- intersect(names, old_names)
[13:34:39.054]                 added <- setdiff(names, old_names)
[13:34:39.054]                 removed <- setdiff(old_names, names)
[13:34:39.054]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.054]                   envs[common]]
[13:34:39.054]                 NAMES <- toupper(changed)
[13:34:39.054]                 args <- list()
[13:34:39.054]                 for (kk in seq_along(NAMES)) {
[13:34:39.054]                   name <- changed[[kk]]
[13:34:39.054]                   NAME <- NAMES[[kk]]
[13:34:39.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.054]                     next
[13:34:39.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.054]                 }
[13:34:39.054]                 NAMES <- toupper(added)
[13:34:39.054]                 for (kk in seq_along(NAMES)) {
[13:34:39.054]                   name <- added[[kk]]
[13:34:39.054]                   NAME <- NAMES[[kk]]
[13:34:39.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.054]                     next
[13:34:39.054]                   args[[name]] <- ""
[13:34:39.054]                 }
[13:34:39.054]                 NAMES <- toupper(removed)
[13:34:39.054]                 for (kk in seq_along(NAMES)) {
[13:34:39.054]                   name <- removed[[kk]]
[13:34:39.054]                   NAME <- NAMES[[kk]]
[13:34:39.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.054]                     next
[13:34:39.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.054]                 }
[13:34:39.054]                 if (length(args) > 0) 
[13:34:39.054]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.054]             }
[13:34:39.054]             else {
[13:34:39.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.054]             }
[13:34:39.054]             {
[13:34:39.054]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.054]                   0L) {
[13:34:39.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.054]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.054]                   base::options(opts)
[13:34:39.054]                 }
[13:34:39.054]                 {
[13:34:39.054]                   {
[13:34:39.054]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.054]                     NULL
[13:34:39.054]                   }
[13:34:39.054]                   options(future.plan = NULL)
[13:34:39.054]                   if (is.na(NA_character_)) 
[13:34:39.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.054]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.054]                     .init = FALSE)
[13:34:39.054]                 }
[13:34:39.054]             }
[13:34:39.054]         }
[13:34:39.054]     })
[13:34:39.054]     if (TRUE) {
[13:34:39.054]         base::sink(type = "output", split = FALSE)
[13:34:39.054]         if (TRUE) {
[13:34:39.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.054]         }
[13:34:39.054]         else {
[13:34:39.054]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.054]         }
[13:34:39.054]         base::close(...future.stdout)
[13:34:39.054]         ...future.stdout <- NULL
[13:34:39.054]     }
[13:34:39.054]     ...future.result$conditions <- ...future.conditions
[13:34:39.054]     ...future.result$finished <- base::Sys.time()
[13:34:39.054]     ...future.result
[13:34:39.054] }
[13:34:39.057] Poll #1 (0): usedNodes() = 2, workers = 2
[13:34:39.067] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.067] - Validating connection of MultisessionFuture
[13:34:39.068] - received message: FutureResult
[13:34:39.068] - Received FutureResult
[13:34:39.068] - Erased future from FutureRegistry
[13:34:39.068] result() for ClusterFuture ...
[13:34:39.068] - result already collected: FutureResult
[13:34:39.068] result() for ClusterFuture ... done
[13:34:39.068] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.068] result() for ClusterFuture ...
[13:34:39.068] - result already collected: FutureResult
[13:34:39.068] result() for ClusterFuture ... done
[13:34:39.068] result() for ClusterFuture ...
[13:34:39.069] - result already collected: FutureResult
[13:34:39.069] result() for ClusterFuture ... done
[13:34:39.069] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[13:34:39.069] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[13:34:39.070] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[13:34:39.070] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:39.070] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.070] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[13:34:39.071] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[13:34:39.071] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:39.071] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.071] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:39.071] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.072] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[13:34:39.072] MultisessionFuture started
[13:34:39.072] - Launch lazy future ... done
[13:34:39.072] run() for ‘MultisessionFuture’ ... done
[13:34:39.072] Created future:
[13:34:39.072] MultisessionFuture:
[13:34:39.072] Label: ‘future_mapply-3’
[13:34:39.072] Expression:
[13:34:39.072] {
[13:34:39.072]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.072]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.072]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.072]         on.exit(options(oopts), add = TRUE)
[13:34:39.072]     }
[13:34:39.072]     {
[13:34:39.072]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.072]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.072]         do.call(mapply, args = args)
[13:34:39.072]     }
[13:34:39.072] }
[13:34:39.072] Lazy evaluation: FALSE
[13:34:39.072] Asynchronous evaluation: TRUE
[13:34:39.072] Local evaluation: TRUE
[13:34:39.072] Environment: R_GlobalEnv
[13:34:39.072] Capture standard output: TRUE
[13:34:39.072] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.072] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.072] Packages: <none>
[13:34:39.072] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.072] Resolved: FALSE
[13:34:39.072] Value: <not collected>
[13:34:39.072] Conditions captured: <none>
[13:34:39.072] Early signaling: FALSE
[13:34:39.072] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.072] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.084] Chunk #3 of 5 ... DONE
[13:34:39.084] Chunk #4 of 5 ...
[13:34:39.084]  - Finding globals in '...' for chunk #4 ...
[13:34:39.084] getGlobalsAndPackages() ...
[13:34:39.084] Searching for globals...
[13:34:39.085] 
[13:34:39.085] Searching for globals ... DONE
[13:34:39.085] - globals: [0] <none>
[13:34:39.085] getGlobalsAndPackages() ... DONE
[13:34:39.085]    + additional globals found: [n=0] 
[13:34:39.085]    + additional namespaces needed: [n=0] 
[13:34:39.085]  - Finding globals in '...' for chunk #4 ... DONE
[13:34:39.085]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:39.085]  - seeds: <none>
[13:34:39.085]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.085] getGlobalsAndPackages() ...
[13:34:39.086] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.086] Resolving globals: FALSE
[13:34:39.086] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:39.087] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:39.087] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.087] 
[13:34:39.087] getGlobalsAndPackages() ... DONE
[13:34:39.087] run() for ‘Future’ ...
[13:34:39.087] - state: ‘created’
[13:34:39.087] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.102] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.102]   - Field: ‘node’
[13:34:39.103]   - Field: ‘label’
[13:34:39.103]   - Field: ‘local’
[13:34:39.103]   - Field: ‘owner’
[13:34:39.103]   - Field: ‘envir’
[13:34:39.103]   - Field: ‘workers’
[13:34:39.103]   - Field: ‘packages’
[13:34:39.103]   - Field: ‘gc’
[13:34:39.103]   - Field: ‘conditions’
[13:34:39.103]   - Field: ‘persistent’
[13:34:39.103]   - Field: ‘expr’
[13:34:39.103]   - Field: ‘uuid’
[13:34:39.104]   - Field: ‘seed’
[13:34:39.104]   - Field: ‘version’
[13:34:39.104]   - Field: ‘result’
[13:34:39.104]   - Field: ‘asynchronous’
[13:34:39.104]   - Field: ‘calls’
[13:34:39.104]   - Field: ‘globals’
[13:34:39.104]   - Field: ‘stdout’
[13:34:39.104]   - Field: ‘earlySignal’
[13:34:39.104]   - Field: ‘lazy’
[13:34:39.104]   - Field: ‘state’
[13:34:39.104] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.105] - Launch lazy future ...
[13:34:39.105] Packages needed by the future expression (n = 0): <none>
[13:34:39.105] Packages needed by future strategies (n = 0): <none>
[13:34:39.105] {
[13:34:39.105]     {
[13:34:39.105]         {
[13:34:39.105]             ...future.startTime <- base::Sys.time()
[13:34:39.105]             {
[13:34:39.105]                 {
[13:34:39.105]                   {
[13:34:39.105]                     {
[13:34:39.105]                       base::local({
[13:34:39.105]                         has_future <- base::requireNamespace("future", 
[13:34:39.105]                           quietly = TRUE)
[13:34:39.105]                         if (has_future) {
[13:34:39.105]                           ns <- base::getNamespace("future")
[13:34:39.105]                           version <- ns[[".package"]][["version"]]
[13:34:39.105]                           if (is.null(version)) 
[13:34:39.105]                             version <- utils::packageVersion("future")
[13:34:39.105]                         }
[13:34:39.105]                         else {
[13:34:39.105]                           version <- NULL
[13:34:39.105]                         }
[13:34:39.105]                         if (!has_future || version < "1.8.0") {
[13:34:39.105]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.105]                             "", base::R.version$version.string), 
[13:34:39.105]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.105]                               "release", "version")], collapse = " "), 
[13:34:39.105]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.105]                             info)
[13:34:39.105]                           info <- base::paste(info, collapse = "; ")
[13:34:39.105]                           if (!has_future) {
[13:34:39.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.105]                               info)
[13:34:39.105]                           }
[13:34:39.105]                           else {
[13:34:39.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.105]                               info, version)
[13:34:39.105]                           }
[13:34:39.105]                           base::stop(msg)
[13:34:39.105]                         }
[13:34:39.105]                       })
[13:34:39.105]                     }
[13:34:39.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.105]                     base::options(mc.cores = 1L)
[13:34:39.105]                   }
[13:34:39.105]                   ...future.strategy.old <- future::plan("list")
[13:34:39.105]                   options(future.plan = NULL)
[13:34:39.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.105]                 }
[13:34:39.105]                 ...future.workdir <- getwd()
[13:34:39.105]             }
[13:34:39.105]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.105]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.105]         }
[13:34:39.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.105]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:39.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.105]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.105]             base::names(...future.oldOptions))
[13:34:39.105]     }
[13:34:39.105]     if (FALSE) {
[13:34:39.105]     }
[13:34:39.105]     else {
[13:34:39.105]         if (TRUE) {
[13:34:39.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.105]                 open = "w")
[13:34:39.105]         }
[13:34:39.105]         else {
[13:34:39.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.105]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.105]         }
[13:34:39.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.105]             base::sink(type = "output", split = FALSE)
[13:34:39.105]             base::close(...future.stdout)
[13:34:39.105]         }, add = TRUE)
[13:34:39.105]     }
[13:34:39.105]     ...future.frame <- base::sys.nframe()
[13:34:39.105]     ...future.conditions <- base::list()
[13:34:39.105]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.105]     if (FALSE) {
[13:34:39.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.105]     }
[13:34:39.105]     ...future.result <- base::tryCatch({
[13:34:39.105]         base::withCallingHandlers({
[13:34:39.105]             ...future.value <- base::withVisible(base::local({
[13:34:39.105]                 ...future.makeSendCondition <- base::local({
[13:34:39.105]                   sendCondition <- NULL
[13:34:39.105]                   function(frame = 1L) {
[13:34:39.105]                     if (is.function(sendCondition)) 
[13:34:39.105]                       return(sendCondition)
[13:34:39.105]                     ns <- getNamespace("parallel")
[13:34:39.105]                     if (exists("sendData", mode = "function", 
[13:34:39.105]                       envir = ns)) {
[13:34:39.105]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.105]                         envir = ns)
[13:34:39.105]                       envir <- sys.frame(frame)
[13:34:39.105]                       master <- NULL
[13:34:39.105]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.105]                         !identical(envir, emptyenv())) {
[13:34:39.105]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.105]                           inherits = FALSE)) {
[13:34:39.105]                           master <- get("master", mode = "list", 
[13:34:39.105]                             envir = envir, inherits = FALSE)
[13:34:39.105]                           if (inherits(master, c("SOCKnode", 
[13:34:39.105]                             "SOCK0node"))) {
[13:34:39.105]                             sendCondition <<- function(cond) {
[13:34:39.105]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.105]                                 success = TRUE)
[13:34:39.105]                               parallel_sendData(master, data)
[13:34:39.105]                             }
[13:34:39.105]                             return(sendCondition)
[13:34:39.105]                           }
[13:34:39.105]                         }
[13:34:39.105]                         frame <- frame + 1L
[13:34:39.105]                         envir <- sys.frame(frame)
[13:34:39.105]                       }
[13:34:39.105]                     }
[13:34:39.105]                     sendCondition <<- function(cond) NULL
[13:34:39.105]                   }
[13:34:39.105]                 })
[13:34:39.105]                 withCallingHandlers({
[13:34:39.105]                   {
[13:34:39.105]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.105]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.105]                       ...future.globals.maxSize)) {
[13:34:39.105]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.105]                       on.exit(options(oopts), add = TRUE)
[13:34:39.105]                     }
[13:34:39.105]                     {
[13:34:39.105]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.105]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.105]                         USE.NAMES = FALSE)
[13:34:39.105]                       do.call(mapply, args = args)
[13:34:39.105]                     }
[13:34:39.105]                   }
[13:34:39.105]                 }, immediateCondition = function(cond) {
[13:34:39.105]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.105]                   sendCondition(cond)
[13:34:39.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.105]                   {
[13:34:39.105]                     inherits <- base::inherits
[13:34:39.105]                     invokeRestart <- base::invokeRestart
[13:34:39.105]                     is.null <- base::is.null
[13:34:39.105]                     muffled <- FALSE
[13:34:39.105]                     if (inherits(cond, "message")) {
[13:34:39.105]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.105]                       if (muffled) 
[13:34:39.105]                         invokeRestart("muffleMessage")
[13:34:39.105]                     }
[13:34:39.105]                     else if (inherits(cond, "warning")) {
[13:34:39.105]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.105]                       if (muffled) 
[13:34:39.105]                         invokeRestart("muffleWarning")
[13:34:39.105]                     }
[13:34:39.105]                     else if (inherits(cond, "condition")) {
[13:34:39.105]                       if (!is.null(pattern)) {
[13:34:39.105]                         computeRestarts <- base::computeRestarts
[13:34:39.105]                         grepl <- base::grepl
[13:34:39.105]                         restarts <- computeRestarts(cond)
[13:34:39.105]                         for (restart in restarts) {
[13:34:39.105]                           name <- restart$name
[13:34:39.105]                           if (is.null(name)) 
[13:34:39.105]                             next
[13:34:39.105]                           if (!grepl(pattern, name)) 
[13:34:39.105]                             next
[13:34:39.105]                           invokeRestart(restart)
[13:34:39.105]                           muffled <- TRUE
[13:34:39.105]                           break
[13:34:39.105]                         }
[13:34:39.105]                       }
[13:34:39.105]                     }
[13:34:39.105]                     invisible(muffled)
[13:34:39.105]                   }
[13:34:39.105]                   muffleCondition(cond)
[13:34:39.105]                 })
[13:34:39.105]             }))
[13:34:39.105]             future::FutureResult(value = ...future.value$value, 
[13:34:39.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.105]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.105]                     ...future.globalenv.names))
[13:34:39.105]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.105]         }, condition = base::local({
[13:34:39.105]             c <- base::c
[13:34:39.105]             inherits <- base::inherits
[13:34:39.105]             invokeRestart <- base::invokeRestart
[13:34:39.105]             length <- base::length
[13:34:39.105]             list <- base::list
[13:34:39.105]             seq.int <- base::seq.int
[13:34:39.105]             signalCondition <- base::signalCondition
[13:34:39.105]             sys.calls <- base::sys.calls
[13:34:39.105]             `[[` <- base::`[[`
[13:34:39.105]             `+` <- base::`+`
[13:34:39.105]             `<<-` <- base::`<<-`
[13:34:39.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.105]                   3L)]
[13:34:39.105]             }
[13:34:39.105]             function(cond) {
[13:34:39.105]                 is_error <- inherits(cond, "error")
[13:34:39.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.105]                   NULL)
[13:34:39.105]                 if (is_error) {
[13:34:39.105]                   sessionInformation <- function() {
[13:34:39.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.105]                       search = base::search(), system = base::Sys.info())
[13:34:39.105]                   }
[13:34:39.105]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.105]                     cond$call), session = sessionInformation(), 
[13:34:39.105]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.105]                   signalCondition(cond)
[13:34:39.105]                 }
[13:34:39.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.105]                 "immediateCondition"))) {
[13:34:39.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.105]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.105]                   if (TRUE && !signal) {
[13:34:39.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.105]                     {
[13:34:39.105]                       inherits <- base::inherits
[13:34:39.105]                       invokeRestart <- base::invokeRestart
[13:34:39.105]                       is.null <- base::is.null
[13:34:39.105]                       muffled <- FALSE
[13:34:39.105]                       if (inherits(cond, "message")) {
[13:34:39.105]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.105]                         if (muffled) 
[13:34:39.105]                           invokeRestart("muffleMessage")
[13:34:39.105]                       }
[13:34:39.105]                       else if (inherits(cond, "warning")) {
[13:34:39.105]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.105]                         if (muffled) 
[13:34:39.105]                           invokeRestart("muffleWarning")
[13:34:39.105]                       }
[13:34:39.105]                       else if (inherits(cond, "condition")) {
[13:34:39.105]                         if (!is.null(pattern)) {
[13:34:39.105]                           computeRestarts <- base::computeRestarts
[13:34:39.105]                           grepl <- base::grepl
[13:34:39.105]                           restarts <- computeRestarts(cond)
[13:34:39.105]                           for (restart in restarts) {
[13:34:39.105]                             name <- restart$name
[13:34:39.105]                             if (is.null(name)) 
[13:34:39.105]                               next
[13:34:39.105]                             if (!grepl(pattern, name)) 
[13:34:39.105]                               next
[13:34:39.105]                             invokeRestart(restart)
[13:34:39.105]                             muffled <- TRUE
[13:34:39.105]                             break
[13:34:39.105]                           }
[13:34:39.105]                         }
[13:34:39.105]                       }
[13:34:39.105]                       invisible(muffled)
[13:34:39.105]                     }
[13:34:39.105]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.105]                   }
[13:34:39.105]                 }
[13:34:39.105]                 else {
[13:34:39.105]                   if (TRUE) {
[13:34:39.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.105]                     {
[13:34:39.105]                       inherits <- base::inherits
[13:34:39.105]                       invokeRestart <- base::invokeRestart
[13:34:39.105]                       is.null <- base::is.null
[13:34:39.105]                       muffled <- FALSE
[13:34:39.105]                       if (inherits(cond, "message")) {
[13:34:39.105]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.105]                         if (muffled) 
[13:34:39.105]                           invokeRestart("muffleMessage")
[13:34:39.105]                       }
[13:34:39.105]                       else if (inherits(cond, "warning")) {
[13:34:39.105]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.105]                         if (muffled) 
[13:34:39.105]                           invokeRestart("muffleWarning")
[13:34:39.105]                       }
[13:34:39.105]                       else if (inherits(cond, "condition")) {
[13:34:39.105]                         if (!is.null(pattern)) {
[13:34:39.105]                           computeRestarts <- base::computeRestarts
[13:34:39.105]                           grepl <- base::grepl
[13:34:39.105]                           restarts <- computeRestarts(cond)
[13:34:39.105]                           for (restart in restarts) {
[13:34:39.105]                             name <- restart$name
[13:34:39.105]                             if (is.null(name)) 
[13:34:39.105]                               next
[13:34:39.105]                             if (!grepl(pattern, name)) 
[13:34:39.105]                               next
[13:34:39.105]                             invokeRestart(restart)
[13:34:39.105]                             muffled <- TRUE
[13:34:39.105]                             break
[13:34:39.105]                           }
[13:34:39.105]                         }
[13:34:39.105]                       }
[13:34:39.105]                       invisible(muffled)
[13:34:39.105]                     }
[13:34:39.105]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.105]                   }
[13:34:39.105]                 }
[13:34:39.105]             }
[13:34:39.105]         }))
[13:34:39.105]     }, error = function(ex) {
[13:34:39.105]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.105]                 ...future.rng), started = ...future.startTime, 
[13:34:39.105]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.105]             version = "1.8"), class = "FutureResult")
[13:34:39.105]     }, finally = {
[13:34:39.105]         if (!identical(...future.workdir, getwd())) 
[13:34:39.105]             setwd(...future.workdir)
[13:34:39.105]         {
[13:34:39.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.105]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.105]             }
[13:34:39.105]             base::options(...future.oldOptions)
[13:34:39.105]             if (.Platform$OS.type == "windows") {
[13:34:39.105]                 old_names <- names(...future.oldEnvVars)
[13:34:39.105]                 envs <- base::Sys.getenv()
[13:34:39.105]                 names <- names(envs)
[13:34:39.105]                 common <- intersect(names, old_names)
[13:34:39.105]                 added <- setdiff(names, old_names)
[13:34:39.105]                 removed <- setdiff(old_names, names)
[13:34:39.105]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.105]                   envs[common]]
[13:34:39.105]                 NAMES <- toupper(changed)
[13:34:39.105]                 args <- list()
[13:34:39.105]                 for (kk in seq_along(NAMES)) {
[13:34:39.105]                   name <- changed[[kk]]
[13:34:39.105]                   NAME <- NAMES[[kk]]
[13:34:39.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.105]                     next
[13:34:39.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.105]                 }
[13:34:39.105]                 NAMES <- toupper(added)
[13:34:39.105]                 for (kk in seq_along(NAMES)) {
[13:34:39.105]                   name <- added[[kk]]
[13:34:39.105]                   NAME <- NAMES[[kk]]
[13:34:39.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.105]                     next
[13:34:39.105]                   args[[name]] <- ""
[13:34:39.105]                 }
[13:34:39.105]                 NAMES <- toupper(removed)
[13:34:39.105]                 for (kk in seq_along(NAMES)) {
[13:34:39.105]                   name <- removed[[kk]]
[13:34:39.105]                   NAME <- NAMES[[kk]]
[13:34:39.105]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.105]                     next
[13:34:39.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.105]                 }
[13:34:39.105]                 if (length(args) > 0) 
[13:34:39.105]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.105]             }
[13:34:39.105]             else {
[13:34:39.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.105]             }
[13:34:39.105]             {
[13:34:39.105]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.105]                   0L) {
[13:34:39.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.105]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.105]                   base::options(opts)
[13:34:39.105]                 }
[13:34:39.105]                 {
[13:34:39.105]                   {
[13:34:39.105]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.105]                     NULL
[13:34:39.105]                   }
[13:34:39.105]                   options(future.plan = NULL)
[13:34:39.105]                   if (is.na(NA_character_)) 
[13:34:39.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.105]                     .init = FALSE)
[13:34:39.105]                 }
[13:34:39.105]             }
[13:34:39.105]         }
[13:34:39.105]     })
[13:34:39.105]     if (TRUE) {
[13:34:39.105]         base::sink(type = "output", split = FALSE)
[13:34:39.105]         if (TRUE) {
[13:34:39.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.105]         }
[13:34:39.105]         else {
[13:34:39.105]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.105]         }
[13:34:39.105]         base::close(...future.stdout)
[13:34:39.105]         ...future.stdout <- NULL
[13:34:39.105]     }
[13:34:39.105]     ...future.result$conditions <- ...future.conditions
[13:34:39.105]     ...future.result$finished <- base::Sys.time()
[13:34:39.105]     ...future.result
[13:34:39.105] }
[13:34:39.107] Poll #1 (0): usedNodes() = 2, workers = 2
[13:34:39.118] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.118] - Validating connection of MultisessionFuture
[13:34:39.119] - received message: FutureResult
[13:34:39.119] - Received FutureResult
[13:34:39.119] - Erased future from FutureRegistry
[13:34:39.119] result() for ClusterFuture ...
[13:34:39.119] - result already collected: FutureResult
[13:34:39.119] result() for ClusterFuture ... done
[13:34:39.119] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.119] result() for ClusterFuture ...
[13:34:39.119] - result already collected: FutureResult
[13:34:39.119] result() for ClusterFuture ... done
[13:34:39.120] result() for ClusterFuture ...
[13:34:39.120] - result already collected: FutureResult
[13:34:39.120] result() for ClusterFuture ... done
[13:34:39.120] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[13:34:39.120] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[13:34:39.121] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[13:34:39.121] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:39.121] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.121] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[13:34:39.122] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[13:34:39.122] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:39.122] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.122] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:39.123] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.123] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[13:34:39.123] MultisessionFuture started
[13:34:39.123] - Launch lazy future ... done
[13:34:39.123] run() for ‘MultisessionFuture’ ... done
[13:34:39.123] Created future:
[13:34:39.124] MultisessionFuture:
[13:34:39.124] Label: ‘future_mapply-4’
[13:34:39.124] Expression:
[13:34:39.124] {
[13:34:39.124]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.124]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.124]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.124]         on.exit(options(oopts), add = TRUE)
[13:34:39.124]     }
[13:34:39.124]     {
[13:34:39.124]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.124]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.124]         do.call(mapply, args = args)
[13:34:39.124]     }
[13:34:39.124] }
[13:34:39.124] Lazy evaluation: FALSE
[13:34:39.124] Asynchronous evaluation: TRUE
[13:34:39.124] Local evaluation: TRUE
[13:34:39.124] Environment: R_GlobalEnv
[13:34:39.124] Capture standard output: TRUE
[13:34:39.124] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.124] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.124] Packages: <none>
[13:34:39.124] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.124] Resolved: FALSE
[13:34:39.124] Value: <not collected>
[13:34:39.124] Conditions captured: <none>
[13:34:39.124] Early signaling: FALSE
[13:34:39.124] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.124] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.135] Chunk #4 of 5 ... DONE
[13:34:39.135] Chunk #5 of 5 ...
[13:34:39.135]  - Finding globals in '...' for chunk #5 ...
[13:34:39.135] getGlobalsAndPackages() ...
[13:34:39.135] Searching for globals...
[13:34:39.136] 
[13:34:39.136] Searching for globals ... DONE
[13:34:39.136] - globals: [0] <none>
[13:34:39.136] getGlobalsAndPackages() ... DONE
[13:34:39.136]    + additional globals found: [n=0] 
[13:34:39.136]    + additional namespaces needed: [n=0] 
[13:34:39.136]  - Finding globals in '...' for chunk #5 ... DONE
[13:34:39.136]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[13:34:39.137]  - seeds: <none>
[13:34:39.137]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.137] getGlobalsAndPackages() ...
[13:34:39.137] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.137] Resolving globals: FALSE
[13:34:39.137] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:39.138] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:39.138] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.138] 
[13:34:39.138] getGlobalsAndPackages() ... DONE
[13:34:39.138] run() for ‘Future’ ...
[13:34:39.139] - state: ‘created’
[13:34:39.139] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.152] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.152]   - Field: ‘node’
[13:34:39.152]   - Field: ‘label’
[13:34:39.152]   - Field: ‘local’
[13:34:39.153]   - Field: ‘owner’
[13:34:39.153]   - Field: ‘envir’
[13:34:39.153]   - Field: ‘workers’
[13:34:39.153]   - Field: ‘packages’
[13:34:39.153]   - Field: ‘gc’
[13:34:39.153]   - Field: ‘conditions’
[13:34:39.153]   - Field: ‘persistent’
[13:34:39.153]   - Field: ‘expr’
[13:34:39.153]   - Field: ‘uuid’
[13:34:39.153]   - Field: ‘seed’
[13:34:39.153]   - Field: ‘version’
[13:34:39.154]   - Field: ‘result’
[13:34:39.154]   - Field: ‘asynchronous’
[13:34:39.154]   - Field: ‘calls’
[13:34:39.154]   - Field: ‘globals’
[13:34:39.154]   - Field: ‘stdout’
[13:34:39.154]   - Field: ‘earlySignal’
[13:34:39.154]   - Field: ‘lazy’
[13:34:39.154]   - Field: ‘state’
[13:34:39.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.154] - Launch lazy future ...
[13:34:39.155] Packages needed by the future expression (n = 0): <none>
[13:34:39.155] Packages needed by future strategies (n = 0): <none>
[13:34:39.155] {
[13:34:39.155]     {
[13:34:39.155]         {
[13:34:39.155]             ...future.startTime <- base::Sys.time()
[13:34:39.155]             {
[13:34:39.155]                 {
[13:34:39.155]                   {
[13:34:39.155]                     {
[13:34:39.155]                       base::local({
[13:34:39.155]                         has_future <- base::requireNamespace("future", 
[13:34:39.155]                           quietly = TRUE)
[13:34:39.155]                         if (has_future) {
[13:34:39.155]                           ns <- base::getNamespace("future")
[13:34:39.155]                           version <- ns[[".package"]][["version"]]
[13:34:39.155]                           if (is.null(version)) 
[13:34:39.155]                             version <- utils::packageVersion("future")
[13:34:39.155]                         }
[13:34:39.155]                         else {
[13:34:39.155]                           version <- NULL
[13:34:39.155]                         }
[13:34:39.155]                         if (!has_future || version < "1.8.0") {
[13:34:39.155]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.155]                             "", base::R.version$version.string), 
[13:34:39.155]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.155]                               "release", "version")], collapse = " "), 
[13:34:39.155]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.155]                             info)
[13:34:39.155]                           info <- base::paste(info, collapse = "; ")
[13:34:39.155]                           if (!has_future) {
[13:34:39.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.155]                               info)
[13:34:39.155]                           }
[13:34:39.155]                           else {
[13:34:39.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.155]                               info, version)
[13:34:39.155]                           }
[13:34:39.155]                           base::stop(msg)
[13:34:39.155]                         }
[13:34:39.155]                       })
[13:34:39.155]                     }
[13:34:39.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.155]                     base::options(mc.cores = 1L)
[13:34:39.155]                   }
[13:34:39.155]                   ...future.strategy.old <- future::plan("list")
[13:34:39.155]                   options(future.plan = NULL)
[13:34:39.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.155]                 }
[13:34:39.155]                 ...future.workdir <- getwd()
[13:34:39.155]             }
[13:34:39.155]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.155]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.155]         }
[13:34:39.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.155]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[13:34:39.155]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.155]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.155]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.155]             base::names(...future.oldOptions))
[13:34:39.155]     }
[13:34:39.155]     if (FALSE) {
[13:34:39.155]     }
[13:34:39.155]     else {
[13:34:39.155]         if (TRUE) {
[13:34:39.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.155]                 open = "w")
[13:34:39.155]         }
[13:34:39.155]         else {
[13:34:39.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.155]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.155]         }
[13:34:39.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.155]             base::sink(type = "output", split = FALSE)
[13:34:39.155]             base::close(...future.stdout)
[13:34:39.155]         }, add = TRUE)
[13:34:39.155]     }
[13:34:39.155]     ...future.frame <- base::sys.nframe()
[13:34:39.155]     ...future.conditions <- base::list()
[13:34:39.155]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.155]     if (FALSE) {
[13:34:39.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.155]     }
[13:34:39.155]     ...future.result <- base::tryCatch({
[13:34:39.155]         base::withCallingHandlers({
[13:34:39.155]             ...future.value <- base::withVisible(base::local({
[13:34:39.155]                 ...future.makeSendCondition <- base::local({
[13:34:39.155]                   sendCondition <- NULL
[13:34:39.155]                   function(frame = 1L) {
[13:34:39.155]                     if (is.function(sendCondition)) 
[13:34:39.155]                       return(sendCondition)
[13:34:39.155]                     ns <- getNamespace("parallel")
[13:34:39.155]                     if (exists("sendData", mode = "function", 
[13:34:39.155]                       envir = ns)) {
[13:34:39.155]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.155]                         envir = ns)
[13:34:39.155]                       envir <- sys.frame(frame)
[13:34:39.155]                       master <- NULL
[13:34:39.155]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.155]                         !identical(envir, emptyenv())) {
[13:34:39.155]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.155]                           inherits = FALSE)) {
[13:34:39.155]                           master <- get("master", mode = "list", 
[13:34:39.155]                             envir = envir, inherits = FALSE)
[13:34:39.155]                           if (inherits(master, c("SOCKnode", 
[13:34:39.155]                             "SOCK0node"))) {
[13:34:39.155]                             sendCondition <<- function(cond) {
[13:34:39.155]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.155]                                 success = TRUE)
[13:34:39.155]                               parallel_sendData(master, data)
[13:34:39.155]                             }
[13:34:39.155]                             return(sendCondition)
[13:34:39.155]                           }
[13:34:39.155]                         }
[13:34:39.155]                         frame <- frame + 1L
[13:34:39.155]                         envir <- sys.frame(frame)
[13:34:39.155]                       }
[13:34:39.155]                     }
[13:34:39.155]                     sendCondition <<- function(cond) NULL
[13:34:39.155]                   }
[13:34:39.155]                 })
[13:34:39.155]                 withCallingHandlers({
[13:34:39.155]                   {
[13:34:39.155]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.155]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.155]                       ...future.globals.maxSize)) {
[13:34:39.155]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.155]                       on.exit(options(oopts), add = TRUE)
[13:34:39.155]                     }
[13:34:39.155]                     {
[13:34:39.155]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.155]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.155]                         USE.NAMES = FALSE)
[13:34:39.155]                       do.call(mapply, args = args)
[13:34:39.155]                     }
[13:34:39.155]                   }
[13:34:39.155]                 }, immediateCondition = function(cond) {
[13:34:39.155]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.155]                   sendCondition(cond)
[13:34:39.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.155]                   {
[13:34:39.155]                     inherits <- base::inherits
[13:34:39.155]                     invokeRestart <- base::invokeRestart
[13:34:39.155]                     is.null <- base::is.null
[13:34:39.155]                     muffled <- FALSE
[13:34:39.155]                     if (inherits(cond, "message")) {
[13:34:39.155]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.155]                       if (muffled) 
[13:34:39.155]                         invokeRestart("muffleMessage")
[13:34:39.155]                     }
[13:34:39.155]                     else if (inherits(cond, "warning")) {
[13:34:39.155]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.155]                       if (muffled) 
[13:34:39.155]                         invokeRestart("muffleWarning")
[13:34:39.155]                     }
[13:34:39.155]                     else if (inherits(cond, "condition")) {
[13:34:39.155]                       if (!is.null(pattern)) {
[13:34:39.155]                         computeRestarts <- base::computeRestarts
[13:34:39.155]                         grepl <- base::grepl
[13:34:39.155]                         restarts <- computeRestarts(cond)
[13:34:39.155]                         for (restart in restarts) {
[13:34:39.155]                           name <- restart$name
[13:34:39.155]                           if (is.null(name)) 
[13:34:39.155]                             next
[13:34:39.155]                           if (!grepl(pattern, name)) 
[13:34:39.155]                             next
[13:34:39.155]                           invokeRestart(restart)
[13:34:39.155]                           muffled <- TRUE
[13:34:39.155]                           break
[13:34:39.155]                         }
[13:34:39.155]                       }
[13:34:39.155]                     }
[13:34:39.155]                     invisible(muffled)
[13:34:39.155]                   }
[13:34:39.155]                   muffleCondition(cond)
[13:34:39.155]                 })
[13:34:39.155]             }))
[13:34:39.155]             future::FutureResult(value = ...future.value$value, 
[13:34:39.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.155]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.155]                     ...future.globalenv.names))
[13:34:39.155]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.155]         }, condition = base::local({
[13:34:39.155]             c <- base::c
[13:34:39.155]             inherits <- base::inherits
[13:34:39.155]             invokeRestart <- base::invokeRestart
[13:34:39.155]             length <- base::length
[13:34:39.155]             list <- base::list
[13:34:39.155]             seq.int <- base::seq.int
[13:34:39.155]             signalCondition <- base::signalCondition
[13:34:39.155]             sys.calls <- base::sys.calls
[13:34:39.155]             `[[` <- base::`[[`
[13:34:39.155]             `+` <- base::`+`
[13:34:39.155]             `<<-` <- base::`<<-`
[13:34:39.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.155]                   3L)]
[13:34:39.155]             }
[13:34:39.155]             function(cond) {
[13:34:39.155]                 is_error <- inherits(cond, "error")
[13:34:39.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.155]                   NULL)
[13:34:39.155]                 if (is_error) {
[13:34:39.155]                   sessionInformation <- function() {
[13:34:39.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.155]                       search = base::search(), system = base::Sys.info())
[13:34:39.155]                   }
[13:34:39.155]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.155]                     cond$call), session = sessionInformation(), 
[13:34:39.155]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.155]                   signalCondition(cond)
[13:34:39.155]                 }
[13:34:39.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.155]                 "immediateCondition"))) {
[13:34:39.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.155]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.155]                   if (TRUE && !signal) {
[13:34:39.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.155]                     {
[13:34:39.155]                       inherits <- base::inherits
[13:34:39.155]                       invokeRestart <- base::invokeRestart
[13:34:39.155]                       is.null <- base::is.null
[13:34:39.155]                       muffled <- FALSE
[13:34:39.155]                       if (inherits(cond, "message")) {
[13:34:39.155]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.155]                         if (muffled) 
[13:34:39.155]                           invokeRestart("muffleMessage")
[13:34:39.155]                       }
[13:34:39.155]                       else if (inherits(cond, "warning")) {
[13:34:39.155]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.155]                         if (muffled) 
[13:34:39.155]                           invokeRestart("muffleWarning")
[13:34:39.155]                       }
[13:34:39.155]                       else if (inherits(cond, "condition")) {
[13:34:39.155]                         if (!is.null(pattern)) {
[13:34:39.155]                           computeRestarts <- base::computeRestarts
[13:34:39.155]                           grepl <- base::grepl
[13:34:39.155]                           restarts <- computeRestarts(cond)
[13:34:39.155]                           for (restart in restarts) {
[13:34:39.155]                             name <- restart$name
[13:34:39.155]                             if (is.null(name)) 
[13:34:39.155]                               next
[13:34:39.155]                             if (!grepl(pattern, name)) 
[13:34:39.155]                               next
[13:34:39.155]                             invokeRestart(restart)
[13:34:39.155]                             muffled <- TRUE
[13:34:39.155]                             break
[13:34:39.155]                           }
[13:34:39.155]                         }
[13:34:39.155]                       }
[13:34:39.155]                       invisible(muffled)
[13:34:39.155]                     }
[13:34:39.155]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.155]                   }
[13:34:39.155]                 }
[13:34:39.155]                 else {
[13:34:39.155]                   if (TRUE) {
[13:34:39.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.155]                     {
[13:34:39.155]                       inherits <- base::inherits
[13:34:39.155]                       invokeRestart <- base::invokeRestart
[13:34:39.155]                       is.null <- base::is.null
[13:34:39.155]                       muffled <- FALSE
[13:34:39.155]                       if (inherits(cond, "message")) {
[13:34:39.155]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.155]                         if (muffled) 
[13:34:39.155]                           invokeRestart("muffleMessage")
[13:34:39.155]                       }
[13:34:39.155]                       else if (inherits(cond, "warning")) {
[13:34:39.155]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.155]                         if (muffled) 
[13:34:39.155]                           invokeRestart("muffleWarning")
[13:34:39.155]                       }
[13:34:39.155]                       else if (inherits(cond, "condition")) {
[13:34:39.155]                         if (!is.null(pattern)) {
[13:34:39.155]                           computeRestarts <- base::computeRestarts
[13:34:39.155]                           grepl <- base::grepl
[13:34:39.155]                           restarts <- computeRestarts(cond)
[13:34:39.155]                           for (restart in restarts) {
[13:34:39.155]                             name <- restart$name
[13:34:39.155]                             if (is.null(name)) 
[13:34:39.155]                               next
[13:34:39.155]                             if (!grepl(pattern, name)) 
[13:34:39.155]                               next
[13:34:39.155]                             invokeRestart(restart)
[13:34:39.155]                             muffled <- TRUE
[13:34:39.155]                             break
[13:34:39.155]                           }
[13:34:39.155]                         }
[13:34:39.155]                       }
[13:34:39.155]                       invisible(muffled)
[13:34:39.155]                     }
[13:34:39.155]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.155]                   }
[13:34:39.155]                 }
[13:34:39.155]             }
[13:34:39.155]         }))
[13:34:39.155]     }, error = function(ex) {
[13:34:39.155]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.155]                 ...future.rng), started = ...future.startTime, 
[13:34:39.155]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.155]             version = "1.8"), class = "FutureResult")
[13:34:39.155]     }, finally = {
[13:34:39.155]         if (!identical(...future.workdir, getwd())) 
[13:34:39.155]             setwd(...future.workdir)
[13:34:39.155]         {
[13:34:39.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.155]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.155]             }
[13:34:39.155]             base::options(...future.oldOptions)
[13:34:39.155]             if (.Platform$OS.type == "windows") {
[13:34:39.155]                 old_names <- names(...future.oldEnvVars)
[13:34:39.155]                 envs <- base::Sys.getenv()
[13:34:39.155]                 names <- names(envs)
[13:34:39.155]                 common <- intersect(names, old_names)
[13:34:39.155]                 added <- setdiff(names, old_names)
[13:34:39.155]                 removed <- setdiff(old_names, names)
[13:34:39.155]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.155]                   envs[common]]
[13:34:39.155]                 NAMES <- toupper(changed)
[13:34:39.155]                 args <- list()
[13:34:39.155]                 for (kk in seq_along(NAMES)) {
[13:34:39.155]                   name <- changed[[kk]]
[13:34:39.155]                   NAME <- NAMES[[kk]]
[13:34:39.155]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.155]                     next
[13:34:39.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.155]                 }
[13:34:39.155]                 NAMES <- toupper(added)
[13:34:39.155]                 for (kk in seq_along(NAMES)) {
[13:34:39.155]                   name <- added[[kk]]
[13:34:39.155]                   NAME <- NAMES[[kk]]
[13:34:39.155]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.155]                     next
[13:34:39.155]                   args[[name]] <- ""
[13:34:39.155]                 }
[13:34:39.155]                 NAMES <- toupper(removed)
[13:34:39.155]                 for (kk in seq_along(NAMES)) {
[13:34:39.155]                   name <- removed[[kk]]
[13:34:39.155]                   NAME <- NAMES[[kk]]
[13:34:39.155]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.155]                     next
[13:34:39.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.155]                 }
[13:34:39.155]                 if (length(args) > 0) 
[13:34:39.155]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.155]             }
[13:34:39.155]             else {
[13:34:39.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.155]             }
[13:34:39.155]             {
[13:34:39.155]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.155]                   0L) {
[13:34:39.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.155]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.155]                   base::options(opts)
[13:34:39.155]                 }
[13:34:39.155]                 {
[13:34:39.155]                   {
[13:34:39.155]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.155]                     NULL
[13:34:39.155]                   }
[13:34:39.155]                   options(future.plan = NULL)
[13:34:39.155]                   if (is.na(NA_character_)) 
[13:34:39.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.155]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.155]                     .init = FALSE)
[13:34:39.155]                 }
[13:34:39.155]             }
[13:34:39.155]         }
[13:34:39.155]     })
[13:34:39.155]     if (TRUE) {
[13:34:39.155]         base::sink(type = "output", split = FALSE)
[13:34:39.155]         if (TRUE) {
[13:34:39.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.155]         }
[13:34:39.155]         else {
[13:34:39.155]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.155]         }
[13:34:39.155]         base::close(...future.stdout)
[13:34:39.155]         ...future.stdout <- NULL
[13:34:39.155]     }
[13:34:39.155]     ...future.result$conditions <- ...future.conditions
[13:34:39.155]     ...future.result$finished <- base::Sys.time()
[13:34:39.155]     ...future.result
[13:34:39.155] }
[13:34:39.157] Poll #1 (0): usedNodes() = 2, workers = 2
[13:34:39.168] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.168] - Validating connection of MultisessionFuture
[13:34:39.168] - received message: FutureResult
[13:34:39.168] - Received FutureResult
[13:34:39.168] - Erased future from FutureRegistry
[13:34:39.169] result() for ClusterFuture ...
[13:34:39.169] - result already collected: FutureResult
[13:34:39.169] result() for ClusterFuture ... done
[13:34:39.169] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.169] result() for ClusterFuture ...
[13:34:39.169] - result already collected: FutureResult
[13:34:39.169] result() for ClusterFuture ... done
[13:34:39.169] result() for ClusterFuture ...
[13:34:39.169] - result already collected: FutureResult
[13:34:39.169] result() for ClusterFuture ... done
[13:34:39.170] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[13:34:39.170] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[13:34:39.170] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[13:34:39.171] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:39.171] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.171] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[13:34:39.171] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[13:34:39.172] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:39.172] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.172] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:39.172] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.172] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[13:34:39.173] MultisessionFuture started
[13:34:39.173] - Launch lazy future ... done
[13:34:39.173] run() for ‘MultisessionFuture’ ... done
[13:34:39.173] Created future:
[13:34:39.173] MultisessionFuture:
[13:34:39.173] Label: ‘future_mapply-5’
[13:34:39.173] Expression:
[13:34:39.173] {
[13:34:39.173]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.173]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.173]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.173]         on.exit(options(oopts), add = TRUE)
[13:34:39.173]     }
[13:34:39.173]     {
[13:34:39.173]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.173]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.173]         do.call(mapply, args = args)
[13:34:39.173]     }
[13:34:39.173] }
[13:34:39.173] Lazy evaluation: FALSE
[13:34:39.173] Asynchronous evaluation: TRUE
[13:34:39.173] Local evaluation: TRUE
[13:34:39.173] Environment: R_GlobalEnv
[13:34:39.173] Capture standard output: TRUE
[13:34:39.173] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.173] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.173] Packages: <none>
[13:34:39.173] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.173] Resolved: FALSE
[13:34:39.173] Value: <not collected>
[13:34:39.173] Conditions captured: <none>
[13:34:39.173] Early signaling: FALSE
[13:34:39.173] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.173] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.185] Chunk #5 of 5 ... DONE
[13:34:39.185] Launching 5 futures (chunks) ... DONE
[13:34:39.185] Resolving 5 futures (chunks) ...
[13:34:39.185] resolve() on list ...
[13:34:39.185]  recursive: 0
[13:34:39.185]  length: 5
[13:34:39.185] 
[13:34:39.185] Future #1
[13:34:39.185] result() for ClusterFuture ...
[13:34:39.185] - result already collected: FutureResult
[13:34:39.186] result() for ClusterFuture ... done
[13:34:39.186] result() for ClusterFuture ...
[13:34:39.186] - result already collected: FutureResult
[13:34:39.186] result() for ClusterFuture ... done
[13:34:39.186] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:39.186] - nx: 5
[13:34:39.186] - relay: TRUE
[13:34:39.186] - stdout: TRUE
[13:34:39.186] - signal: TRUE
[13:34:39.186] - resignal: FALSE
[13:34:39.187] - force: TRUE
[13:34:39.187] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[13:34:39.187] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[13:34:39.187]  - until=1
[13:34:39.187]  - relaying element #1
[13:34:39.187] result() for ClusterFuture ...
[13:34:39.187] - result already collected: FutureResult
[13:34:39.187] result() for ClusterFuture ... done
[13:34:39.187] result() for ClusterFuture ...
[13:34:39.187] - result already collected: FutureResult
[13:34:39.187] result() for ClusterFuture ... done
[13:34:39.188] result() for ClusterFuture ...
[13:34:39.188] - result already collected: FutureResult
[13:34:39.188] result() for ClusterFuture ... done
[13:34:39.188] result() for ClusterFuture ...
[13:34:39.188] - result already collected: FutureResult
[13:34:39.188] result() for ClusterFuture ... done
[13:34:39.188] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:39.188] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:39.188] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:39.188]  length: 4 (resolved future 1)
[13:34:39.188] Future #2
[13:34:39.189] result() for ClusterFuture ...
[13:34:39.189] - result already collected: FutureResult
[13:34:39.189] result() for ClusterFuture ... done
[13:34:39.189] result() for ClusterFuture ...
[13:34:39.189] - result already collected: FutureResult
[13:34:39.189] result() for ClusterFuture ... done
[13:34:39.189] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:39.189] - nx: 5
[13:34:39.189] - relay: TRUE
[13:34:39.189] - stdout: TRUE
[13:34:39.189] - signal: TRUE
[13:34:39.189] - resignal: FALSE
[13:34:39.190] - force: TRUE
[13:34:39.190] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:39.190] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[13:34:39.190]  - until=2
[13:34:39.190]  - relaying element #2
[13:34:39.190] result() for ClusterFuture ...
[13:34:39.190] - result already collected: FutureResult
[13:34:39.190] result() for ClusterFuture ... done
[13:34:39.190] result() for ClusterFuture ...
[13:34:39.190] - result already collected: FutureResult
[13:34:39.190] result() for ClusterFuture ... done
[13:34:39.191] result() for ClusterFuture ...
[13:34:39.191] - result already collected: FutureResult
[13:34:39.191] result() for ClusterFuture ... done
[13:34:39.191] result() for ClusterFuture ...
[13:34:39.191] - result already collected: FutureResult
[13:34:39.191] result() for ClusterFuture ... done
[13:34:39.191] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:39.191] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:39.191] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:39.191]  length: 3 (resolved future 2)
[13:34:39.191] Future #3
[13:34:39.192] result() for ClusterFuture ...
[13:34:39.192] - result already collected: FutureResult
[13:34:39.192] result() for ClusterFuture ... done
[13:34:39.192] result() for ClusterFuture ...
[13:34:39.192] - result already collected: FutureResult
[13:34:39.192] result() for ClusterFuture ... done
[13:34:39.192] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:34:39.192] - nx: 5
[13:34:39.192] - relay: TRUE
[13:34:39.192] - stdout: TRUE
[13:34:39.192] - signal: TRUE
[13:34:39.192] - resignal: FALSE
[13:34:39.193] - force: TRUE
[13:34:39.193] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:39.193] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[13:34:39.193]  - until=3
[13:34:39.193]  - relaying element #3
[13:34:39.193] result() for ClusterFuture ...
[13:34:39.193] - result already collected: FutureResult
[13:34:39.193] result() for ClusterFuture ... done
[13:34:39.193] result() for ClusterFuture ...
[13:34:39.193] - result already collected: FutureResult
[13:34:39.193] result() for ClusterFuture ... done
[13:34:39.194] result() for ClusterFuture ...
[13:34:39.194] - result already collected: FutureResult
[13:34:39.194] result() for ClusterFuture ... done
[13:34:39.194] result() for ClusterFuture ...
[13:34:39.194] - result already collected: FutureResult
[13:34:39.194] result() for ClusterFuture ... done
[13:34:39.194] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:39.194] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:39.194] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:34:39.194]  length: 2 (resolved future 3)
[13:34:39.195] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.195] - Validating connection of MultisessionFuture
[13:34:39.195] - received message: FutureResult
[13:34:39.195] - Received FutureResult
[13:34:39.195] - Erased future from FutureRegistry
[13:34:39.195] result() for ClusterFuture ...
[13:34:39.195] - result already collected: FutureResult
[13:34:39.196] result() for ClusterFuture ... done
[13:34:39.196] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.196] Future #4
[13:34:39.196] result() for ClusterFuture ...
[13:34:39.196] - result already collected: FutureResult
[13:34:39.196] result() for ClusterFuture ... done
[13:34:39.196] result() for ClusterFuture ...
[13:34:39.196] - result already collected: FutureResult
[13:34:39.196] result() for ClusterFuture ... done
[13:34:39.196] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:34:39.196] - nx: 5
[13:34:39.197] - relay: TRUE
[13:34:39.197] - stdout: TRUE
[13:34:39.197] - signal: TRUE
[13:34:39.197] - resignal: FALSE
[13:34:39.197] - force: TRUE
[13:34:39.197] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:39.197] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[13:34:39.197]  - until=4
[13:34:39.197]  - relaying element #4
[13:34:39.197] result() for ClusterFuture ...
[13:34:39.197] - result already collected: FutureResult
[13:34:39.197] result() for ClusterFuture ... done
[13:34:39.198] result() for ClusterFuture ...
[13:34:39.198] - result already collected: FutureResult
[13:34:39.198] result() for ClusterFuture ... done
[13:34:39.198] result() for ClusterFuture ...
[13:34:39.198] - result already collected: FutureResult
[13:34:39.198] result() for ClusterFuture ... done
[13:34:39.198] result() for ClusterFuture ...
[13:34:39.198] - result already collected: FutureResult
[13:34:39.198] result() for ClusterFuture ... done
[13:34:39.198] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:39.198] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:39.199] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:34:39.199]  length: 1 (resolved future 4)
[13:34:39.220] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.220] - Validating connection of MultisessionFuture
[13:34:39.220] - received message: FutureResult
[13:34:39.220] - Received FutureResult
[13:34:39.220] - Erased future from FutureRegistry
[13:34:39.220] result() for ClusterFuture ...
[13:34:39.220] - result already collected: FutureResult
[13:34:39.221] result() for ClusterFuture ... done
[13:34:39.221] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.221] Future #5
[13:34:39.221] result() for ClusterFuture ...
[13:34:39.221] - result already collected: FutureResult
[13:34:39.221] result() for ClusterFuture ... done
[13:34:39.221] result() for ClusterFuture ...
[13:34:39.221] - result already collected: FutureResult
[13:34:39.221] result() for ClusterFuture ... done
[13:34:39.221] signalConditionsASAP(MultisessionFuture, pos=5) ...
[13:34:39.221] - nx: 5
[13:34:39.222] - relay: TRUE
[13:34:39.222] - stdout: TRUE
[13:34:39.222] - signal: TRUE
[13:34:39.222] - resignal: FALSE
[13:34:39.222] - force: TRUE
[13:34:39.222] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:39.222] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[13:34:39.222]  - until=5
[13:34:39.222]  - relaying element #5
[13:34:39.222] result() for ClusterFuture ...
[13:34:39.222] - result already collected: FutureResult
[13:34:39.222] result() for ClusterFuture ... done
[13:34:39.223] result() for ClusterFuture ...
[13:34:39.223] - result already collected: FutureResult
[13:34:39.223] result() for ClusterFuture ... done
[13:34:39.223] result() for ClusterFuture ...
[13:34:39.223] - result already collected: FutureResult
[13:34:39.223] result() for ClusterFuture ... done
[13:34:39.223] result() for ClusterFuture ...
[13:34:39.223] - result already collected: FutureResult
[13:34:39.223] result() for ClusterFuture ... done
[13:34:39.223] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:39.223] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:39.224] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[13:34:39.224]  length: 0 (resolved future 5)
[13:34:39.224] Relaying remaining futures
[13:34:39.224] signalConditionsASAP(NULL, pos=0) ...
[13:34:39.224] - nx: 5
[13:34:39.224] - relay: TRUE
[13:34:39.224] - stdout: TRUE
[13:34:39.224] - signal: TRUE
[13:34:39.224] - resignal: FALSE
[13:34:39.224] - force: TRUE
[13:34:39.224] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:39.224] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[13:34:39.225] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:39.225] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[13:34:39.225] signalConditionsASAP(NULL, pos=0) ... done
[13:34:39.225] resolve() on list ... DONE
[13:34:39.225] result() for ClusterFuture ...
[13:34:39.225] - result already collected: FutureResult
[13:34:39.225] result() for ClusterFuture ... done
[13:34:39.225] result() for ClusterFuture ...
[13:34:39.225] - result already collected: FutureResult
[13:34:39.225] result() for ClusterFuture ... done
[13:34:39.226] result() for ClusterFuture ...
[13:34:39.226] - result already collected: FutureResult
[13:34:39.226] result() for ClusterFuture ... done
[13:34:39.226] result() for ClusterFuture ...
[13:34:39.226] - result already collected: FutureResult
[13:34:39.226] result() for ClusterFuture ... done
[13:34:39.226] result() for ClusterFuture ...
[13:34:39.226] - result already collected: FutureResult
[13:34:39.229] result() for ClusterFuture ... done
[13:34:39.229] result() for ClusterFuture ...
[13:34:39.229] - result already collected: FutureResult
[13:34:39.229] result() for ClusterFuture ... done
[13:34:39.229] result() for ClusterFuture ...
[13:34:39.229] - result already collected: FutureResult
[13:34:39.229] result() for ClusterFuture ... done
[13:34:39.229] result() for ClusterFuture ...
[13:34:39.229] - result already collected: FutureResult
[13:34:39.230] result() for ClusterFuture ... done
[13:34:39.230] result() for ClusterFuture ...
[13:34:39.230] - result already collected: FutureResult
[13:34:39.230] result() for ClusterFuture ... done
[13:34:39.230] result() for ClusterFuture ...
[13:34:39.230] - result already collected: FutureResult
[13:34:39.230] result() for ClusterFuture ... done
[13:34:39.230]  - Number of value chunks collected: 5
[13:34:39.230] Resolving 5 futures (chunks) ... DONE
[13:34:39.230] Reducing values from 5 chunks ...
[13:34:39.230]  - Number of values collected after concatenation: 5
[13:34:39.231]  - Number of values expected: 5
[13:34:39.231] Reducing values from 5 chunks ... DONE
[13:34:39.231] future_mapply() ... DONE
[13:34:39.231] future_mapply() ...
[13:34:39.235] Number of chunks: 2
[13:34:39.235] getGlobalsAndPackagesXApply() ...
[13:34:39.235]  - future.globals: TRUE
[13:34:39.235] getGlobalsAndPackages() ...
[13:34:39.235] Searching for globals...
[13:34:39.236] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:39.236] Searching for globals ... DONE
[13:34:39.236] Resolving globals: FALSE
[13:34:39.237] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:39.237] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:39.237] - globals: [1] ‘FUN’
[13:34:39.237] 
[13:34:39.237] getGlobalsAndPackages() ... DONE
[13:34:39.237]  - globals found/used: [n=1] ‘FUN’
[13:34:39.238]  - needed namespaces: [n=0] 
[13:34:39.238] Finding globals ... DONE
[13:34:39.238] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:39.238] List of 2
[13:34:39.238]  $ ...future.FUN:function (C, k)  
[13:34:39.238]  $ MoreArgs     : list()
[13:34:39.238]  - attr(*, "where")=List of 2
[13:34:39.238]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:39.238]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:39.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:39.238]  - attr(*, "resolved")= logi FALSE
[13:34:39.238]  - attr(*, "total_size")= num NA
[13:34:39.240] Packages to be attached in all futures: [n=0] 
[13:34:39.241] getGlobalsAndPackagesXApply() ... DONE
[13:34:39.241] Number of futures (= number of chunks): 2
[13:34:39.241] Launching 2 futures (chunks) ...
[13:34:39.241] Chunk #1 of 2 ...
[13:34:39.241]  - Finding globals in '...' for chunk #1 ...
[13:34:39.241] getGlobalsAndPackages() ...
[13:34:39.241] Searching for globals...
[13:34:39.242] 
[13:34:39.242] Searching for globals ... DONE
[13:34:39.242] - globals: [0] <none>
[13:34:39.242] getGlobalsAndPackages() ... DONE
[13:34:39.242]    + additional globals found: [n=0] 
[13:34:39.242]    + additional namespaces needed: [n=0] 
[13:34:39.242]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:39.242]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:39.242]  - seeds: <none>
[13:34:39.242]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.243] getGlobalsAndPackages() ...
[13:34:39.243] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.243] Resolving globals: FALSE
[13:34:39.243] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:39.244] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:39.244] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.244] 
[13:34:39.244] getGlobalsAndPackages() ... DONE
[13:34:39.244] run() for ‘Future’ ...
[13:34:39.244] - state: ‘created’
[13:34:39.244] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.258] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.258] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.258]   - Field: ‘node’
[13:34:39.258]   - Field: ‘label’
[13:34:39.258]   - Field: ‘local’
[13:34:39.259]   - Field: ‘owner’
[13:34:39.259]   - Field: ‘envir’
[13:34:39.259]   - Field: ‘workers’
[13:34:39.259]   - Field: ‘packages’
[13:34:39.259]   - Field: ‘gc’
[13:34:39.259]   - Field: ‘conditions’
[13:34:39.259]   - Field: ‘persistent’
[13:34:39.259]   - Field: ‘expr’
[13:34:39.259]   - Field: ‘uuid’
[13:34:39.259]   - Field: ‘seed’
[13:34:39.259]   - Field: ‘version’
[13:34:39.259]   - Field: ‘result’
[13:34:39.260]   - Field: ‘asynchronous’
[13:34:39.260]   - Field: ‘calls’
[13:34:39.260]   - Field: ‘globals’
[13:34:39.260]   - Field: ‘stdout’
[13:34:39.260]   - Field: ‘earlySignal’
[13:34:39.260]   - Field: ‘lazy’
[13:34:39.260]   - Field: ‘state’
[13:34:39.260] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.260] - Launch lazy future ...
[13:34:39.261] Packages needed by the future expression (n = 0): <none>
[13:34:39.261] Packages needed by future strategies (n = 0): <none>
[13:34:39.261] {
[13:34:39.261]     {
[13:34:39.261]         {
[13:34:39.261]             ...future.startTime <- base::Sys.time()
[13:34:39.261]             {
[13:34:39.261]                 {
[13:34:39.261]                   {
[13:34:39.261]                     {
[13:34:39.261]                       base::local({
[13:34:39.261]                         has_future <- base::requireNamespace("future", 
[13:34:39.261]                           quietly = TRUE)
[13:34:39.261]                         if (has_future) {
[13:34:39.261]                           ns <- base::getNamespace("future")
[13:34:39.261]                           version <- ns[[".package"]][["version"]]
[13:34:39.261]                           if (is.null(version)) 
[13:34:39.261]                             version <- utils::packageVersion("future")
[13:34:39.261]                         }
[13:34:39.261]                         else {
[13:34:39.261]                           version <- NULL
[13:34:39.261]                         }
[13:34:39.261]                         if (!has_future || version < "1.8.0") {
[13:34:39.261]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.261]                             "", base::R.version$version.string), 
[13:34:39.261]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.261]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.261]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.261]                               "release", "version")], collapse = " "), 
[13:34:39.261]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.261]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.261]                             info)
[13:34:39.261]                           info <- base::paste(info, collapse = "; ")
[13:34:39.261]                           if (!has_future) {
[13:34:39.261]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.261]                               info)
[13:34:39.261]                           }
[13:34:39.261]                           else {
[13:34:39.261]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.261]                               info, version)
[13:34:39.261]                           }
[13:34:39.261]                           base::stop(msg)
[13:34:39.261]                         }
[13:34:39.261]                       })
[13:34:39.261]                     }
[13:34:39.261]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.261]                     base::options(mc.cores = 1L)
[13:34:39.261]                   }
[13:34:39.261]                   ...future.strategy.old <- future::plan("list")
[13:34:39.261]                   options(future.plan = NULL)
[13:34:39.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.261]                 }
[13:34:39.261]                 ...future.workdir <- getwd()
[13:34:39.261]             }
[13:34:39.261]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.261]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.261]         }
[13:34:39.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.261]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:39.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.261]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.261]             base::names(...future.oldOptions))
[13:34:39.261]     }
[13:34:39.261]     if (FALSE) {
[13:34:39.261]     }
[13:34:39.261]     else {
[13:34:39.261]         if (TRUE) {
[13:34:39.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.261]                 open = "w")
[13:34:39.261]         }
[13:34:39.261]         else {
[13:34:39.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.261]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.261]         }
[13:34:39.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.261]             base::sink(type = "output", split = FALSE)
[13:34:39.261]             base::close(...future.stdout)
[13:34:39.261]         }, add = TRUE)
[13:34:39.261]     }
[13:34:39.261]     ...future.frame <- base::sys.nframe()
[13:34:39.261]     ...future.conditions <- base::list()
[13:34:39.261]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.261]     if (FALSE) {
[13:34:39.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.261]     }
[13:34:39.261]     ...future.result <- base::tryCatch({
[13:34:39.261]         base::withCallingHandlers({
[13:34:39.261]             ...future.value <- base::withVisible(base::local({
[13:34:39.261]                 ...future.makeSendCondition <- base::local({
[13:34:39.261]                   sendCondition <- NULL
[13:34:39.261]                   function(frame = 1L) {
[13:34:39.261]                     if (is.function(sendCondition)) 
[13:34:39.261]                       return(sendCondition)
[13:34:39.261]                     ns <- getNamespace("parallel")
[13:34:39.261]                     if (exists("sendData", mode = "function", 
[13:34:39.261]                       envir = ns)) {
[13:34:39.261]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.261]                         envir = ns)
[13:34:39.261]                       envir <- sys.frame(frame)
[13:34:39.261]                       master <- NULL
[13:34:39.261]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.261]                         !identical(envir, emptyenv())) {
[13:34:39.261]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.261]                           inherits = FALSE)) {
[13:34:39.261]                           master <- get("master", mode = "list", 
[13:34:39.261]                             envir = envir, inherits = FALSE)
[13:34:39.261]                           if (inherits(master, c("SOCKnode", 
[13:34:39.261]                             "SOCK0node"))) {
[13:34:39.261]                             sendCondition <<- function(cond) {
[13:34:39.261]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.261]                                 success = TRUE)
[13:34:39.261]                               parallel_sendData(master, data)
[13:34:39.261]                             }
[13:34:39.261]                             return(sendCondition)
[13:34:39.261]                           }
[13:34:39.261]                         }
[13:34:39.261]                         frame <- frame + 1L
[13:34:39.261]                         envir <- sys.frame(frame)
[13:34:39.261]                       }
[13:34:39.261]                     }
[13:34:39.261]                     sendCondition <<- function(cond) NULL
[13:34:39.261]                   }
[13:34:39.261]                 })
[13:34:39.261]                 withCallingHandlers({
[13:34:39.261]                   {
[13:34:39.261]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.261]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.261]                       ...future.globals.maxSize)) {
[13:34:39.261]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.261]                       on.exit(options(oopts), add = TRUE)
[13:34:39.261]                     }
[13:34:39.261]                     {
[13:34:39.261]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.261]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.261]                         USE.NAMES = FALSE)
[13:34:39.261]                       do.call(mapply, args = args)
[13:34:39.261]                     }
[13:34:39.261]                   }
[13:34:39.261]                 }, immediateCondition = function(cond) {
[13:34:39.261]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.261]                   sendCondition(cond)
[13:34:39.261]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.261]                   {
[13:34:39.261]                     inherits <- base::inherits
[13:34:39.261]                     invokeRestart <- base::invokeRestart
[13:34:39.261]                     is.null <- base::is.null
[13:34:39.261]                     muffled <- FALSE
[13:34:39.261]                     if (inherits(cond, "message")) {
[13:34:39.261]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.261]                       if (muffled) 
[13:34:39.261]                         invokeRestart("muffleMessage")
[13:34:39.261]                     }
[13:34:39.261]                     else if (inherits(cond, "warning")) {
[13:34:39.261]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.261]                       if (muffled) 
[13:34:39.261]                         invokeRestart("muffleWarning")
[13:34:39.261]                     }
[13:34:39.261]                     else if (inherits(cond, "condition")) {
[13:34:39.261]                       if (!is.null(pattern)) {
[13:34:39.261]                         computeRestarts <- base::computeRestarts
[13:34:39.261]                         grepl <- base::grepl
[13:34:39.261]                         restarts <- computeRestarts(cond)
[13:34:39.261]                         for (restart in restarts) {
[13:34:39.261]                           name <- restart$name
[13:34:39.261]                           if (is.null(name)) 
[13:34:39.261]                             next
[13:34:39.261]                           if (!grepl(pattern, name)) 
[13:34:39.261]                             next
[13:34:39.261]                           invokeRestart(restart)
[13:34:39.261]                           muffled <- TRUE
[13:34:39.261]                           break
[13:34:39.261]                         }
[13:34:39.261]                       }
[13:34:39.261]                     }
[13:34:39.261]                     invisible(muffled)
[13:34:39.261]                   }
[13:34:39.261]                   muffleCondition(cond)
[13:34:39.261]                 })
[13:34:39.261]             }))
[13:34:39.261]             future::FutureResult(value = ...future.value$value, 
[13:34:39.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.261]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.261]                     ...future.globalenv.names))
[13:34:39.261]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.261]         }, condition = base::local({
[13:34:39.261]             c <- base::c
[13:34:39.261]             inherits <- base::inherits
[13:34:39.261]             invokeRestart <- base::invokeRestart
[13:34:39.261]             length <- base::length
[13:34:39.261]             list <- base::list
[13:34:39.261]             seq.int <- base::seq.int
[13:34:39.261]             signalCondition <- base::signalCondition
[13:34:39.261]             sys.calls <- base::sys.calls
[13:34:39.261]             `[[` <- base::`[[`
[13:34:39.261]             `+` <- base::`+`
[13:34:39.261]             `<<-` <- base::`<<-`
[13:34:39.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.261]                   3L)]
[13:34:39.261]             }
[13:34:39.261]             function(cond) {
[13:34:39.261]                 is_error <- inherits(cond, "error")
[13:34:39.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.261]                   NULL)
[13:34:39.261]                 if (is_error) {
[13:34:39.261]                   sessionInformation <- function() {
[13:34:39.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.261]                       search = base::search(), system = base::Sys.info())
[13:34:39.261]                   }
[13:34:39.261]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.261]                     cond$call), session = sessionInformation(), 
[13:34:39.261]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.261]                   signalCondition(cond)
[13:34:39.261]                 }
[13:34:39.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.261]                 "immediateCondition"))) {
[13:34:39.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.261]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.261]                   if (TRUE && !signal) {
[13:34:39.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.261]                     {
[13:34:39.261]                       inherits <- base::inherits
[13:34:39.261]                       invokeRestart <- base::invokeRestart
[13:34:39.261]                       is.null <- base::is.null
[13:34:39.261]                       muffled <- FALSE
[13:34:39.261]                       if (inherits(cond, "message")) {
[13:34:39.261]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.261]                         if (muffled) 
[13:34:39.261]                           invokeRestart("muffleMessage")
[13:34:39.261]                       }
[13:34:39.261]                       else if (inherits(cond, "warning")) {
[13:34:39.261]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.261]                         if (muffled) 
[13:34:39.261]                           invokeRestart("muffleWarning")
[13:34:39.261]                       }
[13:34:39.261]                       else if (inherits(cond, "condition")) {
[13:34:39.261]                         if (!is.null(pattern)) {
[13:34:39.261]                           computeRestarts <- base::computeRestarts
[13:34:39.261]                           grepl <- base::grepl
[13:34:39.261]                           restarts <- computeRestarts(cond)
[13:34:39.261]                           for (restart in restarts) {
[13:34:39.261]                             name <- restart$name
[13:34:39.261]                             if (is.null(name)) 
[13:34:39.261]                               next
[13:34:39.261]                             if (!grepl(pattern, name)) 
[13:34:39.261]                               next
[13:34:39.261]                             invokeRestart(restart)
[13:34:39.261]                             muffled <- TRUE
[13:34:39.261]                             break
[13:34:39.261]                           }
[13:34:39.261]                         }
[13:34:39.261]                       }
[13:34:39.261]                       invisible(muffled)
[13:34:39.261]                     }
[13:34:39.261]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.261]                   }
[13:34:39.261]                 }
[13:34:39.261]                 else {
[13:34:39.261]                   if (TRUE) {
[13:34:39.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.261]                     {
[13:34:39.261]                       inherits <- base::inherits
[13:34:39.261]                       invokeRestart <- base::invokeRestart
[13:34:39.261]                       is.null <- base::is.null
[13:34:39.261]                       muffled <- FALSE
[13:34:39.261]                       if (inherits(cond, "message")) {
[13:34:39.261]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.261]                         if (muffled) 
[13:34:39.261]                           invokeRestart("muffleMessage")
[13:34:39.261]                       }
[13:34:39.261]                       else if (inherits(cond, "warning")) {
[13:34:39.261]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.261]                         if (muffled) 
[13:34:39.261]                           invokeRestart("muffleWarning")
[13:34:39.261]                       }
[13:34:39.261]                       else if (inherits(cond, "condition")) {
[13:34:39.261]                         if (!is.null(pattern)) {
[13:34:39.261]                           computeRestarts <- base::computeRestarts
[13:34:39.261]                           grepl <- base::grepl
[13:34:39.261]                           restarts <- computeRestarts(cond)
[13:34:39.261]                           for (restart in restarts) {
[13:34:39.261]                             name <- restart$name
[13:34:39.261]                             if (is.null(name)) 
[13:34:39.261]                               next
[13:34:39.261]                             if (!grepl(pattern, name)) 
[13:34:39.261]                               next
[13:34:39.261]                             invokeRestart(restart)
[13:34:39.261]                             muffled <- TRUE
[13:34:39.261]                             break
[13:34:39.261]                           }
[13:34:39.261]                         }
[13:34:39.261]                       }
[13:34:39.261]                       invisible(muffled)
[13:34:39.261]                     }
[13:34:39.261]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.261]                   }
[13:34:39.261]                 }
[13:34:39.261]             }
[13:34:39.261]         }))
[13:34:39.261]     }, error = function(ex) {
[13:34:39.261]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.261]                 ...future.rng), started = ...future.startTime, 
[13:34:39.261]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.261]             version = "1.8"), class = "FutureResult")
[13:34:39.261]     }, finally = {
[13:34:39.261]         if (!identical(...future.workdir, getwd())) 
[13:34:39.261]             setwd(...future.workdir)
[13:34:39.261]         {
[13:34:39.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.261]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.261]             }
[13:34:39.261]             base::options(...future.oldOptions)
[13:34:39.261]             if (.Platform$OS.type == "windows") {
[13:34:39.261]                 old_names <- names(...future.oldEnvVars)
[13:34:39.261]                 envs <- base::Sys.getenv()
[13:34:39.261]                 names <- names(envs)
[13:34:39.261]                 common <- intersect(names, old_names)
[13:34:39.261]                 added <- setdiff(names, old_names)
[13:34:39.261]                 removed <- setdiff(old_names, names)
[13:34:39.261]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.261]                   envs[common]]
[13:34:39.261]                 NAMES <- toupper(changed)
[13:34:39.261]                 args <- list()
[13:34:39.261]                 for (kk in seq_along(NAMES)) {
[13:34:39.261]                   name <- changed[[kk]]
[13:34:39.261]                   NAME <- NAMES[[kk]]
[13:34:39.261]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.261]                     next
[13:34:39.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.261]                 }
[13:34:39.261]                 NAMES <- toupper(added)
[13:34:39.261]                 for (kk in seq_along(NAMES)) {
[13:34:39.261]                   name <- added[[kk]]
[13:34:39.261]                   NAME <- NAMES[[kk]]
[13:34:39.261]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.261]                     next
[13:34:39.261]                   args[[name]] <- ""
[13:34:39.261]                 }
[13:34:39.261]                 NAMES <- toupper(removed)
[13:34:39.261]                 for (kk in seq_along(NAMES)) {
[13:34:39.261]                   name <- removed[[kk]]
[13:34:39.261]                   NAME <- NAMES[[kk]]
[13:34:39.261]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.261]                     next
[13:34:39.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.261]                 }
[13:34:39.261]                 if (length(args) > 0) 
[13:34:39.261]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.261]             }
[13:34:39.261]             else {
[13:34:39.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.261]             }
[13:34:39.261]             {
[13:34:39.261]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.261]                   0L) {
[13:34:39.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.261]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.261]                   base::options(opts)
[13:34:39.261]                 }
[13:34:39.261]                 {
[13:34:39.261]                   {
[13:34:39.261]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.261]                     NULL
[13:34:39.261]                   }
[13:34:39.261]                   options(future.plan = NULL)
[13:34:39.261]                   if (is.na(NA_character_)) 
[13:34:39.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.261]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.261]                     .init = FALSE)
[13:34:39.261]                 }
[13:34:39.261]             }
[13:34:39.261]         }
[13:34:39.261]     })
[13:34:39.261]     if (TRUE) {
[13:34:39.261]         base::sink(type = "output", split = FALSE)
[13:34:39.261]         if (TRUE) {
[13:34:39.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.261]         }
[13:34:39.261]         else {
[13:34:39.261]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.261]         }
[13:34:39.261]         base::close(...future.stdout)
[13:34:39.261]         ...future.stdout <- NULL
[13:34:39.261]     }
[13:34:39.261]     ...future.result$conditions <- ...future.conditions
[13:34:39.261]     ...future.result$finished <- base::Sys.time()
[13:34:39.261]     ...future.result
[13:34:39.261] }
[13:34:39.263] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[13:34:39.264] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[13:34:39.264] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[13:34:39.264] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:39.264] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.264] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[13:34:39.265] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[13:34:39.265] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:39.265] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.265] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:39.266] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.266] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[13:34:39.266] MultisessionFuture started
[13:34:39.266] - Launch lazy future ... done
[13:34:39.266] run() for ‘MultisessionFuture’ ... done
[13:34:39.266] Created future:
[13:34:39.267] MultisessionFuture:
[13:34:39.267] Label: ‘future_.mapply-1’
[13:34:39.267] Expression:
[13:34:39.267] {
[13:34:39.267]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.267]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.267]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.267]         on.exit(options(oopts), add = TRUE)
[13:34:39.267]     }
[13:34:39.267]     {
[13:34:39.267]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.267]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.267]         do.call(mapply, args = args)
[13:34:39.267]     }
[13:34:39.267] }
[13:34:39.267] Lazy evaluation: FALSE
[13:34:39.267] Asynchronous evaluation: TRUE
[13:34:39.267] Local evaluation: TRUE
[13:34:39.267] Environment: R_GlobalEnv
[13:34:39.267] Capture standard output: TRUE
[13:34:39.267] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.267] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.267] Packages: <none>
[13:34:39.267] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.267] Resolved: FALSE
[13:34:39.267] Value: <not collected>
[13:34:39.267] Conditions captured: <none>
[13:34:39.267] Early signaling: FALSE
[13:34:39.267] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.267] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.278] Chunk #1 of 2 ... DONE
[13:34:39.278] Chunk #2 of 2 ...
[13:34:39.278]  - Finding globals in '...' for chunk #2 ...
[13:34:39.278] getGlobalsAndPackages() ...
[13:34:39.278] Searching for globals...
[13:34:39.279] 
[13:34:39.279] Searching for globals ... DONE
[13:34:39.279] - globals: [0] <none>
[13:34:39.279] getGlobalsAndPackages() ... DONE
[13:34:39.279]    + additional globals found: [n=0] 
[13:34:39.279]    + additional namespaces needed: [n=0] 
[13:34:39.279]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:39.279]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:39.279]  - seeds: <none>
[13:34:39.280]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.280] getGlobalsAndPackages() ...
[13:34:39.280] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.280] Resolving globals: FALSE
[13:34:39.280] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[13:34:39.281] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:39.281] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.281] 
[13:34:39.281] getGlobalsAndPackages() ... DONE
[13:34:39.281] run() for ‘Future’ ...
[13:34:39.281] - state: ‘created’
[13:34:39.282] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.295] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.295]   - Field: ‘node’
[13:34:39.295]   - Field: ‘label’
[13:34:39.295]   - Field: ‘local’
[13:34:39.295]   - Field: ‘owner’
[13:34:39.296]   - Field: ‘envir’
[13:34:39.296]   - Field: ‘workers’
[13:34:39.296]   - Field: ‘packages’
[13:34:39.296]   - Field: ‘gc’
[13:34:39.296]   - Field: ‘conditions’
[13:34:39.296]   - Field: ‘persistent’
[13:34:39.296]   - Field: ‘expr’
[13:34:39.296]   - Field: ‘uuid’
[13:34:39.296]   - Field: ‘seed’
[13:34:39.296]   - Field: ‘version’
[13:34:39.296]   - Field: ‘result’
[13:34:39.297]   - Field: ‘asynchronous’
[13:34:39.297]   - Field: ‘calls’
[13:34:39.297]   - Field: ‘globals’
[13:34:39.297]   - Field: ‘stdout’
[13:34:39.297]   - Field: ‘earlySignal’
[13:34:39.297]   - Field: ‘lazy’
[13:34:39.297]   - Field: ‘state’
[13:34:39.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.297] - Launch lazy future ...
[13:34:39.298] Packages needed by the future expression (n = 0): <none>
[13:34:39.298] Packages needed by future strategies (n = 0): <none>
[13:34:39.298] {
[13:34:39.298]     {
[13:34:39.298]         {
[13:34:39.298]             ...future.startTime <- base::Sys.time()
[13:34:39.298]             {
[13:34:39.298]                 {
[13:34:39.298]                   {
[13:34:39.298]                     {
[13:34:39.298]                       base::local({
[13:34:39.298]                         has_future <- base::requireNamespace("future", 
[13:34:39.298]                           quietly = TRUE)
[13:34:39.298]                         if (has_future) {
[13:34:39.298]                           ns <- base::getNamespace("future")
[13:34:39.298]                           version <- ns[[".package"]][["version"]]
[13:34:39.298]                           if (is.null(version)) 
[13:34:39.298]                             version <- utils::packageVersion("future")
[13:34:39.298]                         }
[13:34:39.298]                         else {
[13:34:39.298]                           version <- NULL
[13:34:39.298]                         }
[13:34:39.298]                         if (!has_future || version < "1.8.0") {
[13:34:39.298]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.298]                             "", base::R.version$version.string), 
[13:34:39.298]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.298]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.298]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.298]                               "release", "version")], collapse = " "), 
[13:34:39.298]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.298]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.298]                             info)
[13:34:39.298]                           info <- base::paste(info, collapse = "; ")
[13:34:39.298]                           if (!has_future) {
[13:34:39.298]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.298]                               info)
[13:34:39.298]                           }
[13:34:39.298]                           else {
[13:34:39.298]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.298]                               info, version)
[13:34:39.298]                           }
[13:34:39.298]                           base::stop(msg)
[13:34:39.298]                         }
[13:34:39.298]                       })
[13:34:39.298]                     }
[13:34:39.298]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.298]                     base::options(mc.cores = 1L)
[13:34:39.298]                   }
[13:34:39.298]                   ...future.strategy.old <- future::plan("list")
[13:34:39.298]                   options(future.plan = NULL)
[13:34:39.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.298]                 }
[13:34:39.298]                 ...future.workdir <- getwd()
[13:34:39.298]             }
[13:34:39.298]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.298]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.298]         }
[13:34:39.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.298]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:39.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.298]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.298]             base::names(...future.oldOptions))
[13:34:39.298]     }
[13:34:39.298]     if (FALSE) {
[13:34:39.298]     }
[13:34:39.298]     else {
[13:34:39.298]         if (TRUE) {
[13:34:39.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.298]                 open = "w")
[13:34:39.298]         }
[13:34:39.298]         else {
[13:34:39.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.298]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.298]         }
[13:34:39.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.298]             base::sink(type = "output", split = FALSE)
[13:34:39.298]             base::close(...future.stdout)
[13:34:39.298]         }, add = TRUE)
[13:34:39.298]     }
[13:34:39.298]     ...future.frame <- base::sys.nframe()
[13:34:39.298]     ...future.conditions <- base::list()
[13:34:39.298]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.298]     if (FALSE) {
[13:34:39.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.298]     }
[13:34:39.298]     ...future.result <- base::tryCatch({
[13:34:39.298]         base::withCallingHandlers({
[13:34:39.298]             ...future.value <- base::withVisible(base::local({
[13:34:39.298]                 ...future.makeSendCondition <- base::local({
[13:34:39.298]                   sendCondition <- NULL
[13:34:39.298]                   function(frame = 1L) {
[13:34:39.298]                     if (is.function(sendCondition)) 
[13:34:39.298]                       return(sendCondition)
[13:34:39.298]                     ns <- getNamespace("parallel")
[13:34:39.298]                     if (exists("sendData", mode = "function", 
[13:34:39.298]                       envir = ns)) {
[13:34:39.298]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.298]                         envir = ns)
[13:34:39.298]                       envir <- sys.frame(frame)
[13:34:39.298]                       master <- NULL
[13:34:39.298]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.298]                         !identical(envir, emptyenv())) {
[13:34:39.298]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.298]                           inherits = FALSE)) {
[13:34:39.298]                           master <- get("master", mode = "list", 
[13:34:39.298]                             envir = envir, inherits = FALSE)
[13:34:39.298]                           if (inherits(master, c("SOCKnode", 
[13:34:39.298]                             "SOCK0node"))) {
[13:34:39.298]                             sendCondition <<- function(cond) {
[13:34:39.298]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.298]                                 success = TRUE)
[13:34:39.298]                               parallel_sendData(master, data)
[13:34:39.298]                             }
[13:34:39.298]                             return(sendCondition)
[13:34:39.298]                           }
[13:34:39.298]                         }
[13:34:39.298]                         frame <- frame + 1L
[13:34:39.298]                         envir <- sys.frame(frame)
[13:34:39.298]                       }
[13:34:39.298]                     }
[13:34:39.298]                     sendCondition <<- function(cond) NULL
[13:34:39.298]                   }
[13:34:39.298]                 })
[13:34:39.298]                 withCallingHandlers({
[13:34:39.298]                   {
[13:34:39.298]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.298]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.298]                       ...future.globals.maxSize)) {
[13:34:39.298]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.298]                       on.exit(options(oopts), add = TRUE)
[13:34:39.298]                     }
[13:34:39.298]                     {
[13:34:39.298]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.298]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.298]                         USE.NAMES = FALSE)
[13:34:39.298]                       do.call(mapply, args = args)
[13:34:39.298]                     }
[13:34:39.298]                   }
[13:34:39.298]                 }, immediateCondition = function(cond) {
[13:34:39.298]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.298]                   sendCondition(cond)
[13:34:39.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.298]                   {
[13:34:39.298]                     inherits <- base::inherits
[13:34:39.298]                     invokeRestart <- base::invokeRestart
[13:34:39.298]                     is.null <- base::is.null
[13:34:39.298]                     muffled <- FALSE
[13:34:39.298]                     if (inherits(cond, "message")) {
[13:34:39.298]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.298]                       if (muffled) 
[13:34:39.298]                         invokeRestart("muffleMessage")
[13:34:39.298]                     }
[13:34:39.298]                     else if (inherits(cond, "warning")) {
[13:34:39.298]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.298]                       if (muffled) 
[13:34:39.298]                         invokeRestart("muffleWarning")
[13:34:39.298]                     }
[13:34:39.298]                     else if (inherits(cond, "condition")) {
[13:34:39.298]                       if (!is.null(pattern)) {
[13:34:39.298]                         computeRestarts <- base::computeRestarts
[13:34:39.298]                         grepl <- base::grepl
[13:34:39.298]                         restarts <- computeRestarts(cond)
[13:34:39.298]                         for (restart in restarts) {
[13:34:39.298]                           name <- restart$name
[13:34:39.298]                           if (is.null(name)) 
[13:34:39.298]                             next
[13:34:39.298]                           if (!grepl(pattern, name)) 
[13:34:39.298]                             next
[13:34:39.298]                           invokeRestart(restart)
[13:34:39.298]                           muffled <- TRUE
[13:34:39.298]                           break
[13:34:39.298]                         }
[13:34:39.298]                       }
[13:34:39.298]                     }
[13:34:39.298]                     invisible(muffled)
[13:34:39.298]                   }
[13:34:39.298]                   muffleCondition(cond)
[13:34:39.298]                 })
[13:34:39.298]             }))
[13:34:39.298]             future::FutureResult(value = ...future.value$value, 
[13:34:39.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.298]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.298]                     ...future.globalenv.names))
[13:34:39.298]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.298]         }, condition = base::local({
[13:34:39.298]             c <- base::c
[13:34:39.298]             inherits <- base::inherits
[13:34:39.298]             invokeRestart <- base::invokeRestart
[13:34:39.298]             length <- base::length
[13:34:39.298]             list <- base::list
[13:34:39.298]             seq.int <- base::seq.int
[13:34:39.298]             signalCondition <- base::signalCondition
[13:34:39.298]             sys.calls <- base::sys.calls
[13:34:39.298]             `[[` <- base::`[[`
[13:34:39.298]             `+` <- base::`+`
[13:34:39.298]             `<<-` <- base::`<<-`
[13:34:39.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.298]                   3L)]
[13:34:39.298]             }
[13:34:39.298]             function(cond) {
[13:34:39.298]                 is_error <- inherits(cond, "error")
[13:34:39.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.298]                   NULL)
[13:34:39.298]                 if (is_error) {
[13:34:39.298]                   sessionInformation <- function() {
[13:34:39.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.298]                       search = base::search(), system = base::Sys.info())
[13:34:39.298]                   }
[13:34:39.298]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.298]                     cond$call), session = sessionInformation(), 
[13:34:39.298]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.298]                   signalCondition(cond)
[13:34:39.298]                 }
[13:34:39.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.298]                 "immediateCondition"))) {
[13:34:39.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.298]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.298]                   if (TRUE && !signal) {
[13:34:39.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.298]                     {
[13:34:39.298]                       inherits <- base::inherits
[13:34:39.298]                       invokeRestart <- base::invokeRestart
[13:34:39.298]                       is.null <- base::is.null
[13:34:39.298]                       muffled <- FALSE
[13:34:39.298]                       if (inherits(cond, "message")) {
[13:34:39.298]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.298]                         if (muffled) 
[13:34:39.298]                           invokeRestart("muffleMessage")
[13:34:39.298]                       }
[13:34:39.298]                       else if (inherits(cond, "warning")) {
[13:34:39.298]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.298]                         if (muffled) 
[13:34:39.298]                           invokeRestart("muffleWarning")
[13:34:39.298]                       }
[13:34:39.298]                       else if (inherits(cond, "condition")) {
[13:34:39.298]                         if (!is.null(pattern)) {
[13:34:39.298]                           computeRestarts <- base::computeRestarts
[13:34:39.298]                           grepl <- base::grepl
[13:34:39.298]                           restarts <- computeRestarts(cond)
[13:34:39.298]                           for (restart in restarts) {
[13:34:39.298]                             name <- restart$name
[13:34:39.298]                             if (is.null(name)) 
[13:34:39.298]                               next
[13:34:39.298]                             if (!grepl(pattern, name)) 
[13:34:39.298]                               next
[13:34:39.298]                             invokeRestart(restart)
[13:34:39.298]                             muffled <- TRUE
[13:34:39.298]                             break
[13:34:39.298]                           }
[13:34:39.298]                         }
[13:34:39.298]                       }
[13:34:39.298]                       invisible(muffled)
[13:34:39.298]                     }
[13:34:39.298]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.298]                   }
[13:34:39.298]                 }
[13:34:39.298]                 else {
[13:34:39.298]                   if (TRUE) {
[13:34:39.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.298]                     {
[13:34:39.298]                       inherits <- base::inherits
[13:34:39.298]                       invokeRestart <- base::invokeRestart
[13:34:39.298]                       is.null <- base::is.null
[13:34:39.298]                       muffled <- FALSE
[13:34:39.298]                       if (inherits(cond, "message")) {
[13:34:39.298]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.298]                         if (muffled) 
[13:34:39.298]                           invokeRestart("muffleMessage")
[13:34:39.298]                       }
[13:34:39.298]                       else if (inherits(cond, "warning")) {
[13:34:39.298]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.298]                         if (muffled) 
[13:34:39.298]                           invokeRestart("muffleWarning")
[13:34:39.298]                       }
[13:34:39.298]                       else if (inherits(cond, "condition")) {
[13:34:39.298]                         if (!is.null(pattern)) {
[13:34:39.298]                           computeRestarts <- base::computeRestarts
[13:34:39.298]                           grepl <- base::grepl
[13:34:39.298]                           restarts <- computeRestarts(cond)
[13:34:39.298]                           for (restart in restarts) {
[13:34:39.298]                             name <- restart$name
[13:34:39.298]                             if (is.null(name)) 
[13:34:39.298]                               next
[13:34:39.298]                             if (!grepl(pattern, name)) 
[13:34:39.298]                               next
[13:34:39.298]                             invokeRestart(restart)
[13:34:39.298]                             muffled <- TRUE
[13:34:39.298]                             break
[13:34:39.298]                           }
[13:34:39.298]                         }
[13:34:39.298]                       }
[13:34:39.298]                       invisible(muffled)
[13:34:39.298]                     }
[13:34:39.298]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.298]                   }
[13:34:39.298]                 }
[13:34:39.298]             }
[13:34:39.298]         }))
[13:34:39.298]     }, error = function(ex) {
[13:34:39.298]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.298]                 ...future.rng), started = ...future.startTime, 
[13:34:39.298]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.298]             version = "1.8"), class = "FutureResult")
[13:34:39.298]     }, finally = {
[13:34:39.298]         if (!identical(...future.workdir, getwd())) 
[13:34:39.298]             setwd(...future.workdir)
[13:34:39.298]         {
[13:34:39.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.298]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.298]             }
[13:34:39.298]             base::options(...future.oldOptions)
[13:34:39.298]             if (.Platform$OS.type == "windows") {
[13:34:39.298]                 old_names <- names(...future.oldEnvVars)
[13:34:39.298]                 envs <- base::Sys.getenv()
[13:34:39.298]                 names <- names(envs)
[13:34:39.298]                 common <- intersect(names, old_names)
[13:34:39.298]                 added <- setdiff(names, old_names)
[13:34:39.298]                 removed <- setdiff(old_names, names)
[13:34:39.298]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.298]                   envs[common]]
[13:34:39.298]                 NAMES <- toupper(changed)
[13:34:39.298]                 args <- list()
[13:34:39.298]                 for (kk in seq_along(NAMES)) {
[13:34:39.298]                   name <- changed[[kk]]
[13:34:39.298]                   NAME <- NAMES[[kk]]
[13:34:39.298]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.298]                     next
[13:34:39.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.298]                 }
[13:34:39.298]                 NAMES <- toupper(added)
[13:34:39.298]                 for (kk in seq_along(NAMES)) {
[13:34:39.298]                   name <- added[[kk]]
[13:34:39.298]                   NAME <- NAMES[[kk]]
[13:34:39.298]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.298]                     next
[13:34:39.298]                   args[[name]] <- ""
[13:34:39.298]                 }
[13:34:39.298]                 NAMES <- toupper(removed)
[13:34:39.298]                 for (kk in seq_along(NAMES)) {
[13:34:39.298]                   name <- removed[[kk]]
[13:34:39.298]                   NAME <- NAMES[[kk]]
[13:34:39.298]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.298]                     next
[13:34:39.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.298]                 }
[13:34:39.298]                 if (length(args) > 0) 
[13:34:39.298]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.298]             }
[13:34:39.298]             else {
[13:34:39.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.298]             }
[13:34:39.298]             {
[13:34:39.298]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.298]                   0L) {
[13:34:39.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.298]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.298]                   base::options(opts)
[13:34:39.298]                 }
[13:34:39.298]                 {
[13:34:39.298]                   {
[13:34:39.298]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.298]                     NULL
[13:34:39.298]                   }
[13:34:39.298]                   options(future.plan = NULL)
[13:34:39.298]                   if (is.na(NA_character_)) 
[13:34:39.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.298]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.298]                     .init = FALSE)
[13:34:39.298]                 }
[13:34:39.298]             }
[13:34:39.298]         }
[13:34:39.298]     })
[13:34:39.298]     if (TRUE) {
[13:34:39.298]         base::sink(type = "output", split = FALSE)
[13:34:39.298]         if (TRUE) {
[13:34:39.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.298]         }
[13:34:39.298]         else {
[13:34:39.298]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.298]         }
[13:34:39.298]         base::close(...future.stdout)
[13:34:39.298]         ...future.stdout <- NULL
[13:34:39.298]     }
[13:34:39.298]     ...future.result$conditions <- ...future.conditions
[13:34:39.298]     ...future.result$finished <- base::Sys.time()
[13:34:39.298]     ...future.result
[13:34:39.298] }
[13:34:39.301] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[13:34:39.301] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[13:34:39.301] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[13:34:39.301] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:39.301] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.302] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[13:34:39.302] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[13:34:39.302] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:39.302] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.303] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:39.303] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.303] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[13:34:39.303] MultisessionFuture started
[13:34:39.304] - Launch lazy future ... done
[13:34:39.304] run() for ‘MultisessionFuture’ ... done
[13:34:39.304] Created future:
[13:34:39.304] MultisessionFuture:
[13:34:39.304] Label: ‘future_.mapply-2’
[13:34:39.304] Expression:
[13:34:39.304] {
[13:34:39.304]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.304]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.304]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.304]         on.exit(options(oopts), add = TRUE)
[13:34:39.304]     }
[13:34:39.304]     {
[13:34:39.304]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.304]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.304]         do.call(mapply, args = args)
[13:34:39.304]     }
[13:34:39.304] }
[13:34:39.304] Lazy evaluation: FALSE
[13:34:39.304] Asynchronous evaluation: TRUE
[13:34:39.304] Local evaluation: TRUE
[13:34:39.304] Environment: R_GlobalEnv
[13:34:39.304] Capture standard output: TRUE
[13:34:39.304] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.304] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.304] Packages: <none>
[13:34:39.304] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.304] Resolved: FALSE
[13:34:39.304] Value: <not collected>
[13:34:39.304] Conditions captured: <none>
[13:34:39.304] Early signaling: FALSE
[13:34:39.304] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.304] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.315] Chunk #2 of 2 ... DONE
[13:34:39.315] Launching 2 futures (chunks) ... DONE
[13:34:39.315] Resolving 2 futures (chunks) ...
[13:34:39.315] resolve() on list ...
[13:34:39.315]  recursive: 0
[13:34:39.316]  length: 2
[13:34:39.316] 
[13:34:39.316] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.316] - Validating connection of MultisessionFuture
[13:34:39.316] - received message: FutureResult
[13:34:39.316] - Received FutureResult
[13:34:39.317] - Erased future from FutureRegistry
[13:34:39.317] result() for ClusterFuture ...
[13:34:39.317] - result already collected: FutureResult
[13:34:39.317] result() for ClusterFuture ... done
[13:34:39.317] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.317] Future #1
[13:34:39.317] result() for ClusterFuture ...
[13:34:39.317] - result already collected: FutureResult
[13:34:39.317] result() for ClusterFuture ... done
[13:34:39.317] result() for ClusterFuture ...
[13:34:39.317] - result already collected: FutureResult
[13:34:39.318] result() for ClusterFuture ... done
[13:34:39.318] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:39.318] - nx: 2
[13:34:39.318] - relay: TRUE
[13:34:39.318] - stdout: TRUE
[13:34:39.318] - signal: TRUE
[13:34:39.318] - resignal: FALSE
[13:34:39.318] - force: TRUE
[13:34:39.318] - relayed: [n=2] FALSE, FALSE
[13:34:39.318] - queued futures: [n=2] FALSE, FALSE
[13:34:39.318]  - until=1
[13:34:39.319]  - relaying element #1
[13:34:39.319] result() for ClusterFuture ...
[13:34:39.319] - result already collected: FutureResult
[13:34:39.319] result() for ClusterFuture ... done
[13:34:39.319] result() for ClusterFuture ...
[13:34:39.319] - result already collected: FutureResult
[13:34:39.319] result() for ClusterFuture ... done
[13:34:39.319] result() for ClusterFuture ...
[13:34:39.319] - result already collected: FutureResult
[13:34:39.319] result() for ClusterFuture ... done
[13:34:39.319] result() for ClusterFuture ...
[13:34:39.320] - result already collected: FutureResult
[13:34:39.320] result() for ClusterFuture ... done
[13:34:39.320] - relayed: [n=2] TRUE, FALSE
[13:34:39.320] - queued futures: [n=2] TRUE, FALSE
[13:34:39.320] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:39.320]  length: 1 (resolved future 1)
[13:34:39.348] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.348] - Validating connection of MultisessionFuture
[13:34:39.348] - received message: FutureResult
[13:34:39.348] - Received FutureResult
[13:34:39.348] - Erased future from FutureRegistry
[13:34:39.348] result() for ClusterFuture ...
[13:34:39.348] - result already collected: FutureResult
[13:34:39.349] result() for ClusterFuture ... done
[13:34:39.349] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.349] Future #2
[13:34:39.349] result() for ClusterFuture ...
[13:34:39.349] - result already collected: FutureResult
[13:34:39.349] result() for ClusterFuture ... done
[13:34:39.349] result() for ClusterFuture ...
[13:34:39.349] - result already collected: FutureResult
[13:34:39.349] result() for ClusterFuture ... done
[13:34:39.349] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:39.349] - nx: 2
[13:34:39.350] - relay: TRUE
[13:34:39.350] - stdout: TRUE
[13:34:39.350] - signal: TRUE
[13:34:39.350] - resignal: FALSE
[13:34:39.350] - force: TRUE
[13:34:39.350] - relayed: [n=2] TRUE, FALSE
[13:34:39.350] - queued futures: [n=2] TRUE, FALSE
[13:34:39.350]  - until=2
[13:34:39.350]  - relaying element #2
[13:34:39.350] result() for ClusterFuture ...
[13:34:39.350] - result already collected: FutureResult
[13:34:39.350] result() for ClusterFuture ... done
[13:34:39.351] result() for ClusterFuture ...
[13:34:39.351] - result already collected: FutureResult
[13:34:39.351] result() for ClusterFuture ... done
[13:34:39.351] result() for ClusterFuture ...
[13:34:39.351] - result already collected: FutureResult
[13:34:39.351] result() for ClusterFuture ... done
[13:34:39.351] result() for ClusterFuture ...
[13:34:39.351] - result already collected: FutureResult
[13:34:39.351] result() for ClusterFuture ... done
[13:34:39.351] - relayed: [n=2] TRUE, TRUE
[13:34:39.352] - queued futures: [n=2] TRUE, TRUE
[13:34:39.352] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:39.352]  length: 0 (resolved future 2)
[13:34:39.352] Relaying remaining futures
[13:34:39.352] signalConditionsASAP(NULL, pos=0) ...
[13:34:39.352] - nx: 2
[13:34:39.352] - relay: TRUE
[13:34:39.352] - stdout: TRUE
[13:34:39.352] - signal: TRUE
[13:34:39.352] - resignal: FALSE
[13:34:39.352] - force: TRUE
[13:34:39.352] - relayed: [n=2] TRUE, TRUE
[13:34:39.352] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:39.353] - relayed: [n=2] TRUE, TRUE
[13:34:39.353] - queued futures: [n=2] TRUE, TRUE
[13:34:39.353] signalConditionsASAP(NULL, pos=0) ... done
[13:34:39.353] resolve() on list ... DONE
[13:34:39.353] result() for ClusterFuture ...
[13:34:39.353] - result already collected: FutureResult
[13:34:39.353] result() for ClusterFuture ... done
[13:34:39.353] result() for ClusterFuture ...
[13:34:39.353] - result already collected: FutureResult
[13:34:39.353] result() for ClusterFuture ... done
[13:34:39.354] result() for ClusterFuture ...
[13:34:39.354] - result already collected: FutureResult
[13:34:39.354] result() for ClusterFuture ... done
[13:34:39.354] result() for ClusterFuture ...
[13:34:39.354] - result already collected: FutureResult
[13:34:39.354] result() for ClusterFuture ... done
[13:34:39.354]  - Number of value chunks collected: 2
[13:34:39.354] Resolving 2 futures (chunks) ... DONE
[13:34:39.354] Reducing values from 2 chunks ...
[13:34:39.354]  - Number of values collected after concatenation: 5
[13:34:39.354]  - Number of values expected: 5
[13:34:39.355] Reducing values from 2 chunks ... DONE
[13:34:39.355] future_mapply() ... DONE
[13:34:39.355] future_mapply() ...
[13:34:39.358] Number of chunks: 3
[13:34:39.358] Index remapping (attribute 'ordering'): [n = 5] 1, 2, 3, 4, 5
[13:34:39.358] getGlobalsAndPackagesXApply() ...
[13:34:39.359]  - future.globals: TRUE
[13:34:39.359] getGlobalsAndPackages() ...
[13:34:39.359] Searching for globals...
[13:34:39.360] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:39.360] Searching for globals ... DONE
[13:34:39.360] Resolving globals: FALSE
[13:34:39.361] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:39.361] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:39.361] - globals: [1] ‘FUN’
[13:34:39.361] 
[13:34:39.361] getGlobalsAndPackages() ... DONE
[13:34:39.361]  - globals found/used: [n=1] ‘FUN’
[13:34:39.361]  - needed namespaces: [n=0] 
[13:34:39.361] Finding globals ... DONE
[13:34:39.362] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:39.362] List of 2
[13:34:39.362]  $ ...future.FUN:function (C, k)  
[13:34:39.362]  $ MoreArgs     : NULL
[13:34:39.362]  - attr(*, "where")=List of 2
[13:34:39.362]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:39.362]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:39.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:39.362]  - attr(*, "resolved")= logi FALSE
[13:34:39.362]  - attr(*, "total_size")= num NA
[13:34:39.364] Packages to be attached in all futures: [n=0] 
[13:34:39.364] getGlobalsAndPackagesXApply() ... DONE
[13:34:39.364] Number of futures (= number of chunks): 3
[13:34:39.365] Launching 3 futures (chunks) ...
[13:34:39.365] Chunk #1 of 3 ...
[13:34:39.365]  - Finding globals in '...' for chunk #1 ...
[13:34:39.365] getGlobalsAndPackages() ...
[13:34:39.365] Searching for globals...
[13:34:39.365] 
[13:34:39.365] Searching for globals ... DONE
[13:34:39.365] - globals: [0] <none>
[13:34:39.365] getGlobalsAndPackages() ... DONE
[13:34:39.366]    + additional globals found: [n=0] 
[13:34:39.366]    + additional namespaces needed: [n=0] 
[13:34:39.366]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:39.366]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:34:39.366]  - seeds: <none>
[13:34:39.366]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.366] getGlobalsAndPackages() ...
[13:34:39.366] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.366] Resolving globals: FALSE
[13:34:39.367] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:39.367] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:39.367] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.367] 
[13:34:39.368] getGlobalsAndPackages() ... DONE
[13:34:39.368] run() for ‘Future’ ...
[13:34:39.368] - state: ‘created’
[13:34:39.368] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.381] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.382] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.382]   - Field: ‘node’
[13:34:39.382]   - Field: ‘label’
[13:34:39.382]   - Field: ‘local’
[13:34:39.382]   - Field: ‘owner’
[13:34:39.382]   - Field: ‘envir’
[13:34:39.382]   - Field: ‘workers’
[13:34:39.382]   - Field: ‘packages’
[13:34:39.382]   - Field: ‘gc’
[13:34:39.383]   - Field: ‘conditions’
[13:34:39.383]   - Field: ‘persistent’
[13:34:39.383]   - Field: ‘expr’
[13:34:39.383]   - Field: ‘uuid’
[13:34:39.383]   - Field: ‘seed’
[13:34:39.383]   - Field: ‘version’
[13:34:39.383]   - Field: ‘result’
[13:34:39.383]   - Field: ‘asynchronous’
[13:34:39.383]   - Field: ‘calls’
[13:34:39.383]   - Field: ‘globals’
[13:34:39.383]   - Field: ‘stdout’
[13:34:39.384]   - Field: ‘earlySignal’
[13:34:39.384]   - Field: ‘lazy’
[13:34:39.384]   - Field: ‘state’
[13:34:39.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.384] - Launch lazy future ...
[13:34:39.384] Packages needed by the future expression (n = 0): <none>
[13:34:39.384] Packages needed by future strategies (n = 0): <none>
[13:34:39.385] {
[13:34:39.385]     {
[13:34:39.385]         {
[13:34:39.385]             ...future.startTime <- base::Sys.time()
[13:34:39.385]             {
[13:34:39.385]                 {
[13:34:39.385]                   {
[13:34:39.385]                     {
[13:34:39.385]                       base::local({
[13:34:39.385]                         has_future <- base::requireNamespace("future", 
[13:34:39.385]                           quietly = TRUE)
[13:34:39.385]                         if (has_future) {
[13:34:39.385]                           ns <- base::getNamespace("future")
[13:34:39.385]                           version <- ns[[".package"]][["version"]]
[13:34:39.385]                           if (is.null(version)) 
[13:34:39.385]                             version <- utils::packageVersion("future")
[13:34:39.385]                         }
[13:34:39.385]                         else {
[13:34:39.385]                           version <- NULL
[13:34:39.385]                         }
[13:34:39.385]                         if (!has_future || version < "1.8.0") {
[13:34:39.385]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.385]                             "", base::R.version$version.string), 
[13:34:39.385]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.385]                               "release", "version")], collapse = " "), 
[13:34:39.385]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.385]                             info)
[13:34:39.385]                           info <- base::paste(info, collapse = "; ")
[13:34:39.385]                           if (!has_future) {
[13:34:39.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.385]                               info)
[13:34:39.385]                           }
[13:34:39.385]                           else {
[13:34:39.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.385]                               info, version)
[13:34:39.385]                           }
[13:34:39.385]                           base::stop(msg)
[13:34:39.385]                         }
[13:34:39.385]                       })
[13:34:39.385]                     }
[13:34:39.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.385]                     base::options(mc.cores = 1L)
[13:34:39.385]                   }
[13:34:39.385]                   ...future.strategy.old <- future::plan("list")
[13:34:39.385]                   options(future.plan = NULL)
[13:34:39.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.385]                 }
[13:34:39.385]                 ...future.workdir <- getwd()
[13:34:39.385]             }
[13:34:39.385]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.385]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.385]         }
[13:34:39.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.385]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:34:39.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.385]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.385]             base::names(...future.oldOptions))
[13:34:39.385]     }
[13:34:39.385]     if (FALSE) {
[13:34:39.385]     }
[13:34:39.385]     else {
[13:34:39.385]         if (TRUE) {
[13:34:39.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.385]                 open = "w")
[13:34:39.385]         }
[13:34:39.385]         else {
[13:34:39.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.385]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.385]         }
[13:34:39.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.385]             base::sink(type = "output", split = FALSE)
[13:34:39.385]             base::close(...future.stdout)
[13:34:39.385]         }, add = TRUE)
[13:34:39.385]     }
[13:34:39.385]     ...future.frame <- base::sys.nframe()
[13:34:39.385]     ...future.conditions <- base::list()
[13:34:39.385]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.385]     if (FALSE) {
[13:34:39.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.385]     }
[13:34:39.385]     ...future.result <- base::tryCatch({
[13:34:39.385]         base::withCallingHandlers({
[13:34:39.385]             ...future.value <- base::withVisible(base::local({
[13:34:39.385]                 ...future.makeSendCondition <- base::local({
[13:34:39.385]                   sendCondition <- NULL
[13:34:39.385]                   function(frame = 1L) {
[13:34:39.385]                     if (is.function(sendCondition)) 
[13:34:39.385]                       return(sendCondition)
[13:34:39.385]                     ns <- getNamespace("parallel")
[13:34:39.385]                     if (exists("sendData", mode = "function", 
[13:34:39.385]                       envir = ns)) {
[13:34:39.385]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.385]                         envir = ns)
[13:34:39.385]                       envir <- sys.frame(frame)
[13:34:39.385]                       master <- NULL
[13:34:39.385]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.385]                         !identical(envir, emptyenv())) {
[13:34:39.385]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.385]                           inherits = FALSE)) {
[13:34:39.385]                           master <- get("master", mode = "list", 
[13:34:39.385]                             envir = envir, inherits = FALSE)
[13:34:39.385]                           if (inherits(master, c("SOCKnode", 
[13:34:39.385]                             "SOCK0node"))) {
[13:34:39.385]                             sendCondition <<- function(cond) {
[13:34:39.385]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.385]                                 success = TRUE)
[13:34:39.385]                               parallel_sendData(master, data)
[13:34:39.385]                             }
[13:34:39.385]                             return(sendCondition)
[13:34:39.385]                           }
[13:34:39.385]                         }
[13:34:39.385]                         frame <- frame + 1L
[13:34:39.385]                         envir <- sys.frame(frame)
[13:34:39.385]                       }
[13:34:39.385]                     }
[13:34:39.385]                     sendCondition <<- function(cond) NULL
[13:34:39.385]                   }
[13:34:39.385]                 })
[13:34:39.385]                 withCallingHandlers({
[13:34:39.385]                   {
[13:34:39.385]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.385]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.385]                       ...future.globals.maxSize)) {
[13:34:39.385]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.385]                       on.exit(options(oopts), add = TRUE)
[13:34:39.385]                     }
[13:34:39.385]                     {
[13:34:39.385]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.385]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.385]                         USE.NAMES = FALSE)
[13:34:39.385]                       do.call(mapply, args = args)
[13:34:39.385]                     }
[13:34:39.385]                   }
[13:34:39.385]                 }, immediateCondition = function(cond) {
[13:34:39.385]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.385]                   sendCondition(cond)
[13:34:39.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.385]                   {
[13:34:39.385]                     inherits <- base::inherits
[13:34:39.385]                     invokeRestart <- base::invokeRestart
[13:34:39.385]                     is.null <- base::is.null
[13:34:39.385]                     muffled <- FALSE
[13:34:39.385]                     if (inherits(cond, "message")) {
[13:34:39.385]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.385]                       if (muffled) 
[13:34:39.385]                         invokeRestart("muffleMessage")
[13:34:39.385]                     }
[13:34:39.385]                     else if (inherits(cond, "warning")) {
[13:34:39.385]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.385]                       if (muffled) 
[13:34:39.385]                         invokeRestart("muffleWarning")
[13:34:39.385]                     }
[13:34:39.385]                     else if (inherits(cond, "condition")) {
[13:34:39.385]                       if (!is.null(pattern)) {
[13:34:39.385]                         computeRestarts <- base::computeRestarts
[13:34:39.385]                         grepl <- base::grepl
[13:34:39.385]                         restarts <- computeRestarts(cond)
[13:34:39.385]                         for (restart in restarts) {
[13:34:39.385]                           name <- restart$name
[13:34:39.385]                           if (is.null(name)) 
[13:34:39.385]                             next
[13:34:39.385]                           if (!grepl(pattern, name)) 
[13:34:39.385]                             next
[13:34:39.385]                           invokeRestart(restart)
[13:34:39.385]                           muffled <- TRUE
[13:34:39.385]                           break
[13:34:39.385]                         }
[13:34:39.385]                       }
[13:34:39.385]                     }
[13:34:39.385]                     invisible(muffled)
[13:34:39.385]                   }
[13:34:39.385]                   muffleCondition(cond)
[13:34:39.385]                 })
[13:34:39.385]             }))
[13:34:39.385]             future::FutureResult(value = ...future.value$value, 
[13:34:39.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.385]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.385]                     ...future.globalenv.names))
[13:34:39.385]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.385]         }, condition = base::local({
[13:34:39.385]             c <- base::c
[13:34:39.385]             inherits <- base::inherits
[13:34:39.385]             invokeRestart <- base::invokeRestart
[13:34:39.385]             length <- base::length
[13:34:39.385]             list <- base::list
[13:34:39.385]             seq.int <- base::seq.int
[13:34:39.385]             signalCondition <- base::signalCondition
[13:34:39.385]             sys.calls <- base::sys.calls
[13:34:39.385]             `[[` <- base::`[[`
[13:34:39.385]             `+` <- base::`+`
[13:34:39.385]             `<<-` <- base::`<<-`
[13:34:39.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.385]                   3L)]
[13:34:39.385]             }
[13:34:39.385]             function(cond) {
[13:34:39.385]                 is_error <- inherits(cond, "error")
[13:34:39.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.385]                   NULL)
[13:34:39.385]                 if (is_error) {
[13:34:39.385]                   sessionInformation <- function() {
[13:34:39.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.385]                       search = base::search(), system = base::Sys.info())
[13:34:39.385]                   }
[13:34:39.385]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.385]                     cond$call), session = sessionInformation(), 
[13:34:39.385]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.385]                   signalCondition(cond)
[13:34:39.385]                 }
[13:34:39.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.385]                 "immediateCondition"))) {
[13:34:39.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.385]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.385]                   if (TRUE && !signal) {
[13:34:39.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.385]                     {
[13:34:39.385]                       inherits <- base::inherits
[13:34:39.385]                       invokeRestart <- base::invokeRestart
[13:34:39.385]                       is.null <- base::is.null
[13:34:39.385]                       muffled <- FALSE
[13:34:39.385]                       if (inherits(cond, "message")) {
[13:34:39.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.385]                         if (muffled) 
[13:34:39.385]                           invokeRestart("muffleMessage")
[13:34:39.385]                       }
[13:34:39.385]                       else if (inherits(cond, "warning")) {
[13:34:39.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.385]                         if (muffled) 
[13:34:39.385]                           invokeRestart("muffleWarning")
[13:34:39.385]                       }
[13:34:39.385]                       else if (inherits(cond, "condition")) {
[13:34:39.385]                         if (!is.null(pattern)) {
[13:34:39.385]                           computeRestarts <- base::computeRestarts
[13:34:39.385]                           grepl <- base::grepl
[13:34:39.385]                           restarts <- computeRestarts(cond)
[13:34:39.385]                           for (restart in restarts) {
[13:34:39.385]                             name <- restart$name
[13:34:39.385]                             if (is.null(name)) 
[13:34:39.385]                               next
[13:34:39.385]                             if (!grepl(pattern, name)) 
[13:34:39.385]                               next
[13:34:39.385]                             invokeRestart(restart)
[13:34:39.385]                             muffled <- TRUE
[13:34:39.385]                             break
[13:34:39.385]                           }
[13:34:39.385]                         }
[13:34:39.385]                       }
[13:34:39.385]                       invisible(muffled)
[13:34:39.385]                     }
[13:34:39.385]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.385]                   }
[13:34:39.385]                 }
[13:34:39.385]                 else {
[13:34:39.385]                   if (TRUE) {
[13:34:39.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.385]                     {
[13:34:39.385]                       inherits <- base::inherits
[13:34:39.385]                       invokeRestart <- base::invokeRestart
[13:34:39.385]                       is.null <- base::is.null
[13:34:39.385]                       muffled <- FALSE
[13:34:39.385]                       if (inherits(cond, "message")) {
[13:34:39.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.385]                         if (muffled) 
[13:34:39.385]                           invokeRestart("muffleMessage")
[13:34:39.385]                       }
[13:34:39.385]                       else if (inherits(cond, "warning")) {
[13:34:39.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.385]                         if (muffled) 
[13:34:39.385]                           invokeRestart("muffleWarning")
[13:34:39.385]                       }
[13:34:39.385]                       else if (inherits(cond, "condition")) {
[13:34:39.385]                         if (!is.null(pattern)) {
[13:34:39.385]                           computeRestarts <- base::computeRestarts
[13:34:39.385]                           grepl <- base::grepl
[13:34:39.385]                           restarts <- computeRestarts(cond)
[13:34:39.385]                           for (restart in restarts) {
[13:34:39.385]                             name <- restart$name
[13:34:39.385]                             if (is.null(name)) 
[13:34:39.385]                               next
[13:34:39.385]                             if (!grepl(pattern, name)) 
[13:34:39.385]                               next
[13:34:39.385]                             invokeRestart(restart)
[13:34:39.385]                             muffled <- TRUE
[13:34:39.385]                             break
[13:34:39.385]                           }
[13:34:39.385]                         }
[13:34:39.385]                       }
[13:34:39.385]                       invisible(muffled)
[13:34:39.385]                     }
[13:34:39.385]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.385]                   }
[13:34:39.385]                 }
[13:34:39.385]             }
[13:34:39.385]         }))
[13:34:39.385]     }, error = function(ex) {
[13:34:39.385]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.385]                 ...future.rng), started = ...future.startTime, 
[13:34:39.385]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.385]             version = "1.8"), class = "FutureResult")
[13:34:39.385]     }, finally = {
[13:34:39.385]         if (!identical(...future.workdir, getwd())) 
[13:34:39.385]             setwd(...future.workdir)
[13:34:39.385]         {
[13:34:39.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.385]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.385]             }
[13:34:39.385]             base::options(...future.oldOptions)
[13:34:39.385]             if (.Platform$OS.type == "windows") {
[13:34:39.385]                 old_names <- names(...future.oldEnvVars)
[13:34:39.385]                 envs <- base::Sys.getenv()
[13:34:39.385]                 names <- names(envs)
[13:34:39.385]                 common <- intersect(names, old_names)
[13:34:39.385]                 added <- setdiff(names, old_names)
[13:34:39.385]                 removed <- setdiff(old_names, names)
[13:34:39.385]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.385]                   envs[common]]
[13:34:39.385]                 NAMES <- toupper(changed)
[13:34:39.385]                 args <- list()
[13:34:39.385]                 for (kk in seq_along(NAMES)) {
[13:34:39.385]                   name <- changed[[kk]]
[13:34:39.385]                   NAME <- NAMES[[kk]]
[13:34:39.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.385]                     next
[13:34:39.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.385]                 }
[13:34:39.385]                 NAMES <- toupper(added)
[13:34:39.385]                 for (kk in seq_along(NAMES)) {
[13:34:39.385]                   name <- added[[kk]]
[13:34:39.385]                   NAME <- NAMES[[kk]]
[13:34:39.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.385]                     next
[13:34:39.385]                   args[[name]] <- ""
[13:34:39.385]                 }
[13:34:39.385]                 NAMES <- toupper(removed)
[13:34:39.385]                 for (kk in seq_along(NAMES)) {
[13:34:39.385]                   name <- removed[[kk]]
[13:34:39.385]                   NAME <- NAMES[[kk]]
[13:34:39.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.385]                     next
[13:34:39.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.385]                 }
[13:34:39.385]                 if (length(args) > 0) 
[13:34:39.385]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.385]             }
[13:34:39.385]             else {
[13:34:39.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.385]             }
[13:34:39.385]             {
[13:34:39.385]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.385]                   0L) {
[13:34:39.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.385]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.385]                   base::options(opts)
[13:34:39.385]                 }
[13:34:39.385]                 {
[13:34:39.385]                   {
[13:34:39.385]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.385]                     NULL
[13:34:39.385]                   }
[13:34:39.385]                   options(future.plan = NULL)
[13:34:39.385]                   if (is.na(NA_character_)) 
[13:34:39.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.385]                     .init = FALSE)
[13:34:39.385]                 }
[13:34:39.385]             }
[13:34:39.385]         }
[13:34:39.385]     })
[13:34:39.385]     if (TRUE) {
[13:34:39.385]         base::sink(type = "output", split = FALSE)
[13:34:39.385]         if (TRUE) {
[13:34:39.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.385]         }
[13:34:39.385]         else {
[13:34:39.385]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.385]         }
[13:34:39.385]         base::close(...future.stdout)
[13:34:39.385]         ...future.stdout <- NULL
[13:34:39.385]     }
[13:34:39.385]     ...future.result$conditions <- ...future.conditions
[13:34:39.385]     ...future.result$finished <- base::Sys.time()
[13:34:39.385]     ...future.result
[13:34:39.385] }
[13:34:39.387] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[13:34:39.387] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[13:34:39.388] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[13:34:39.388] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:39.388] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.388] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[13:34:39.389] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[13:34:39.389] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:39.392] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.392] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:39.392] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.392] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[13:34:39.393] MultisessionFuture started
[13:34:39.393] - Launch lazy future ... done
[13:34:39.393] run() for ‘MultisessionFuture’ ... done
[13:34:39.393] Created future:
[13:34:39.393] MultisessionFuture:
[13:34:39.393] Label: ‘future_mapply-1’
[13:34:39.393] Expression:
[13:34:39.393] {
[13:34:39.393]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.393]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.393]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.393]         on.exit(options(oopts), add = TRUE)
[13:34:39.393]     }
[13:34:39.393]     {
[13:34:39.393]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.393]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.393]         do.call(mapply, args = args)
[13:34:39.393]     }
[13:34:39.393] }
[13:34:39.393] Lazy evaluation: FALSE
[13:34:39.393] Asynchronous evaluation: TRUE
[13:34:39.393] Local evaluation: TRUE
[13:34:39.393] Environment: R_GlobalEnv
[13:34:39.393] Capture standard output: TRUE
[13:34:39.393] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.393] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.393] Packages: <none>
[13:34:39.393] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.393] Resolved: FALSE
[13:34:39.393] Value: <not collected>
[13:34:39.393] Conditions captured: <none>
[13:34:39.393] Early signaling: FALSE
[13:34:39.393] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.393] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.405] Chunk #1 of 3 ... DONE
[13:34:39.405] Chunk #2 of 3 ...
[13:34:39.405]  - Finding globals in '...' for chunk #2 ...
[13:34:39.405] getGlobalsAndPackages() ...
[13:34:39.405] Searching for globals...
[13:34:39.406] 
[13:34:39.406] Searching for globals ... DONE
[13:34:39.406] - globals: [0] <none>
[13:34:39.406] getGlobalsAndPackages() ... DONE
[13:34:39.406]    + additional globals found: [n=0] 
[13:34:39.406]    + additional namespaces needed: [n=0] 
[13:34:39.406]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:39.406]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:34:39.406]  - seeds: <none>
[13:34:39.407]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.407] getGlobalsAndPackages() ...
[13:34:39.407] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.407] Resolving globals: FALSE
[13:34:39.407] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[13:34:39.408] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:39.408] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.408] 
[13:34:39.408] getGlobalsAndPackages() ... DONE
[13:34:39.408] run() for ‘Future’ ...
[13:34:39.408] - state: ‘created’
[13:34:39.408] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.422] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.423]   - Field: ‘node’
[13:34:39.423]   - Field: ‘label’
[13:34:39.423]   - Field: ‘local’
[13:34:39.423]   - Field: ‘owner’
[13:34:39.423]   - Field: ‘envir’
[13:34:39.423]   - Field: ‘workers’
[13:34:39.423]   - Field: ‘packages’
[13:34:39.423]   - Field: ‘gc’
[13:34:39.423]   - Field: ‘conditions’
[13:34:39.423]   - Field: ‘persistent’
[13:34:39.423]   - Field: ‘expr’
[13:34:39.424]   - Field: ‘uuid’
[13:34:39.424]   - Field: ‘seed’
[13:34:39.424]   - Field: ‘version’
[13:34:39.424]   - Field: ‘result’
[13:34:39.424]   - Field: ‘asynchronous’
[13:34:39.424]   - Field: ‘calls’
[13:34:39.424]   - Field: ‘globals’
[13:34:39.424]   - Field: ‘stdout’
[13:34:39.424]   - Field: ‘earlySignal’
[13:34:39.424]   - Field: ‘lazy’
[13:34:39.424]   - Field: ‘state’
[13:34:39.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.425] - Launch lazy future ...
[13:34:39.425] Packages needed by the future expression (n = 0): <none>
[13:34:39.425] Packages needed by future strategies (n = 0): <none>
[13:34:39.425] {
[13:34:39.425]     {
[13:34:39.425]         {
[13:34:39.425]             ...future.startTime <- base::Sys.time()
[13:34:39.425]             {
[13:34:39.425]                 {
[13:34:39.425]                   {
[13:34:39.425]                     {
[13:34:39.425]                       base::local({
[13:34:39.425]                         has_future <- base::requireNamespace("future", 
[13:34:39.425]                           quietly = TRUE)
[13:34:39.425]                         if (has_future) {
[13:34:39.425]                           ns <- base::getNamespace("future")
[13:34:39.425]                           version <- ns[[".package"]][["version"]]
[13:34:39.425]                           if (is.null(version)) 
[13:34:39.425]                             version <- utils::packageVersion("future")
[13:34:39.425]                         }
[13:34:39.425]                         else {
[13:34:39.425]                           version <- NULL
[13:34:39.425]                         }
[13:34:39.425]                         if (!has_future || version < "1.8.0") {
[13:34:39.425]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.425]                             "", base::R.version$version.string), 
[13:34:39.425]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.425]                               "release", "version")], collapse = " "), 
[13:34:39.425]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.425]                             info)
[13:34:39.425]                           info <- base::paste(info, collapse = "; ")
[13:34:39.425]                           if (!has_future) {
[13:34:39.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.425]                               info)
[13:34:39.425]                           }
[13:34:39.425]                           else {
[13:34:39.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.425]                               info, version)
[13:34:39.425]                           }
[13:34:39.425]                           base::stop(msg)
[13:34:39.425]                         }
[13:34:39.425]                       })
[13:34:39.425]                     }
[13:34:39.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.425]                     base::options(mc.cores = 1L)
[13:34:39.425]                   }
[13:34:39.425]                   ...future.strategy.old <- future::plan("list")
[13:34:39.425]                   options(future.plan = NULL)
[13:34:39.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.425]                 }
[13:34:39.425]                 ...future.workdir <- getwd()
[13:34:39.425]             }
[13:34:39.425]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.425]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.425]         }
[13:34:39.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.425]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:34:39.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.425]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.425]             base::names(...future.oldOptions))
[13:34:39.425]     }
[13:34:39.425]     if (FALSE) {
[13:34:39.425]     }
[13:34:39.425]     else {
[13:34:39.425]         if (TRUE) {
[13:34:39.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.425]                 open = "w")
[13:34:39.425]         }
[13:34:39.425]         else {
[13:34:39.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.425]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.425]         }
[13:34:39.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.425]             base::sink(type = "output", split = FALSE)
[13:34:39.425]             base::close(...future.stdout)
[13:34:39.425]         }, add = TRUE)
[13:34:39.425]     }
[13:34:39.425]     ...future.frame <- base::sys.nframe()
[13:34:39.425]     ...future.conditions <- base::list()
[13:34:39.425]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.425]     if (FALSE) {
[13:34:39.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.425]     }
[13:34:39.425]     ...future.result <- base::tryCatch({
[13:34:39.425]         base::withCallingHandlers({
[13:34:39.425]             ...future.value <- base::withVisible(base::local({
[13:34:39.425]                 ...future.makeSendCondition <- base::local({
[13:34:39.425]                   sendCondition <- NULL
[13:34:39.425]                   function(frame = 1L) {
[13:34:39.425]                     if (is.function(sendCondition)) 
[13:34:39.425]                       return(sendCondition)
[13:34:39.425]                     ns <- getNamespace("parallel")
[13:34:39.425]                     if (exists("sendData", mode = "function", 
[13:34:39.425]                       envir = ns)) {
[13:34:39.425]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.425]                         envir = ns)
[13:34:39.425]                       envir <- sys.frame(frame)
[13:34:39.425]                       master <- NULL
[13:34:39.425]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.425]                         !identical(envir, emptyenv())) {
[13:34:39.425]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.425]                           inherits = FALSE)) {
[13:34:39.425]                           master <- get("master", mode = "list", 
[13:34:39.425]                             envir = envir, inherits = FALSE)
[13:34:39.425]                           if (inherits(master, c("SOCKnode", 
[13:34:39.425]                             "SOCK0node"))) {
[13:34:39.425]                             sendCondition <<- function(cond) {
[13:34:39.425]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.425]                                 success = TRUE)
[13:34:39.425]                               parallel_sendData(master, data)
[13:34:39.425]                             }
[13:34:39.425]                             return(sendCondition)
[13:34:39.425]                           }
[13:34:39.425]                         }
[13:34:39.425]                         frame <- frame + 1L
[13:34:39.425]                         envir <- sys.frame(frame)
[13:34:39.425]                       }
[13:34:39.425]                     }
[13:34:39.425]                     sendCondition <<- function(cond) NULL
[13:34:39.425]                   }
[13:34:39.425]                 })
[13:34:39.425]                 withCallingHandlers({
[13:34:39.425]                   {
[13:34:39.425]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.425]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.425]                       ...future.globals.maxSize)) {
[13:34:39.425]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.425]                       on.exit(options(oopts), add = TRUE)
[13:34:39.425]                     }
[13:34:39.425]                     {
[13:34:39.425]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.425]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.425]                         USE.NAMES = FALSE)
[13:34:39.425]                       do.call(mapply, args = args)
[13:34:39.425]                     }
[13:34:39.425]                   }
[13:34:39.425]                 }, immediateCondition = function(cond) {
[13:34:39.425]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.425]                   sendCondition(cond)
[13:34:39.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.425]                   {
[13:34:39.425]                     inherits <- base::inherits
[13:34:39.425]                     invokeRestart <- base::invokeRestart
[13:34:39.425]                     is.null <- base::is.null
[13:34:39.425]                     muffled <- FALSE
[13:34:39.425]                     if (inherits(cond, "message")) {
[13:34:39.425]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.425]                       if (muffled) 
[13:34:39.425]                         invokeRestart("muffleMessage")
[13:34:39.425]                     }
[13:34:39.425]                     else if (inherits(cond, "warning")) {
[13:34:39.425]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.425]                       if (muffled) 
[13:34:39.425]                         invokeRestart("muffleWarning")
[13:34:39.425]                     }
[13:34:39.425]                     else if (inherits(cond, "condition")) {
[13:34:39.425]                       if (!is.null(pattern)) {
[13:34:39.425]                         computeRestarts <- base::computeRestarts
[13:34:39.425]                         grepl <- base::grepl
[13:34:39.425]                         restarts <- computeRestarts(cond)
[13:34:39.425]                         for (restart in restarts) {
[13:34:39.425]                           name <- restart$name
[13:34:39.425]                           if (is.null(name)) 
[13:34:39.425]                             next
[13:34:39.425]                           if (!grepl(pattern, name)) 
[13:34:39.425]                             next
[13:34:39.425]                           invokeRestart(restart)
[13:34:39.425]                           muffled <- TRUE
[13:34:39.425]                           break
[13:34:39.425]                         }
[13:34:39.425]                       }
[13:34:39.425]                     }
[13:34:39.425]                     invisible(muffled)
[13:34:39.425]                   }
[13:34:39.425]                   muffleCondition(cond)
[13:34:39.425]                 })
[13:34:39.425]             }))
[13:34:39.425]             future::FutureResult(value = ...future.value$value, 
[13:34:39.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.425]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.425]                     ...future.globalenv.names))
[13:34:39.425]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.425]         }, condition = base::local({
[13:34:39.425]             c <- base::c
[13:34:39.425]             inherits <- base::inherits
[13:34:39.425]             invokeRestart <- base::invokeRestart
[13:34:39.425]             length <- base::length
[13:34:39.425]             list <- base::list
[13:34:39.425]             seq.int <- base::seq.int
[13:34:39.425]             signalCondition <- base::signalCondition
[13:34:39.425]             sys.calls <- base::sys.calls
[13:34:39.425]             `[[` <- base::`[[`
[13:34:39.425]             `+` <- base::`+`
[13:34:39.425]             `<<-` <- base::`<<-`
[13:34:39.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.425]                   3L)]
[13:34:39.425]             }
[13:34:39.425]             function(cond) {
[13:34:39.425]                 is_error <- inherits(cond, "error")
[13:34:39.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.425]                   NULL)
[13:34:39.425]                 if (is_error) {
[13:34:39.425]                   sessionInformation <- function() {
[13:34:39.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.425]                       search = base::search(), system = base::Sys.info())
[13:34:39.425]                   }
[13:34:39.425]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.425]                     cond$call), session = sessionInformation(), 
[13:34:39.425]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.425]                   signalCondition(cond)
[13:34:39.425]                 }
[13:34:39.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.425]                 "immediateCondition"))) {
[13:34:39.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.425]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.425]                   if (TRUE && !signal) {
[13:34:39.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.425]                     {
[13:34:39.425]                       inherits <- base::inherits
[13:34:39.425]                       invokeRestart <- base::invokeRestart
[13:34:39.425]                       is.null <- base::is.null
[13:34:39.425]                       muffled <- FALSE
[13:34:39.425]                       if (inherits(cond, "message")) {
[13:34:39.425]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.425]                         if (muffled) 
[13:34:39.425]                           invokeRestart("muffleMessage")
[13:34:39.425]                       }
[13:34:39.425]                       else if (inherits(cond, "warning")) {
[13:34:39.425]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.425]                         if (muffled) 
[13:34:39.425]                           invokeRestart("muffleWarning")
[13:34:39.425]                       }
[13:34:39.425]                       else if (inherits(cond, "condition")) {
[13:34:39.425]                         if (!is.null(pattern)) {
[13:34:39.425]                           computeRestarts <- base::computeRestarts
[13:34:39.425]                           grepl <- base::grepl
[13:34:39.425]                           restarts <- computeRestarts(cond)
[13:34:39.425]                           for (restart in restarts) {
[13:34:39.425]                             name <- restart$name
[13:34:39.425]                             if (is.null(name)) 
[13:34:39.425]                               next
[13:34:39.425]                             if (!grepl(pattern, name)) 
[13:34:39.425]                               next
[13:34:39.425]                             invokeRestart(restart)
[13:34:39.425]                             muffled <- TRUE
[13:34:39.425]                             break
[13:34:39.425]                           }
[13:34:39.425]                         }
[13:34:39.425]                       }
[13:34:39.425]                       invisible(muffled)
[13:34:39.425]                     }
[13:34:39.425]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.425]                   }
[13:34:39.425]                 }
[13:34:39.425]                 else {
[13:34:39.425]                   if (TRUE) {
[13:34:39.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.425]                     {
[13:34:39.425]                       inherits <- base::inherits
[13:34:39.425]                       invokeRestart <- base::invokeRestart
[13:34:39.425]                       is.null <- base::is.null
[13:34:39.425]                       muffled <- FALSE
[13:34:39.425]                       if (inherits(cond, "message")) {
[13:34:39.425]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.425]                         if (muffled) 
[13:34:39.425]                           invokeRestart("muffleMessage")
[13:34:39.425]                       }
[13:34:39.425]                       else if (inherits(cond, "warning")) {
[13:34:39.425]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.425]                         if (muffled) 
[13:34:39.425]                           invokeRestart("muffleWarning")
[13:34:39.425]                       }
[13:34:39.425]                       else if (inherits(cond, "condition")) {
[13:34:39.425]                         if (!is.null(pattern)) {
[13:34:39.425]                           computeRestarts <- base::computeRestarts
[13:34:39.425]                           grepl <- base::grepl
[13:34:39.425]                           restarts <- computeRestarts(cond)
[13:34:39.425]                           for (restart in restarts) {
[13:34:39.425]                             name <- restart$name
[13:34:39.425]                             if (is.null(name)) 
[13:34:39.425]                               next
[13:34:39.425]                             if (!grepl(pattern, name)) 
[13:34:39.425]                               next
[13:34:39.425]                             invokeRestart(restart)
[13:34:39.425]                             muffled <- TRUE
[13:34:39.425]                             break
[13:34:39.425]                           }
[13:34:39.425]                         }
[13:34:39.425]                       }
[13:34:39.425]                       invisible(muffled)
[13:34:39.425]                     }
[13:34:39.425]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.425]                   }
[13:34:39.425]                 }
[13:34:39.425]             }
[13:34:39.425]         }))
[13:34:39.425]     }, error = function(ex) {
[13:34:39.425]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.425]                 ...future.rng), started = ...future.startTime, 
[13:34:39.425]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.425]             version = "1.8"), class = "FutureResult")
[13:34:39.425]     }, finally = {
[13:34:39.425]         if (!identical(...future.workdir, getwd())) 
[13:34:39.425]             setwd(...future.workdir)
[13:34:39.425]         {
[13:34:39.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.425]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.425]             }
[13:34:39.425]             base::options(...future.oldOptions)
[13:34:39.425]             if (.Platform$OS.type == "windows") {
[13:34:39.425]                 old_names <- names(...future.oldEnvVars)
[13:34:39.425]                 envs <- base::Sys.getenv()
[13:34:39.425]                 names <- names(envs)
[13:34:39.425]                 common <- intersect(names, old_names)
[13:34:39.425]                 added <- setdiff(names, old_names)
[13:34:39.425]                 removed <- setdiff(old_names, names)
[13:34:39.425]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.425]                   envs[common]]
[13:34:39.425]                 NAMES <- toupper(changed)
[13:34:39.425]                 args <- list()
[13:34:39.425]                 for (kk in seq_along(NAMES)) {
[13:34:39.425]                   name <- changed[[kk]]
[13:34:39.425]                   NAME <- NAMES[[kk]]
[13:34:39.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.425]                     next
[13:34:39.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.425]                 }
[13:34:39.425]                 NAMES <- toupper(added)
[13:34:39.425]                 for (kk in seq_along(NAMES)) {
[13:34:39.425]                   name <- added[[kk]]
[13:34:39.425]                   NAME <- NAMES[[kk]]
[13:34:39.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.425]                     next
[13:34:39.425]                   args[[name]] <- ""
[13:34:39.425]                 }
[13:34:39.425]                 NAMES <- toupper(removed)
[13:34:39.425]                 for (kk in seq_along(NAMES)) {
[13:34:39.425]                   name <- removed[[kk]]
[13:34:39.425]                   NAME <- NAMES[[kk]]
[13:34:39.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.425]                     next
[13:34:39.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.425]                 }
[13:34:39.425]                 if (length(args) > 0) 
[13:34:39.425]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.425]             }
[13:34:39.425]             else {
[13:34:39.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.425]             }
[13:34:39.425]             {
[13:34:39.425]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.425]                   0L) {
[13:34:39.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.425]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.425]                   base::options(opts)
[13:34:39.425]                 }
[13:34:39.425]                 {
[13:34:39.425]                   {
[13:34:39.425]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.425]                     NULL
[13:34:39.425]                   }
[13:34:39.425]                   options(future.plan = NULL)
[13:34:39.425]                   if (is.na(NA_character_)) 
[13:34:39.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.425]                     .init = FALSE)
[13:34:39.425]                 }
[13:34:39.425]             }
[13:34:39.425]         }
[13:34:39.425]     })
[13:34:39.425]     if (TRUE) {
[13:34:39.425]         base::sink(type = "output", split = FALSE)
[13:34:39.425]         if (TRUE) {
[13:34:39.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.425]         }
[13:34:39.425]         else {
[13:34:39.425]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.425]         }
[13:34:39.425]         base::close(...future.stdout)
[13:34:39.425]         ...future.stdout <- NULL
[13:34:39.425]     }
[13:34:39.425]     ...future.result$conditions <- ...future.conditions
[13:34:39.425]     ...future.result$finished <- base::Sys.time()
[13:34:39.425]     ...future.result
[13:34:39.425] }
[13:34:39.428] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[13:34:39.428] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[13:34:39.428] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[13:34:39.428] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:39.429] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.429] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[13:34:39.429] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[13:34:39.429] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:39.430] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.430] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:39.430] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.430] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[13:34:39.431] MultisessionFuture started
[13:34:39.431] - Launch lazy future ... done
[13:34:39.431] run() for ‘MultisessionFuture’ ... done
[13:34:39.431] Created future:
[13:34:39.432] MultisessionFuture:
[13:34:39.432] Label: ‘future_mapply-2’
[13:34:39.432] Expression:
[13:34:39.432] {
[13:34:39.432]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.432]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.432]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.432]         on.exit(options(oopts), add = TRUE)
[13:34:39.432]     }
[13:34:39.432]     {
[13:34:39.432]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.432]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.432]         do.call(mapply, args = args)
[13:34:39.432]     }
[13:34:39.432] }
[13:34:39.432] Lazy evaluation: FALSE
[13:34:39.432] Asynchronous evaluation: TRUE
[13:34:39.432] Local evaluation: TRUE
[13:34:39.432] Environment: R_GlobalEnv
[13:34:39.432] Capture standard output: TRUE
[13:34:39.432] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.432] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.432] Packages: <none>
[13:34:39.432] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.432] Resolved: FALSE
[13:34:39.432] Value: <not collected>
[13:34:39.432] Conditions captured: <none>
[13:34:39.432] Early signaling: FALSE
[13:34:39.432] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.432] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.443] Chunk #2 of 3 ... DONE
[13:34:39.443] Chunk #3 of 3 ...
[13:34:39.443]  - Finding globals in '...' for chunk #3 ...
[13:34:39.443] getGlobalsAndPackages() ...
[13:34:39.443] Searching for globals...
[13:34:39.444] 
[13:34:39.444] Searching for globals ... DONE
[13:34:39.444] - globals: [0] <none>
[13:34:39.444] getGlobalsAndPackages() ... DONE
[13:34:39.444]    + additional globals found: [n=0] 
[13:34:39.444]    + additional namespaces needed: [n=0] 
[13:34:39.444]  - Finding globals in '...' for chunk #3 ... DONE
[13:34:39.444]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:34:39.444]  - seeds: <none>
[13:34:39.445]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.445] getGlobalsAndPackages() ...
[13:34:39.445] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.445] Resolving globals: FALSE
[13:34:39.445] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:39.446] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:39.446] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.446] 
[13:34:39.446] getGlobalsAndPackages() ... DONE
[13:34:39.446] run() for ‘Future’ ...
[13:34:39.446] - state: ‘created’
[13:34:39.447] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.461] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.461] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.461]   - Field: ‘node’
[13:34:39.461]   - Field: ‘label’
[13:34:39.461]   - Field: ‘local’
[13:34:39.461]   - Field: ‘owner’
[13:34:39.461]   - Field: ‘envir’
[13:34:39.461]   - Field: ‘workers’
[13:34:39.461]   - Field: ‘packages’
[13:34:39.461]   - Field: ‘gc’
[13:34:39.462]   - Field: ‘conditions’
[13:34:39.462]   - Field: ‘persistent’
[13:34:39.462]   - Field: ‘expr’
[13:34:39.462]   - Field: ‘uuid’
[13:34:39.462]   - Field: ‘seed’
[13:34:39.462]   - Field: ‘version’
[13:34:39.462]   - Field: ‘result’
[13:34:39.462]   - Field: ‘asynchronous’
[13:34:39.462]   - Field: ‘calls’
[13:34:39.462]   - Field: ‘globals’
[13:34:39.462]   - Field: ‘stdout’
[13:34:39.463]   - Field: ‘earlySignal’
[13:34:39.463]   - Field: ‘lazy’
[13:34:39.463]   - Field: ‘state’
[13:34:39.463] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.463] - Launch lazy future ...
[13:34:39.463] Packages needed by the future expression (n = 0): <none>
[13:34:39.463] Packages needed by future strategies (n = 0): <none>
[13:34:39.464] {
[13:34:39.464]     {
[13:34:39.464]         {
[13:34:39.464]             ...future.startTime <- base::Sys.time()
[13:34:39.464]             {
[13:34:39.464]                 {
[13:34:39.464]                   {
[13:34:39.464]                     {
[13:34:39.464]                       base::local({
[13:34:39.464]                         has_future <- base::requireNamespace("future", 
[13:34:39.464]                           quietly = TRUE)
[13:34:39.464]                         if (has_future) {
[13:34:39.464]                           ns <- base::getNamespace("future")
[13:34:39.464]                           version <- ns[[".package"]][["version"]]
[13:34:39.464]                           if (is.null(version)) 
[13:34:39.464]                             version <- utils::packageVersion("future")
[13:34:39.464]                         }
[13:34:39.464]                         else {
[13:34:39.464]                           version <- NULL
[13:34:39.464]                         }
[13:34:39.464]                         if (!has_future || version < "1.8.0") {
[13:34:39.464]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.464]                             "", base::R.version$version.string), 
[13:34:39.464]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.464]                               "release", "version")], collapse = " "), 
[13:34:39.464]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.464]                             info)
[13:34:39.464]                           info <- base::paste(info, collapse = "; ")
[13:34:39.464]                           if (!has_future) {
[13:34:39.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.464]                               info)
[13:34:39.464]                           }
[13:34:39.464]                           else {
[13:34:39.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.464]                               info, version)
[13:34:39.464]                           }
[13:34:39.464]                           base::stop(msg)
[13:34:39.464]                         }
[13:34:39.464]                       })
[13:34:39.464]                     }
[13:34:39.464]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.464]                     base::options(mc.cores = 1L)
[13:34:39.464]                   }
[13:34:39.464]                   ...future.strategy.old <- future::plan("list")
[13:34:39.464]                   options(future.plan = NULL)
[13:34:39.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.464]                 }
[13:34:39.464]                 ...future.workdir <- getwd()
[13:34:39.464]             }
[13:34:39.464]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.464]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.464]         }
[13:34:39.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.464]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:34:39.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.464]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.464]             base::names(...future.oldOptions))
[13:34:39.464]     }
[13:34:39.464]     if (FALSE) {
[13:34:39.464]     }
[13:34:39.464]     else {
[13:34:39.464]         if (TRUE) {
[13:34:39.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.464]                 open = "w")
[13:34:39.464]         }
[13:34:39.464]         else {
[13:34:39.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.464]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.464]         }
[13:34:39.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.464]             base::sink(type = "output", split = FALSE)
[13:34:39.464]             base::close(...future.stdout)
[13:34:39.464]         }, add = TRUE)
[13:34:39.464]     }
[13:34:39.464]     ...future.frame <- base::sys.nframe()
[13:34:39.464]     ...future.conditions <- base::list()
[13:34:39.464]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.464]     if (FALSE) {
[13:34:39.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.464]     }
[13:34:39.464]     ...future.result <- base::tryCatch({
[13:34:39.464]         base::withCallingHandlers({
[13:34:39.464]             ...future.value <- base::withVisible(base::local({
[13:34:39.464]                 ...future.makeSendCondition <- base::local({
[13:34:39.464]                   sendCondition <- NULL
[13:34:39.464]                   function(frame = 1L) {
[13:34:39.464]                     if (is.function(sendCondition)) 
[13:34:39.464]                       return(sendCondition)
[13:34:39.464]                     ns <- getNamespace("parallel")
[13:34:39.464]                     if (exists("sendData", mode = "function", 
[13:34:39.464]                       envir = ns)) {
[13:34:39.464]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.464]                         envir = ns)
[13:34:39.464]                       envir <- sys.frame(frame)
[13:34:39.464]                       master <- NULL
[13:34:39.464]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.464]                         !identical(envir, emptyenv())) {
[13:34:39.464]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.464]                           inherits = FALSE)) {
[13:34:39.464]                           master <- get("master", mode = "list", 
[13:34:39.464]                             envir = envir, inherits = FALSE)
[13:34:39.464]                           if (inherits(master, c("SOCKnode", 
[13:34:39.464]                             "SOCK0node"))) {
[13:34:39.464]                             sendCondition <<- function(cond) {
[13:34:39.464]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.464]                                 success = TRUE)
[13:34:39.464]                               parallel_sendData(master, data)
[13:34:39.464]                             }
[13:34:39.464]                             return(sendCondition)
[13:34:39.464]                           }
[13:34:39.464]                         }
[13:34:39.464]                         frame <- frame + 1L
[13:34:39.464]                         envir <- sys.frame(frame)
[13:34:39.464]                       }
[13:34:39.464]                     }
[13:34:39.464]                     sendCondition <<- function(cond) NULL
[13:34:39.464]                   }
[13:34:39.464]                 })
[13:34:39.464]                 withCallingHandlers({
[13:34:39.464]                   {
[13:34:39.464]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.464]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.464]                       ...future.globals.maxSize)) {
[13:34:39.464]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.464]                       on.exit(options(oopts), add = TRUE)
[13:34:39.464]                     }
[13:34:39.464]                     {
[13:34:39.464]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.464]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.464]                         USE.NAMES = FALSE)
[13:34:39.464]                       do.call(mapply, args = args)
[13:34:39.464]                     }
[13:34:39.464]                   }
[13:34:39.464]                 }, immediateCondition = function(cond) {
[13:34:39.464]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.464]                   sendCondition(cond)
[13:34:39.464]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.464]                   {
[13:34:39.464]                     inherits <- base::inherits
[13:34:39.464]                     invokeRestart <- base::invokeRestart
[13:34:39.464]                     is.null <- base::is.null
[13:34:39.464]                     muffled <- FALSE
[13:34:39.464]                     if (inherits(cond, "message")) {
[13:34:39.464]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.464]                       if (muffled) 
[13:34:39.464]                         invokeRestart("muffleMessage")
[13:34:39.464]                     }
[13:34:39.464]                     else if (inherits(cond, "warning")) {
[13:34:39.464]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.464]                       if (muffled) 
[13:34:39.464]                         invokeRestart("muffleWarning")
[13:34:39.464]                     }
[13:34:39.464]                     else if (inherits(cond, "condition")) {
[13:34:39.464]                       if (!is.null(pattern)) {
[13:34:39.464]                         computeRestarts <- base::computeRestarts
[13:34:39.464]                         grepl <- base::grepl
[13:34:39.464]                         restarts <- computeRestarts(cond)
[13:34:39.464]                         for (restart in restarts) {
[13:34:39.464]                           name <- restart$name
[13:34:39.464]                           if (is.null(name)) 
[13:34:39.464]                             next
[13:34:39.464]                           if (!grepl(pattern, name)) 
[13:34:39.464]                             next
[13:34:39.464]                           invokeRestart(restart)
[13:34:39.464]                           muffled <- TRUE
[13:34:39.464]                           break
[13:34:39.464]                         }
[13:34:39.464]                       }
[13:34:39.464]                     }
[13:34:39.464]                     invisible(muffled)
[13:34:39.464]                   }
[13:34:39.464]                   muffleCondition(cond)
[13:34:39.464]                 })
[13:34:39.464]             }))
[13:34:39.464]             future::FutureResult(value = ...future.value$value, 
[13:34:39.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.464]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.464]                     ...future.globalenv.names))
[13:34:39.464]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.464]         }, condition = base::local({
[13:34:39.464]             c <- base::c
[13:34:39.464]             inherits <- base::inherits
[13:34:39.464]             invokeRestart <- base::invokeRestart
[13:34:39.464]             length <- base::length
[13:34:39.464]             list <- base::list
[13:34:39.464]             seq.int <- base::seq.int
[13:34:39.464]             signalCondition <- base::signalCondition
[13:34:39.464]             sys.calls <- base::sys.calls
[13:34:39.464]             `[[` <- base::`[[`
[13:34:39.464]             `+` <- base::`+`
[13:34:39.464]             `<<-` <- base::`<<-`
[13:34:39.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.464]                   3L)]
[13:34:39.464]             }
[13:34:39.464]             function(cond) {
[13:34:39.464]                 is_error <- inherits(cond, "error")
[13:34:39.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.464]                   NULL)
[13:34:39.464]                 if (is_error) {
[13:34:39.464]                   sessionInformation <- function() {
[13:34:39.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.464]                       search = base::search(), system = base::Sys.info())
[13:34:39.464]                   }
[13:34:39.464]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.464]                     cond$call), session = sessionInformation(), 
[13:34:39.464]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.464]                   signalCondition(cond)
[13:34:39.464]                 }
[13:34:39.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.464]                 "immediateCondition"))) {
[13:34:39.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.464]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.464]                   if (TRUE && !signal) {
[13:34:39.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.464]                     {
[13:34:39.464]                       inherits <- base::inherits
[13:34:39.464]                       invokeRestart <- base::invokeRestart
[13:34:39.464]                       is.null <- base::is.null
[13:34:39.464]                       muffled <- FALSE
[13:34:39.464]                       if (inherits(cond, "message")) {
[13:34:39.464]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.464]                         if (muffled) 
[13:34:39.464]                           invokeRestart("muffleMessage")
[13:34:39.464]                       }
[13:34:39.464]                       else if (inherits(cond, "warning")) {
[13:34:39.464]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.464]                         if (muffled) 
[13:34:39.464]                           invokeRestart("muffleWarning")
[13:34:39.464]                       }
[13:34:39.464]                       else if (inherits(cond, "condition")) {
[13:34:39.464]                         if (!is.null(pattern)) {
[13:34:39.464]                           computeRestarts <- base::computeRestarts
[13:34:39.464]                           grepl <- base::grepl
[13:34:39.464]                           restarts <- computeRestarts(cond)
[13:34:39.464]                           for (restart in restarts) {
[13:34:39.464]                             name <- restart$name
[13:34:39.464]                             if (is.null(name)) 
[13:34:39.464]                               next
[13:34:39.464]                             if (!grepl(pattern, name)) 
[13:34:39.464]                               next
[13:34:39.464]                             invokeRestart(restart)
[13:34:39.464]                             muffled <- TRUE
[13:34:39.464]                             break
[13:34:39.464]                           }
[13:34:39.464]                         }
[13:34:39.464]                       }
[13:34:39.464]                       invisible(muffled)
[13:34:39.464]                     }
[13:34:39.464]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.464]                   }
[13:34:39.464]                 }
[13:34:39.464]                 else {
[13:34:39.464]                   if (TRUE) {
[13:34:39.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.464]                     {
[13:34:39.464]                       inherits <- base::inherits
[13:34:39.464]                       invokeRestart <- base::invokeRestart
[13:34:39.464]                       is.null <- base::is.null
[13:34:39.464]                       muffled <- FALSE
[13:34:39.464]                       if (inherits(cond, "message")) {
[13:34:39.464]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.464]                         if (muffled) 
[13:34:39.464]                           invokeRestart("muffleMessage")
[13:34:39.464]                       }
[13:34:39.464]                       else if (inherits(cond, "warning")) {
[13:34:39.464]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.464]                         if (muffled) 
[13:34:39.464]                           invokeRestart("muffleWarning")
[13:34:39.464]                       }
[13:34:39.464]                       else if (inherits(cond, "condition")) {
[13:34:39.464]                         if (!is.null(pattern)) {
[13:34:39.464]                           computeRestarts <- base::computeRestarts
[13:34:39.464]                           grepl <- base::grepl
[13:34:39.464]                           restarts <- computeRestarts(cond)
[13:34:39.464]                           for (restart in restarts) {
[13:34:39.464]                             name <- restart$name
[13:34:39.464]                             if (is.null(name)) 
[13:34:39.464]                               next
[13:34:39.464]                             if (!grepl(pattern, name)) 
[13:34:39.464]                               next
[13:34:39.464]                             invokeRestart(restart)
[13:34:39.464]                             muffled <- TRUE
[13:34:39.464]                             break
[13:34:39.464]                           }
[13:34:39.464]                         }
[13:34:39.464]                       }
[13:34:39.464]                       invisible(muffled)
[13:34:39.464]                     }
[13:34:39.464]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.464]                   }
[13:34:39.464]                 }
[13:34:39.464]             }
[13:34:39.464]         }))
[13:34:39.464]     }, error = function(ex) {
[13:34:39.464]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.464]                 ...future.rng), started = ...future.startTime, 
[13:34:39.464]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.464]             version = "1.8"), class = "FutureResult")
[13:34:39.464]     }, finally = {
[13:34:39.464]         if (!identical(...future.workdir, getwd())) 
[13:34:39.464]             setwd(...future.workdir)
[13:34:39.464]         {
[13:34:39.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.464]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.464]             }
[13:34:39.464]             base::options(...future.oldOptions)
[13:34:39.464]             if (.Platform$OS.type == "windows") {
[13:34:39.464]                 old_names <- names(...future.oldEnvVars)
[13:34:39.464]                 envs <- base::Sys.getenv()
[13:34:39.464]                 names <- names(envs)
[13:34:39.464]                 common <- intersect(names, old_names)
[13:34:39.464]                 added <- setdiff(names, old_names)
[13:34:39.464]                 removed <- setdiff(old_names, names)
[13:34:39.464]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.464]                   envs[common]]
[13:34:39.464]                 NAMES <- toupper(changed)
[13:34:39.464]                 args <- list()
[13:34:39.464]                 for (kk in seq_along(NAMES)) {
[13:34:39.464]                   name <- changed[[kk]]
[13:34:39.464]                   NAME <- NAMES[[kk]]
[13:34:39.464]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.464]                     next
[13:34:39.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.464]                 }
[13:34:39.464]                 NAMES <- toupper(added)
[13:34:39.464]                 for (kk in seq_along(NAMES)) {
[13:34:39.464]                   name <- added[[kk]]
[13:34:39.464]                   NAME <- NAMES[[kk]]
[13:34:39.464]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.464]                     next
[13:34:39.464]                   args[[name]] <- ""
[13:34:39.464]                 }
[13:34:39.464]                 NAMES <- toupper(removed)
[13:34:39.464]                 for (kk in seq_along(NAMES)) {
[13:34:39.464]                   name <- removed[[kk]]
[13:34:39.464]                   NAME <- NAMES[[kk]]
[13:34:39.464]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.464]                     next
[13:34:39.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.464]                 }
[13:34:39.464]                 if (length(args) > 0) 
[13:34:39.464]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.464]             }
[13:34:39.464]             else {
[13:34:39.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.464]             }
[13:34:39.464]             {
[13:34:39.464]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.464]                   0L) {
[13:34:39.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.464]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.464]                   base::options(opts)
[13:34:39.464]                 }
[13:34:39.464]                 {
[13:34:39.464]                   {
[13:34:39.464]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.464]                     NULL
[13:34:39.464]                   }
[13:34:39.464]                   options(future.plan = NULL)
[13:34:39.464]                   if (is.na(NA_character_)) 
[13:34:39.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.464]                     .init = FALSE)
[13:34:39.464]                 }
[13:34:39.464]             }
[13:34:39.464]         }
[13:34:39.464]     })
[13:34:39.464]     if (TRUE) {
[13:34:39.464]         base::sink(type = "output", split = FALSE)
[13:34:39.464]         if (TRUE) {
[13:34:39.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.464]         }
[13:34:39.464]         else {
[13:34:39.464]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.464]         }
[13:34:39.464]         base::close(...future.stdout)
[13:34:39.464]         ...future.stdout <- NULL
[13:34:39.464]     }
[13:34:39.464]     ...future.result$conditions <- ...future.conditions
[13:34:39.464]     ...future.result$finished <- base::Sys.time()
[13:34:39.464]     ...future.result
[13:34:39.464] }
[13:34:39.466] Poll #1 (0): usedNodes() = 2, workers = 2
[13:34:39.476] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.476] - Validating connection of MultisessionFuture
[13:34:39.477] - received message: FutureResult
[13:34:39.477] - Received FutureResult
[13:34:39.477] - Erased future from FutureRegistry
[13:34:39.477] result() for ClusterFuture ...
[13:34:39.477] - result already collected: FutureResult
[13:34:39.477] result() for ClusterFuture ... done
[13:34:39.477] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.477] result() for ClusterFuture ...
[13:34:39.477] - result already collected: FutureResult
[13:34:39.478] result() for ClusterFuture ... done
[13:34:39.478] result() for ClusterFuture ...
[13:34:39.478] - result already collected: FutureResult
[13:34:39.478] result() for ClusterFuture ... done
[13:34:39.478] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[13:34:39.479] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[13:34:39.479] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[13:34:39.479] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:39.480] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.480] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[13:34:39.480] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[13:34:39.480] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:39.481] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.481] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:39.481] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.481] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[13:34:39.482] MultisessionFuture started
[13:34:39.482] - Launch lazy future ... done
[13:34:39.482] run() for ‘MultisessionFuture’ ... done
[13:34:39.482] Created future:
[13:34:39.482] MultisessionFuture:
[13:34:39.482] Label: ‘future_mapply-3’
[13:34:39.482] Expression:
[13:34:39.482] {
[13:34:39.482]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.482]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.482]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.482]         on.exit(options(oopts), add = TRUE)
[13:34:39.482]     }
[13:34:39.482]     {
[13:34:39.482]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.482]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.482]         do.call(mapply, args = args)
[13:34:39.482]     }
[13:34:39.482] }
[13:34:39.482] Lazy evaluation: FALSE
[13:34:39.482] Asynchronous evaluation: TRUE
[13:34:39.482] Local evaluation: TRUE
[13:34:39.482] Environment: R_GlobalEnv
[13:34:39.482] Capture standard output: TRUE
[13:34:39.482] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.482] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.482] Packages: <none>
[13:34:39.482] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.482] Resolved: FALSE
[13:34:39.482] Value: <not collected>
[13:34:39.482] Conditions captured: <none>
[13:34:39.482] Early signaling: FALSE
[13:34:39.482] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.482] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.494] Chunk #3 of 3 ... DONE
[13:34:39.494] Launching 3 futures (chunks) ... DONE
[13:34:39.494] Resolving 3 futures (chunks) ...
[13:34:39.494] resolve() on list ...
[13:34:39.494]  recursive: 0
[13:34:39.494]  length: 3
[13:34:39.494] 
[13:34:39.495] Future #1
[13:34:39.495] result() for ClusterFuture ...
[13:34:39.495] - result already collected: FutureResult
[13:34:39.495] result() for ClusterFuture ... done
[13:34:39.495] result() for ClusterFuture ...
[13:34:39.495] - result already collected: FutureResult
[13:34:39.495] result() for ClusterFuture ... done
[13:34:39.495] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:39.495] - nx: 3
[13:34:39.495] - relay: TRUE
[13:34:39.495] - stdout: TRUE
[13:34:39.496] - signal: TRUE
[13:34:39.496] - resignal: FALSE
[13:34:39.496] - force: TRUE
[13:34:39.496] - relayed: [n=3] FALSE, FALSE, FALSE
[13:34:39.496] - queued futures: [n=3] FALSE, FALSE, FALSE
[13:34:39.496]  - until=1
[13:34:39.496]  - relaying element #1
[13:34:39.496] result() for ClusterFuture ...
[13:34:39.496] - result already collected: FutureResult
[13:34:39.496] result() for ClusterFuture ... done
[13:34:39.496] result() for ClusterFuture ...
[13:34:39.496] - result already collected: FutureResult
[13:34:39.497] result() for ClusterFuture ... done
[13:34:39.497] result() for ClusterFuture ...
[13:34:39.497] - result already collected: FutureResult
[13:34:39.497] result() for ClusterFuture ... done
[13:34:39.497] result() for ClusterFuture ...
[13:34:39.497] - result already collected: FutureResult
[13:34:39.497] result() for ClusterFuture ... done
[13:34:39.497] - relayed: [n=3] TRUE, FALSE, FALSE
[13:34:39.497] - queued futures: [n=3] TRUE, FALSE, FALSE
[13:34:39.497] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:39.497]  length: 2 (resolved future 1)
[13:34:39.498] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.498] - Validating connection of MultisessionFuture
[13:34:39.498] - received message: FutureResult
[13:34:39.498] - Received FutureResult
[13:34:39.498] - Erased future from FutureRegistry
[13:34:39.498] result() for ClusterFuture ...
[13:34:39.499] - result already collected: FutureResult
[13:34:39.499] result() for ClusterFuture ... done
[13:34:39.499] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.499] Future #2
[13:34:39.499] result() for ClusterFuture ...
[13:34:39.499] - result already collected: FutureResult
[13:34:39.499] result() for ClusterFuture ... done
[13:34:39.499] result() for ClusterFuture ...
[13:34:39.499] - result already collected: FutureResult
[13:34:39.499] result() for ClusterFuture ... done
[13:34:39.499] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:39.500] - nx: 3
[13:34:39.500] - relay: TRUE
[13:34:39.500] - stdout: TRUE
[13:34:39.500] - signal: TRUE
[13:34:39.500] - resignal: FALSE
[13:34:39.500] - force: TRUE
[13:34:39.500] - relayed: [n=3] TRUE, FALSE, FALSE
[13:34:39.500] - queued futures: [n=3] TRUE, FALSE, FALSE
[13:34:39.500]  - until=2
[13:34:39.500]  - relaying element #2
[13:34:39.500] result() for ClusterFuture ...
[13:34:39.500] - result already collected: FutureResult
[13:34:39.501] result() for ClusterFuture ... done
[13:34:39.501] result() for ClusterFuture ...
[13:34:39.501] - result already collected: FutureResult
[13:34:39.501] result() for ClusterFuture ... done
[13:34:39.501] result() for ClusterFuture ...
[13:34:39.501] - result already collected: FutureResult
[13:34:39.501] result() for ClusterFuture ... done
[13:34:39.501] result() for ClusterFuture ...
[13:34:39.501] - result already collected: FutureResult
[13:34:39.501] result() for ClusterFuture ... done
[13:34:39.501] - relayed: [n=3] TRUE, TRUE, FALSE
[13:34:39.502] - queued futures: [n=3] TRUE, TRUE, FALSE
[13:34:39.502] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:39.502]  length: 1 (resolved future 2)
[13:34:39.524] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.524] - Validating connection of MultisessionFuture
[13:34:39.524] - received message: FutureResult
[13:34:39.524] - Received FutureResult
[13:34:39.524] - Erased future from FutureRegistry
[13:34:39.524] result() for ClusterFuture ...
[13:34:39.525] - result already collected: FutureResult
[13:34:39.525] result() for ClusterFuture ... done
[13:34:39.525] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.525] Future #3
[13:34:39.525] result() for ClusterFuture ...
[13:34:39.525] - result already collected: FutureResult
[13:34:39.525] result() for ClusterFuture ... done
[13:34:39.525] result() for ClusterFuture ...
[13:34:39.525] - result already collected: FutureResult
[13:34:39.525] result() for ClusterFuture ... done
[13:34:39.525] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:34:39.526] - nx: 3
[13:34:39.526] - relay: TRUE
[13:34:39.526] - stdout: TRUE
[13:34:39.526] - signal: TRUE
[13:34:39.526] - resignal: FALSE
[13:34:39.526] - force: TRUE
[13:34:39.526] - relayed: [n=3] TRUE, TRUE, FALSE
[13:34:39.526] - queued futures: [n=3] TRUE, TRUE, FALSE
[13:34:39.526]  - until=3
[13:34:39.526]  - relaying element #3
[13:34:39.526] result() for ClusterFuture ...
[13:34:39.526] - result already collected: FutureResult
[13:34:39.527] result() for ClusterFuture ... done
[13:34:39.527] result() for ClusterFuture ...
[13:34:39.527] - result already collected: FutureResult
[13:34:39.527] result() for ClusterFuture ... done
[13:34:39.527] result() for ClusterFuture ...
[13:34:39.527] - result already collected: FutureResult
[13:34:39.527] result() for ClusterFuture ... done
[13:34:39.527] result() for ClusterFuture ...
[13:34:39.527] - result already collected: FutureResult
[13:34:39.527] result() for ClusterFuture ... done
[13:34:39.527] - relayed: [n=3] TRUE, TRUE, TRUE
[13:34:39.528] - queued futures: [n=3] TRUE, TRUE, TRUE
[13:34:39.528] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:34:39.528]  length: 0 (resolved future 3)
[13:34:39.528] Relaying remaining futures
[13:34:39.528] signalConditionsASAP(NULL, pos=0) ...
[13:34:39.528] - nx: 3
[13:34:39.528] - relay: TRUE
[13:34:39.528] - stdout: TRUE
[13:34:39.528] - signal: TRUE
[13:34:39.528] - resignal: FALSE
[13:34:39.528] - force: TRUE
[13:34:39.528] - relayed: [n=3] TRUE, TRUE, TRUE
[13:34:39.529] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[13:34:39.529] - relayed: [n=3] TRUE, TRUE, TRUE
[13:34:39.529] - queued futures: [n=3] TRUE, TRUE, TRUE
[13:34:39.529] signalConditionsASAP(NULL, pos=0) ... done
[13:34:39.529] resolve() on list ... DONE
[13:34:39.529] result() for ClusterFuture ...
[13:34:39.529] - result already collected: FutureResult
[13:34:39.529] result() for ClusterFuture ... done
[13:34:39.529] result() for ClusterFuture ...
[13:34:39.529] - result already collected: FutureResult
[13:34:39.529] result() for ClusterFuture ... done
[13:34:39.530] result() for ClusterFuture ...
[13:34:39.530] - result already collected: FutureResult
[13:34:39.530] result() for ClusterFuture ... done
[13:34:39.530] result() for ClusterFuture ...
[13:34:39.530] - result already collected: FutureResult
[13:34:39.530] result() for ClusterFuture ... done
[13:34:39.530] result() for ClusterFuture ...
[13:34:39.530] - result already collected: FutureResult
[13:34:39.530] result() for ClusterFuture ... done
[13:34:39.530] result() for ClusterFuture ...
[13:34:39.531] - result already collected: FutureResult
[13:34:39.531] result() for ClusterFuture ... done
[13:34:39.531]  - Number of value chunks collected: 3
[13:34:39.531] Resolving 3 futures (chunks) ... DONE
[13:34:39.531] Reducing values from 3 chunks ...
[13:34:39.531]  - Number of values collected after concatenation: 5
[13:34:39.531]  - Number of values expected: 5
[13:34:39.531] Reverse index remapping (attribute 'ordering'): [n = 5] 1, 2, 3, 4, 5
[13:34:39.531] Reducing values from 3 chunks ... DONE
[13:34:39.531] future_mapply() ... DONE
[13:34:39.532] future_mapply() ...
[13:34:39.535] Number of chunks: 2
[13:34:39.535] getGlobalsAndPackagesXApply() ...
[13:34:39.535]  - future.globals: TRUE
[13:34:39.535] getGlobalsAndPackages() ...
[13:34:39.536] Searching for globals...
[13:34:39.537] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:39.537] Searching for globals ... DONE
[13:34:39.537] Resolving globals: FALSE
[13:34:39.537] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:39.538] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:39.538] - globals: [1] ‘FUN’
[13:34:39.538] 
[13:34:39.538] getGlobalsAndPackages() ... DONE
[13:34:39.538]  - globals found/used: [n=1] ‘FUN’
[13:34:39.538]  - needed namespaces: [n=0] 
[13:34:39.538] Finding globals ... DONE
[13:34:39.539] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:39.539] List of 2
[13:34:39.539]  $ ...future.FUN:function (C, k)  
[13:34:39.539]  $ MoreArgs     : list()
[13:34:39.539]  - attr(*, "where")=List of 2
[13:34:39.539]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:39.539]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:39.539]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:39.539]  - attr(*, "resolved")= logi FALSE
[13:34:39.539]  - attr(*, "total_size")= num NA
[13:34:39.541] Packages to be attached in all futures: [n=0] 
[13:34:39.541] getGlobalsAndPackagesXApply() ... DONE
[13:34:39.541] Number of futures (= number of chunks): 2
[13:34:39.541] Launching 2 futures (chunks) ...
[13:34:39.542] Chunk #1 of 2 ...
[13:34:39.542]  - Finding globals in '...' for chunk #1 ...
[13:34:39.542] getGlobalsAndPackages() ...
[13:34:39.542] Searching for globals...
[13:34:39.542] 
[13:34:39.542] Searching for globals ... DONE
[13:34:39.542] - globals: [0] <none>
[13:34:39.542] getGlobalsAndPackages() ... DONE
[13:34:39.543]    + additional globals found: [n=0] 
[13:34:39.543]    + additional namespaces needed: [n=0] 
[13:34:39.543]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:39.543]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:39.543]  - seeds: <none>
[13:34:39.543]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.543] getGlobalsAndPackages() ...
[13:34:39.543] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.543] Resolving globals: FALSE
[13:34:39.544] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:39.544] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:39.544] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.544] 
[13:34:39.545] getGlobalsAndPackages() ... DONE
[13:34:39.545] run() for ‘Future’ ...
[13:34:39.545] - state: ‘created’
[13:34:39.545] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.558] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.559]   - Field: ‘node’
[13:34:39.559]   - Field: ‘label’
[13:34:39.559]   - Field: ‘local’
[13:34:39.559]   - Field: ‘owner’
[13:34:39.559]   - Field: ‘envir’
[13:34:39.559]   - Field: ‘workers’
[13:34:39.559]   - Field: ‘packages’
[13:34:39.559]   - Field: ‘gc’
[13:34:39.559]   - Field: ‘conditions’
[13:34:39.560]   - Field: ‘persistent’
[13:34:39.560]   - Field: ‘expr’
[13:34:39.560]   - Field: ‘uuid’
[13:34:39.560]   - Field: ‘seed’
[13:34:39.560]   - Field: ‘version’
[13:34:39.560]   - Field: ‘result’
[13:34:39.560]   - Field: ‘asynchronous’
[13:34:39.560]   - Field: ‘calls’
[13:34:39.560]   - Field: ‘globals’
[13:34:39.560]   - Field: ‘stdout’
[13:34:39.560]   - Field: ‘earlySignal’
[13:34:39.560]   - Field: ‘lazy’
[13:34:39.561]   - Field: ‘state’
[13:34:39.561] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.561] - Launch lazy future ...
[13:34:39.561] Packages needed by the future expression (n = 0): <none>
[13:34:39.561] Packages needed by future strategies (n = 0): <none>
[13:34:39.562] {
[13:34:39.562]     {
[13:34:39.562]         {
[13:34:39.562]             ...future.startTime <- base::Sys.time()
[13:34:39.562]             {
[13:34:39.562]                 {
[13:34:39.562]                   {
[13:34:39.562]                     {
[13:34:39.562]                       base::local({
[13:34:39.562]                         has_future <- base::requireNamespace("future", 
[13:34:39.562]                           quietly = TRUE)
[13:34:39.562]                         if (has_future) {
[13:34:39.562]                           ns <- base::getNamespace("future")
[13:34:39.562]                           version <- ns[[".package"]][["version"]]
[13:34:39.562]                           if (is.null(version)) 
[13:34:39.562]                             version <- utils::packageVersion("future")
[13:34:39.562]                         }
[13:34:39.562]                         else {
[13:34:39.562]                           version <- NULL
[13:34:39.562]                         }
[13:34:39.562]                         if (!has_future || version < "1.8.0") {
[13:34:39.562]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.562]                             "", base::R.version$version.string), 
[13:34:39.562]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.562]                               "release", "version")], collapse = " "), 
[13:34:39.562]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.562]                             info)
[13:34:39.562]                           info <- base::paste(info, collapse = "; ")
[13:34:39.562]                           if (!has_future) {
[13:34:39.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.562]                               info)
[13:34:39.562]                           }
[13:34:39.562]                           else {
[13:34:39.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.562]                               info, version)
[13:34:39.562]                           }
[13:34:39.562]                           base::stop(msg)
[13:34:39.562]                         }
[13:34:39.562]                       })
[13:34:39.562]                     }
[13:34:39.562]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.562]                     base::options(mc.cores = 1L)
[13:34:39.562]                   }
[13:34:39.562]                   ...future.strategy.old <- future::plan("list")
[13:34:39.562]                   options(future.plan = NULL)
[13:34:39.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.562]                 }
[13:34:39.562]                 ...future.workdir <- getwd()
[13:34:39.562]             }
[13:34:39.562]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.562]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.562]         }
[13:34:39.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.562]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:39.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.562]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.562]             base::names(...future.oldOptions))
[13:34:39.562]     }
[13:34:39.562]     if (FALSE) {
[13:34:39.562]     }
[13:34:39.562]     else {
[13:34:39.562]         if (TRUE) {
[13:34:39.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.562]                 open = "w")
[13:34:39.562]         }
[13:34:39.562]         else {
[13:34:39.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.562]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.562]         }
[13:34:39.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.562]             base::sink(type = "output", split = FALSE)
[13:34:39.562]             base::close(...future.stdout)
[13:34:39.562]         }, add = TRUE)
[13:34:39.562]     }
[13:34:39.562]     ...future.frame <- base::sys.nframe()
[13:34:39.562]     ...future.conditions <- base::list()
[13:34:39.562]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.562]     if (FALSE) {
[13:34:39.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.562]     }
[13:34:39.562]     ...future.result <- base::tryCatch({
[13:34:39.562]         base::withCallingHandlers({
[13:34:39.562]             ...future.value <- base::withVisible(base::local({
[13:34:39.562]                 ...future.makeSendCondition <- base::local({
[13:34:39.562]                   sendCondition <- NULL
[13:34:39.562]                   function(frame = 1L) {
[13:34:39.562]                     if (is.function(sendCondition)) 
[13:34:39.562]                       return(sendCondition)
[13:34:39.562]                     ns <- getNamespace("parallel")
[13:34:39.562]                     if (exists("sendData", mode = "function", 
[13:34:39.562]                       envir = ns)) {
[13:34:39.562]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.562]                         envir = ns)
[13:34:39.562]                       envir <- sys.frame(frame)
[13:34:39.562]                       master <- NULL
[13:34:39.562]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.562]                         !identical(envir, emptyenv())) {
[13:34:39.562]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.562]                           inherits = FALSE)) {
[13:34:39.562]                           master <- get("master", mode = "list", 
[13:34:39.562]                             envir = envir, inherits = FALSE)
[13:34:39.562]                           if (inherits(master, c("SOCKnode", 
[13:34:39.562]                             "SOCK0node"))) {
[13:34:39.562]                             sendCondition <<- function(cond) {
[13:34:39.562]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.562]                                 success = TRUE)
[13:34:39.562]                               parallel_sendData(master, data)
[13:34:39.562]                             }
[13:34:39.562]                             return(sendCondition)
[13:34:39.562]                           }
[13:34:39.562]                         }
[13:34:39.562]                         frame <- frame + 1L
[13:34:39.562]                         envir <- sys.frame(frame)
[13:34:39.562]                       }
[13:34:39.562]                     }
[13:34:39.562]                     sendCondition <<- function(cond) NULL
[13:34:39.562]                   }
[13:34:39.562]                 })
[13:34:39.562]                 withCallingHandlers({
[13:34:39.562]                   {
[13:34:39.562]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.562]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.562]                       ...future.globals.maxSize)) {
[13:34:39.562]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.562]                       on.exit(options(oopts), add = TRUE)
[13:34:39.562]                     }
[13:34:39.562]                     {
[13:34:39.562]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.562]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.562]                         USE.NAMES = FALSE)
[13:34:39.562]                       do.call(mapply, args = args)
[13:34:39.562]                     }
[13:34:39.562]                   }
[13:34:39.562]                 }, immediateCondition = function(cond) {
[13:34:39.562]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.562]                   sendCondition(cond)
[13:34:39.562]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.562]                   {
[13:34:39.562]                     inherits <- base::inherits
[13:34:39.562]                     invokeRestart <- base::invokeRestart
[13:34:39.562]                     is.null <- base::is.null
[13:34:39.562]                     muffled <- FALSE
[13:34:39.562]                     if (inherits(cond, "message")) {
[13:34:39.562]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.562]                       if (muffled) 
[13:34:39.562]                         invokeRestart("muffleMessage")
[13:34:39.562]                     }
[13:34:39.562]                     else if (inherits(cond, "warning")) {
[13:34:39.562]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.562]                       if (muffled) 
[13:34:39.562]                         invokeRestart("muffleWarning")
[13:34:39.562]                     }
[13:34:39.562]                     else if (inherits(cond, "condition")) {
[13:34:39.562]                       if (!is.null(pattern)) {
[13:34:39.562]                         computeRestarts <- base::computeRestarts
[13:34:39.562]                         grepl <- base::grepl
[13:34:39.562]                         restarts <- computeRestarts(cond)
[13:34:39.562]                         for (restart in restarts) {
[13:34:39.562]                           name <- restart$name
[13:34:39.562]                           if (is.null(name)) 
[13:34:39.562]                             next
[13:34:39.562]                           if (!grepl(pattern, name)) 
[13:34:39.562]                             next
[13:34:39.562]                           invokeRestart(restart)
[13:34:39.562]                           muffled <- TRUE
[13:34:39.562]                           break
[13:34:39.562]                         }
[13:34:39.562]                       }
[13:34:39.562]                     }
[13:34:39.562]                     invisible(muffled)
[13:34:39.562]                   }
[13:34:39.562]                   muffleCondition(cond)
[13:34:39.562]                 })
[13:34:39.562]             }))
[13:34:39.562]             future::FutureResult(value = ...future.value$value, 
[13:34:39.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.562]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.562]                     ...future.globalenv.names))
[13:34:39.562]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.562]         }, condition = base::local({
[13:34:39.562]             c <- base::c
[13:34:39.562]             inherits <- base::inherits
[13:34:39.562]             invokeRestart <- base::invokeRestart
[13:34:39.562]             length <- base::length
[13:34:39.562]             list <- base::list
[13:34:39.562]             seq.int <- base::seq.int
[13:34:39.562]             signalCondition <- base::signalCondition
[13:34:39.562]             sys.calls <- base::sys.calls
[13:34:39.562]             `[[` <- base::`[[`
[13:34:39.562]             `+` <- base::`+`
[13:34:39.562]             `<<-` <- base::`<<-`
[13:34:39.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.562]                   3L)]
[13:34:39.562]             }
[13:34:39.562]             function(cond) {
[13:34:39.562]                 is_error <- inherits(cond, "error")
[13:34:39.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.562]                   NULL)
[13:34:39.562]                 if (is_error) {
[13:34:39.562]                   sessionInformation <- function() {
[13:34:39.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.562]                       search = base::search(), system = base::Sys.info())
[13:34:39.562]                   }
[13:34:39.562]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.562]                     cond$call), session = sessionInformation(), 
[13:34:39.562]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.562]                   signalCondition(cond)
[13:34:39.562]                 }
[13:34:39.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.562]                 "immediateCondition"))) {
[13:34:39.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.562]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.562]                   if (TRUE && !signal) {
[13:34:39.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.562]                     {
[13:34:39.562]                       inherits <- base::inherits
[13:34:39.562]                       invokeRestart <- base::invokeRestart
[13:34:39.562]                       is.null <- base::is.null
[13:34:39.562]                       muffled <- FALSE
[13:34:39.562]                       if (inherits(cond, "message")) {
[13:34:39.562]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.562]                         if (muffled) 
[13:34:39.562]                           invokeRestart("muffleMessage")
[13:34:39.562]                       }
[13:34:39.562]                       else if (inherits(cond, "warning")) {
[13:34:39.562]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.562]                         if (muffled) 
[13:34:39.562]                           invokeRestart("muffleWarning")
[13:34:39.562]                       }
[13:34:39.562]                       else if (inherits(cond, "condition")) {
[13:34:39.562]                         if (!is.null(pattern)) {
[13:34:39.562]                           computeRestarts <- base::computeRestarts
[13:34:39.562]                           grepl <- base::grepl
[13:34:39.562]                           restarts <- computeRestarts(cond)
[13:34:39.562]                           for (restart in restarts) {
[13:34:39.562]                             name <- restart$name
[13:34:39.562]                             if (is.null(name)) 
[13:34:39.562]                               next
[13:34:39.562]                             if (!grepl(pattern, name)) 
[13:34:39.562]                               next
[13:34:39.562]                             invokeRestart(restart)
[13:34:39.562]                             muffled <- TRUE
[13:34:39.562]                             break
[13:34:39.562]                           }
[13:34:39.562]                         }
[13:34:39.562]                       }
[13:34:39.562]                       invisible(muffled)
[13:34:39.562]                     }
[13:34:39.562]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.562]                   }
[13:34:39.562]                 }
[13:34:39.562]                 else {
[13:34:39.562]                   if (TRUE) {
[13:34:39.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.562]                     {
[13:34:39.562]                       inherits <- base::inherits
[13:34:39.562]                       invokeRestart <- base::invokeRestart
[13:34:39.562]                       is.null <- base::is.null
[13:34:39.562]                       muffled <- FALSE
[13:34:39.562]                       if (inherits(cond, "message")) {
[13:34:39.562]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.562]                         if (muffled) 
[13:34:39.562]                           invokeRestart("muffleMessage")
[13:34:39.562]                       }
[13:34:39.562]                       else if (inherits(cond, "warning")) {
[13:34:39.562]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.562]                         if (muffled) 
[13:34:39.562]                           invokeRestart("muffleWarning")
[13:34:39.562]                       }
[13:34:39.562]                       else if (inherits(cond, "condition")) {
[13:34:39.562]                         if (!is.null(pattern)) {
[13:34:39.562]                           computeRestarts <- base::computeRestarts
[13:34:39.562]                           grepl <- base::grepl
[13:34:39.562]                           restarts <- computeRestarts(cond)
[13:34:39.562]                           for (restart in restarts) {
[13:34:39.562]                             name <- restart$name
[13:34:39.562]                             if (is.null(name)) 
[13:34:39.562]                               next
[13:34:39.562]                             if (!grepl(pattern, name)) 
[13:34:39.562]                               next
[13:34:39.562]                             invokeRestart(restart)
[13:34:39.562]                             muffled <- TRUE
[13:34:39.562]                             break
[13:34:39.562]                           }
[13:34:39.562]                         }
[13:34:39.562]                       }
[13:34:39.562]                       invisible(muffled)
[13:34:39.562]                     }
[13:34:39.562]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.562]                   }
[13:34:39.562]                 }
[13:34:39.562]             }
[13:34:39.562]         }))
[13:34:39.562]     }, error = function(ex) {
[13:34:39.562]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.562]                 ...future.rng), started = ...future.startTime, 
[13:34:39.562]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.562]             version = "1.8"), class = "FutureResult")
[13:34:39.562]     }, finally = {
[13:34:39.562]         if (!identical(...future.workdir, getwd())) 
[13:34:39.562]             setwd(...future.workdir)
[13:34:39.562]         {
[13:34:39.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.562]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.562]             }
[13:34:39.562]             base::options(...future.oldOptions)
[13:34:39.562]             if (.Platform$OS.type == "windows") {
[13:34:39.562]                 old_names <- names(...future.oldEnvVars)
[13:34:39.562]                 envs <- base::Sys.getenv()
[13:34:39.562]                 names <- names(envs)
[13:34:39.562]                 common <- intersect(names, old_names)
[13:34:39.562]                 added <- setdiff(names, old_names)
[13:34:39.562]                 removed <- setdiff(old_names, names)
[13:34:39.562]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.562]                   envs[common]]
[13:34:39.562]                 NAMES <- toupper(changed)
[13:34:39.562]                 args <- list()
[13:34:39.562]                 for (kk in seq_along(NAMES)) {
[13:34:39.562]                   name <- changed[[kk]]
[13:34:39.562]                   NAME <- NAMES[[kk]]
[13:34:39.562]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.562]                     next
[13:34:39.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.562]                 }
[13:34:39.562]                 NAMES <- toupper(added)
[13:34:39.562]                 for (kk in seq_along(NAMES)) {
[13:34:39.562]                   name <- added[[kk]]
[13:34:39.562]                   NAME <- NAMES[[kk]]
[13:34:39.562]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.562]                     next
[13:34:39.562]                   args[[name]] <- ""
[13:34:39.562]                 }
[13:34:39.562]                 NAMES <- toupper(removed)
[13:34:39.562]                 for (kk in seq_along(NAMES)) {
[13:34:39.562]                   name <- removed[[kk]]
[13:34:39.562]                   NAME <- NAMES[[kk]]
[13:34:39.562]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.562]                     next
[13:34:39.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.562]                 }
[13:34:39.562]                 if (length(args) > 0) 
[13:34:39.562]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.562]             }
[13:34:39.562]             else {
[13:34:39.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.562]             }
[13:34:39.562]             {
[13:34:39.562]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.562]                   0L) {
[13:34:39.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.562]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.562]                   base::options(opts)
[13:34:39.562]                 }
[13:34:39.562]                 {
[13:34:39.562]                   {
[13:34:39.562]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.562]                     NULL
[13:34:39.562]                   }
[13:34:39.562]                   options(future.plan = NULL)
[13:34:39.562]                   if (is.na(NA_character_)) 
[13:34:39.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.562]                     .init = FALSE)
[13:34:39.562]                 }
[13:34:39.562]             }
[13:34:39.562]         }
[13:34:39.562]     })
[13:34:39.562]     if (TRUE) {
[13:34:39.562]         base::sink(type = "output", split = FALSE)
[13:34:39.562]         if (TRUE) {
[13:34:39.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.562]         }
[13:34:39.562]         else {
[13:34:39.562]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.562]         }
[13:34:39.562]         base::close(...future.stdout)
[13:34:39.562]         ...future.stdout <- NULL
[13:34:39.562]     }
[13:34:39.562]     ...future.result$conditions <- ...future.conditions
[13:34:39.562]     ...future.result$finished <- base::Sys.time()
[13:34:39.562]     ...future.result
[13:34:39.562] }
[13:34:39.564] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[13:34:39.564] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[13:34:39.565] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[13:34:39.565] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:39.565] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.565] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[13:34:39.566] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[13:34:39.566] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:39.566] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.566] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:39.567] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.567] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[13:34:39.567] MultisessionFuture started
[13:34:39.567] - Launch lazy future ... done
[13:34:39.568] run() for ‘MultisessionFuture’ ... done
[13:34:39.568] Created future:
[13:34:39.568] MultisessionFuture:
[13:34:39.568] Label: ‘future_.mapply-1’
[13:34:39.568] Expression:
[13:34:39.568] {
[13:34:39.568]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.568]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.568]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.568]         on.exit(options(oopts), add = TRUE)
[13:34:39.568]     }
[13:34:39.568]     {
[13:34:39.568]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.568]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.568]         do.call(mapply, args = args)
[13:34:39.568]     }
[13:34:39.568] }
[13:34:39.568] Lazy evaluation: FALSE
[13:34:39.568] Asynchronous evaluation: TRUE
[13:34:39.568] Local evaluation: TRUE
[13:34:39.568] Environment: R_GlobalEnv
[13:34:39.568] Capture standard output: TRUE
[13:34:39.568] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.568] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.568] Packages: <none>
[13:34:39.568] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.568] Resolved: FALSE
[13:34:39.568] Value: <not collected>
[13:34:39.568] Conditions captured: <none>
[13:34:39.568] Early signaling: FALSE
[13:34:39.568] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.568] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.582] Chunk #1 of 2 ... DONE
[13:34:39.582] Chunk #2 of 2 ...
[13:34:39.582]  - Finding globals in '...' for chunk #2 ...
[13:34:39.582] getGlobalsAndPackages() ...
[13:34:39.583] Searching for globals...
[13:34:39.583] 
[13:34:39.583] Searching for globals ... DONE
[13:34:39.583] - globals: [0] <none>
[13:34:39.583] getGlobalsAndPackages() ... DONE
[13:34:39.583]    + additional globals found: [n=0] 
[13:34:39.583]    + additional namespaces needed: [n=0] 
[13:34:39.583]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:39.584]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:39.584]  - seeds: <none>
[13:34:39.584]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.584] getGlobalsAndPackages() ...
[13:34:39.584] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.584] Resolving globals: FALSE
[13:34:39.585] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[13:34:39.585] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:39.585] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.585] 
[13:34:39.585] getGlobalsAndPackages() ... DONE
[13:34:39.585] run() for ‘Future’ ...
[13:34:39.586] - state: ‘created’
[13:34:39.586] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.599] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.599] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.599]   - Field: ‘node’
[13:34:39.599]   - Field: ‘label’
[13:34:39.600]   - Field: ‘local’
[13:34:39.600]   - Field: ‘owner’
[13:34:39.600]   - Field: ‘envir’
[13:34:39.600]   - Field: ‘workers’
[13:34:39.600]   - Field: ‘packages’
[13:34:39.600]   - Field: ‘gc’
[13:34:39.600]   - Field: ‘conditions’
[13:34:39.600]   - Field: ‘persistent’
[13:34:39.600]   - Field: ‘expr’
[13:34:39.600]   - Field: ‘uuid’
[13:34:39.600]   - Field: ‘seed’
[13:34:39.600]   - Field: ‘version’
[13:34:39.601]   - Field: ‘result’
[13:34:39.601]   - Field: ‘asynchronous’
[13:34:39.601]   - Field: ‘calls’
[13:34:39.601]   - Field: ‘globals’
[13:34:39.601]   - Field: ‘stdout’
[13:34:39.601]   - Field: ‘earlySignal’
[13:34:39.601]   - Field: ‘lazy’
[13:34:39.601]   - Field: ‘state’
[13:34:39.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.601] - Launch lazy future ...
[13:34:39.602] Packages needed by the future expression (n = 0): <none>
[13:34:39.602] Packages needed by future strategies (n = 0): <none>
[13:34:39.602] {
[13:34:39.602]     {
[13:34:39.602]         {
[13:34:39.602]             ...future.startTime <- base::Sys.time()
[13:34:39.602]             {
[13:34:39.602]                 {
[13:34:39.602]                   {
[13:34:39.602]                     {
[13:34:39.602]                       base::local({
[13:34:39.602]                         has_future <- base::requireNamespace("future", 
[13:34:39.602]                           quietly = TRUE)
[13:34:39.602]                         if (has_future) {
[13:34:39.602]                           ns <- base::getNamespace("future")
[13:34:39.602]                           version <- ns[[".package"]][["version"]]
[13:34:39.602]                           if (is.null(version)) 
[13:34:39.602]                             version <- utils::packageVersion("future")
[13:34:39.602]                         }
[13:34:39.602]                         else {
[13:34:39.602]                           version <- NULL
[13:34:39.602]                         }
[13:34:39.602]                         if (!has_future || version < "1.8.0") {
[13:34:39.602]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.602]                             "", base::R.version$version.string), 
[13:34:39.602]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.602]                               "release", "version")], collapse = " "), 
[13:34:39.602]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.602]                             info)
[13:34:39.602]                           info <- base::paste(info, collapse = "; ")
[13:34:39.602]                           if (!has_future) {
[13:34:39.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.602]                               info)
[13:34:39.602]                           }
[13:34:39.602]                           else {
[13:34:39.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.602]                               info, version)
[13:34:39.602]                           }
[13:34:39.602]                           base::stop(msg)
[13:34:39.602]                         }
[13:34:39.602]                       })
[13:34:39.602]                     }
[13:34:39.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.602]                     base::options(mc.cores = 1L)
[13:34:39.602]                   }
[13:34:39.602]                   ...future.strategy.old <- future::plan("list")
[13:34:39.602]                   options(future.plan = NULL)
[13:34:39.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.602]                 }
[13:34:39.602]                 ...future.workdir <- getwd()
[13:34:39.602]             }
[13:34:39.602]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.602]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.602]         }
[13:34:39.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.602]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:39.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.602]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.602]             base::names(...future.oldOptions))
[13:34:39.602]     }
[13:34:39.602]     if (FALSE) {
[13:34:39.602]     }
[13:34:39.602]     else {
[13:34:39.602]         if (TRUE) {
[13:34:39.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.602]                 open = "w")
[13:34:39.602]         }
[13:34:39.602]         else {
[13:34:39.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.602]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.602]         }
[13:34:39.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.602]             base::sink(type = "output", split = FALSE)
[13:34:39.602]             base::close(...future.stdout)
[13:34:39.602]         }, add = TRUE)
[13:34:39.602]     }
[13:34:39.602]     ...future.frame <- base::sys.nframe()
[13:34:39.602]     ...future.conditions <- base::list()
[13:34:39.602]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.602]     if (FALSE) {
[13:34:39.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.602]     }
[13:34:39.602]     ...future.result <- base::tryCatch({
[13:34:39.602]         base::withCallingHandlers({
[13:34:39.602]             ...future.value <- base::withVisible(base::local({
[13:34:39.602]                 ...future.makeSendCondition <- base::local({
[13:34:39.602]                   sendCondition <- NULL
[13:34:39.602]                   function(frame = 1L) {
[13:34:39.602]                     if (is.function(sendCondition)) 
[13:34:39.602]                       return(sendCondition)
[13:34:39.602]                     ns <- getNamespace("parallel")
[13:34:39.602]                     if (exists("sendData", mode = "function", 
[13:34:39.602]                       envir = ns)) {
[13:34:39.602]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.602]                         envir = ns)
[13:34:39.602]                       envir <- sys.frame(frame)
[13:34:39.602]                       master <- NULL
[13:34:39.602]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.602]                         !identical(envir, emptyenv())) {
[13:34:39.602]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.602]                           inherits = FALSE)) {
[13:34:39.602]                           master <- get("master", mode = "list", 
[13:34:39.602]                             envir = envir, inherits = FALSE)
[13:34:39.602]                           if (inherits(master, c("SOCKnode", 
[13:34:39.602]                             "SOCK0node"))) {
[13:34:39.602]                             sendCondition <<- function(cond) {
[13:34:39.602]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.602]                                 success = TRUE)
[13:34:39.602]                               parallel_sendData(master, data)
[13:34:39.602]                             }
[13:34:39.602]                             return(sendCondition)
[13:34:39.602]                           }
[13:34:39.602]                         }
[13:34:39.602]                         frame <- frame + 1L
[13:34:39.602]                         envir <- sys.frame(frame)
[13:34:39.602]                       }
[13:34:39.602]                     }
[13:34:39.602]                     sendCondition <<- function(cond) NULL
[13:34:39.602]                   }
[13:34:39.602]                 })
[13:34:39.602]                 withCallingHandlers({
[13:34:39.602]                   {
[13:34:39.602]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.602]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.602]                       ...future.globals.maxSize)) {
[13:34:39.602]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.602]                       on.exit(options(oopts), add = TRUE)
[13:34:39.602]                     }
[13:34:39.602]                     {
[13:34:39.602]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.602]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.602]                         USE.NAMES = FALSE)
[13:34:39.602]                       do.call(mapply, args = args)
[13:34:39.602]                     }
[13:34:39.602]                   }
[13:34:39.602]                 }, immediateCondition = function(cond) {
[13:34:39.602]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.602]                   sendCondition(cond)
[13:34:39.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.602]                   {
[13:34:39.602]                     inherits <- base::inherits
[13:34:39.602]                     invokeRestart <- base::invokeRestart
[13:34:39.602]                     is.null <- base::is.null
[13:34:39.602]                     muffled <- FALSE
[13:34:39.602]                     if (inherits(cond, "message")) {
[13:34:39.602]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.602]                       if (muffled) 
[13:34:39.602]                         invokeRestart("muffleMessage")
[13:34:39.602]                     }
[13:34:39.602]                     else if (inherits(cond, "warning")) {
[13:34:39.602]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.602]                       if (muffled) 
[13:34:39.602]                         invokeRestart("muffleWarning")
[13:34:39.602]                     }
[13:34:39.602]                     else if (inherits(cond, "condition")) {
[13:34:39.602]                       if (!is.null(pattern)) {
[13:34:39.602]                         computeRestarts <- base::computeRestarts
[13:34:39.602]                         grepl <- base::grepl
[13:34:39.602]                         restarts <- computeRestarts(cond)
[13:34:39.602]                         for (restart in restarts) {
[13:34:39.602]                           name <- restart$name
[13:34:39.602]                           if (is.null(name)) 
[13:34:39.602]                             next
[13:34:39.602]                           if (!grepl(pattern, name)) 
[13:34:39.602]                             next
[13:34:39.602]                           invokeRestart(restart)
[13:34:39.602]                           muffled <- TRUE
[13:34:39.602]                           break
[13:34:39.602]                         }
[13:34:39.602]                       }
[13:34:39.602]                     }
[13:34:39.602]                     invisible(muffled)
[13:34:39.602]                   }
[13:34:39.602]                   muffleCondition(cond)
[13:34:39.602]                 })
[13:34:39.602]             }))
[13:34:39.602]             future::FutureResult(value = ...future.value$value, 
[13:34:39.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.602]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.602]                     ...future.globalenv.names))
[13:34:39.602]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.602]         }, condition = base::local({
[13:34:39.602]             c <- base::c
[13:34:39.602]             inherits <- base::inherits
[13:34:39.602]             invokeRestart <- base::invokeRestart
[13:34:39.602]             length <- base::length
[13:34:39.602]             list <- base::list
[13:34:39.602]             seq.int <- base::seq.int
[13:34:39.602]             signalCondition <- base::signalCondition
[13:34:39.602]             sys.calls <- base::sys.calls
[13:34:39.602]             `[[` <- base::`[[`
[13:34:39.602]             `+` <- base::`+`
[13:34:39.602]             `<<-` <- base::`<<-`
[13:34:39.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.602]                   3L)]
[13:34:39.602]             }
[13:34:39.602]             function(cond) {
[13:34:39.602]                 is_error <- inherits(cond, "error")
[13:34:39.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.602]                   NULL)
[13:34:39.602]                 if (is_error) {
[13:34:39.602]                   sessionInformation <- function() {
[13:34:39.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.602]                       search = base::search(), system = base::Sys.info())
[13:34:39.602]                   }
[13:34:39.602]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.602]                     cond$call), session = sessionInformation(), 
[13:34:39.602]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.602]                   signalCondition(cond)
[13:34:39.602]                 }
[13:34:39.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.602]                 "immediateCondition"))) {
[13:34:39.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.602]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.602]                   if (TRUE && !signal) {
[13:34:39.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.602]                     {
[13:34:39.602]                       inherits <- base::inherits
[13:34:39.602]                       invokeRestart <- base::invokeRestart
[13:34:39.602]                       is.null <- base::is.null
[13:34:39.602]                       muffled <- FALSE
[13:34:39.602]                       if (inherits(cond, "message")) {
[13:34:39.602]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.602]                         if (muffled) 
[13:34:39.602]                           invokeRestart("muffleMessage")
[13:34:39.602]                       }
[13:34:39.602]                       else if (inherits(cond, "warning")) {
[13:34:39.602]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.602]                         if (muffled) 
[13:34:39.602]                           invokeRestart("muffleWarning")
[13:34:39.602]                       }
[13:34:39.602]                       else if (inherits(cond, "condition")) {
[13:34:39.602]                         if (!is.null(pattern)) {
[13:34:39.602]                           computeRestarts <- base::computeRestarts
[13:34:39.602]                           grepl <- base::grepl
[13:34:39.602]                           restarts <- computeRestarts(cond)
[13:34:39.602]                           for (restart in restarts) {
[13:34:39.602]                             name <- restart$name
[13:34:39.602]                             if (is.null(name)) 
[13:34:39.602]                               next
[13:34:39.602]                             if (!grepl(pattern, name)) 
[13:34:39.602]                               next
[13:34:39.602]                             invokeRestart(restart)
[13:34:39.602]                             muffled <- TRUE
[13:34:39.602]                             break
[13:34:39.602]                           }
[13:34:39.602]                         }
[13:34:39.602]                       }
[13:34:39.602]                       invisible(muffled)
[13:34:39.602]                     }
[13:34:39.602]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.602]                   }
[13:34:39.602]                 }
[13:34:39.602]                 else {
[13:34:39.602]                   if (TRUE) {
[13:34:39.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.602]                     {
[13:34:39.602]                       inherits <- base::inherits
[13:34:39.602]                       invokeRestart <- base::invokeRestart
[13:34:39.602]                       is.null <- base::is.null
[13:34:39.602]                       muffled <- FALSE
[13:34:39.602]                       if (inherits(cond, "message")) {
[13:34:39.602]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.602]                         if (muffled) 
[13:34:39.602]                           invokeRestart("muffleMessage")
[13:34:39.602]                       }
[13:34:39.602]                       else if (inherits(cond, "warning")) {
[13:34:39.602]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.602]                         if (muffled) 
[13:34:39.602]                           invokeRestart("muffleWarning")
[13:34:39.602]                       }
[13:34:39.602]                       else if (inherits(cond, "condition")) {
[13:34:39.602]                         if (!is.null(pattern)) {
[13:34:39.602]                           computeRestarts <- base::computeRestarts
[13:34:39.602]                           grepl <- base::grepl
[13:34:39.602]                           restarts <- computeRestarts(cond)
[13:34:39.602]                           for (restart in restarts) {
[13:34:39.602]                             name <- restart$name
[13:34:39.602]                             if (is.null(name)) 
[13:34:39.602]                               next
[13:34:39.602]                             if (!grepl(pattern, name)) 
[13:34:39.602]                               next
[13:34:39.602]                             invokeRestart(restart)
[13:34:39.602]                             muffled <- TRUE
[13:34:39.602]                             break
[13:34:39.602]                           }
[13:34:39.602]                         }
[13:34:39.602]                       }
[13:34:39.602]                       invisible(muffled)
[13:34:39.602]                     }
[13:34:39.602]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.602]                   }
[13:34:39.602]                 }
[13:34:39.602]             }
[13:34:39.602]         }))
[13:34:39.602]     }, error = function(ex) {
[13:34:39.602]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.602]                 ...future.rng), started = ...future.startTime, 
[13:34:39.602]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.602]             version = "1.8"), class = "FutureResult")
[13:34:39.602]     }, finally = {
[13:34:39.602]         if (!identical(...future.workdir, getwd())) 
[13:34:39.602]             setwd(...future.workdir)
[13:34:39.602]         {
[13:34:39.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.602]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.602]             }
[13:34:39.602]             base::options(...future.oldOptions)
[13:34:39.602]             if (.Platform$OS.type == "windows") {
[13:34:39.602]                 old_names <- names(...future.oldEnvVars)
[13:34:39.602]                 envs <- base::Sys.getenv()
[13:34:39.602]                 names <- names(envs)
[13:34:39.602]                 common <- intersect(names, old_names)
[13:34:39.602]                 added <- setdiff(names, old_names)
[13:34:39.602]                 removed <- setdiff(old_names, names)
[13:34:39.602]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.602]                   envs[common]]
[13:34:39.602]                 NAMES <- toupper(changed)
[13:34:39.602]                 args <- list()
[13:34:39.602]                 for (kk in seq_along(NAMES)) {
[13:34:39.602]                   name <- changed[[kk]]
[13:34:39.602]                   NAME <- NAMES[[kk]]
[13:34:39.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.602]                     next
[13:34:39.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.602]                 }
[13:34:39.602]                 NAMES <- toupper(added)
[13:34:39.602]                 for (kk in seq_along(NAMES)) {
[13:34:39.602]                   name <- added[[kk]]
[13:34:39.602]                   NAME <- NAMES[[kk]]
[13:34:39.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.602]                     next
[13:34:39.602]                   args[[name]] <- ""
[13:34:39.602]                 }
[13:34:39.602]                 NAMES <- toupper(removed)
[13:34:39.602]                 for (kk in seq_along(NAMES)) {
[13:34:39.602]                   name <- removed[[kk]]
[13:34:39.602]                   NAME <- NAMES[[kk]]
[13:34:39.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.602]                     next
[13:34:39.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.602]                 }
[13:34:39.602]                 if (length(args) > 0) 
[13:34:39.602]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.602]             }
[13:34:39.602]             else {
[13:34:39.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.602]             }
[13:34:39.602]             {
[13:34:39.602]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.602]                   0L) {
[13:34:39.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.602]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.602]                   base::options(opts)
[13:34:39.602]                 }
[13:34:39.602]                 {
[13:34:39.602]                   {
[13:34:39.602]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.602]                     NULL
[13:34:39.602]                   }
[13:34:39.602]                   options(future.plan = NULL)
[13:34:39.602]                   if (is.na(NA_character_)) 
[13:34:39.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.602]                     .init = FALSE)
[13:34:39.602]                 }
[13:34:39.602]             }
[13:34:39.602]         }
[13:34:39.602]     })
[13:34:39.602]     if (TRUE) {
[13:34:39.602]         base::sink(type = "output", split = FALSE)
[13:34:39.602]         if (TRUE) {
[13:34:39.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.602]         }
[13:34:39.602]         else {
[13:34:39.602]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.602]         }
[13:34:39.602]         base::close(...future.stdout)
[13:34:39.602]         ...future.stdout <- NULL
[13:34:39.602]     }
[13:34:39.602]     ...future.result$conditions <- ...future.conditions
[13:34:39.602]     ...future.result$finished <- base::Sys.time()
[13:34:39.602]     ...future.result
[13:34:39.602] }
[13:34:39.605] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[13:34:39.605] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[13:34:39.605] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[13:34:39.605] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:39.606] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.606] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[13:34:39.606] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[13:34:39.606] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:39.607] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.607] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:39.607] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.607] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[13:34:39.608] MultisessionFuture started
[13:34:39.608] - Launch lazy future ... done
[13:34:39.608] run() for ‘MultisessionFuture’ ... done
[13:34:39.608] Created future:
[13:34:39.608] MultisessionFuture:
[13:34:39.608] Label: ‘future_.mapply-2’
[13:34:39.608] Expression:
[13:34:39.608] {
[13:34:39.608]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.608]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.608]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.608]         on.exit(options(oopts), add = TRUE)
[13:34:39.608]     }
[13:34:39.608]     {
[13:34:39.608]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.608]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.608]         do.call(mapply, args = args)
[13:34:39.608]     }
[13:34:39.608] }
[13:34:39.608] Lazy evaluation: FALSE
[13:34:39.608] Asynchronous evaluation: TRUE
[13:34:39.608] Local evaluation: TRUE
[13:34:39.608] Environment: R_GlobalEnv
[13:34:39.608] Capture standard output: TRUE
[13:34:39.608] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.608] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.608] Packages: <none>
[13:34:39.608] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.608] Resolved: FALSE
[13:34:39.608] Value: <not collected>
[13:34:39.608] Conditions captured: <none>
[13:34:39.608] Early signaling: FALSE
[13:34:39.608] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.608] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.619] Chunk #2 of 2 ... DONE
[13:34:39.619] Launching 2 futures (chunks) ... DONE
[13:34:39.619] Resolving 2 futures (chunks) ...
[13:34:39.620] resolve() on list ...
[13:34:39.620]  recursive: 0
[13:34:39.620]  length: 2
[13:34:39.620] 
[13:34:39.620] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.620] - Validating connection of MultisessionFuture
[13:34:39.620] - received message: FutureResult
[13:34:39.621] - Received FutureResult
[13:34:39.621] - Erased future from FutureRegistry
[13:34:39.621] result() for ClusterFuture ...
[13:34:39.621] - result already collected: FutureResult
[13:34:39.621] result() for ClusterFuture ... done
[13:34:39.621] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.621] Future #1
[13:34:39.621] result() for ClusterFuture ...
[13:34:39.621] - result already collected: FutureResult
[13:34:39.621] result() for ClusterFuture ... done
[13:34:39.622] result() for ClusterFuture ...
[13:34:39.622] - result already collected: FutureResult
[13:34:39.622] result() for ClusterFuture ... done
[13:34:39.622] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:39.622] - nx: 2
[13:34:39.622] - relay: TRUE
[13:34:39.622] - stdout: TRUE
[13:34:39.622] - signal: TRUE
[13:34:39.622] - resignal: FALSE
[13:34:39.622] - force: TRUE
[13:34:39.622] - relayed: [n=2] FALSE, FALSE
[13:34:39.622] - queued futures: [n=2] FALSE, FALSE
[13:34:39.623]  - until=1
[13:34:39.623]  - relaying element #1
[13:34:39.623] result() for ClusterFuture ...
[13:34:39.623] - result already collected: FutureResult
[13:34:39.623] result() for ClusterFuture ... done
[13:34:39.623] result() for ClusterFuture ...
[13:34:39.623] - result already collected: FutureResult
[13:34:39.623] result() for ClusterFuture ... done
[13:34:39.623] result() for ClusterFuture ...
[13:34:39.623] - result already collected: FutureResult
[13:34:39.623] result() for ClusterFuture ... done
[13:34:39.624] result() for ClusterFuture ...
[13:34:39.624] - result already collected: FutureResult
[13:34:39.624] result() for ClusterFuture ... done
[13:34:39.624] - relayed: [n=2] TRUE, FALSE
[13:34:39.624] - queued futures: [n=2] TRUE, FALSE
[13:34:39.624] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:39.624]  length: 1 (resolved future 1)
[13:34:39.652] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.652] - Validating connection of MultisessionFuture
[13:34:39.652] - received message: FutureResult
[13:34:39.652] - Received FutureResult
[13:34:39.652] - Erased future from FutureRegistry
[13:34:39.652] result() for ClusterFuture ...
[13:34:39.653] - result already collected: FutureResult
[13:34:39.653] result() for ClusterFuture ... done
[13:34:39.653] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.653] Future #2
[13:34:39.653] result() for ClusterFuture ...
[13:34:39.653] - result already collected: FutureResult
[13:34:39.653] result() for ClusterFuture ... done
[13:34:39.653] result() for ClusterFuture ...
[13:34:39.653] - result already collected: FutureResult
[13:34:39.653] result() for ClusterFuture ... done
[13:34:39.653] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:39.654] - nx: 2
[13:34:39.654] - relay: TRUE
[13:34:39.654] - stdout: TRUE
[13:34:39.654] - signal: TRUE
[13:34:39.654] - resignal: FALSE
[13:34:39.654] - force: TRUE
[13:34:39.654] - relayed: [n=2] TRUE, FALSE
[13:34:39.654] - queued futures: [n=2] TRUE, FALSE
[13:34:39.654]  - until=2
[13:34:39.654]  - relaying element #2
[13:34:39.654] result() for ClusterFuture ...
[13:34:39.655] - result already collected: FutureResult
[13:34:39.655] result() for ClusterFuture ... done
[13:34:39.655] result() for ClusterFuture ...
[13:34:39.655] - result already collected: FutureResult
[13:34:39.655] result() for ClusterFuture ... done
[13:34:39.655] result() for ClusterFuture ...
[13:34:39.655] - result already collected: FutureResult
[13:34:39.655] result() for ClusterFuture ... done
[13:34:39.655] result() for ClusterFuture ...
[13:34:39.655] - result already collected: FutureResult
[13:34:39.655] result() for ClusterFuture ... done
[13:34:39.656] - relayed: [n=2] TRUE, TRUE
[13:34:39.656] - queued futures: [n=2] TRUE, TRUE
[13:34:39.656] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:39.656]  length: 0 (resolved future 2)
[13:34:39.656] Relaying remaining futures
[13:34:39.656] signalConditionsASAP(NULL, pos=0) ...
[13:34:39.656] - nx: 2
[13:34:39.656] - relay: TRUE
[13:34:39.656] - stdout: TRUE
[13:34:39.656] - signal: TRUE
[13:34:39.656] - resignal: FALSE
[13:34:39.656] - force: TRUE
[13:34:39.657] - relayed: [n=2] TRUE, TRUE
[13:34:39.657] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:39.657] - relayed: [n=2] TRUE, TRUE
[13:34:39.657] - queued futures: [n=2] TRUE, TRUE
[13:34:39.657] signalConditionsASAP(NULL, pos=0) ... done
[13:34:39.657] resolve() on list ... DONE
[13:34:39.657] result() for ClusterFuture ...
[13:34:39.657] - result already collected: FutureResult
[13:34:39.657] result() for ClusterFuture ... done
[13:34:39.657] result() for ClusterFuture ...
[13:34:39.657] - result already collected: FutureResult
[13:34:39.658] result() for ClusterFuture ... done
[13:34:39.658] result() for ClusterFuture ...
[13:34:39.658] - result already collected: FutureResult
[13:34:39.658] result() for ClusterFuture ... done
[13:34:39.658] result() for ClusterFuture ...
[13:34:39.658] - result already collected: FutureResult
[13:34:39.658] result() for ClusterFuture ... done
[13:34:39.658]  - Number of value chunks collected: 2
[13:34:39.658] Resolving 2 futures (chunks) ... DONE
[13:34:39.658] Reducing values from 2 chunks ...
[13:34:39.659]  - Number of values collected after concatenation: 5
[13:34:39.659]  - Number of values expected: 5
[13:34:39.659] Reducing values from 2 chunks ... DONE
[13:34:39.659] future_mapply() ... DONE
[13:34:39.659] future_mapply() ...
[13:34:39.663] Number of chunks: 2
[13:34:39.663] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[13:34:39.663] getGlobalsAndPackagesXApply() ...
[13:34:39.663]  - future.globals: TRUE
[13:34:39.663] getGlobalsAndPackages() ...
[13:34:39.663] Searching for globals...
[13:34:39.664] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:39.664] Searching for globals ... DONE
[13:34:39.664] Resolving globals: FALSE
[13:34:39.665] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:39.665] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:39.665] - globals: [1] ‘FUN’
[13:34:39.665] 
[13:34:39.665] getGlobalsAndPackages() ... DONE
[13:34:39.666]  - globals found/used: [n=1] ‘FUN’
[13:34:39.666]  - needed namespaces: [n=0] 
[13:34:39.666] Finding globals ... DONE
[13:34:39.666] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:39.666] List of 2
[13:34:39.666]  $ ...future.FUN:function (C, k)  
[13:34:39.666]  $ MoreArgs     : NULL
[13:34:39.666]  - attr(*, "where")=List of 2
[13:34:39.666]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:39.666]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:39.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:39.666]  - attr(*, "resolved")= logi FALSE
[13:34:39.666]  - attr(*, "total_size")= num NA
[13:34:39.668] Packages to be attached in all futures: [n=0] 
[13:34:39.668] getGlobalsAndPackagesXApply() ... DONE
[13:34:39.669] Number of futures (= number of chunks): 2
[13:34:39.669] Launching 2 futures (chunks) ...
[13:34:39.669] Chunk #1 of 2 ...
[13:34:39.669]  - Finding globals in '...' for chunk #1 ...
[13:34:39.669] getGlobalsAndPackages() ...
[13:34:39.669] Searching for globals...
[13:34:39.669] 
[13:34:39.670] Searching for globals ... DONE
[13:34:39.670] - globals: [0] <none>
[13:34:39.670] getGlobalsAndPackages() ... DONE
[13:34:39.670]    + additional globals found: [n=0] 
[13:34:39.670]    + additional namespaces needed: [n=0] 
[13:34:39.670]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:39.670]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:39.670]  - seeds: <none>
[13:34:39.670]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.670] getGlobalsAndPackages() ...
[13:34:39.671] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.671] Resolving globals: FALSE
[13:34:39.671] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:39.672] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:39.672] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.672] 
[13:34:39.672] getGlobalsAndPackages() ... DONE
[13:34:39.672] run() for ‘Future’ ...
[13:34:39.672] - state: ‘created’
[13:34:39.672] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.686] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.686]   - Field: ‘node’
[13:34:39.686]   - Field: ‘label’
[13:34:39.686]   - Field: ‘local’
[13:34:39.686]   - Field: ‘owner’
[13:34:39.687]   - Field: ‘envir’
[13:34:39.687]   - Field: ‘workers’
[13:34:39.687]   - Field: ‘packages’
[13:34:39.687]   - Field: ‘gc’
[13:34:39.687]   - Field: ‘conditions’
[13:34:39.687]   - Field: ‘persistent’
[13:34:39.687]   - Field: ‘expr’
[13:34:39.687]   - Field: ‘uuid’
[13:34:39.687]   - Field: ‘seed’
[13:34:39.687]   - Field: ‘version’
[13:34:39.687]   - Field: ‘result’
[13:34:39.688]   - Field: ‘asynchronous’
[13:34:39.688]   - Field: ‘calls’
[13:34:39.688]   - Field: ‘globals’
[13:34:39.688]   - Field: ‘stdout’
[13:34:39.688]   - Field: ‘earlySignal’
[13:34:39.688]   - Field: ‘lazy’
[13:34:39.688]   - Field: ‘state’
[13:34:39.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.688] - Launch lazy future ...
[13:34:39.689] Packages needed by the future expression (n = 0): <none>
[13:34:39.689] Packages needed by future strategies (n = 0): <none>
[13:34:39.689] {
[13:34:39.689]     {
[13:34:39.689]         {
[13:34:39.689]             ...future.startTime <- base::Sys.time()
[13:34:39.689]             {
[13:34:39.689]                 {
[13:34:39.689]                   {
[13:34:39.689]                     {
[13:34:39.689]                       base::local({
[13:34:39.689]                         has_future <- base::requireNamespace("future", 
[13:34:39.689]                           quietly = TRUE)
[13:34:39.689]                         if (has_future) {
[13:34:39.689]                           ns <- base::getNamespace("future")
[13:34:39.689]                           version <- ns[[".package"]][["version"]]
[13:34:39.689]                           if (is.null(version)) 
[13:34:39.689]                             version <- utils::packageVersion("future")
[13:34:39.689]                         }
[13:34:39.689]                         else {
[13:34:39.689]                           version <- NULL
[13:34:39.689]                         }
[13:34:39.689]                         if (!has_future || version < "1.8.0") {
[13:34:39.689]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.689]                             "", base::R.version$version.string), 
[13:34:39.689]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.689]                               "release", "version")], collapse = " "), 
[13:34:39.689]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.689]                             info)
[13:34:39.689]                           info <- base::paste(info, collapse = "; ")
[13:34:39.689]                           if (!has_future) {
[13:34:39.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.689]                               info)
[13:34:39.689]                           }
[13:34:39.689]                           else {
[13:34:39.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.689]                               info, version)
[13:34:39.689]                           }
[13:34:39.689]                           base::stop(msg)
[13:34:39.689]                         }
[13:34:39.689]                       })
[13:34:39.689]                     }
[13:34:39.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.689]                     base::options(mc.cores = 1L)
[13:34:39.689]                   }
[13:34:39.689]                   ...future.strategy.old <- future::plan("list")
[13:34:39.689]                   options(future.plan = NULL)
[13:34:39.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.689]                 }
[13:34:39.689]                 ...future.workdir <- getwd()
[13:34:39.689]             }
[13:34:39.689]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.689]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.689]         }
[13:34:39.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.689]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:39.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.689]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.689]             base::names(...future.oldOptions))
[13:34:39.689]     }
[13:34:39.689]     if (FALSE) {
[13:34:39.689]     }
[13:34:39.689]     else {
[13:34:39.689]         if (TRUE) {
[13:34:39.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.689]                 open = "w")
[13:34:39.689]         }
[13:34:39.689]         else {
[13:34:39.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.689]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.689]         }
[13:34:39.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.689]             base::sink(type = "output", split = FALSE)
[13:34:39.689]             base::close(...future.stdout)
[13:34:39.689]         }, add = TRUE)
[13:34:39.689]     }
[13:34:39.689]     ...future.frame <- base::sys.nframe()
[13:34:39.689]     ...future.conditions <- base::list()
[13:34:39.689]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.689]     if (FALSE) {
[13:34:39.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.689]     }
[13:34:39.689]     ...future.result <- base::tryCatch({
[13:34:39.689]         base::withCallingHandlers({
[13:34:39.689]             ...future.value <- base::withVisible(base::local({
[13:34:39.689]                 ...future.makeSendCondition <- base::local({
[13:34:39.689]                   sendCondition <- NULL
[13:34:39.689]                   function(frame = 1L) {
[13:34:39.689]                     if (is.function(sendCondition)) 
[13:34:39.689]                       return(sendCondition)
[13:34:39.689]                     ns <- getNamespace("parallel")
[13:34:39.689]                     if (exists("sendData", mode = "function", 
[13:34:39.689]                       envir = ns)) {
[13:34:39.689]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.689]                         envir = ns)
[13:34:39.689]                       envir <- sys.frame(frame)
[13:34:39.689]                       master <- NULL
[13:34:39.689]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.689]                         !identical(envir, emptyenv())) {
[13:34:39.689]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.689]                           inherits = FALSE)) {
[13:34:39.689]                           master <- get("master", mode = "list", 
[13:34:39.689]                             envir = envir, inherits = FALSE)
[13:34:39.689]                           if (inherits(master, c("SOCKnode", 
[13:34:39.689]                             "SOCK0node"))) {
[13:34:39.689]                             sendCondition <<- function(cond) {
[13:34:39.689]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.689]                                 success = TRUE)
[13:34:39.689]                               parallel_sendData(master, data)
[13:34:39.689]                             }
[13:34:39.689]                             return(sendCondition)
[13:34:39.689]                           }
[13:34:39.689]                         }
[13:34:39.689]                         frame <- frame + 1L
[13:34:39.689]                         envir <- sys.frame(frame)
[13:34:39.689]                       }
[13:34:39.689]                     }
[13:34:39.689]                     sendCondition <<- function(cond) NULL
[13:34:39.689]                   }
[13:34:39.689]                 })
[13:34:39.689]                 withCallingHandlers({
[13:34:39.689]                   {
[13:34:39.689]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.689]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.689]                       ...future.globals.maxSize)) {
[13:34:39.689]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.689]                       on.exit(options(oopts), add = TRUE)
[13:34:39.689]                     }
[13:34:39.689]                     {
[13:34:39.689]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.689]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.689]                         USE.NAMES = FALSE)
[13:34:39.689]                       do.call(mapply, args = args)
[13:34:39.689]                     }
[13:34:39.689]                   }
[13:34:39.689]                 }, immediateCondition = function(cond) {
[13:34:39.689]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.689]                   sendCondition(cond)
[13:34:39.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.689]                   {
[13:34:39.689]                     inherits <- base::inherits
[13:34:39.689]                     invokeRestart <- base::invokeRestart
[13:34:39.689]                     is.null <- base::is.null
[13:34:39.689]                     muffled <- FALSE
[13:34:39.689]                     if (inherits(cond, "message")) {
[13:34:39.689]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.689]                       if (muffled) 
[13:34:39.689]                         invokeRestart("muffleMessage")
[13:34:39.689]                     }
[13:34:39.689]                     else if (inherits(cond, "warning")) {
[13:34:39.689]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.689]                       if (muffled) 
[13:34:39.689]                         invokeRestart("muffleWarning")
[13:34:39.689]                     }
[13:34:39.689]                     else if (inherits(cond, "condition")) {
[13:34:39.689]                       if (!is.null(pattern)) {
[13:34:39.689]                         computeRestarts <- base::computeRestarts
[13:34:39.689]                         grepl <- base::grepl
[13:34:39.689]                         restarts <- computeRestarts(cond)
[13:34:39.689]                         for (restart in restarts) {
[13:34:39.689]                           name <- restart$name
[13:34:39.689]                           if (is.null(name)) 
[13:34:39.689]                             next
[13:34:39.689]                           if (!grepl(pattern, name)) 
[13:34:39.689]                             next
[13:34:39.689]                           invokeRestart(restart)
[13:34:39.689]                           muffled <- TRUE
[13:34:39.689]                           break
[13:34:39.689]                         }
[13:34:39.689]                       }
[13:34:39.689]                     }
[13:34:39.689]                     invisible(muffled)
[13:34:39.689]                   }
[13:34:39.689]                   muffleCondition(cond)
[13:34:39.689]                 })
[13:34:39.689]             }))
[13:34:39.689]             future::FutureResult(value = ...future.value$value, 
[13:34:39.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.689]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.689]                     ...future.globalenv.names))
[13:34:39.689]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.689]         }, condition = base::local({
[13:34:39.689]             c <- base::c
[13:34:39.689]             inherits <- base::inherits
[13:34:39.689]             invokeRestart <- base::invokeRestart
[13:34:39.689]             length <- base::length
[13:34:39.689]             list <- base::list
[13:34:39.689]             seq.int <- base::seq.int
[13:34:39.689]             signalCondition <- base::signalCondition
[13:34:39.689]             sys.calls <- base::sys.calls
[13:34:39.689]             `[[` <- base::`[[`
[13:34:39.689]             `+` <- base::`+`
[13:34:39.689]             `<<-` <- base::`<<-`
[13:34:39.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.689]                   3L)]
[13:34:39.689]             }
[13:34:39.689]             function(cond) {
[13:34:39.689]                 is_error <- inherits(cond, "error")
[13:34:39.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.689]                   NULL)
[13:34:39.689]                 if (is_error) {
[13:34:39.689]                   sessionInformation <- function() {
[13:34:39.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.689]                       search = base::search(), system = base::Sys.info())
[13:34:39.689]                   }
[13:34:39.689]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.689]                     cond$call), session = sessionInformation(), 
[13:34:39.689]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.689]                   signalCondition(cond)
[13:34:39.689]                 }
[13:34:39.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.689]                 "immediateCondition"))) {
[13:34:39.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.689]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.689]                   if (TRUE && !signal) {
[13:34:39.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.689]                     {
[13:34:39.689]                       inherits <- base::inherits
[13:34:39.689]                       invokeRestart <- base::invokeRestart
[13:34:39.689]                       is.null <- base::is.null
[13:34:39.689]                       muffled <- FALSE
[13:34:39.689]                       if (inherits(cond, "message")) {
[13:34:39.689]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.689]                         if (muffled) 
[13:34:39.689]                           invokeRestart("muffleMessage")
[13:34:39.689]                       }
[13:34:39.689]                       else if (inherits(cond, "warning")) {
[13:34:39.689]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.689]                         if (muffled) 
[13:34:39.689]                           invokeRestart("muffleWarning")
[13:34:39.689]                       }
[13:34:39.689]                       else if (inherits(cond, "condition")) {
[13:34:39.689]                         if (!is.null(pattern)) {
[13:34:39.689]                           computeRestarts <- base::computeRestarts
[13:34:39.689]                           grepl <- base::grepl
[13:34:39.689]                           restarts <- computeRestarts(cond)
[13:34:39.689]                           for (restart in restarts) {
[13:34:39.689]                             name <- restart$name
[13:34:39.689]                             if (is.null(name)) 
[13:34:39.689]                               next
[13:34:39.689]                             if (!grepl(pattern, name)) 
[13:34:39.689]                               next
[13:34:39.689]                             invokeRestart(restart)
[13:34:39.689]                             muffled <- TRUE
[13:34:39.689]                             break
[13:34:39.689]                           }
[13:34:39.689]                         }
[13:34:39.689]                       }
[13:34:39.689]                       invisible(muffled)
[13:34:39.689]                     }
[13:34:39.689]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.689]                   }
[13:34:39.689]                 }
[13:34:39.689]                 else {
[13:34:39.689]                   if (TRUE) {
[13:34:39.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.689]                     {
[13:34:39.689]                       inherits <- base::inherits
[13:34:39.689]                       invokeRestart <- base::invokeRestart
[13:34:39.689]                       is.null <- base::is.null
[13:34:39.689]                       muffled <- FALSE
[13:34:39.689]                       if (inherits(cond, "message")) {
[13:34:39.689]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.689]                         if (muffled) 
[13:34:39.689]                           invokeRestart("muffleMessage")
[13:34:39.689]                       }
[13:34:39.689]                       else if (inherits(cond, "warning")) {
[13:34:39.689]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.689]                         if (muffled) 
[13:34:39.689]                           invokeRestart("muffleWarning")
[13:34:39.689]                       }
[13:34:39.689]                       else if (inherits(cond, "condition")) {
[13:34:39.689]                         if (!is.null(pattern)) {
[13:34:39.689]                           computeRestarts <- base::computeRestarts
[13:34:39.689]                           grepl <- base::grepl
[13:34:39.689]                           restarts <- computeRestarts(cond)
[13:34:39.689]                           for (restart in restarts) {
[13:34:39.689]                             name <- restart$name
[13:34:39.689]                             if (is.null(name)) 
[13:34:39.689]                               next
[13:34:39.689]                             if (!grepl(pattern, name)) 
[13:34:39.689]                               next
[13:34:39.689]                             invokeRestart(restart)
[13:34:39.689]                             muffled <- TRUE
[13:34:39.689]                             break
[13:34:39.689]                           }
[13:34:39.689]                         }
[13:34:39.689]                       }
[13:34:39.689]                       invisible(muffled)
[13:34:39.689]                     }
[13:34:39.689]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.689]                   }
[13:34:39.689]                 }
[13:34:39.689]             }
[13:34:39.689]         }))
[13:34:39.689]     }, error = function(ex) {
[13:34:39.689]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.689]                 ...future.rng), started = ...future.startTime, 
[13:34:39.689]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.689]             version = "1.8"), class = "FutureResult")
[13:34:39.689]     }, finally = {
[13:34:39.689]         if (!identical(...future.workdir, getwd())) 
[13:34:39.689]             setwd(...future.workdir)
[13:34:39.689]         {
[13:34:39.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.689]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.689]             }
[13:34:39.689]             base::options(...future.oldOptions)
[13:34:39.689]             if (.Platform$OS.type == "windows") {
[13:34:39.689]                 old_names <- names(...future.oldEnvVars)
[13:34:39.689]                 envs <- base::Sys.getenv()
[13:34:39.689]                 names <- names(envs)
[13:34:39.689]                 common <- intersect(names, old_names)
[13:34:39.689]                 added <- setdiff(names, old_names)
[13:34:39.689]                 removed <- setdiff(old_names, names)
[13:34:39.689]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.689]                   envs[common]]
[13:34:39.689]                 NAMES <- toupper(changed)
[13:34:39.689]                 args <- list()
[13:34:39.689]                 for (kk in seq_along(NAMES)) {
[13:34:39.689]                   name <- changed[[kk]]
[13:34:39.689]                   NAME <- NAMES[[kk]]
[13:34:39.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.689]                     next
[13:34:39.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.689]                 }
[13:34:39.689]                 NAMES <- toupper(added)
[13:34:39.689]                 for (kk in seq_along(NAMES)) {
[13:34:39.689]                   name <- added[[kk]]
[13:34:39.689]                   NAME <- NAMES[[kk]]
[13:34:39.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.689]                     next
[13:34:39.689]                   args[[name]] <- ""
[13:34:39.689]                 }
[13:34:39.689]                 NAMES <- toupper(removed)
[13:34:39.689]                 for (kk in seq_along(NAMES)) {
[13:34:39.689]                   name <- removed[[kk]]
[13:34:39.689]                   NAME <- NAMES[[kk]]
[13:34:39.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.689]                     next
[13:34:39.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.689]                 }
[13:34:39.689]                 if (length(args) > 0) 
[13:34:39.689]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.689]             }
[13:34:39.689]             else {
[13:34:39.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.689]             }
[13:34:39.689]             {
[13:34:39.689]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.689]                   0L) {
[13:34:39.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.689]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.689]                   base::options(opts)
[13:34:39.689]                 }
[13:34:39.689]                 {
[13:34:39.689]                   {
[13:34:39.689]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.689]                     NULL
[13:34:39.689]                   }
[13:34:39.689]                   options(future.plan = NULL)
[13:34:39.689]                   if (is.na(NA_character_)) 
[13:34:39.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.689]                     .init = FALSE)
[13:34:39.689]                 }
[13:34:39.689]             }
[13:34:39.689]         }
[13:34:39.689]     })
[13:34:39.689]     if (TRUE) {
[13:34:39.689]         base::sink(type = "output", split = FALSE)
[13:34:39.689]         if (TRUE) {
[13:34:39.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.689]         }
[13:34:39.689]         else {
[13:34:39.689]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.689]         }
[13:34:39.689]         base::close(...future.stdout)
[13:34:39.689]         ...future.stdout <- NULL
[13:34:39.689]     }
[13:34:39.689]     ...future.result$conditions <- ...future.conditions
[13:34:39.689]     ...future.result$finished <- base::Sys.time()
[13:34:39.689]     ...future.result
[13:34:39.689] }
[13:34:39.692] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[13:34:39.692] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[13:34:39.692] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[13:34:39.692] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:39.693] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.693] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[13:34:39.693] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[13:34:39.693] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:39.694] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.694] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:39.694] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.694] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[13:34:39.695] MultisessionFuture started
[13:34:39.695] - Launch lazy future ... done
[13:34:39.695] run() for ‘MultisessionFuture’ ... done
[13:34:39.695] Created future:
[13:34:39.695] MultisessionFuture:
[13:34:39.695] Label: ‘future_mapply-1’
[13:34:39.695] Expression:
[13:34:39.695] {
[13:34:39.695]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.695]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.695]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.695]         on.exit(options(oopts), add = TRUE)
[13:34:39.695]     }
[13:34:39.695]     {
[13:34:39.695]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.695]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.695]         do.call(mapply, args = args)
[13:34:39.695]     }
[13:34:39.695] }
[13:34:39.695] Lazy evaluation: FALSE
[13:34:39.695] Asynchronous evaluation: TRUE
[13:34:39.695] Local evaluation: TRUE
[13:34:39.695] Environment: R_GlobalEnv
[13:34:39.695] Capture standard output: TRUE
[13:34:39.695] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.695] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.695] Packages: <none>
[13:34:39.695] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.695] Resolved: FALSE
[13:34:39.695] Value: <not collected>
[13:34:39.695] Conditions captured: <none>
[13:34:39.695] Early signaling: FALSE
[13:34:39.695] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.695] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.707] Chunk #1 of 2 ... DONE
[13:34:39.707] Chunk #2 of 2 ...
[13:34:39.707]  - Finding globals in '...' for chunk #2 ...
[13:34:39.707] getGlobalsAndPackages() ...
[13:34:39.707] Searching for globals...
[13:34:39.708] 
[13:34:39.708] Searching for globals ... DONE
[13:34:39.708] - globals: [0] <none>
[13:34:39.708] getGlobalsAndPackages() ... DONE
[13:34:39.708]    + additional globals found: [n=0] 
[13:34:39.708]    + additional namespaces needed: [n=0] 
[13:34:39.708]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:39.708]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:39.708]  - seeds: <none>
[13:34:39.708]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.708] getGlobalsAndPackages() ...
[13:34:39.709] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.709] Resolving globals: FALSE
[13:34:39.709] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[13:34:39.709] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:39.710] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.710] 
[13:34:39.710] getGlobalsAndPackages() ... DONE
[13:34:39.710] run() for ‘Future’ ...
[13:34:39.710] - state: ‘created’
[13:34:39.710] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.723] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.724]   - Field: ‘node’
[13:34:39.724]   - Field: ‘label’
[13:34:39.724]   - Field: ‘local’
[13:34:39.724]   - Field: ‘owner’
[13:34:39.724]   - Field: ‘envir’
[13:34:39.724]   - Field: ‘workers’
[13:34:39.724]   - Field: ‘packages’
[13:34:39.724]   - Field: ‘gc’
[13:34:39.724]   - Field: ‘conditions’
[13:34:39.725]   - Field: ‘persistent’
[13:34:39.725]   - Field: ‘expr’
[13:34:39.725]   - Field: ‘uuid’
[13:34:39.725]   - Field: ‘seed’
[13:34:39.725]   - Field: ‘version’
[13:34:39.725]   - Field: ‘result’
[13:34:39.725]   - Field: ‘asynchronous’
[13:34:39.725]   - Field: ‘calls’
[13:34:39.725]   - Field: ‘globals’
[13:34:39.725]   - Field: ‘stdout’
[13:34:39.725]   - Field: ‘earlySignal’
[13:34:39.726]   - Field: ‘lazy’
[13:34:39.726]   - Field: ‘state’
[13:34:39.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.726] - Launch lazy future ...
[13:34:39.726] Packages needed by the future expression (n = 0): <none>
[13:34:39.726] Packages needed by future strategies (n = 0): <none>
[13:34:39.727] {
[13:34:39.727]     {
[13:34:39.727]         {
[13:34:39.727]             ...future.startTime <- base::Sys.time()
[13:34:39.727]             {
[13:34:39.727]                 {
[13:34:39.727]                   {
[13:34:39.727]                     {
[13:34:39.727]                       base::local({
[13:34:39.727]                         has_future <- base::requireNamespace("future", 
[13:34:39.727]                           quietly = TRUE)
[13:34:39.727]                         if (has_future) {
[13:34:39.727]                           ns <- base::getNamespace("future")
[13:34:39.727]                           version <- ns[[".package"]][["version"]]
[13:34:39.727]                           if (is.null(version)) 
[13:34:39.727]                             version <- utils::packageVersion("future")
[13:34:39.727]                         }
[13:34:39.727]                         else {
[13:34:39.727]                           version <- NULL
[13:34:39.727]                         }
[13:34:39.727]                         if (!has_future || version < "1.8.0") {
[13:34:39.727]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.727]                             "", base::R.version$version.string), 
[13:34:39.727]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.727]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.727]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.727]                               "release", "version")], collapse = " "), 
[13:34:39.727]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.727]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.727]                             info)
[13:34:39.727]                           info <- base::paste(info, collapse = "; ")
[13:34:39.727]                           if (!has_future) {
[13:34:39.727]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.727]                               info)
[13:34:39.727]                           }
[13:34:39.727]                           else {
[13:34:39.727]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.727]                               info, version)
[13:34:39.727]                           }
[13:34:39.727]                           base::stop(msg)
[13:34:39.727]                         }
[13:34:39.727]                       })
[13:34:39.727]                     }
[13:34:39.727]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.727]                     base::options(mc.cores = 1L)
[13:34:39.727]                   }
[13:34:39.727]                   ...future.strategy.old <- future::plan("list")
[13:34:39.727]                   options(future.plan = NULL)
[13:34:39.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.727]                 }
[13:34:39.727]                 ...future.workdir <- getwd()
[13:34:39.727]             }
[13:34:39.727]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.727]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.727]         }
[13:34:39.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.727]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:39.727]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.727]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.727]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.727]             base::names(...future.oldOptions))
[13:34:39.727]     }
[13:34:39.727]     if (FALSE) {
[13:34:39.727]     }
[13:34:39.727]     else {
[13:34:39.727]         if (TRUE) {
[13:34:39.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.727]                 open = "w")
[13:34:39.727]         }
[13:34:39.727]         else {
[13:34:39.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.727]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.727]         }
[13:34:39.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.727]             base::sink(type = "output", split = FALSE)
[13:34:39.727]             base::close(...future.stdout)
[13:34:39.727]         }, add = TRUE)
[13:34:39.727]     }
[13:34:39.727]     ...future.frame <- base::sys.nframe()
[13:34:39.727]     ...future.conditions <- base::list()
[13:34:39.727]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.727]     if (FALSE) {
[13:34:39.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.727]     }
[13:34:39.727]     ...future.result <- base::tryCatch({
[13:34:39.727]         base::withCallingHandlers({
[13:34:39.727]             ...future.value <- base::withVisible(base::local({
[13:34:39.727]                 ...future.makeSendCondition <- base::local({
[13:34:39.727]                   sendCondition <- NULL
[13:34:39.727]                   function(frame = 1L) {
[13:34:39.727]                     if (is.function(sendCondition)) 
[13:34:39.727]                       return(sendCondition)
[13:34:39.727]                     ns <- getNamespace("parallel")
[13:34:39.727]                     if (exists("sendData", mode = "function", 
[13:34:39.727]                       envir = ns)) {
[13:34:39.727]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.727]                         envir = ns)
[13:34:39.727]                       envir <- sys.frame(frame)
[13:34:39.727]                       master <- NULL
[13:34:39.727]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.727]                         !identical(envir, emptyenv())) {
[13:34:39.727]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.727]                           inherits = FALSE)) {
[13:34:39.727]                           master <- get("master", mode = "list", 
[13:34:39.727]                             envir = envir, inherits = FALSE)
[13:34:39.727]                           if (inherits(master, c("SOCKnode", 
[13:34:39.727]                             "SOCK0node"))) {
[13:34:39.727]                             sendCondition <<- function(cond) {
[13:34:39.727]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.727]                                 success = TRUE)
[13:34:39.727]                               parallel_sendData(master, data)
[13:34:39.727]                             }
[13:34:39.727]                             return(sendCondition)
[13:34:39.727]                           }
[13:34:39.727]                         }
[13:34:39.727]                         frame <- frame + 1L
[13:34:39.727]                         envir <- sys.frame(frame)
[13:34:39.727]                       }
[13:34:39.727]                     }
[13:34:39.727]                     sendCondition <<- function(cond) NULL
[13:34:39.727]                   }
[13:34:39.727]                 })
[13:34:39.727]                 withCallingHandlers({
[13:34:39.727]                   {
[13:34:39.727]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.727]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.727]                       ...future.globals.maxSize)) {
[13:34:39.727]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.727]                       on.exit(options(oopts), add = TRUE)
[13:34:39.727]                     }
[13:34:39.727]                     {
[13:34:39.727]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.727]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.727]                         USE.NAMES = FALSE)
[13:34:39.727]                       do.call(mapply, args = args)
[13:34:39.727]                     }
[13:34:39.727]                   }
[13:34:39.727]                 }, immediateCondition = function(cond) {
[13:34:39.727]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.727]                   sendCondition(cond)
[13:34:39.727]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.727]                   {
[13:34:39.727]                     inherits <- base::inherits
[13:34:39.727]                     invokeRestart <- base::invokeRestart
[13:34:39.727]                     is.null <- base::is.null
[13:34:39.727]                     muffled <- FALSE
[13:34:39.727]                     if (inherits(cond, "message")) {
[13:34:39.727]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.727]                       if (muffled) 
[13:34:39.727]                         invokeRestart("muffleMessage")
[13:34:39.727]                     }
[13:34:39.727]                     else if (inherits(cond, "warning")) {
[13:34:39.727]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.727]                       if (muffled) 
[13:34:39.727]                         invokeRestart("muffleWarning")
[13:34:39.727]                     }
[13:34:39.727]                     else if (inherits(cond, "condition")) {
[13:34:39.727]                       if (!is.null(pattern)) {
[13:34:39.727]                         computeRestarts <- base::computeRestarts
[13:34:39.727]                         grepl <- base::grepl
[13:34:39.727]                         restarts <- computeRestarts(cond)
[13:34:39.727]                         for (restart in restarts) {
[13:34:39.727]                           name <- restart$name
[13:34:39.727]                           if (is.null(name)) 
[13:34:39.727]                             next
[13:34:39.727]                           if (!grepl(pattern, name)) 
[13:34:39.727]                             next
[13:34:39.727]                           invokeRestart(restart)
[13:34:39.727]                           muffled <- TRUE
[13:34:39.727]                           break
[13:34:39.727]                         }
[13:34:39.727]                       }
[13:34:39.727]                     }
[13:34:39.727]                     invisible(muffled)
[13:34:39.727]                   }
[13:34:39.727]                   muffleCondition(cond)
[13:34:39.727]                 })
[13:34:39.727]             }))
[13:34:39.727]             future::FutureResult(value = ...future.value$value, 
[13:34:39.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.727]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.727]                     ...future.globalenv.names))
[13:34:39.727]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.727]         }, condition = base::local({
[13:34:39.727]             c <- base::c
[13:34:39.727]             inherits <- base::inherits
[13:34:39.727]             invokeRestart <- base::invokeRestart
[13:34:39.727]             length <- base::length
[13:34:39.727]             list <- base::list
[13:34:39.727]             seq.int <- base::seq.int
[13:34:39.727]             signalCondition <- base::signalCondition
[13:34:39.727]             sys.calls <- base::sys.calls
[13:34:39.727]             `[[` <- base::`[[`
[13:34:39.727]             `+` <- base::`+`
[13:34:39.727]             `<<-` <- base::`<<-`
[13:34:39.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.727]                   3L)]
[13:34:39.727]             }
[13:34:39.727]             function(cond) {
[13:34:39.727]                 is_error <- inherits(cond, "error")
[13:34:39.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.727]                   NULL)
[13:34:39.727]                 if (is_error) {
[13:34:39.727]                   sessionInformation <- function() {
[13:34:39.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.727]                       search = base::search(), system = base::Sys.info())
[13:34:39.727]                   }
[13:34:39.727]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.727]                     cond$call), session = sessionInformation(), 
[13:34:39.727]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.727]                   signalCondition(cond)
[13:34:39.727]                 }
[13:34:39.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.727]                 "immediateCondition"))) {
[13:34:39.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.727]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.727]                   if (TRUE && !signal) {
[13:34:39.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.727]                     {
[13:34:39.727]                       inherits <- base::inherits
[13:34:39.727]                       invokeRestart <- base::invokeRestart
[13:34:39.727]                       is.null <- base::is.null
[13:34:39.727]                       muffled <- FALSE
[13:34:39.727]                       if (inherits(cond, "message")) {
[13:34:39.727]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.727]                         if (muffled) 
[13:34:39.727]                           invokeRestart("muffleMessage")
[13:34:39.727]                       }
[13:34:39.727]                       else if (inherits(cond, "warning")) {
[13:34:39.727]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.727]                         if (muffled) 
[13:34:39.727]                           invokeRestart("muffleWarning")
[13:34:39.727]                       }
[13:34:39.727]                       else if (inherits(cond, "condition")) {
[13:34:39.727]                         if (!is.null(pattern)) {
[13:34:39.727]                           computeRestarts <- base::computeRestarts
[13:34:39.727]                           grepl <- base::grepl
[13:34:39.727]                           restarts <- computeRestarts(cond)
[13:34:39.727]                           for (restart in restarts) {
[13:34:39.727]                             name <- restart$name
[13:34:39.727]                             if (is.null(name)) 
[13:34:39.727]                               next
[13:34:39.727]                             if (!grepl(pattern, name)) 
[13:34:39.727]                               next
[13:34:39.727]                             invokeRestart(restart)
[13:34:39.727]                             muffled <- TRUE
[13:34:39.727]                             break
[13:34:39.727]                           }
[13:34:39.727]                         }
[13:34:39.727]                       }
[13:34:39.727]                       invisible(muffled)
[13:34:39.727]                     }
[13:34:39.727]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.727]                   }
[13:34:39.727]                 }
[13:34:39.727]                 else {
[13:34:39.727]                   if (TRUE) {
[13:34:39.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.727]                     {
[13:34:39.727]                       inherits <- base::inherits
[13:34:39.727]                       invokeRestart <- base::invokeRestart
[13:34:39.727]                       is.null <- base::is.null
[13:34:39.727]                       muffled <- FALSE
[13:34:39.727]                       if (inherits(cond, "message")) {
[13:34:39.727]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.727]                         if (muffled) 
[13:34:39.727]                           invokeRestart("muffleMessage")
[13:34:39.727]                       }
[13:34:39.727]                       else if (inherits(cond, "warning")) {
[13:34:39.727]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.727]                         if (muffled) 
[13:34:39.727]                           invokeRestart("muffleWarning")
[13:34:39.727]                       }
[13:34:39.727]                       else if (inherits(cond, "condition")) {
[13:34:39.727]                         if (!is.null(pattern)) {
[13:34:39.727]                           computeRestarts <- base::computeRestarts
[13:34:39.727]                           grepl <- base::grepl
[13:34:39.727]                           restarts <- computeRestarts(cond)
[13:34:39.727]                           for (restart in restarts) {
[13:34:39.727]                             name <- restart$name
[13:34:39.727]                             if (is.null(name)) 
[13:34:39.727]                               next
[13:34:39.727]                             if (!grepl(pattern, name)) 
[13:34:39.727]                               next
[13:34:39.727]                             invokeRestart(restart)
[13:34:39.727]                             muffled <- TRUE
[13:34:39.727]                             break
[13:34:39.727]                           }
[13:34:39.727]                         }
[13:34:39.727]                       }
[13:34:39.727]                       invisible(muffled)
[13:34:39.727]                     }
[13:34:39.727]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.727]                   }
[13:34:39.727]                 }
[13:34:39.727]             }
[13:34:39.727]         }))
[13:34:39.727]     }, error = function(ex) {
[13:34:39.727]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.727]                 ...future.rng), started = ...future.startTime, 
[13:34:39.727]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.727]             version = "1.8"), class = "FutureResult")
[13:34:39.727]     }, finally = {
[13:34:39.727]         if (!identical(...future.workdir, getwd())) 
[13:34:39.727]             setwd(...future.workdir)
[13:34:39.727]         {
[13:34:39.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.727]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.727]             }
[13:34:39.727]             base::options(...future.oldOptions)
[13:34:39.727]             if (.Platform$OS.type == "windows") {
[13:34:39.727]                 old_names <- names(...future.oldEnvVars)
[13:34:39.727]                 envs <- base::Sys.getenv()
[13:34:39.727]                 names <- names(envs)
[13:34:39.727]                 common <- intersect(names, old_names)
[13:34:39.727]                 added <- setdiff(names, old_names)
[13:34:39.727]                 removed <- setdiff(old_names, names)
[13:34:39.727]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.727]                   envs[common]]
[13:34:39.727]                 NAMES <- toupper(changed)
[13:34:39.727]                 args <- list()
[13:34:39.727]                 for (kk in seq_along(NAMES)) {
[13:34:39.727]                   name <- changed[[kk]]
[13:34:39.727]                   NAME <- NAMES[[kk]]
[13:34:39.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.727]                     next
[13:34:39.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.727]                 }
[13:34:39.727]                 NAMES <- toupper(added)
[13:34:39.727]                 for (kk in seq_along(NAMES)) {
[13:34:39.727]                   name <- added[[kk]]
[13:34:39.727]                   NAME <- NAMES[[kk]]
[13:34:39.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.727]                     next
[13:34:39.727]                   args[[name]] <- ""
[13:34:39.727]                 }
[13:34:39.727]                 NAMES <- toupper(removed)
[13:34:39.727]                 for (kk in seq_along(NAMES)) {
[13:34:39.727]                   name <- removed[[kk]]
[13:34:39.727]                   NAME <- NAMES[[kk]]
[13:34:39.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.727]                     next
[13:34:39.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.727]                 }
[13:34:39.727]                 if (length(args) > 0) 
[13:34:39.727]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.727]             }
[13:34:39.727]             else {
[13:34:39.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.727]             }
[13:34:39.727]             {
[13:34:39.727]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.727]                   0L) {
[13:34:39.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.727]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.727]                   base::options(opts)
[13:34:39.727]                 }
[13:34:39.727]                 {
[13:34:39.727]                   {
[13:34:39.727]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.727]                     NULL
[13:34:39.727]                   }
[13:34:39.727]                   options(future.plan = NULL)
[13:34:39.727]                   if (is.na(NA_character_)) 
[13:34:39.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.727]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.727]                     .init = FALSE)
[13:34:39.727]                 }
[13:34:39.727]             }
[13:34:39.727]         }
[13:34:39.727]     })
[13:34:39.727]     if (TRUE) {
[13:34:39.727]         base::sink(type = "output", split = FALSE)
[13:34:39.727]         if (TRUE) {
[13:34:39.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.727]         }
[13:34:39.727]         else {
[13:34:39.727]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.727]         }
[13:34:39.727]         base::close(...future.stdout)
[13:34:39.727]         ...future.stdout <- NULL
[13:34:39.727]     }
[13:34:39.727]     ...future.result$conditions <- ...future.conditions
[13:34:39.727]     ...future.result$finished <- base::Sys.time()
[13:34:39.727]     ...future.result
[13:34:39.727] }
[13:34:39.729] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[13:34:39.729] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[13:34:39.730] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[13:34:39.730] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:39.730] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.730] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[13:34:39.731] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[13:34:39.731] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:39.731] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.731] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:39.731] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.731] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[13:34:39.732] MultisessionFuture started
[13:34:39.732] - Launch lazy future ... done
[13:34:39.732] run() for ‘MultisessionFuture’ ... done
[13:34:39.732] Created future:
[13:34:39.732] MultisessionFuture:
[13:34:39.732] Label: ‘future_mapply-2’
[13:34:39.732] Expression:
[13:34:39.732] {
[13:34:39.732]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.732]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.732]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.732]         on.exit(options(oopts), add = TRUE)
[13:34:39.732]     }
[13:34:39.732]     {
[13:34:39.732]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.732]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.732]         do.call(mapply, args = args)
[13:34:39.732]     }
[13:34:39.732] }
[13:34:39.732] Lazy evaluation: FALSE
[13:34:39.732] Asynchronous evaluation: TRUE
[13:34:39.732] Local evaluation: TRUE
[13:34:39.732] Environment: R_GlobalEnv
[13:34:39.732] Capture standard output: TRUE
[13:34:39.732] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.732] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.732] Packages: <none>
[13:34:39.732] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.732] Resolved: FALSE
[13:34:39.732] Value: <not collected>
[13:34:39.732] Conditions captured: <none>
[13:34:39.732] Early signaling: FALSE
[13:34:39.732] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.732] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.744] Chunk #2 of 2 ... DONE
[13:34:39.744] Launching 2 futures (chunks) ... DONE
[13:34:39.744] Resolving 2 futures (chunks) ...
[13:34:39.744] resolve() on list ...
[13:34:39.744]  recursive: 0
[13:34:39.744]  length: 2
[13:34:39.744] 
[13:34:39.745] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.745] - Validating connection of MultisessionFuture
[13:34:39.745] - received message: FutureResult
[13:34:39.745] - Received FutureResult
[13:34:39.745] - Erased future from FutureRegistry
[13:34:39.745] result() for ClusterFuture ...
[13:34:39.745] - result already collected: FutureResult
[13:34:39.745] result() for ClusterFuture ... done
[13:34:39.745] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.746] Future #1
[13:34:39.746] result() for ClusterFuture ...
[13:34:39.746] - result already collected: FutureResult
[13:34:39.746] result() for ClusterFuture ... done
[13:34:39.746] result() for ClusterFuture ...
[13:34:39.746] - result already collected: FutureResult
[13:34:39.746] result() for ClusterFuture ... done
[13:34:39.746] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:39.746] - nx: 2
[13:34:39.746] - relay: TRUE
[13:34:39.746] - stdout: TRUE
[13:34:39.747] - signal: TRUE
[13:34:39.747] - resignal: FALSE
[13:34:39.747] - force: TRUE
[13:34:39.747] - relayed: [n=2] FALSE, FALSE
[13:34:39.747] - queued futures: [n=2] FALSE, FALSE
[13:34:39.747]  - until=1
[13:34:39.747]  - relaying element #1
[13:34:39.747] result() for ClusterFuture ...
[13:34:39.747] - result already collected: FutureResult
[13:34:39.747] result() for ClusterFuture ... done
[13:34:39.747] result() for ClusterFuture ...
[13:34:39.747] - result already collected: FutureResult
[13:34:39.748] result() for ClusterFuture ... done
[13:34:39.748] result() for ClusterFuture ...
[13:34:39.748] - result already collected: FutureResult
[13:34:39.748] result() for ClusterFuture ... done
[13:34:39.748] result() for ClusterFuture ...
[13:34:39.748] - result already collected: FutureResult
[13:34:39.748] result() for ClusterFuture ... done
[13:34:39.748] - relayed: [n=2] TRUE, FALSE
[13:34:39.748] - queued futures: [n=2] TRUE, FALSE
[13:34:39.748] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:39.748]  length: 1 (resolved future 1)
[13:34:39.776] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.776] - Validating connection of MultisessionFuture
[13:34:39.776] - received message: FutureResult
[13:34:39.776] - Received FutureResult
[13:34:39.776] - Erased future from FutureRegistry
[13:34:39.776] result() for ClusterFuture ...
[13:34:39.776] - result already collected: FutureResult
[13:34:39.776] result() for ClusterFuture ... done
[13:34:39.777] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.779] Future #2
[13:34:39.779] result() for ClusterFuture ...
[13:34:39.780] - result already collected: FutureResult
[13:34:39.780] result() for ClusterFuture ... done
[13:34:39.780] result() for ClusterFuture ...
[13:34:39.780] - result already collected: FutureResult
[13:34:39.780] result() for ClusterFuture ... done
[13:34:39.780] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:39.780] - nx: 2
[13:34:39.780] - relay: TRUE
[13:34:39.780] - stdout: TRUE
[13:34:39.780] - signal: TRUE
[13:34:39.780] - resignal: FALSE
[13:34:39.781] - force: TRUE
[13:34:39.781] - relayed: [n=2] TRUE, FALSE
[13:34:39.781] - queued futures: [n=2] TRUE, FALSE
[13:34:39.781]  - until=2
[13:34:39.781]  - relaying element #2
[13:34:39.781] result() for ClusterFuture ...
[13:34:39.781] - result already collected: FutureResult
[13:34:39.781] result() for ClusterFuture ... done
[13:34:39.781] result() for ClusterFuture ...
[13:34:39.781] - result already collected: FutureResult
[13:34:39.781] result() for ClusterFuture ... done
[13:34:39.782] result() for ClusterFuture ...
[13:34:39.782] - result already collected: FutureResult
[13:34:39.782] result() for ClusterFuture ... done
[13:34:39.782] result() for ClusterFuture ...
[13:34:39.782] - result already collected: FutureResult
[13:34:39.782] result() for ClusterFuture ... done
[13:34:39.782] - relayed: [n=2] TRUE, TRUE
[13:34:39.782] - queued futures: [n=2] TRUE, TRUE
[13:34:39.782] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:39.782]  length: 0 (resolved future 2)
[13:34:39.783] Relaying remaining futures
[13:34:39.783] signalConditionsASAP(NULL, pos=0) ...
[13:34:39.783] - nx: 2
[13:34:39.783] - relay: TRUE
[13:34:39.783] - stdout: TRUE
[13:34:39.783] - signal: TRUE
[13:34:39.783] - resignal: FALSE
[13:34:39.783] - force: TRUE
[13:34:39.783] - relayed: [n=2] TRUE, TRUE
[13:34:39.783] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:39.783] - relayed: [n=2] TRUE, TRUE
[13:34:39.783] - queued futures: [n=2] TRUE, TRUE
[13:34:39.784] signalConditionsASAP(NULL, pos=0) ... done
[13:34:39.784] resolve() on list ... DONE
[13:34:39.784] result() for ClusterFuture ...
[13:34:39.784] - result already collected: FutureResult
[13:34:39.784] result() for ClusterFuture ... done
[13:34:39.784] result() for ClusterFuture ...
[13:34:39.784] - result already collected: FutureResult
[13:34:39.784] result() for ClusterFuture ... done
[13:34:39.784] result() for ClusterFuture ...
[13:34:39.784] - result already collected: FutureResult
[13:34:39.784] result() for ClusterFuture ... done
[13:34:39.784] result() for ClusterFuture ...
[13:34:39.785] - result already collected: FutureResult
[13:34:39.785] result() for ClusterFuture ... done
[13:34:39.785]  - Number of value chunks collected: 2
[13:34:39.785] Resolving 2 futures (chunks) ... DONE
[13:34:39.785] Reducing values from 2 chunks ...
[13:34:39.785]  - Number of values collected after concatenation: 5
[13:34:39.785]  - Number of values expected: 5
[13:34:39.785] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[13:34:39.785] Reducing values from 2 chunks ... DONE
[13:34:39.785] future_mapply() ... DONE
[13:34:39.786] future_mapply() ...
[13:34:39.789] Number of chunks: 2
[13:34:39.789] getGlobalsAndPackagesXApply() ...
[13:34:39.789]  - future.globals: TRUE
[13:34:39.790] getGlobalsAndPackages() ...
[13:34:39.790] Searching for globals...
[13:34:39.791] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[13:34:39.791] Searching for globals ... DONE
[13:34:39.791] Resolving globals: FALSE
[13:34:39.791] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[13:34:39.792] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[13:34:39.792] - globals: [1] ‘FUN’
[13:34:39.792] 
[13:34:39.792] getGlobalsAndPackages() ... DONE
[13:34:39.792]  - globals found/used: [n=1] ‘FUN’
[13:34:39.792]  - needed namespaces: [n=0] 
[13:34:39.792] Finding globals ... DONE
[13:34:39.792] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:39.793] List of 2
[13:34:39.793]  $ ...future.FUN:function (C, k)  
[13:34:39.793]  $ MoreArgs     : list()
[13:34:39.793]  - attr(*, "where")=List of 2
[13:34:39.793]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:39.793]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:39.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:39.793]  - attr(*, "resolved")= logi FALSE
[13:34:39.793]  - attr(*, "total_size")= num NA
[13:34:39.795] Packages to be attached in all futures: [n=0] 
[13:34:39.795] getGlobalsAndPackagesXApply() ... DONE
[13:34:39.795] Number of futures (= number of chunks): 2
[13:34:39.795] Launching 2 futures (chunks) ...
[13:34:39.795] Chunk #1 of 2 ...
[13:34:39.796]  - Finding globals in '...' for chunk #1 ...
[13:34:39.796] getGlobalsAndPackages() ...
[13:34:39.796] Searching for globals...
[13:34:39.796] 
[13:34:39.796] Searching for globals ... DONE
[13:34:39.796] - globals: [0] <none>
[13:34:39.796] getGlobalsAndPackages() ... DONE
[13:34:39.796]    + additional globals found: [n=0] 
[13:34:39.796]    + additional namespaces needed: [n=0] 
[13:34:39.797]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:39.797]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:39.797]  - seeds: <none>
[13:34:39.797]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.797] getGlobalsAndPackages() ...
[13:34:39.797] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.797] Resolving globals: FALSE
[13:34:39.798] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[13:34:39.798] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:39.798] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.798] 
[13:34:39.798] getGlobalsAndPackages() ... DONE
[13:34:39.799] run() for ‘Future’ ...
[13:34:39.799] - state: ‘created’
[13:34:39.799] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.812] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.813]   - Field: ‘node’
[13:34:39.813]   - Field: ‘label’
[13:34:39.813]   - Field: ‘local’
[13:34:39.813]   - Field: ‘owner’
[13:34:39.813]   - Field: ‘envir’
[13:34:39.813]   - Field: ‘workers’
[13:34:39.813]   - Field: ‘packages’
[13:34:39.813]   - Field: ‘gc’
[13:34:39.813]   - Field: ‘conditions’
[13:34:39.814]   - Field: ‘persistent’
[13:34:39.814]   - Field: ‘expr’
[13:34:39.814]   - Field: ‘uuid’
[13:34:39.814]   - Field: ‘seed’
[13:34:39.814]   - Field: ‘version’
[13:34:39.814]   - Field: ‘result’
[13:34:39.814]   - Field: ‘asynchronous’
[13:34:39.814]   - Field: ‘calls’
[13:34:39.814]   - Field: ‘globals’
[13:34:39.814]   - Field: ‘stdout’
[13:34:39.814]   - Field: ‘earlySignal’
[13:34:39.815]   - Field: ‘lazy’
[13:34:39.815]   - Field: ‘state’
[13:34:39.815] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.815] - Launch lazy future ...
[13:34:39.815] Packages needed by the future expression (n = 0): <none>
[13:34:39.815] Packages needed by future strategies (n = 0): <none>
[13:34:39.816] {
[13:34:39.816]     {
[13:34:39.816]         {
[13:34:39.816]             ...future.startTime <- base::Sys.time()
[13:34:39.816]             {
[13:34:39.816]                 {
[13:34:39.816]                   {
[13:34:39.816]                     {
[13:34:39.816]                       base::local({
[13:34:39.816]                         has_future <- base::requireNamespace("future", 
[13:34:39.816]                           quietly = TRUE)
[13:34:39.816]                         if (has_future) {
[13:34:39.816]                           ns <- base::getNamespace("future")
[13:34:39.816]                           version <- ns[[".package"]][["version"]]
[13:34:39.816]                           if (is.null(version)) 
[13:34:39.816]                             version <- utils::packageVersion("future")
[13:34:39.816]                         }
[13:34:39.816]                         else {
[13:34:39.816]                           version <- NULL
[13:34:39.816]                         }
[13:34:39.816]                         if (!has_future || version < "1.8.0") {
[13:34:39.816]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.816]                             "", base::R.version$version.string), 
[13:34:39.816]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.816]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.816]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.816]                               "release", "version")], collapse = " "), 
[13:34:39.816]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.816]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.816]                             info)
[13:34:39.816]                           info <- base::paste(info, collapse = "; ")
[13:34:39.816]                           if (!has_future) {
[13:34:39.816]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.816]                               info)
[13:34:39.816]                           }
[13:34:39.816]                           else {
[13:34:39.816]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.816]                               info, version)
[13:34:39.816]                           }
[13:34:39.816]                           base::stop(msg)
[13:34:39.816]                         }
[13:34:39.816]                       })
[13:34:39.816]                     }
[13:34:39.816]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.816]                     base::options(mc.cores = 1L)
[13:34:39.816]                   }
[13:34:39.816]                   ...future.strategy.old <- future::plan("list")
[13:34:39.816]                   options(future.plan = NULL)
[13:34:39.816]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.816]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.816]                 }
[13:34:39.816]                 ...future.workdir <- getwd()
[13:34:39.816]             }
[13:34:39.816]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.816]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.816]         }
[13:34:39.816]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.816]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:39.816]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.816]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.816]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.816]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.816]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.816]             base::names(...future.oldOptions))
[13:34:39.816]     }
[13:34:39.816]     if (FALSE) {
[13:34:39.816]     }
[13:34:39.816]     else {
[13:34:39.816]         if (TRUE) {
[13:34:39.816]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.816]                 open = "w")
[13:34:39.816]         }
[13:34:39.816]         else {
[13:34:39.816]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.816]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.816]         }
[13:34:39.816]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.816]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.816]             base::sink(type = "output", split = FALSE)
[13:34:39.816]             base::close(...future.stdout)
[13:34:39.816]         }, add = TRUE)
[13:34:39.816]     }
[13:34:39.816]     ...future.frame <- base::sys.nframe()
[13:34:39.816]     ...future.conditions <- base::list()
[13:34:39.816]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.816]     if (FALSE) {
[13:34:39.816]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.816]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.816]     }
[13:34:39.816]     ...future.result <- base::tryCatch({
[13:34:39.816]         base::withCallingHandlers({
[13:34:39.816]             ...future.value <- base::withVisible(base::local({
[13:34:39.816]                 ...future.makeSendCondition <- base::local({
[13:34:39.816]                   sendCondition <- NULL
[13:34:39.816]                   function(frame = 1L) {
[13:34:39.816]                     if (is.function(sendCondition)) 
[13:34:39.816]                       return(sendCondition)
[13:34:39.816]                     ns <- getNamespace("parallel")
[13:34:39.816]                     if (exists("sendData", mode = "function", 
[13:34:39.816]                       envir = ns)) {
[13:34:39.816]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.816]                         envir = ns)
[13:34:39.816]                       envir <- sys.frame(frame)
[13:34:39.816]                       master <- NULL
[13:34:39.816]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.816]                         !identical(envir, emptyenv())) {
[13:34:39.816]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.816]                           inherits = FALSE)) {
[13:34:39.816]                           master <- get("master", mode = "list", 
[13:34:39.816]                             envir = envir, inherits = FALSE)
[13:34:39.816]                           if (inherits(master, c("SOCKnode", 
[13:34:39.816]                             "SOCK0node"))) {
[13:34:39.816]                             sendCondition <<- function(cond) {
[13:34:39.816]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.816]                                 success = TRUE)
[13:34:39.816]                               parallel_sendData(master, data)
[13:34:39.816]                             }
[13:34:39.816]                             return(sendCondition)
[13:34:39.816]                           }
[13:34:39.816]                         }
[13:34:39.816]                         frame <- frame + 1L
[13:34:39.816]                         envir <- sys.frame(frame)
[13:34:39.816]                       }
[13:34:39.816]                     }
[13:34:39.816]                     sendCondition <<- function(cond) NULL
[13:34:39.816]                   }
[13:34:39.816]                 })
[13:34:39.816]                 withCallingHandlers({
[13:34:39.816]                   {
[13:34:39.816]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.816]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.816]                       ...future.globals.maxSize)) {
[13:34:39.816]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.816]                       on.exit(options(oopts), add = TRUE)
[13:34:39.816]                     }
[13:34:39.816]                     {
[13:34:39.816]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.816]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.816]                         USE.NAMES = FALSE)
[13:34:39.816]                       do.call(mapply, args = args)
[13:34:39.816]                     }
[13:34:39.816]                   }
[13:34:39.816]                 }, immediateCondition = function(cond) {
[13:34:39.816]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.816]                   sendCondition(cond)
[13:34:39.816]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.816]                   {
[13:34:39.816]                     inherits <- base::inherits
[13:34:39.816]                     invokeRestart <- base::invokeRestart
[13:34:39.816]                     is.null <- base::is.null
[13:34:39.816]                     muffled <- FALSE
[13:34:39.816]                     if (inherits(cond, "message")) {
[13:34:39.816]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.816]                       if (muffled) 
[13:34:39.816]                         invokeRestart("muffleMessage")
[13:34:39.816]                     }
[13:34:39.816]                     else if (inherits(cond, "warning")) {
[13:34:39.816]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.816]                       if (muffled) 
[13:34:39.816]                         invokeRestart("muffleWarning")
[13:34:39.816]                     }
[13:34:39.816]                     else if (inherits(cond, "condition")) {
[13:34:39.816]                       if (!is.null(pattern)) {
[13:34:39.816]                         computeRestarts <- base::computeRestarts
[13:34:39.816]                         grepl <- base::grepl
[13:34:39.816]                         restarts <- computeRestarts(cond)
[13:34:39.816]                         for (restart in restarts) {
[13:34:39.816]                           name <- restart$name
[13:34:39.816]                           if (is.null(name)) 
[13:34:39.816]                             next
[13:34:39.816]                           if (!grepl(pattern, name)) 
[13:34:39.816]                             next
[13:34:39.816]                           invokeRestart(restart)
[13:34:39.816]                           muffled <- TRUE
[13:34:39.816]                           break
[13:34:39.816]                         }
[13:34:39.816]                       }
[13:34:39.816]                     }
[13:34:39.816]                     invisible(muffled)
[13:34:39.816]                   }
[13:34:39.816]                   muffleCondition(cond)
[13:34:39.816]                 })
[13:34:39.816]             }))
[13:34:39.816]             future::FutureResult(value = ...future.value$value, 
[13:34:39.816]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.816]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.816]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.816]                     ...future.globalenv.names))
[13:34:39.816]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.816]         }, condition = base::local({
[13:34:39.816]             c <- base::c
[13:34:39.816]             inherits <- base::inherits
[13:34:39.816]             invokeRestart <- base::invokeRestart
[13:34:39.816]             length <- base::length
[13:34:39.816]             list <- base::list
[13:34:39.816]             seq.int <- base::seq.int
[13:34:39.816]             signalCondition <- base::signalCondition
[13:34:39.816]             sys.calls <- base::sys.calls
[13:34:39.816]             `[[` <- base::`[[`
[13:34:39.816]             `+` <- base::`+`
[13:34:39.816]             `<<-` <- base::`<<-`
[13:34:39.816]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.816]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.816]                   3L)]
[13:34:39.816]             }
[13:34:39.816]             function(cond) {
[13:34:39.816]                 is_error <- inherits(cond, "error")
[13:34:39.816]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.816]                   NULL)
[13:34:39.816]                 if (is_error) {
[13:34:39.816]                   sessionInformation <- function() {
[13:34:39.816]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.816]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.816]                       search = base::search(), system = base::Sys.info())
[13:34:39.816]                   }
[13:34:39.816]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.816]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.816]                     cond$call), session = sessionInformation(), 
[13:34:39.816]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.816]                   signalCondition(cond)
[13:34:39.816]                 }
[13:34:39.816]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.816]                 "immediateCondition"))) {
[13:34:39.816]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.816]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.816]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.816]                   if (TRUE && !signal) {
[13:34:39.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.816]                     {
[13:34:39.816]                       inherits <- base::inherits
[13:34:39.816]                       invokeRestart <- base::invokeRestart
[13:34:39.816]                       is.null <- base::is.null
[13:34:39.816]                       muffled <- FALSE
[13:34:39.816]                       if (inherits(cond, "message")) {
[13:34:39.816]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.816]                         if (muffled) 
[13:34:39.816]                           invokeRestart("muffleMessage")
[13:34:39.816]                       }
[13:34:39.816]                       else if (inherits(cond, "warning")) {
[13:34:39.816]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.816]                         if (muffled) 
[13:34:39.816]                           invokeRestart("muffleWarning")
[13:34:39.816]                       }
[13:34:39.816]                       else if (inherits(cond, "condition")) {
[13:34:39.816]                         if (!is.null(pattern)) {
[13:34:39.816]                           computeRestarts <- base::computeRestarts
[13:34:39.816]                           grepl <- base::grepl
[13:34:39.816]                           restarts <- computeRestarts(cond)
[13:34:39.816]                           for (restart in restarts) {
[13:34:39.816]                             name <- restart$name
[13:34:39.816]                             if (is.null(name)) 
[13:34:39.816]                               next
[13:34:39.816]                             if (!grepl(pattern, name)) 
[13:34:39.816]                               next
[13:34:39.816]                             invokeRestart(restart)
[13:34:39.816]                             muffled <- TRUE
[13:34:39.816]                             break
[13:34:39.816]                           }
[13:34:39.816]                         }
[13:34:39.816]                       }
[13:34:39.816]                       invisible(muffled)
[13:34:39.816]                     }
[13:34:39.816]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.816]                   }
[13:34:39.816]                 }
[13:34:39.816]                 else {
[13:34:39.816]                   if (TRUE) {
[13:34:39.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.816]                     {
[13:34:39.816]                       inherits <- base::inherits
[13:34:39.816]                       invokeRestart <- base::invokeRestart
[13:34:39.816]                       is.null <- base::is.null
[13:34:39.816]                       muffled <- FALSE
[13:34:39.816]                       if (inherits(cond, "message")) {
[13:34:39.816]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.816]                         if (muffled) 
[13:34:39.816]                           invokeRestart("muffleMessage")
[13:34:39.816]                       }
[13:34:39.816]                       else if (inherits(cond, "warning")) {
[13:34:39.816]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.816]                         if (muffled) 
[13:34:39.816]                           invokeRestart("muffleWarning")
[13:34:39.816]                       }
[13:34:39.816]                       else if (inherits(cond, "condition")) {
[13:34:39.816]                         if (!is.null(pattern)) {
[13:34:39.816]                           computeRestarts <- base::computeRestarts
[13:34:39.816]                           grepl <- base::grepl
[13:34:39.816]                           restarts <- computeRestarts(cond)
[13:34:39.816]                           for (restart in restarts) {
[13:34:39.816]                             name <- restart$name
[13:34:39.816]                             if (is.null(name)) 
[13:34:39.816]                               next
[13:34:39.816]                             if (!grepl(pattern, name)) 
[13:34:39.816]                               next
[13:34:39.816]                             invokeRestart(restart)
[13:34:39.816]                             muffled <- TRUE
[13:34:39.816]                             break
[13:34:39.816]                           }
[13:34:39.816]                         }
[13:34:39.816]                       }
[13:34:39.816]                       invisible(muffled)
[13:34:39.816]                     }
[13:34:39.816]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.816]                   }
[13:34:39.816]                 }
[13:34:39.816]             }
[13:34:39.816]         }))
[13:34:39.816]     }, error = function(ex) {
[13:34:39.816]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.816]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.816]                 ...future.rng), started = ...future.startTime, 
[13:34:39.816]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.816]             version = "1.8"), class = "FutureResult")
[13:34:39.816]     }, finally = {
[13:34:39.816]         if (!identical(...future.workdir, getwd())) 
[13:34:39.816]             setwd(...future.workdir)
[13:34:39.816]         {
[13:34:39.816]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.816]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.816]             }
[13:34:39.816]             base::options(...future.oldOptions)
[13:34:39.816]             if (.Platform$OS.type == "windows") {
[13:34:39.816]                 old_names <- names(...future.oldEnvVars)
[13:34:39.816]                 envs <- base::Sys.getenv()
[13:34:39.816]                 names <- names(envs)
[13:34:39.816]                 common <- intersect(names, old_names)
[13:34:39.816]                 added <- setdiff(names, old_names)
[13:34:39.816]                 removed <- setdiff(old_names, names)
[13:34:39.816]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.816]                   envs[common]]
[13:34:39.816]                 NAMES <- toupper(changed)
[13:34:39.816]                 args <- list()
[13:34:39.816]                 for (kk in seq_along(NAMES)) {
[13:34:39.816]                   name <- changed[[kk]]
[13:34:39.816]                   NAME <- NAMES[[kk]]
[13:34:39.816]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.816]                     next
[13:34:39.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.816]                 }
[13:34:39.816]                 NAMES <- toupper(added)
[13:34:39.816]                 for (kk in seq_along(NAMES)) {
[13:34:39.816]                   name <- added[[kk]]
[13:34:39.816]                   NAME <- NAMES[[kk]]
[13:34:39.816]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.816]                     next
[13:34:39.816]                   args[[name]] <- ""
[13:34:39.816]                 }
[13:34:39.816]                 NAMES <- toupper(removed)
[13:34:39.816]                 for (kk in seq_along(NAMES)) {
[13:34:39.816]                   name <- removed[[kk]]
[13:34:39.816]                   NAME <- NAMES[[kk]]
[13:34:39.816]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.816]                     next
[13:34:39.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.816]                 }
[13:34:39.816]                 if (length(args) > 0) 
[13:34:39.816]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.816]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.816]             }
[13:34:39.816]             else {
[13:34:39.816]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.816]             }
[13:34:39.816]             {
[13:34:39.816]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.816]                   0L) {
[13:34:39.816]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.816]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.816]                   base::options(opts)
[13:34:39.816]                 }
[13:34:39.816]                 {
[13:34:39.816]                   {
[13:34:39.816]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.816]                     NULL
[13:34:39.816]                   }
[13:34:39.816]                   options(future.plan = NULL)
[13:34:39.816]                   if (is.na(NA_character_)) 
[13:34:39.816]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.816]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.816]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.816]                     .init = FALSE)
[13:34:39.816]                 }
[13:34:39.816]             }
[13:34:39.816]         }
[13:34:39.816]     })
[13:34:39.816]     if (TRUE) {
[13:34:39.816]         base::sink(type = "output", split = FALSE)
[13:34:39.816]         if (TRUE) {
[13:34:39.816]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.816]         }
[13:34:39.816]         else {
[13:34:39.816]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.816]         }
[13:34:39.816]         base::close(...future.stdout)
[13:34:39.816]         ...future.stdout <- NULL
[13:34:39.816]     }
[13:34:39.816]     ...future.result$conditions <- ...future.conditions
[13:34:39.816]     ...future.result$finished <- base::Sys.time()
[13:34:39.816]     ...future.result
[13:34:39.816] }
[13:34:39.818] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[13:34:39.818] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[13:34:39.819] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[13:34:39.819] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:39.819] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.819] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[13:34:39.820] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[13:34:39.820] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:39.820] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.820] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:39.821] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.821] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[13:34:39.821] MultisessionFuture started
[13:34:39.822] - Launch lazy future ... done
[13:34:39.822] run() for ‘MultisessionFuture’ ... done
[13:34:39.822] Created future:
[13:34:39.822] MultisessionFuture:
[13:34:39.822] Label: ‘future_.mapply-1’
[13:34:39.822] Expression:
[13:34:39.822] {
[13:34:39.822]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.822]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.822]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.822]         on.exit(options(oopts), add = TRUE)
[13:34:39.822]     }
[13:34:39.822]     {
[13:34:39.822]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.822]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.822]         do.call(mapply, args = args)
[13:34:39.822]     }
[13:34:39.822] }
[13:34:39.822] Lazy evaluation: FALSE
[13:34:39.822] Asynchronous evaluation: TRUE
[13:34:39.822] Local evaluation: TRUE
[13:34:39.822] Environment: R_GlobalEnv
[13:34:39.822] Capture standard output: TRUE
[13:34:39.822] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.822] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.822] Packages: <none>
[13:34:39.822] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.822] Resolved: FALSE
[13:34:39.822] Value: <not collected>
[13:34:39.822] Conditions captured: <none>
[13:34:39.822] Early signaling: FALSE
[13:34:39.822] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.822] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.833] Chunk #1 of 2 ... DONE
[13:34:39.833] Chunk #2 of 2 ...
[13:34:39.834]  - Finding globals in '...' for chunk #2 ...
[13:34:39.834] getGlobalsAndPackages() ...
[13:34:39.834] Searching for globals...
[13:34:39.834] 
[13:34:39.834] Searching for globals ... DONE
[13:34:39.835] - globals: [0] <none>
[13:34:39.835] getGlobalsAndPackages() ... DONE
[13:34:39.835]    + additional globals found: [n=0] 
[13:34:39.835]    + additional namespaces needed: [n=0] 
[13:34:39.835]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:39.835]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:39.835]  - seeds: <none>
[13:34:39.835]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.835] getGlobalsAndPackages() ...
[13:34:39.835] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.835] Resolving globals: FALSE
[13:34:39.836] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[13:34:39.836] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:39.836] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.837] 
[13:34:39.837] getGlobalsAndPackages() ... DONE
[13:34:39.837] run() for ‘Future’ ...
[13:34:39.837] - state: ‘created’
[13:34:39.837] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.850] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.851]   - Field: ‘node’
[13:34:39.851]   - Field: ‘label’
[13:34:39.851]   - Field: ‘local’
[13:34:39.851]   - Field: ‘owner’
[13:34:39.851]   - Field: ‘envir’
[13:34:39.851]   - Field: ‘workers’
[13:34:39.851]   - Field: ‘packages’
[13:34:39.851]   - Field: ‘gc’
[13:34:39.851]   - Field: ‘conditions’
[13:34:39.851]   - Field: ‘persistent’
[13:34:39.851]   - Field: ‘expr’
[13:34:39.852]   - Field: ‘uuid’
[13:34:39.852]   - Field: ‘seed’
[13:34:39.852]   - Field: ‘version’
[13:34:39.852]   - Field: ‘result’
[13:34:39.852]   - Field: ‘asynchronous’
[13:34:39.852]   - Field: ‘calls’
[13:34:39.852]   - Field: ‘globals’
[13:34:39.852]   - Field: ‘stdout’
[13:34:39.852]   - Field: ‘earlySignal’
[13:34:39.852]   - Field: ‘lazy’
[13:34:39.852]   - Field: ‘state’
[13:34:39.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.853] - Launch lazy future ...
[13:34:39.853] Packages needed by the future expression (n = 0): <none>
[13:34:39.853] Packages needed by future strategies (n = 0): <none>
[13:34:39.853] {
[13:34:39.853]     {
[13:34:39.853]         {
[13:34:39.853]             ...future.startTime <- base::Sys.time()
[13:34:39.853]             {
[13:34:39.853]                 {
[13:34:39.853]                   {
[13:34:39.853]                     {
[13:34:39.853]                       base::local({
[13:34:39.853]                         has_future <- base::requireNamespace("future", 
[13:34:39.853]                           quietly = TRUE)
[13:34:39.853]                         if (has_future) {
[13:34:39.853]                           ns <- base::getNamespace("future")
[13:34:39.853]                           version <- ns[[".package"]][["version"]]
[13:34:39.853]                           if (is.null(version)) 
[13:34:39.853]                             version <- utils::packageVersion("future")
[13:34:39.853]                         }
[13:34:39.853]                         else {
[13:34:39.853]                           version <- NULL
[13:34:39.853]                         }
[13:34:39.853]                         if (!has_future || version < "1.8.0") {
[13:34:39.853]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.853]                             "", base::R.version$version.string), 
[13:34:39.853]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.853]                               "release", "version")], collapse = " "), 
[13:34:39.853]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.853]                             info)
[13:34:39.853]                           info <- base::paste(info, collapse = "; ")
[13:34:39.853]                           if (!has_future) {
[13:34:39.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.853]                               info)
[13:34:39.853]                           }
[13:34:39.853]                           else {
[13:34:39.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.853]                               info, version)
[13:34:39.853]                           }
[13:34:39.853]                           base::stop(msg)
[13:34:39.853]                         }
[13:34:39.853]                       })
[13:34:39.853]                     }
[13:34:39.853]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.853]                     base::options(mc.cores = 1L)
[13:34:39.853]                   }
[13:34:39.853]                   ...future.strategy.old <- future::plan("list")
[13:34:39.853]                   options(future.plan = NULL)
[13:34:39.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.853]                 }
[13:34:39.853]                 ...future.workdir <- getwd()
[13:34:39.853]             }
[13:34:39.853]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.853]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.853]         }
[13:34:39.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.853]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:39.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.853]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.853]             base::names(...future.oldOptions))
[13:34:39.853]     }
[13:34:39.853]     if (FALSE) {
[13:34:39.853]     }
[13:34:39.853]     else {
[13:34:39.853]         if (TRUE) {
[13:34:39.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.853]                 open = "w")
[13:34:39.853]         }
[13:34:39.853]         else {
[13:34:39.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.853]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.853]         }
[13:34:39.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.853]             base::sink(type = "output", split = FALSE)
[13:34:39.853]             base::close(...future.stdout)
[13:34:39.853]         }, add = TRUE)
[13:34:39.853]     }
[13:34:39.853]     ...future.frame <- base::sys.nframe()
[13:34:39.853]     ...future.conditions <- base::list()
[13:34:39.853]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.853]     if (FALSE) {
[13:34:39.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.853]     }
[13:34:39.853]     ...future.result <- base::tryCatch({
[13:34:39.853]         base::withCallingHandlers({
[13:34:39.853]             ...future.value <- base::withVisible(base::local({
[13:34:39.853]                 ...future.makeSendCondition <- base::local({
[13:34:39.853]                   sendCondition <- NULL
[13:34:39.853]                   function(frame = 1L) {
[13:34:39.853]                     if (is.function(sendCondition)) 
[13:34:39.853]                       return(sendCondition)
[13:34:39.853]                     ns <- getNamespace("parallel")
[13:34:39.853]                     if (exists("sendData", mode = "function", 
[13:34:39.853]                       envir = ns)) {
[13:34:39.853]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.853]                         envir = ns)
[13:34:39.853]                       envir <- sys.frame(frame)
[13:34:39.853]                       master <- NULL
[13:34:39.853]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.853]                         !identical(envir, emptyenv())) {
[13:34:39.853]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.853]                           inherits = FALSE)) {
[13:34:39.853]                           master <- get("master", mode = "list", 
[13:34:39.853]                             envir = envir, inherits = FALSE)
[13:34:39.853]                           if (inherits(master, c("SOCKnode", 
[13:34:39.853]                             "SOCK0node"))) {
[13:34:39.853]                             sendCondition <<- function(cond) {
[13:34:39.853]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.853]                                 success = TRUE)
[13:34:39.853]                               parallel_sendData(master, data)
[13:34:39.853]                             }
[13:34:39.853]                             return(sendCondition)
[13:34:39.853]                           }
[13:34:39.853]                         }
[13:34:39.853]                         frame <- frame + 1L
[13:34:39.853]                         envir <- sys.frame(frame)
[13:34:39.853]                       }
[13:34:39.853]                     }
[13:34:39.853]                     sendCondition <<- function(cond) NULL
[13:34:39.853]                   }
[13:34:39.853]                 })
[13:34:39.853]                 withCallingHandlers({
[13:34:39.853]                   {
[13:34:39.853]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.853]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.853]                       ...future.globals.maxSize)) {
[13:34:39.853]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.853]                       on.exit(options(oopts), add = TRUE)
[13:34:39.853]                     }
[13:34:39.853]                     {
[13:34:39.853]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.853]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.853]                         USE.NAMES = FALSE)
[13:34:39.853]                       do.call(mapply, args = args)
[13:34:39.853]                     }
[13:34:39.853]                   }
[13:34:39.853]                 }, immediateCondition = function(cond) {
[13:34:39.853]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.853]                   sendCondition(cond)
[13:34:39.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.853]                   {
[13:34:39.853]                     inherits <- base::inherits
[13:34:39.853]                     invokeRestart <- base::invokeRestart
[13:34:39.853]                     is.null <- base::is.null
[13:34:39.853]                     muffled <- FALSE
[13:34:39.853]                     if (inherits(cond, "message")) {
[13:34:39.853]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.853]                       if (muffled) 
[13:34:39.853]                         invokeRestart("muffleMessage")
[13:34:39.853]                     }
[13:34:39.853]                     else if (inherits(cond, "warning")) {
[13:34:39.853]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.853]                       if (muffled) 
[13:34:39.853]                         invokeRestart("muffleWarning")
[13:34:39.853]                     }
[13:34:39.853]                     else if (inherits(cond, "condition")) {
[13:34:39.853]                       if (!is.null(pattern)) {
[13:34:39.853]                         computeRestarts <- base::computeRestarts
[13:34:39.853]                         grepl <- base::grepl
[13:34:39.853]                         restarts <- computeRestarts(cond)
[13:34:39.853]                         for (restart in restarts) {
[13:34:39.853]                           name <- restart$name
[13:34:39.853]                           if (is.null(name)) 
[13:34:39.853]                             next
[13:34:39.853]                           if (!grepl(pattern, name)) 
[13:34:39.853]                             next
[13:34:39.853]                           invokeRestart(restart)
[13:34:39.853]                           muffled <- TRUE
[13:34:39.853]                           break
[13:34:39.853]                         }
[13:34:39.853]                       }
[13:34:39.853]                     }
[13:34:39.853]                     invisible(muffled)
[13:34:39.853]                   }
[13:34:39.853]                   muffleCondition(cond)
[13:34:39.853]                 })
[13:34:39.853]             }))
[13:34:39.853]             future::FutureResult(value = ...future.value$value, 
[13:34:39.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.853]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.853]                     ...future.globalenv.names))
[13:34:39.853]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.853]         }, condition = base::local({
[13:34:39.853]             c <- base::c
[13:34:39.853]             inherits <- base::inherits
[13:34:39.853]             invokeRestart <- base::invokeRestart
[13:34:39.853]             length <- base::length
[13:34:39.853]             list <- base::list
[13:34:39.853]             seq.int <- base::seq.int
[13:34:39.853]             signalCondition <- base::signalCondition
[13:34:39.853]             sys.calls <- base::sys.calls
[13:34:39.853]             `[[` <- base::`[[`
[13:34:39.853]             `+` <- base::`+`
[13:34:39.853]             `<<-` <- base::`<<-`
[13:34:39.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.853]                   3L)]
[13:34:39.853]             }
[13:34:39.853]             function(cond) {
[13:34:39.853]                 is_error <- inherits(cond, "error")
[13:34:39.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.853]                   NULL)
[13:34:39.853]                 if (is_error) {
[13:34:39.853]                   sessionInformation <- function() {
[13:34:39.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.853]                       search = base::search(), system = base::Sys.info())
[13:34:39.853]                   }
[13:34:39.853]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.853]                     cond$call), session = sessionInformation(), 
[13:34:39.853]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.853]                   signalCondition(cond)
[13:34:39.853]                 }
[13:34:39.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.853]                 "immediateCondition"))) {
[13:34:39.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.853]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.853]                   if (TRUE && !signal) {
[13:34:39.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.853]                     {
[13:34:39.853]                       inherits <- base::inherits
[13:34:39.853]                       invokeRestart <- base::invokeRestart
[13:34:39.853]                       is.null <- base::is.null
[13:34:39.853]                       muffled <- FALSE
[13:34:39.853]                       if (inherits(cond, "message")) {
[13:34:39.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.853]                         if (muffled) 
[13:34:39.853]                           invokeRestart("muffleMessage")
[13:34:39.853]                       }
[13:34:39.853]                       else if (inherits(cond, "warning")) {
[13:34:39.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.853]                         if (muffled) 
[13:34:39.853]                           invokeRestart("muffleWarning")
[13:34:39.853]                       }
[13:34:39.853]                       else if (inherits(cond, "condition")) {
[13:34:39.853]                         if (!is.null(pattern)) {
[13:34:39.853]                           computeRestarts <- base::computeRestarts
[13:34:39.853]                           grepl <- base::grepl
[13:34:39.853]                           restarts <- computeRestarts(cond)
[13:34:39.853]                           for (restart in restarts) {
[13:34:39.853]                             name <- restart$name
[13:34:39.853]                             if (is.null(name)) 
[13:34:39.853]                               next
[13:34:39.853]                             if (!grepl(pattern, name)) 
[13:34:39.853]                               next
[13:34:39.853]                             invokeRestart(restart)
[13:34:39.853]                             muffled <- TRUE
[13:34:39.853]                             break
[13:34:39.853]                           }
[13:34:39.853]                         }
[13:34:39.853]                       }
[13:34:39.853]                       invisible(muffled)
[13:34:39.853]                     }
[13:34:39.853]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.853]                   }
[13:34:39.853]                 }
[13:34:39.853]                 else {
[13:34:39.853]                   if (TRUE) {
[13:34:39.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.853]                     {
[13:34:39.853]                       inherits <- base::inherits
[13:34:39.853]                       invokeRestart <- base::invokeRestart
[13:34:39.853]                       is.null <- base::is.null
[13:34:39.853]                       muffled <- FALSE
[13:34:39.853]                       if (inherits(cond, "message")) {
[13:34:39.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.853]                         if (muffled) 
[13:34:39.853]                           invokeRestart("muffleMessage")
[13:34:39.853]                       }
[13:34:39.853]                       else if (inherits(cond, "warning")) {
[13:34:39.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.853]                         if (muffled) 
[13:34:39.853]                           invokeRestart("muffleWarning")
[13:34:39.853]                       }
[13:34:39.853]                       else if (inherits(cond, "condition")) {
[13:34:39.853]                         if (!is.null(pattern)) {
[13:34:39.853]                           computeRestarts <- base::computeRestarts
[13:34:39.853]                           grepl <- base::grepl
[13:34:39.853]                           restarts <- computeRestarts(cond)
[13:34:39.853]                           for (restart in restarts) {
[13:34:39.853]                             name <- restart$name
[13:34:39.853]                             if (is.null(name)) 
[13:34:39.853]                               next
[13:34:39.853]                             if (!grepl(pattern, name)) 
[13:34:39.853]                               next
[13:34:39.853]                             invokeRestart(restart)
[13:34:39.853]                             muffled <- TRUE
[13:34:39.853]                             break
[13:34:39.853]                           }
[13:34:39.853]                         }
[13:34:39.853]                       }
[13:34:39.853]                       invisible(muffled)
[13:34:39.853]                     }
[13:34:39.853]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.853]                   }
[13:34:39.853]                 }
[13:34:39.853]             }
[13:34:39.853]         }))
[13:34:39.853]     }, error = function(ex) {
[13:34:39.853]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.853]                 ...future.rng), started = ...future.startTime, 
[13:34:39.853]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.853]             version = "1.8"), class = "FutureResult")
[13:34:39.853]     }, finally = {
[13:34:39.853]         if (!identical(...future.workdir, getwd())) 
[13:34:39.853]             setwd(...future.workdir)
[13:34:39.853]         {
[13:34:39.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.853]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.853]             }
[13:34:39.853]             base::options(...future.oldOptions)
[13:34:39.853]             if (.Platform$OS.type == "windows") {
[13:34:39.853]                 old_names <- names(...future.oldEnvVars)
[13:34:39.853]                 envs <- base::Sys.getenv()
[13:34:39.853]                 names <- names(envs)
[13:34:39.853]                 common <- intersect(names, old_names)
[13:34:39.853]                 added <- setdiff(names, old_names)
[13:34:39.853]                 removed <- setdiff(old_names, names)
[13:34:39.853]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.853]                   envs[common]]
[13:34:39.853]                 NAMES <- toupper(changed)
[13:34:39.853]                 args <- list()
[13:34:39.853]                 for (kk in seq_along(NAMES)) {
[13:34:39.853]                   name <- changed[[kk]]
[13:34:39.853]                   NAME <- NAMES[[kk]]
[13:34:39.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.853]                     next
[13:34:39.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.853]                 }
[13:34:39.853]                 NAMES <- toupper(added)
[13:34:39.853]                 for (kk in seq_along(NAMES)) {
[13:34:39.853]                   name <- added[[kk]]
[13:34:39.853]                   NAME <- NAMES[[kk]]
[13:34:39.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.853]                     next
[13:34:39.853]                   args[[name]] <- ""
[13:34:39.853]                 }
[13:34:39.853]                 NAMES <- toupper(removed)
[13:34:39.853]                 for (kk in seq_along(NAMES)) {
[13:34:39.853]                   name <- removed[[kk]]
[13:34:39.853]                   NAME <- NAMES[[kk]]
[13:34:39.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.853]                     next
[13:34:39.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.853]                 }
[13:34:39.853]                 if (length(args) > 0) 
[13:34:39.853]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.853]             }
[13:34:39.853]             else {
[13:34:39.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.853]             }
[13:34:39.853]             {
[13:34:39.853]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.853]                   0L) {
[13:34:39.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.853]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.853]                   base::options(opts)
[13:34:39.853]                 }
[13:34:39.853]                 {
[13:34:39.853]                   {
[13:34:39.853]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.853]                     NULL
[13:34:39.853]                   }
[13:34:39.853]                   options(future.plan = NULL)
[13:34:39.853]                   if (is.na(NA_character_)) 
[13:34:39.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.853]                     .init = FALSE)
[13:34:39.853]                 }
[13:34:39.853]             }
[13:34:39.853]         }
[13:34:39.853]     })
[13:34:39.853]     if (TRUE) {
[13:34:39.853]         base::sink(type = "output", split = FALSE)
[13:34:39.853]         if (TRUE) {
[13:34:39.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.853]         }
[13:34:39.853]         else {
[13:34:39.853]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.853]         }
[13:34:39.853]         base::close(...future.stdout)
[13:34:39.853]         ...future.stdout <- NULL
[13:34:39.853]     }
[13:34:39.853]     ...future.result$conditions <- ...future.conditions
[13:34:39.853]     ...future.result$finished <- base::Sys.time()
[13:34:39.853]     ...future.result
[13:34:39.853] }
[13:34:39.856] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[13:34:39.856] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[13:34:39.856] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[13:34:39.857] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:39.857] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.857] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[13:34:39.857] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[13:34:39.857] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:39.858] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.858] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:39.858] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:39.858] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[13:34:39.859] MultisessionFuture started
[13:34:39.859] - Launch lazy future ... done
[13:34:39.859] run() for ‘MultisessionFuture’ ... done
[13:34:39.859] Created future:
[13:34:39.859] MultisessionFuture:
[13:34:39.859] Label: ‘future_.mapply-2’
[13:34:39.859] Expression:
[13:34:39.859] {
[13:34:39.859]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.859]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.859]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.859]         on.exit(options(oopts), add = TRUE)
[13:34:39.859]     }
[13:34:39.859]     {
[13:34:39.859]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.859]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.859]         do.call(mapply, args = args)
[13:34:39.859]     }
[13:34:39.859] }
[13:34:39.859] Lazy evaluation: FALSE
[13:34:39.859] Asynchronous evaluation: TRUE
[13:34:39.859] Local evaluation: TRUE
[13:34:39.859] Environment: R_GlobalEnv
[13:34:39.859] Capture standard output: TRUE
[13:34:39.859] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.859] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.859] Packages: <none>
[13:34:39.859] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.859] Resolved: FALSE
[13:34:39.859] Value: <not collected>
[13:34:39.859] Conditions captured: <none>
[13:34:39.859] Early signaling: FALSE
[13:34:39.859] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.859] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.871] Chunk #2 of 2 ... DONE
[13:34:39.871] Launching 2 futures (chunks) ... DONE
[13:34:39.871] Resolving 2 futures (chunks) ...
[13:34:39.871] resolve() on list ...
[13:34:39.871]  recursive: 0
[13:34:39.871]  length: 2
[13:34:39.871] 
[13:34:39.872] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.872] - Validating connection of MultisessionFuture
[13:34:39.872] - received message: FutureResult
[13:34:39.872] - Received FutureResult
[13:34:39.872] - Erased future from FutureRegistry
[13:34:39.872] result() for ClusterFuture ...
[13:34:39.872] - result already collected: FutureResult
[13:34:39.872] result() for ClusterFuture ... done
[13:34:39.873] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.873] Future #1
[13:34:39.873] result() for ClusterFuture ...
[13:34:39.873] - result already collected: FutureResult
[13:34:39.873] result() for ClusterFuture ... done
[13:34:39.873] result() for ClusterFuture ...
[13:34:39.873] - result already collected: FutureResult
[13:34:39.873] result() for ClusterFuture ... done
[13:34:39.873] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:39.873] - nx: 2
[13:34:39.873] - relay: TRUE
[13:34:39.874] - stdout: TRUE
[13:34:39.874] - signal: TRUE
[13:34:39.874] - resignal: FALSE
[13:34:39.874] - force: TRUE
[13:34:39.874] - relayed: [n=2] FALSE, FALSE
[13:34:39.874] - queued futures: [n=2] FALSE, FALSE
[13:34:39.874]  - until=1
[13:34:39.874]  - relaying element #1
[13:34:39.874] result() for ClusterFuture ...
[13:34:39.874] - result already collected: FutureResult
[13:34:39.874] result() for ClusterFuture ... done
[13:34:39.875] result() for ClusterFuture ...
[13:34:39.875] - result already collected: FutureResult
[13:34:39.875] result() for ClusterFuture ... done
[13:34:39.875] result() for ClusterFuture ...
[13:34:39.875] - result already collected: FutureResult
[13:34:39.875] result() for ClusterFuture ... done
[13:34:39.875] result() for ClusterFuture ...
[13:34:39.875] - result already collected: FutureResult
[13:34:39.875] result() for ClusterFuture ... done
[13:34:39.875] - relayed: [n=2] TRUE, FALSE
[13:34:39.875] - queued futures: [n=2] TRUE, FALSE
[13:34:39.876] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:39.876]  length: 1 (resolved future 1)
[13:34:39.904] receiveMessageFromWorker() for ClusterFuture ...
[13:34:39.904] - Validating connection of MultisessionFuture
[13:34:39.904] - received message: FutureResult
[13:34:39.904] - Received FutureResult
[13:34:39.904] - Erased future from FutureRegistry
[13:34:39.904] result() for ClusterFuture ...
[13:34:39.904] - result already collected: FutureResult
[13:34:39.905] result() for ClusterFuture ... done
[13:34:39.905] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:39.905] Future #2
[13:34:39.905] result() for ClusterFuture ...
[13:34:39.905] - result already collected: FutureResult
[13:34:39.905] result() for ClusterFuture ... done
[13:34:39.905] result() for ClusterFuture ...
[13:34:39.905] - result already collected: FutureResult
[13:34:39.905] result() for ClusterFuture ... done
[13:34:39.905] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:39.905] - nx: 2
[13:34:39.906] - relay: TRUE
[13:34:39.906] - stdout: TRUE
[13:34:39.906] - signal: TRUE
[13:34:39.906] - resignal: FALSE
[13:34:39.906] - force: TRUE
[13:34:39.906] - relayed: [n=2] TRUE, FALSE
[13:34:39.906] - queued futures: [n=2] TRUE, FALSE
[13:34:39.906]  - until=2
[13:34:39.906]  - relaying element #2
[13:34:39.906] result() for ClusterFuture ...
[13:34:39.906] - result already collected: FutureResult
[13:34:39.907] result() for ClusterFuture ... done
[13:34:39.907] result() for ClusterFuture ...
[13:34:39.907] - result already collected: FutureResult
[13:34:39.907] result() for ClusterFuture ... done
[13:34:39.907] result() for ClusterFuture ...
[13:34:39.907] - result already collected: FutureResult
[13:34:39.907] result() for ClusterFuture ... done
[13:34:39.907] result() for ClusterFuture ...
[13:34:39.907] - result already collected: FutureResult
[13:34:39.907] result() for ClusterFuture ... done
[13:34:39.907] - relayed: [n=2] TRUE, TRUE
[13:34:39.908] - queued futures: [n=2] TRUE, TRUE
[13:34:39.908] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:39.908]  length: 0 (resolved future 2)
[13:34:39.908] Relaying remaining futures
[13:34:39.908] signalConditionsASAP(NULL, pos=0) ...
[13:34:39.908] - nx: 2
[13:34:39.908] - relay: TRUE
[13:34:39.908] - stdout: TRUE
[13:34:39.908] - signal: TRUE
[13:34:39.908] - resignal: FALSE
[13:34:39.908] - force: TRUE
[13:34:39.908] - relayed: [n=2] TRUE, TRUE
[13:34:39.909] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:39.909] - relayed: [n=2] TRUE, TRUE
[13:34:39.909] - queued futures: [n=2] TRUE, TRUE
[13:34:39.909] signalConditionsASAP(NULL, pos=0) ... done
[13:34:39.909] resolve() on list ... DONE
[13:34:39.909] result() for ClusterFuture ...
[13:34:39.909] - result already collected: FutureResult
[13:34:39.909] result() for ClusterFuture ... done
[13:34:39.909] result() for ClusterFuture ...
[13:34:39.909] - result already collected: FutureResult
[13:34:39.909] result() for ClusterFuture ... done
[13:34:39.910] result() for ClusterFuture ...
[13:34:39.910] - result already collected: FutureResult
[13:34:39.910] result() for ClusterFuture ... done
[13:34:39.910] result() for ClusterFuture ...
[13:34:39.910] - result already collected: FutureResult
[13:34:39.910] result() for ClusterFuture ... done
[13:34:39.910]  - Number of value chunks collected: 2
[13:34:39.910] Resolving 2 futures (chunks) ... DONE
[13:34:39.910] Reducing values from 2 chunks ...
[13:34:39.910]  - Number of values collected after concatenation: 5
[13:34:39.910]  - Number of values expected: 5
[13:34:39.910] Reducing values from 2 chunks ... DONE
[13:34:39.911] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[13:34:39.911] future_mapply() ...
[13:34:39.914] Number of chunks: 1
[13:34:39.914] getGlobalsAndPackagesXApply() ...
[13:34:39.914]  - future.globals: TRUE
[13:34:39.914] getGlobalsAndPackages() ...
[13:34:39.915] Searching for globals...
[13:34:39.915] - globals found: [1] ‘FUN’
[13:34:39.916] Searching for globals ... DONE
[13:34:39.916] Resolving globals: FALSE
[13:34:39.916] The total size of the 1 globals is 848 bytes (848 bytes)
[13:34:39.916] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:34:39.916] - globals: [1] ‘FUN’
[13:34:39.916] 
[13:34:39.917] getGlobalsAndPackages() ... DONE
[13:34:39.917]  - globals found/used: [n=1] ‘FUN’
[13:34:39.917]  - needed namespaces: [n=0] 
[13:34:39.917] Finding globals ... DONE
[13:34:39.917] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:39.917] List of 2
[13:34:39.917]  $ ...future.FUN:function (x)  
[13:34:39.917]  $ MoreArgs     : NULL
[13:34:39.917]  - attr(*, "where")=List of 2
[13:34:39.917]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:39.917]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:39.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:39.917]  - attr(*, "resolved")= logi FALSE
[13:34:39.917]  - attr(*, "total_size")= num NA
[13:34:39.920] Packages to be attached in all futures: [n=0] 
[13:34:39.920] getGlobalsAndPackagesXApply() ... DONE
[13:34:39.920] Number of futures (= number of chunks): 1
[13:34:39.920] Launching 1 futures (chunks) ...
[13:34:39.920] Chunk #1 of 1 ...
[13:34:39.920]  - Finding globals in '...' for chunk #1 ...
[13:34:39.920] getGlobalsAndPackages() ...
[13:34:39.920] Searching for globals...
[13:34:39.921] 
[13:34:39.921] Searching for globals ... DONE
[13:34:39.921] - globals: [0] <none>
[13:34:39.921] getGlobalsAndPackages() ... DONE
[13:34:39.921]    + additional globals found: [n=0] 
[13:34:39.921]    + additional namespaces needed: [n=0] 
[13:34:39.921]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:39.921]  - seeds: <none>
[13:34:39.921]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.921] getGlobalsAndPackages() ...
[13:34:39.922] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.922] Resolving globals: FALSE
[13:34:39.922] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[13:34:39.922] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:39.923] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:39.923] 
[13:34:39.923] getGlobalsAndPackages() ... DONE
[13:34:39.923] run() for ‘Future’ ...
[13:34:39.923] - state: ‘created’
[13:34:39.923] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:39.937] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.937] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:39.937]   - Field: ‘node’
[13:34:39.937]   - Field: ‘label’
[13:34:39.940]   - Field: ‘local’
[13:34:39.940]   - Field: ‘owner’
[13:34:39.940]   - Field: ‘envir’
[13:34:39.940]   - Field: ‘workers’
[13:34:39.940]   - Field: ‘packages’
[13:34:39.940]   - Field: ‘gc’
[13:34:39.940]   - Field: ‘conditions’
[13:34:39.940]   - Field: ‘persistent’
[13:34:39.940]   - Field: ‘expr’
[13:34:39.941]   - Field: ‘uuid’
[13:34:39.941]   - Field: ‘seed’
[13:34:39.941]   - Field: ‘version’
[13:34:39.941]   - Field: ‘result’
[13:34:39.941]   - Field: ‘asynchronous’
[13:34:39.941]   - Field: ‘calls’
[13:34:39.941]   - Field: ‘globals’
[13:34:39.941]   - Field: ‘stdout’
[13:34:39.941]   - Field: ‘earlySignal’
[13:34:39.941]   - Field: ‘lazy’
[13:34:39.941]   - Field: ‘state’
[13:34:39.942] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:39.942] - Launch lazy future ...
[13:34:39.942] Packages needed by the future expression (n = 0): <none>
[13:34:39.942] Packages needed by future strategies (n = 0): <none>
[13:34:39.942] {
[13:34:39.942]     {
[13:34:39.942]         {
[13:34:39.942]             ...future.startTime <- base::Sys.time()
[13:34:39.942]             {
[13:34:39.942]                 {
[13:34:39.942]                   {
[13:34:39.942]                     {
[13:34:39.942]                       base::local({
[13:34:39.942]                         has_future <- base::requireNamespace("future", 
[13:34:39.942]                           quietly = TRUE)
[13:34:39.942]                         if (has_future) {
[13:34:39.942]                           ns <- base::getNamespace("future")
[13:34:39.942]                           version <- ns[[".package"]][["version"]]
[13:34:39.942]                           if (is.null(version)) 
[13:34:39.942]                             version <- utils::packageVersion("future")
[13:34:39.942]                         }
[13:34:39.942]                         else {
[13:34:39.942]                           version <- NULL
[13:34:39.942]                         }
[13:34:39.942]                         if (!has_future || version < "1.8.0") {
[13:34:39.942]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:39.942]                             "", base::R.version$version.string), 
[13:34:39.942]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:39.942]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:39.942]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:39.942]                               "release", "version")], collapse = " "), 
[13:34:39.942]                             hostname = base::Sys.info()[["nodename"]])
[13:34:39.942]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:39.942]                             info)
[13:34:39.942]                           info <- base::paste(info, collapse = "; ")
[13:34:39.942]                           if (!has_future) {
[13:34:39.942]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:39.942]                               info)
[13:34:39.942]                           }
[13:34:39.942]                           else {
[13:34:39.942]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:39.942]                               info, version)
[13:34:39.942]                           }
[13:34:39.942]                           base::stop(msg)
[13:34:39.942]                         }
[13:34:39.942]                       })
[13:34:39.942]                     }
[13:34:39.942]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:39.942]                     base::options(mc.cores = 1L)
[13:34:39.942]                   }
[13:34:39.942]                   ...future.strategy.old <- future::plan("list")
[13:34:39.942]                   options(future.plan = NULL)
[13:34:39.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:39.942]                 }
[13:34:39.942]                 ...future.workdir <- getwd()
[13:34:39.942]             }
[13:34:39.942]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:39.942]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:39.942]         }
[13:34:39.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:39.942]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:39.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:39.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:39.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:39.942]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:39.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:39.942]             base::names(...future.oldOptions))
[13:34:39.942]     }
[13:34:39.942]     if (FALSE) {
[13:34:39.942]     }
[13:34:39.942]     else {
[13:34:39.942]         if (TRUE) {
[13:34:39.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:39.942]                 open = "w")
[13:34:39.942]         }
[13:34:39.942]         else {
[13:34:39.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:39.942]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:39.942]         }
[13:34:39.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:39.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:39.942]             base::sink(type = "output", split = FALSE)
[13:34:39.942]             base::close(...future.stdout)
[13:34:39.942]         }, add = TRUE)
[13:34:39.942]     }
[13:34:39.942]     ...future.frame <- base::sys.nframe()
[13:34:39.942]     ...future.conditions <- base::list()
[13:34:39.942]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:39.942]     if (FALSE) {
[13:34:39.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:39.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:39.942]     }
[13:34:39.942]     ...future.result <- base::tryCatch({
[13:34:39.942]         base::withCallingHandlers({
[13:34:39.942]             ...future.value <- base::withVisible(base::local({
[13:34:39.942]                 ...future.makeSendCondition <- base::local({
[13:34:39.942]                   sendCondition <- NULL
[13:34:39.942]                   function(frame = 1L) {
[13:34:39.942]                     if (is.function(sendCondition)) 
[13:34:39.942]                       return(sendCondition)
[13:34:39.942]                     ns <- getNamespace("parallel")
[13:34:39.942]                     if (exists("sendData", mode = "function", 
[13:34:39.942]                       envir = ns)) {
[13:34:39.942]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:39.942]                         envir = ns)
[13:34:39.942]                       envir <- sys.frame(frame)
[13:34:39.942]                       master <- NULL
[13:34:39.942]                       while (!identical(envir, .GlobalEnv) && 
[13:34:39.942]                         !identical(envir, emptyenv())) {
[13:34:39.942]                         if (exists("master", mode = "list", envir = envir, 
[13:34:39.942]                           inherits = FALSE)) {
[13:34:39.942]                           master <- get("master", mode = "list", 
[13:34:39.942]                             envir = envir, inherits = FALSE)
[13:34:39.942]                           if (inherits(master, c("SOCKnode", 
[13:34:39.942]                             "SOCK0node"))) {
[13:34:39.942]                             sendCondition <<- function(cond) {
[13:34:39.942]                               data <- list(type = "VALUE", value = cond, 
[13:34:39.942]                                 success = TRUE)
[13:34:39.942]                               parallel_sendData(master, data)
[13:34:39.942]                             }
[13:34:39.942]                             return(sendCondition)
[13:34:39.942]                           }
[13:34:39.942]                         }
[13:34:39.942]                         frame <- frame + 1L
[13:34:39.942]                         envir <- sys.frame(frame)
[13:34:39.942]                       }
[13:34:39.942]                     }
[13:34:39.942]                     sendCondition <<- function(cond) NULL
[13:34:39.942]                   }
[13:34:39.942]                 })
[13:34:39.942]                 withCallingHandlers({
[13:34:39.942]                   {
[13:34:39.942]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.942]                     if (!identical(...future.globals.maxSize.org, 
[13:34:39.942]                       ...future.globals.maxSize)) {
[13:34:39.942]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.942]                       on.exit(options(oopts), add = TRUE)
[13:34:39.942]                     }
[13:34:39.942]                     {
[13:34:39.942]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.942]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:39.942]                         USE.NAMES = FALSE)
[13:34:39.942]                       do.call(mapply, args = args)
[13:34:39.942]                     }
[13:34:39.942]                   }
[13:34:39.942]                 }, immediateCondition = function(cond) {
[13:34:39.942]                   sendCondition <- ...future.makeSendCondition()
[13:34:39.942]                   sendCondition(cond)
[13:34:39.942]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.942]                   {
[13:34:39.942]                     inherits <- base::inherits
[13:34:39.942]                     invokeRestart <- base::invokeRestart
[13:34:39.942]                     is.null <- base::is.null
[13:34:39.942]                     muffled <- FALSE
[13:34:39.942]                     if (inherits(cond, "message")) {
[13:34:39.942]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:39.942]                       if (muffled) 
[13:34:39.942]                         invokeRestart("muffleMessage")
[13:34:39.942]                     }
[13:34:39.942]                     else if (inherits(cond, "warning")) {
[13:34:39.942]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:39.942]                       if (muffled) 
[13:34:39.942]                         invokeRestart("muffleWarning")
[13:34:39.942]                     }
[13:34:39.942]                     else if (inherits(cond, "condition")) {
[13:34:39.942]                       if (!is.null(pattern)) {
[13:34:39.942]                         computeRestarts <- base::computeRestarts
[13:34:39.942]                         grepl <- base::grepl
[13:34:39.942]                         restarts <- computeRestarts(cond)
[13:34:39.942]                         for (restart in restarts) {
[13:34:39.942]                           name <- restart$name
[13:34:39.942]                           if (is.null(name)) 
[13:34:39.942]                             next
[13:34:39.942]                           if (!grepl(pattern, name)) 
[13:34:39.942]                             next
[13:34:39.942]                           invokeRestart(restart)
[13:34:39.942]                           muffled <- TRUE
[13:34:39.942]                           break
[13:34:39.942]                         }
[13:34:39.942]                       }
[13:34:39.942]                     }
[13:34:39.942]                     invisible(muffled)
[13:34:39.942]                   }
[13:34:39.942]                   muffleCondition(cond)
[13:34:39.942]                 })
[13:34:39.942]             }))
[13:34:39.942]             future::FutureResult(value = ...future.value$value, 
[13:34:39.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.942]                   ...future.rng), globalenv = if (FALSE) 
[13:34:39.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:39.942]                     ...future.globalenv.names))
[13:34:39.942]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:39.942]         }, condition = base::local({
[13:34:39.942]             c <- base::c
[13:34:39.942]             inherits <- base::inherits
[13:34:39.942]             invokeRestart <- base::invokeRestart
[13:34:39.942]             length <- base::length
[13:34:39.942]             list <- base::list
[13:34:39.942]             seq.int <- base::seq.int
[13:34:39.942]             signalCondition <- base::signalCondition
[13:34:39.942]             sys.calls <- base::sys.calls
[13:34:39.942]             `[[` <- base::`[[`
[13:34:39.942]             `+` <- base::`+`
[13:34:39.942]             `<<-` <- base::`<<-`
[13:34:39.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:39.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:39.942]                   3L)]
[13:34:39.942]             }
[13:34:39.942]             function(cond) {
[13:34:39.942]                 is_error <- inherits(cond, "error")
[13:34:39.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:39.942]                   NULL)
[13:34:39.942]                 if (is_error) {
[13:34:39.942]                   sessionInformation <- function() {
[13:34:39.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:39.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:39.942]                       search = base::search(), system = base::Sys.info())
[13:34:39.942]                   }
[13:34:39.942]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:39.942]                     cond$call), session = sessionInformation(), 
[13:34:39.942]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:39.942]                   signalCondition(cond)
[13:34:39.942]                 }
[13:34:39.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:39.942]                 "immediateCondition"))) {
[13:34:39.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:39.942]                   ...future.conditions[[length(...future.conditions) + 
[13:34:39.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:39.942]                   if (TRUE && !signal) {
[13:34:39.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.942]                     {
[13:34:39.942]                       inherits <- base::inherits
[13:34:39.942]                       invokeRestart <- base::invokeRestart
[13:34:39.942]                       is.null <- base::is.null
[13:34:39.942]                       muffled <- FALSE
[13:34:39.942]                       if (inherits(cond, "message")) {
[13:34:39.942]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.942]                         if (muffled) 
[13:34:39.942]                           invokeRestart("muffleMessage")
[13:34:39.942]                       }
[13:34:39.942]                       else if (inherits(cond, "warning")) {
[13:34:39.942]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.942]                         if (muffled) 
[13:34:39.942]                           invokeRestart("muffleWarning")
[13:34:39.942]                       }
[13:34:39.942]                       else if (inherits(cond, "condition")) {
[13:34:39.942]                         if (!is.null(pattern)) {
[13:34:39.942]                           computeRestarts <- base::computeRestarts
[13:34:39.942]                           grepl <- base::grepl
[13:34:39.942]                           restarts <- computeRestarts(cond)
[13:34:39.942]                           for (restart in restarts) {
[13:34:39.942]                             name <- restart$name
[13:34:39.942]                             if (is.null(name)) 
[13:34:39.942]                               next
[13:34:39.942]                             if (!grepl(pattern, name)) 
[13:34:39.942]                               next
[13:34:39.942]                             invokeRestart(restart)
[13:34:39.942]                             muffled <- TRUE
[13:34:39.942]                             break
[13:34:39.942]                           }
[13:34:39.942]                         }
[13:34:39.942]                       }
[13:34:39.942]                       invisible(muffled)
[13:34:39.942]                     }
[13:34:39.942]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.942]                   }
[13:34:39.942]                 }
[13:34:39.942]                 else {
[13:34:39.942]                   if (TRUE) {
[13:34:39.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:39.942]                     {
[13:34:39.942]                       inherits <- base::inherits
[13:34:39.942]                       invokeRestart <- base::invokeRestart
[13:34:39.942]                       is.null <- base::is.null
[13:34:39.942]                       muffled <- FALSE
[13:34:39.942]                       if (inherits(cond, "message")) {
[13:34:39.942]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:39.942]                         if (muffled) 
[13:34:39.942]                           invokeRestart("muffleMessage")
[13:34:39.942]                       }
[13:34:39.942]                       else if (inherits(cond, "warning")) {
[13:34:39.942]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:39.942]                         if (muffled) 
[13:34:39.942]                           invokeRestart("muffleWarning")
[13:34:39.942]                       }
[13:34:39.942]                       else if (inherits(cond, "condition")) {
[13:34:39.942]                         if (!is.null(pattern)) {
[13:34:39.942]                           computeRestarts <- base::computeRestarts
[13:34:39.942]                           grepl <- base::grepl
[13:34:39.942]                           restarts <- computeRestarts(cond)
[13:34:39.942]                           for (restart in restarts) {
[13:34:39.942]                             name <- restart$name
[13:34:39.942]                             if (is.null(name)) 
[13:34:39.942]                               next
[13:34:39.942]                             if (!grepl(pattern, name)) 
[13:34:39.942]                               next
[13:34:39.942]                             invokeRestart(restart)
[13:34:39.942]                             muffled <- TRUE
[13:34:39.942]                             break
[13:34:39.942]                           }
[13:34:39.942]                         }
[13:34:39.942]                       }
[13:34:39.942]                       invisible(muffled)
[13:34:39.942]                     }
[13:34:39.942]                     muffleCondition(cond, pattern = "^muffle")
[13:34:39.942]                   }
[13:34:39.942]                 }
[13:34:39.942]             }
[13:34:39.942]         }))
[13:34:39.942]     }, error = function(ex) {
[13:34:39.942]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:39.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:39.942]                 ...future.rng), started = ...future.startTime, 
[13:34:39.942]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:39.942]             version = "1.8"), class = "FutureResult")
[13:34:39.942]     }, finally = {
[13:34:39.942]         if (!identical(...future.workdir, getwd())) 
[13:34:39.942]             setwd(...future.workdir)
[13:34:39.942]         {
[13:34:39.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:39.942]                 ...future.oldOptions$nwarnings <- NULL
[13:34:39.942]             }
[13:34:39.942]             base::options(...future.oldOptions)
[13:34:39.942]             if (.Platform$OS.type == "windows") {
[13:34:39.942]                 old_names <- names(...future.oldEnvVars)
[13:34:39.942]                 envs <- base::Sys.getenv()
[13:34:39.942]                 names <- names(envs)
[13:34:39.942]                 common <- intersect(names, old_names)
[13:34:39.942]                 added <- setdiff(names, old_names)
[13:34:39.942]                 removed <- setdiff(old_names, names)
[13:34:39.942]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:39.942]                   envs[common]]
[13:34:39.942]                 NAMES <- toupper(changed)
[13:34:39.942]                 args <- list()
[13:34:39.942]                 for (kk in seq_along(NAMES)) {
[13:34:39.942]                   name <- changed[[kk]]
[13:34:39.942]                   NAME <- NAMES[[kk]]
[13:34:39.942]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.942]                     next
[13:34:39.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.942]                 }
[13:34:39.942]                 NAMES <- toupper(added)
[13:34:39.942]                 for (kk in seq_along(NAMES)) {
[13:34:39.942]                   name <- added[[kk]]
[13:34:39.942]                   NAME <- NAMES[[kk]]
[13:34:39.942]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.942]                     next
[13:34:39.942]                   args[[name]] <- ""
[13:34:39.942]                 }
[13:34:39.942]                 NAMES <- toupper(removed)
[13:34:39.942]                 for (kk in seq_along(NAMES)) {
[13:34:39.942]                   name <- removed[[kk]]
[13:34:39.942]                   NAME <- NAMES[[kk]]
[13:34:39.942]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:39.942]                     next
[13:34:39.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:39.942]                 }
[13:34:39.942]                 if (length(args) > 0) 
[13:34:39.942]                   base::do.call(base::Sys.setenv, args = args)
[13:34:39.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:39.942]             }
[13:34:39.942]             else {
[13:34:39.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:39.942]             }
[13:34:39.942]             {
[13:34:39.942]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:39.942]                   0L) {
[13:34:39.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:39.942]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:39.942]                   base::options(opts)
[13:34:39.942]                 }
[13:34:39.942]                 {
[13:34:39.942]                   {
[13:34:39.942]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:39.942]                     NULL
[13:34:39.942]                   }
[13:34:39.942]                   options(future.plan = NULL)
[13:34:39.942]                   if (is.na(NA_character_)) 
[13:34:39.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:39.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:39.942]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:39.942]                     .init = FALSE)
[13:34:39.942]                 }
[13:34:39.942]             }
[13:34:39.942]         }
[13:34:39.942]     })
[13:34:39.942]     if (TRUE) {
[13:34:39.942]         base::sink(type = "output", split = FALSE)
[13:34:39.942]         if (TRUE) {
[13:34:39.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:39.942]         }
[13:34:39.942]         else {
[13:34:39.942]             ...future.result["stdout"] <- base::list(NULL)
[13:34:39.942]         }
[13:34:39.942]         base::close(...future.stdout)
[13:34:39.942]         ...future.stdout <- NULL
[13:34:39.942]     }
[13:34:39.942]     ...future.result$conditions <- ...future.conditions
[13:34:39.942]     ...future.result$finished <- base::Sys.time()
[13:34:39.942]     ...future.result
[13:34:39.942] }
[13:34:39.945] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[13:34:39.945] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:34:39.945] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:34:39.946] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:39.946] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.946] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:34:39.947] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:34:39.947] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:39.947] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.947] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:39.948] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:39.948] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[13:34:39.948] MultisessionFuture started
[13:34:39.948] - Launch lazy future ... done
[13:34:39.948] run() for ‘MultisessionFuture’ ... done
[13:34:39.949] Created future:
[13:34:39.949] MultisessionFuture:
[13:34:39.949] Label: ‘future_mapply-1’
[13:34:39.949] Expression:
[13:34:39.949] {
[13:34:39.949]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:39.949]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:39.949]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:39.949]         on.exit(options(oopts), add = TRUE)
[13:34:39.949]     }
[13:34:39.949]     {
[13:34:39.949]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:39.949]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:39.949]         do.call(mapply, args = args)
[13:34:39.949]     }
[13:34:39.949] }
[13:34:39.949] Lazy evaluation: FALSE
[13:34:39.949] Asynchronous evaluation: TRUE
[13:34:39.949] Local evaluation: TRUE
[13:34:39.949] Environment: R_GlobalEnv
[13:34:39.949] Capture standard output: TRUE
[13:34:39.949] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:39.949] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:39.949] Packages: <none>
[13:34:39.949] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:39.949] Resolved: FALSE
[13:34:39.949] Value: <not collected>
[13:34:39.949] Conditions captured: <none>
[13:34:39.949] Early signaling: FALSE
[13:34:39.949] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:39.949] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:39.960] Chunk #1 of 1 ... DONE
[13:34:39.960] Launching 1 futures (chunks) ... DONE
[13:34:39.960] Resolving 1 futures (chunks) ...
[13:34:39.960] resolve() on list ...
[13:34:39.960]  recursive: 0
[13:34:39.960]  length: 1
[13:34:39.961] 
[13:34:40.002] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.002] - Validating connection of MultisessionFuture
[13:34:40.003] - received message: FutureResult
[13:34:40.003] - Received FutureResult
[13:34:40.003] - Erased future from FutureRegistry
[13:34:40.003] result() for ClusterFuture ...
[13:34:40.003] - result already collected: FutureResult
[13:34:40.003] result() for ClusterFuture ... done
[13:34:40.003] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.003] Future #1
[13:34:40.003] result() for ClusterFuture ...
[13:34:40.003] - result already collected: FutureResult
[13:34:40.003] result() for ClusterFuture ... done
[13:34:40.004] result() for ClusterFuture ...
[13:34:40.004] - result already collected: FutureResult
[13:34:40.004] result() for ClusterFuture ... done
[13:34:40.004] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:40.004] - nx: 1
[13:34:40.004] - relay: TRUE
[13:34:40.004] - stdout: TRUE
[13:34:40.004] - signal: TRUE
[13:34:40.004] - resignal: FALSE
[13:34:40.004] - force: TRUE
[13:34:40.004] - relayed: [n=1] FALSE
[13:34:40.005] - queued futures: [n=1] FALSE
[13:34:40.005]  - until=1
[13:34:40.005]  - relaying element #1
[13:34:40.005] result() for ClusterFuture ...
[13:34:40.005] - result already collected: FutureResult
[13:34:40.005] result() for ClusterFuture ... done
[13:34:40.005] result() for ClusterFuture ...
[13:34:40.005] - result already collected: FutureResult
[13:34:40.005] result() for ClusterFuture ... done
[13:34:40.005] result() for ClusterFuture ...
[13:34:40.005] - result already collected: FutureResult
[13:34:40.005] result() for ClusterFuture ... done
[13:34:40.006] result() for ClusterFuture ...
[13:34:40.006] - result already collected: FutureResult
[13:34:40.006] result() for ClusterFuture ... done
[13:34:40.006] - relayed: [n=1] TRUE
[13:34:40.006] - queued futures: [n=1] TRUE
[13:34:40.006] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:40.006]  length: 0 (resolved future 1)
[13:34:40.006] Relaying remaining futures
[13:34:40.006] signalConditionsASAP(NULL, pos=0) ...
[13:34:40.006] - nx: 1
[13:34:40.006] - relay: TRUE
[13:34:40.007] - stdout: TRUE
[13:34:40.007] - signal: TRUE
[13:34:40.007] - resignal: FALSE
[13:34:40.007] - force: TRUE
[13:34:40.007] - relayed: [n=1] TRUE
[13:34:40.007] - queued futures: [n=1] TRUE
 - flush all
[13:34:40.007] - relayed: [n=1] TRUE
[13:34:40.007] - queued futures: [n=1] TRUE
[13:34:40.007] signalConditionsASAP(NULL, pos=0) ... done
[13:34:40.007] resolve() on list ... DONE
[13:34:40.007] result() for ClusterFuture ...
[13:34:40.008] - result already collected: FutureResult
[13:34:40.008] result() for ClusterFuture ... done
[13:34:40.008] result() for ClusterFuture ...
[13:34:40.008] - result already collected: FutureResult
[13:34:40.008] result() for ClusterFuture ... done
[13:34:40.008]  - Number of value chunks collected: 1
[13:34:40.008] Resolving 1 futures (chunks) ... DONE
[13:34:40.008] Reducing values from 1 chunks ...
[13:34:40.008]  - Number of values collected after concatenation: 1
[13:34:40.008]  - Number of values expected: 1
[13:34:40.008] Reducing values from 1 chunks ... DONE
[13:34:40.008] future_mapply() ... DONE
[13:34:40.009] future_mapply() ...
[13:34:40.012] Number of chunks: 1
[13:34:40.012] getGlobalsAndPackagesXApply() ...
[13:34:40.012]  - future.globals: TRUE
[13:34:40.012] getGlobalsAndPackages() ...
[13:34:40.012] Searching for globals...
[13:34:40.013] - globals found: [1] ‘FUN’
[13:34:40.013] Searching for globals ... DONE
[13:34:40.013] Resolving globals: FALSE
[13:34:40.014] The total size of the 1 globals is 848 bytes (848 bytes)
[13:34:40.014] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:34:40.014] - globals: [1] ‘FUN’
[13:34:40.014] 
[13:34:40.014] getGlobalsAndPackages() ... DONE
[13:34:40.014]  - globals found/used: [n=1] ‘FUN’
[13:34:40.015]  - needed namespaces: [n=0] 
[13:34:40.015] Finding globals ... DONE
[13:34:40.015] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:40.015] List of 2
[13:34:40.015]  $ ...future.FUN:function (x)  
[13:34:40.015]  $ MoreArgs     : list()
[13:34:40.015]  - attr(*, "where")=List of 2
[13:34:40.015]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:40.015]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:40.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:40.015]  - attr(*, "resolved")= logi FALSE
[13:34:40.015]  - attr(*, "total_size")= num NA
[13:34:40.017] Packages to be attached in all futures: [n=0] 
[13:34:40.017] getGlobalsAndPackagesXApply() ... DONE
[13:34:40.018] Number of futures (= number of chunks): 1
[13:34:40.018] Launching 1 futures (chunks) ...
[13:34:40.018] Chunk #1 of 1 ...
[13:34:40.018]  - Finding globals in '...' for chunk #1 ...
[13:34:40.018] getGlobalsAndPackages() ...
[13:34:40.018] Searching for globals...
[13:34:40.018] 
[13:34:40.019] Searching for globals ... DONE
[13:34:40.019] - globals: [0] <none>
[13:34:40.019] getGlobalsAndPackages() ... DONE
[13:34:40.019]    + additional globals found: [n=0] 
[13:34:40.019]    + additional namespaces needed: [n=0] 
[13:34:40.019]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:40.019]  - seeds: <none>
[13:34:40.019]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.019] getGlobalsAndPackages() ...
[13:34:40.019] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.019] Resolving globals: FALSE
[13:34:40.020] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[13:34:40.020] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[13:34:40.020] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.020] 
[13:34:40.021] getGlobalsAndPackages() ... DONE
[13:34:40.021] run() for ‘Future’ ...
[13:34:40.021] - state: ‘created’
[13:34:40.021] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.035] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.035] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.035]   - Field: ‘node’
[13:34:40.035]   - Field: ‘label’
[13:34:40.035]   - Field: ‘local’
[13:34:40.035]   - Field: ‘owner’
[13:34:40.035]   - Field: ‘envir’
[13:34:40.035]   - Field: ‘workers’
[13:34:40.035]   - Field: ‘packages’
[13:34:40.035]   - Field: ‘gc’
[13:34:40.036]   - Field: ‘conditions’
[13:34:40.036]   - Field: ‘persistent’
[13:34:40.036]   - Field: ‘expr’
[13:34:40.036]   - Field: ‘uuid’
[13:34:40.036]   - Field: ‘seed’
[13:34:40.036]   - Field: ‘version’
[13:34:40.036]   - Field: ‘result’
[13:34:40.036]   - Field: ‘asynchronous’
[13:34:40.036]   - Field: ‘calls’
[13:34:40.036]   - Field: ‘globals’
[13:34:40.036]   - Field: ‘stdout’
[13:34:40.037]   - Field: ‘earlySignal’
[13:34:40.037]   - Field: ‘lazy’
[13:34:40.037]   - Field: ‘state’
[13:34:40.037] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.037] - Launch lazy future ...
[13:34:40.037] Packages needed by the future expression (n = 0): <none>
[13:34:40.037] Packages needed by future strategies (n = 0): <none>
[13:34:40.038] {
[13:34:40.038]     {
[13:34:40.038]         {
[13:34:40.038]             ...future.startTime <- base::Sys.time()
[13:34:40.038]             {
[13:34:40.038]                 {
[13:34:40.038]                   {
[13:34:40.038]                     {
[13:34:40.038]                       base::local({
[13:34:40.038]                         has_future <- base::requireNamespace("future", 
[13:34:40.038]                           quietly = TRUE)
[13:34:40.038]                         if (has_future) {
[13:34:40.038]                           ns <- base::getNamespace("future")
[13:34:40.038]                           version <- ns[[".package"]][["version"]]
[13:34:40.038]                           if (is.null(version)) 
[13:34:40.038]                             version <- utils::packageVersion("future")
[13:34:40.038]                         }
[13:34:40.038]                         else {
[13:34:40.038]                           version <- NULL
[13:34:40.038]                         }
[13:34:40.038]                         if (!has_future || version < "1.8.0") {
[13:34:40.038]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.038]                             "", base::R.version$version.string), 
[13:34:40.038]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:40.038]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:40.038]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.038]                               "release", "version")], collapse = " "), 
[13:34:40.038]                             hostname = base::Sys.info()[["nodename"]])
[13:34:40.038]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.038]                             info)
[13:34:40.038]                           info <- base::paste(info, collapse = "; ")
[13:34:40.038]                           if (!has_future) {
[13:34:40.038]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.038]                               info)
[13:34:40.038]                           }
[13:34:40.038]                           else {
[13:34:40.038]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.038]                               info, version)
[13:34:40.038]                           }
[13:34:40.038]                           base::stop(msg)
[13:34:40.038]                         }
[13:34:40.038]                       })
[13:34:40.038]                     }
[13:34:40.038]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.038]                     base::options(mc.cores = 1L)
[13:34:40.038]                   }
[13:34:40.038]                   ...future.strategy.old <- future::plan("list")
[13:34:40.038]                   options(future.plan = NULL)
[13:34:40.038]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.038]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.038]                 }
[13:34:40.038]                 ...future.workdir <- getwd()
[13:34:40.038]             }
[13:34:40.038]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.038]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.038]         }
[13:34:40.038]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.038]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:34:40.038]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.038]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.038]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.038]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.038]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.038]             base::names(...future.oldOptions))
[13:34:40.038]     }
[13:34:40.038]     if (FALSE) {
[13:34:40.038]     }
[13:34:40.038]     else {
[13:34:40.038]         if (TRUE) {
[13:34:40.038]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.038]                 open = "w")
[13:34:40.038]         }
[13:34:40.038]         else {
[13:34:40.038]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.038]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.038]         }
[13:34:40.038]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.038]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.038]             base::sink(type = "output", split = FALSE)
[13:34:40.038]             base::close(...future.stdout)
[13:34:40.038]         }, add = TRUE)
[13:34:40.038]     }
[13:34:40.038]     ...future.frame <- base::sys.nframe()
[13:34:40.038]     ...future.conditions <- base::list()
[13:34:40.038]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.038]     if (FALSE) {
[13:34:40.038]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.038]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.038]     }
[13:34:40.038]     ...future.result <- base::tryCatch({
[13:34:40.038]         base::withCallingHandlers({
[13:34:40.038]             ...future.value <- base::withVisible(base::local({
[13:34:40.038]                 ...future.makeSendCondition <- base::local({
[13:34:40.038]                   sendCondition <- NULL
[13:34:40.038]                   function(frame = 1L) {
[13:34:40.038]                     if (is.function(sendCondition)) 
[13:34:40.038]                       return(sendCondition)
[13:34:40.038]                     ns <- getNamespace("parallel")
[13:34:40.038]                     if (exists("sendData", mode = "function", 
[13:34:40.038]                       envir = ns)) {
[13:34:40.038]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.038]                         envir = ns)
[13:34:40.038]                       envir <- sys.frame(frame)
[13:34:40.038]                       master <- NULL
[13:34:40.038]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.038]                         !identical(envir, emptyenv())) {
[13:34:40.038]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.038]                           inherits = FALSE)) {
[13:34:40.038]                           master <- get("master", mode = "list", 
[13:34:40.038]                             envir = envir, inherits = FALSE)
[13:34:40.038]                           if (inherits(master, c("SOCKnode", 
[13:34:40.038]                             "SOCK0node"))) {
[13:34:40.038]                             sendCondition <<- function(cond) {
[13:34:40.038]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.038]                                 success = TRUE)
[13:34:40.038]                               parallel_sendData(master, data)
[13:34:40.038]                             }
[13:34:40.038]                             return(sendCondition)
[13:34:40.038]                           }
[13:34:40.038]                         }
[13:34:40.038]                         frame <- frame + 1L
[13:34:40.038]                         envir <- sys.frame(frame)
[13:34:40.038]                       }
[13:34:40.038]                     }
[13:34:40.038]                     sendCondition <<- function(cond) NULL
[13:34:40.038]                   }
[13:34:40.038]                 })
[13:34:40.038]                 withCallingHandlers({
[13:34:40.038]                   {
[13:34:40.038]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.038]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.038]                       ...future.globals.maxSize)) {
[13:34:40.038]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.038]                       on.exit(options(oopts), add = TRUE)
[13:34:40.038]                     }
[13:34:40.038]                     {
[13:34:40.038]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.038]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.038]                         USE.NAMES = FALSE)
[13:34:40.038]                       do.call(mapply, args = args)
[13:34:40.038]                     }
[13:34:40.038]                   }
[13:34:40.038]                 }, immediateCondition = function(cond) {
[13:34:40.038]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.038]                   sendCondition(cond)
[13:34:40.038]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.038]                   {
[13:34:40.038]                     inherits <- base::inherits
[13:34:40.038]                     invokeRestart <- base::invokeRestart
[13:34:40.038]                     is.null <- base::is.null
[13:34:40.038]                     muffled <- FALSE
[13:34:40.038]                     if (inherits(cond, "message")) {
[13:34:40.038]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.038]                       if (muffled) 
[13:34:40.038]                         invokeRestart("muffleMessage")
[13:34:40.038]                     }
[13:34:40.038]                     else if (inherits(cond, "warning")) {
[13:34:40.038]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.038]                       if (muffled) 
[13:34:40.038]                         invokeRestart("muffleWarning")
[13:34:40.038]                     }
[13:34:40.038]                     else if (inherits(cond, "condition")) {
[13:34:40.038]                       if (!is.null(pattern)) {
[13:34:40.038]                         computeRestarts <- base::computeRestarts
[13:34:40.038]                         grepl <- base::grepl
[13:34:40.038]                         restarts <- computeRestarts(cond)
[13:34:40.038]                         for (restart in restarts) {
[13:34:40.038]                           name <- restart$name
[13:34:40.038]                           if (is.null(name)) 
[13:34:40.038]                             next
[13:34:40.038]                           if (!grepl(pattern, name)) 
[13:34:40.038]                             next
[13:34:40.038]                           invokeRestart(restart)
[13:34:40.038]                           muffled <- TRUE
[13:34:40.038]                           break
[13:34:40.038]                         }
[13:34:40.038]                       }
[13:34:40.038]                     }
[13:34:40.038]                     invisible(muffled)
[13:34:40.038]                   }
[13:34:40.038]                   muffleCondition(cond)
[13:34:40.038]                 })
[13:34:40.038]             }))
[13:34:40.038]             future::FutureResult(value = ...future.value$value, 
[13:34:40.038]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.038]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.038]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.038]                     ...future.globalenv.names))
[13:34:40.038]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.038]         }, condition = base::local({
[13:34:40.038]             c <- base::c
[13:34:40.038]             inherits <- base::inherits
[13:34:40.038]             invokeRestart <- base::invokeRestart
[13:34:40.038]             length <- base::length
[13:34:40.038]             list <- base::list
[13:34:40.038]             seq.int <- base::seq.int
[13:34:40.038]             signalCondition <- base::signalCondition
[13:34:40.038]             sys.calls <- base::sys.calls
[13:34:40.038]             `[[` <- base::`[[`
[13:34:40.038]             `+` <- base::`+`
[13:34:40.038]             `<<-` <- base::`<<-`
[13:34:40.038]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.038]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.038]                   3L)]
[13:34:40.038]             }
[13:34:40.038]             function(cond) {
[13:34:40.038]                 is_error <- inherits(cond, "error")
[13:34:40.038]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.038]                   NULL)
[13:34:40.038]                 if (is_error) {
[13:34:40.038]                   sessionInformation <- function() {
[13:34:40.038]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.038]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.038]                       search = base::search(), system = base::Sys.info())
[13:34:40.038]                   }
[13:34:40.038]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.038]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.038]                     cond$call), session = sessionInformation(), 
[13:34:40.038]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.038]                   signalCondition(cond)
[13:34:40.038]                 }
[13:34:40.038]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.038]                 "immediateCondition"))) {
[13:34:40.038]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.038]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.038]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.038]                   if (TRUE && !signal) {
[13:34:40.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.038]                     {
[13:34:40.038]                       inherits <- base::inherits
[13:34:40.038]                       invokeRestart <- base::invokeRestart
[13:34:40.038]                       is.null <- base::is.null
[13:34:40.038]                       muffled <- FALSE
[13:34:40.038]                       if (inherits(cond, "message")) {
[13:34:40.038]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.038]                         if (muffled) 
[13:34:40.038]                           invokeRestart("muffleMessage")
[13:34:40.038]                       }
[13:34:40.038]                       else if (inherits(cond, "warning")) {
[13:34:40.038]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.038]                         if (muffled) 
[13:34:40.038]                           invokeRestart("muffleWarning")
[13:34:40.038]                       }
[13:34:40.038]                       else if (inherits(cond, "condition")) {
[13:34:40.038]                         if (!is.null(pattern)) {
[13:34:40.038]                           computeRestarts <- base::computeRestarts
[13:34:40.038]                           grepl <- base::grepl
[13:34:40.038]                           restarts <- computeRestarts(cond)
[13:34:40.038]                           for (restart in restarts) {
[13:34:40.038]                             name <- restart$name
[13:34:40.038]                             if (is.null(name)) 
[13:34:40.038]                               next
[13:34:40.038]                             if (!grepl(pattern, name)) 
[13:34:40.038]                               next
[13:34:40.038]                             invokeRestart(restart)
[13:34:40.038]                             muffled <- TRUE
[13:34:40.038]                             break
[13:34:40.038]                           }
[13:34:40.038]                         }
[13:34:40.038]                       }
[13:34:40.038]                       invisible(muffled)
[13:34:40.038]                     }
[13:34:40.038]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.038]                   }
[13:34:40.038]                 }
[13:34:40.038]                 else {
[13:34:40.038]                   if (TRUE) {
[13:34:40.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.038]                     {
[13:34:40.038]                       inherits <- base::inherits
[13:34:40.038]                       invokeRestart <- base::invokeRestart
[13:34:40.038]                       is.null <- base::is.null
[13:34:40.038]                       muffled <- FALSE
[13:34:40.038]                       if (inherits(cond, "message")) {
[13:34:40.038]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.038]                         if (muffled) 
[13:34:40.038]                           invokeRestart("muffleMessage")
[13:34:40.038]                       }
[13:34:40.038]                       else if (inherits(cond, "warning")) {
[13:34:40.038]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.038]                         if (muffled) 
[13:34:40.038]                           invokeRestart("muffleWarning")
[13:34:40.038]                       }
[13:34:40.038]                       else if (inherits(cond, "condition")) {
[13:34:40.038]                         if (!is.null(pattern)) {
[13:34:40.038]                           computeRestarts <- base::computeRestarts
[13:34:40.038]                           grepl <- base::grepl
[13:34:40.038]                           restarts <- computeRestarts(cond)
[13:34:40.038]                           for (restart in restarts) {
[13:34:40.038]                             name <- restart$name
[13:34:40.038]                             if (is.null(name)) 
[13:34:40.038]                               next
[13:34:40.038]                             if (!grepl(pattern, name)) 
[13:34:40.038]                               next
[13:34:40.038]                             invokeRestart(restart)
[13:34:40.038]                             muffled <- TRUE
[13:34:40.038]                             break
[13:34:40.038]                           }
[13:34:40.038]                         }
[13:34:40.038]                       }
[13:34:40.038]                       invisible(muffled)
[13:34:40.038]                     }
[13:34:40.038]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.038]                   }
[13:34:40.038]                 }
[13:34:40.038]             }
[13:34:40.038]         }))
[13:34:40.038]     }, error = function(ex) {
[13:34:40.038]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.038]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.038]                 ...future.rng), started = ...future.startTime, 
[13:34:40.038]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.038]             version = "1.8"), class = "FutureResult")
[13:34:40.038]     }, finally = {
[13:34:40.038]         if (!identical(...future.workdir, getwd())) 
[13:34:40.038]             setwd(...future.workdir)
[13:34:40.038]         {
[13:34:40.038]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.038]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.038]             }
[13:34:40.038]             base::options(...future.oldOptions)
[13:34:40.038]             if (.Platform$OS.type == "windows") {
[13:34:40.038]                 old_names <- names(...future.oldEnvVars)
[13:34:40.038]                 envs <- base::Sys.getenv()
[13:34:40.038]                 names <- names(envs)
[13:34:40.038]                 common <- intersect(names, old_names)
[13:34:40.038]                 added <- setdiff(names, old_names)
[13:34:40.038]                 removed <- setdiff(old_names, names)
[13:34:40.038]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.038]                   envs[common]]
[13:34:40.038]                 NAMES <- toupper(changed)
[13:34:40.038]                 args <- list()
[13:34:40.038]                 for (kk in seq_along(NAMES)) {
[13:34:40.038]                   name <- changed[[kk]]
[13:34:40.038]                   NAME <- NAMES[[kk]]
[13:34:40.038]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.038]                     next
[13:34:40.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.038]                 }
[13:34:40.038]                 NAMES <- toupper(added)
[13:34:40.038]                 for (kk in seq_along(NAMES)) {
[13:34:40.038]                   name <- added[[kk]]
[13:34:40.038]                   NAME <- NAMES[[kk]]
[13:34:40.038]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.038]                     next
[13:34:40.038]                   args[[name]] <- ""
[13:34:40.038]                 }
[13:34:40.038]                 NAMES <- toupper(removed)
[13:34:40.038]                 for (kk in seq_along(NAMES)) {
[13:34:40.038]                   name <- removed[[kk]]
[13:34:40.038]                   NAME <- NAMES[[kk]]
[13:34:40.038]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.038]                     next
[13:34:40.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.038]                 }
[13:34:40.038]                 if (length(args) > 0) 
[13:34:40.038]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.038]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.038]             }
[13:34:40.038]             else {
[13:34:40.038]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.038]             }
[13:34:40.038]             {
[13:34:40.038]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.038]                   0L) {
[13:34:40.038]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.038]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.038]                   base::options(opts)
[13:34:40.038]                 }
[13:34:40.038]                 {
[13:34:40.038]                   {
[13:34:40.038]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.038]                     NULL
[13:34:40.038]                   }
[13:34:40.038]                   options(future.plan = NULL)
[13:34:40.038]                   if (is.na(NA_character_)) 
[13:34:40.038]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.038]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.038]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.038]                     .init = FALSE)
[13:34:40.038]                 }
[13:34:40.038]             }
[13:34:40.038]         }
[13:34:40.038]     })
[13:34:40.038]     if (TRUE) {
[13:34:40.038]         base::sink(type = "output", split = FALSE)
[13:34:40.038]         if (TRUE) {
[13:34:40.038]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.038]         }
[13:34:40.038]         else {
[13:34:40.038]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.038]         }
[13:34:40.038]         base::close(...future.stdout)
[13:34:40.038]         ...future.stdout <- NULL
[13:34:40.038]     }
[13:34:40.038]     ...future.result$conditions <- ...future.conditions
[13:34:40.038]     ...future.result$finished <- base::Sys.time()
[13:34:40.038]     ...future.result
[13:34:40.038] }
[13:34:40.040] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[13:34:40.040] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:34:40.041] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:34:40.041] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:40.041] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.041] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:34:40.042] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:34:40.042] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:40.042] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.042] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:40.042] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.043] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[13:34:40.043] MultisessionFuture started
[13:34:40.043] - Launch lazy future ... done
[13:34:40.043] run() for ‘MultisessionFuture’ ... done
[13:34:40.043] Created future:
[13:34:40.043] MultisessionFuture:
[13:34:40.043] Label: ‘future_.mapply-1’
[13:34:40.043] Expression:
[13:34:40.043] {
[13:34:40.043]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.043]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.043]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.043]         on.exit(options(oopts), add = TRUE)
[13:34:40.043]     }
[13:34:40.043]     {
[13:34:40.043]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.043]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.043]         do.call(mapply, args = args)
[13:34:40.043]     }
[13:34:40.043] }
[13:34:40.043] Lazy evaluation: FALSE
[13:34:40.043] Asynchronous evaluation: TRUE
[13:34:40.043] Local evaluation: TRUE
[13:34:40.043] Environment: R_GlobalEnv
[13:34:40.043] Capture standard output: TRUE
[13:34:40.043] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.043] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.043] Packages: <none>
[13:34:40.043] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:40.043] Resolved: FALSE
[13:34:40.043] Value: <not collected>
[13:34:40.043] Conditions captured: <none>
[13:34:40.043] Early signaling: FALSE
[13:34:40.043] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.043] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.055] Chunk #1 of 1 ... DONE
[13:34:40.055] Launching 1 futures (chunks) ... DONE
[13:34:40.055] Resolving 1 futures (chunks) ...
[13:34:40.055] resolve() on list ...
[13:34:40.055]  recursive: 0
[13:34:40.055]  length: 1
[13:34:40.055] 
[13:34:40.097] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.097] - Validating connection of MultisessionFuture
[13:34:40.097] - received message: FutureResult
[13:34:40.097] - Received FutureResult
[13:34:40.097] - Erased future from FutureRegistry
[13:34:40.098] result() for ClusterFuture ...
[13:34:40.098] - result already collected: FutureResult
[13:34:40.098] result() for ClusterFuture ... done
[13:34:40.098] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.098] Future #1
[13:34:40.098] result() for ClusterFuture ...
[13:34:40.098] - result already collected: FutureResult
[13:34:40.098] result() for ClusterFuture ... done
[13:34:40.098] result() for ClusterFuture ...
[13:34:40.098] - result already collected: FutureResult
[13:34:40.099] result() for ClusterFuture ... done
[13:34:40.099] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:40.099] - nx: 1
[13:34:40.099] - relay: TRUE
[13:34:40.099] - stdout: TRUE
[13:34:40.099] - signal: TRUE
[13:34:40.099] - resignal: FALSE
[13:34:40.099] - force: TRUE
[13:34:40.099] - relayed: [n=1] FALSE
[13:34:40.099] - queued futures: [n=1] FALSE
[13:34:40.099]  - until=1
[13:34:40.100]  - relaying element #1
[13:34:40.100] result() for ClusterFuture ...
[13:34:40.100] - result already collected: FutureResult
[13:34:40.100] result() for ClusterFuture ... done
[13:34:40.100] result() for ClusterFuture ...
[13:34:40.100] - result already collected: FutureResult
[13:34:40.100] result() for ClusterFuture ... done
[13:34:40.100] result() for ClusterFuture ...
[13:34:40.100] - result already collected: FutureResult
[13:34:40.100] result() for ClusterFuture ... done
[13:34:40.100] result() for ClusterFuture ...
[13:34:40.101] - result already collected: FutureResult
[13:34:40.101] result() for ClusterFuture ... done
[13:34:40.101] - relayed: [n=1] TRUE
[13:34:40.101] - queued futures: [n=1] TRUE
[13:34:40.101] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:40.101]  length: 0 (resolved future 1)
[13:34:40.101] Relaying remaining futures
[13:34:40.101] signalConditionsASAP(NULL, pos=0) ...
[13:34:40.101] - nx: 1
[13:34:40.101] - relay: TRUE
[13:34:40.101] - stdout: TRUE
[13:34:40.101] - signal: TRUE
[13:34:40.102] - resignal: FALSE
[13:34:40.102] - force: TRUE
[13:34:40.102] - relayed: [n=1] TRUE
[13:34:40.102] - queued futures: [n=1] TRUE
 - flush all
[13:34:40.102] - relayed: [n=1] TRUE
[13:34:40.102] - queued futures: [n=1] TRUE
[13:34:40.102] signalConditionsASAP(NULL, pos=0) ... done
[13:34:40.102] resolve() on list ... DONE
[13:34:40.102] result() for ClusterFuture ...
[13:34:40.102] - result already collected: FutureResult
[13:34:40.102] result() for ClusterFuture ... done
[13:34:40.103] result() for ClusterFuture ...
[13:34:40.103] - result already collected: FutureResult
[13:34:40.103] result() for ClusterFuture ... done
[13:34:40.103]  - Number of value chunks collected: 1
[13:34:40.103] Resolving 1 futures (chunks) ... DONE
[13:34:40.103] Reducing values from 1 chunks ...
[13:34:40.103]  - Number of values collected after concatenation: 1
[13:34:40.103]  - Number of values expected: 1
[13:34:40.103] Reducing values from 1 chunks ... DONE
[13:34:40.103] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[13:34:40.104] future_mapply() ...
[13:34:40.107] Number of chunks: 2
[13:34:40.107] getGlobalsAndPackagesXApply() ...
[13:34:40.107]  - future.globals: TRUE
[13:34:40.108] getGlobalsAndPackages() ...
[13:34:40.108] Searching for globals...
[13:34:40.109] - globals found: [1] ‘FUN’
[13:34:40.109] Searching for globals ... DONE
[13:34:40.109] Resolving globals: FALSE
[13:34:40.109] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[13:34:40.109] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[13:34:40.110] - globals: [1] ‘FUN’
[13:34:40.110] 
[13:34:40.110] getGlobalsAndPackages() ... DONE
[13:34:40.110]  - globals found/used: [n=1] ‘FUN’
[13:34:40.110]  - needed namespaces: [n=0] 
[13:34:40.110] Finding globals ... DONE
[13:34:40.110] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:40.110] List of 2
[13:34:40.110]  $ ...future.FUN:function (x, y)  
[13:34:40.110]  $ MoreArgs     :List of 1
[13:34:40.110]   ..$ y: int [1:2] 3 4
[13:34:40.110]  - attr(*, "where")=List of 2
[13:34:40.110]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:40.110]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:40.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:40.110]  - attr(*, "resolved")= logi FALSE
[13:34:40.110]  - attr(*, "total_size")= num NA
[13:34:40.113] Packages to be attached in all futures: [n=0] 
[13:34:40.113] getGlobalsAndPackagesXApply() ... DONE
[13:34:40.113] Number of futures (= number of chunks): 2
[13:34:40.114] Launching 2 futures (chunks) ...
[13:34:40.114] Chunk #1 of 2 ...
[13:34:40.114]  - Finding globals in '...' for chunk #1 ...
[13:34:40.114] getGlobalsAndPackages() ...
[13:34:40.114] Searching for globals...
[13:34:40.114] 
[13:34:40.114] Searching for globals ... DONE
[13:34:40.114] - globals: [0] <none>
[13:34:40.115] getGlobalsAndPackages() ... DONE
[13:34:40.115]    + additional globals found: [n=0] 
[13:34:40.115]    + additional namespaces needed: [n=0] 
[13:34:40.115]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:40.115]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.115]  - seeds: <none>
[13:34:40.115]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.115] getGlobalsAndPackages() ...
[13:34:40.115] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.115] Resolving globals: FALSE
[13:34:40.116] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[13:34:40.116] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[13:34:40.116] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.117] 
[13:34:40.117] getGlobalsAndPackages() ... DONE
[13:34:40.117] run() for ‘Future’ ...
[13:34:40.117] - state: ‘created’
[13:34:40.117] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.131] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.131]   - Field: ‘node’
[13:34:40.131]   - Field: ‘label’
[13:34:40.131]   - Field: ‘local’
[13:34:40.131]   - Field: ‘owner’
[13:34:40.131]   - Field: ‘envir’
[13:34:40.131]   - Field: ‘workers’
[13:34:40.131]   - Field: ‘packages’
[13:34:40.131]   - Field: ‘gc’
[13:34:40.132]   - Field: ‘conditions’
[13:34:40.132]   - Field: ‘persistent’
[13:34:40.132]   - Field: ‘expr’
[13:34:40.132]   - Field: ‘uuid’
[13:34:40.132]   - Field: ‘seed’
[13:34:40.132]   - Field: ‘version’
[13:34:40.132]   - Field: ‘result’
[13:34:40.132]   - Field: ‘asynchronous’
[13:34:40.132]   - Field: ‘calls’
[13:34:40.132]   - Field: ‘globals’
[13:34:40.132]   - Field: ‘stdout’
[13:34:40.133]   - Field: ‘earlySignal’
[13:34:40.133]   - Field: ‘lazy’
[13:34:40.133]   - Field: ‘state’
[13:34:40.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.133] - Launch lazy future ...
[13:34:40.133] Packages needed by the future expression (n = 0): <none>
[13:34:40.133] Packages needed by future strategies (n = 0): <none>
[13:34:40.134] {
[13:34:40.134]     {
[13:34:40.134]         {
[13:34:40.134]             ...future.startTime <- base::Sys.time()
[13:34:40.134]             {
[13:34:40.134]                 {
[13:34:40.134]                   {
[13:34:40.134]                     {
[13:34:40.134]                       base::local({
[13:34:40.134]                         has_future <- base::requireNamespace("future", 
[13:34:40.134]                           quietly = TRUE)
[13:34:40.134]                         if (has_future) {
[13:34:40.134]                           ns <- base::getNamespace("future")
[13:34:40.134]                           version <- ns[[".package"]][["version"]]
[13:34:40.134]                           if (is.null(version)) 
[13:34:40.134]                             version <- utils::packageVersion("future")
[13:34:40.134]                         }
[13:34:40.134]                         else {
[13:34:40.134]                           version <- NULL
[13:34:40.134]                         }
[13:34:40.134]                         if (!has_future || version < "1.8.0") {
[13:34:40.134]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.134]                             "", base::R.version$version.string), 
[13:34:40.134]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:40.134]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:40.134]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.134]                               "release", "version")], collapse = " "), 
[13:34:40.134]                             hostname = base::Sys.info()[["nodename"]])
[13:34:40.134]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.134]                             info)
[13:34:40.134]                           info <- base::paste(info, collapse = "; ")
[13:34:40.134]                           if (!has_future) {
[13:34:40.134]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.134]                               info)
[13:34:40.134]                           }
[13:34:40.134]                           else {
[13:34:40.134]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.134]                               info, version)
[13:34:40.134]                           }
[13:34:40.134]                           base::stop(msg)
[13:34:40.134]                         }
[13:34:40.134]                       })
[13:34:40.134]                     }
[13:34:40.134]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.134]                     base::options(mc.cores = 1L)
[13:34:40.134]                   }
[13:34:40.134]                   ...future.strategy.old <- future::plan("list")
[13:34:40.134]                   options(future.plan = NULL)
[13:34:40.134]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.134]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.134]                 }
[13:34:40.134]                 ...future.workdir <- getwd()
[13:34:40.134]             }
[13:34:40.134]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.134]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.134]         }
[13:34:40.134]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.134]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.134]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.134]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.134]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.134]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.134]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.134]             base::names(...future.oldOptions))
[13:34:40.134]     }
[13:34:40.134]     if (FALSE) {
[13:34:40.134]     }
[13:34:40.134]     else {
[13:34:40.134]         if (TRUE) {
[13:34:40.134]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.134]                 open = "w")
[13:34:40.134]         }
[13:34:40.134]         else {
[13:34:40.134]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.134]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.134]         }
[13:34:40.134]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.134]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.134]             base::sink(type = "output", split = FALSE)
[13:34:40.134]             base::close(...future.stdout)
[13:34:40.134]         }, add = TRUE)
[13:34:40.134]     }
[13:34:40.134]     ...future.frame <- base::sys.nframe()
[13:34:40.134]     ...future.conditions <- base::list()
[13:34:40.134]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.134]     if (FALSE) {
[13:34:40.134]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.134]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.134]     }
[13:34:40.134]     ...future.result <- base::tryCatch({
[13:34:40.134]         base::withCallingHandlers({
[13:34:40.134]             ...future.value <- base::withVisible(base::local({
[13:34:40.134]                 ...future.makeSendCondition <- base::local({
[13:34:40.134]                   sendCondition <- NULL
[13:34:40.134]                   function(frame = 1L) {
[13:34:40.134]                     if (is.function(sendCondition)) 
[13:34:40.134]                       return(sendCondition)
[13:34:40.134]                     ns <- getNamespace("parallel")
[13:34:40.134]                     if (exists("sendData", mode = "function", 
[13:34:40.134]                       envir = ns)) {
[13:34:40.134]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.134]                         envir = ns)
[13:34:40.134]                       envir <- sys.frame(frame)
[13:34:40.134]                       master <- NULL
[13:34:40.134]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.134]                         !identical(envir, emptyenv())) {
[13:34:40.134]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.134]                           inherits = FALSE)) {
[13:34:40.134]                           master <- get("master", mode = "list", 
[13:34:40.134]                             envir = envir, inherits = FALSE)
[13:34:40.134]                           if (inherits(master, c("SOCKnode", 
[13:34:40.134]                             "SOCK0node"))) {
[13:34:40.134]                             sendCondition <<- function(cond) {
[13:34:40.134]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.134]                                 success = TRUE)
[13:34:40.134]                               parallel_sendData(master, data)
[13:34:40.134]                             }
[13:34:40.134]                             return(sendCondition)
[13:34:40.134]                           }
[13:34:40.134]                         }
[13:34:40.134]                         frame <- frame + 1L
[13:34:40.134]                         envir <- sys.frame(frame)
[13:34:40.134]                       }
[13:34:40.134]                     }
[13:34:40.134]                     sendCondition <<- function(cond) NULL
[13:34:40.134]                   }
[13:34:40.134]                 })
[13:34:40.134]                 withCallingHandlers({
[13:34:40.134]                   {
[13:34:40.134]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.134]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.134]                       ...future.globals.maxSize)) {
[13:34:40.134]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.134]                       on.exit(options(oopts), add = TRUE)
[13:34:40.134]                     }
[13:34:40.134]                     {
[13:34:40.134]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.134]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.134]                         USE.NAMES = FALSE)
[13:34:40.134]                       do.call(mapply, args = args)
[13:34:40.134]                     }
[13:34:40.134]                   }
[13:34:40.134]                 }, immediateCondition = function(cond) {
[13:34:40.134]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.134]                   sendCondition(cond)
[13:34:40.134]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.134]                   {
[13:34:40.134]                     inherits <- base::inherits
[13:34:40.134]                     invokeRestart <- base::invokeRestart
[13:34:40.134]                     is.null <- base::is.null
[13:34:40.134]                     muffled <- FALSE
[13:34:40.134]                     if (inherits(cond, "message")) {
[13:34:40.134]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.134]                       if (muffled) 
[13:34:40.134]                         invokeRestart("muffleMessage")
[13:34:40.134]                     }
[13:34:40.134]                     else if (inherits(cond, "warning")) {
[13:34:40.134]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.134]                       if (muffled) 
[13:34:40.134]                         invokeRestart("muffleWarning")
[13:34:40.134]                     }
[13:34:40.134]                     else if (inherits(cond, "condition")) {
[13:34:40.134]                       if (!is.null(pattern)) {
[13:34:40.134]                         computeRestarts <- base::computeRestarts
[13:34:40.134]                         grepl <- base::grepl
[13:34:40.134]                         restarts <- computeRestarts(cond)
[13:34:40.134]                         for (restart in restarts) {
[13:34:40.134]                           name <- restart$name
[13:34:40.134]                           if (is.null(name)) 
[13:34:40.134]                             next
[13:34:40.134]                           if (!grepl(pattern, name)) 
[13:34:40.134]                             next
[13:34:40.134]                           invokeRestart(restart)
[13:34:40.134]                           muffled <- TRUE
[13:34:40.134]                           break
[13:34:40.134]                         }
[13:34:40.134]                       }
[13:34:40.134]                     }
[13:34:40.134]                     invisible(muffled)
[13:34:40.134]                   }
[13:34:40.134]                   muffleCondition(cond)
[13:34:40.134]                 })
[13:34:40.134]             }))
[13:34:40.134]             future::FutureResult(value = ...future.value$value, 
[13:34:40.134]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.134]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.134]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.134]                     ...future.globalenv.names))
[13:34:40.134]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.134]         }, condition = base::local({
[13:34:40.134]             c <- base::c
[13:34:40.134]             inherits <- base::inherits
[13:34:40.134]             invokeRestart <- base::invokeRestart
[13:34:40.134]             length <- base::length
[13:34:40.134]             list <- base::list
[13:34:40.134]             seq.int <- base::seq.int
[13:34:40.134]             signalCondition <- base::signalCondition
[13:34:40.134]             sys.calls <- base::sys.calls
[13:34:40.134]             `[[` <- base::`[[`
[13:34:40.134]             `+` <- base::`+`
[13:34:40.134]             `<<-` <- base::`<<-`
[13:34:40.134]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.134]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.134]                   3L)]
[13:34:40.134]             }
[13:34:40.134]             function(cond) {
[13:34:40.134]                 is_error <- inherits(cond, "error")
[13:34:40.134]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.134]                   NULL)
[13:34:40.134]                 if (is_error) {
[13:34:40.134]                   sessionInformation <- function() {
[13:34:40.134]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.134]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.134]                       search = base::search(), system = base::Sys.info())
[13:34:40.134]                   }
[13:34:40.134]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.134]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.134]                     cond$call), session = sessionInformation(), 
[13:34:40.134]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.134]                   signalCondition(cond)
[13:34:40.134]                 }
[13:34:40.134]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.134]                 "immediateCondition"))) {
[13:34:40.134]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.134]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.134]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.134]                   if (TRUE && !signal) {
[13:34:40.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.134]                     {
[13:34:40.134]                       inherits <- base::inherits
[13:34:40.134]                       invokeRestart <- base::invokeRestart
[13:34:40.134]                       is.null <- base::is.null
[13:34:40.134]                       muffled <- FALSE
[13:34:40.134]                       if (inherits(cond, "message")) {
[13:34:40.134]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.134]                         if (muffled) 
[13:34:40.134]                           invokeRestart("muffleMessage")
[13:34:40.134]                       }
[13:34:40.134]                       else if (inherits(cond, "warning")) {
[13:34:40.134]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.134]                         if (muffled) 
[13:34:40.134]                           invokeRestart("muffleWarning")
[13:34:40.134]                       }
[13:34:40.134]                       else if (inherits(cond, "condition")) {
[13:34:40.134]                         if (!is.null(pattern)) {
[13:34:40.134]                           computeRestarts <- base::computeRestarts
[13:34:40.134]                           grepl <- base::grepl
[13:34:40.134]                           restarts <- computeRestarts(cond)
[13:34:40.134]                           for (restart in restarts) {
[13:34:40.134]                             name <- restart$name
[13:34:40.134]                             if (is.null(name)) 
[13:34:40.134]                               next
[13:34:40.134]                             if (!grepl(pattern, name)) 
[13:34:40.134]                               next
[13:34:40.134]                             invokeRestart(restart)
[13:34:40.134]                             muffled <- TRUE
[13:34:40.134]                             break
[13:34:40.134]                           }
[13:34:40.134]                         }
[13:34:40.134]                       }
[13:34:40.134]                       invisible(muffled)
[13:34:40.134]                     }
[13:34:40.134]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.134]                   }
[13:34:40.134]                 }
[13:34:40.134]                 else {
[13:34:40.134]                   if (TRUE) {
[13:34:40.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.134]                     {
[13:34:40.134]                       inherits <- base::inherits
[13:34:40.134]                       invokeRestart <- base::invokeRestart
[13:34:40.134]                       is.null <- base::is.null
[13:34:40.134]                       muffled <- FALSE
[13:34:40.134]                       if (inherits(cond, "message")) {
[13:34:40.134]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.134]                         if (muffled) 
[13:34:40.134]                           invokeRestart("muffleMessage")
[13:34:40.134]                       }
[13:34:40.134]                       else if (inherits(cond, "warning")) {
[13:34:40.134]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.134]                         if (muffled) 
[13:34:40.134]                           invokeRestart("muffleWarning")
[13:34:40.134]                       }
[13:34:40.134]                       else if (inherits(cond, "condition")) {
[13:34:40.134]                         if (!is.null(pattern)) {
[13:34:40.134]                           computeRestarts <- base::computeRestarts
[13:34:40.134]                           grepl <- base::grepl
[13:34:40.134]                           restarts <- computeRestarts(cond)
[13:34:40.134]                           for (restart in restarts) {
[13:34:40.134]                             name <- restart$name
[13:34:40.134]                             if (is.null(name)) 
[13:34:40.134]                               next
[13:34:40.134]                             if (!grepl(pattern, name)) 
[13:34:40.134]                               next
[13:34:40.134]                             invokeRestart(restart)
[13:34:40.134]                             muffled <- TRUE
[13:34:40.134]                             break
[13:34:40.134]                           }
[13:34:40.134]                         }
[13:34:40.134]                       }
[13:34:40.134]                       invisible(muffled)
[13:34:40.134]                     }
[13:34:40.134]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.134]                   }
[13:34:40.134]                 }
[13:34:40.134]             }
[13:34:40.134]         }))
[13:34:40.134]     }, error = function(ex) {
[13:34:40.134]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.134]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.134]                 ...future.rng), started = ...future.startTime, 
[13:34:40.134]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.134]             version = "1.8"), class = "FutureResult")
[13:34:40.134]     }, finally = {
[13:34:40.134]         if (!identical(...future.workdir, getwd())) 
[13:34:40.134]             setwd(...future.workdir)
[13:34:40.134]         {
[13:34:40.134]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.134]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.134]             }
[13:34:40.134]             base::options(...future.oldOptions)
[13:34:40.134]             if (.Platform$OS.type == "windows") {
[13:34:40.134]                 old_names <- names(...future.oldEnvVars)
[13:34:40.134]                 envs <- base::Sys.getenv()
[13:34:40.134]                 names <- names(envs)
[13:34:40.134]                 common <- intersect(names, old_names)
[13:34:40.134]                 added <- setdiff(names, old_names)
[13:34:40.134]                 removed <- setdiff(old_names, names)
[13:34:40.134]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.134]                   envs[common]]
[13:34:40.134]                 NAMES <- toupper(changed)
[13:34:40.134]                 args <- list()
[13:34:40.134]                 for (kk in seq_along(NAMES)) {
[13:34:40.134]                   name <- changed[[kk]]
[13:34:40.134]                   NAME <- NAMES[[kk]]
[13:34:40.134]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.134]                     next
[13:34:40.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.134]                 }
[13:34:40.134]                 NAMES <- toupper(added)
[13:34:40.134]                 for (kk in seq_along(NAMES)) {
[13:34:40.134]                   name <- added[[kk]]
[13:34:40.134]                   NAME <- NAMES[[kk]]
[13:34:40.134]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.134]                     next
[13:34:40.134]                   args[[name]] <- ""
[13:34:40.134]                 }
[13:34:40.134]                 NAMES <- toupper(removed)
[13:34:40.134]                 for (kk in seq_along(NAMES)) {
[13:34:40.134]                   name <- removed[[kk]]
[13:34:40.134]                   NAME <- NAMES[[kk]]
[13:34:40.134]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.134]                     next
[13:34:40.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.134]                 }
[13:34:40.134]                 if (length(args) > 0) 
[13:34:40.134]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.134]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.134]             }
[13:34:40.134]             else {
[13:34:40.134]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.134]             }
[13:34:40.134]             {
[13:34:40.134]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.134]                   0L) {
[13:34:40.134]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.134]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.134]                   base::options(opts)
[13:34:40.134]                 }
[13:34:40.134]                 {
[13:34:40.134]                   {
[13:34:40.134]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.134]                     NULL
[13:34:40.134]                   }
[13:34:40.134]                   options(future.plan = NULL)
[13:34:40.134]                   if (is.na(NA_character_)) 
[13:34:40.134]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.134]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.134]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.134]                     .init = FALSE)
[13:34:40.134]                 }
[13:34:40.134]             }
[13:34:40.134]         }
[13:34:40.134]     })
[13:34:40.134]     if (TRUE) {
[13:34:40.134]         base::sink(type = "output", split = FALSE)
[13:34:40.134]         if (TRUE) {
[13:34:40.134]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.134]         }
[13:34:40.134]         else {
[13:34:40.134]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.134]         }
[13:34:40.134]         base::close(...future.stdout)
[13:34:40.134]         ...future.stdout <- NULL
[13:34:40.134]     }
[13:34:40.134]     ...future.result$conditions <- ...future.conditions
[13:34:40.134]     ...future.result$finished <- base::Sys.time()
[13:34:40.134]     ...future.result
[13:34:40.134] }
[13:34:40.136] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[13:34:40.136] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[13:34:40.137] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[13:34:40.137] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[13:34:40.137] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[13:34:40.137] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:34:40.138] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:34:40.138] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:40.138] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.138] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:40.138] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.139] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[13:34:40.139] MultisessionFuture started
[13:34:40.139] - Launch lazy future ... done
[13:34:40.139] run() for ‘MultisessionFuture’ ... done
[13:34:40.139] Created future:
[13:34:40.139] MultisessionFuture:
[13:34:40.139] Label: ‘future_mapply-1’
[13:34:40.139] Expression:
[13:34:40.139] {
[13:34:40.139]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.139]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.139]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.139]         on.exit(options(oopts), add = TRUE)
[13:34:40.139]     }
[13:34:40.139]     {
[13:34:40.139]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.139]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.139]         do.call(mapply, args = args)
[13:34:40.139]     }
[13:34:40.139] }
[13:34:40.139] Lazy evaluation: FALSE
[13:34:40.139] Asynchronous evaluation: TRUE
[13:34:40.139] Local evaluation: TRUE
[13:34:40.139] Environment: R_GlobalEnv
[13:34:40.139] Capture standard output: TRUE
[13:34:40.139] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.139] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.139] Packages: <none>
[13:34:40.139] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:40.139] Resolved: FALSE
[13:34:40.139] Value: <not collected>
[13:34:40.139] Conditions captured: <none>
[13:34:40.139] Early signaling: FALSE
[13:34:40.139] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.139] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.151] Chunk #1 of 2 ... DONE
[13:34:40.151] Chunk #2 of 2 ...
[13:34:40.151]  - Finding globals in '...' for chunk #2 ...
[13:34:40.151] getGlobalsAndPackages() ...
[13:34:40.151] Searching for globals...
[13:34:40.151] 
[13:34:40.152] Searching for globals ... DONE
[13:34:40.152] - globals: [0] <none>
[13:34:40.152] getGlobalsAndPackages() ... DONE
[13:34:40.152]    + additional globals found: [n=0] 
[13:34:40.152]    + additional namespaces needed: [n=0] 
[13:34:40.152]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:40.152]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.152]  - seeds: <none>
[13:34:40.152]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.152] getGlobalsAndPackages() ...
[13:34:40.152] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.153] Resolving globals: FALSE
[13:34:40.153] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[13:34:40.153] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[13:34:40.153] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.154] 
[13:34:40.154] getGlobalsAndPackages() ... DONE
[13:34:40.157] run() for ‘Future’ ...
[13:34:40.157] - state: ‘created’
[13:34:40.157] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.170] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.171]   - Field: ‘node’
[13:34:40.171]   - Field: ‘label’
[13:34:40.171]   - Field: ‘local’
[13:34:40.171]   - Field: ‘owner’
[13:34:40.171]   - Field: ‘envir’
[13:34:40.171]   - Field: ‘workers’
[13:34:40.171]   - Field: ‘packages’
[13:34:40.171]   - Field: ‘gc’
[13:34:40.171]   - Field: ‘conditions’
[13:34:40.171]   - Field: ‘persistent’
[13:34:40.171]   - Field: ‘expr’
[13:34:40.172]   - Field: ‘uuid’
[13:34:40.172]   - Field: ‘seed’
[13:34:40.172]   - Field: ‘version’
[13:34:40.172]   - Field: ‘result’
[13:34:40.172]   - Field: ‘asynchronous’
[13:34:40.172]   - Field: ‘calls’
[13:34:40.172]   - Field: ‘globals’
[13:34:40.172]   - Field: ‘stdout’
[13:34:40.172]   - Field: ‘earlySignal’
[13:34:40.172]   - Field: ‘lazy’
[13:34:40.172]   - Field: ‘state’
[13:34:40.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.173] - Launch lazy future ...
[13:34:40.173] Packages needed by the future expression (n = 0): <none>
[13:34:40.173] Packages needed by future strategies (n = 0): <none>
[13:34:40.173] {
[13:34:40.173]     {
[13:34:40.173]         {
[13:34:40.173]             ...future.startTime <- base::Sys.time()
[13:34:40.173]             {
[13:34:40.173]                 {
[13:34:40.173]                   {
[13:34:40.173]                     {
[13:34:40.173]                       base::local({
[13:34:40.173]                         has_future <- base::requireNamespace("future", 
[13:34:40.173]                           quietly = TRUE)
[13:34:40.173]                         if (has_future) {
[13:34:40.173]                           ns <- base::getNamespace("future")
[13:34:40.173]                           version <- ns[[".package"]][["version"]]
[13:34:40.173]                           if (is.null(version)) 
[13:34:40.173]                             version <- utils::packageVersion("future")
[13:34:40.173]                         }
[13:34:40.173]                         else {
[13:34:40.173]                           version <- NULL
[13:34:40.173]                         }
[13:34:40.173]                         if (!has_future || version < "1.8.0") {
[13:34:40.173]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.173]                             "", base::R.version$version.string), 
[13:34:40.173]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:40.173]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:40.173]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.173]                               "release", "version")], collapse = " "), 
[13:34:40.173]                             hostname = base::Sys.info()[["nodename"]])
[13:34:40.173]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.173]                             info)
[13:34:40.173]                           info <- base::paste(info, collapse = "; ")
[13:34:40.173]                           if (!has_future) {
[13:34:40.173]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.173]                               info)
[13:34:40.173]                           }
[13:34:40.173]                           else {
[13:34:40.173]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.173]                               info, version)
[13:34:40.173]                           }
[13:34:40.173]                           base::stop(msg)
[13:34:40.173]                         }
[13:34:40.173]                       })
[13:34:40.173]                     }
[13:34:40.173]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.173]                     base::options(mc.cores = 1L)
[13:34:40.173]                   }
[13:34:40.173]                   ...future.strategy.old <- future::plan("list")
[13:34:40.173]                   options(future.plan = NULL)
[13:34:40.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.173]                 }
[13:34:40.173]                 ...future.workdir <- getwd()
[13:34:40.173]             }
[13:34:40.173]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.173]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.173]         }
[13:34:40.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.173]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.173]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.173]             base::names(...future.oldOptions))
[13:34:40.173]     }
[13:34:40.173]     if (FALSE) {
[13:34:40.173]     }
[13:34:40.173]     else {
[13:34:40.173]         if (TRUE) {
[13:34:40.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.173]                 open = "w")
[13:34:40.173]         }
[13:34:40.173]         else {
[13:34:40.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.173]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.173]         }
[13:34:40.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.173]             base::sink(type = "output", split = FALSE)
[13:34:40.173]             base::close(...future.stdout)
[13:34:40.173]         }, add = TRUE)
[13:34:40.173]     }
[13:34:40.173]     ...future.frame <- base::sys.nframe()
[13:34:40.173]     ...future.conditions <- base::list()
[13:34:40.173]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.173]     if (FALSE) {
[13:34:40.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.173]     }
[13:34:40.173]     ...future.result <- base::tryCatch({
[13:34:40.173]         base::withCallingHandlers({
[13:34:40.173]             ...future.value <- base::withVisible(base::local({
[13:34:40.173]                 ...future.makeSendCondition <- base::local({
[13:34:40.173]                   sendCondition <- NULL
[13:34:40.173]                   function(frame = 1L) {
[13:34:40.173]                     if (is.function(sendCondition)) 
[13:34:40.173]                       return(sendCondition)
[13:34:40.173]                     ns <- getNamespace("parallel")
[13:34:40.173]                     if (exists("sendData", mode = "function", 
[13:34:40.173]                       envir = ns)) {
[13:34:40.173]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.173]                         envir = ns)
[13:34:40.173]                       envir <- sys.frame(frame)
[13:34:40.173]                       master <- NULL
[13:34:40.173]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.173]                         !identical(envir, emptyenv())) {
[13:34:40.173]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.173]                           inherits = FALSE)) {
[13:34:40.173]                           master <- get("master", mode = "list", 
[13:34:40.173]                             envir = envir, inherits = FALSE)
[13:34:40.173]                           if (inherits(master, c("SOCKnode", 
[13:34:40.173]                             "SOCK0node"))) {
[13:34:40.173]                             sendCondition <<- function(cond) {
[13:34:40.173]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.173]                                 success = TRUE)
[13:34:40.173]                               parallel_sendData(master, data)
[13:34:40.173]                             }
[13:34:40.173]                             return(sendCondition)
[13:34:40.173]                           }
[13:34:40.173]                         }
[13:34:40.173]                         frame <- frame + 1L
[13:34:40.173]                         envir <- sys.frame(frame)
[13:34:40.173]                       }
[13:34:40.173]                     }
[13:34:40.173]                     sendCondition <<- function(cond) NULL
[13:34:40.173]                   }
[13:34:40.173]                 })
[13:34:40.173]                 withCallingHandlers({
[13:34:40.173]                   {
[13:34:40.173]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.173]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.173]                       ...future.globals.maxSize)) {
[13:34:40.173]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.173]                       on.exit(options(oopts), add = TRUE)
[13:34:40.173]                     }
[13:34:40.173]                     {
[13:34:40.173]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.173]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.173]                         USE.NAMES = FALSE)
[13:34:40.173]                       do.call(mapply, args = args)
[13:34:40.173]                     }
[13:34:40.173]                   }
[13:34:40.173]                 }, immediateCondition = function(cond) {
[13:34:40.173]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.173]                   sendCondition(cond)
[13:34:40.173]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.173]                   {
[13:34:40.173]                     inherits <- base::inherits
[13:34:40.173]                     invokeRestart <- base::invokeRestart
[13:34:40.173]                     is.null <- base::is.null
[13:34:40.173]                     muffled <- FALSE
[13:34:40.173]                     if (inherits(cond, "message")) {
[13:34:40.173]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.173]                       if (muffled) 
[13:34:40.173]                         invokeRestart("muffleMessage")
[13:34:40.173]                     }
[13:34:40.173]                     else if (inherits(cond, "warning")) {
[13:34:40.173]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.173]                       if (muffled) 
[13:34:40.173]                         invokeRestart("muffleWarning")
[13:34:40.173]                     }
[13:34:40.173]                     else if (inherits(cond, "condition")) {
[13:34:40.173]                       if (!is.null(pattern)) {
[13:34:40.173]                         computeRestarts <- base::computeRestarts
[13:34:40.173]                         grepl <- base::grepl
[13:34:40.173]                         restarts <- computeRestarts(cond)
[13:34:40.173]                         for (restart in restarts) {
[13:34:40.173]                           name <- restart$name
[13:34:40.173]                           if (is.null(name)) 
[13:34:40.173]                             next
[13:34:40.173]                           if (!grepl(pattern, name)) 
[13:34:40.173]                             next
[13:34:40.173]                           invokeRestart(restart)
[13:34:40.173]                           muffled <- TRUE
[13:34:40.173]                           break
[13:34:40.173]                         }
[13:34:40.173]                       }
[13:34:40.173]                     }
[13:34:40.173]                     invisible(muffled)
[13:34:40.173]                   }
[13:34:40.173]                   muffleCondition(cond)
[13:34:40.173]                 })
[13:34:40.173]             }))
[13:34:40.173]             future::FutureResult(value = ...future.value$value, 
[13:34:40.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.173]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.173]                     ...future.globalenv.names))
[13:34:40.173]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.173]         }, condition = base::local({
[13:34:40.173]             c <- base::c
[13:34:40.173]             inherits <- base::inherits
[13:34:40.173]             invokeRestart <- base::invokeRestart
[13:34:40.173]             length <- base::length
[13:34:40.173]             list <- base::list
[13:34:40.173]             seq.int <- base::seq.int
[13:34:40.173]             signalCondition <- base::signalCondition
[13:34:40.173]             sys.calls <- base::sys.calls
[13:34:40.173]             `[[` <- base::`[[`
[13:34:40.173]             `+` <- base::`+`
[13:34:40.173]             `<<-` <- base::`<<-`
[13:34:40.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.173]                   3L)]
[13:34:40.173]             }
[13:34:40.173]             function(cond) {
[13:34:40.173]                 is_error <- inherits(cond, "error")
[13:34:40.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.173]                   NULL)
[13:34:40.173]                 if (is_error) {
[13:34:40.173]                   sessionInformation <- function() {
[13:34:40.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.173]                       search = base::search(), system = base::Sys.info())
[13:34:40.173]                   }
[13:34:40.173]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.173]                     cond$call), session = sessionInformation(), 
[13:34:40.173]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.173]                   signalCondition(cond)
[13:34:40.173]                 }
[13:34:40.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.173]                 "immediateCondition"))) {
[13:34:40.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.173]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.173]                   if (TRUE && !signal) {
[13:34:40.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.173]                     {
[13:34:40.173]                       inherits <- base::inherits
[13:34:40.173]                       invokeRestart <- base::invokeRestart
[13:34:40.173]                       is.null <- base::is.null
[13:34:40.173]                       muffled <- FALSE
[13:34:40.173]                       if (inherits(cond, "message")) {
[13:34:40.173]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.173]                         if (muffled) 
[13:34:40.173]                           invokeRestart("muffleMessage")
[13:34:40.173]                       }
[13:34:40.173]                       else if (inherits(cond, "warning")) {
[13:34:40.173]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.173]                         if (muffled) 
[13:34:40.173]                           invokeRestart("muffleWarning")
[13:34:40.173]                       }
[13:34:40.173]                       else if (inherits(cond, "condition")) {
[13:34:40.173]                         if (!is.null(pattern)) {
[13:34:40.173]                           computeRestarts <- base::computeRestarts
[13:34:40.173]                           grepl <- base::grepl
[13:34:40.173]                           restarts <- computeRestarts(cond)
[13:34:40.173]                           for (restart in restarts) {
[13:34:40.173]                             name <- restart$name
[13:34:40.173]                             if (is.null(name)) 
[13:34:40.173]                               next
[13:34:40.173]                             if (!grepl(pattern, name)) 
[13:34:40.173]                               next
[13:34:40.173]                             invokeRestart(restart)
[13:34:40.173]                             muffled <- TRUE
[13:34:40.173]                             break
[13:34:40.173]                           }
[13:34:40.173]                         }
[13:34:40.173]                       }
[13:34:40.173]                       invisible(muffled)
[13:34:40.173]                     }
[13:34:40.173]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.173]                   }
[13:34:40.173]                 }
[13:34:40.173]                 else {
[13:34:40.173]                   if (TRUE) {
[13:34:40.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.173]                     {
[13:34:40.173]                       inherits <- base::inherits
[13:34:40.173]                       invokeRestart <- base::invokeRestart
[13:34:40.173]                       is.null <- base::is.null
[13:34:40.173]                       muffled <- FALSE
[13:34:40.173]                       if (inherits(cond, "message")) {
[13:34:40.173]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.173]                         if (muffled) 
[13:34:40.173]                           invokeRestart("muffleMessage")
[13:34:40.173]                       }
[13:34:40.173]                       else if (inherits(cond, "warning")) {
[13:34:40.173]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.173]                         if (muffled) 
[13:34:40.173]                           invokeRestart("muffleWarning")
[13:34:40.173]                       }
[13:34:40.173]                       else if (inherits(cond, "condition")) {
[13:34:40.173]                         if (!is.null(pattern)) {
[13:34:40.173]                           computeRestarts <- base::computeRestarts
[13:34:40.173]                           grepl <- base::grepl
[13:34:40.173]                           restarts <- computeRestarts(cond)
[13:34:40.173]                           for (restart in restarts) {
[13:34:40.173]                             name <- restart$name
[13:34:40.173]                             if (is.null(name)) 
[13:34:40.173]                               next
[13:34:40.173]                             if (!grepl(pattern, name)) 
[13:34:40.173]                               next
[13:34:40.173]                             invokeRestart(restart)
[13:34:40.173]                             muffled <- TRUE
[13:34:40.173]                             break
[13:34:40.173]                           }
[13:34:40.173]                         }
[13:34:40.173]                       }
[13:34:40.173]                       invisible(muffled)
[13:34:40.173]                     }
[13:34:40.173]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.173]                   }
[13:34:40.173]                 }
[13:34:40.173]             }
[13:34:40.173]         }))
[13:34:40.173]     }, error = function(ex) {
[13:34:40.173]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.173]                 ...future.rng), started = ...future.startTime, 
[13:34:40.173]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.173]             version = "1.8"), class = "FutureResult")
[13:34:40.173]     }, finally = {
[13:34:40.173]         if (!identical(...future.workdir, getwd())) 
[13:34:40.173]             setwd(...future.workdir)
[13:34:40.173]         {
[13:34:40.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.173]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.173]             }
[13:34:40.173]             base::options(...future.oldOptions)
[13:34:40.173]             if (.Platform$OS.type == "windows") {
[13:34:40.173]                 old_names <- names(...future.oldEnvVars)
[13:34:40.173]                 envs <- base::Sys.getenv()
[13:34:40.173]                 names <- names(envs)
[13:34:40.173]                 common <- intersect(names, old_names)
[13:34:40.173]                 added <- setdiff(names, old_names)
[13:34:40.173]                 removed <- setdiff(old_names, names)
[13:34:40.173]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.173]                   envs[common]]
[13:34:40.173]                 NAMES <- toupper(changed)
[13:34:40.173]                 args <- list()
[13:34:40.173]                 for (kk in seq_along(NAMES)) {
[13:34:40.173]                   name <- changed[[kk]]
[13:34:40.173]                   NAME <- NAMES[[kk]]
[13:34:40.173]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.173]                     next
[13:34:40.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.173]                 }
[13:34:40.173]                 NAMES <- toupper(added)
[13:34:40.173]                 for (kk in seq_along(NAMES)) {
[13:34:40.173]                   name <- added[[kk]]
[13:34:40.173]                   NAME <- NAMES[[kk]]
[13:34:40.173]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.173]                     next
[13:34:40.173]                   args[[name]] <- ""
[13:34:40.173]                 }
[13:34:40.173]                 NAMES <- toupper(removed)
[13:34:40.173]                 for (kk in seq_along(NAMES)) {
[13:34:40.173]                   name <- removed[[kk]]
[13:34:40.173]                   NAME <- NAMES[[kk]]
[13:34:40.173]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.173]                     next
[13:34:40.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.173]                 }
[13:34:40.173]                 if (length(args) > 0) 
[13:34:40.173]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.173]             }
[13:34:40.173]             else {
[13:34:40.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.173]             }
[13:34:40.173]             {
[13:34:40.173]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.173]                   0L) {
[13:34:40.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.173]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.173]                   base::options(opts)
[13:34:40.173]                 }
[13:34:40.173]                 {
[13:34:40.173]                   {
[13:34:40.173]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.173]                     NULL
[13:34:40.173]                   }
[13:34:40.173]                   options(future.plan = NULL)
[13:34:40.173]                   if (is.na(NA_character_)) 
[13:34:40.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.173]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.173]                     .init = FALSE)
[13:34:40.173]                 }
[13:34:40.173]             }
[13:34:40.173]         }
[13:34:40.173]     })
[13:34:40.173]     if (TRUE) {
[13:34:40.173]         base::sink(type = "output", split = FALSE)
[13:34:40.173]         if (TRUE) {
[13:34:40.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.173]         }
[13:34:40.173]         else {
[13:34:40.173]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.173]         }
[13:34:40.173]         base::close(...future.stdout)
[13:34:40.173]         ...future.stdout <- NULL
[13:34:40.173]     }
[13:34:40.173]     ...future.result$conditions <- ...future.conditions
[13:34:40.173]     ...future.result$finished <- base::Sys.time()
[13:34:40.173]     ...future.result
[13:34:40.173] }
[13:34:40.176] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[13:34:40.176] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[13:34:40.176] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[13:34:40.177] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[13:34:40.177] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[13:34:40.177] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:34:40.177] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:34:40.177] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:40.178] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.178] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:40.178] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.178] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[13:34:40.179] MultisessionFuture started
[13:34:40.179] - Launch lazy future ... done
[13:34:40.179] run() for ‘MultisessionFuture’ ... done
[13:34:40.179] Created future:
[13:34:40.179] MultisessionFuture:
[13:34:40.179] Label: ‘future_mapply-2’
[13:34:40.179] Expression:
[13:34:40.179] {
[13:34:40.179]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.179]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.179]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.179]         on.exit(options(oopts), add = TRUE)
[13:34:40.179]     }
[13:34:40.179]     {
[13:34:40.179]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.179]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.179]         do.call(mapply, args = args)
[13:34:40.179]     }
[13:34:40.179] }
[13:34:40.179] Lazy evaluation: FALSE
[13:34:40.179] Asynchronous evaluation: TRUE
[13:34:40.179] Local evaluation: TRUE
[13:34:40.179] Environment: R_GlobalEnv
[13:34:40.179] Capture standard output: TRUE
[13:34:40.179] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.179] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.179] Packages: <none>
[13:34:40.179] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:40.179] Resolved: FALSE
[13:34:40.179] Value: <not collected>
[13:34:40.179] Conditions captured: <none>
[13:34:40.179] Early signaling: FALSE
[13:34:40.179] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.179] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.190] Chunk #2 of 2 ... DONE
[13:34:40.191] Launching 2 futures (chunks) ... DONE
[13:34:40.191] Resolving 2 futures (chunks) ...
[13:34:40.191] resolve() on list ...
[13:34:40.191]  recursive: 0
[13:34:40.191]  length: 2
[13:34:40.191] 
[13:34:40.192] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.192] - Validating connection of MultisessionFuture
[13:34:40.192] - received message: FutureResult
[13:34:40.192] - Received FutureResult
[13:34:40.192] - Erased future from FutureRegistry
[13:34:40.192] result() for ClusterFuture ...
[13:34:40.192] - result already collected: FutureResult
[13:34:40.192] result() for ClusterFuture ... done
[13:34:40.192] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.192] Future #1
[13:34:40.193] result() for ClusterFuture ...
[13:34:40.193] - result already collected: FutureResult
[13:34:40.193] result() for ClusterFuture ... done
[13:34:40.193] result() for ClusterFuture ...
[13:34:40.193] - result already collected: FutureResult
[13:34:40.193] result() for ClusterFuture ... done
[13:34:40.193] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:40.193] - nx: 2
[13:34:40.193] - relay: TRUE
[13:34:40.193] - stdout: TRUE
[13:34:40.193] - signal: TRUE
[13:34:40.193] - resignal: FALSE
[13:34:40.194] - force: TRUE
[13:34:40.194] - relayed: [n=2] FALSE, FALSE
[13:34:40.194] - queued futures: [n=2] FALSE, FALSE
[13:34:40.194]  - until=1
[13:34:40.194]  - relaying element #1
[13:34:40.194] result() for ClusterFuture ...
[13:34:40.194] - result already collected: FutureResult
[13:34:40.194] result() for ClusterFuture ... done
[13:34:40.194] result() for ClusterFuture ...
[13:34:40.194] - result already collected: FutureResult
[13:34:40.194] result() for ClusterFuture ... done
[13:34:40.195] result() for ClusterFuture ...
[13:34:40.195] - result already collected: FutureResult
[13:34:40.195] result() for ClusterFuture ... done
[13:34:40.195] result() for ClusterFuture ...
[13:34:40.195] - result already collected: FutureResult
[13:34:40.195] result() for ClusterFuture ... done
[13:34:40.195] - relayed: [n=2] TRUE, FALSE
[13:34:40.195] - queued futures: [n=2] TRUE, FALSE
[13:34:40.195] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:40.195]  length: 1 (resolved future 1)
[13:34:40.224] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.224] - Validating connection of MultisessionFuture
[13:34:40.224] - received message: FutureResult
[13:34:40.224] - Received FutureResult
[13:34:40.224] - Erased future from FutureRegistry
[13:34:40.224] result() for ClusterFuture ...
[13:34:40.224] - result already collected: FutureResult
[13:34:40.224] result() for ClusterFuture ... done
[13:34:40.225] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.225] Future #2
[13:34:40.225] result() for ClusterFuture ...
[13:34:40.225] - result already collected: FutureResult
[13:34:40.225] result() for ClusterFuture ... done
[13:34:40.225] result() for ClusterFuture ...
[13:34:40.225] - result already collected: FutureResult
[13:34:40.225] result() for ClusterFuture ... done
[13:34:40.225] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:40.225] - nx: 2
[13:34:40.226] - relay: TRUE
[13:34:40.226] - stdout: TRUE
[13:34:40.226] - signal: TRUE
[13:34:40.226] - resignal: FALSE
[13:34:40.226] - force: TRUE
[13:34:40.226] - relayed: [n=2] TRUE, FALSE
[13:34:40.226] - queued futures: [n=2] TRUE, FALSE
[13:34:40.226]  - until=2
[13:34:40.226]  - relaying element #2
[13:34:40.226] result() for ClusterFuture ...
[13:34:40.226] - result already collected: FutureResult
[13:34:40.226] result() for ClusterFuture ... done
[13:34:40.227] result() for ClusterFuture ...
[13:34:40.227] - result already collected: FutureResult
[13:34:40.227] result() for ClusterFuture ... done
[13:34:40.227] result() for ClusterFuture ...
[13:34:40.227] - result already collected: FutureResult
[13:34:40.227] result() for ClusterFuture ... done
[13:34:40.227] result() for ClusterFuture ...
[13:34:40.227] - result already collected: FutureResult
[13:34:40.227] result() for ClusterFuture ... done
[13:34:40.227] - relayed: [n=2] TRUE, TRUE
[13:34:40.227] - queued futures: [n=2] TRUE, TRUE
[13:34:40.227] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:40.228]  length: 0 (resolved future 2)
[13:34:40.228] Relaying remaining futures
[13:34:40.228] signalConditionsASAP(NULL, pos=0) ...
[13:34:40.228] - nx: 2
[13:34:40.228] - relay: TRUE
[13:34:40.228] - stdout: TRUE
[13:34:40.228] - signal: TRUE
[13:34:40.228] - resignal: FALSE
[13:34:40.228] - force: TRUE
[13:34:40.228] - relayed: [n=2] TRUE, TRUE
[13:34:40.228] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:40.229] - relayed: [n=2] TRUE, TRUE
[13:34:40.229] - queued futures: [n=2] TRUE, TRUE
[13:34:40.229] signalConditionsASAP(NULL, pos=0) ... done
[13:34:40.229] resolve() on list ... DONE
[13:34:40.229] result() for ClusterFuture ...
[13:34:40.229] - result already collected: FutureResult
[13:34:40.229] result() for ClusterFuture ... done
[13:34:40.229] result() for ClusterFuture ...
[13:34:40.229] - result already collected: FutureResult
[13:34:40.229] result() for ClusterFuture ... done
[13:34:40.229] result() for ClusterFuture ...
[13:34:40.229] - result already collected: FutureResult
[13:34:40.230] result() for ClusterFuture ... done
[13:34:40.230] result() for ClusterFuture ...
[13:34:40.230] - result already collected: FutureResult
[13:34:40.230] result() for ClusterFuture ... done
[13:34:40.230]  - Number of value chunks collected: 2
[13:34:40.230] Resolving 2 futures (chunks) ... DONE
[13:34:40.230] Reducing values from 2 chunks ...
[13:34:40.230]  - Number of values collected after concatenation: 2
[13:34:40.230]  - Number of values expected: 2
[13:34:40.230] Reducing values from 2 chunks ... DONE
[13:34:40.231] future_mapply() ... DONE
[13:34:40.231] future_mapply() ...
[13:34:40.231] Generating random seeds ...
[13:34:40.231] Generating random seed streams for 2 elements ...
[13:34:40.231] Generating random seed streams for 2 elements ... DONE
[13:34:40.231] Generating random seeds ... DONE
[13:34:40.231] Will set RNG state on exit: 10407, 1920756929, -363966863, -1781353469, -1622966520, 757597968, 196216724
[13:34:40.235] Number of chunks: 2
[13:34:40.235] getGlobalsAndPackagesXApply() ...
[13:34:40.235]  - future.globals: TRUE
[13:34:40.235] getGlobalsAndPackages() ...
[13:34:40.235] Searching for globals...
[13:34:40.236] - globals found: [1] ‘FUN’
[13:34:40.236] Searching for globals ... DONE
[13:34:40.236] Resolving globals: FALSE
[13:34:40.236] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[13:34:40.237] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[13:34:40.237] - globals: [1] ‘FUN’
[13:34:40.237] 
[13:34:40.237] getGlobalsAndPackages() ... DONE
[13:34:40.237]  - globals found/used: [n=1] ‘FUN’
[13:34:40.237]  - needed namespaces: [n=0] 
[13:34:40.237] Finding globals ... DONE
[13:34:40.238] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:40.238] List of 2
[13:34:40.238]  $ ...future.FUN:function (x, y)  
[13:34:40.238]  $ MoreArgs     :List of 1
[13:34:40.238]   ..$ y: int [1:2] 3 4
[13:34:40.238]  - attr(*, "where")=List of 2
[13:34:40.238]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:40.238]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:40.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:40.238]  - attr(*, "resolved")= logi FALSE
[13:34:40.238]  - attr(*, "total_size")= num NA
[13:34:40.240] Packages to be attached in all futures: [n=0] 
[13:34:40.241] getGlobalsAndPackagesXApply() ... DONE
[13:34:40.241] Number of futures (= number of chunks): 2
[13:34:40.241] Launching 2 futures (chunks) ...
[13:34:40.241] Chunk #1 of 2 ...
[13:34:40.241]  - Finding globals in '...' for chunk #1 ...
[13:34:40.241] getGlobalsAndPackages() ...
[13:34:40.241] Searching for globals...
[13:34:40.241] 
[13:34:40.242] Searching for globals ... DONE
[13:34:40.242] - globals: [0] <none>
[13:34:40.242] getGlobalsAndPackages() ... DONE
[13:34:40.242]    + additional globals found: [n=0] 
[13:34:40.242]    + additional namespaces needed: [n=0] 
[13:34:40.242]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:40.242]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.242]  - seeds: [1] <seeds>
[13:34:40.242]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.242] getGlobalsAndPackages() ...
[13:34:40.243] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.243] Resolving globals: FALSE
[13:34:40.243] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[13:34:40.244] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[13:34:40.244] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.244] 
[13:34:40.244] getGlobalsAndPackages() ... DONE
[13:34:40.244] run() for ‘Future’ ...
[13:34:40.244] - state: ‘created’
[13:34:40.244] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.258] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.258] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.258]   - Field: ‘node’
[13:34:40.258]   - Field: ‘label’
[13:34:40.258]   - Field: ‘local’
[13:34:40.258]   - Field: ‘owner’
[13:34:40.258]   - Field: ‘envir’
[13:34:40.258]   - Field: ‘workers’
[13:34:40.259]   - Field: ‘packages’
[13:34:40.259]   - Field: ‘gc’
[13:34:40.259]   - Field: ‘conditions’
[13:34:40.259]   - Field: ‘persistent’
[13:34:40.259]   - Field: ‘expr’
[13:34:40.259]   - Field: ‘uuid’
[13:34:40.259]   - Field: ‘seed’
[13:34:40.259]   - Field: ‘version’
[13:34:40.259]   - Field: ‘result’
[13:34:40.259]   - Field: ‘asynchronous’
[13:34:40.259]   - Field: ‘calls’
[13:34:40.260]   - Field: ‘globals’
[13:34:40.260]   - Field: ‘stdout’
[13:34:40.260]   - Field: ‘earlySignal’
[13:34:40.260]   - Field: ‘lazy’
[13:34:40.260]   - Field: ‘state’
[13:34:40.260] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.260] - Launch lazy future ...
[13:34:40.260] Packages needed by the future expression (n = 0): <none>
[13:34:40.260] Packages needed by future strategies (n = 0): <none>
[13:34:40.261] {
[13:34:40.261]     {
[13:34:40.261]         {
[13:34:40.261]             ...future.startTime <- base::Sys.time()
[13:34:40.261]             {
[13:34:40.261]                 {
[13:34:40.261]                   {
[13:34:40.261]                     {
[13:34:40.261]                       base::local({
[13:34:40.261]                         has_future <- base::requireNamespace("future", 
[13:34:40.261]                           quietly = TRUE)
[13:34:40.261]                         if (has_future) {
[13:34:40.261]                           ns <- base::getNamespace("future")
[13:34:40.261]                           version <- ns[[".package"]][["version"]]
[13:34:40.261]                           if (is.null(version)) 
[13:34:40.261]                             version <- utils::packageVersion("future")
[13:34:40.261]                         }
[13:34:40.261]                         else {
[13:34:40.261]                           version <- NULL
[13:34:40.261]                         }
[13:34:40.261]                         if (!has_future || version < "1.8.0") {
[13:34:40.261]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.261]                             "", base::R.version$version.string), 
[13:34:40.261]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:40.261]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:40.261]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.261]                               "release", "version")], collapse = " "), 
[13:34:40.261]                             hostname = base::Sys.info()[["nodename"]])
[13:34:40.261]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.261]                             info)
[13:34:40.261]                           info <- base::paste(info, collapse = "; ")
[13:34:40.261]                           if (!has_future) {
[13:34:40.261]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.261]                               info)
[13:34:40.261]                           }
[13:34:40.261]                           else {
[13:34:40.261]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.261]                               info, version)
[13:34:40.261]                           }
[13:34:40.261]                           base::stop(msg)
[13:34:40.261]                         }
[13:34:40.261]                       })
[13:34:40.261]                     }
[13:34:40.261]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.261]                     base::options(mc.cores = 1L)
[13:34:40.261]                   }
[13:34:40.261]                   ...future.strategy.old <- future::plan("list")
[13:34:40.261]                   options(future.plan = NULL)
[13:34:40.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.261]                 }
[13:34:40.261]                 ...future.workdir <- getwd()
[13:34:40.261]             }
[13:34:40.261]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.261]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.261]         }
[13:34:40.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.261]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.261]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.261]             base::names(...future.oldOptions))
[13:34:40.261]     }
[13:34:40.261]     if (FALSE) {
[13:34:40.261]     }
[13:34:40.261]     else {
[13:34:40.261]         if (TRUE) {
[13:34:40.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.261]                 open = "w")
[13:34:40.261]         }
[13:34:40.261]         else {
[13:34:40.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.261]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.261]         }
[13:34:40.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.261]             base::sink(type = "output", split = FALSE)
[13:34:40.261]             base::close(...future.stdout)
[13:34:40.261]         }, add = TRUE)
[13:34:40.261]     }
[13:34:40.261]     ...future.frame <- base::sys.nframe()
[13:34:40.261]     ...future.conditions <- base::list()
[13:34:40.261]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.261]     if (FALSE) {
[13:34:40.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.261]     }
[13:34:40.261]     ...future.result <- base::tryCatch({
[13:34:40.261]         base::withCallingHandlers({
[13:34:40.261]             ...future.value <- base::withVisible(base::local({
[13:34:40.261]                 ...future.makeSendCondition <- base::local({
[13:34:40.261]                   sendCondition <- NULL
[13:34:40.261]                   function(frame = 1L) {
[13:34:40.261]                     if (is.function(sendCondition)) 
[13:34:40.261]                       return(sendCondition)
[13:34:40.261]                     ns <- getNamespace("parallel")
[13:34:40.261]                     if (exists("sendData", mode = "function", 
[13:34:40.261]                       envir = ns)) {
[13:34:40.261]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.261]                         envir = ns)
[13:34:40.261]                       envir <- sys.frame(frame)
[13:34:40.261]                       master <- NULL
[13:34:40.261]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.261]                         !identical(envir, emptyenv())) {
[13:34:40.261]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.261]                           inherits = FALSE)) {
[13:34:40.261]                           master <- get("master", mode = "list", 
[13:34:40.261]                             envir = envir, inherits = FALSE)
[13:34:40.261]                           if (inherits(master, c("SOCKnode", 
[13:34:40.261]                             "SOCK0node"))) {
[13:34:40.261]                             sendCondition <<- function(cond) {
[13:34:40.261]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.261]                                 success = TRUE)
[13:34:40.261]                               parallel_sendData(master, data)
[13:34:40.261]                             }
[13:34:40.261]                             return(sendCondition)
[13:34:40.261]                           }
[13:34:40.261]                         }
[13:34:40.261]                         frame <- frame + 1L
[13:34:40.261]                         envir <- sys.frame(frame)
[13:34:40.261]                       }
[13:34:40.261]                     }
[13:34:40.261]                     sendCondition <<- function(cond) NULL
[13:34:40.261]                   }
[13:34:40.261]                 })
[13:34:40.261]                 withCallingHandlers({
[13:34:40.261]                   {
[13:34:40.261]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.261]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.261]                       ...future.globals.maxSize)) {
[13:34:40.261]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.261]                       on.exit(options(oopts), add = TRUE)
[13:34:40.261]                     }
[13:34:40.261]                     {
[13:34:40.261]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:40.261]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[13:34:40.261]                           envir = globalenv(), inherits = FALSE)
[13:34:40.261]                         ...future.FUN(...)
[13:34:40.261]                       }
[13:34:40.261]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:40.261]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:40.261]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.261]                         USE.NAMES = FALSE)
[13:34:40.261]                       do.call(mapply, args = args)
[13:34:40.261]                     }
[13:34:40.261]                   }
[13:34:40.261]                 }, immediateCondition = function(cond) {
[13:34:40.261]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.261]                   sendCondition(cond)
[13:34:40.261]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.261]                   {
[13:34:40.261]                     inherits <- base::inherits
[13:34:40.261]                     invokeRestart <- base::invokeRestart
[13:34:40.261]                     is.null <- base::is.null
[13:34:40.261]                     muffled <- FALSE
[13:34:40.261]                     if (inherits(cond, "message")) {
[13:34:40.261]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.261]                       if (muffled) 
[13:34:40.261]                         invokeRestart("muffleMessage")
[13:34:40.261]                     }
[13:34:40.261]                     else if (inherits(cond, "warning")) {
[13:34:40.261]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.261]                       if (muffled) 
[13:34:40.261]                         invokeRestart("muffleWarning")
[13:34:40.261]                     }
[13:34:40.261]                     else if (inherits(cond, "condition")) {
[13:34:40.261]                       if (!is.null(pattern)) {
[13:34:40.261]                         computeRestarts <- base::computeRestarts
[13:34:40.261]                         grepl <- base::grepl
[13:34:40.261]                         restarts <- computeRestarts(cond)
[13:34:40.261]                         for (restart in restarts) {
[13:34:40.261]                           name <- restart$name
[13:34:40.261]                           if (is.null(name)) 
[13:34:40.261]                             next
[13:34:40.261]                           if (!grepl(pattern, name)) 
[13:34:40.261]                             next
[13:34:40.261]                           invokeRestart(restart)
[13:34:40.261]                           muffled <- TRUE
[13:34:40.261]                           break
[13:34:40.261]                         }
[13:34:40.261]                       }
[13:34:40.261]                     }
[13:34:40.261]                     invisible(muffled)
[13:34:40.261]                   }
[13:34:40.261]                   muffleCondition(cond)
[13:34:40.261]                 })
[13:34:40.261]             }))
[13:34:40.261]             future::FutureResult(value = ...future.value$value, 
[13:34:40.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.261]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.261]                     ...future.globalenv.names))
[13:34:40.261]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.261]         }, condition = base::local({
[13:34:40.261]             c <- base::c
[13:34:40.261]             inherits <- base::inherits
[13:34:40.261]             invokeRestart <- base::invokeRestart
[13:34:40.261]             length <- base::length
[13:34:40.261]             list <- base::list
[13:34:40.261]             seq.int <- base::seq.int
[13:34:40.261]             signalCondition <- base::signalCondition
[13:34:40.261]             sys.calls <- base::sys.calls
[13:34:40.261]             `[[` <- base::`[[`
[13:34:40.261]             `+` <- base::`+`
[13:34:40.261]             `<<-` <- base::`<<-`
[13:34:40.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.261]                   3L)]
[13:34:40.261]             }
[13:34:40.261]             function(cond) {
[13:34:40.261]                 is_error <- inherits(cond, "error")
[13:34:40.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.261]                   NULL)
[13:34:40.261]                 if (is_error) {
[13:34:40.261]                   sessionInformation <- function() {
[13:34:40.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.261]                       search = base::search(), system = base::Sys.info())
[13:34:40.261]                   }
[13:34:40.261]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.261]                     cond$call), session = sessionInformation(), 
[13:34:40.261]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.261]                   signalCondition(cond)
[13:34:40.261]                 }
[13:34:40.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.261]                 "immediateCondition"))) {
[13:34:40.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.261]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.261]                   if (TRUE && !signal) {
[13:34:40.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.261]                     {
[13:34:40.261]                       inherits <- base::inherits
[13:34:40.261]                       invokeRestart <- base::invokeRestart
[13:34:40.261]                       is.null <- base::is.null
[13:34:40.261]                       muffled <- FALSE
[13:34:40.261]                       if (inherits(cond, "message")) {
[13:34:40.261]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.261]                         if (muffled) 
[13:34:40.261]                           invokeRestart("muffleMessage")
[13:34:40.261]                       }
[13:34:40.261]                       else if (inherits(cond, "warning")) {
[13:34:40.261]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.261]                         if (muffled) 
[13:34:40.261]                           invokeRestart("muffleWarning")
[13:34:40.261]                       }
[13:34:40.261]                       else if (inherits(cond, "condition")) {
[13:34:40.261]                         if (!is.null(pattern)) {
[13:34:40.261]                           computeRestarts <- base::computeRestarts
[13:34:40.261]                           grepl <- base::grepl
[13:34:40.261]                           restarts <- computeRestarts(cond)
[13:34:40.261]                           for (restart in restarts) {
[13:34:40.261]                             name <- restart$name
[13:34:40.261]                             if (is.null(name)) 
[13:34:40.261]                               next
[13:34:40.261]                             if (!grepl(pattern, name)) 
[13:34:40.261]                               next
[13:34:40.261]                             invokeRestart(restart)
[13:34:40.261]                             muffled <- TRUE
[13:34:40.261]                             break
[13:34:40.261]                           }
[13:34:40.261]                         }
[13:34:40.261]                       }
[13:34:40.261]                       invisible(muffled)
[13:34:40.261]                     }
[13:34:40.261]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.261]                   }
[13:34:40.261]                 }
[13:34:40.261]                 else {
[13:34:40.261]                   if (TRUE) {
[13:34:40.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.261]                     {
[13:34:40.261]                       inherits <- base::inherits
[13:34:40.261]                       invokeRestart <- base::invokeRestart
[13:34:40.261]                       is.null <- base::is.null
[13:34:40.261]                       muffled <- FALSE
[13:34:40.261]                       if (inherits(cond, "message")) {
[13:34:40.261]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.261]                         if (muffled) 
[13:34:40.261]                           invokeRestart("muffleMessage")
[13:34:40.261]                       }
[13:34:40.261]                       else if (inherits(cond, "warning")) {
[13:34:40.261]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.261]                         if (muffled) 
[13:34:40.261]                           invokeRestart("muffleWarning")
[13:34:40.261]                       }
[13:34:40.261]                       else if (inherits(cond, "condition")) {
[13:34:40.261]                         if (!is.null(pattern)) {
[13:34:40.261]                           computeRestarts <- base::computeRestarts
[13:34:40.261]                           grepl <- base::grepl
[13:34:40.261]                           restarts <- computeRestarts(cond)
[13:34:40.261]                           for (restart in restarts) {
[13:34:40.261]                             name <- restart$name
[13:34:40.261]                             if (is.null(name)) 
[13:34:40.261]                               next
[13:34:40.261]                             if (!grepl(pattern, name)) 
[13:34:40.261]                               next
[13:34:40.261]                             invokeRestart(restart)
[13:34:40.261]                             muffled <- TRUE
[13:34:40.261]                             break
[13:34:40.261]                           }
[13:34:40.261]                         }
[13:34:40.261]                       }
[13:34:40.261]                       invisible(muffled)
[13:34:40.261]                     }
[13:34:40.261]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.261]                   }
[13:34:40.261]                 }
[13:34:40.261]             }
[13:34:40.261]         }))
[13:34:40.261]     }, error = function(ex) {
[13:34:40.261]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.261]                 ...future.rng), started = ...future.startTime, 
[13:34:40.261]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.261]             version = "1.8"), class = "FutureResult")
[13:34:40.261]     }, finally = {
[13:34:40.261]         if (!identical(...future.workdir, getwd())) 
[13:34:40.261]             setwd(...future.workdir)
[13:34:40.261]         {
[13:34:40.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.261]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.261]             }
[13:34:40.261]             base::options(...future.oldOptions)
[13:34:40.261]             if (.Platform$OS.type == "windows") {
[13:34:40.261]                 old_names <- names(...future.oldEnvVars)
[13:34:40.261]                 envs <- base::Sys.getenv()
[13:34:40.261]                 names <- names(envs)
[13:34:40.261]                 common <- intersect(names, old_names)
[13:34:40.261]                 added <- setdiff(names, old_names)
[13:34:40.261]                 removed <- setdiff(old_names, names)
[13:34:40.261]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.261]                   envs[common]]
[13:34:40.261]                 NAMES <- toupper(changed)
[13:34:40.261]                 args <- list()
[13:34:40.261]                 for (kk in seq_along(NAMES)) {
[13:34:40.261]                   name <- changed[[kk]]
[13:34:40.261]                   NAME <- NAMES[[kk]]
[13:34:40.261]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.261]                     next
[13:34:40.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.261]                 }
[13:34:40.261]                 NAMES <- toupper(added)
[13:34:40.261]                 for (kk in seq_along(NAMES)) {
[13:34:40.261]                   name <- added[[kk]]
[13:34:40.261]                   NAME <- NAMES[[kk]]
[13:34:40.261]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.261]                     next
[13:34:40.261]                   args[[name]] <- ""
[13:34:40.261]                 }
[13:34:40.261]                 NAMES <- toupper(removed)
[13:34:40.261]                 for (kk in seq_along(NAMES)) {
[13:34:40.261]                   name <- removed[[kk]]
[13:34:40.261]                   NAME <- NAMES[[kk]]
[13:34:40.261]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.261]                     next
[13:34:40.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.261]                 }
[13:34:40.261]                 if (length(args) > 0) 
[13:34:40.261]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.261]             }
[13:34:40.261]             else {
[13:34:40.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.261]             }
[13:34:40.261]             {
[13:34:40.261]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.261]                   0L) {
[13:34:40.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.261]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.261]                   base::options(opts)
[13:34:40.261]                 }
[13:34:40.261]                 {
[13:34:40.261]                   {
[13:34:40.261]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.261]                     NULL
[13:34:40.261]                   }
[13:34:40.261]                   options(future.plan = NULL)
[13:34:40.261]                   if (is.na(NA_character_)) 
[13:34:40.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.261]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.261]                     .init = FALSE)
[13:34:40.261]                 }
[13:34:40.261]             }
[13:34:40.261]         }
[13:34:40.261]     })
[13:34:40.261]     if (TRUE) {
[13:34:40.261]         base::sink(type = "output", split = FALSE)
[13:34:40.261]         if (TRUE) {
[13:34:40.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.261]         }
[13:34:40.261]         else {
[13:34:40.261]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.261]         }
[13:34:40.261]         base::close(...future.stdout)
[13:34:40.261]         ...future.stdout <- NULL
[13:34:40.261]     }
[13:34:40.261]     ...future.result$conditions <- ...future.conditions
[13:34:40.261]     ...future.result$finished <- base::Sys.time()
[13:34:40.261]     ...future.result
[13:34:40.261] }
[13:34:40.263] Exporting 5 global objects (1.85 KiB) to cluster node #1 ...
[13:34:40.264] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[13:34:40.264] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[13:34:40.264] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[13:34:40.264] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[13:34:40.264] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:34:40.265] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:34:40.265] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[13:34:40.265] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[13:34:40.265] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:40.266] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.266] Exporting 5 global objects (1.85 KiB) to cluster node #1 ... DONE
[13:34:40.266] MultisessionFuture started
[13:34:40.266] - Launch lazy future ... done
[13:34:40.266] run() for ‘MultisessionFuture’ ... done
[13:34:40.266] Created future:
[13:34:40.267] MultisessionFuture:
[13:34:40.267] Label: ‘future_mapply-1’
[13:34:40.267] Expression:
[13:34:40.267] {
[13:34:40.267]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.267]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.267]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.267]         on.exit(options(oopts), add = TRUE)
[13:34:40.267]     }
[13:34:40.267]     {
[13:34:40.267]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:40.267]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[13:34:40.267]                 inherits = FALSE)
[13:34:40.267]             ...future.FUN(...)
[13:34:40.267]         }
[13:34:40.267]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:40.267]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:40.267]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.267]         do.call(mapply, args = args)
[13:34:40.267]     }
[13:34:40.267] }
[13:34:40.267] Lazy evaluation: FALSE
[13:34:40.267] Asynchronous evaluation: TRUE
[13:34:40.267] Local evaluation: TRUE
[13:34:40.267] Environment: R_GlobalEnv
[13:34:40.267] Capture standard output: TRUE
[13:34:40.267] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.267] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.267] Packages: <none>
[13:34:40.267] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:34:40.267] Resolved: FALSE
[13:34:40.267] Value: <not collected>
[13:34:40.267] Conditions captured: <none>
[13:34:40.267] Early signaling: FALSE
[13:34:40.267] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.267] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.278] Chunk #1 of 2 ... DONE
[13:34:40.278] Chunk #2 of 2 ...
[13:34:40.278]  - Finding globals in '...' for chunk #2 ...
[13:34:40.278] getGlobalsAndPackages() ...
[13:34:40.278] Searching for globals...
[13:34:40.279] 
[13:34:40.279] Searching for globals ... DONE
[13:34:40.279] - globals: [0] <none>
[13:34:40.279] getGlobalsAndPackages() ... DONE
[13:34:40.279]    + additional globals found: [n=0] 
[13:34:40.279]    + additional namespaces needed: [n=0] 
[13:34:40.279]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:40.279]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.279]  - seeds: [1] <seeds>
[13:34:40.279]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.280] getGlobalsAndPackages() ...
[13:34:40.280] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.280] Resolving globals: FALSE
[13:34:40.280] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[13:34:40.281] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[13:34:40.281] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.281] 
[13:34:40.281] getGlobalsAndPackages() ... DONE
[13:34:40.281] run() for ‘Future’ ...
[13:34:40.281] - state: ‘created’
[13:34:40.281] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.295] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.295]   - Field: ‘node’
[13:34:40.296]   - Field: ‘label’
[13:34:40.296]   - Field: ‘local’
[13:34:40.296]   - Field: ‘owner’
[13:34:40.296]   - Field: ‘envir’
[13:34:40.296]   - Field: ‘workers’
[13:34:40.296]   - Field: ‘packages’
[13:34:40.296]   - Field: ‘gc’
[13:34:40.296]   - Field: ‘conditions’
[13:34:40.296]   - Field: ‘persistent’
[13:34:40.296]   - Field: ‘expr’
[13:34:40.296]   - Field: ‘uuid’
[13:34:40.297]   - Field: ‘seed’
[13:34:40.297]   - Field: ‘version’
[13:34:40.297]   - Field: ‘result’
[13:34:40.297]   - Field: ‘asynchronous’
[13:34:40.297]   - Field: ‘calls’
[13:34:40.297]   - Field: ‘globals’
[13:34:40.297]   - Field: ‘stdout’
[13:34:40.297]   - Field: ‘earlySignal’
[13:34:40.297]   - Field: ‘lazy’
[13:34:40.297]   - Field: ‘state’
[13:34:40.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.298] - Launch lazy future ...
[13:34:40.298] Packages needed by the future expression (n = 0): <none>
[13:34:40.298] Packages needed by future strategies (n = 0): <none>
[13:34:40.298] {
[13:34:40.298]     {
[13:34:40.298]         {
[13:34:40.298]             ...future.startTime <- base::Sys.time()
[13:34:40.298]             {
[13:34:40.298]                 {
[13:34:40.298]                   {
[13:34:40.298]                     {
[13:34:40.298]                       base::local({
[13:34:40.298]                         has_future <- base::requireNamespace("future", 
[13:34:40.298]                           quietly = TRUE)
[13:34:40.298]                         if (has_future) {
[13:34:40.298]                           ns <- base::getNamespace("future")
[13:34:40.298]                           version <- ns[[".package"]][["version"]]
[13:34:40.298]                           if (is.null(version)) 
[13:34:40.298]                             version <- utils::packageVersion("future")
[13:34:40.298]                         }
[13:34:40.298]                         else {
[13:34:40.298]                           version <- NULL
[13:34:40.298]                         }
[13:34:40.298]                         if (!has_future || version < "1.8.0") {
[13:34:40.298]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.298]                             "", base::R.version$version.string), 
[13:34:40.298]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:40.298]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:40.298]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.298]                               "release", "version")], collapse = " "), 
[13:34:40.298]                             hostname = base::Sys.info()[["nodename"]])
[13:34:40.298]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.298]                             info)
[13:34:40.298]                           info <- base::paste(info, collapse = "; ")
[13:34:40.298]                           if (!has_future) {
[13:34:40.298]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.298]                               info)
[13:34:40.298]                           }
[13:34:40.298]                           else {
[13:34:40.298]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.298]                               info, version)
[13:34:40.298]                           }
[13:34:40.298]                           base::stop(msg)
[13:34:40.298]                         }
[13:34:40.298]                       })
[13:34:40.298]                     }
[13:34:40.298]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.298]                     base::options(mc.cores = 1L)
[13:34:40.298]                   }
[13:34:40.298]                   ...future.strategy.old <- future::plan("list")
[13:34:40.298]                   options(future.plan = NULL)
[13:34:40.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.298]                 }
[13:34:40.298]                 ...future.workdir <- getwd()
[13:34:40.298]             }
[13:34:40.298]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.298]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.298]         }
[13:34:40.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.298]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.298]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.298]             base::names(...future.oldOptions))
[13:34:40.298]     }
[13:34:40.298]     if (FALSE) {
[13:34:40.298]     }
[13:34:40.298]     else {
[13:34:40.298]         if (TRUE) {
[13:34:40.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.298]                 open = "w")
[13:34:40.298]         }
[13:34:40.298]         else {
[13:34:40.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.298]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.298]         }
[13:34:40.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.298]             base::sink(type = "output", split = FALSE)
[13:34:40.298]             base::close(...future.stdout)
[13:34:40.298]         }, add = TRUE)
[13:34:40.298]     }
[13:34:40.298]     ...future.frame <- base::sys.nframe()
[13:34:40.298]     ...future.conditions <- base::list()
[13:34:40.298]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.298]     if (FALSE) {
[13:34:40.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.298]     }
[13:34:40.298]     ...future.result <- base::tryCatch({
[13:34:40.298]         base::withCallingHandlers({
[13:34:40.298]             ...future.value <- base::withVisible(base::local({
[13:34:40.298]                 ...future.makeSendCondition <- base::local({
[13:34:40.298]                   sendCondition <- NULL
[13:34:40.298]                   function(frame = 1L) {
[13:34:40.298]                     if (is.function(sendCondition)) 
[13:34:40.298]                       return(sendCondition)
[13:34:40.298]                     ns <- getNamespace("parallel")
[13:34:40.298]                     if (exists("sendData", mode = "function", 
[13:34:40.298]                       envir = ns)) {
[13:34:40.298]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.298]                         envir = ns)
[13:34:40.298]                       envir <- sys.frame(frame)
[13:34:40.298]                       master <- NULL
[13:34:40.298]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.298]                         !identical(envir, emptyenv())) {
[13:34:40.298]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.298]                           inherits = FALSE)) {
[13:34:40.298]                           master <- get("master", mode = "list", 
[13:34:40.298]                             envir = envir, inherits = FALSE)
[13:34:40.298]                           if (inherits(master, c("SOCKnode", 
[13:34:40.298]                             "SOCK0node"))) {
[13:34:40.298]                             sendCondition <<- function(cond) {
[13:34:40.298]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.298]                                 success = TRUE)
[13:34:40.298]                               parallel_sendData(master, data)
[13:34:40.298]                             }
[13:34:40.298]                             return(sendCondition)
[13:34:40.298]                           }
[13:34:40.298]                         }
[13:34:40.298]                         frame <- frame + 1L
[13:34:40.298]                         envir <- sys.frame(frame)
[13:34:40.298]                       }
[13:34:40.298]                     }
[13:34:40.298]                     sendCondition <<- function(cond) NULL
[13:34:40.298]                   }
[13:34:40.298]                 })
[13:34:40.298]                 withCallingHandlers({
[13:34:40.298]                   {
[13:34:40.298]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.298]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.298]                       ...future.globals.maxSize)) {
[13:34:40.298]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.298]                       on.exit(options(oopts), add = TRUE)
[13:34:40.298]                     }
[13:34:40.298]                     {
[13:34:40.298]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:40.298]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[13:34:40.298]                           envir = globalenv(), inherits = FALSE)
[13:34:40.298]                         ...future.FUN(...)
[13:34:40.298]                       }
[13:34:40.298]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:40.298]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:40.298]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.298]                         USE.NAMES = FALSE)
[13:34:40.298]                       do.call(mapply, args = args)
[13:34:40.298]                     }
[13:34:40.298]                   }
[13:34:40.298]                 }, immediateCondition = function(cond) {
[13:34:40.298]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.298]                   sendCondition(cond)
[13:34:40.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.298]                   {
[13:34:40.298]                     inherits <- base::inherits
[13:34:40.298]                     invokeRestart <- base::invokeRestart
[13:34:40.298]                     is.null <- base::is.null
[13:34:40.298]                     muffled <- FALSE
[13:34:40.298]                     if (inherits(cond, "message")) {
[13:34:40.298]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.298]                       if (muffled) 
[13:34:40.298]                         invokeRestart("muffleMessage")
[13:34:40.298]                     }
[13:34:40.298]                     else if (inherits(cond, "warning")) {
[13:34:40.298]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.298]                       if (muffled) 
[13:34:40.298]                         invokeRestart("muffleWarning")
[13:34:40.298]                     }
[13:34:40.298]                     else if (inherits(cond, "condition")) {
[13:34:40.298]                       if (!is.null(pattern)) {
[13:34:40.298]                         computeRestarts <- base::computeRestarts
[13:34:40.298]                         grepl <- base::grepl
[13:34:40.298]                         restarts <- computeRestarts(cond)
[13:34:40.298]                         for (restart in restarts) {
[13:34:40.298]                           name <- restart$name
[13:34:40.298]                           if (is.null(name)) 
[13:34:40.298]                             next
[13:34:40.298]                           if (!grepl(pattern, name)) 
[13:34:40.298]                             next
[13:34:40.298]                           invokeRestart(restart)
[13:34:40.298]                           muffled <- TRUE
[13:34:40.298]                           break
[13:34:40.298]                         }
[13:34:40.298]                       }
[13:34:40.298]                     }
[13:34:40.298]                     invisible(muffled)
[13:34:40.298]                   }
[13:34:40.298]                   muffleCondition(cond)
[13:34:40.298]                 })
[13:34:40.298]             }))
[13:34:40.298]             future::FutureResult(value = ...future.value$value, 
[13:34:40.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.298]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.298]                     ...future.globalenv.names))
[13:34:40.298]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.298]         }, condition = base::local({
[13:34:40.298]             c <- base::c
[13:34:40.298]             inherits <- base::inherits
[13:34:40.298]             invokeRestart <- base::invokeRestart
[13:34:40.298]             length <- base::length
[13:34:40.298]             list <- base::list
[13:34:40.298]             seq.int <- base::seq.int
[13:34:40.298]             signalCondition <- base::signalCondition
[13:34:40.298]             sys.calls <- base::sys.calls
[13:34:40.298]             `[[` <- base::`[[`
[13:34:40.298]             `+` <- base::`+`
[13:34:40.298]             `<<-` <- base::`<<-`
[13:34:40.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.298]                   3L)]
[13:34:40.298]             }
[13:34:40.298]             function(cond) {
[13:34:40.298]                 is_error <- inherits(cond, "error")
[13:34:40.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.298]                   NULL)
[13:34:40.298]                 if (is_error) {
[13:34:40.298]                   sessionInformation <- function() {
[13:34:40.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.298]                       search = base::search(), system = base::Sys.info())
[13:34:40.298]                   }
[13:34:40.298]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.298]                     cond$call), session = sessionInformation(), 
[13:34:40.298]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.298]                   signalCondition(cond)
[13:34:40.298]                 }
[13:34:40.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.298]                 "immediateCondition"))) {
[13:34:40.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.298]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.298]                   if (TRUE && !signal) {
[13:34:40.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.298]                     {
[13:34:40.298]                       inherits <- base::inherits
[13:34:40.298]                       invokeRestart <- base::invokeRestart
[13:34:40.298]                       is.null <- base::is.null
[13:34:40.298]                       muffled <- FALSE
[13:34:40.298]                       if (inherits(cond, "message")) {
[13:34:40.298]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.298]                         if (muffled) 
[13:34:40.298]                           invokeRestart("muffleMessage")
[13:34:40.298]                       }
[13:34:40.298]                       else if (inherits(cond, "warning")) {
[13:34:40.298]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.298]                         if (muffled) 
[13:34:40.298]                           invokeRestart("muffleWarning")
[13:34:40.298]                       }
[13:34:40.298]                       else if (inherits(cond, "condition")) {
[13:34:40.298]                         if (!is.null(pattern)) {
[13:34:40.298]                           computeRestarts <- base::computeRestarts
[13:34:40.298]                           grepl <- base::grepl
[13:34:40.298]                           restarts <- computeRestarts(cond)
[13:34:40.298]                           for (restart in restarts) {
[13:34:40.298]                             name <- restart$name
[13:34:40.298]                             if (is.null(name)) 
[13:34:40.298]                               next
[13:34:40.298]                             if (!grepl(pattern, name)) 
[13:34:40.298]                               next
[13:34:40.298]                             invokeRestart(restart)
[13:34:40.298]                             muffled <- TRUE
[13:34:40.298]                             break
[13:34:40.298]                           }
[13:34:40.298]                         }
[13:34:40.298]                       }
[13:34:40.298]                       invisible(muffled)
[13:34:40.298]                     }
[13:34:40.298]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.298]                   }
[13:34:40.298]                 }
[13:34:40.298]                 else {
[13:34:40.298]                   if (TRUE) {
[13:34:40.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.298]                     {
[13:34:40.298]                       inherits <- base::inherits
[13:34:40.298]                       invokeRestart <- base::invokeRestart
[13:34:40.298]                       is.null <- base::is.null
[13:34:40.298]                       muffled <- FALSE
[13:34:40.298]                       if (inherits(cond, "message")) {
[13:34:40.298]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.298]                         if (muffled) 
[13:34:40.298]                           invokeRestart("muffleMessage")
[13:34:40.298]                       }
[13:34:40.298]                       else if (inherits(cond, "warning")) {
[13:34:40.298]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.298]                         if (muffled) 
[13:34:40.298]                           invokeRestart("muffleWarning")
[13:34:40.298]                       }
[13:34:40.298]                       else if (inherits(cond, "condition")) {
[13:34:40.298]                         if (!is.null(pattern)) {
[13:34:40.298]                           computeRestarts <- base::computeRestarts
[13:34:40.298]                           grepl <- base::grepl
[13:34:40.298]                           restarts <- computeRestarts(cond)
[13:34:40.298]                           for (restart in restarts) {
[13:34:40.298]                             name <- restart$name
[13:34:40.298]                             if (is.null(name)) 
[13:34:40.298]                               next
[13:34:40.298]                             if (!grepl(pattern, name)) 
[13:34:40.298]                               next
[13:34:40.298]                             invokeRestart(restart)
[13:34:40.298]                             muffled <- TRUE
[13:34:40.298]                             break
[13:34:40.298]                           }
[13:34:40.298]                         }
[13:34:40.298]                       }
[13:34:40.298]                       invisible(muffled)
[13:34:40.298]                     }
[13:34:40.298]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.298]                   }
[13:34:40.298]                 }
[13:34:40.298]             }
[13:34:40.298]         }))
[13:34:40.298]     }, error = function(ex) {
[13:34:40.298]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.298]                 ...future.rng), started = ...future.startTime, 
[13:34:40.298]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.298]             version = "1.8"), class = "FutureResult")
[13:34:40.298]     }, finally = {
[13:34:40.298]         if (!identical(...future.workdir, getwd())) 
[13:34:40.298]             setwd(...future.workdir)
[13:34:40.298]         {
[13:34:40.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.298]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.298]             }
[13:34:40.298]             base::options(...future.oldOptions)
[13:34:40.298]             if (.Platform$OS.type == "windows") {
[13:34:40.298]                 old_names <- names(...future.oldEnvVars)
[13:34:40.298]                 envs <- base::Sys.getenv()
[13:34:40.298]                 names <- names(envs)
[13:34:40.298]                 common <- intersect(names, old_names)
[13:34:40.298]                 added <- setdiff(names, old_names)
[13:34:40.298]                 removed <- setdiff(old_names, names)
[13:34:40.298]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.298]                   envs[common]]
[13:34:40.298]                 NAMES <- toupper(changed)
[13:34:40.298]                 args <- list()
[13:34:40.298]                 for (kk in seq_along(NAMES)) {
[13:34:40.298]                   name <- changed[[kk]]
[13:34:40.298]                   NAME <- NAMES[[kk]]
[13:34:40.298]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.298]                     next
[13:34:40.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.298]                 }
[13:34:40.298]                 NAMES <- toupper(added)
[13:34:40.298]                 for (kk in seq_along(NAMES)) {
[13:34:40.298]                   name <- added[[kk]]
[13:34:40.298]                   NAME <- NAMES[[kk]]
[13:34:40.298]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.298]                     next
[13:34:40.298]                   args[[name]] <- ""
[13:34:40.298]                 }
[13:34:40.298]                 NAMES <- toupper(removed)
[13:34:40.298]                 for (kk in seq_along(NAMES)) {
[13:34:40.298]                   name <- removed[[kk]]
[13:34:40.298]                   NAME <- NAMES[[kk]]
[13:34:40.298]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.298]                     next
[13:34:40.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.298]                 }
[13:34:40.298]                 if (length(args) > 0) 
[13:34:40.298]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.298]             }
[13:34:40.298]             else {
[13:34:40.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.298]             }
[13:34:40.298]             {
[13:34:40.298]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.298]                   0L) {
[13:34:40.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.298]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.298]                   base::options(opts)
[13:34:40.298]                 }
[13:34:40.298]                 {
[13:34:40.298]                   {
[13:34:40.298]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.298]                     NULL
[13:34:40.298]                   }
[13:34:40.298]                   options(future.plan = NULL)
[13:34:40.298]                   if (is.na(NA_character_)) 
[13:34:40.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.298]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.298]                     .init = FALSE)
[13:34:40.298]                 }
[13:34:40.298]             }
[13:34:40.298]         }
[13:34:40.298]     })
[13:34:40.298]     if (TRUE) {
[13:34:40.298]         base::sink(type = "output", split = FALSE)
[13:34:40.298]         if (TRUE) {
[13:34:40.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.298]         }
[13:34:40.298]         else {
[13:34:40.298]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.298]         }
[13:34:40.298]         base::close(...future.stdout)
[13:34:40.298]         ...future.stdout <- NULL
[13:34:40.298]     }
[13:34:40.298]     ...future.result$conditions <- ...future.conditions
[13:34:40.298]     ...future.result$finished <- base::Sys.time()
[13:34:40.298]     ...future.result
[13:34:40.298] }
[13:34:40.301] Exporting 5 global objects (1.85 KiB) to cluster node #2 ...
[13:34:40.301] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[13:34:40.301] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[13:34:40.301] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[13:34:40.302] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[13:34:40.302] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:34:40.302] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:34:40.302] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[13:34:40.303] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[13:34:40.303] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:40.303] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.303] Exporting 5 global objects (1.85 KiB) to cluster node #2 ... DONE
[13:34:40.304] MultisessionFuture started
[13:34:40.304] - Launch lazy future ... done
[13:34:40.304] run() for ‘MultisessionFuture’ ... done
[13:34:40.304] Created future:
[13:34:40.304] MultisessionFuture:
[13:34:40.304] Label: ‘future_mapply-2’
[13:34:40.304] Expression:
[13:34:40.304] {
[13:34:40.304]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.304]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.304]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.304]         on.exit(options(oopts), add = TRUE)
[13:34:40.304]     }
[13:34:40.304]     {
[13:34:40.304]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:40.304]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[13:34:40.304]                 inherits = FALSE)
[13:34:40.304]             ...future.FUN(...)
[13:34:40.304]         }
[13:34:40.304]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:40.304]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:40.304]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.304]         do.call(mapply, args = args)
[13:34:40.304]     }
[13:34:40.304] }
[13:34:40.304] Lazy evaluation: FALSE
[13:34:40.304] Asynchronous evaluation: TRUE
[13:34:40.304] Local evaluation: TRUE
[13:34:40.304] Environment: R_GlobalEnv
[13:34:40.304] Capture standard output: TRUE
[13:34:40.304] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.304] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.304] Packages: <none>
[13:34:40.304] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:34:40.304] Resolved: FALSE
[13:34:40.304] Value: <not collected>
[13:34:40.304] Conditions captured: <none>
[13:34:40.304] Early signaling: FALSE
[13:34:40.304] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.304] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.315] Chunk #2 of 2 ... DONE
[13:34:40.316] Launching 2 futures (chunks) ... DONE
[13:34:40.316] Resolving 2 futures (chunks) ...
[13:34:40.316] resolve() on list ...
[13:34:40.316]  recursive: 0
[13:34:40.316]  length: 2
[13:34:40.316] 
[13:34:40.317] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.317] - Validating connection of MultisessionFuture
[13:34:40.317] - received message: FutureResult
[13:34:40.317] - Received FutureResult
[13:34:40.317] - Erased future from FutureRegistry
[13:34:40.317] result() for ClusterFuture ...
[13:34:40.317] - result already collected: FutureResult
[13:34:40.318] result() for ClusterFuture ... done
[13:34:40.318] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.318] Future #1
[13:34:40.318] result() for ClusterFuture ...
[13:34:40.318] - result already collected: FutureResult
[13:34:40.318] result() for ClusterFuture ... done
[13:34:40.318] result() for ClusterFuture ...
[13:34:40.318] - result already collected: FutureResult
[13:34:40.318] result() for ClusterFuture ... done
[13:34:40.318] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:40.319] - nx: 2
[13:34:40.319] - relay: TRUE
[13:34:40.319] - stdout: TRUE
[13:34:40.319] - signal: TRUE
[13:34:40.319] - resignal: FALSE
[13:34:40.319] - force: TRUE
[13:34:40.319] - relayed: [n=2] FALSE, FALSE
[13:34:40.319] - queued futures: [n=2] FALSE, FALSE
[13:34:40.319]  - until=1
[13:34:40.319]  - relaying element #1
[13:34:40.319] result() for ClusterFuture ...
[13:34:40.320] - result already collected: FutureResult
[13:34:40.320] result() for ClusterFuture ... done
[13:34:40.320] result() for ClusterFuture ...
[13:34:40.320] - result already collected: FutureResult
[13:34:40.320] result() for ClusterFuture ... done
[13:34:40.320] result() for ClusterFuture ...
[13:34:40.320] - result already collected: FutureResult
[13:34:40.320] result() for ClusterFuture ... done
[13:34:40.320] result() for ClusterFuture ...
[13:34:40.320] - result already collected: FutureResult
[13:34:40.320] result() for ClusterFuture ... done
[13:34:40.320] - relayed: [n=2] TRUE, FALSE
[13:34:40.321] - queued futures: [n=2] TRUE, FALSE
[13:34:40.321] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:40.321]  length: 1 (resolved future 1)
[13:34:40.348] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.348] - Validating connection of MultisessionFuture
[13:34:40.348] - received message: FutureResult
[13:34:40.348] - Received FutureResult
[13:34:40.348] - Erased future from FutureRegistry
[13:34:40.348] result() for ClusterFuture ...
[13:34:40.348] - result already collected: FutureResult
[13:34:40.349] result() for ClusterFuture ... done
[13:34:40.349] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.349] Future #2
[13:34:40.349] result() for ClusterFuture ...
[13:34:40.349] - result already collected: FutureResult
[13:34:40.349] result() for ClusterFuture ... done
[13:34:40.349] result() for ClusterFuture ...
[13:34:40.349] - result already collected: FutureResult
[13:34:40.349] result() for ClusterFuture ... done
[13:34:40.349] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:40.349] - nx: 2
[13:34:40.349] - relay: TRUE
[13:34:40.350] - stdout: TRUE
[13:34:40.350] - signal: TRUE
[13:34:40.350] - resignal: FALSE
[13:34:40.350] - force: TRUE
[13:34:40.350] - relayed: [n=2] TRUE, FALSE
[13:34:40.350] - queued futures: [n=2] TRUE, FALSE
[13:34:40.350]  - until=2
[13:34:40.350]  - relaying element #2
[13:34:40.350] result() for ClusterFuture ...
[13:34:40.350] - result already collected: FutureResult
[13:34:40.350] result() for ClusterFuture ... done
[13:34:40.351] result() for ClusterFuture ...
[13:34:40.351] - result already collected: FutureResult
[13:34:40.351] result() for ClusterFuture ... done
[13:34:40.351] result() for ClusterFuture ...
[13:34:40.351] - result already collected: FutureResult
[13:34:40.351] result() for ClusterFuture ... done
[13:34:40.351] result() for ClusterFuture ...
[13:34:40.351] - result already collected: FutureResult
[13:34:40.354] result() for ClusterFuture ... done
[13:34:40.354] - relayed: [n=2] TRUE, TRUE
[13:34:40.354] - queued futures: [n=2] TRUE, TRUE
[13:34:40.354] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:40.355]  length: 0 (resolved future 2)
[13:34:40.355] Relaying remaining futures
[13:34:40.355] signalConditionsASAP(NULL, pos=0) ...
[13:34:40.355] - nx: 2
[13:34:40.355] - relay: TRUE
[13:34:40.355] - stdout: TRUE
[13:34:40.355] - signal: TRUE
[13:34:40.355] - resignal: FALSE
[13:34:40.355] - force: TRUE
[13:34:40.355] - relayed: [n=2] TRUE, TRUE
[13:34:40.355] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:40.355] - relayed: [n=2] TRUE, TRUE
[13:34:40.356] - queued futures: [n=2] TRUE, TRUE
[13:34:40.356] signalConditionsASAP(NULL, pos=0) ... done
[13:34:40.356] resolve() on list ... DONE
[13:34:40.356] result() for ClusterFuture ...
[13:34:40.356] - result already collected: FutureResult
[13:34:40.356] result() for ClusterFuture ... done
[13:34:40.356] result() for ClusterFuture ...
[13:34:40.356] - result already collected: FutureResult
[13:34:40.356] result() for ClusterFuture ... done
[13:34:40.356] result() for ClusterFuture ...
[13:34:40.356] - result already collected: FutureResult
[13:34:40.357] result() for ClusterFuture ... done
[13:34:40.357] result() for ClusterFuture ...
[13:34:40.357] - result already collected: FutureResult
[13:34:40.357] result() for ClusterFuture ... done
[13:34:40.357]  - Number of value chunks collected: 2
[13:34:40.357] Resolving 2 futures (chunks) ... DONE
[13:34:40.357] Reducing values from 2 chunks ...
[13:34:40.357]  - Number of values collected after concatenation: 2
[13:34:40.357]  - Number of values expected: 2
[13:34:40.357] Reducing values from 2 chunks ... DONE
[13:34:40.357] future_mapply() ... DONE
[13:34:40.358] future_mapply() ...
[13:34:40.361] Number of chunks: 2
[13:34:40.361] getGlobalsAndPackagesXApply() ...
[13:34:40.361]  - future.globals: TRUE
[13:34:40.361] getGlobalsAndPackages() ...
[13:34:40.362] Searching for globals...
[13:34:40.363] - globals found: [1] ‘FUN’
[13:34:40.363] Searching for globals ... DONE
[13:34:40.363] Resolving globals: FALSE
[13:34:40.363] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[13:34:40.363] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[13:34:40.364] - globals: [1] ‘FUN’
[13:34:40.364] 
[13:34:40.364] getGlobalsAndPackages() ... DONE
[13:34:40.364]  - globals found/used: [n=1] ‘FUN’
[13:34:40.364]  - needed namespaces: [n=0] 
[13:34:40.364] Finding globals ... DONE
[13:34:40.364] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:40.364] List of 2
[13:34:40.364]  $ ...future.FUN:function (x, y)  
[13:34:40.364]  $ MoreArgs     :List of 1
[13:34:40.364]   ..$ y: int [1:2] 3 4
[13:34:40.364]  - attr(*, "where")=List of 2
[13:34:40.364]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:40.364]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:40.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:40.364]  - attr(*, "resolved")= logi FALSE
[13:34:40.364]  - attr(*, "total_size")= num NA
[13:34:40.367] Packages to be attached in all futures: [n=0] 
[13:34:40.367] getGlobalsAndPackagesXApply() ... DONE
[13:34:40.367] Number of futures (= number of chunks): 2
[13:34:40.368] Launching 2 futures (chunks) ...
[13:34:40.368] Chunk #1 of 2 ...
[13:34:40.368]  - Finding globals in '...' for chunk #1 ...
[13:34:40.368] getGlobalsAndPackages() ...
[13:34:40.368] Searching for globals...
[13:34:40.368] 
[13:34:40.368] Searching for globals ... DONE
[13:34:40.368] - globals: [0] <none>
[13:34:40.368] getGlobalsAndPackages() ... DONE
[13:34:40.369]    + additional globals found: [n=0] 
[13:34:40.369]    + additional namespaces needed: [n=0] 
[13:34:40.369]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:40.369]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.369]  - seeds: <none>
[13:34:40.369]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.369] getGlobalsAndPackages() ...
[13:34:40.369] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.369] Resolving globals: FALSE
[13:34:40.370] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[13:34:40.370] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[13:34:40.370] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.370] 
[13:34:40.371] getGlobalsAndPackages() ... DONE
[13:34:40.371] run() for ‘Future’ ...
[13:34:40.371] - state: ‘created’
[13:34:40.371] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.385] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.385] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.385]   - Field: ‘node’
[13:34:40.385]   - Field: ‘label’
[13:34:40.385]   - Field: ‘local’
[13:34:40.385]   - Field: ‘owner’
[13:34:40.385]   - Field: ‘envir’
[13:34:40.385]   - Field: ‘workers’
[13:34:40.385]   - Field: ‘packages’
[13:34:40.385]   - Field: ‘gc’
[13:34:40.386]   - Field: ‘conditions’
[13:34:40.386]   - Field: ‘persistent’
[13:34:40.386]   - Field: ‘expr’
[13:34:40.386]   - Field: ‘uuid’
[13:34:40.386]   - Field: ‘seed’
[13:34:40.386]   - Field: ‘version’
[13:34:40.386]   - Field: ‘result’
[13:34:40.386]   - Field: ‘asynchronous’
[13:34:40.386]   - Field: ‘calls’
[13:34:40.386]   - Field: ‘globals’
[13:34:40.386]   - Field: ‘stdout’
[13:34:40.387]   - Field: ‘earlySignal’
[13:34:40.387]   - Field: ‘lazy’
[13:34:40.387]   - Field: ‘state’
[13:34:40.387] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.387] - Launch lazy future ...
[13:34:40.387] Packages needed by the future expression (n = 0): <none>
[13:34:40.387] Packages needed by future strategies (n = 0): <none>
[13:34:40.388] {
[13:34:40.388]     {
[13:34:40.388]         {
[13:34:40.388]             ...future.startTime <- base::Sys.time()
[13:34:40.388]             {
[13:34:40.388]                 {
[13:34:40.388]                   {
[13:34:40.388]                     {
[13:34:40.388]                       base::local({
[13:34:40.388]                         has_future <- base::requireNamespace("future", 
[13:34:40.388]                           quietly = TRUE)
[13:34:40.388]                         if (has_future) {
[13:34:40.388]                           ns <- base::getNamespace("future")
[13:34:40.388]                           version <- ns[[".package"]][["version"]]
[13:34:40.388]                           if (is.null(version)) 
[13:34:40.388]                             version <- utils::packageVersion("future")
[13:34:40.388]                         }
[13:34:40.388]                         else {
[13:34:40.388]                           version <- NULL
[13:34:40.388]                         }
[13:34:40.388]                         if (!has_future || version < "1.8.0") {
[13:34:40.388]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.388]                             "", base::R.version$version.string), 
[13:34:40.388]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:40.388]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:40.388]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.388]                               "release", "version")], collapse = " "), 
[13:34:40.388]                             hostname = base::Sys.info()[["nodename"]])
[13:34:40.388]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.388]                             info)
[13:34:40.388]                           info <- base::paste(info, collapse = "; ")
[13:34:40.388]                           if (!has_future) {
[13:34:40.388]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.388]                               info)
[13:34:40.388]                           }
[13:34:40.388]                           else {
[13:34:40.388]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.388]                               info, version)
[13:34:40.388]                           }
[13:34:40.388]                           base::stop(msg)
[13:34:40.388]                         }
[13:34:40.388]                       })
[13:34:40.388]                     }
[13:34:40.388]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.388]                     base::options(mc.cores = 1L)
[13:34:40.388]                   }
[13:34:40.388]                   ...future.strategy.old <- future::plan("list")
[13:34:40.388]                   options(future.plan = NULL)
[13:34:40.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.388]                 }
[13:34:40.388]                 ...future.workdir <- getwd()
[13:34:40.388]             }
[13:34:40.388]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.388]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.388]         }
[13:34:40.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.388]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.388]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.388]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.388]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.388]             base::names(...future.oldOptions))
[13:34:40.388]     }
[13:34:40.388]     if (FALSE) {
[13:34:40.388]     }
[13:34:40.388]     else {
[13:34:40.388]         if (TRUE) {
[13:34:40.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.388]                 open = "w")
[13:34:40.388]         }
[13:34:40.388]         else {
[13:34:40.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.388]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.388]         }
[13:34:40.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.388]             base::sink(type = "output", split = FALSE)
[13:34:40.388]             base::close(...future.stdout)
[13:34:40.388]         }, add = TRUE)
[13:34:40.388]     }
[13:34:40.388]     ...future.frame <- base::sys.nframe()
[13:34:40.388]     ...future.conditions <- base::list()
[13:34:40.388]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.388]     if (FALSE) {
[13:34:40.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.388]     }
[13:34:40.388]     ...future.result <- base::tryCatch({
[13:34:40.388]         base::withCallingHandlers({
[13:34:40.388]             ...future.value <- base::withVisible(base::local({
[13:34:40.388]                 ...future.makeSendCondition <- base::local({
[13:34:40.388]                   sendCondition <- NULL
[13:34:40.388]                   function(frame = 1L) {
[13:34:40.388]                     if (is.function(sendCondition)) 
[13:34:40.388]                       return(sendCondition)
[13:34:40.388]                     ns <- getNamespace("parallel")
[13:34:40.388]                     if (exists("sendData", mode = "function", 
[13:34:40.388]                       envir = ns)) {
[13:34:40.388]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.388]                         envir = ns)
[13:34:40.388]                       envir <- sys.frame(frame)
[13:34:40.388]                       master <- NULL
[13:34:40.388]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.388]                         !identical(envir, emptyenv())) {
[13:34:40.388]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.388]                           inherits = FALSE)) {
[13:34:40.388]                           master <- get("master", mode = "list", 
[13:34:40.388]                             envir = envir, inherits = FALSE)
[13:34:40.388]                           if (inherits(master, c("SOCKnode", 
[13:34:40.388]                             "SOCK0node"))) {
[13:34:40.388]                             sendCondition <<- function(cond) {
[13:34:40.388]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.388]                                 success = TRUE)
[13:34:40.388]                               parallel_sendData(master, data)
[13:34:40.388]                             }
[13:34:40.388]                             return(sendCondition)
[13:34:40.388]                           }
[13:34:40.388]                         }
[13:34:40.388]                         frame <- frame + 1L
[13:34:40.388]                         envir <- sys.frame(frame)
[13:34:40.388]                       }
[13:34:40.388]                     }
[13:34:40.388]                     sendCondition <<- function(cond) NULL
[13:34:40.388]                   }
[13:34:40.388]                 })
[13:34:40.388]                 withCallingHandlers({
[13:34:40.388]                   {
[13:34:40.388]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.388]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.388]                       ...future.globals.maxSize)) {
[13:34:40.388]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.388]                       on.exit(options(oopts), add = TRUE)
[13:34:40.388]                     }
[13:34:40.388]                     {
[13:34:40.388]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.388]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.388]                         USE.NAMES = FALSE)
[13:34:40.388]                       do.call(mapply, args = args)
[13:34:40.388]                     }
[13:34:40.388]                   }
[13:34:40.388]                 }, immediateCondition = function(cond) {
[13:34:40.388]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.388]                   sendCondition(cond)
[13:34:40.388]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.388]                   {
[13:34:40.388]                     inherits <- base::inherits
[13:34:40.388]                     invokeRestart <- base::invokeRestart
[13:34:40.388]                     is.null <- base::is.null
[13:34:40.388]                     muffled <- FALSE
[13:34:40.388]                     if (inherits(cond, "message")) {
[13:34:40.388]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.388]                       if (muffled) 
[13:34:40.388]                         invokeRestart("muffleMessage")
[13:34:40.388]                     }
[13:34:40.388]                     else if (inherits(cond, "warning")) {
[13:34:40.388]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.388]                       if (muffled) 
[13:34:40.388]                         invokeRestart("muffleWarning")
[13:34:40.388]                     }
[13:34:40.388]                     else if (inherits(cond, "condition")) {
[13:34:40.388]                       if (!is.null(pattern)) {
[13:34:40.388]                         computeRestarts <- base::computeRestarts
[13:34:40.388]                         grepl <- base::grepl
[13:34:40.388]                         restarts <- computeRestarts(cond)
[13:34:40.388]                         for (restart in restarts) {
[13:34:40.388]                           name <- restart$name
[13:34:40.388]                           if (is.null(name)) 
[13:34:40.388]                             next
[13:34:40.388]                           if (!grepl(pattern, name)) 
[13:34:40.388]                             next
[13:34:40.388]                           invokeRestart(restart)
[13:34:40.388]                           muffled <- TRUE
[13:34:40.388]                           break
[13:34:40.388]                         }
[13:34:40.388]                       }
[13:34:40.388]                     }
[13:34:40.388]                     invisible(muffled)
[13:34:40.388]                   }
[13:34:40.388]                   muffleCondition(cond)
[13:34:40.388]                 })
[13:34:40.388]             }))
[13:34:40.388]             future::FutureResult(value = ...future.value$value, 
[13:34:40.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.388]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.388]                     ...future.globalenv.names))
[13:34:40.388]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.388]         }, condition = base::local({
[13:34:40.388]             c <- base::c
[13:34:40.388]             inherits <- base::inherits
[13:34:40.388]             invokeRestart <- base::invokeRestart
[13:34:40.388]             length <- base::length
[13:34:40.388]             list <- base::list
[13:34:40.388]             seq.int <- base::seq.int
[13:34:40.388]             signalCondition <- base::signalCondition
[13:34:40.388]             sys.calls <- base::sys.calls
[13:34:40.388]             `[[` <- base::`[[`
[13:34:40.388]             `+` <- base::`+`
[13:34:40.388]             `<<-` <- base::`<<-`
[13:34:40.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.388]                   3L)]
[13:34:40.388]             }
[13:34:40.388]             function(cond) {
[13:34:40.388]                 is_error <- inherits(cond, "error")
[13:34:40.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.388]                   NULL)
[13:34:40.388]                 if (is_error) {
[13:34:40.388]                   sessionInformation <- function() {
[13:34:40.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.388]                       search = base::search(), system = base::Sys.info())
[13:34:40.388]                   }
[13:34:40.388]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.388]                     cond$call), session = sessionInformation(), 
[13:34:40.388]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.388]                   signalCondition(cond)
[13:34:40.388]                 }
[13:34:40.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.388]                 "immediateCondition"))) {
[13:34:40.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.388]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.388]                   if (TRUE && !signal) {
[13:34:40.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.388]                     {
[13:34:40.388]                       inherits <- base::inherits
[13:34:40.388]                       invokeRestart <- base::invokeRestart
[13:34:40.388]                       is.null <- base::is.null
[13:34:40.388]                       muffled <- FALSE
[13:34:40.388]                       if (inherits(cond, "message")) {
[13:34:40.388]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.388]                         if (muffled) 
[13:34:40.388]                           invokeRestart("muffleMessage")
[13:34:40.388]                       }
[13:34:40.388]                       else if (inherits(cond, "warning")) {
[13:34:40.388]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.388]                         if (muffled) 
[13:34:40.388]                           invokeRestart("muffleWarning")
[13:34:40.388]                       }
[13:34:40.388]                       else if (inherits(cond, "condition")) {
[13:34:40.388]                         if (!is.null(pattern)) {
[13:34:40.388]                           computeRestarts <- base::computeRestarts
[13:34:40.388]                           grepl <- base::grepl
[13:34:40.388]                           restarts <- computeRestarts(cond)
[13:34:40.388]                           for (restart in restarts) {
[13:34:40.388]                             name <- restart$name
[13:34:40.388]                             if (is.null(name)) 
[13:34:40.388]                               next
[13:34:40.388]                             if (!grepl(pattern, name)) 
[13:34:40.388]                               next
[13:34:40.388]                             invokeRestart(restart)
[13:34:40.388]                             muffled <- TRUE
[13:34:40.388]                             break
[13:34:40.388]                           }
[13:34:40.388]                         }
[13:34:40.388]                       }
[13:34:40.388]                       invisible(muffled)
[13:34:40.388]                     }
[13:34:40.388]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.388]                   }
[13:34:40.388]                 }
[13:34:40.388]                 else {
[13:34:40.388]                   if (TRUE) {
[13:34:40.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.388]                     {
[13:34:40.388]                       inherits <- base::inherits
[13:34:40.388]                       invokeRestart <- base::invokeRestart
[13:34:40.388]                       is.null <- base::is.null
[13:34:40.388]                       muffled <- FALSE
[13:34:40.388]                       if (inherits(cond, "message")) {
[13:34:40.388]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.388]                         if (muffled) 
[13:34:40.388]                           invokeRestart("muffleMessage")
[13:34:40.388]                       }
[13:34:40.388]                       else if (inherits(cond, "warning")) {
[13:34:40.388]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.388]                         if (muffled) 
[13:34:40.388]                           invokeRestart("muffleWarning")
[13:34:40.388]                       }
[13:34:40.388]                       else if (inherits(cond, "condition")) {
[13:34:40.388]                         if (!is.null(pattern)) {
[13:34:40.388]                           computeRestarts <- base::computeRestarts
[13:34:40.388]                           grepl <- base::grepl
[13:34:40.388]                           restarts <- computeRestarts(cond)
[13:34:40.388]                           for (restart in restarts) {
[13:34:40.388]                             name <- restart$name
[13:34:40.388]                             if (is.null(name)) 
[13:34:40.388]                               next
[13:34:40.388]                             if (!grepl(pattern, name)) 
[13:34:40.388]                               next
[13:34:40.388]                             invokeRestart(restart)
[13:34:40.388]                             muffled <- TRUE
[13:34:40.388]                             break
[13:34:40.388]                           }
[13:34:40.388]                         }
[13:34:40.388]                       }
[13:34:40.388]                       invisible(muffled)
[13:34:40.388]                     }
[13:34:40.388]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.388]                   }
[13:34:40.388]                 }
[13:34:40.388]             }
[13:34:40.388]         }))
[13:34:40.388]     }, error = function(ex) {
[13:34:40.388]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.388]                 ...future.rng), started = ...future.startTime, 
[13:34:40.388]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.388]             version = "1.8"), class = "FutureResult")
[13:34:40.388]     }, finally = {
[13:34:40.388]         if (!identical(...future.workdir, getwd())) 
[13:34:40.388]             setwd(...future.workdir)
[13:34:40.388]         {
[13:34:40.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.388]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.388]             }
[13:34:40.388]             base::options(...future.oldOptions)
[13:34:40.388]             if (.Platform$OS.type == "windows") {
[13:34:40.388]                 old_names <- names(...future.oldEnvVars)
[13:34:40.388]                 envs <- base::Sys.getenv()
[13:34:40.388]                 names <- names(envs)
[13:34:40.388]                 common <- intersect(names, old_names)
[13:34:40.388]                 added <- setdiff(names, old_names)
[13:34:40.388]                 removed <- setdiff(old_names, names)
[13:34:40.388]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.388]                   envs[common]]
[13:34:40.388]                 NAMES <- toupper(changed)
[13:34:40.388]                 args <- list()
[13:34:40.388]                 for (kk in seq_along(NAMES)) {
[13:34:40.388]                   name <- changed[[kk]]
[13:34:40.388]                   NAME <- NAMES[[kk]]
[13:34:40.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.388]                     next
[13:34:40.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.388]                 }
[13:34:40.388]                 NAMES <- toupper(added)
[13:34:40.388]                 for (kk in seq_along(NAMES)) {
[13:34:40.388]                   name <- added[[kk]]
[13:34:40.388]                   NAME <- NAMES[[kk]]
[13:34:40.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.388]                     next
[13:34:40.388]                   args[[name]] <- ""
[13:34:40.388]                 }
[13:34:40.388]                 NAMES <- toupper(removed)
[13:34:40.388]                 for (kk in seq_along(NAMES)) {
[13:34:40.388]                   name <- removed[[kk]]
[13:34:40.388]                   NAME <- NAMES[[kk]]
[13:34:40.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.388]                     next
[13:34:40.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.388]                 }
[13:34:40.388]                 if (length(args) > 0) 
[13:34:40.388]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.388]             }
[13:34:40.388]             else {
[13:34:40.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.388]             }
[13:34:40.388]             {
[13:34:40.388]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.388]                   0L) {
[13:34:40.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.388]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.388]                   base::options(opts)
[13:34:40.388]                 }
[13:34:40.388]                 {
[13:34:40.388]                   {
[13:34:40.388]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.388]                     NULL
[13:34:40.388]                   }
[13:34:40.388]                   options(future.plan = NULL)
[13:34:40.388]                   if (is.na(NA_character_)) 
[13:34:40.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.388]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.388]                     .init = FALSE)
[13:34:40.388]                 }
[13:34:40.388]             }
[13:34:40.388]         }
[13:34:40.388]     })
[13:34:40.388]     if (TRUE) {
[13:34:40.388]         base::sink(type = "output", split = FALSE)
[13:34:40.388]         if (TRUE) {
[13:34:40.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.388]         }
[13:34:40.388]         else {
[13:34:40.388]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.388]         }
[13:34:40.388]         base::close(...future.stdout)
[13:34:40.388]         ...future.stdout <- NULL
[13:34:40.388]     }
[13:34:40.388]     ...future.result$conditions <- ...future.conditions
[13:34:40.388]     ...future.result$finished <- base::Sys.time()
[13:34:40.388]     ...future.result
[13:34:40.388] }
[13:34:40.390] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[13:34:40.390] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[13:34:40.391] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[13:34:40.391] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[13:34:40.391] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[13:34:40.391] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:34:40.392] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:34:40.392] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:40.392] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.392] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:40.392] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.393] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[13:34:40.393] MultisessionFuture started
[13:34:40.393] - Launch lazy future ... done
[13:34:40.393] run() for ‘MultisessionFuture’ ... done
[13:34:40.393] Created future:
[13:34:40.393] MultisessionFuture:
[13:34:40.393] Label: ‘future_.mapply-1’
[13:34:40.393] Expression:
[13:34:40.393] {
[13:34:40.393]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.393]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.393]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.393]         on.exit(options(oopts), add = TRUE)
[13:34:40.393]     }
[13:34:40.393]     {
[13:34:40.393]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.393]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.393]         do.call(mapply, args = args)
[13:34:40.393]     }
[13:34:40.393] }
[13:34:40.393] Lazy evaluation: FALSE
[13:34:40.393] Asynchronous evaluation: TRUE
[13:34:40.393] Local evaluation: TRUE
[13:34:40.393] Environment: R_GlobalEnv
[13:34:40.393] Capture standard output: TRUE
[13:34:40.393] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.393] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.393] Packages: <none>
[13:34:40.393] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:40.393] Resolved: FALSE
[13:34:40.393] Value: <not collected>
[13:34:40.393] Conditions captured: <none>
[13:34:40.393] Early signaling: FALSE
[13:34:40.393] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.393] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.405] Chunk #1 of 2 ... DONE
[13:34:40.405] Chunk #2 of 2 ...
[13:34:40.405]  - Finding globals in '...' for chunk #2 ...
[13:34:40.405] getGlobalsAndPackages() ...
[13:34:40.405] Searching for globals...
[13:34:40.406] 
[13:34:40.406] Searching for globals ... DONE
[13:34:40.406] - globals: [0] <none>
[13:34:40.406] getGlobalsAndPackages() ... DONE
[13:34:40.406]    + additional globals found: [n=0] 
[13:34:40.406]    + additional namespaces needed: [n=0] 
[13:34:40.406]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:40.406]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.406]  - seeds: <none>
[13:34:40.406]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.407] getGlobalsAndPackages() ...
[13:34:40.407] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.407] Resolving globals: FALSE
[13:34:40.407] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[13:34:40.408] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[13:34:40.408] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.408] 
[13:34:40.408] getGlobalsAndPackages() ... DONE
[13:34:40.408] run() for ‘Future’ ...
[13:34:40.408] - state: ‘created’
[13:34:40.408] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.422] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.422]   - Field: ‘node’
[13:34:40.422]   - Field: ‘label’
[13:34:40.422]   - Field: ‘local’
[13:34:40.422]   - Field: ‘owner’
[13:34:40.422]   - Field: ‘envir’
[13:34:40.422]   - Field: ‘workers’
[13:34:40.423]   - Field: ‘packages’
[13:34:40.423]   - Field: ‘gc’
[13:34:40.423]   - Field: ‘conditions’
[13:34:40.423]   - Field: ‘persistent’
[13:34:40.423]   - Field: ‘expr’
[13:34:40.423]   - Field: ‘uuid’
[13:34:40.423]   - Field: ‘seed’
[13:34:40.423]   - Field: ‘version’
[13:34:40.423]   - Field: ‘result’
[13:34:40.423]   - Field: ‘asynchronous’
[13:34:40.423]   - Field: ‘calls’
[13:34:40.424]   - Field: ‘globals’
[13:34:40.424]   - Field: ‘stdout’
[13:34:40.424]   - Field: ‘earlySignal’
[13:34:40.424]   - Field: ‘lazy’
[13:34:40.424]   - Field: ‘state’
[13:34:40.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.424] - Launch lazy future ...
[13:34:40.424] Packages needed by the future expression (n = 0): <none>
[13:34:40.424] Packages needed by future strategies (n = 0): <none>
[13:34:40.425] {
[13:34:40.425]     {
[13:34:40.425]         {
[13:34:40.425]             ...future.startTime <- base::Sys.time()
[13:34:40.425]             {
[13:34:40.425]                 {
[13:34:40.425]                   {
[13:34:40.425]                     {
[13:34:40.425]                       base::local({
[13:34:40.425]                         has_future <- base::requireNamespace("future", 
[13:34:40.425]                           quietly = TRUE)
[13:34:40.425]                         if (has_future) {
[13:34:40.425]                           ns <- base::getNamespace("future")
[13:34:40.425]                           version <- ns[[".package"]][["version"]]
[13:34:40.425]                           if (is.null(version)) 
[13:34:40.425]                             version <- utils::packageVersion("future")
[13:34:40.425]                         }
[13:34:40.425]                         else {
[13:34:40.425]                           version <- NULL
[13:34:40.425]                         }
[13:34:40.425]                         if (!has_future || version < "1.8.0") {
[13:34:40.425]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.425]                             "", base::R.version$version.string), 
[13:34:40.425]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:40.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:40.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.425]                               "release", "version")], collapse = " "), 
[13:34:40.425]                             hostname = base::Sys.info()[["nodename"]])
[13:34:40.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.425]                             info)
[13:34:40.425]                           info <- base::paste(info, collapse = "; ")
[13:34:40.425]                           if (!has_future) {
[13:34:40.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.425]                               info)
[13:34:40.425]                           }
[13:34:40.425]                           else {
[13:34:40.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.425]                               info, version)
[13:34:40.425]                           }
[13:34:40.425]                           base::stop(msg)
[13:34:40.425]                         }
[13:34:40.425]                       })
[13:34:40.425]                     }
[13:34:40.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.425]                     base::options(mc.cores = 1L)
[13:34:40.425]                   }
[13:34:40.425]                   ...future.strategy.old <- future::plan("list")
[13:34:40.425]                   options(future.plan = NULL)
[13:34:40.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.425]                 }
[13:34:40.425]                 ...future.workdir <- getwd()
[13:34:40.425]             }
[13:34:40.425]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.425]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.425]         }
[13:34:40.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.425]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.425]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.425]             base::names(...future.oldOptions))
[13:34:40.425]     }
[13:34:40.425]     if (FALSE) {
[13:34:40.425]     }
[13:34:40.425]     else {
[13:34:40.425]         if (TRUE) {
[13:34:40.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.425]                 open = "w")
[13:34:40.425]         }
[13:34:40.425]         else {
[13:34:40.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.425]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.425]         }
[13:34:40.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.425]             base::sink(type = "output", split = FALSE)
[13:34:40.425]             base::close(...future.stdout)
[13:34:40.425]         }, add = TRUE)
[13:34:40.425]     }
[13:34:40.425]     ...future.frame <- base::sys.nframe()
[13:34:40.425]     ...future.conditions <- base::list()
[13:34:40.425]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.425]     if (FALSE) {
[13:34:40.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.425]     }
[13:34:40.425]     ...future.result <- base::tryCatch({
[13:34:40.425]         base::withCallingHandlers({
[13:34:40.425]             ...future.value <- base::withVisible(base::local({
[13:34:40.425]                 ...future.makeSendCondition <- base::local({
[13:34:40.425]                   sendCondition <- NULL
[13:34:40.425]                   function(frame = 1L) {
[13:34:40.425]                     if (is.function(sendCondition)) 
[13:34:40.425]                       return(sendCondition)
[13:34:40.425]                     ns <- getNamespace("parallel")
[13:34:40.425]                     if (exists("sendData", mode = "function", 
[13:34:40.425]                       envir = ns)) {
[13:34:40.425]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.425]                         envir = ns)
[13:34:40.425]                       envir <- sys.frame(frame)
[13:34:40.425]                       master <- NULL
[13:34:40.425]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.425]                         !identical(envir, emptyenv())) {
[13:34:40.425]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.425]                           inherits = FALSE)) {
[13:34:40.425]                           master <- get("master", mode = "list", 
[13:34:40.425]                             envir = envir, inherits = FALSE)
[13:34:40.425]                           if (inherits(master, c("SOCKnode", 
[13:34:40.425]                             "SOCK0node"))) {
[13:34:40.425]                             sendCondition <<- function(cond) {
[13:34:40.425]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.425]                                 success = TRUE)
[13:34:40.425]                               parallel_sendData(master, data)
[13:34:40.425]                             }
[13:34:40.425]                             return(sendCondition)
[13:34:40.425]                           }
[13:34:40.425]                         }
[13:34:40.425]                         frame <- frame + 1L
[13:34:40.425]                         envir <- sys.frame(frame)
[13:34:40.425]                       }
[13:34:40.425]                     }
[13:34:40.425]                     sendCondition <<- function(cond) NULL
[13:34:40.425]                   }
[13:34:40.425]                 })
[13:34:40.425]                 withCallingHandlers({
[13:34:40.425]                   {
[13:34:40.425]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.425]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.425]                       ...future.globals.maxSize)) {
[13:34:40.425]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.425]                       on.exit(options(oopts), add = TRUE)
[13:34:40.425]                     }
[13:34:40.425]                     {
[13:34:40.425]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.425]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.425]                         USE.NAMES = FALSE)
[13:34:40.425]                       do.call(mapply, args = args)
[13:34:40.425]                     }
[13:34:40.425]                   }
[13:34:40.425]                 }, immediateCondition = function(cond) {
[13:34:40.425]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.425]                   sendCondition(cond)
[13:34:40.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.425]                   {
[13:34:40.425]                     inherits <- base::inherits
[13:34:40.425]                     invokeRestart <- base::invokeRestart
[13:34:40.425]                     is.null <- base::is.null
[13:34:40.425]                     muffled <- FALSE
[13:34:40.425]                     if (inherits(cond, "message")) {
[13:34:40.425]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.425]                       if (muffled) 
[13:34:40.425]                         invokeRestart("muffleMessage")
[13:34:40.425]                     }
[13:34:40.425]                     else if (inherits(cond, "warning")) {
[13:34:40.425]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.425]                       if (muffled) 
[13:34:40.425]                         invokeRestart("muffleWarning")
[13:34:40.425]                     }
[13:34:40.425]                     else if (inherits(cond, "condition")) {
[13:34:40.425]                       if (!is.null(pattern)) {
[13:34:40.425]                         computeRestarts <- base::computeRestarts
[13:34:40.425]                         grepl <- base::grepl
[13:34:40.425]                         restarts <- computeRestarts(cond)
[13:34:40.425]                         for (restart in restarts) {
[13:34:40.425]                           name <- restart$name
[13:34:40.425]                           if (is.null(name)) 
[13:34:40.425]                             next
[13:34:40.425]                           if (!grepl(pattern, name)) 
[13:34:40.425]                             next
[13:34:40.425]                           invokeRestart(restart)
[13:34:40.425]                           muffled <- TRUE
[13:34:40.425]                           break
[13:34:40.425]                         }
[13:34:40.425]                       }
[13:34:40.425]                     }
[13:34:40.425]                     invisible(muffled)
[13:34:40.425]                   }
[13:34:40.425]                   muffleCondition(cond)
[13:34:40.425]                 })
[13:34:40.425]             }))
[13:34:40.425]             future::FutureResult(value = ...future.value$value, 
[13:34:40.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.425]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.425]                     ...future.globalenv.names))
[13:34:40.425]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.425]         }, condition = base::local({
[13:34:40.425]             c <- base::c
[13:34:40.425]             inherits <- base::inherits
[13:34:40.425]             invokeRestart <- base::invokeRestart
[13:34:40.425]             length <- base::length
[13:34:40.425]             list <- base::list
[13:34:40.425]             seq.int <- base::seq.int
[13:34:40.425]             signalCondition <- base::signalCondition
[13:34:40.425]             sys.calls <- base::sys.calls
[13:34:40.425]             `[[` <- base::`[[`
[13:34:40.425]             `+` <- base::`+`
[13:34:40.425]             `<<-` <- base::`<<-`
[13:34:40.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.425]                   3L)]
[13:34:40.425]             }
[13:34:40.425]             function(cond) {
[13:34:40.425]                 is_error <- inherits(cond, "error")
[13:34:40.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.425]                   NULL)
[13:34:40.425]                 if (is_error) {
[13:34:40.425]                   sessionInformation <- function() {
[13:34:40.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.425]                       search = base::search(), system = base::Sys.info())
[13:34:40.425]                   }
[13:34:40.425]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.425]                     cond$call), session = sessionInformation(), 
[13:34:40.425]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.425]                   signalCondition(cond)
[13:34:40.425]                 }
[13:34:40.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.425]                 "immediateCondition"))) {
[13:34:40.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.425]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.425]                   if (TRUE && !signal) {
[13:34:40.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.425]                     {
[13:34:40.425]                       inherits <- base::inherits
[13:34:40.425]                       invokeRestart <- base::invokeRestart
[13:34:40.425]                       is.null <- base::is.null
[13:34:40.425]                       muffled <- FALSE
[13:34:40.425]                       if (inherits(cond, "message")) {
[13:34:40.425]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.425]                         if (muffled) 
[13:34:40.425]                           invokeRestart("muffleMessage")
[13:34:40.425]                       }
[13:34:40.425]                       else if (inherits(cond, "warning")) {
[13:34:40.425]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.425]                         if (muffled) 
[13:34:40.425]                           invokeRestart("muffleWarning")
[13:34:40.425]                       }
[13:34:40.425]                       else if (inherits(cond, "condition")) {
[13:34:40.425]                         if (!is.null(pattern)) {
[13:34:40.425]                           computeRestarts <- base::computeRestarts
[13:34:40.425]                           grepl <- base::grepl
[13:34:40.425]                           restarts <- computeRestarts(cond)
[13:34:40.425]                           for (restart in restarts) {
[13:34:40.425]                             name <- restart$name
[13:34:40.425]                             if (is.null(name)) 
[13:34:40.425]                               next
[13:34:40.425]                             if (!grepl(pattern, name)) 
[13:34:40.425]                               next
[13:34:40.425]                             invokeRestart(restart)
[13:34:40.425]                             muffled <- TRUE
[13:34:40.425]                             break
[13:34:40.425]                           }
[13:34:40.425]                         }
[13:34:40.425]                       }
[13:34:40.425]                       invisible(muffled)
[13:34:40.425]                     }
[13:34:40.425]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.425]                   }
[13:34:40.425]                 }
[13:34:40.425]                 else {
[13:34:40.425]                   if (TRUE) {
[13:34:40.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.425]                     {
[13:34:40.425]                       inherits <- base::inherits
[13:34:40.425]                       invokeRestart <- base::invokeRestart
[13:34:40.425]                       is.null <- base::is.null
[13:34:40.425]                       muffled <- FALSE
[13:34:40.425]                       if (inherits(cond, "message")) {
[13:34:40.425]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.425]                         if (muffled) 
[13:34:40.425]                           invokeRestart("muffleMessage")
[13:34:40.425]                       }
[13:34:40.425]                       else if (inherits(cond, "warning")) {
[13:34:40.425]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.425]                         if (muffled) 
[13:34:40.425]                           invokeRestart("muffleWarning")
[13:34:40.425]                       }
[13:34:40.425]                       else if (inherits(cond, "condition")) {
[13:34:40.425]                         if (!is.null(pattern)) {
[13:34:40.425]                           computeRestarts <- base::computeRestarts
[13:34:40.425]                           grepl <- base::grepl
[13:34:40.425]                           restarts <- computeRestarts(cond)
[13:34:40.425]                           for (restart in restarts) {
[13:34:40.425]                             name <- restart$name
[13:34:40.425]                             if (is.null(name)) 
[13:34:40.425]                               next
[13:34:40.425]                             if (!grepl(pattern, name)) 
[13:34:40.425]                               next
[13:34:40.425]                             invokeRestart(restart)
[13:34:40.425]                             muffled <- TRUE
[13:34:40.425]                             break
[13:34:40.425]                           }
[13:34:40.425]                         }
[13:34:40.425]                       }
[13:34:40.425]                       invisible(muffled)
[13:34:40.425]                     }
[13:34:40.425]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.425]                   }
[13:34:40.425]                 }
[13:34:40.425]             }
[13:34:40.425]         }))
[13:34:40.425]     }, error = function(ex) {
[13:34:40.425]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.425]                 ...future.rng), started = ...future.startTime, 
[13:34:40.425]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.425]             version = "1.8"), class = "FutureResult")
[13:34:40.425]     }, finally = {
[13:34:40.425]         if (!identical(...future.workdir, getwd())) 
[13:34:40.425]             setwd(...future.workdir)
[13:34:40.425]         {
[13:34:40.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.425]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.425]             }
[13:34:40.425]             base::options(...future.oldOptions)
[13:34:40.425]             if (.Platform$OS.type == "windows") {
[13:34:40.425]                 old_names <- names(...future.oldEnvVars)
[13:34:40.425]                 envs <- base::Sys.getenv()
[13:34:40.425]                 names <- names(envs)
[13:34:40.425]                 common <- intersect(names, old_names)
[13:34:40.425]                 added <- setdiff(names, old_names)
[13:34:40.425]                 removed <- setdiff(old_names, names)
[13:34:40.425]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.425]                   envs[common]]
[13:34:40.425]                 NAMES <- toupper(changed)
[13:34:40.425]                 args <- list()
[13:34:40.425]                 for (kk in seq_along(NAMES)) {
[13:34:40.425]                   name <- changed[[kk]]
[13:34:40.425]                   NAME <- NAMES[[kk]]
[13:34:40.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.425]                     next
[13:34:40.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.425]                 }
[13:34:40.425]                 NAMES <- toupper(added)
[13:34:40.425]                 for (kk in seq_along(NAMES)) {
[13:34:40.425]                   name <- added[[kk]]
[13:34:40.425]                   NAME <- NAMES[[kk]]
[13:34:40.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.425]                     next
[13:34:40.425]                   args[[name]] <- ""
[13:34:40.425]                 }
[13:34:40.425]                 NAMES <- toupper(removed)
[13:34:40.425]                 for (kk in seq_along(NAMES)) {
[13:34:40.425]                   name <- removed[[kk]]
[13:34:40.425]                   NAME <- NAMES[[kk]]
[13:34:40.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.425]                     next
[13:34:40.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.425]                 }
[13:34:40.425]                 if (length(args) > 0) 
[13:34:40.425]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.425]             }
[13:34:40.425]             else {
[13:34:40.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.425]             }
[13:34:40.425]             {
[13:34:40.425]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.425]                   0L) {
[13:34:40.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.425]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.425]                   base::options(opts)
[13:34:40.425]                 }
[13:34:40.425]                 {
[13:34:40.425]                   {
[13:34:40.425]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.425]                     NULL
[13:34:40.425]                   }
[13:34:40.425]                   options(future.plan = NULL)
[13:34:40.425]                   if (is.na(NA_character_)) 
[13:34:40.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.425]                     .init = FALSE)
[13:34:40.425]                 }
[13:34:40.425]             }
[13:34:40.425]         }
[13:34:40.425]     })
[13:34:40.425]     if (TRUE) {
[13:34:40.425]         base::sink(type = "output", split = FALSE)
[13:34:40.425]         if (TRUE) {
[13:34:40.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.425]         }
[13:34:40.425]         else {
[13:34:40.425]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.425]         }
[13:34:40.425]         base::close(...future.stdout)
[13:34:40.425]         ...future.stdout <- NULL
[13:34:40.425]     }
[13:34:40.425]     ...future.result$conditions <- ...future.conditions
[13:34:40.425]     ...future.result$finished <- base::Sys.time()
[13:34:40.425]     ...future.result
[13:34:40.425] }
[13:34:40.427] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[13:34:40.427] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[13:34:40.428] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[13:34:40.428] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[13:34:40.428] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[13:34:40.428] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:34:40.429] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:34:40.429] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:40.429] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.429] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:40.429] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.430] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[13:34:40.430] MultisessionFuture started
[13:34:40.430] - Launch lazy future ... done
[13:34:40.430] run() for ‘MultisessionFuture’ ... done
[13:34:40.430] Created future:
[13:34:40.430] MultisessionFuture:
[13:34:40.430] Label: ‘future_.mapply-2’
[13:34:40.430] Expression:
[13:34:40.430] {
[13:34:40.430]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.430]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.430]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.430]         on.exit(options(oopts), add = TRUE)
[13:34:40.430]     }
[13:34:40.430]     {
[13:34:40.430]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.430]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.430]         do.call(mapply, args = args)
[13:34:40.430]     }
[13:34:40.430] }
[13:34:40.430] Lazy evaluation: FALSE
[13:34:40.430] Asynchronous evaluation: TRUE
[13:34:40.430] Local evaluation: TRUE
[13:34:40.430] Environment: R_GlobalEnv
[13:34:40.430] Capture standard output: TRUE
[13:34:40.430] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.430] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.430] Packages: <none>
[13:34:40.430] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:40.430] Resolved: FALSE
[13:34:40.430] Value: <not collected>
[13:34:40.430] Conditions captured: <none>
[13:34:40.430] Early signaling: FALSE
[13:34:40.430] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.430] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.442] Chunk #2 of 2 ... DONE
[13:34:40.442] Launching 2 futures (chunks) ... DONE
[13:34:40.442] Resolving 2 futures (chunks) ...
[13:34:40.442] resolve() on list ...
[13:34:40.442]  recursive: 0
[13:34:40.442]  length: 2
[13:34:40.442] 
[13:34:40.443] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.443] - Validating connection of MultisessionFuture
[13:34:40.443] - received message: FutureResult
[13:34:40.443] - Received FutureResult
[13:34:40.443] - Erased future from FutureRegistry
[13:34:40.444] result() for ClusterFuture ...
[13:34:40.444] - result already collected: FutureResult
[13:34:40.444] result() for ClusterFuture ... done
[13:34:40.444] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.444] Future #1
[13:34:40.444] result() for ClusterFuture ...
[13:34:40.444] - result already collected: FutureResult
[13:34:40.444] result() for ClusterFuture ... done
[13:34:40.444] result() for ClusterFuture ...
[13:34:40.444] - result already collected: FutureResult
[13:34:40.444] result() for ClusterFuture ... done
[13:34:40.445] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:40.445] - nx: 2
[13:34:40.445] - relay: TRUE
[13:34:40.445] - stdout: TRUE
[13:34:40.445] - signal: TRUE
[13:34:40.445] - resignal: FALSE
[13:34:40.445] - force: TRUE
[13:34:40.445] - relayed: [n=2] FALSE, FALSE
[13:34:40.445] - queued futures: [n=2] FALSE, FALSE
[13:34:40.445]  - until=1
[13:34:40.445]  - relaying element #1
[13:34:40.445] result() for ClusterFuture ...
[13:34:40.446] - result already collected: FutureResult
[13:34:40.446] result() for ClusterFuture ... done
[13:34:40.446] result() for ClusterFuture ...
[13:34:40.446] - result already collected: FutureResult
[13:34:40.446] result() for ClusterFuture ... done
[13:34:40.446] result() for ClusterFuture ...
[13:34:40.446] - result already collected: FutureResult
[13:34:40.446] result() for ClusterFuture ... done
[13:34:40.446] result() for ClusterFuture ...
[13:34:40.446] - result already collected: FutureResult
[13:34:40.446] result() for ClusterFuture ... done
[13:34:40.447] - relayed: [n=2] TRUE, FALSE
[13:34:40.447] - queued futures: [n=2] TRUE, FALSE
[13:34:40.447] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:40.447]  length: 1 (resolved future 1)
[13:34:40.472] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.472] - Validating connection of MultisessionFuture
[13:34:40.472] - received message: FutureResult
[13:34:40.472] - Received FutureResult
[13:34:40.472] - Erased future from FutureRegistry
[13:34:40.472] result() for ClusterFuture ...
[13:34:40.472] - result already collected: FutureResult
[13:34:40.472] result() for ClusterFuture ... done
[13:34:40.472] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.473] Future #2
[13:34:40.473] result() for ClusterFuture ...
[13:34:40.473] - result already collected: FutureResult
[13:34:40.473] result() for ClusterFuture ... done
[13:34:40.473] result() for ClusterFuture ...
[13:34:40.473] - result already collected: FutureResult
[13:34:40.473] result() for ClusterFuture ... done
[13:34:40.473] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:40.473] - nx: 2
[13:34:40.473] - relay: TRUE
[13:34:40.473] - stdout: TRUE
[13:34:40.473] - signal: TRUE
[13:34:40.474] - resignal: FALSE
[13:34:40.474] - force: TRUE
[13:34:40.474] - relayed: [n=2] TRUE, FALSE
[13:34:40.474] - queued futures: [n=2] TRUE, FALSE
[13:34:40.474]  - until=2
[13:34:40.474]  - relaying element #2
[13:34:40.474] result() for ClusterFuture ...
[13:34:40.474] - result already collected: FutureResult
[13:34:40.474] result() for ClusterFuture ... done
[13:34:40.474] result() for ClusterFuture ...
[13:34:40.474] - result already collected: FutureResult
[13:34:40.475] result() for ClusterFuture ... done
[13:34:40.475] result() for ClusterFuture ...
[13:34:40.475] - result already collected: FutureResult
[13:34:40.475] result() for ClusterFuture ... done
[13:34:40.475] result() for ClusterFuture ...
[13:34:40.475] - result already collected: FutureResult
[13:34:40.475] result() for ClusterFuture ... done
[13:34:40.475] - relayed: [n=2] TRUE, TRUE
[13:34:40.475] - queued futures: [n=2] TRUE, TRUE
[13:34:40.475] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:40.475]  length: 0 (resolved future 2)
[13:34:40.476] Relaying remaining futures
[13:34:40.476] signalConditionsASAP(NULL, pos=0) ...
[13:34:40.476] - nx: 2
[13:34:40.476] - relay: TRUE
[13:34:40.476] - stdout: TRUE
[13:34:40.476] - signal: TRUE
[13:34:40.476] - resignal: FALSE
[13:34:40.476] - force: TRUE
[13:34:40.476] - relayed: [n=2] TRUE, TRUE
[13:34:40.476] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:40.476] - relayed: [n=2] TRUE, TRUE
[13:34:40.477] - queued futures: [n=2] TRUE, TRUE
[13:34:40.477] signalConditionsASAP(NULL, pos=0) ... done
[13:34:40.477] resolve() on list ... DONE
[13:34:40.477] result() for ClusterFuture ...
[13:34:40.477] - result already collected: FutureResult
[13:34:40.477] result() for ClusterFuture ... done
[13:34:40.477] result() for ClusterFuture ...
[13:34:40.477] - result already collected: FutureResult
[13:34:40.477] result() for ClusterFuture ... done
[13:34:40.477] result() for ClusterFuture ...
[13:34:40.477] - result already collected: FutureResult
[13:34:40.478] result() for ClusterFuture ... done
[13:34:40.478] result() for ClusterFuture ...
[13:34:40.478] - result already collected: FutureResult
[13:34:40.478] result() for ClusterFuture ... done
[13:34:40.478]  - Number of value chunks collected: 2
[13:34:40.478] Resolving 2 futures (chunks) ... DONE
[13:34:40.478] Reducing values from 2 chunks ...
[13:34:40.478]  - Number of values collected after concatenation: 2
[13:34:40.478]  - Number of values expected: 2
[13:34:40.478] Reducing values from 2 chunks ... DONE
[13:34:40.478] future_mapply() ... DONE
- Recycle arguments to same length ...
[13:34:40.479] future_mapply() ...
[13:34:40.482] Number of chunks: 2
[13:34:40.482] getGlobalsAndPackagesXApply() ...
[13:34:40.482]  - future.globals: TRUE
[13:34:40.482] getGlobalsAndPackages() ...
[13:34:40.482] Searching for globals...
[13:34:40.483] - globals found: [1] ‘FUN’
[13:34:40.483] Searching for globals ... DONE
[13:34:40.483] Resolving globals: FALSE
[13:34:40.484] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:40.484] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:40.484] - globals: [1] ‘FUN’
[13:34:40.484] 
[13:34:40.484] getGlobalsAndPackages() ... DONE
[13:34:40.484]  - globals found/used: [n=1] ‘FUN’
[13:34:40.484]  - needed namespaces: [n=0] 
[13:34:40.484] Finding globals ... DONE
[13:34:40.485] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:40.485] List of 2
[13:34:40.485]  $ ...future.FUN:function (x, ...)  
[13:34:40.485]  $ MoreArgs     : NULL
[13:34:40.485]  - attr(*, "where")=List of 2
[13:34:40.485]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:40.485]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:40.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:40.485]  - attr(*, "resolved")= logi FALSE
[13:34:40.485]  - attr(*, "total_size")= num NA
[13:34:40.487] Packages to be attached in all futures: [n=0] 
[13:34:40.487] getGlobalsAndPackagesXApply() ... DONE
[13:34:40.487] Number of futures (= number of chunks): 2
[13:34:40.488] Launching 2 futures (chunks) ...
[13:34:40.488] Chunk #1 of 2 ...
[13:34:40.488]  - Finding globals in '...' for chunk #1 ...
[13:34:40.488] getGlobalsAndPackages() ...
[13:34:40.488] Searching for globals...
[13:34:40.488] 
[13:34:40.488] Searching for globals ... DONE
[13:34:40.488] - globals: [0] <none>
[13:34:40.489] getGlobalsAndPackages() ... DONE
[13:34:40.489]    + additional globals found: [n=0] 
[13:34:40.489]    + additional namespaces needed: [n=0] 
[13:34:40.489]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:40.489]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.489]  - seeds: <none>
[13:34:40.489]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.489] getGlobalsAndPackages() ...
[13:34:40.489] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.489] Resolving globals: FALSE
[13:34:40.490] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:40.490] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:40.490] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.491] 
[13:34:40.491] getGlobalsAndPackages() ... DONE
[13:34:40.491] run() for ‘Future’ ...
[13:34:40.491] - state: ‘created’
[13:34:40.491] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.504] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.504] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.505]   - Field: ‘node’
[13:34:40.505]   - Field: ‘label’
[13:34:40.505]   - Field: ‘local’
[13:34:40.505]   - Field: ‘owner’
[13:34:40.505]   - Field: ‘envir’
[13:34:40.505]   - Field: ‘workers’
[13:34:40.505]   - Field: ‘packages’
[13:34:40.505]   - Field: ‘gc’
[13:34:40.505]   - Field: ‘conditions’
[13:34:40.505]   - Field: ‘persistent’
[13:34:40.506]   - Field: ‘expr’
[13:34:40.506]   - Field: ‘uuid’
[13:34:40.506]   - Field: ‘seed’
[13:34:40.506]   - Field: ‘version’
[13:34:40.506]   - Field: ‘result’
[13:34:40.506]   - Field: ‘asynchronous’
[13:34:40.506]   - Field: ‘calls’
[13:34:40.506]   - Field: ‘globals’
[13:34:40.506]   - Field: ‘stdout’
[13:34:40.506]   - Field: ‘earlySignal’
[13:34:40.507]   - Field: ‘lazy’
[13:34:40.507]   - Field: ‘state’
[13:34:40.507] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.507] - Launch lazy future ...
[13:34:40.507] Packages needed by the future expression (n = 0): <none>
[13:34:40.507] Packages needed by future strategies (n = 0): <none>
[13:34:40.510] {
[13:34:40.510]     {
[13:34:40.510]         {
[13:34:40.510]             ...future.startTime <- base::Sys.time()
[13:34:40.510]             {
[13:34:40.510]                 {
[13:34:40.510]                   {
[13:34:40.510]                     {
[13:34:40.510]                       base::local({
[13:34:40.510]                         has_future <- base::requireNamespace("future", 
[13:34:40.510]                           quietly = TRUE)
[13:34:40.510]                         if (has_future) {
[13:34:40.510]                           ns <- base::getNamespace("future")
[13:34:40.510]                           version <- ns[[".package"]][["version"]]
[13:34:40.510]                           if (is.null(version)) 
[13:34:40.510]                             version <- utils::packageVersion("future")
[13:34:40.510]                         }
[13:34:40.510]                         else {
[13:34:40.510]                           version <- NULL
[13:34:40.510]                         }
[13:34:40.510]                         if (!has_future || version < "1.8.0") {
[13:34:40.510]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.510]                             "", base::R.version$version.string), 
[13:34:40.510]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:40.510]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:40.510]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.510]                               "release", "version")], collapse = " "), 
[13:34:40.510]                             hostname = base::Sys.info()[["nodename"]])
[13:34:40.510]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.510]                             info)
[13:34:40.510]                           info <- base::paste(info, collapse = "; ")
[13:34:40.510]                           if (!has_future) {
[13:34:40.510]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.510]                               info)
[13:34:40.510]                           }
[13:34:40.510]                           else {
[13:34:40.510]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.510]                               info, version)
[13:34:40.510]                           }
[13:34:40.510]                           base::stop(msg)
[13:34:40.510]                         }
[13:34:40.510]                       })
[13:34:40.510]                     }
[13:34:40.510]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.510]                     base::options(mc.cores = 1L)
[13:34:40.510]                   }
[13:34:40.510]                   ...future.strategy.old <- future::plan("list")
[13:34:40.510]                   options(future.plan = NULL)
[13:34:40.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.510]                 }
[13:34:40.510]                 ...future.workdir <- getwd()
[13:34:40.510]             }
[13:34:40.510]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.510]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.510]         }
[13:34:40.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.510]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.510]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.510]             base::names(...future.oldOptions))
[13:34:40.510]     }
[13:34:40.510]     if (FALSE) {
[13:34:40.510]     }
[13:34:40.510]     else {
[13:34:40.510]         if (TRUE) {
[13:34:40.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.510]                 open = "w")
[13:34:40.510]         }
[13:34:40.510]         else {
[13:34:40.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.510]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.510]         }
[13:34:40.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.510]             base::sink(type = "output", split = FALSE)
[13:34:40.510]             base::close(...future.stdout)
[13:34:40.510]         }, add = TRUE)
[13:34:40.510]     }
[13:34:40.510]     ...future.frame <- base::sys.nframe()
[13:34:40.510]     ...future.conditions <- base::list()
[13:34:40.510]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.510]     if (FALSE) {
[13:34:40.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.510]     }
[13:34:40.510]     ...future.result <- base::tryCatch({
[13:34:40.510]         base::withCallingHandlers({
[13:34:40.510]             ...future.value <- base::withVisible(base::local({
[13:34:40.510]                 ...future.makeSendCondition <- base::local({
[13:34:40.510]                   sendCondition <- NULL
[13:34:40.510]                   function(frame = 1L) {
[13:34:40.510]                     if (is.function(sendCondition)) 
[13:34:40.510]                       return(sendCondition)
[13:34:40.510]                     ns <- getNamespace("parallel")
[13:34:40.510]                     if (exists("sendData", mode = "function", 
[13:34:40.510]                       envir = ns)) {
[13:34:40.510]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.510]                         envir = ns)
[13:34:40.510]                       envir <- sys.frame(frame)
[13:34:40.510]                       master <- NULL
[13:34:40.510]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.510]                         !identical(envir, emptyenv())) {
[13:34:40.510]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.510]                           inherits = FALSE)) {
[13:34:40.510]                           master <- get("master", mode = "list", 
[13:34:40.510]                             envir = envir, inherits = FALSE)
[13:34:40.510]                           if (inherits(master, c("SOCKnode", 
[13:34:40.510]                             "SOCK0node"))) {
[13:34:40.510]                             sendCondition <<- function(cond) {
[13:34:40.510]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.510]                                 success = TRUE)
[13:34:40.510]                               parallel_sendData(master, data)
[13:34:40.510]                             }
[13:34:40.510]                             return(sendCondition)
[13:34:40.510]                           }
[13:34:40.510]                         }
[13:34:40.510]                         frame <- frame + 1L
[13:34:40.510]                         envir <- sys.frame(frame)
[13:34:40.510]                       }
[13:34:40.510]                     }
[13:34:40.510]                     sendCondition <<- function(cond) NULL
[13:34:40.510]                   }
[13:34:40.510]                 })
[13:34:40.510]                 withCallingHandlers({
[13:34:40.510]                   {
[13:34:40.510]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.510]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.510]                       ...future.globals.maxSize)) {
[13:34:40.510]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.510]                       on.exit(options(oopts), add = TRUE)
[13:34:40.510]                     }
[13:34:40.510]                     {
[13:34:40.510]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.510]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.510]                         USE.NAMES = FALSE)
[13:34:40.510]                       do.call(mapply, args = args)
[13:34:40.510]                     }
[13:34:40.510]                   }
[13:34:40.510]                 }, immediateCondition = function(cond) {
[13:34:40.510]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.510]                   sendCondition(cond)
[13:34:40.510]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.510]                   {
[13:34:40.510]                     inherits <- base::inherits
[13:34:40.510]                     invokeRestart <- base::invokeRestart
[13:34:40.510]                     is.null <- base::is.null
[13:34:40.510]                     muffled <- FALSE
[13:34:40.510]                     if (inherits(cond, "message")) {
[13:34:40.510]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.510]                       if (muffled) 
[13:34:40.510]                         invokeRestart("muffleMessage")
[13:34:40.510]                     }
[13:34:40.510]                     else if (inherits(cond, "warning")) {
[13:34:40.510]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.510]                       if (muffled) 
[13:34:40.510]                         invokeRestart("muffleWarning")
[13:34:40.510]                     }
[13:34:40.510]                     else if (inherits(cond, "condition")) {
[13:34:40.510]                       if (!is.null(pattern)) {
[13:34:40.510]                         computeRestarts <- base::computeRestarts
[13:34:40.510]                         grepl <- base::grepl
[13:34:40.510]                         restarts <- computeRestarts(cond)
[13:34:40.510]                         for (restart in restarts) {
[13:34:40.510]                           name <- restart$name
[13:34:40.510]                           if (is.null(name)) 
[13:34:40.510]                             next
[13:34:40.510]                           if (!grepl(pattern, name)) 
[13:34:40.510]                             next
[13:34:40.510]                           invokeRestart(restart)
[13:34:40.510]                           muffled <- TRUE
[13:34:40.510]                           break
[13:34:40.510]                         }
[13:34:40.510]                       }
[13:34:40.510]                     }
[13:34:40.510]                     invisible(muffled)
[13:34:40.510]                   }
[13:34:40.510]                   muffleCondition(cond)
[13:34:40.510]                 })
[13:34:40.510]             }))
[13:34:40.510]             future::FutureResult(value = ...future.value$value, 
[13:34:40.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.510]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.510]                     ...future.globalenv.names))
[13:34:40.510]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.510]         }, condition = base::local({
[13:34:40.510]             c <- base::c
[13:34:40.510]             inherits <- base::inherits
[13:34:40.510]             invokeRestart <- base::invokeRestart
[13:34:40.510]             length <- base::length
[13:34:40.510]             list <- base::list
[13:34:40.510]             seq.int <- base::seq.int
[13:34:40.510]             signalCondition <- base::signalCondition
[13:34:40.510]             sys.calls <- base::sys.calls
[13:34:40.510]             `[[` <- base::`[[`
[13:34:40.510]             `+` <- base::`+`
[13:34:40.510]             `<<-` <- base::`<<-`
[13:34:40.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.510]                   3L)]
[13:34:40.510]             }
[13:34:40.510]             function(cond) {
[13:34:40.510]                 is_error <- inherits(cond, "error")
[13:34:40.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.510]                   NULL)
[13:34:40.510]                 if (is_error) {
[13:34:40.510]                   sessionInformation <- function() {
[13:34:40.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.510]                       search = base::search(), system = base::Sys.info())
[13:34:40.510]                   }
[13:34:40.510]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.510]                     cond$call), session = sessionInformation(), 
[13:34:40.510]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.510]                   signalCondition(cond)
[13:34:40.510]                 }
[13:34:40.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.510]                 "immediateCondition"))) {
[13:34:40.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.510]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.510]                   if (TRUE && !signal) {
[13:34:40.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.510]                     {
[13:34:40.510]                       inherits <- base::inherits
[13:34:40.510]                       invokeRestart <- base::invokeRestart
[13:34:40.510]                       is.null <- base::is.null
[13:34:40.510]                       muffled <- FALSE
[13:34:40.510]                       if (inherits(cond, "message")) {
[13:34:40.510]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.510]                         if (muffled) 
[13:34:40.510]                           invokeRestart("muffleMessage")
[13:34:40.510]                       }
[13:34:40.510]                       else if (inherits(cond, "warning")) {
[13:34:40.510]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.510]                         if (muffled) 
[13:34:40.510]                           invokeRestart("muffleWarning")
[13:34:40.510]                       }
[13:34:40.510]                       else if (inherits(cond, "condition")) {
[13:34:40.510]                         if (!is.null(pattern)) {
[13:34:40.510]                           computeRestarts <- base::computeRestarts
[13:34:40.510]                           grepl <- base::grepl
[13:34:40.510]                           restarts <- computeRestarts(cond)
[13:34:40.510]                           for (restart in restarts) {
[13:34:40.510]                             name <- restart$name
[13:34:40.510]                             if (is.null(name)) 
[13:34:40.510]                               next
[13:34:40.510]                             if (!grepl(pattern, name)) 
[13:34:40.510]                               next
[13:34:40.510]                             invokeRestart(restart)
[13:34:40.510]                             muffled <- TRUE
[13:34:40.510]                             break
[13:34:40.510]                           }
[13:34:40.510]                         }
[13:34:40.510]                       }
[13:34:40.510]                       invisible(muffled)
[13:34:40.510]                     }
[13:34:40.510]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.510]                   }
[13:34:40.510]                 }
[13:34:40.510]                 else {
[13:34:40.510]                   if (TRUE) {
[13:34:40.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.510]                     {
[13:34:40.510]                       inherits <- base::inherits
[13:34:40.510]                       invokeRestart <- base::invokeRestart
[13:34:40.510]                       is.null <- base::is.null
[13:34:40.510]                       muffled <- FALSE
[13:34:40.510]                       if (inherits(cond, "message")) {
[13:34:40.510]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.510]                         if (muffled) 
[13:34:40.510]                           invokeRestart("muffleMessage")
[13:34:40.510]                       }
[13:34:40.510]                       else if (inherits(cond, "warning")) {
[13:34:40.510]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.510]                         if (muffled) 
[13:34:40.510]                           invokeRestart("muffleWarning")
[13:34:40.510]                       }
[13:34:40.510]                       else if (inherits(cond, "condition")) {
[13:34:40.510]                         if (!is.null(pattern)) {
[13:34:40.510]                           computeRestarts <- base::computeRestarts
[13:34:40.510]                           grepl <- base::grepl
[13:34:40.510]                           restarts <- computeRestarts(cond)
[13:34:40.510]                           for (restart in restarts) {
[13:34:40.510]                             name <- restart$name
[13:34:40.510]                             if (is.null(name)) 
[13:34:40.510]                               next
[13:34:40.510]                             if (!grepl(pattern, name)) 
[13:34:40.510]                               next
[13:34:40.510]                             invokeRestart(restart)
[13:34:40.510]                             muffled <- TRUE
[13:34:40.510]                             break
[13:34:40.510]                           }
[13:34:40.510]                         }
[13:34:40.510]                       }
[13:34:40.510]                       invisible(muffled)
[13:34:40.510]                     }
[13:34:40.510]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.510]                   }
[13:34:40.510]                 }
[13:34:40.510]             }
[13:34:40.510]         }))
[13:34:40.510]     }, error = function(ex) {
[13:34:40.510]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.510]                 ...future.rng), started = ...future.startTime, 
[13:34:40.510]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.510]             version = "1.8"), class = "FutureResult")
[13:34:40.510]     }, finally = {
[13:34:40.510]         if (!identical(...future.workdir, getwd())) 
[13:34:40.510]             setwd(...future.workdir)
[13:34:40.510]         {
[13:34:40.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.510]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.510]             }
[13:34:40.510]             base::options(...future.oldOptions)
[13:34:40.510]             if (.Platform$OS.type == "windows") {
[13:34:40.510]                 old_names <- names(...future.oldEnvVars)
[13:34:40.510]                 envs <- base::Sys.getenv()
[13:34:40.510]                 names <- names(envs)
[13:34:40.510]                 common <- intersect(names, old_names)
[13:34:40.510]                 added <- setdiff(names, old_names)
[13:34:40.510]                 removed <- setdiff(old_names, names)
[13:34:40.510]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.510]                   envs[common]]
[13:34:40.510]                 NAMES <- toupper(changed)
[13:34:40.510]                 args <- list()
[13:34:40.510]                 for (kk in seq_along(NAMES)) {
[13:34:40.510]                   name <- changed[[kk]]
[13:34:40.510]                   NAME <- NAMES[[kk]]
[13:34:40.510]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.510]                     next
[13:34:40.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.510]                 }
[13:34:40.510]                 NAMES <- toupper(added)
[13:34:40.510]                 for (kk in seq_along(NAMES)) {
[13:34:40.510]                   name <- added[[kk]]
[13:34:40.510]                   NAME <- NAMES[[kk]]
[13:34:40.510]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.510]                     next
[13:34:40.510]                   args[[name]] <- ""
[13:34:40.510]                 }
[13:34:40.510]                 NAMES <- toupper(removed)
[13:34:40.510]                 for (kk in seq_along(NAMES)) {
[13:34:40.510]                   name <- removed[[kk]]
[13:34:40.510]                   NAME <- NAMES[[kk]]
[13:34:40.510]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.510]                     next
[13:34:40.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.510]                 }
[13:34:40.510]                 if (length(args) > 0) 
[13:34:40.510]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.510]             }
[13:34:40.510]             else {
[13:34:40.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.510]             }
[13:34:40.510]             {
[13:34:40.510]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.510]                   0L) {
[13:34:40.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.510]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.510]                   base::options(opts)
[13:34:40.510]                 }
[13:34:40.510]                 {
[13:34:40.510]                   {
[13:34:40.510]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.510]                     NULL
[13:34:40.510]                   }
[13:34:40.510]                   options(future.plan = NULL)
[13:34:40.510]                   if (is.na(NA_character_)) 
[13:34:40.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.510]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.510]                     .init = FALSE)
[13:34:40.510]                 }
[13:34:40.510]             }
[13:34:40.510]         }
[13:34:40.510]     })
[13:34:40.510]     if (TRUE) {
[13:34:40.510]         base::sink(type = "output", split = FALSE)
[13:34:40.510]         if (TRUE) {
[13:34:40.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.510]         }
[13:34:40.510]         else {
[13:34:40.510]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.510]         }
[13:34:40.510]         base::close(...future.stdout)
[13:34:40.510]         ...future.stdout <- NULL
[13:34:40.510]     }
[13:34:40.510]     ...future.result$conditions <- ...future.conditions
[13:34:40.510]     ...future.result$finished <- base::Sys.time()
[13:34:40.510]     ...future.result
[13:34:40.510] }
[13:34:40.513] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[13:34:40.513] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[13:34:40.513] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[13:34:40.513] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:40.514] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.514] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[13:34:40.514] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[13:34:40.514] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:40.515] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.515] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:40.515] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.515] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[13:34:40.516] MultisessionFuture started
[13:34:40.516] - Launch lazy future ... done
[13:34:40.516] run() for ‘MultisessionFuture’ ... done
[13:34:40.516] Created future:
[13:34:40.516] MultisessionFuture:
[13:34:40.516] Label: ‘future_mapply-1’
[13:34:40.516] Expression:
[13:34:40.516] {
[13:34:40.516]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.516]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.516]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.516]         on.exit(options(oopts), add = TRUE)
[13:34:40.516]     }
[13:34:40.516]     {
[13:34:40.516]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.516]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.516]         do.call(mapply, args = args)
[13:34:40.516]     }
[13:34:40.516] }
[13:34:40.516] Lazy evaluation: FALSE
[13:34:40.516] Asynchronous evaluation: TRUE
[13:34:40.516] Local evaluation: TRUE
[13:34:40.516] Environment: R_GlobalEnv
[13:34:40.516] Capture standard output: TRUE
[13:34:40.516] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.516] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.516] Packages: <none>
[13:34:40.516] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:40.516] Resolved: FALSE
[13:34:40.516] Value: <not collected>
[13:34:40.516] Conditions captured: <none>
[13:34:40.516] Early signaling: FALSE
[13:34:40.516] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.516] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.527] Chunk #1 of 2 ... DONE
[13:34:40.527] Chunk #2 of 2 ...
[13:34:40.527]  - Finding globals in '...' for chunk #2 ...
[13:34:40.527] getGlobalsAndPackages() ...
[13:34:40.528] Searching for globals...
[13:34:40.528] 
[13:34:40.528] Searching for globals ... DONE
[13:34:40.528] - globals: [0] <none>
[13:34:40.528] getGlobalsAndPackages() ... DONE
[13:34:40.528]    + additional globals found: [n=0] 
[13:34:40.528]    + additional namespaces needed: [n=0] 
[13:34:40.528]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:40.528]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.529]  - seeds: <none>
[13:34:40.529]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.529] getGlobalsAndPackages() ...
[13:34:40.529] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.529] Resolving globals: FALSE
[13:34:40.529] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:40.530] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:40.530] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.530] 
[13:34:40.530] getGlobalsAndPackages() ... DONE
[13:34:40.530] run() for ‘Future’ ...
[13:34:40.531] - state: ‘created’
[13:34:40.531] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.544] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.544] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.545]   - Field: ‘node’
[13:34:40.545]   - Field: ‘label’
[13:34:40.545]   - Field: ‘local’
[13:34:40.545]   - Field: ‘owner’
[13:34:40.545]   - Field: ‘envir’
[13:34:40.545]   - Field: ‘workers’
[13:34:40.545]   - Field: ‘packages’
[13:34:40.545]   - Field: ‘gc’
[13:34:40.545]   - Field: ‘conditions’
[13:34:40.545]   - Field: ‘persistent’
[13:34:40.545]   - Field: ‘expr’
[13:34:40.546]   - Field: ‘uuid’
[13:34:40.546]   - Field: ‘seed’
[13:34:40.546]   - Field: ‘version’
[13:34:40.546]   - Field: ‘result’
[13:34:40.546]   - Field: ‘asynchronous’
[13:34:40.546]   - Field: ‘calls’
[13:34:40.546]   - Field: ‘globals’
[13:34:40.546]   - Field: ‘stdout’
[13:34:40.546]   - Field: ‘earlySignal’
[13:34:40.546]   - Field: ‘lazy’
[13:34:40.546]   - Field: ‘state’
[13:34:40.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.547] - Launch lazy future ...
[13:34:40.547] Packages needed by the future expression (n = 0): <none>
[13:34:40.547] Packages needed by future strategies (n = 0): <none>
[13:34:40.547] {
[13:34:40.547]     {
[13:34:40.547]         {
[13:34:40.547]             ...future.startTime <- base::Sys.time()
[13:34:40.547]             {
[13:34:40.547]                 {
[13:34:40.547]                   {
[13:34:40.547]                     {
[13:34:40.547]                       base::local({
[13:34:40.547]                         has_future <- base::requireNamespace("future", 
[13:34:40.547]                           quietly = TRUE)
[13:34:40.547]                         if (has_future) {
[13:34:40.547]                           ns <- base::getNamespace("future")
[13:34:40.547]                           version <- ns[[".package"]][["version"]]
[13:34:40.547]                           if (is.null(version)) 
[13:34:40.547]                             version <- utils::packageVersion("future")
[13:34:40.547]                         }
[13:34:40.547]                         else {
[13:34:40.547]                           version <- NULL
[13:34:40.547]                         }
[13:34:40.547]                         if (!has_future || version < "1.8.0") {
[13:34:40.547]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.547]                             "", base::R.version$version.string), 
[13:34:40.547]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:40.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:40.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.547]                               "release", "version")], collapse = " "), 
[13:34:40.547]                             hostname = base::Sys.info()[["nodename"]])
[13:34:40.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.547]                             info)
[13:34:40.547]                           info <- base::paste(info, collapse = "; ")
[13:34:40.547]                           if (!has_future) {
[13:34:40.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.547]                               info)
[13:34:40.547]                           }
[13:34:40.547]                           else {
[13:34:40.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.547]                               info, version)
[13:34:40.547]                           }
[13:34:40.547]                           base::stop(msg)
[13:34:40.547]                         }
[13:34:40.547]                       })
[13:34:40.547]                     }
[13:34:40.547]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.547]                     base::options(mc.cores = 1L)
[13:34:40.547]                   }
[13:34:40.547]                   ...future.strategy.old <- future::plan("list")
[13:34:40.547]                   options(future.plan = NULL)
[13:34:40.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.547]                 }
[13:34:40.547]                 ...future.workdir <- getwd()
[13:34:40.547]             }
[13:34:40.547]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.547]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.547]         }
[13:34:40.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.547]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.547]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.547]             base::names(...future.oldOptions))
[13:34:40.547]     }
[13:34:40.547]     if (FALSE) {
[13:34:40.547]     }
[13:34:40.547]     else {
[13:34:40.547]         if (TRUE) {
[13:34:40.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.547]                 open = "w")
[13:34:40.547]         }
[13:34:40.547]         else {
[13:34:40.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.547]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.547]         }
[13:34:40.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.547]             base::sink(type = "output", split = FALSE)
[13:34:40.547]             base::close(...future.stdout)
[13:34:40.547]         }, add = TRUE)
[13:34:40.547]     }
[13:34:40.547]     ...future.frame <- base::sys.nframe()
[13:34:40.547]     ...future.conditions <- base::list()
[13:34:40.547]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.547]     if (FALSE) {
[13:34:40.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.547]     }
[13:34:40.547]     ...future.result <- base::tryCatch({
[13:34:40.547]         base::withCallingHandlers({
[13:34:40.547]             ...future.value <- base::withVisible(base::local({
[13:34:40.547]                 ...future.makeSendCondition <- base::local({
[13:34:40.547]                   sendCondition <- NULL
[13:34:40.547]                   function(frame = 1L) {
[13:34:40.547]                     if (is.function(sendCondition)) 
[13:34:40.547]                       return(sendCondition)
[13:34:40.547]                     ns <- getNamespace("parallel")
[13:34:40.547]                     if (exists("sendData", mode = "function", 
[13:34:40.547]                       envir = ns)) {
[13:34:40.547]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.547]                         envir = ns)
[13:34:40.547]                       envir <- sys.frame(frame)
[13:34:40.547]                       master <- NULL
[13:34:40.547]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.547]                         !identical(envir, emptyenv())) {
[13:34:40.547]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.547]                           inherits = FALSE)) {
[13:34:40.547]                           master <- get("master", mode = "list", 
[13:34:40.547]                             envir = envir, inherits = FALSE)
[13:34:40.547]                           if (inherits(master, c("SOCKnode", 
[13:34:40.547]                             "SOCK0node"))) {
[13:34:40.547]                             sendCondition <<- function(cond) {
[13:34:40.547]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.547]                                 success = TRUE)
[13:34:40.547]                               parallel_sendData(master, data)
[13:34:40.547]                             }
[13:34:40.547]                             return(sendCondition)
[13:34:40.547]                           }
[13:34:40.547]                         }
[13:34:40.547]                         frame <- frame + 1L
[13:34:40.547]                         envir <- sys.frame(frame)
[13:34:40.547]                       }
[13:34:40.547]                     }
[13:34:40.547]                     sendCondition <<- function(cond) NULL
[13:34:40.547]                   }
[13:34:40.547]                 })
[13:34:40.547]                 withCallingHandlers({
[13:34:40.547]                   {
[13:34:40.547]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.547]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.547]                       ...future.globals.maxSize)) {
[13:34:40.547]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.547]                       on.exit(options(oopts), add = TRUE)
[13:34:40.547]                     }
[13:34:40.547]                     {
[13:34:40.547]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.547]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.547]                         USE.NAMES = FALSE)
[13:34:40.547]                       do.call(mapply, args = args)
[13:34:40.547]                     }
[13:34:40.547]                   }
[13:34:40.547]                 }, immediateCondition = function(cond) {
[13:34:40.547]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.547]                   sendCondition(cond)
[13:34:40.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.547]                   {
[13:34:40.547]                     inherits <- base::inherits
[13:34:40.547]                     invokeRestart <- base::invokeRestart
[13:34:40.547]                     is.null <- base::is.null
[13:34:40.547]                     muffled <- FALSE
[13:34:40.547]                     if (inherits(cond, "message")) {
[13:34:40.547]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.547]                       if (muffled) 
[13:34:40.547]                         invokeRestart("muffleMessage")
[13:34:40.547]                     }
[13:34:40.547]                     else if (inherits(cond, "warning")) {
[13:34:40.547]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.547]                       if (muffled) 
[13:34:40.547]                         invokeRestart("muffleWarning")
[13:34:40.547]                     }
[13:34:40.547]                     else if (inherits(cond, "condition")) {
[13:34:40.547]                       if (!is.null(pattern)) {
[13:34:40.547]                         computeRestarts <- base::computeRestarts
[13:34:40.547]                         grepl <- base::grepl
[13:34:40.547]                         restarts <- computeRestarts(cond)
[13:34:40.547]                         for (restart in restarts) {
[13:34:40.547]                           name <- restart$name
[13:34:40.547]                           if (is.null(name)) 
[13:34:40.547]                             next
[13:34:40.547]                           if (!grepl(pattern, name)) 
[13:34:40.547]                             next
[13:34:40.547]                           invokeRestart(restart)
[13:34:40.547]                           muffled <- TRUE
[13:34:40.547]                           break
[13:34:40.547]                         }
[13:34:40.547]                       }
[13:34:40.547]                     }
[13:34:40.547]                     invisible(muffled)
[13:34:40.547]                   }
[13:34:40.547]                   muffleCondition(cond)
[13:34:40.547]                 })
[13:34:40.547]             }))
[13:34:40.547]             future::FutureResult(value = ...future.value$value, 
[13:34:40.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.547]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.547]                     ...future.globalenv.names))
[13:34:40.547]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.547]         }, condition = base::local({
[13:34:40.547]             c <- base::c
[13:34:40.547]             inherits <- base::inherits
[13:34:40.547]             invokeRestart <- base::invokeRestart
[13:34:40.547]             length <- base::length
[13:34:40.547]             list <- base::list
[13:34:40.547]             seq.int <- base::seq.int
[13:34:40.547]             signalCondition <- base::signalCondition
[13:34:40.547]             sys.calls <- base::sys.calls
[13:34:40.547]             `[[` <- base::`[[`
[13:34:40.547]             `+` <- base::`+`
[13:34:40.547]             `<<-` <- base::`<<-`
[13:34:40.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.547]                   3L)]
[13:34:40.547]             }
[13:34:40.547]             function(cond) {
[13:34:40.547]                 is_error <- inherits(cond, "error")
[13:34:40.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.547]                   NULL)
[13:34:40.547]                 if (is_error) {
[13:34:40.547]                   sessionInformation <- function() {
[13:34:40.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.547]                       search = base::search(), system = base::Sys.info())
[13:34:40.547]                   }
[13:34:40.547]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.547]                     cond$call), session = sessionInformation(), 
[13:34:40.547]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.547]                   signalCondition(cond)
[13:34:40.547]                 }
[13:34:40.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.547]                 "immediateCondition"))) {
[13:34:40.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.547]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.547]                   if (TRUE && !signal) {
[13:34:40.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.547]                     {
[13:34:40.547]                       inherits <- base::inherits
[13:34:40.547]                       invokeRestart <- base::invokeRestart
[13:34:40.547]                       is.null <- base::is.null
[13:34:40.547]                       muffled <- FALSE
[13:34:40.547]                       if (inherits(cond, "message")) {
[13:34:40.547]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.547]                         if (muffled) 
[13:34:40.547]                           invokeRestart("muffleMessage")
[13:34:40.547]                       }
[13:34:40.547]                       else if (inherits(cond, "warning")) {
[13:34:40.547]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.547]                         if (muffled) 
[13:34:40.547]                           invokeRestart("muffleWarning")
[13:34:40.547]                       }
[13:34:40.547]                       else if (inherits(cond, "condition")) {
[13:34:40.547]                         if (!is.null(pattern)) {
[13:34:40.547]                           computeRestarts <- base::computeRestarts
[13:34:40.547]                           grepl <- base::grepl
[13:34:40.547]                           restarts <- computeRestarts(cond)
[13:34:40.547]                           for (restart in restarts) {
[13:34:40.547]                             name <- restart$name
[13:34:40.547]                             if (is.null(name)) 
[13:34:40.547]                               next
[13:34:40.547]                             if (!grepl(pattern, name)) 
[13:34:40.547]                               next
[13:34:40.547]                             invokeRestart(restart)
[13:34:40.547]                             muffled <- TRUE
[13:34:40.547]                             break
[13:34:40.547]                           }
[13:34:40.547]                         }
[13:34:40.547]                       }
[13:34:40.547]                       invisible(muffled)
[13:34:40.547]                     }
[13:34:40.547]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.547]                   }
[13:34:40.547]                 }
[13:34:40.547]                 else {
[13:34:40.547]                   if (TRUE) {
[13:34:40.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.547]                     {
[13:34:40.547]                       inherits <- base::inherits
[13:34:40.547]                       invokeRestart <- base::invokeRestart
[13:34:40.547]                       is.null <- base::is.null
[13:34:40.547]                       muffled <- FALSE
[13:34:40.547]                       if (inherits(cond, "message")) {
[13:34:40.547]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.547]                         if (muffled) 
[13:34:40.547]                           invokeRestart("muffleMessage")
[13:34:40.547]                       }
[13:34:40.547]                       else if (inherits(cond, "warning")) {
[13:34:40.547]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.547]                         if (muffled) 
[13:34:40.547]                           invokeRestart("muffleWarning")
[13:34:40.547]                       }
[13:34:40.547]                       else if (inherits(cond, "condition")) {
[13:34:40.547]                         if (!is.null(pattern)) {
[13:34:40.547]                           computeRestarts <- base::computeRestarts
[13:34:40.547]                           grepl <- base::grepl
[13:34:40.547]                           restarts <- computeRestarts(cond)
[13:34:40.547]                           for (restart in restarts) {
[13:34:40.547]                             name <- restart$name
[13:34:40.547]                             if (is.null(name)) 
[13:34:40.547]                               next
[13:34:40.547]                             if (!grepl(pattern, name)) 
[13:34:40.547]                               next
[13:34:40.547]                             invokeRestart(restart)
[13:34:40.547]                             muffled <- TRUE
[13:34:40.547]                             break
[13:34:40.547]                           }
[13:34:40.547]                         }
[13:34:40.547]                       }
[13:34:40.547]                       invisible(muffled)
[13:34:40.547]                     }
[13:34:40.547]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.547]                   }
[13:34:40.547]                 }
[13:34:40.547]             }
[13:34:40.547]         }))
[13:34:40.547]     }, error = function(ex) {
[13:34:40.547]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.547]                 ...future.rng), started = ...future.startTime, 
[13:34:40.547]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.547]             version = "1.8"), class = "FutureResult")
[13:34:40.547]     }, finally = {
[13:34:40.547]         if (!identical(...future.workdir, getwd())) 
[13:34:40.547]             setwd(...future.workdir)
[13:34:40.547]         {
[13:34:40.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.547]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.547]             }
[13:34:40.547]             base::options(...future.oldOptions)
[13:34:40.547]             if (.Platform$OS.type == "windows") {
[13:34:40.547]                 old_names <- names(...future.oldEnvVars)
[13:34:40.547]                 envs <- base::Sys.getenv()
[13:34:40.547]                 names <- names(envs)
[13:34:40.547]                 common <- intersect(names, old_names)
[13:34:40.547]                 added <- setdiff(names, old_names)
[13:34:40.547]                 removed <- setdiff(old_names, names)
[13:34:40.547]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.547]                   envs[common]]
[13:34:40.547]                 NAMES <- toupper(changed)
[13:34:40.547]                 args <- list()
[13:34:40.547]                 for (kk in seq_along(NAMES)) {
[13:34:40.547]                   name <- changed[[kk]]
[13:34:40.547]                   NAME <- NAMES[[kk]]
[13:34:40.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.547]                     next
[13:34:40.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.547]                 }
[13:34:40.547]                 NAMES <- toupper(added)
[13:34:40.547]                 for (kk in seq_along(NAMES)) {
[13:34:40.547]                   name <- added[[kk]]
[13:34:40.547]                   NAME <- NAMES[[kk]]
[13:34:40.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.547]                     next
[13:34:40.547]                   args[[name]] <- ""
[13:34:40.547]                 }
[13:34:40.547]                 NAMES <- toupper(removed)
[13:34:40.547]                 for (kk in seq_along(NAMES)) {
[13:34:40.547]                   name <- removed[[kk]]
[13:34:40.547]                   NAME <- NAMES[[kk]]
[13:34:40.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.547]                     next
[13:34:40.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.547]                 }
[13:34:40.547]                 if (length(args) > 0) 
[13:34:40.547]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.547]             }
[13:34:40.547]             else {
[13:34:40.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.547]             }
[13:34:40.547]             {
[13:34:40.547]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.547]                   0L) {
[13:34:40.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.547]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.547]                   base::options(opts)
[13:34:40.547]                 }
[13:34:40.547]                 {
[13:34:40.547]                   {
[13:34:40.547]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.547]                     NULL
[13:34:40.547]                   }
[13:34:40.547]                   options(future.plan = NULL)
[13:34:40.547]                   if (is.na(NA_character_)) 
[13:34:40.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.547]                     .init = FALSE)
[13:34:40.547]                 }
[13:34:40.547]             }
[13:34:40.547]         }
[13:34:40.547]     })
[13:34:40.547]     if (TRUE) {
[13:34:40.547]         base::sink(type = "output", split = FALSE)
[13:34:40.547]         if (TRUE) {
[13:34:40.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.547]         }
[13:34:40.547]         else {
[13:34:40.547]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.547]         }
[13:34:40.547]         base::close(...future.stdout)
[13:34:40.547]         ...future.stdout <- NULL
[13:34:40.547]     }
[13:34:40.547]     ...future.result$conditions <- ...future.conditions
[13:34:40.547]     ...future.result$finished <- base::Sys.time()
[13:34:40.547]     ...future.result
[13:34:40.547] }
[13:34:40.550] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[13:34:40.550] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[13:34:40.550] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[13:34:40.550] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:40.551] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.551] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[13:34:40.551] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[13:34:40.551] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:40.552] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.552] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:40.552] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.552] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[13:34:40.553] MultisessionFuture started
[13:34:40.553] - Launch lazy future ... done
[13:34:40.553] run() for ‘MultisessionFuture’ ... done
[13:34:40.553] Created future:
[13:34:40.553] MultisessionFuture:
[13:34:40.553] Label: ‘future_mapply-2’
[13:34:40.553] Expression:
[13:34:40.553] {
[13:34:40.553]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.553]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.553]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.553]         on.exit(options(oopts), add = TRUE)
[13:34:40.553]     }
[13:34:40.553]     {
[13:34:40.553]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.553]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.553]         do.call(mapply, args = args)
[13:34:40.553]     }
[13:34:40.553] }
[13:34:40.553] Lazy evaluation: FALSE
[13:34:40.553] Asynchronous evaluation: TRUE
[13:34:40.553] Local evaluation: TRUE
[13:34:40.553] Environment: R_GlobalEnv
[13:34:40.553] Capture standard output: TRUE
[13:34:40.553] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.553] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.553] Packages: <none>
[13:34:40.553] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:40.553] Resolved: FALSE
[13:34:40.553] Value: <not collected>
[13:34:40.553] Conditions captured: <none>
[13:34:40.553] Early signaling: FALSE
[13:34:40.553] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.553] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.564] Chunk #2 of 2 ... DONE
[13:34:40.564] Launching 2 futures (chunks) ... DONE
[13:34:40.565] Resolving 2 futures (chunks) ...
[13:34:40.565] resolve() on list ...
[13:34:40.565]  recursive: 0
[13:34:40.565]  length: 2
[13:34:40.565] 
[13:34:40.565] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.565] - Validating connection of MultisessionFuture
[13:34:40.566] - received message: FutureResult
[13:34:40.566] - Received FutureResult
[13:34:40.566] - Erased future from FutureRegistry
[13:34:40.566] result() for ClusterFuture ...
[13:34:40.566] - result already collected: FutureResult
[13:34:40.566] result() for ClusterFuture ... done
[13:34:40.566] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.566] Future #1
[13:34:40.566] result() for ClusterFuture ...
[13:34:40.566] - result already collected: FutureResult
[13:34:40.567] result() for ClusterFuture ... done
[13:34:40.567] result() for ClusterFuture ...
[13:34:40.567] - result already collected: FutureResult
[13:34:40.567] result() for ClusterFuture ... done
[13:34:40.567] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:40.567] - nx: 2
[13:34:40.567] - relay: TRUE
[13:34:40.567] - stdout: TRUE
[13:34:40.567] - signal: TRUE
[13:34:40.567] - resignal: FALSE
[13:34:40.567] - force: TRUE
[13:34:40.567] - relayed: [n=2] FALSE, FALSE
[13:34:40.568] - queued futures: [n=2] FALSE, FALSE
[13:34:40.568]  - until=1
[13:34:40.568]  - relaying element #1
[13:34:40.568] result() for ClusterFuture ...
[13:34:40.568] - result already collected: FutureResult
[13:34:40.568] result() for ClusterFuture ... done
[13:34:40.568] result() for ClusterFuture ...
[13:34:40.568] - result already collected: FutureResult
[13:34:40.568] result() for ClusterFuture ... done
[13:34:40.568] result() for ClusterFuture ...
[13:34:40.568] - result already collected: FutureResult
[13:34:40.569] result() for ClusterFuture ... done
[13:34:40.569] result() for ClusterFuture ...
[13:34:40.569] - result already collected: FutureResult
[13:34:40.569] result() for ClusterFuture ... done
[13:34:40.569] - relayed: [n=2] TRUE, FALSE
[13:34:40.569] - queued futures: [n=2] TRUE, FALSE
[13:34:40.569] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:40.569]  length: 1 (resolved future 1)
[13:34:40.596] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.596] - Validating connection of MultisessionFuture
[13:34:40.596] - received message: FutureResult
[13:34:40.596] - Received FutureResult
[13:34:40.596] - Erased future from FutureRegistry
[13:34:40.596] result() for ClusterFuture ...
[13:34:40.596] - result already collected: FutureResult
[13:34:40.597] result() for ClusterFuture ... done
[13:34:40.597] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.597] Future #2
[13:34:40.597] result() for ClusterFuture ...
[13:34:40.597] - result already collected: FutureResult
[13:34:40.597] result() for ClusterFuture ... done
[13:34:40.597] result() for ClusterFuture ...
[13:34:40.597] - result already collected: FutureResult
[13:34:40.597] result() for ClusterFuture ... done
[13:34:40.597] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:40.597] - nx: 2
[13:34:40.598] - relay: TRUE
[13:34:40.598] - stdout: TRUE
[13:34:40.598] - signal: TRUE
[13:34:40.598] - resignal: FALSE
[13:34:40.598] - force: TRUE
[13:34:40.598] - relayed: [n=2] TRUE, FALSE
[13:34:40.598] - queued futures: [n=2] TRUE, FALSE
[13:34:40.598]  - until=2
[13:34:40.598]  - relaying element #2
[13:34:40.598] result() for ClusterFuture ...
[13:34:40.598] - result already collected: FutureResult
[13:34:40.599] result() for ClusterFuture ... done
[13:34:40.599] result() for ClusterFuture ...
[13:34:40.599] - result already collected: FutureResult
[13:34:40.599] result() for ClusterFuture ... done
[13:34:40.599] result() for ClusterFuture ...
[13:34:40.599] - result already collected: FutureResult
[13:34:40.599] result() for ClusterFuture ... done
[13:34:40.599] result() for ClusterFuture ...
[13:34:40.599] - result already collected: FutureResult
[13:34:40.599] result() for ClusterFuture ... done
[13:34:40.599] - relayed: [n=2] TRUE, TRUE
[13:34:40.599] - queued futures: [n=2] TRUE, TRUE
[13:34:40.600] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:40.600]  length: 0 (resolved future 2)
[13:34:40.600] Relaying remaining futures
[13:34:40.600] signalConditionsASAP(NULL, pos=0) ...
[13:34:40.600] - nx: 2
[13:34:40.600] - relay: TRUE
[13:34:40.600] - stdout: TRUE
[13:34:40.600] - signal: TRUE
[13:34:40.600] - resignal: FALSE
[13:34:40.600] - force: TRUE
[13:34:40.600] - relayed: [n=2] TRUE, TRUE
[13:34:40.600] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:40.601] - relayed: [n=2] TRUE, TRUE
[13:34:40.601] - queued futures: [n=2] TRUE, TRUE
[13:34:40.601] signalConditionsASAP(NULL, pos=0) ... done
[13:34:40.601] resolve() on list ... DONE
[13:34:40.601] result() for ClusterFuture ...
[13:34:40.601] - result already collected: FutureResult
[13:34:40.601] result() for ClusterFuture ... done
[13:34:40.601] result() for ClusterFuture ...
[13:34:40.601] - result already collected: FutureResult
[13:34:40.601] result() for ClusterFuture ... done
[13:34:40.601] result() for ClusterFuture ...
[13:34:40.602] - result already collected: FutureResult
[13:34:40.602] result() for ClusterFuture ... done
[13:34:40.602] result() for ClusterFuture ...
[13:34:40.602] - result already collected: FutureResult
[13:34:40.602] result() for ClusterFuture ... done
[13:34:40.602]  - Number of value chunks collected: 2
[13:34:40.602] Resolving 2 futures (chunks) ... DONE
[13:34:40.602] Reducing values from 2 chunks ...
[13:34:40.602]  - Number of values collected after concatenation: 4
[13:34:40.602]  - Number of values expected: 4
[13:34:40.602] Reducing values from 2 chunks ... DONE
[13:34:40.603] future_mapply() ... DONE
- Parallel RNG ...
[13:34:40.603] future_mapply() ...
[13:34:40.603] Generating random seeds ...
[13:34:40.603] Generating random seed streams for 4 elements ...
[13:34:40.603] Generating random seed streams for 4 elements ... DONE
[13:34:40.603] Generating random seeds ... DONE
[13:34:40.603] Will set RNG state on exit: 10407, -1781353469, 1862305738, 1165041331, 196216724, -686613661, -1838247543
[13:34:40.607] Number of chunks: 2
[13:34:40.607] getGlobalsAndPackagesXApply() ...
[13:34:40.607]  - future.globals: TRUE
[13:34:40.607] getGlobalsAndPackages() ...
[13:34:40.607] Searching for globals...
[13:34:40.608] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[13:34:40.608] Searching for globals ... DONE
[13:34:40.609] Resolving globals: FALSE
[13:34:40.609] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[13:34:40.609] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[13:34:40.609] - globals: [1] ‘FUN’
[13:34:40.610] - packages: [1] ‘stats’
[13:34:40.610] getGlobalsAndPackages() ... DONE
[13:34:40.610]  - globals found/used: [n=1] ‘FUN’
[13:34:40.610]  - needed namespaces: [n=1] ‘stats’
[13:34:40.610] Finding globals ... DONE
[13:34:40.610] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:40.610] List of 2
[13:34:40.610]  $ ...future.FUN:function (n, min = 0, max = 1)  
[13:34:40.610]  $ MoreArgs     :List of 1
[13:34:40.610]   ..$ min: num 1
[13:34:40.610]  - attr(*, "where")=List of 2
[13:34:40.610]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:40.610]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:40.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:40.610]  - attr(*, "resolved")= logi FALSE
[13:34:40.610]  - attr(*, "total_size")= num NA
[13:34:40.613] Packages to be attached in all futures: [n=1] ‘stats’
[13:34:40.613] getGlobalsAndPackagesXApply() ... DONE
[13:34:40.613] Number of futures (= number of chunks): 2
[13:34:40.613] Launching 2 futures (chunks) ...
[13:34:40.614] Chunk #1 of 2 ...
[13:34:40.614]  - Finding globals in '...' for chunk #1 ...
[13:34:40.614] getGlobalsAndPackages() ...
[13:34:40.614] Searching for globals...
[13:34:40.614] 
[13:34:40.614] Searching for globals ... DONE
[13:34:40.614] - globals: [0] <none>
[13:34:40.614] getGlobalsAndPackages() ... DONE
[13:34:40.615]    + additional globals found: [n=0] 
[13:34:40.615]    + additional namespaces needed: [n=0] 
[13:34:40.615]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:40.615]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.615]  - seeds: [2] <seeds>
[13:34:40.615]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.615] getGlobalsAndPackages() ...
[13:34:40.615] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.615] Resolving globals: FALSE
[13:34:40.616] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[13:34:40.616] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[13:34:40.616] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.617] - packages: [1] ‘stats’
[13:34:40.617] getGlobalsAndPackages() ... DONE
[13:34:40.617] run() for ‘Future’ ...
[13:34:40.617] - state: ‘created’
[13:34:40.617] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.630] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.631]   - Field: ‘node’
[13:34:40.631]   - Field: ‘label’
[13:34:40.631]   - Field: ‘local’
[13:34:40.631]   - Field: ‘owner’
[13:34:40.631]   - Field: ‘envir’
[13:34:40.631]   - Field: ‘workers’
[13:34:40.631]   - Field: ‘packages’
[13:34:40.631]   - Field: ‘gc’
[13:34:40.631]   - Field: ‘conditions’
[13:34:40.631]   - Field: ‘persistent’
[13:34:40.632]   - Field: ‘expr’
[13:34:40.632]   - Field: ‘uuid’
[13:34:40.632]   - Field: ‘seed’
[13:34:40.632]   - Field: ‘version’
[13:34:40.632]   - Field: ‘result’
[13:34:40.632]   - Field: ‘asynchronous’
[13:34:40.632]   - Field: ‘calls’
[13:34:40.632]   - Field: ‘globals’
[13:34:40.632]   - Field: ‘stdout’
[13:34:40.632]   - Field: ‘earlySignal’
[13:34:40.632]   - Field: ‘lazy’
[13:34:40.633]   - Field: ‘state’
[13:34:40.633] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.633] - Launch lazy future ...
[13:34:40.633] Packages needed by the future expression (n = 1): ‘stats’
[13:34:40.633] Packages needed by future strategies (n = 0): <none>
[13:34:40.634] {
[13:34:40.634]     {
[13:34:40.634]         {
[13:34:40.634]             ...future.startTime <- base::Sys.time()
[13:34:40.634]             {
[13:34:40.634]                 {
[13:34:40.634]                   {
[13:34:40.634]                     {
[13:34:40.634]                       {
[13:34:40.634]                         base::local({
[13:34:40.634]                           has_future <- base::requireNamespace("future", 
[13:34:40.634]                             quietly = TRUE)
[13:34:40.634]                           if (has_future) {
[13:34:40.634]                             ns <- base::getNamespace("future")
[13:34:40.634]                             version <- ns[[".package"]][["version"]]
[13:34:40.634]                             if (is.null(version)) 
[13:34:40.634]                               version <- utils::packageVersion("future")
[13:34:40.634]                           }
[13:34:40.634]                           else {
[13:34:40.634]                             version <- NULL
[13:34:40.634]                           }
[13:34:40.634]                           if (!has_future || version < "1.8.0") {
[13:34:40.634]                             info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.634]                               "", base::R.version$version.string), 
[13:34:40.634]                               platform = base::sprintf("%s (%s-bit)", 
[13:34:40.634]                                 base::R.version$platform, 8 * 
[13:34:40.634]                                   base::.Machine$sizeof.pointer), 
[13:34:40.634]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.634]                                 "release", "version")], collapse = " "), 
[13:34:40.634]                               hostname = base::Sys.info()[["nodename"]])
[13:34:40.634]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.634]                               info)
[13:34:40.634]                             info <- base::paste(info, collapse = "; ")
[13:34:40.634]                             if (!has_future) {
[13:34:40.634]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.634]                                 info)
[13:34:40.634]                             }
[13:34:40.634]                             else {
[13:34:40.634]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.634]                                 info, version)
[13:34:40.634]                             }
[13:34:40.634]                             base::stop(msg)
[13:34:40.634]                           }
[13:34:40.634]                         })
[13:34:40.634]                       }
[13:34:40.634]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.634]                       base::options(mc.cores = 1L)
[13:34:40.634]                     }
[13:34:40.634]                     base::local({
[13:34:40.634]                       for (pkg in "stats") {
[13:34:40.634]                         base::loadNamespace(pkg)
[13:34:40.634]                         base::library(pkg, character.only = TRUE)
[13:34:40.634]                       }
[13:34:40.634]                     })
[13:34:40.634]                   }
[13:34:40.634]                   ...future.strategy.old <- future::plan("list")
[13:34:40.634]                   options(future.plan = NULL)
[13:34:40.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.634]                 }
[13:34:40.634]                 ...future.workdir <- getwd()
[13:34:40.634]             }
[13:34:40.634]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.634]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.634]         }
[13:34:40.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.634]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.634]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.634]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.634]             base::names(...future.oldOptions))
[13:34:40.634]     }
[13:34:40.634]     if (FALSE) {
[13:34:40.634]     }
[13:34:40.634]     else {
[13:34:40.634]         if (TRUE) {
[13:34:40.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.634]                 open = "w")
[13:34:40.634]         }
[13:34:40.634]         else {
[13:34:40.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.634]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.634]         }
[13:34:40.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.634]             base::sink(type = "output", split = FALSE)
[13:34:40.634]             base::close(...future.stdout)
[13:34:40.634]         }, add = TRUE)
[13:34:40.634]     }
[13:34:40.634]     ...future.frame <- base::sys.nframe()
[13:34:40.634]     ...future.conditions <- base::list()
[13:34:40.634]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.634]     if (FALSE) {
[13:34:40.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.634]     }
[13:34:40.634]     ...future.result <- base::tryCatch({
[13:34:40.634]         base::withCallingHandlers({
[13:34:40.634]             ...future.value <- base::withVisible(base::local({
[13:34:40.634]                 ...future.makeSendCondition <- base::local({
[13:34:40.634]                   sendCondition <- NULL
[13:34:40.634]                   function(frame = 1L) {
[13:34:40.634]                     if (is.function(sendCondition)) 
[13:34:40.634]                       return(sendCondition)
[13:34:40.634]                     ns <- getNamespace("parallel")
[13:34:40.634]                     if (exists("sendData", mode = "function", 
[13:34:40.634]                       envir = ns)) {
[13:34:40.634]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.634]                         envir = ns)
[13:34:40.634]                       envir <- sys.frame(frame)
[13:34:40.634]                       master <- NULL
[13:34:40.634]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.634]                         !identical(envir, emptyenv())) {
[13:34:40.634]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.634]                           inherits = FALSE)) {
[13:34:40.634]                           master <- get("master", mode = "list", 
[13:34:40.634]                             envir = envir, inherits = FALSE)
[13:34:40.634]                           if (inherits(master, c("SOCKnode", 
[13:34:40.634]                             "SOCK0node"))) {
[13:34:40.634]                             sendCondition <<- function(cond) {
[13:34:40.634]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.634]                                 success = TRUE)
[13:34:40.634]                               parallel_sendData(master, data)
[13:34:40.634]                             }
[13:34:40.634]                             return(sendCondition)
[13:34:40.634]                           }
[13:34:40.634]                         }
[13:34:40.634]                         frame <- frame + 1L
[13:34:40.634]                         envir <- sys.frame(frame)
[13:34:40.634]                       }
[13:34:40.634]                     }
[13:34:40.634]                     sendCondition <<- function(cond) NULL
[13:34:40.634]                   }
[13:34:40.634]                 })
[13:34:40.634]                 withCallingHandlers({
[13:34:40.634]                   {
[13:34:40.634]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.634]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.634]                       ...future.globals.maxSize)) {
[13:34:40.634]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.634]                       on.exit(options(oopts), add = TRUE)
[13:34:40.634]                     }
[13:34:40.634]                     {
[13:34:40.634]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:40.634]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[13:34:40.634]                           envir = globalenv(), inherits = FALSE)
[13:34:40.634]                         ...future.FUN(...)
[13:34:40.634]                       }
[13:34:40.634]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:40.634]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:40.634]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.634]                         USE.NAMES = FALSE)
[13:34:40.634]                       do.call(mapply, args = args)
[13:34:40.634]                     }
[13:34:40.634]                   }
[13:34:40.634]                 }, immediateCondition = function(cond) {
[13:34:40.634]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.634]                   sendCondition(cond)
[13:34:40.634]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.634]                   {
[13:34:40.634]                     inherits <- base::inherits
[13:34:40.634]                     invokeRestart <- base::invokeRestart
[13:34:40.634]                     is.null <- base::is.null
[13:34:40.634]                     muffled <- FALSE
[13:34:40.634]                     if (inherits(cond, "message")) {
[13:34:40.634]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.634]                       if (muffled) 
[13:34:40.634]                         invokeRestart("muffleMessage")
[13:34:40.634]                     }
[13:34:40.634]                     else if (inherits(cond, "warning")) {
[13:34:40.634]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.634]                       if (muffled) 
[13:34:40.634]                         invokeRestart("muffleWarning")
[13:34:40.634]                     }
[13:34:40.634]                     else if (inherits(cond, "condition")) {
[13:34:40.634]                       if (!is.null(pattern)) {
[13:34:40.634]                         computeRestarts <- base::computeRestarts
[13:34:40.634]                         grepl <- base::grepl
[13:34:40.634]                         restarts <- computeRestarts(cond)
[13:34:40.634]                         for (restart in restarts) {
[13:34:40.634]                           name <- restart$name
[13:34:40.634]                           if (is.null(name)) 
[13:34:40.634]                             next
[13:34:40.634]                           if (!grepl(pattern, name)) 
[13:34:40.634]                             next
[13:34:40.634]                           invokeRestart(restart)
[13:34:40.634]                           muffled <- TRUE
[13:34:40.634]                           break
[13:34:40.634]                         }
[13:34:40.634]                       }
[13:34:40.634]                     }
[13:34:40.634]                     invisible(muffled)
[13:34:40.634]                   }
[13:34:40.634]                   muffleCondition(cond)
[13:34:40.634]                 })
[13:34:40.634]             }))
[13:34:40.634]             future::FutureResult(value = ...future.value$value, 
[13:34:40.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.634]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.634]                     ...future.globalenv.names))
[13:34:40.634]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.634]         }, condition = base::local({
[13:34:40.634]             c <- base::c
[13:34:40.634]             inherits <- base::inherits
[13:34:40.634]             invokeRestart <- base::invokeRestart
[13:34:40.634]             length <- base::length
[13:34:40.634]             list <- base::list
[13:34:40.634]             seq.int <- base::seq.int
[13:34:40.634]             signalCondition <- base::signalCondition
[13:34:40.634]             sys.calls <- base::sys.calls
[13:34:40.634]             `[[` <- base::`[[`
[13:34:40.634]             `+` <- base::`+`
[13:34:40.634]             `<<-` <- base::`<<-`
[13:34:40.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.634]                   3L)]
[13:34:40.634]             }
[13:34:40.634]             function(cond) {
[13:34:40.634]                 is_error <- inherits(cond, "error")
[13:34:40.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.634]                   NULL)
[13:34:40.634]                 if (is_error) {
[13:34:40.634]                   sessionInformation <- function() {
[13:34:40.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.634]                       search = base::search(), system = base::Sys.info())
[13:34:40.634]                   }
[13:34:40.634]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.634]                     cond$call), session = sessionInformation(), 
[13:34:40.634]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.634]                   signalCondition(cond)
[13:34:40.634]                 }
[13:34:40.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.634]                 "immediateCondition"))) {
[13:34:40.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.634]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.634]                   if (TRUE && !signal) {
[13:34:40.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.634]                     {
[13:34:40.634]                       inherits <- base::inherits
[13:34:40.634]                       invokeRestart <- base::invokeRestart
[13:34:40.634]                       is.null <- base::is.null
[13:34:40.634]                       muffled <- FALSE
[13:34:40.634]                       if (inherits(cond, "message")) {
[13:34:40.634]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.634]                         if (muffled) 
[13:34:40.634]                           invokeRestart("muffleMessage")
[13:34:40.634]                       }
[13:34:40.634]                       else if (inherits(cond, "warning")) {
[13:34:40.634]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.634]                         if (muffled) 
[13:34:40.634]                           invokeRestart("muffleWarning")
[13:34:40.634]                       }
[13:34:40.634]                       else if (inherits(cond, "condition")) {
[13:34:40.634]                         if (!is.null(pattern)) {
[13:34:40.634]                           computeRestarts <- base::computeRestarts
[13:34:40.634]                           grepl <- base::grepl
[13:34:40.634]                           restarts <- computeRestarts(cond)
[13:34:40.634]                           for (restart in restarts) {
[13:34:40.634]                             name <- restart$name
[13:34:40.634]                             if (is.null(name)) 
[13:34:40.634]                               next
[13:34:40.634]                             if (!grepl(pattern, name)) 
[13:34:40.634]                               next
[13:34:40.634]                             invokeRestart(restart)
[13:34:40.634]                             muffled <- TRUE
[13:34:40.634]                             break
[13:34:40.634]                           }
[13:34:40.634]                         }
[13:34:40.634]                       }
[13:34:40.634]                       invisible(muffled)
[13:34:40.634]                     }
[13:34:40.634]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.634]                   }
[13:34:40.634]                 }
[13:34:40.634]                 else {
[13:34:40.634]                   if (TRUE) {
[13:34:40.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.634]                     {
[13:34:40.634]                       inherits <- base::inherits
[13:34:40.634]                       invokeRestart <- base::invokeRestart
[13:34:40.634]                       is.null <- base::is.null
[13:34:40.634]                       muffled <- FALSE
[13:34:40.634]                       if (inherits(cond, "message")) {
[13:34:40.634]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.634]                         if (muffled) 
[13:34:40.634]                           invokeRestart("muffleMessage")
[13:34:40.634]                       }
[13:34:40.634]                       else if (inherits(cond, "warning")) {
[13:34:40.634]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.634]                         if (muffled) 
[13:34:40.634]                           invokeRestart("muffleWarning")
[13:34:40.634]                       }
[13:34:40.634]                       else if (inherits(cond, "condition")) {
[13:34:40.634]                         if (!is.null(pattern)) {
[13:34:40.634]                           computeRestarts <- base::computeRestarts
[13:34:40.634]                           grepl <- base::grepl
[13:34:40.634]                           restarts <- computeRestarts(cond)
[13:34:40.634]                           for (restart in restarts) {
[13:34:40.634]                             name <- restart$name
[13:34:40.634]                             if (is.null(name)) 
[13:34:40.634]                               next
[13:34:40.634]                             if (!grepl(pattern, name)) 
[13:34:40.634]                               next
[13:34:40.634]                             invokeRestart(restart)
[13:34:40.634]                             muffled <- TRUE
[13:34:40.634]                             break
[13:34:40.634]                           }
[13:34:40.634]                         }
[13:34:40.634]                       }
[13:34:40.634]                       invisible(muffled)
[13:34:40.634]                     }
[13:34:40.634]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.634]                   }
[13:34:40.634]                 }
[13:34:40.634]             }
[13:34:40.634]         }))
[13:34:40.634]     }, error = function(ex) {
[13:34:40.634]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.634]                 ...future.rng), started = ...future.startTime, 
[13:34:40.634]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.634]             version = "1.8"), class = "FutureResult")
[13:34:40.634]     }, finally = {
[13:34:40.634]         if (!identical(...future.workdir, getwd())) 
[13:34:40.634]             setwd(...future.workdir)
[13:34:40.634]         {
[13:34:40.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.634]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.634]             }
[13:34:40.634]             base::options(...future.oldOptions)
[13:34:40.634]             if (.Platform$OS.type == "windows") {
[13:34:40.634]                 old_names <- names(...future.oldEnvVars)
[13:34:40.634]                 envs <- base::Sys.getenv()
[13:34:40.634]                 names <- names(envs)
[13:34:40.634]                 common <- intersect(names, old_names)
[13:34:40.634]                 added <- setdiff(names, old_names)
[13:34:40.634]                 removed <- setdiff(old_names, names)
[13:34:40.634]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.634]                   envs[common]]
[13:34:40.634]                 NAMES <- toupper(changed)
[13:34:40.634]                 args <- list()
[13:34:40.634]                 for (kk in seq_along(NAMES)) {
[13:34:40.634]                   name <- changed[[kk]]
[13:34:40.634]                   NAME <- NAMES[[kk]]
[13:34:40.634]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.634]                     next
[13:34:40.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.634]                 }
[13:34:40.634]                 NAMES <- toupper(added)
[13:34:40.634]                 for (kk in seq_along(NAMES)) {
[13:34:40.634]                   name <- added[[kk]]
[13:34:40.634]                   NAME <- NAMES[[kk]]
[13:34:40.634]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.634]                     next
[13:34:40.634]                   args[[name]] <- ""
[13:34:40.634]                 }
[13:34:40.634]                 NAMES <- toupper(removed)
[13:34:40.634]                 for (kk in seq_along(NAMES)) {
[13:34:40.634]                   name <- removed[[kk]]
[13:34:40.634]                   NAME <- NAMES[[kk]]
[13:34:40.634]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.634]                     next
[13:34:40.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.634]                 }
[13:34:40.634]                 if (length(args) > 0) 
[13:34:40.634]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.634]             }
[13:34:40.634]             else {
[13:34:40.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.634]             }
[13:34:40.634]             {
[13:34:40.634]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.634]                   0L) {
[13:34:40.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.634]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.634]                   base::options(opts)
[13:34:40.634]                 }
[13:34:40.634]                 {
[13:34:40.634]                   {
[13:34:40.634]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.634]                     NULL
[13:34:40.634]                   }
[13:34:40.634]                   options(future.plan = NULL)
[13:34:40.634]                   if (is.na(NA_character_)) 
[13:34:40.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.634]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.634]                     .init = FALSE)
[13:34:40.634]                 }
[13:34:40.634]             }
[13:34:40.634]         }
[13:34:40.634]     })
[13:34:40.634]     if (TRUE) {
[13:34:40.634]         base::sink(type = "output", split = FALSE)
[13:34:40.634]         if (TRUE) {
[13:34:40.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.634]         }
[13:34:40.634]         else {
[13:34:40.634]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.634]         }
[13:34:40.634]         base::close(...future.stdout)
[13:34:40.634]         ...future.stdout <- NULL
[13:34:40.634]     }
[13:34:40.634]     ...future.result$conditions <- ...future.conditions
[13:34:40.634]     ...future.result$finished <- base::Sys.time()
[13:34:40.634]     ...future.result
[13:34:40.634] }
[13:34:40.636] Exporting 5 global objects (2.47 KiB) to cluster node #1 ...
[13:34:40.636] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ...
[13:34:40.637] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ... DONE
[13:34:40.637] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[13:34:40.637] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[13:34:40.637] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[13:34:40.638] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[13:34:40.638] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ...
[13:34:40.638] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ... DONE
[13:34:40.638] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:40.638] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.639] Exporting 5 global objects (2.47 KiB) to cluster node #1 ... DONE
[13:34:40.639] MultisessionFuture started
[13:34:40.639] - Launch lazy future ... done
[13:34:40.639] run() for ‘MultisessionFuture’ ... done
[13:34:40.639] Created future:
[13:34:40.639] MultisessionFuture:
[13:34:40.639] Label: ‘future_mapply-1’
[13:34:40.639] Expression:
[13:34:40.639] {
[13:34:40.639]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.639]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.639]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.639]         on.exit(options(oopts), add = TRUE)
[13:34:40.639]     }
[13:34:40.639]     {
[13:34:40.639]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:40.639]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[13:34:40.639]                 inherits = FALSE)
[13:34:40.639]             ...future.FUN(...)
[13:34:40.639]         }
[13:34:40.639]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:40.639]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:40.639]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.639]         do.call(mapply, args = args)
[13:34:40.639]     }
[13:34:40.639] }
[13:34:40.639] Lazy evaluation: FALSE
[13:34:40.639] Asynchronous evaluation: TRUE
[13:34:40.639] Local evaluation: TRUE
[13:34:40.639] Environment: R_GlobalEnv
[13:34:40.639] Capture standard output: TRUE
[13:34:40.639] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.639] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.639] Packages: 1 packages (‘stats’)
[13:34:40.639] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:34:40.639] Resolved: FALSE
[13:34:40.639] Value: <not collected>
[13:34:40.639] Conditions captured: <none>
[13:34:40.639] Early signaling: FALSE
[13:34:40.639] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.639] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.651] Chunk #1 of 2 ... DONE
[13:34:40.651] Chunk #2 of 2 ...
[13:34:40.651]  - Finding globals in '...' for chunk #2 ...
[13:34:40.651] getGlobalsAndPackages() ...
[13:34:40.651] Searching for globals...
[13:34:40.651] 
[13:34:40.652] Searching for globals ... DONE
[13:34:40.652] - globals: [0] <none>
[13:34:40.652] getGlobalsAndPackages() ... DONE
[13:34:40.652]    + additional globals found: [n=0] 
[13:34:40.652]    + additional namespaces needed: [n=0] 
[13:34:40.652]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:40.652]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.652]  - seeds: [2] <seeds>
[13:34:40.652]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.652] getGlobalsAndPackages() ...
[13:34:40.653] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.653] Resolving globals: FALSE
[13:34:40.653] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[13:34:40.654] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[13:34:40.654] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.654] - packages: [1] ‘stats’
[13:34:40.654] getGlobalsAndPackages() ... DONE
[13:34:40.654] run() for ‘Future’ ...
[13:34:40.654] - state: ‘created’
[13:34:40.654] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.668] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.668] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.668]   - Field: ‘node’
[13:34:40.668]   - Field: ‘label’
[13:34:40.668]   - Field: ‘local’
[13:34:40.668]   - Field: ‘owner’
[13:34:40.668]   - Field: ‘envir’
[13:34:40.668]   - Field: ‘workers’
[13:34:40.669]   - Field: ‘packages’
[13:34:40.669]   - Field: ‘gc’
[13:34:40.669]   - Field: ‘conditions’
[13:34:40.669]   - Field: ‘persistent’
[13:34:40.669]   - Field: ‘expr’
[13:34:40.669]   - Field: ‘uuid’
[13:34:40.669]   - Field: ‘seed’
[13:34:40.669]   - Field: ‘version’
[13:34:40.669]   - Field: ‘result’
[13:34:40.669]   - Field: ‘asynchronous’
[13:34:40.669]   - Field: ‘calls’
[13:34:40.670]   - Field: ‘globals’
[13:34:40.670]   - Field: ‘stdout’
[13:34:40.670]   - Field: ‘earlySignal’
[13:34:40.670]   - Field: ‘lazy’
[13:34:40.670]   - Field: ‘state’
[13:34:40.670] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.670] - Launch lazy future ...
[13:34:40.670] Packages needed by the future expression (n = 1): ‘stats’
[13:34:40.670] Packages needed by future strategies (n = 0): <none>
[13:34:40.671] {
[13:34:40.671]     {
[13:34:40.671]         {
[13:34:40.671]             ...future.startTime <- base::Sys.time()
[13:34:40.671]             {
[13:34:40.671]                 {
[13:34:40.671]                   {
[13:34:40.671]                     {
[13:34:40.671]                       {
[13:34:40.671]                         base::local({
[13:34:40.671]                           has_future <- base::requireNamespace("future", 
[13:34:40.671]                             quietly = TRUE)
[13:34:40.671]                           if (has_future) {
[13:34:40.671]                             ns <- base::getNamespace("future")
[13:34:40.671]                             version <- ns[[".package"]][["version"]]
[13:34:40.671]                             if (is.null(version)) 
[13:34:40.671]                               version <- utils::packageVersion("future")
[13:34:40.671]                           }
[13:34:40.671]                           else {
[13:34:40.671]                             version <- NULL
[13:34:40.671]                           }
[13:34:40.671]                           if (!has_future || version < "1.8.0") {
[13:34:40.671]                             info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.671]                               "", base::R.version$version.string), 
[13:34:40.671]                               platform = base::sprintf("%s (%s-bit)", 
[13:34:40.671]                                 base::R.version$platform, 8 * 
[13:34:40.671]                                   base::.Machine$sizeof.pointer), 
[13:34:40.671]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.671]                                 "release", "version")], collapse = " "), 
[13:34:40.671]                               hostname = base::Sys.info()[["nodename"]])
[13:34:40.671]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.671]                               info)
[13:34:40.671]                             info <- base::paste(info, collapse = "; ")
[13:34:40.671]                             if (!has_future) {
[13:34:40.671]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.671]                                 info)
[13:34:40.671]                             }
[13:34:40.671]                             else {
[13:34:40.671]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.671]                                 info, version)
[13:34:40.671]                             }
[13:34:40.671]                             base::stop(msg)
[13:34:40.671]                           }
[13:34:40.671]                         })
[13:34:40.671]                       }
[13:34:40.671]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.671]                       base::options(mc.cores = 1L)
[13:34:40.671]                     }
[13:34:40.671]                     base::local({
[13:34:40.671]                       for (pkg in "stats") {
[13:34:40.671]                         base::loadNamespace(pkg)
[13:34:40.671]                         base::library(pkg, character.only = TRUE)
[13:34:40.671]                       }
[13:34:40.671]                     })
[13:34:40.671]                   }
[13:34:40.671]                   ...future.strategy.old <- future::plan("list")
[13:34:40.671]                   options(future.plan = NULL)
[13:34:40.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.671]                 }
[13:34:40.671]                 ...future.workdir <- getwd()
[13:34:40.671]             }
[13:34:40.671]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.671]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.671]         }
[13:34:40.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.671]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.671]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.671]             base::names(...future.oldOptions))
[13:34:40.671]     }
[13:34:40.671]     if (FALSE) {
[13:34:40.671]     }
[13:34:40.671]     else {
[13:34:40.671]         if (TRUE) {
[13:34:40.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.671]                 open = "w")
[13:34:40.671]         }
[13:34:40.671]         else {
[13:34:40.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.671]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.671]         }
[13:34:40.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.671]             base::sink(type = "output", split = FALSE)
[13:34:40.671]             base::close(...future.stdout)
[13:34:40.671]         }, add = TRUE)
[13:34:40.671]     }
[13:34:40.671]     ...future.frame <- base::sys.nframe()
[13:34:40.671]     ...future.conditions <- base::list()
[13:34:40.671]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.671]     if (FALSE) {
[13:34:40.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.671]     }
[13:34:40.671]     ...future.result <- base::tryCatch({
[13:34:40.671]         base::withCallingHandlers({
[13:34:40.671]             ...future.value <- base::withVisible(base::local({
[13:34:40.671]                 ...future.makeSendCondition <- base::local({
[13:34:40.671]                   sendCondition <- NULL
[13:34:40.671]                   function(frame = 1L) {
[13:34:40.671]                     if (is.function(sendCondition)) 
[13:34:40.671]                       return(sendCondition)
[13:34:40.671]                     ns <- getNamespace("parallel")
[13:34:40.671]                     if (exists("sendData", mode = "function", 
[13:34:40.671]                       envir = ns)) {
[13:34:40.671]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.671]                         envir = ns)
[13:34:40.671]                       envir <- sys.frame(frame)
[13:34:40.671]                       master <- NULL
[13:34:40.671]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.671]                         !identical(envir, emptyenv())) {
[13:34:40.671]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.671]                           inherits = FALSE)) {
[13:34:40.671]                           master <- get("master", mode = "list", 
[13:34:40.671]                             envir = envir, inherits = FALSE)
[13:34:40.671]                           if (inherits(master, c("SOCKnode", 
[13:34:40.671]                             "SOCK0node"))) {
[13:34:40.671]                             sendCondition <<- function(cond) {
[13:34:40.671]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.671]                                 success = TRUE)
[13:34:40.671]                               parallel_sendData(master, data)
[13:34:40.671]                             }
[13:34:40.671]                             return(sendCondition)
[13:34:40.671]                           }
[13:34:40.671]                         }
[13:34:40.671]                         frame <- frame + 1L
[13:34:40.671]                         envir <- sys.frame(frame)
[13:34:40.671]                       }
[13:34:40.671]                     }
[13:34:40.671]                     sendCondition <<- function(cond) NULL
[13:34:40.671]                   }
[13:34:40.671]                 })
[13:34:40.671]                 withCallingHandlers({
[13:34:40.671]                   {
[13:34:40.671]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.671]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.671]                       ...future.globals.maxSize)) {
[13:34:40.671]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.671]                       on.exit(options(oopts), add = TRUE)
[13:34:40.671]                     }
[13:34:40.671]                     {
[13:34:40.671]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:40.671]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[13:34:40.671]                           envir = globalenv(), inherits = FALSE)
[13:34:40.671]                         ...future.FUN(...)
[13:34:40.671]                       }
[13:34:40.671]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:40.671]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:40.671]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.671]                         USE.NAMES = FALSE)
[13:34:40.671]                       do.call(mapply, args = args)
[13:34:40.671]                     }
[13:34:40.671]                   }
[13:34:40.671]                 }, immediateCondition = function(cond) {
[13:34:40.671]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.671]                   sendCondition(cond)
[13:34:40.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.671]                   {
[13:34:40.671]                     inherits <- base::inherits
[13:34:40.671]                     invokeRestart <- base::invokeRestart
[13:34:40.671]                     is.null <- base::is.null
[13:34:40.671]                     muffled <- FALSE
[13:34:40.671]                     if (inherits(cond, "message")) {
[13:34:40.671]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.671]                       if (muffled) 
[13:34:40.671]                         invokeRestart("muffleMessage")
[13:34:40.671]                     }
[13:34:40.671]                     else if (inherits(cond, "warning")) {
[13:34:40.671]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.671]                       if (muffled) 
[13:34:40.671]                         invokeRestart("muffleWarning")
[13:34:40.671]                     }
[13:34:40.671]                     else if (inherits(cond, "condition")) {
[13:34:40.671]                       if (!is.null(pattern)) {
[13:34:40.671]                         computeRestarts <- base::computeRestarts
[13:34:40.671]                         grepl <- base::grepl
[13:34:40.671]                         restarts <- computeRestarts(cond)
[13:34:40.671]                         for (restart in restarts) {
[13:34:40.671]                           name <- restart$name
[13:34:40.671]                           if (is.null(name)) 
[13:34:40.671]                             next
[13:34:40.671]                           if (!grepl(pattern, name)) 
[13:34:40.671]                             next
[13:34:40.671]                           invokeRestart(restart)
[13:34:40.671]                           muffled <- TRUE
[13:34:40.671]                           break
[13:34:40.671]                         }
[13:34:40.671]                       }
[13:34:40.671]                     }
[13:34:40.671]                     invisible(muffled)
[13:34:40.671]                   }
[13:34:40.671]                   muffleCondition(cond)
[13:34:40.671]                 })
[13:34:40.671]             }))
[13:34:40.671]             future::FutureResult(value = ...future.value$value, 
[13:34:40.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.671]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.671]                     ...future.globalenv.names))
[13:34:40.671]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.671]         }, condition = base::local({
[13:34:40.671]             c <- base::c
[13:34:40.671]             inherits <- base::inherits
[13:34:40.671]             invokeRestart <- base::invokeRestart
[13:34:40.671]             length <- base::length
[13:34:40.671]             list <- base::list
[13:34:40.671]             seq.int <- base::seq.int
[13:34:40.671]             signalCondition <- base::signalCondition
[13:34:40.671]             sys.calls <- base::sys.calls
[13:34:40.671]             `[[` <- base::`[[`
[13:34:40.671]             `+` <- base::`+`
[13:34:40.671]             `<<-` <- base::`<<-`
[13:34:40.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.671]                   3L)]
[13:34:40.671]             }
[13:34:40.671]             function(cond) {
[13:34:40.671]                 is_error <- inherits(cond, "error")
[13:34:40.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.671]                   NULL)
[13:34:40.671]                 if (is_error) {
[13:34:40.671]                   sessionInformation <- function() {
[13:34:40.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.671]                       search = base::search(), system = base::Sys.info())
[13:34:40.671]                   }
[13:34:40.671]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.671]                     cond$call), session = sessionInformation(), 
[13:34:40.671]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.671]                   signalCondition(cond)
[13:34:40.671]                 }
[13:34:40.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.671]                 "immediateCondition"))) {
[13:34:40.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.671]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.671]                   if (TRUE && !signal) {
[13:34:40.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.671]                     {
[13:34:40.671]                       inherits <- base::inherits
[13:34:40.671]                       invokeRestart <- base::invokeRestart
[13:34:40.671]                       is.null <- base::is.null
[13:34:40.671]                       muffled <- FALSE
[13:34:40.671]                       if (inherits(cond, "message")) {
[13:34:40.671]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.671]                         if (muffled) 
[13:34:40.671]                           invokeRestart("muffleMessage")
[13:34:40.671]                       }
[13:34:40.671]                       else if (inherits(cond, "warning")) {
[13:34:40.671]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.671]                         if (muffled) 
[13:34:40.671]                           invokeRestart("muffleWarning")
[13:34:40.671]                       }
[13:34:40.671]                       else if (inherits(cond, "condition")) {
[13:34:40.671]                         if (!is.null(pattern)) {
[13:34:40.671]                           computeRestarts <- base::computeRestarts
[13:34:40.671]                           grepl <- base::grepl
[13:34:40.671]                           restarts <- computeRestarts(cond)
[13:34:40.671]                           for (restart in restarts) {
[13:34:40.671]                             name <- restart$name
[13:34:40.671]                             if (is.null(name)) 
[13:34:40.671]                               next
[13:34:40.671]                             if (!grepl(pattern, name)) 
[13:34:40.671]                               next
[13:34:40.671]                             invokeRestart(restart)
[13:34:40.671]                             muffled <- TRUE
[13:34:40.671]                             break
[13:34:40.671]                           }
[13:34:40.671]                         }
[13:34:40.671]                       }
[13:34:40.671]                       invisible(muffled)
[13:34:40.671]                     }
[13:34:40.671]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.671]                   }
[13:34:40.671]                 }
[13:34:40.671]                 else {
[13:34:40.671]                   if (TRUE) {
[13:34:40.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.671]                     {
[13:34:40.671]                       inherits <- base::inherits
[13:34:40.671]                       invokeRestart <- base::invokeRestart
[13:34:40.671]                       is.null <- base::is.null
[13:34:40.671]                       muffled <- FALSE
[13:34:40.671]                       if (inherits(cond, "message")) {
[13:34:40.671]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.671]                         if (muffled) 
[13:34:40.671]                           invokeRestart("muffleMessage")
[13:34:40.671]                       }
[13:34:40.671]                       else if (inherits(cond, "warning")) {
[13:34:40.671]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.671]                         if (muffled) 
[13:34:40.671]                           invokeRestart("muffleWarning")
[13:34:40.671]                       }
[13:34:40.671]                       else if (inherits(cond, "condition")) {
[13:34:40.671]                         if (!is.null(pattern)) {
[13:34:40.671]                           computeRestarts <- base::computeRestarts
[13:34:40.671]                           grepl <- base::grepl
[13:34:40.671]                           restarts <- computeRestarts(cond)
[13:34:40.671]                           for (restart in restarts) {
[13:34:40.671]                             name <- restart$name
[13:34:40.671]                             if (is.null(name)) 
[13:34:40.671]                               next
[13:34:40.671]                             if (!grepl(pattern, name)) 
[13:34:40.671]                               next
[13:34:40.671]                             invokeRestart(restart)
[13:34:40.671]                             muffled <- TRUE
[13:34:40.671]                             break
[13:34:40.671]                           }
[13:34:40.671]                         }
[13:34:40.671]                       }
[13:34:40.671]                       invisible(muffled)
[13:34:40.671]                     }
[13:34:40.671]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.671]                   }
[13:34:40.671]                 }
[13:34:40.671]             }
[13:34:40.671]         }))
[13:34:40.671]     }, error = function(ex) {
[13:34:40.671]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.671]                 ...future.rng), started = ...future.startTime, 
[13:34:40.671]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.671]             version = "1.8"), class = "FutureResult")
[13:34:40.671]     }, finally = {
[13:34:40.671]         if (!identical(...future.workdir, getwd())) 
[13:34:40.671]             setwd(...future.workdir)
[13:34:40.671]         {
[13:34:40.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.671]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.671]             }
[13:34:40.671]             base::options(...future.oldOptions)
[13:34:40.671]             if (.Platform$OS.type == "windows") {
[13:34:40.671]                 old_names <- names(...future.oldEnvVars)
[13:34:40.671]                 envs <- base::Sys.getenv()
[13:34:40.671]                 names <- names(envs)
[13:34:40.671]                 common <- intersect(names, old_names)
[13:34:40.671]                 added <- setdiff(names, old_names)
[13:34:40.671]                 removed <- setdiff(old_names, names)
[13:34:40.671]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.671]                   envs[common]]
[13:34:40.671]                 NAMES <- toupper(changed)
[13:34:40.671]                 args <- list()
[13:34:40.671]                 for (kk in seq_along(NAMES)) {
[13:34:40.671]                   name <- changed[[kk]]
[13:34:40.671]                   NAME <- NAMES[[kk]]
[13:34:40.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.671]                     next
[13:34:40.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.671]                 }
[13:34:40.671]                 NAMES <- toupper(added)
[13:34:40.671]                 for (kk in seq_along(NAMES)) {
[13:34:40.671]                   name <- added[[kk]]
[13:34:40.671]                   NAME <- NAMES[[kk]]
[13:34:40.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.671]                     next
[13:34:40.671]                   args[[name]] <- ""
[13:34:40.671]                 }
[13:34:40.671]                 NAMES <- toupper(removed)
[13:34:40.671]                 for (kk in seq_along(NAMES)) {
[13:34:40.671]                   name <- removed[[kk]]
[13:34:40.671]                   NAME <- NAMES[[kk]]
[13:34:40.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.671]                     next
[13:34:40.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.671]                 }
[13:34:40.671]                 if (length(args) > 0) 
[13:34:40.671]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.671]             }
[13:34:40.671]             else {
[13:34:40.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.671]             }
[13:34:40.671]             {
[13:34:40.671]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.671]                   0L) {
[13:34:40.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.671]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.671]                   base::options(opts)
[13:34:40.671]                 }
[13:34:40.671]                 {
[13:34:40.671]                   {
[13:34:40.671]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.671]                     NULL
[13:34:40.671]                   }
[13:34:40.671]                   options(future.plan = NULL)
[13:34:40.671]                   if (is.na(NA_character_)) 
[13:34:40.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.671]                     .init = FALSE)
[13:34:40.671]                 }
[13:34:40.671]             }
[13:34:40.671]         }
[13:34:40.671]     })
[13:34:40.671]     if (TRUE) {
[13:34:40.671]         base::sink(type = "output", split = FALSE)
[13:34:40.671]         if (TRUE) {
[13:34:40.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.671]         }
[13:34:40.671]         else {
[13:34:40.671]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.671]         }
[13:34:40.671]         base::close(...future.stdout)
[13:34:40.671]         ...future.stdout <- NULL
[13:34:40.671]     }
[13:34:40.671]     ...future.result$conditions <- ...future.conditions
[13:34:40.671]     ...future.result$finished <- base::Sys.time()
[13:34:40.671]     ...future.result
[13:34:40.671] }
[13:34:40.674] Exporting 5 global objects (2.47 KiB) to cluster node #2 ...
[13:34:40.674] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ...
[13:34:40.674] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ... DONE
[13:34:40.674] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[13:34:40.675] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[13:34:40.675] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[13:34:40.675] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[13:34:40.675] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ...
[13:34:40.676] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ... DONE
[13:34:40.676] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:40.676] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.676] Exporting 5 global objects (2.47 KiB) to cluster node #2 ... DONE
[13:34:40.677] MultisessionFuture started
[13:34:40.677] - Launch lazy future ... done
[13:34:40.677] run() for ‘MultisessionFuture’ ... done
[13:34:40.677] Created future:
[13:34:40.677] MultisessionFuture:
[13:34:40.677] Label: ‘future_mapply-2’
[13:34:40.677] Expression:
[13:34:40.677] {
[13:34:40.677]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.677]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.677]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.677]         on.exit(options(oopts), add = TRUE)
[13:34:40.677]     }
[13:34:40.677]     {
[13:34:40.677]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[13:34:40.677]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[13:34:40.677]                 inherits = FALSE)
[13:34:40.677]             ...future.FUN(...)
[13:34:40.677]         }
[13:34:40.677]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[13:34:40.677]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[13:34:40.677]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.677]         do.call(mapply, args = args)
[13:34:40.677]     }
[13:34:40.677] }
[13:34:40.677] Lazy evaluation: FALSE
[13:34:40.677] Asynchronous evaluation: TRUE
[13:34:40.677] Local evaluation: TRUE
[13:34:40.677] Environment: R_GlobalEnv
[13:34:40.677] Capture standard output: TRUE
[13:34:40.677] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.677] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.677] Packages: 1 packages (‘stats’)
[13:34:40.677] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:34:40.677] Resolved: FALSE
[13:34:40.677] Value: <not collected>
[13:34:40.677] Conditions captured: <none>
[13:34:40.677] Early signaling: FALSE
[13:34:40.677] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.677] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.688] Chunk #2 of 2 ... DONE
[13:34:40.689] Launching 2 futures (chunks) ... DONE
[13:34:40.692] Resolving 2 futures (chunks) ...
[13:34:40.692] resolve() on list ...
[13:34:40.692]  recursive: 0
[13:34:40.692]  length: 2
[13:34:40.692] 
[13:34:40.692] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.693] - Validating connection of MultisessionFuture
[13:34:40.693] - received message: FutureResult
[13:34:40.693] - Received FutureResult
[13:34:40.693] - Erased future from FutureRegistry
[13:34:40.693] result() for ClusterFuture ...
[13:34:40.693] - result already collected: FutureResult
[13:34:40.693] result() for ClusterFuture ... done
[13:34:40.693] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.693] Future #1
[13:34:40.693] result() for ClusterFuture ...
[13:34:40.694] - result already collected: FutureResult
[13:34:40.694] result() for ClusterFuture ... done
[13:34:40.694] result() for ClusterFuture ...
[13:34:40.694] - result already collected: FutureResult
[13:34:40.694] result() for ClusterFuture ... done
[13:34:40.694] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:40.694] - nx: 2
[13:34:40.694] - relay: TRUE
[13:34:40.694] - stdout: TRUE
[13:34:40.694] - signal: TRUE
[13:34:40.694] - resignal: FALSE
[13:34:40.695] - force: TRUE
[13:34:40.695] - relayed: [n=2] FALSE, FALSE
[13:34:40.695] - queued futures: [n=2] FALSE, FALSE
[13:34:40.695]  - until=1
[13:34:40.695]  - relaying element #1
[13:34:40.695] result() for ClusterFuture ...
[13:34:40.695] - result already collected: FutureResult
[13:34:40.695] result() for ClusterFuture ... done
[13:34:40.695] result() for ClusterFuture ...
[13:34:40.695] - result already collected: FutureResult
[13:34:40.695] result() for ClusterFuture ... done
[13:34:40.695] result() for ClusterFuture ...
[13:34:40.696] - result already collected: FutureResult
[13:34:40.696] result() for ClusterFuture ... done
[13:34:40.696] result() for ClusterFuture ...
[13:34:40.696] - result already collected: FutureResult
[13:34:40.696] result() for ClusterFuture ... done
[13:34:40.696] - relayed: [n=2] TRUE, FALSE
[13:34:40.696] - queued futures: [n=2] TRUE, FALSE
[13:34:40.696] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:40.696]  length: 1 (resolved future 1)
[13:34:40.720] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.720] - Validating connection of MultisessionFuture
[13:34:40.720] - received message: FutureResult
[13:34:40.720] - Received FutureResult
[13:34:40.720] - Erased future from FutureRegistry
[13:34:40.721] result() for ClusterFuture ...
[13:34:40.721] - result already collected: FutureResult
[13:34:40.721] result() for ClusterFuture ... done
[13:34:40.721] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.721] Future #2
[13:34:40.721] result() for ClusterFuture ...
[13:34:40.721] - result already collected: FutureResult
[13:34:40.721] result() for ClusterFuture ... done
[13:34:40.721] result() for ClusterFuture ...
[13:34:40.721] - result already collected: FutureResult
[13:34:40.721] result() for ClusterFuture ... done
[13:34:40.722] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:40.722] - nx: 2
[13:34:40.722] - relay: TRUE
[13:34:40.722] - stdout: TRUE
[13:34:40.722] - signal: TRUE
[13:34:40.722] - resignal: FALSE
[13:34:40.722] - force: TRUE
[13:34:40.722] - relayed: [n=2] TRUE, FALSE
[13:34:40.722] - queued futures: [n=2] TRUE, FALSE
[13:34:40.722]  - until=2
[13:34:40.722]  - relaying element #2
[13:34:40.723] result() for ClusterFuture ...
[13:34:40.723] - result already collected: FutureResult
[13:34:40.723] result() for ClusterFuture ... done
[13:34:40.723] result() for ClusterFuture ...
[13:34:40.723] - result already collected: FutureResult
[13:34:40.723] result() for ClusterFuture ... done
[13:34:40.723] result() for ClusterFuture ...
[13:34:40.723] - result already collected: FutureResult
[13:34:40.723] result() for ClusterFuture ... done
[13:34:40.723] result() for ClusterFuture ...
[13:34:40.723] - result already collected: FutureResult
[13:34:40.724] result() for ClusterFuture ... done
[13:34:40.724] - relayed: [n=2] TRUE, TRUE
[13:34:40.724] - queued futures: [n=2] TRUE, TRUE
[13:34:40.724] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:40.724]  length: 0 (resolved future 2)
[13:34:40.724] Relaying remaining futures
[13:34:40.724] signalConditionsASAP(NULL, pos=0) ...
[13:34:40.724] - nx: 2
[13:34:40.724] - relay: TRUE
[13:34:40.724] - stdout: TRUE
[13:34:40.724] - signal: TRUE
[13:34:40.724] - resignal: FALSE
[13:34:40.725] - force: TRUE
[13:34:40.725] - relayed: [n=2] TRUE, TRUE
[13:34:40.725] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:40.725] - relayed: [n=2] TRUE, TRUE
[13:34:40.725] - queued futures: [n=2] TRUE, TRUE
[13:34:40.725] signalConditionsASAP(NULL, pos=0) ... done
[13:34:40.725] resolve() on list ... DONE
[13:34:40.725] result() for ClusterFuture ...
[13:34:40.725] - result already collected: FutureResult
[13:34:40.725] result() for ClusterFuture ... done
[13:34:40.725] result() for ClusterFuture ...
[13:34:40.725] - result already collected: FutureResult
[13:34:40.726] result() for ClusterFuture ... done
[13:34:40.726] result() for ClusterFuture ...
[13:34:40.726] - result already collected: FutureResult
[13:34:40.726] result() for ClusterFuture ... done
[13:34:40.726] result() for ClusterFuture ...
[13:34:40.726] - result already collected: FutureResult
[13:34:40.726] result() for ClusterFuture ... done
[13:34:40.726]  - Number of value chunks collected: 2
[13:34:40.726] Resolving 2 futures (chunks) ... DONE
[13:34:40.726] Reducing values from 2 chunks ...
[13:34:40.727]  - Number of values collected after concatenation: 4
[13:34:40.727]  - Number of values expected: 4
[13:34:40.727] Reducing values from 2 chunks ... DONE
[13:34:40.727] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[13:34:40.727] future_mapply() ...
[13:34:40.731] Number of chunks: 2
[13:34:40.731] getGlobalsAndPackagesXApply() ...
[13:34:40.731]  - future.globals: TRUE
[13:34:40.731] getGlobalsAndPackages() ...
[13:34:40.731] Searching for globals...
[13:34:40.732] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:34:40.732] Searching for globals ... DONE
[13:34:40.732] Resolving globals: FALSE
[13:34:40.733] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[13:34:40.733] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[13:34:40.733] - globals: [1] ‘FUN’
[13:34:40.733] - packages: [1] ‘stats’
[13:34:40.733] getGlobalsAndPackages() ... DONE
[13:34:40.734]  - globals found/used: [n=1] ‘FUN’
[13:34:40.734]  - needed namespaces: [n=1] ‘stats’
[13:34:40.734] Finding globals ... DONE
[13:34:40.734] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:40.734] List of 2
[13:34:40.734]  $ ...future.FUN:function (x, w, ...)  
[13:34:40.734]  $ MoreArgs     : NULL
[13:34:40.734]  - attr(*, "where")=List of 2
[13:34:40.734]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:40.734]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:40.734]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:40.734]  - attr(*, "resolved")= logi FALSE
[13:34:40.734]  - attr(*, "total_size")= num NA
[13:34:40.736] Packages to be attached in all futures: [n=1] ‘stats’
[13:34:40.737] getGlobalsAndPackagesXApply() ... DONE
[13:34:40.737] Number of futures (= number of chunks): 2
[13:34:40.737] Launching 2 futures (chunks) ...
[13:34:40.737] Chunk #1 of 2 ...
[13:34:40.737]  - Finding globals in '...' for chunk #1 ...
[13:34:40.737] getGlobalsAndPackages() ...
[13:34:40.737] Searching for globals...
[13:34:40.738] 
[13:34:40.738] Searching for globals ... DONE
[13:34:40.738] - globals: [0] <none>
[13:34:40.738] getGlobalsAndPackages() ... DONE
[13:34:40.738]    + additional globals found: [n=0] 
[13:34:40.738]    + additional namespaces needed: [n=0] 
[13:34:40.738]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:40.738]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.738]  - seeds: <none>
[13:34:40.738]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.739] getGlobalsAndPackages() ...
[13:34:40.739] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.739] Resolving globals: FALSE
[13:34:40.739] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[13:34:40.740] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:40.740] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.740] - packages: [1] ‘stats’
[13:34:40.740] getGlobalsAndPackages() ... DONE
[13:34:40.740] run() for ‘Future’ ...
[13:34:40.740] - state: ‘created’
[13:34:40.740] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.756] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.756] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.756]   - Field: ‘node’
[13:34:40.756]   - Field: ‘label’
[13:34:40.756]   - Field: ‘local’
[13:34:40.756]   - Field: ‘owner’
[13:34:40.757]   - Field: ‘envir’
[13:34:40.757]   - Field: ‘workers’
[13:34:40.757]   - Field: ‘packages’
[13:34:40.757]   - Field: ‘gc’
[13:34:40.757]   - Field: ‘conditions’
[13:34:40.757]   - Field: ‘persistent’
[13:34:40.757]   - Field: ‘expr’
[13:34:40.757]   - Field: ‘uuid’
[13:34:40.757]   - Field: ‘seed’
[13:34:40.757]   - Field: ‘version’
[13:34:40.757]   - Field: ‘result’
[13:34:40.758]   - Field: ‘asynchronous’
[13:34:40.758]   - Field: ‘calls’
[13:34:40.758]   - Field: ‘globals’
[13:34:40.758]   - Field: ‘stdout’
[13:34:40.758]   - Field: ‘earlySignal’
[13:34:40.758]   - Field: ‘lazy’
[13:34:40.758]   - Field: ‘state’
[13:34:40.758] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.758] - Launch lazy future ...
[13:34:40.759] Packages needed by the future expression (n = 1): ‘stats’
[13:34:40.759] Packages needed by future strategies (n = 0): <none>
[13:34:40.759] {
[13:34:40.759]     {
[13:34:40.759]         {
[13:34:40.759]             ...future.startTime <- base::Sys.time()
[13:34:40.759]             {
[13:34:40.759]                 {
[13:34:40.759]                   {
[13:34:40.759]                     {
[13:34:40.759]                       {
[13:34:40.759]                         base::local({
[13:34:40.759]                           has_future <- base::requireNamespace("future", 
[13:34:40.759]                             quietly = TRUE)
[13:34:40.759]                           if (has_future) {
[13:34:40.759]                             ns <- base::getNamespace("future")
[13:34:40.759]                             version <- ns[[".package"]][["version"]]
[13:34:40.759]                             if (is.null(version)) 
[13:34:40.759]                               version <- utils::packageVersion("future")
[13:34:40.759]                           }
[13:34:40.759]                           else {
[13:34:40.759]                             version <- NULL
[13:34:40.759]                           }
[13:34:40.759]                           if (!has_future || version < "1.8.0") {
[13:34:40.759]                             info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.759]                               "", base::R.version$version.string), 
[13:34:40.759]                               platform = base::sprintf("%s (%s-bit)", 
[13:34:40.759]                                 base::R.version$platform, 8 * 
[13:34:40.759]                                   base::.Machine$sizeof.pointer), 
[13:34:40.759]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.759]                                 "release", "version")], collapse = " "), 
[13:34:40.759]                               hostname = base::Sys.info()[["nodename"]])
[13:34:40.759]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.759]                               info)
[13:34:40.759]                             info <- base::paste(info, collapse = "; ")
[13:34:40.759]                             if (!has_future) {
[13:34:40.759]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.759]                                 info)
[13:34:40.759]                             }
[13:34:40.759]                             else {
[13:34:40.759]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.759]                                 info, version)
[13:34:40.759]                             }
[13:34:40.759]                             base::stop(msg)
[13:34:40.759]                           }
[13:34:40.759]                         })
[13:34:40.759]                       }
[13:34:40.759]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.759]                       base::options(mc.cores = 1L)
[13:34:40.759]                     }
[13:34:40.759]                     base::local({
[13:34:40.759]                       for (pkg in "stats") {
[13:34:40.759]                         base::loadNamespace(pkg)
[13:34:40.759]                         base::library(pkg, character.only = TRUE)
[13:34:40.759]                       }
[13:34:40.759]                     })
[13:34:40.759]                   }
[13:34:40.759]                   ...future.strategy.old <- future::plan("list")
[13:34:40.759]                   options(future.plan = NULL)
[13:34:40.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.759]                 }
[13:34:40.759]                 ...future.workdir <- getwd()
[13:34:40.759]             }
[13:34:40.759]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.759]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.759]         }
[13:34:40.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.759]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.759]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.759]             base::names(...future.oldOptions))
[13:34:40.759]     }
[13:34:40.759]     if (FALSE) {
[13:34:40.759]     }
[13:34:40.759]     else {
[13:34:40.759]         if (TRUE) {
[13:34:40.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.759]                 open = "w")
[13:34:40.759]         }
[13:34:40.759]         else {
[13:34:40.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.759]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.759]         }
[13:34:40.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.759]             base::sink(type = "output", split = FALSE)
[13:34:40.759]             base::close(...future.stdout)
[13:34:40.759]         }, add = TRUE)
[13:34:40.759]     }
[13:34:40.759]     ...future.frame <- base::sys.nframe()
[13:34:40.759]     ...future.conditions <- base::list()
[13:34:40.759]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.759]     if (FALSE) {
[13:34:40.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.759]     }
[13:34:40.759]     ...future.result <- base::tryCatch({
[13:34:40.759]         base::withCallingHandlers({
[13:34:40.759]             ...future.value <- base::withVisible(base::local({
[13:34:40.759]                 ...future.makeSendCondition <- base::local({
[13:34:40.759]                   sendCondition <- NULL
[13:34:40.759]                   function(frame = 1L) {
[13:34:40.759]                     if (is.function(sendCondition)) 
[13:34:40.759]                       return(sendCondition)
[13:34:40.759]                     ns <- getNamespace("parallel")
[13:34:40.759]                     if (exists("sendData", mode = "function", 
[13:34:40.759]                       envir = ns)) {
[13:34:40.759]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.759]                         envir = ns)
[13:34:40.759]                       envir <- sys.frame(frame)
[13:34:40.759]                       master <- NULL
[13:34:40.759]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.759]                         !identical(envir, emptyenv())) {
[13:34:40.759]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.759]                           inherits = FALSE)) {
[13:34:40.759]                           master <- get("master", mode = "list", 
[13:34:40.759]                             envir = envir, inherits = FALSE)
[13:34:40.759]                           if (inherits(master, c("SOCKnode", 
[13:34:40.759]                             "SOCK0node"))) {
[13:34:40.759]                             sendCondition <<- function(cond) {
[13:34:40.759]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.759]                                 success = TRUE)
[13:34:40.759]                               parallel_sendData(master, data)
[13:34:40.759]                             }
[13:34:40.759]                             return(sendCondition)
[13:34:40.759]                           }
[13:34:40.759]                         }
[13:34:40.759]                         frame <- frame + 1L
[13:34:40.759]                         envir <- sys.frame(frame)
[13:34:40.759]                       }
[13:34:40.759]                     }
[13:34:40.759]                     sendCondition <<- function(cond) NULL
[13:34:40.759]                   }
[13:34:40.759]                 })
[13:34:40.759]                 withCallingHandlers({
[13:34:40.759]                   {
[13:34:40.759]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.759]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.759]                       ...future.globals.maxSize)) {
[13:34:40.759]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.759]                       on.exit(options(oopts), add = TRUE)
[13:34:40.759]                     }
[13:34:40.759]                     {
[13:34:40.759]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.759]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.759]                         USE.NAMES = FALSE)
[13:34:40.759]                       do.call(mapply, args = args)
[13:34:40.759]                     }
[13:34:40.759]                   }
[13:34:40.759]                 }, immediateCondition = function(cond) {
[13:34:40.759]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.759]                   sendCondition(cond)
[13:34:40.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.759]                   {
[13:34:40.759]                     inherits <- base::inherits
[13:34:40.759]                     invokeRestart <- base::invokeRestart
[13:34:40.759]                     is.null <- base::is.null
[13:34:40.759]                     muffled <- FALSE
[13:34:40.759]                     if (inherits(cond, "message")) {
[13:34:40.759]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.759]                       if (muffled) 
[13:34:40.759]                         invokeRestart("muffleMessage")
[13:34:40.759]                     }
[13:34:40.759]                     else if (inherits(cond, "warning")) {
[13:34:40.759]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.759]                       if (muffled) 
[13:34:40.759]                         invokeRestart("muffleWarning")
[13:34:40.759]                     }
[13:34:40.759]                     else if (inherits(cond, "condition")) {
[13:34:40.759]                       if (!is.null(pattern)) {
[13:34:40.759]                         computeRestarts <- base::computeRestarts
[13:34:40.759]                         grepl <- base::grepl
[13:34:40.759]                         restarts <- computeRestarts(cond)
[13:34:40.759]                         for (restart in restarts) {
[13:34:40.759]                           name <- restart$name
[13:34:40.759]                           if (is.null(name)) 
[13:34:40.759]                             next
[13:34:40.759]                           if (!grepl(pattern, name)) 
[13:34:40.759]                             next
[13:34:40.759]                           invokeRestart(restart)
[13:34:40.759]                           muffled <- TRUE
[13:34:40.759]                           break
[13:34:40.759]                         }
[13:34:40.759]                       }
[13:34:40.759]                     }
[13:34:40.759]                     invisible(muffled)
[13:34:40.759]                   }
[13:34:40.759]                   muffleCondition(cond)
[13:34:40.759]                 })
[13:34:40.759]             }))
[13:34:40.759]             future::FutureResult(value = ...future.value$value, 
[13:34:40.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.759]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.759]                     ...future.globalenv.names))
[13:34:40.759]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.759]         }, condition = base::local({
[13:34:40.759]             c <- base::c
[13:34:40.759]             inherits <- base::inherits
[13:34:40.759]             invokeRestart <- base::invokeRestart
[13:34:40.759]             length <- base::length
[13:34:40.759]             list <- base::list
[13:34:40.759]             seq.int <- base::seq.int
[13:34:40.759]             signalCondition <- base::signalCondition
[13:34:40.759]             sys.calls <- base::sys.calls
[13:34:40.759]             `[[` <- base::`[[`
[13:34:40.759]             `+` <- base::`+`
[13:34:40.759]             `<<-` <- base::`<<-`
[13:34:40.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.759]                   3L)]
[13:34:40.759]             }
[13:34:40.759]             function(cond) {
[13:34:40.759]                 is_error <- inherits(cond, "error")
[13:34:40.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.759]                   NULL)
[13:34:40.759]                 if (is_error) {
[13:34:40.759]                   sessionInformation <- function() {
[13:34:40.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.759]                       search = base::search(), system = base::Sys.info())
[13:34:40.759]                   }
[13:34:40.759]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.759]                     cond$call), session = sessionInformation(), 
[13:34:40.759]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.759]                   signalCondition(cond)
[13:34:40.759]                 }
[13:34:40.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.759]                 "immediateCondition"))) {
[13:34:40.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.759]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.759]                   if (TRUE && !signal) {
[13:34:40.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.759]                     {
[13:34:40.759]                       inherits <- base::inherits
[13:34:40.759]                       invokeRestart <- base::invokeRestart
[13:34:40.759]                       is.null <- base::is.null
[13:34:40.759]                       muffled <- FALSE
[13:34:40.759]                       if (inherits(cond, "message")) {
[13:34:40.759]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.759]                         if (muffled) 
[13:34:40.759]                           invokeRestart("muffleMessage")
[13:34:40.759]                       }
[13:34:40.759]                       else if (inherits(cond, "warning")) {
[13:34:40.759]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.759]                         if (muffled) 
[13:34:40.759]                           invokeRestart("muffleWarning")
[13:34:40.759]                       }
[13:34:40.759]                       else if (inherits(cond, "condition")) {
[13:34:40.759]                         if (!is.null(pattern)) {
[13:34:40.759]                           computeRestarts <- base::computeRestarts
[13:34:40.759]                           grepl <- base::grepl
[13:34:40.759]                           restarts <- computeRestarts(cond)
[13:34:40.759]                           for (restart in restarts) {
[13:34:40.759]                             name <- restart$name
[13:34:40.759]                             if (is.null(name)) 
[13:34:40.759]                               next
[13:34:40.759]                             if (!grepl(pattern, name)) 
[13:34:40.759]                               next
[13:34:40.759]                             invokeRestart(restart)
[13:34:40.759]                             muffled <- TRUE
[13:34:40.759]                             break
[13:34:40.759]                           }
[13:34:40.759]                         }
[13:34:40.759]                       }
[13:34:40.759]                       invisible(muffled)
[13:34:40.759]                     }
[13:34:40.759]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.759]                   }
[13:34:40.759]                 }
[13:34:40.759]                 else {
[13:34:40.759]                   if (TRUE) {
[13:34:40.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.759]                     {
[13:34:40.759]                       inherits <- base::inherits
[13:34:40.759]                       invokeRestart <- base::invokeRestart
[13:34:40.759]                       is.null <- base::is.null
[13:34:40.759]                       muffled <- FALSE
[13:34:40.759]                       if (inherits(cond, "message")) {
[13:34:40.759]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.759]                         if (muffled) 
[13:34:40.759]                           invokeRestart("muffleMessage")
[13:34:40.759]                       }
[13:34:40.759]                       else if (inherits(cond, "warning")) {
[13:34:40.759]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.759]                         if (muffled) 
[13:34:40.759]                           invokeRestart("muffleWarning")
[13:34:40.759]                       }
[13:34:40.759]                       else if (inherits(cond, "condition")) {
[13:34:40.759]                         if (!is.null(pattern)) {
[13:34:40.759]                           computeRestarts <- base::computeRestarts
[13:34:40.759]                           grepl <- base::grepl
[13:34:40.759]                           restarts <- computeRestarts(cond)
[13:34:40.759]                           for (restart in restarts) {
[13:34:40.759]                             name <- restart$name
[13:34:40.759]                             if (is.null(name)) 
[13:34:40.759]                               next
[13:34:40.759]                             if (!grepl(pattern, name)) 
[13:34:40.759]                               next
[13:34:40.759]                             invokeRestart(restart)
[13:34:40.759]                             muffled <- TRUE
[13:34:40.759]                             break
[13:34:40.759]                           }
[13:34:40.759]                         }
[13:34:40.759]                       }
[13:34:40.759]                       invisible(muffled)
[13:34:40.759]                     }
[13:34:40.759]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.759]                   }
[13:34:40.759]                 }
[13:34:40.759]             }
[13:34:40.759]         }))
[13:34:40.759]     }, error = function(ex) {
[13:34:40.759]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.759]                 ...future.rng), started = ...future.startTime, 
[13:34:40.759]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.759]             version = "1.8"), class = "FutureResult")
[13:34:40.759]     }, finally = {
[13:34:40.759]         if (!identical(...future.workdir, getwd())) 
[13:34:40.759]             setwd(...future.workdir)
[13:34:40.759]         {
[13:34:40.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.759]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.759]             }
[13:34:40.759]             base::options(...future.oldOptions)
[13:34:40.759]             if (.Platform$OS.type == "windows") {
[13:34:40.759]                 old_names <- names(...future.oldEnvVars)
[13:34:40.759]                 envs <- base::Sys.getenv()
[13:34:40.759]                 names <- names(envs)
[13:34:40.759]                 common <- intersect(names, old_names)
[13:34:40.759]                 added <- setdiff(names, old_names)
[13:34:40.759]                 removed <- setdiff(old_names, names)
[13:34:40.759]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.759]                   envs[common]]
[13:34:40.759]                 NAMES <- toupper(changed)
[13:34:40.759]                 args <- list()
[13:34:40.759]                 for (kk in seq_along(NAMES)) {
[13:34:40.759]                   name <- changed[[kk]]
[13:34:40.759]                   NAME <- NAMES[[kk]]
[13:34:40.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.759]                     next
[13:34:40.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.759]                 }
[13:34:40.759]                 NAMES <- toupper(added)
[13:34:40.759]                 for (kk in seq_along(NAMES)) {
[13:34:40.759]                   name <- added[[kk]]
[13:34:40.759]                   NAME <- NAMES[[kk]]
[13:34:40.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.759]                     next
[13:34:40.759]                   args[[name]] <- ""
[13:34:40.759]                 }
[13:34:40.759]                 NAMES <- toupper(removed)
[13:34:40.759]                 for (kk in seq_along(NAMES)) {
[13:34:40.759]                   name <- removed[[kk]]
[13:34:40.759]                   NAME <- NAMES[[kk]]
[13:34:40.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.759]                     next
[13:34:40.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.759]                 }
[13:34:40.759]                 if (length(args) > 0) 
[13:34:40.759]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.759]             }
[13:34:40.759]             else {
[13:34:40.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.759]             }
[13:34:40.759]             {
[13:34:40.759]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.759]                   0L) {
[13:34:40.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.759]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.759]                   base::options(opts)
[13:34:40.759]                 }
[13:34:40.759]                 {
[13:34:40.759]                   {
[13:34:40.759]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.759]                     NULL
[13:34:40.759]                   }
[13:34:40.759]                   options(future.plan = NULL)
[13:34:40.759]                   if (is.na(NA_character_)) 
[13:34:40.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.759]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.759]                     .init = FALSE)
[13:34:40.759]                 }
[13:34:40.759]             }
[13:34:40.759]         }
[13:34:40.759]     })
[13:34:40.759]     if (TRUE) {
[13:34:40.759]         base::sink(type = "output", split = FALSE)
[13:34:40.759]         if (TRUE) {
[13:34:40.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.759]         }
[13:34:40.759]         else {
[13:34:40.759]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.759]         }
[13:34:40.759]         base::close(...future.stdout)
[13:34:40.759]         ...future.stdout <- NULL
[13:34:40.759]     }
[13:34:40.759]     ...future.result$conditions <- ...future.conditions
[13:34:40.759]     ...future.result$finished <- base::Sys.time()
[13:34:40.759]     ...future.result
[13:34:40.759] }
[13:34:40.762] Exporting 5 global objects (2.07 KiB) to cluster node #1 ...
[13:34:40.762] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ...
[13:34:40.762] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ... DONE
[13:34:40.762] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:40.763] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.763] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ...
[13:34:40.763] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ... DONE
[13:34:40.763] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:40.764] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.764] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:40.764] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.764] Exporting 5 global objects (2.07 KiB) to cluster node #1 ... DONE
[13:34:40.765] MultisessionFuture started
[13:34:40.765] - Launch lazy future ... done
[13:34:40.765] run() for ‘MultisessionFuture’ ... done
[13:34:40.765] Created future:
[13:34:40.765] MultisessionFuture:
[13:34:40.765] Label: ‘future_Map-1’
[13:34:40.765] Expression:
[13:34:40.765] {
[13:34:40.765]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.765]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.765]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.765]         on.exit(options(oopts), add = TRUE)
[13:34:40.765]     }
[13:34:40.765]     {
[13:34:40.765]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.765]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.765]         do.call(mapply, args = args)
[13:34:40.765]     }
[13:34:40.765] }
[13:34:40.765] Lazy evaluation: FALSE
[13:34:40.765] Asynchronous evaluation: TRUE
[13:34:40.765] Local evaluation: TRUE
[13:34:40.765] Environment: R_GlobalEnv
[13:34:40.765] Capture standard output: TRUE
[13:34:40.765] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.765] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.765] Packages: 1 packages (‘stats’)
[13:34:40.765] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:40.765] Resolved: FALSE
[13:34:40.765] Value: <not collected>
[13:34:40.765] Conditions captured: <none>
[13:34:40.765] Early signaling: FALSE
[13:34:40.765] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.765] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.776] Chunk #1 of 2 ... DONE
[13:34:40.776] Chunk #2 of 2 ...
[13:34:40.777]  - Finding globals in '...' for chunk #2 ...
[13:34:40.777] getGlobalsAndPackages() ...
[13:34:40.777] Searching for globals...
[13:34:40.777] 
[13:34:40.777] Searching for globals ... DONE
[13:34:40.777] - globals: [0] <none>
[13:34:40.777] getGlobalsAndPackages() ... DONE
[13:34:40.778]    + additional globals found: [n=0] 
[13:34:40.778]    + additional namespaces needed: [n=0] 
[13:34:40.778]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:40.778]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.778]  - seeds: <none>
[13:34:40.778]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.778] getGlobalsAndPackages() ...
[13:34:40.778] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.778] Resolving globals: FALSE
[13:34:40.779] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[13:34:40.779] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:40.779] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.779] - packages: [1] ‘stats’
[13:34:40.780] getGlobalsAndPackages() ... DONE
[13:34:40.780] run() for ‘Future’ ...
[13:34:40.780] - state: ‘created’
[13:34:40.780] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.793] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.794]   - Field: ‘node’
[13:34:40.794]   - Field: ‘label’
[13:34:40.794]   - Field: ‘local’
[13:34:40.794]   - Field: ‘owner’
[13:34:40.794]   - Field: ‘envir’
[13:34:40.794]   - Field: ‘workers’
[13:34:40.794]   - Field: ‘packages’
[13:34:40.794]   - Field: ‘gc’
[13:34:40.794]   - Field: ‘conditions’
[13:34:40.795]   - Field: ‘persistent’
[13:34:40.795]   - Field: ‘expr’
[13:34:40.795]   - Field: ‘uuid’
[13:34:40.795]   - Field: ‘seed’
[13:34:40.795]   - Field: ‘version’
[13:34:40.795]   - Field: ‘result’
[13:34:40.795]   - Field: ‘asynchronous’
[13:34:40.795]   - Field: ‘calls’
[13:34:40.795]   - Field: ‘globals’
[13:34:40.795]   - Field: ‘stdout’
[13:34:40.795]   - Field: ‘earlySignal’
[13:34:40.796]   - Field: ‘lazy’
[13:34:40.796]   - Field: ‘state’
[13:34:40.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.796] - Launch lazy future ...
[13:34:40.796] Packages needed by the future expression (n = 1): ‘stats’
[13:34:40.796] Packages needed by future strategies (n = 0): <none>
[13:34:40.797] {
[13:34:40.797]     {
[13:34:40.797]         {
[13:34:40.797]             ...future.startTime <- base::Sys.time()
[13:34:40.797]             {
[13:34:40.797]                 {
[13:34:40.797]                   {
[13:34:40.797]                     {
[13:34:40.797]                       {
[13:34:40.797]                         base::local({
[13:34:40.797]                           has_future <- base::requireNamespace("future", 
[13:34:40.797]                             quietly = TRUE)
[13:34:40.797]                           if (has_future) {
[13:34:40.797]                             ns <- base::getNamespace("future")
[13:34:40.797]                             version <- ns[[".package"]][["version"]]
[13:34:40.797]                             if (is.null(version)) 
[13:34:40.797]                               version <- utils::packageVersion("future")
[13:34:40.797]                           }
[13:34:40.797]                           else {
[13:34:40.797]                             version <- NULL
[13:34:40.797]                           }
[13:34:40.797]                           if (!has_future || version < "1.8.0") {
[13:34:40.797]                             info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.797]                               "", base::R.version$version.string), 
[13:34:40.797]                               platform = base::sprintf("%s (%s-bit)", 
[13:34:40.797]                                 base::R.version$platform, 8 * 
[13:34:40.797]                                   base::.Machine$sizeof.pointer), 
[13:34:40.797]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.797]                                 "release", "version")], collapse = " "), 
[13:34:40.797]                               hostname = base::Sys.info()[["nodename"]])
[13:34:40.797]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.797]                               info)
[13:34:40.797]                             info <- base::paste(info, collapse = "; ")
[13:34:40.797]                             if (!has_future) {
[13:34:40.797]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.797]                                 info)
[13:34:40.797]                             }
[13:34:40.797]                             else {
[13:34:40.797]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.797]                                 info, version)
[13:34:40.797]                             }
[13:34:40.797]                             base::stop(msg)
[13:34:40.797]                           }
[13:34:40.797]                         })
[13:34:40.797]                       }
[13:34:40.797]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.797]                       base::options(mc.cores = 1L)
[13:34:40.797]                     }
[13:34:40.797]                     base::local({
[13:34:40.797]                       for (pkg in "stats") {
[13:34:40.797]                         base::loadNamespace(pkg)
[13:34:40.797]                         base::library(pkg, character.only = TRUE)
[13:34:40.797]                       }
[13:34:40.797]                     })
[13:34:40.797]                   }
[13:34:40.797]                   ...future.strategy.old <- future::plan("list")
[13:34:40.797]                   options(future.plan = NULL)
[13:34:40.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.797]                 }
[13:34:40.797]                 ...future.workdir <- getwd()
[13:34:40.797]             }
[13:34:40.797]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.797]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.797]         }
[13:34:40.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.797]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.797]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.797]             base::names(...future.oldOptions))
[13:34:40.797]     }
[13:34:40.797]     if (FALSE) {
[13:34:40.797]     }
[13:34:40.797]     else {
[13:34:40.797]         if (TRUE) {
[13:34:40.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.797]                 open = "w")
[13:34:40.797]         }
[13:34:40.797]         else {
[13:34:40.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.797]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.797]         }
[13:34:40.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.797]             base::sink(type = "output", split = FALSE)
[13:34:40.797]             base::close(...future.stdout)
[13:34:40.797]         }, add = TRUE)
[13:34:40.797]     }
[13:34:40.797]     ...future.frame <- base::sys.nframe()
[13:34:40.797]     ...future.conditions <- base::list()
[13:34:40.797]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.797]     if (FALSE) {
[13:34:40.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.797]     }
[13:34:40.797]     ...future.result <- base::tryCatch({
[13:34:40.797]         base::withCallingHandlers({
[13:34:40.797]             ...future.value <- base::withVisible(base::local({
[13:34:40.797]                 ...future.makeSendCondition <- base::local({
[13:34:40.797]                   sendCondition <- NULL
[13:34:40.797]                   function(frame = 1L) {
[13:34:40.797]                     if (is.function(sendCondition)) 
[13:34:40.797]                       return(sendCondition)
[13:34:40.797]                     ns <- getNamespace("parallel")
[13:34:40.797]                     if (exists("sendData", mode = "function", 
[13:34:40.797]                       envir = ns)) {
[13:34:40.797]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.797]                         envir = ns)
[13:34:40.797]                       envir <- sys.frame(frame)
[13:34:40.797]                       master <- NULL
[13:34:40.797]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.797]                         !identical(envir, emptyenv())) {
[13:34:40.797]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.797]                           inherits = FALSE)) {
[13:34:40.797]                           master <- get("master", mode = "list", 
[13:34:40.797]                             envir = envir, inherits = FALSE)
[13:34:40.797]                           if (inherits(master, c("SOCKnode", 
[13:34:40.797]                             "SOCK0node"))) {
[13:34:40.797]                             sendCondition <<- function(cond) {
[13:34:40.797]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.797]                                 success = TRUE)
[13:34:40.797]                               parallel_sendData(master, data)
[13:34:40.797]                             }
[13:34:40.797]                             return(sendCondition)
[13:34:40.797]                           }
[13:34:40.797]                         }
[13:34:40.797]                         frame <- frame + 1L
[13:34:40.797]                         envir <- sys.frame(frame)
[13:34:40.797]                       }
[13:34:40.797]                     }
[13:34:40.797]                     sendCondition <<- function(cond) NULL
[13:34:40.797]                   }
[13:34:40.797]                 })
[13:34:40.797]                 withCallingHandlers({
[13:34:40.797]                   {
[13:34:40.797]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.797]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.797]                       ...future.globals.maxSize)) {
[13:34:40.797]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.797]                       on.exit(options(oopts), add = TRUE)
[13:34:40.797]                     }
[13:34:40.797]                     {
[13:34:40.797]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.797]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.797]                         USE.NAMES = FALSE)
[13:34:40.797]                       do.call(mapply, args = args)
[13:34:40.797]                     }
[13:34:40.797]                   }
[13:34:40.797]                 }, immediateCondition = function(cond) {
[13:34:40.797]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.797]                   sendCondition(cond)
[13:34:40.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.797]                   {
[13:34:40.797]                     inherits <- base::inherits
[13:34:40.797]                     invokeRestart <- base::invokeRestart
[13:34:40.797]                     is.null <- base::is.null
[13:34:40.797]                     muffled <- FALSE
[13:34:40.797]                     if (inherits(cond, "message")) {
[13:34:40.797]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.797]                       if (muffled) 
[13:34:40.797]                         invokeRestart("muffleMessage")
[13:34:40.797]                     }
[13:34:40.797]                     else if (inherits(cond, "warning")) {
[13:34:40.797]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.797]                       if (muffled) 
[13:34:40.797]                         invokeRestart("muffleWarning")
[13:34:40.797]                     }
[13:34:40.797]                     else if (inherits(cond, "condition")) {
[13:34:40.797]                       if (!is.null(pattern)) {
[13:34:40.797]                         computeRestarts <- base::computeRestarts
[13:34:40.797]                         grepl <- base::grepl
[13:34:40.797]                         restarts <- computeRestarts(cond)
[13:34:40.797]                         for (restart in restarts) {
[13:34:40.797]                           name <- restart$name
[13:34:40.797]                           if (is.null(name)) 
[13:34:40.797]                             next
[13:34:40.797]                           if (!grepl(pattern, name)) 
[13:34:40.797]                             next
[13:34:40.797]                           invokeRestart(restart)
[13:34:40.797]                           muffled <- TRUE
[13:34:40.797]                           break
[13:34:40.797]                         }
[13:34:40.797]                       }
[13:34:40.797]                     }
[13:34:40.797]                     invisible(muffled)
[13:34:40.797]                   }
[13:34:40.797]                   muffleCondition(cond)
[13:34:40.797]                 })
[13:34:40.797]             }))
[13:34:40.797]             future::FutureResult(value = ...future.value$value, 
[13:34:40.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.797]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.797]                     ...future.globalenv.names))
[13:34:40.797]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.797]         }, condition = base::local({
[13:34:40.797]             c <- base::c
[13:34:40.797]             inherits <- base::inherits
[13:34:40.797]             invokeRestart <- base::invokeRestart
[13:34:40.797]             length <- base::length
[13:34:40.797]             list <- base::list
[13:34:40.797]             seq.int <- base::seq.int
[13:34:40.797]             signalCondition <- base::signalCondition
[13:34:40.797]             sys.calls <- base::sys.calls
[13:34:40.797]             `[[` <- base::`[[`
[13:34:40.797]             `+` <- base::`+`
[13:34:40.797]             `<<-` <- base::`<<-`
[13:34:40.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.797]                   3L)]
[13:34:40.797]             }
[13:34:40.797]             function(cond) {
[13:34:40.797]                 is_error <- inherits(cond, "error")
[13:34:40.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.797]                   NULL)
[13:34:40.797]                 if (is_error) {
[13:34:40.797]                   sessionInformation <- function() {
[13:34:40.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.797]                       search = base::search(), system = base::Sys.info())
[13:34:40.797]                   }
[13:34:40.797]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.797]                     cond$call), session = sessionInformation(), 
[13:34:40.797]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.797]                   signalCondition(cond)
[13:34:40.797]                 }
[13:34:40.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.797]                 "immediateCondition"))) {
[13:34:40.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.797]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.797]                   if (TRUE && !signal) {
[13:34:40.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.797]                     {
[13:34:40.797]                       inherits <- base::inherits
[13:34:40.797]                       invokeRestart <- base::invokeRestart
[13:34:40.797]                       is.null <- base::is.null
[13:34:40.797]                       muffled <- FALSE
[13:34:40.797]                       if (inherits(cond, "message")) {
[13:34:40.797]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.797]                         if (muffled) 
[13:34:40.797]                           invokeRestart("muffleMessage")
[13:34:40.797]                       }
[13:34:40.797]                       else if (inherits(cond, "warning")) {
[13:34:40.797]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.797]                         if (muffled) 
[13:34:40.797]                           invokeRestart("muffleWarning")
[13:34:40.797]                       }
[13:34:40.797]                       else if (inherits(cond, "condition")) {
[13:34:40.797]                         if (!is.null(pattern)) {
[13:34:40.797]                           computeRestarts <- base::computeRestarts
[13:34:40.797]                           grepl <- base::grepl
[13:34:40.797]                           restarts <- computeRestarts(cond)
[13:34:40.797]                           for (restart in restarts) {
[13:34:40.797]                             name <- restart$name
[13:34:40.797]                             if (is.null(name)) 
[13:34:40.797]                               next
[13:34:40.797]                             if (!grepl(pattern, name)) 
[13:34:40.797]                               next
[13:34:40.797]                             invokeRestart(restart)
[13:34:40.797]                             muffled <- TRUE
[13:34:40.797]                             break
[13:34:40.797]                           }
[13:34:40.797]                         }
[13:34:40.797]                       }
[13:34:40.797]                       invisible(muffled)
[13:34:40.797]                     }
[13:34:40.797]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.797]                   }
[13:34:40.797]                 }
[13:34:40.797]                 else {
[13:34:40.797]                   if (TRUE) {
[13:34:40.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.797]                     {
[13:34:40.797]                       inherits <- base::inherits
[13:34:40.797]                       invokeRestart <- base::invokeRestart
[13:34:40.797]                       is.null <- base::is.null
[13:34:40.797]                       muffled <- FALSE
[13:34:40.797]                       if (inherits(cond, "message")) {
[13:34:40.797]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.797]                         if (muffled) 
[13:34:40.797]                           invokeRestart("muffleMessage")
[13:34:40.797]                       }
[13:34:40.797]                       else if (inherits(cond, "warning")) {
[13:34:40.797]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.797]                         if (muffled) 
[13:34:40.797]                           invokeRestart("muffleWarning")
[13:34:40.797]                       }
[13:34:40.797]                       else if (inherits(cond, "condition")) {
[13:34:40.797]                         if (!is.null(pattern)) {
[13:34:40.797]                           computeRestarts <- base::computeRestarts
[13:34:40.797]                           grepl <- base::grepl
[13:34:40.797]                           restarts <- computeRestarts(cond)
[13:34:40.797]                           for (restart in restarts) {
[13:34:40.797]                             name <- restart$name
[13:34:40.797]                             if (is.null(name)) 
[13:34:40.797]                               next
[13:34:40.797]                             if (!grepl(pattern, name)) 
[13:34:40.797]                               next
[13:34:40.797]                             invokeRestart(restart)
[13:34:40.797]                             muffled <- TRUE
[13:34:40.797]                             break
[13:34:40.797]                           }
[13:34:40.797]                         }
[13:34:40.797]                       }
[13:34:40.797]                       invisible(muffled)
[13:34:40.797]                     }
[13:34:40.797]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.797]                   }
[13:34:40.797]                 }
[13:34:40.797]             }
[13:34:40.797]         }))
[13:34:40.797]     }, error = function(ex) {
[13:34:40.797]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.797]                 ...future.rng), started = ...future.startTime, 
[13:34:40.797]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.797]             version = "1.8"), class = "FutureResult")
[13:34:40.797]     }, finally = {
[13:34:40.797]         if (!identical(...future.workdir, getwd())) 
[13:34:40.797]             setwd(...future.workdir)
[13:34:40.797]         {
[13:34:40.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.797]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.797]             }
[13:34:40.797]             base::options(...future.oldOptions)
[13:34:40.797]             if (.Platform$OS.type == "windows") {
[13:34:40.797]                 old_names <- names(...future.oldEnvVars)
[13:34:40.797]                 envs <- base::Sys.getenv()
[13:34:40.797]                 names <- names(envs)
[13:34:40.797]                 common <- intersect(names, old_names)
[13:34:40.797]                 added <- setdiff(names, old_names)
[13:34:40.797]                 removed <- setdiff(old_names, names)
[13:34:40.797]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.797]                   envs[common]]
[13:34:40.797]                 NAMES <- toupper(changed)
[13:34:40.797]                 args <- list()
[13:34:40.797]                 for (kk in seq_along(NAMES)) {
[13:34:40.797]                   name <- changed[[kk]]
[13:34:40.797]                   NAME <- NAMES[[kk]]
[13:34:40.797]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.797]                     next
[13:34:40.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.797]                 }
[13:34:40.797]                 NAMES <- toupper(added)
[13:34:40.797]                 for (kk in seq_along(NAMES)) {
[13:34:40.797]                   name <- added[[kk]]
[13:34:40.797]                   NAME <- NAMES[[kk]]
[13:34:40.797]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.797]                     next
[13:34:40.797]                   args[[name]] <- ""
[13:34:40.797]                 }
[13:34:40.797]                 NAMES <- toupper(removed)
[13:34:40.797]                 for (kk in seq_along(NAMES)) {
[13:34:40.797]                   name <- removed[[kk]]
[13:34:40.797]                   NAME <- NAMES[[kk]]
[13:34:40.797]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.797]                     next
[13:34:40.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.797]                 }
[13:34:40.797]                 if (length(args) > 0) 
[13:34:40.797]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.797]             }
[13:34:40.797]             else {
[13:34:40.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.797]             }
[13:34:40.797]             {
[13:34:40.797]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.797]                   0L) {
[13:34:40.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.797]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.797]                   base::options(opts)
[13:34:40.797]                 }
[13:34:40.797]                 {
[13:34:40.797]                   {
[13:34:40.797]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.797]                     NULL
[13:34:40.797]                   }
[13:34:40.797]                   options(future.plan = NULL)
[13:34:40.797]                   if (is.na(NA_character_)) 
[13:34:40.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.797]                     .init = FALSE)
[13:34:40.797]                 }
[13:34:40.797]             }
[13:34:40.797]         }
[13:34:40.797]     })
[13:34:40.797]     if (TRUE) {
[13:34:40.797]         base::sink(type = "output", split = FALSE)
[13:34:40.797]         if (TRUE) {
[13:34:40.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.797]         }
[13:34:40.797]         else {
[13:34:40.797]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.797]         }
[13:34:40.797]         base::close(...future.stdout)
[13:34:40.797]         ...future.stdout <- NULL
[13:34:40.797]     }
[13:34:40.797]     ...future.result$conditions <- ...future.conditions
[13:34:40.797]     ...future.result$finished <- base::Sys.time()
[13:34:40.797]     ...future.result
[13:34:40.797] }
[13:34:40.799] Exporting 5 global objects (2.41 KiB) to cluster node #2 ...
[13:34:40.799] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ...
[13:34:40.800] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ... DONE
[13:34:40.800] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:40.800] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.800] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ...
[13:34:40.801] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ... DONE
[13:34:40.801] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:40.801] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.801] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:40.802] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.802] Exporting 5 global objects (2.41 KiB) to cluster node #2 ... DONE
[13:34:40.802] MultisessionFuture started
[13:34:40.802] - Launch lazy future ... done
[13:34:40.802] run() for ‘MultisessionFuture’ ... done
[13:34:40.802] Created future:
[13:34:40.803] MultisessionFuture:
[13:34:40.803] Label: ‘future_Map-2’
[13:34:40.803] Expression:
[13:34:40.803] {
[13:34:40.803]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.803]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.803]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.803]         on.exit(options(oopts), add = TRUE)
[13:34:40.803]     }
[13:34:40.803]     {
[13:34:40.803]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.803]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.803]         do.call(mapply, args = args)
[13:34:40.803]     }
[13:34:40.803] }
[13:34:40.803] Lazy evaluation: FALSE
[13:34:40.803] Asynchronous evaluation: TRUE
[13:34:40.803] Local evaluation: TRUE
[13:34:40.803] Environment: R_GlobalEnv
[13:34:40.803] Capture standard output: TRUE
[13:34:40.803] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.803] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.803] Packages: 1 packages (‘stats’)
[13:34:40.803] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:40.803] Resolved: FALSE
[13:34:40.803] Value: <not collected>
[13:34:40.803] Conditions captured: <none>
[13:34:40.803] Early signaling: FALSE
[13:34:40.803] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.803] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.814] Chunk #2 of 2 ... DONE
[13:34:40.814] Launching 2 futures (chunks) ... DONE
[13:34:40.814] Resolving 2 futures (chunks) ...
[13:34:40.814] resolve() on list ...
[13:34:40.814]  recursive: 0
[13:34:40.814]  length: 2
[13:34:40.815] 
[13:34:40.815] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.815] - Validating connection of MultisessionFuture
[13:34:40.815] - received message: FutureResult
[13:34:40.815] - Received FutureResult
[13:34:40.815] - Erased future from FutureRegistry
[13:34:40.816] result() for ClusterFuture ...
[13:34:40.816] - result already collected: FutureResult
[13:34:40.816] result() for ClusterFuture ... done
[13:34:40.816] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.816] Future #1
[13:34:40.816] result() for ClusterFuture ...
[13:34:40.816] - result already collected: FutureResult
[13:34:40.816] result() for ClusterFuture ... done
[13:34:40.816] result() for ClusterFuture ...
[13:34:40.816] - result already collected: FutureResult
[13:34:40.816] result() for ClusterFuture ... done
[13:34:40.817] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:40.817] - nx: 2
[13:34:40.817] - relay: TRUE
[13:34:40.817] - stdout: TRUE
[13:34:40.817] - signal: TRUE
[13:34:40.817] - resignal: FALSE
[13:34:40.817] - force: TRUE
[13:34:40.817] - relayed: [n=2] FALSE, FALSE
[13:34:40.817] - queued futures: [n=2] FALSE, FALSE
[13:34:40.817]  - until=1
[13:34:40.817]  - relaying element #1
[13:34:40.817] result() for ClusterFuture ...
[13:34:40.818] - result already collected: FutureResult
[13:34:40.818] result() for ClusterFuture ... done
[13:34:40.818] result() for ClusterFuture ...
[13:34:40.818] - result already collected: FutureResult
[13:34:40.818] result() for ClusterFuture ... done
[13:34:40.818] result() for ClusterFuture ...
[13:34:40.818] - result already collected: FutureResult
[13:34:40.818] result() for ClusterFuture ... done
[13:34:40.818] result() for ClusterFuture ...
[13:34:40.818] - result already collected: FutureResult
[13:34:40.819] result() for ClusterFuture ... done
[13:34:40.819] - relayed: [n=2] TRUE, FALSE
[13:34:40.819] - queued futures: [n=2] TRUE, FALSE
[13:34:40.819] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:40.819]  length: 1 (resolved future 1)
[13:34:40.844] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.844] - Validating connection of MultisessionFuture
[13:34:40.844] - received message: FutureResult
[13:34:40.844] - Received FutureResult
[13:34:40.845] - Erased future from FutureRegistry
[13:34:40.845] result() for ClusterFuture ...
[13:34:40.845] - result already collected: FutureResult
[13:34:40.845] result() for ClusterFuture ... done
[13:34:40.845] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.845] Future #2
[13:34:40.845] result() for ClusterFuture ...
[13:34:40.845] - result already collected: FutureResult
[13:34:40.845] result() for ClusterFuture ... done
[13:34:40.845] result() for ClusterFuture ...
[13:34:40.846] - result already collected: FutureResult
[13:34:40.846] result() for ClusterFuture ... done
[13:34:40.846] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:40.846] - nx: 2
[13:34:40.846] - relay: TRUE
[13:34:40.846] - stdout: TRUE
[13:34:40.846] - signal: TRUE
[13:34:40.846] - resignal: FALSE
[13:34:40.846] - force: TRUE
[13:34:40.846] - relayed: [n=2] TRUE, FALSE
[13:34:40.846] - queued futures: [n=2] TRUE, FALSE
[13:34:40.847]  - until=2
[13:34:40.847]  - relaying element #2
[13:34:40.847] result() for ClusterFuture ...
[13:34:40.847] - result already collected: FutureResult
[13:34:40.847] result() for ClusterFuture ... done
[13:34:40.847] result() for ClusterFuture ...
[13:34:40.847] - result already collected: FutureResult
[13:34:40.847] result() for ClusterFuture ... done
[13:34:40.847] result() for ClusterFuture ...
[13:34:40.847] - result already collected: FutureResult
[13:34:40.847] result() for ClusterFuture ... done
[13:34:40.848] result() for ClusterFuture ...
[13:34:40.848] - result already collected: FutureResult
[13:34:40.848] result() for ClusterFuture ... done
[13:34:40.848] - relayed: [n=2] TRUE, TRUE
[13:34:40.848] - queued futures: [n=2] TRUE, TRUE
[13:34:40.848] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:40.848]  length: 0 (resolved future 2)
[13:34:40.848] Relaying remaining futures
[13:34:40.848] signalConditionsASAP(NULL, pos=0) ...
[13:34:40.848] - nx: 2
[13:34:40.848] - relay: TRUE
[13:34:40.848] - stdout: TRUE
[13:34:40.849] - signal: TRUE
[13:34:40.849] - resignal: FALSE
[13:34:40.849] - force: TRUE
[13:34:40.849] - relayed: [n=2] TRUE, TRUE
[13:34:40.849] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:40.849] - relayed: [n=2] TRUE, TRUE
[13:34:40.849] - queued futures: [n=2] TRUE, TRUE
[13:34:40.849] signalConditionsASAP(NULL, pos=0) ... done
[13:34:40.849] resolve() on list ... DONE
[13:34:40.849] result() for ClusterFuture ...
[13:34:40.849] - result already collected: FutureResult
[13:34:40.849] result() for ClusterFuture ... done
[13:34:40.850] result() for ClusterFuture ...
[13:34:40.850] - result already collected: FutureResult
[13:34:40.850] result() for ClusterFuture ... done
[13:34:40.850] result() for ClusterFuture ...
[13:34:40.850] - result already collected: FutureResult
[13:34:40.850] result() for ClusterFuture ... done
[13:34:40.850] result() for ClusterFuture ...
[13:34:40.850] - result already collected: FutureResult
[13:34:40.850] result() for ClusterFuture ... done
[13:34:40.850]  - Number of value chunks collected: 2
[13:34:40.850] Resolving 2 futures (chunks) ... DONE
[13:34:40.851] Reducing values from 2 chunks ...
[13:34:40.851]  - Number of values collected after concatenation: 5
[13:34:40.851]  - Number of values expected: 5
[13:34:40.851] Reducing values from 2 chunks ... DONE
[13:34:40.851] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[13:34:40.853] future_mapply() ...
[13:34:40.856] Number of chunks: 2
[13:34:40.857] getGlobalsAndPackagesXApply() ...
[13:34:40.857]  - future.globals: TRUE
[13:34:40.857] getGlobalsAndPackages() ...
[13:34:40.857] Searching for globals...
[13:34:40.858] - globals found: [1] ‘FUN’
[13:34:40.858] Searching for globals ... DONE
[13:34:40.858] Resolving globals: FALSE
[13:34:40.858] The total size of the 1 globals is 56 bytes (56 bytes)
[13:34:40.859] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[13:34:40.859] - globals: [1] ‘FUN’
[13:34:40.859] 
[13:34:40.859] getGlobalsAndPackages() ... DONE
[13:34:40.859]  - globals found/used: [n=1] ‘FUN’
[13:34:40.859]  - needed namespaces: [n=0] 
[13:34:40.859] Finding globals ... DONE
[13:34:40.859] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:40.862] List of 2
[13:34:40.862]  $ ...future.FUN:function (e1, e2)  
[13:34:40.862]  $ MoreArgs     : NULL
[13:34:40.862]  - attr(*, "where")=List of 2
[13:34:40.862]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:40.862]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:40.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:40.862]  - attr(*, "resolved")= logi FALSE
[13:34:40.862]  - attr(*, "total_size")= num NA
[13:34:40.865] Packages to be attached in all futures: [n=0] 
[13:34:40.865] getGlobalsAndPackagesXApply() ... DONE
[13:34:40.865] Number of futures (= number of chunks): 2
[13:34:40.866] Launching 2 futures (chunks) ...
[13:34:40.866] Chunk #1 of 2 ...
[13:34:40.866]  - Finding globals in '...' for chunk #1 ...
[13:34:40.866] getGlobalsAndPackages() ...
[13:34:40.866] Searching for globals...
[13:34:40.866] 
[13:34:40.866] Searching for globals ... DONE
[13:34:40.866] - globals: [0] <none>
[13:34:40.867] getGlobalsAndPackages() ... DONE
[13:34:40.867]    + additional globals found: [n=0] 
[13:34:40.867]    + additional namespaces needed: [n=0] 
[13:34:40.867]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:40.867]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.867]  - seeds: <none>
[13:34:40.867]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.867] getGlobalsAndPackages() ...
[13:34:40.867] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.867] Resolving globals: FALSE
[13:34:40.868] The total size of the 5 globals is 168 bytes (168 bytes)
[13:34:40.868] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:40.868] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.869] 
[13:34:40.869] getGlobalsAndPackages() ... DONE
[13:34:40.869] run() for ‘Future’ ...
[13:34:40.869] - state: ‘created’
[13:34:40.869] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.883] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.883] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.883]   - Field: ‘node’
[13:34:40.883]   - Field: ‘label’
[13:34:40.884]   - Field: ‘local’
[13:34:40.884]   - Field: ‘owner’
[13:34:40.884]   - Field: ‘envir’
[13:34:40.884]   - Field: ‘workers’
[13:34:40.884]   - Field: ‘packages’
[13:34:40.884]   - Field: ‘gc’
[13:34:40.884]   - Field: ‘conditions’
[13:34:40.884]   - Field: ‘persistent’
[13:34:40.884]   - Field: ‘expr’
[13:34:40.884]   - Field: ‘uuid’
[13:34:40.884]   - Field: ‘seed’
[13:34:40.885]   - Field: ‘version’
[13:34:40.885]   - Field: ‘result’
[13:34:40.885]   - Field: ‘asynchronous’
[13:34:40.885]   - Field: ‘calls’
[13:34:40.885]   - Field: ‘globals’
[13:34:40.885]   - Field: ‘stdout’
[13:34:40.885]   - Field: ‘earlySignal’
[13:34:40.885]   - Field: ‘lazy’
[13:34:40.885]   - Field: ‘state’
[13:34:40.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.885] - Launch lazy future ...
[13:34:40.886] Packages needed by the future expression (n = 0): <none>
[13:34:40.886] Packages needed by future strategies (n = 0): <none>
[13:34:40.886] {
[13:34:40.886]     {
[13:34:40.886]         {
[13:34:40.886]             ...future.startTime <- base::Sys.time()
[13:34:40.886]             {
[13:34:40.886]                 {
[13:34:40.886]                   {
[13:34:40.886]                     {
[13:34:40.886]                       base::local({
[13:34:40.886]                         has_future <- base::requireNamespace("future", 
[13:34:40.886]                           quietly = TRUE)
[13:34:40.886]                         if (has_future) {
[13:34:40.886]                           ns <- base::getNamespace("future")
[13:34:40.886]                           version <- ns[[".package"]][["version"]]
[13:34:40.886]                           if (is.null(version)) 
[13:34:40.886]                             version <- utils::packageVersion("future")
[13:34:40.886]                         }
[13:34:40.886]                         else {
[13:34:40.886]                           version <- NULL
[13:34:40.886]                         }
[13:34:40.886]                         if (!has_future || version < "1.8.0") {
[13:34:40.886]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.886]                             "", base::R.version$version.string), 
[13:34:40.886]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:40.886]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:40.886]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.886]                               "release", "version")], collapse = " "), 
[13:34:40.886]                             hostname = base::Sys.info()[["nodename"]])
[13:34:40.886]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.886]                             info)
[13:34:40.886]                           info <- base::paste(info, collapse = "; ")
[13:34:40.886]                           if (!has_future) {
[13:34:40.886]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.886]                               info)
[13:34:40.886]                           }
[13:34:40.886]                           else {
[13:34:40.886]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.886]                               info, version)
[13:34:40.886]                           }
[13:34:40.886]                           base::stop(msg)
[13:34:40.886]                         }
[13:34:40.886]                       })
[13:34:40.886]                     }
[13:34:40.886]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.886]                     base::options(mc.cores = 1L)
[13:34:40.886]                   }
[13:34:40.886]                   ...future.strategy.old <- future::plan("list")
[13:34:40.886]                   options(future.plan = NULL)
[13:34:40.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.886]                 }
[13:34:40.886]                 ...future.workdir <- getwd()
[13:34:40.886]             }
[13:34:40.886]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.886]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.886]         }
[13:34:40.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.886]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.886]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.886]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.886]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.886]             base::names(...future.oldOptions))
[13:34:40.886]     }
[13:34:40.886]     if (FALSE) {
[13:34:40.886]     }
[13:34:40.886]     else {
[13:34:40.886]         if (TRUE) {
[13:34:40.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.886]                 open = "w")
[13:34:40.886]         }
[13:34:40.886]         else {
[13:34:40.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.886]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.886]         }
[13:34:40.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.886]             base::sink(type = "output", split = FALSE)
[13:34:40.886]             base::close(...future.stdout)
[13:34:40.886]         }, add = TRUE)
[13:34:40.886]     }
[13:34:40.886]     ...future.frame <- base::sys.nframe()
[13:34:40.886]     ...future.conditions <- base::list()
[13:34:40.886]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.886]     if (FALSE) {
[13:34:40.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.886]     }
[13:34:40.886]     ...future.result <- base::tryCatch({
[13:34:40.886]         base::withCallingHandlers({
[13:34:40.886]             ...future.value <- base::withVisible(base::local({
[13:34:40.886]                 ...future.makeSendCondition <- base::local({
[13:34:40.886]                   sendCondition <- NULL
[13:34:40.886]                   function(frame = 1L) {
[13:34:40.886]                     if (is.function(sendCondition)) 
[13:34:40.886]                       return(sendCondition)
[13:34:40.886]                     ns <- getNamespace("parallel")
[13:34:40.886]                     if (exists("sendData", mode = "function", 
[13:34:40.886]                       envir = ns)) {
[13:34:40.886]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.886]                         envir = ns)
[13:34:40.886]                       envir <- sys.frame(frame)
[13:34:40.886]                       master <- NULL
[13:34:40.886]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.886]                         !identical(envir, emptyenv())) {
[13:34:40.886]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.886]                           inherits = FALSE)) {
[13:34:40.886]                           master <- get("master", mode = "list", 
[13:34:40.886]                             envir = envir, inherits = FALSE)
[13:34:40.886]                           if (inherits(master, c("SOCKnode", 
[13:34:40.886]                             "SOCK0node"))) {
[13:34:40.886]                             sendCondition <<- function(cond) {
[13:34:40.886]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.886]                                 success = TRUE)
[13:34:40.886]                               parallel_sendData(master, data)
[13:34:40.886]                             }
[13:34:40.886]                             return(sendCondition)
[13:34:40.886]                           }
[13:34:40.886]                         }
[13:34:40.886]                         frame <- frame + 1L
[13:34:40.886]                         envir <- sys.frame(frame)
[13:34:40.886]                       }
[13:34:40.886]                     }
[13:34:40.886]                     sendCondition <<- function(cond) NULL
[13:34:40.886]                   }
[13:34:40.886]                 })
[13:34:40.886]                 withCallingHandlers({
[13:34:40.886]                   {
[13:34:40.886]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.886]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.886]                       ...future.globals.maxSize)) {
[13:34:40.886]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.886]                       on.exit(options(oopts), add = TRUE)
[13:34:40.886]                     }
[13:34:40.886]                     {
[13:34:40.886]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.886]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.886]                         USE.NAMES = FALSE)
[13:34:40.886]                       do.call(mapply, args = args)
[13:34:40.886]                     }
[13:34:40.886]                   }
[13:34:40.886]                 }, immediateCondition = function(cond) {
[13:34:40.886]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.886]                   sendCondition(cond)
[13:34:40.886]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.886]                   {
[13:34:40.886]                     inherits <- base::inherits
[13:34:40.886]                     invokeRestart <- base::invokeRestart
[13:34:40.886]                     is.null <- base::is.null
[13:34:40.886]                     muffled <- FALSE
[13:34:40.886]                     if (inherits(cond, "message")) {
[13:34:40.886]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.886]                       if (muffled) 
[13:34:40.886]                         invokeRestart("muffleMessage")
[13:34:40.886]                     }
[13:34:40.886]                     else if (inherits(cond, "warning")) {
[13:34:40.886]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.886]                       if (muffled) 
[13:34:40.886]                         invokeRestart("muffleWarning")
[13:34:40.886]                     }
[13:34:40.886]                     else if (inherits(cond, "condition")) {
[13:34:40.886]                       if (!is.null(pattern)) {
[13:34:40.886]                         computeRestarts <- base::computeRestarts
[13:34:40.886]                         grepl <- base::grepl
[13:34:40.886]                         restarts <- computeRestarts(cond)
[13:34:40.886]                         for (restart in restarts) {
[13:34:40.886]                           name <- restart$name
[13:34:40.886]                           if (is.null(name)) 
[13:34:40.886]                             next
[13:34:40.886]                           if (!grepl(pattern, name)) 
[13:34:40.886]                             next
[13:34:40.886]                           invokeRestart(restart)
[13:34:40.886]                           muffled <- TRUE
[13:34:40.886]                           break
[13:34:40.886]                         }
[13:34:40.886]                       }
[13:34:40.886]                     }
[13:34:40.886]                     invisible(muffled)
[13:34:40.886]                   }
[13:34:40.886]                   muffleCondition(cond)
[13:34:40.886]                 })
[13:34:40.886]             }))
[13:34:40.886]             future::FutureResult(value = ...future.value$value, 
[13:34:40.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.886]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.886]                     ...future.globalenv.names))
[13:34:40.886]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.886]         }, condition = base::local({
[13:34:40.886]             c <- base::c
[13:34:40.886]             inherits <- base::inherits
[13:34:40.886]             invokeRestart <- base::invokeRestart
[13:34:40.886]             length <- base::length
[13:34:40.886]             list <- base::list
[13:34:40.886]             seq.int <- base::seq.int
[13:34:40.886]             signalCondition <- base::signalCondition
[13:34:40.886]             sys.calls <- base::sys.calls
[13:34:40.886]             `[[` <- base::`[[`
[13:34:40.886]             `+` <- base::`+`
[13:34:40.886]             `<<-` <- base::`<<-`
[13:34:40.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.886]                   3L)]
[13:34:40.886]             }
[13:34:40.886]             function(cond) {
[13:34:40.886]                 is_error <- inherits(cond, "error")
[13:34:40.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.886]                   NULL)
[13:34:40.886]                 if (is_error) {
[13:34:40.886]                   sessionInformation <- function() {
[13:34:40.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.886]                       search = base::search(), system = base::Sys.info())
[13:34:40.886]                   }
[13:34:40.886]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.886]                     cond$call), session = sessionInformation(), 
[13:34:40.886]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.886]                   signalCondition(cond)
[13:34:40.886]                 }
[13:34:40.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.886]                 "immediateCondition"))) {
[13:34:40.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.886]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.886]                   if (TRUE && !signal) {
[13:34:40.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.886]                     {
[13:34:40.886]                       inherits <- base::inherits
[13:34:40.886]                       invokeRestart <- base::invokeRestart
[13:34:40.886]                       is.null <- base::is.null
[13:34:40.886]                       muffled <- FALSE
[13:34:40.886]                       if (inherits(cond, "message")) {
[13:34:40.886]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.886]                         if (muffled) 
[13:34:40.886]                           invokeRestart("muffleMessage")
[13:34:40.886]                       }
[13:34:40.886]                       else if (inherits(cond, "warning")) {
[13:34:40.886]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.886]                         if (muffled) 
[13:34:40.886]                           invokeRestart("muffleWarning")
[13:34:40.886]                       }
[13:34:40.886]                       else if (inherits(cond, "condition")) {
[13:34:40.886]                         if (!is.null(pattern)) {
[13:34:40.886]                           computeRestarts <- base::computeRestarts
[13:34:40.886]                           grepl <- base::grepl
[13:34:40.886]                           restarts <- computeRestarts(cond)
[13:34:40.886]                           for (restart in restarts) {
[13:34:40.886]                             name <- restart$name
[13:34:40.886]                             if (is.null(name)) 
[13:34:40.886]                               next
[13:34:40.886]                             if (!grepl(pattern, name)) 
[13:34:40.886]                               next
[13:34:40.886]                             invokeRestart(restart)
[13:34:40.886]                             muffled <- TRUE
[13:34:40.886]                             break
[13:34:40.886]                           }
[13:34:40.886]                         }
[13:34:40.886]                       }
[13:34:40.886]                       invisible(muffled)
[13:34:40.886]                     }
[13:34:40.886]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.886]                   }
[13:34:40.886]                 }
[13:34:40.886]                 else {
[13:34:40.886]                   if (TRUE) {
[13:34:40.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.886]                     {
[13:34:40.886]                       inherits <- base::inherits
[13:34:40.886]                       invokeRestart <- base::invokeRestart
[13:34:40.886]                       is.null <- base::is.null
[13:34:40.886]                       muffled <- FALSE
[13:34:40.886]                       if (inherits(cond, "message")) {
[13:34:40.886]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.886]                         if (muffled) 
[13:34:40.886]                           invokeRestart("muffleMessage")
[13:34:40.886]                       }
[13:34:40.886]                       else if (inherits(cond, "warning")) {
[13:34:40.886]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.886]                         if (muffled) 
[13:34:40.886]                           invokeRestart("muffleWarning")
[13:34:40.886]                       }
[13:34:40.886]                       else if (inherits(cond, "condition")) {
[13:34:40.886]                         if (!is.null(pattern)) {
[13:34:40.886]                           computeRestarts <- base::computeRestarts
[13:34:40.886]                           grepl <- base::grepl
[13:34:40.886]                           restarts <- computeRestarts(cond)
[13:34:40.886]                           for (restart in restarts) {
[13:34:40.886]                             name <- restart$name
[13:34:40.886]                             if (is.null(name)) 
[13:34:40.886]                               next
[13:34:40.886]                             if (!grepl(pattern, name)) 
[13:34:40.886]                               next
[13:34:40.886]                             invokeRestart(restart)
[13:34:40.886]                             muffled <- TRUE
[13:34:40.886]                             break
[13:34:40.886]                           }
[13:34:40.886]                         }
[13:34:40.886]                       }
[13:34:40.886]                       invisible(muffled)
[13:34:40.886]                     }
[13:34:40.886]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.886]                   }
[13:34:40.886]                 }
[13:34:40.886]             }
[13:34:40.886]         }))
[13:34:40.886]     }, error = function(ex) {
[13:34:40.886]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.886]                 ...future.rng), started = ...future.startTime, 
[13:34:40.886]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.886]             version = "1.8"), class = "FutureResult")
[13:34:40.886]     }, finally = {
[13:34:40.886]         if (!identical(...future.workdir, getwd())) 
[13:34:40.886]             setwd(...future.workdir)
[13:34:40.886]         {
[13:34:40.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.886]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.886]             }
[13:34:40.886]             base::options(...future.oldOptions)
[13:34:40.886]             if (.Platform$OS.type == "windows") {
[13:34:40.886]                 old_names <- names(...future.oldEnvVars)
[13:34:40.886]                 envs <- base::Sys.getenv()
[13:34:40.886]                 names <- names(envs)
[13:34:40.886]                 common <- intersect(names, old_names)
[13:34:40.886]                 added <- setdiff(names, old_names)
[13:34:40.886]                 removed <- setdiff(old_names, names)
[13:34:40.886]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.886]                   envs[common]]
[13:34:40.886]                 NAMES <- toupper(changed)
[13:34:40.886]                 args <- list()
[13:34:40.886]                 for (kk in seq_along(NAMES)) {
[13:34:40.886]                   name <- changed[[kk]]
[13:34:40.886]                   NAME <- NAMES[[kk]]
[13:34:40.886]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.886]                     next
[13:34:40.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.886]                 }
[13:34:40.886]                 NAMES <- toupper(added)
[13:34:40.886]                 for (kk in seq_along(NAMES)) {
[13:34:40.886]                   name <- added[[kk]]
[13:34:40.886]                   NAME <- NAMES[[kk]]
[13:34:40.886]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.886]                     next
[13:34:40.886]                   args[[name]] <- ""
[13:34:40.886]                 }
[13:34:40.886]                 NAMES <- toupper(removed)
[13:34:40.886]                 for (kk in seq_along(NAMES)) {
[13:34:40.886]                   name <- removed[[kk]]
[13:34:40.886]                   NAME <- NAMES[[kk]]
[13:34:40.886]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.886]                     next
[13:34:40.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.886]                 }
[13:34:40.886]                 if (length(args) > 0) 
[13:34:40.886]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.886]             }
[13:34:40.886]             else {
[13:34:40.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.886]             }
[13:34:40.886]             {
[13:34:40.886]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.886]                   0L) {
[13:34:40.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.886]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.886]                   base::options(opts)
[13:34:40.886]                 }
[13:34:40.886]                 {
[13:34:40.886]                   {
[13:34:40.886]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.886]                     NULL
[13:34:40.886]                   }
[13:34:40.886]                   options(future.plan = NULL)
[13:34:40.886]                   if (is.na(NA_character_)) 
[13:34:40.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.886]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.886]                     .init = FALSE)
[13:34:40.886]                 }
[13:34:40.886]             }
[13:34:40.886]         }
[13:34:40.886]     })
[13:34:40.886]     if (TRUE) {
[13:34:40.886]         base::sink(type = "output", split = FALSE)
[13:34:40.886]         if (TRUE) {
[13:34:40.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.886]         }
[13:34:40.886]         else {
[13:34:40.886]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.886]         }
[13:34:40.886]         base::close(...future.stdout)
[13:34:40.886]         ...future.stdout <- NULL
[13:34:40.886]     }
[13:34:40.886]     ...future.result$conditions <- ...future.conditions
[13:34:40.886]     ...future.result$finished <- base::Sys.time()
[13:34:40.886]     ...future.result
[13:34:40.886] }
[13:34:40.889] Exporting 5 global objects (168 bytes) to cluster node #1 ...
[13:34:40.889] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[13:34:40.889] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[13:34:40.889] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:40.890] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.890] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:34:40.890] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:34:40.890] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:40.891] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.891] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:40.891] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:40.891] Exporting 5 global objects (168 bytes) to cluster node #1 ... DONE
[13:34:40.892] MultisessionFuture started
[13:34:40.892] - Launch lazy future ... done
[13:34:40.892] run() for ‘MultisessionFuture’ ... done
[13:34:40.892] Created future:
[13:34:40.892] MultisessionFuture:
[13:34:40.892] Label: ‘future_Map-1’
[13:34:40.892] Expression:
[13:34:40.892] {
[13:34:40.892]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.892]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.892]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.892]         on.exit(options(oopts), add = TRUE)
[13:34:40.892]     }
[13:34:40.892]     {
[13:34:40.892]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.892]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.892]         do.call(mapply, args = args)
[13:34:40.892]     }
[13:34:40.892] }
[13:34:40.892] Lazy evaluation: FALSE
[13:34:40.892] Asynchronous evaluation: TRUE
[13:34:40.892] Local evaluation: TRUE
[13:34:40.892] Environment: R_GlobalEnv
[13:34:40.892] Capture standard output: TRUE
[13:34:40.892] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.892] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.892] Packages: <none>
[13:34:40.892] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:40.892] Resolved: FALSE
[13:34:40.892] Value: <not collected>
[13:34:40.892] Conditions captured: <none>
[13:34:40.892] Early signaling: FALSE
[13:34:40.892] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.892] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.903] Chunk #1 of 2 ... DONE
[13:34:40.903] Chunk #2 of 2 ...
[13:34:40.904]  - Finding globals in '...' for chunk #2 ...
[13:34:40.904] getGlobalsAndPackages() ...
[13:34:40.904] Searching for globals...
[13:34:40.904] 
[13:34:40.904] Searching for globals ... DONE
[13:34:40.904] - globals: [0] <none>
[13:34:40.904] getGlobalsAndPackages() ... DONE
[13:34:40.904]    + additional globals found: [n=0] 
[13:34:40.904]    + additional namespaces needed: [n=0] 
[13:34:40.905]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:40.905]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.905]  - seeds: <none>
[13:34:40.905]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.905] getGlobalsAndPackages() ...
[13:34:40.905] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.905] Resolving globals: FALSE
[13:34:40.906] The total size of the 5 globals is 280 bytes (280 bytes)
[13:34:40.906] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:40.906] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.906] 
[13:34:40.906] getGlobalsAndPackages() ... DONE
[13:34:40.907] run() for ‘Future’ ...
[13:34:40.907] - state: ‘created’
[13:34:40.907] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:40.921] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.921] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:40.921]   - Field: ‘node’
[13:34:40.921]   - Field: ‘label’
[13:34:40.922]   - Field: ‘local’
[13:34:40.922]   - Field: ‘owner’
[13:34:40.922]   - Field: ‘envir’
[13:34:40.922]   - Field: ‘workers’
[13:34:40.922]   - Field: ‘packages’
[13:34:40.922]   - Field: ‘gc’
[13:34:40.922]   - Field: ‘conditions’
[13:34:40.922]   - Field: ‘persistent’
[13:34:40.922]   - Field: ‘expr’
[13:34:40.922]   - Field: ‘uuid’
[13:34:40.923]   - Field: ‘seed’
[13:34:40.923]   - Field: ‘version’
[13:34:40.923]   - Field: ‘result’
[13:34:40.923]   - Field: ‘asynchronous’
[13:34:40.923]   - Field: ‘calls’
[13:34:40.923]   - Field: ‘globals’
[13:34:40.923]   - Field: ‘stdout’
[13:34:40.923]   - Field: ‘earlySignal’
[13:34:40.923]   - Field: ‘lazy’
[13:34:40.923]   - Field: ‘state’
[13:34:40.923] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:40.924] - Launch lazy future ...
[13:34:40.924] Packages needed by the future expression (n = 0): <none>
[13:34:40.924] Packages needed by future strategies (n = 0): <none>
[13:34:40.924] {
[13:34:40.924]     {
[13:34:40.924]         {
[13:34:40.924]             ...future.startTime <- base::Sys.time()
[13:34:40.924]             {
[13:34:40.924]                 {
[13:34:40.924]                   {
[13:34:40.924]                     {
[13:34:40.924]                       base::local({
[13:34:40.924]                         has_future <- base::requireNamespace("future", 
[13:34:40.924]                           quietly = TRUE)
[13:34:40.924]                         if (has_future) {
[13:34:40.924]                           ns <- base::getNamespace("future")
[13:34:40.924]                           version <- ns[[".package"]][["version"]]
[13:34:40.924]                           if (is.null(version)) 
[13:34:40.924]                             version <- utils::packageVersion("future")
[13:34:40.924]                         }
[13:34:40.924]                         else {
[13:34:40.924]                           version <- NULL
[13:34:40.924]                         }
[13:34:40.924]                         if (!has_future || version < "1.8.0") {
[13:34:40.924]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:40.924]                             "", base::R.version$version.string), 
[13:34:40.924]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:40.924]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:40.924]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:40.924]                               "release", "version")], collapse = " "), 
[13:34:40.924]                             hostname = base::Sys.info()[["nodename"]])
[13:34:40.924]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:40.924]                             info)
[13:34:40.924]                           info <- base::paste(info, collapse = "; ")
[13:34:40.924]                           if (!has_future) {
[13:34:40.924]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:40.924]                               info)
[13:34:40.924]                           }
[13:34:40.924]                           else {
[13:34:40.924]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:40.924]                               info, version)
[13:34:40.924]                           }
[13:34:40.924]                           base::stop(msg)
[13:34:40.924]                         }
[13:34:40.924]                       })
[13:34:40.924]                     }
[13:34:40.924]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:40.924]                     base::options(mc.cores = 1L)
[13:34:40.924]                   }
[13:34:40.924]                   ...future.strategy.old <- future::plan("list")
[13:34:40.924]                   options(future.plan = NULL)
[13:34:40.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:40.924]                 }
[13:34:40.924]                 ...future.workdir <- getwd()
[13:34:40.924]             }
[13:34:40.924]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:40.924]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:40.924]         }
[13:34:40.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:40.924]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:40.924]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:40.924]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:40.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:40.924]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:40.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:40.924]             base::names(...future.oldOptions))
[13:34:40.924]     }
[13:34:40.924]     if (FALSE) {
[13:34:40.924]     }
[13:34:40.924]     else {
[13:34:40.924]         if (TRUE) {
[13:34:40.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:40.924]                 open = "w")
[13:34:40.924]         }
[13:34:40.924]         else {
[13:34:40.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:40.924]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:40.924]         }
[13:34:40.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:40.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:40.924]             base::sink(type = "output", split = FALSE)
[13:34:40.924]             base::close(...future.stdout)
[13:34:40.924]         }, add = TRUE)
[13:34:40.924]     }
[13:34:40.924]     ...future.frame <- base::sys.nframe()
[13:34:40.924]     ...future.conditions <- base::list()
[13:34:40.924]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:40.924]     if (FALSE) {
[13:34:40.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:40.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:40.924]     }
[13:34:40.924]     ...future.result <- base::tryCatch({
[13:34:40.924]         base::withCallingHandlers({
[13:34:40.924]             ...future.value <- base::withVisible(base::local({
[13:34:40.924]                 ...future.makeSendCondition <- base::local({
[13:34:40.924]                   sendCondition <- NULL
[13:34:40.924]                   function(frame = 1L) {
[13:34:40.924]                     if (is.function(sendCondition)) 
[13:34:40.924]                       return(sendCondition)
[13:34:40.924]                     ns <- getNamespace("parallel")
[13:34:40.924]                     if (exists("sendData", mode = "function", 
[13:34:40.924]                       envir = ns)) {
[13:34:40.924]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:40.924]                         envir = ns)
[13:34:40.924]                       envir <- sys.frame(frame)
[13:34:40.924]                       master <- NULL
[13:34:40.924]                       while (!identical(envir, .GlobalEnv) && 
[13:34:40.924]                         !identical(envir, emptyenv())) {
[13:34:40.924]                         if (exists("master", mode = "list", envir = envir, 
[13:34:40.924]                           inherits = FALSE)) {
[13:34:40.924]                           master <- get("master", mode = "list", 
[13:34:40.924]                             envir = envir, inherits = FALSE)
[13:34:40.924]                           if (inherits(master, c("SOCKnode", 
[13:34:40.924]                             "SOCK0node"))) {
[13:34:40.924]                             sendCondition <<- function(cond) {
[13:34:40.924]                               data <- list(type = "VALUE", value = cond, 
[13:34:40.924]                                 success = TRUE)
[13:34:40.924]                               parallel_sendData(master, data)
[13:34:40.924]                             }
[13:34:40.924]                             return(sendCondition)
[13:34:40.924]                           }
[13:34:40.924]                         }
[13:34:40.924]                         frame <- frame + 1L
[13:34:40.924]                         envir <- sys.frame(frame)
[13:34:40.924]                       }
[13:34:40.924]                     }
[13:34:40.924]                     sendCondition <<- function(cond) NULL
[13:34:40.924]                   }
[13:34:40.924]                 })
[13:34:40.924]                 withCallingHandlers({
[13:34:40.924]                   {
[13:34:40.924]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.924]                     if (!identical(...future.globals.maxSize.org, 
[13:34:40.924]                       ...future.globals.maxSize)) {
[13:34:40.924]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.924]                       on.exit(options(oopts), add = TRUE)
[13:34:40.924]                     }
[13:34:40.924]                     {
[13:34:40.924]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.924]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:40.924]                         USE.NAMES = FALSE)
[13:34:40.924]                       do.call(mapply, args = args)
[13:34:40.924]                     }
[13:34:40.924]                   }
[13:34:40.924]                 }, immediateCondition = function(cond) {
[13:34:40.924]                   sendCondition <- ...future.makeSendCondition()
[13:34:40.924]                   sendCondition(cond)
[13:34:40.924]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.924]                   {
[13:34:40.924]                     inherits <- base::inherits
[13:34:40.924]                     invokeRestart <- base::invokeRestart
[13:34:40.924]                     is.null <- base::is.null
[13:34:40.924]                     muffled <- FALSE
[13:34:40.924]                     if (inherits(cond, "message")) {
[13:34:40.924]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:40.924]                       if (muffled) 
[13:34:40.924]                         invokeRestart("muffleMessage")
[13:34:40.924]                     }
[13:34:40.924]                     else if (inherits(cond, "warning")) {
[13:34:40.924]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:40.924]                       if (muffled) 
[13:34:40.924]                         invokeRestart("muffleWarning")
[13:34:40.924]                     }
[13:34:40.924]                     else if (inherits(cond, "condition")) {
[13:34:40.924]                       if (!is.null(pattern)) {
[13:34:40.924]                         computeRestarts <- base::computeRestarts
[13:34:40.924]                         grepl <- base::grepl
[13:34:40.924]                         restarts <- computeRestarts(cond)
[13:34:40.924]                         for (restart in restarts) {
[13:34:40.924]                           name <- restart$name
[13:34:40.924]                           if (is.null(name)) 
[13:34:40.924]                             next
[13:34:40.924]                           if (!grepl(pattern, name)) 
[13:34:40.924]                             next
[13:34:40.924]                           invokeRestart(restart)
[13:34:40.924]                           muffled <- TRUE
[13:34:40.924]                           break
[13:34:40.924]                         }
[13:34:40.924]                       }
[13:34:40.924]                     }
[13:34:40.924]                     invisible(muffled)
[13:34:40.924]                   }
[13:34:40.924]                   muffleCondition(cond)
[13:34:40.924]                 })
[13:34:40.924]             }))
[13:34:40.924]             future::FutureResult(value = ...future.value$value, 
[13:34:40.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.924]                   ...future.rng), globalenv = if (FALSE) 
[13:34:40.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:40.924]                     ...future.globalenv.names))
[13:34:40.924]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:40.924]         }, condition = base::local({
[13:34:40.924]             c <- base::c
[13:34:40.924]             inherits <- base::inherits
[13:34:40.924]             invokeRestart <- base::invokeRestart
[13:34:40.924]             length <- base::length
[13:34:40.924]             list <- base::list
[13:34:40.924]             seq.int <- base::seq.int
[13:34:40.924]             signalCondition <- base::signalCondition
[13:34:40.924]             sys.calls <- base::sys.calls
[13:34:40.924]             `[[` <- base::`[[`
[13:34:40.924]             `+` <- base::`+`
[13:34:40.924]             `<<-` <- base::`<<-`
[13:34:40.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:40.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:40.924]                   3L)]
[13:34:40.924]             }
[13:34:40.924]             function(cond) {
[13:34:40.924]                 is_error <- inherits(cond, "error")
[13:34:40.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:40.924]                   NULL)
[13:34:40.924]                 if (is_error) {
[13:34:40.924]                   sessionInformation <- function() {
[13:34:40.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:40.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:40.924]                       search = base::search(), system = base::Sys.info())
[13:34:40.924]                   }
[13:34:40.924]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:40.924]                     cond$call), session = sessionInformation(), 
[13:34:40.924]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:40.924]                   signalCondition(cond)
[13:34:40.924]                 }
[13:34:40.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:40.924]                 "immediateCondition"))) {
[13:34:40.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:40.924]                   ...future.conditions[[length(...future.conditions) + 
[13:34:40.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:40.924]                   if (TRUE && !signal) {
[13:34:40.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.924]                     {
[13:34:40.924]                       inherits <- base::inherits
[13:34:40.924]                       invokeRestart <- base::invokeRestart
[13:34:40.924]                       is.null <- base::is.null
[13:34:40.924]                       muffled <- FALSE
[13:34:40.924]                       if (inherits(cond, "message")) {
[13:34:40.924]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.924]                         if (muffled) 
[13:34:40.924]                           invokeRestart("muffleMessage")
[13:34:40.924]                       }
[13:34:40.924]                       else if (inherits(cond, "warning")) {
[13:34:40.924]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.924]                         if (muffled) 
[13:34:40.924]                           invokeRestart("muffleWarning")
[13:34:40.924]                       }
[13:34:40.924]                       else if (inherits(cond, "condition")) {
[13:34:40.924]                         if (!is.null(pattern)) {
[13:34:40.924]                           computeRestarts <- base::computeRestarts
[13:34:40.924]                           grepl <- base::grepl
[13:34:40.924]                           restarts <- computeRestarts(cond)
[13:34:40.924]                           for (restart in restarts) {
[13:34:40.924]                             name <- restart$name
[13:34:40.924]                             if (is.null(name)) 
[13:34:40.924]                               next
[13:34:40.924]                             if (!grepl(pattern, name)) 
[13:34:40.924]                               next
[13:34:40.924]                             invokeRestart(restart)
[13:34:40.924]                             muffled <- TRUE
[13:34:40.924]                             break
[13:34:40.924]                           }
[13:34:40.924]                         }
[13:34:40.924]                       }
[13:34:40.924]                       invisible(muffled)
[13:34:40.924]                     }
[13:34:40.924]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.924]                   }
[13:34:40.924]                 }
[13:34:40.924]                 else {
[13:34:40.924]                   if (TRUE) {
[13:34:40.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:40.924]                     {
[13:34:40.924]                       inherits <- base::inherits
[13:34:40.924]                       invokeRestart <- base::invokeRestart
[13:34:40.924]                       is.null <- base::is.null
[13:34:40.924]                       muffled <- FALSE
[13:34:40.924]                       if (inherits(cond, "message")) {
[13:34:40.924]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:40.924]                         if (muffled) 
[13:34:40.924]                           invokeRestart("muffleMessage")
[13:34:40.924]                       }
[13:34:40.924]                       else if (inherits(cond, "warning")) {
[13:34:40.924]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:40.924]                         if (muffled) 
[13:34:40.924]                           invokeRestart("muffleWarning")
[13:34:40.924]                       }
[13:34:40.924]                       else if (inherits(cond, "condition")) {
[13:34:40.924]                         if (!is.null(pattern)) {
[13:34:40.924]                           computeRestarts <- base::computeRestarts
[13:34:40.924]                           grepl <- base::grepl
[13:34:40.924]                           restarts <- computeRestarts(cond)
[13:34:40.924]                           for (restart in restarts) {
[13:34:40.924]                             name <- restart$name
[13:34:40.924]                             if (is.null(name)) 
[13:34:40.924]                               next
[13:34:40.924]                             if (!grepl(pattern, name)) 
[13:34:40.924]                               next
[13:34:40.924]                             invokeRestart(restart)
[13:34:40.924]                             muffled <- TRUE
[13:34:40.924]                             break
[13:34:40.924]                           }
[13:34:40.924]                         }
[13:34:40.924]                       }
[13:34:40.924]                       invisible(muffled)
[13:34:40.924]                     }
[13:34:40.924]                     muffleCondition(cond, pattern = "^muffle")
[13:34:40.924]                   }
[13:34:40.924]                 }
[13:34:40.924]             }
[13:34:40.924]         }))
[13:34:40.924]     }, error = function(ex) {
[13:34:40.924]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:40.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:40.924]                 ...future.rng), started = ...future.startTime, 
[13:34:40.924]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:40.924]             version = "1.8"), class = "FutureResult")
[13:34:40.924]     }, finally = {
[13:34:40.924]         if (!identical(...future.workdir, getwd())) 
[13:34:40.924]             setwd(...future.workdir)
[13:34:40.924]         {
[13:34:40.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:40.924]                 ...future.oldOptions$nwarnings <- NULL
[13:34:40.924]             }
[13:34:40.924]             base::options(...future.oldOptions)
[13:34:40.924]             if (.Platform$OS.type == "windows") {
[13:34:40.924]                 old_names <- names(...future.oldEnvVars)
[13:34:40.924]                 envs <- base::Sys.getenv()
[13:34:40.924]                 names <- names(envs)
[13:34:40.924]                 common <- intersect(names, old_names)
[13:34:40.924]                 added <- setdiff(names, old_names)
[13:34:40.924]                 removed <- setdiff(old_names, names)
[13:34:40.924]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:40.924]                   envs[common]]
[13:34:40.924]                 NAMES <- toupper(changed)
[13:34:40.924]                 args <- list()
[13:34:40.924]                 for (kk in seq_along(NAMES)) {
[13:34:40.924]                   name <- changed[[kk]]
[13:34:40.924]                   NAME <- NAMES[[kk]]
[13:34:40.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.924]                     next
[13:34:40.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.924]                 }
[13:34:40.924]                 NAMES <- toupper(added)
[13:34:40.924]                 for (kk in seq_along(NAMES)) {
[13:34:40.924]                   name <- added[[kk]]
[13:34:40.924]                   NAME <- NAMES[[kk]]
[13:34:40.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.924]                     next
[13:34:40.924]                   args[[name]] <- ""
[13:34:40.924]                 }
[13:34:40.924]                 NAMES <- toupper(removed)
[13:34:40.924]                 for (kk in seq_along(NAMES)) {
[13:34:40.924]                   name <- removed[[kk]]
[13:34:40.924]                   NAME <- NAMES[[kk]]
[13:34:40.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:40.924]                     next
[13:34:40.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:40.924]                 }
[13:34:40.924]                 if (length(args) > 0) 
[13:34:40.924]                   base::do.call(base::Sys.setenv, args = args)
[13:34:40.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:40.924]             }
[13:34:40.924]             else {
[13:34:40.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:40.924]             }
[13:34:40.924]             {
[13:34:40.924]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:40.924]                   0L) {
[13:34:40.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:40.924]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:40.924]                   base::options(opts)
[13:34:40.924]                 }
[13:34:40.924]                 {
[13:34:40.924]                   {
[13:34:40.924]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:40.924]                     NULL
[13:34:40.924]                   }
[13:34:40.924]                   options(future.plan = NULL)
[13:34:40.924]                   if (is.na(NA_character_)) 
[13:34:40.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:40.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:40.924]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:40.924]                     .init = FALSE)
[13:34:40.924]                 }
[13:34:40.924]             }
[13:34:40.924]         }
[13:34:40.924]     })
[13:34:40.924]     if (TRUE) {
[13:34:40.924]         base::sink(type = "output", split = FALSE)
[13:34:40.924]         if (TRUE) {
[13:34:40.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:40.924]         }
[13:34:40.924]         else {
[13:34:40.924]             ...future.result["stdout"] <- base::list(NULL)
[13:34:40.924]         }
[13:34:40.924]         base::close(...future.stdout)
[13:34:40.924]         ...future.stdout <- NULL
[13:34:40.924]     }
[13:34:40.924]     ...future.result$conditions <- ...future.conditions
[13:34:40.924]     ...future.result$finished <- base::Sys.time()
[13:34:40.924]     ...future.result
[13:34:40.924] }
[13:34:40.927] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[13:34:40.927] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[13:34:40.927] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[13:34:40.927] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:40.928] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.928] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[13:34:40.928] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[13:34:40.928] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:40.929] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.929] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:40.929] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:40.929] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[13:34:40.930] MultisessionFuture started
[13:34:40.930] - Launch lazy future ... done
[13:34:40.930] run() for ‘MultisessionFuture’ ... done
[13:34:40.930] Created future:
[13:34:40.930] MultisessionFuture:
[13:34:40.930] Label: ‘future_Map-2’
[13:34:40.930] Expression:
[13:34:40.930] {
[13:34:40.930]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:40.930]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:40.930]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:40.930]         on.exit(options(oopts), add = TRUE)
[13:34:40.930]     }
[13:34:40.930]     {
[13:34:40.930]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:40.930]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:40.930]         do.call(mapply, args = args)
[13:34:40.930]     }
[13:34:40.930] }
[13:34:40.930] Lazy evaluation: FALSE
[13:34:40.930] Asynchronous evaluation: TRUE
[13:34:40.930] Local evaluation: TRUE
[13:34:40.930] Environment: R_GlobalEnv
[13:34:40.930] Capture standard output: TRUE
[13:34:40.930] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:40.930] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:40.930] Packages: <none>
[13:34:40.930] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:40.930] Resolved: FALSE
[13:34:40.930] Value: <not collected>
[13:34:40.930] Conditions captured: <none>
[13:34:40.930] Early signaling: FALSE
[13:34:40.930] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:40.930] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:40.941] Chunk #2 of 2 ... DONE
[13:34:40.942] Launching 2 futures (chunks) ... DONE
[13:34:40.942] Resolving 2 futures (chunks) ...
[13:34:40.942] resolve() on list ...
[13:34:40.942]  recursive: 0
[13:34:40.942]  length: 2
[13:34:40.942] 
[13:34:40.943] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.943] - Validating connection of MultisessionFuture
[13:34:40.943] - received message: FutureResult
[13:34:40.943] - Received FutureResult
[13:34:40.943] - Erased future from FutureRegistry
[13:34:40.943] result() for ClusterFuture ...
[13:34:40.943] - result already collected: FutureResult
[13:34:40.943] result() for ClusterFuture ... done
[13:34:40.944] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.944] Future #1
[13:34:40.944] result() for ClusterFuture ...
[13:34:40.944] - result already collected: FutureResult
[13:34:40.944] result() for ClusterFuture ... done
[13:34:40.944] result() for ClusterFuture ...
[13:34:40.944] - result already collected: FutureResult
[13:34:40.944] result() for ClusterFuture ... done
[13:34:40.944] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:40.944] - nx: 2
[13:34:40.944] - relay: TRUE
[13:34:40.944] - stdout: TRUE
[13:34:40.945] - signal: TRUE
[13:34:40.945] - resignal: FALSE
[13:34:40.945] - force: TRUE
[13:34:40.945] - relayed: [n=2] FALSE, FALSE
[13:34:40.945] - queued futures: [n=2] FALSE, FALSE
[13:34:40.945]  - until=1
[13:34:40.945]  - relaying element #1
[13:34:40.945] result() for ClusterFuture ...
[13:34:40.945] - result already collected: FutureResult
[13:34:40.945] result() for ClusterFuture ... done
[13:34:40.945] result() for ClusterFuture ...
[13:34:40.945] - result already collected: FutureResult
[13:34:40.946] result() for ClusterFuture ... done
[13:34:40.946] result() for ClusterFuture ...
[13:34:40.946] - result already collected: FutureResult
[13:34:40.946] result() for ClusterFuture ... done
[13:34:40.946] result() for ClusterFuture ...
[13:34:40.946] - result already collected: FutureResult
[13:34:40.946] result() for ClusterFuture ... done
[13:34:40.946] - relayed: [n=2] TRUE, FALSE
[13:34:40.946] - queued futures: [n=2] TRUE, FALSE
[13:34:40.946] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:40.947]  length: 1 (resolved future 1)
[13:34:40.972] receiveMessageFromWorker() for ClusterFuture ...
[13:34:40.972] - Validating connection of MultisessionFuture
[13:34:40.972] - received message: FutureResult
[13:34:40.972] - Received FutureResult
[13:34:40.972] - Erased future from FutureRegistry
[13:34:40.972] result() for ClusterFuture ...
[13:34:40.972] - result already collected: FutureResult
[13:34:40.973] result() for ClusterFuture ... done
[13:34:40.973] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:40.973] Future #2
[13:34:40.973] result() for ClusterFuture ...
[13:34:40.973] - result already collected: FutureResult
[13:34:40.973] result() for ClusterFuture ... done
[13:34:40.973] result() for ClusterFuture ...
[13:34:40.973] - result already collected: FutureResult
[13:34:40.973] result() for ClusterFuture ... done
[13:34:40.973] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:40.973] - nx: 2
[13:34:40.974] - relay: TRUE
[13:34:40.974] - stdout: TRUE
[13:34:40.974] - signal: TRUE
[13:34:40.974] - resignal: FALSE
[13:34:40.974] - force: TRUE
[13:34:40.974] - relayed: [n=2] TRUE, FALSE
[13:34:40.974] - queued futures: [n=2] TRUE, FALSE
[13:34:40.974]  - until=2
[13:34:40.974]  - relaying element #2
[13:34:40.974] result() for ClusterFuture ...
[13:34:40.974] - result already collected: FutureResult
[13:34:40.975] result() for ClusterFuture ... done
[13:34:40.975] result() for ClusterFuture ...
[13:34:40.975] - result already collected: FutureResult
[13:34:40.975] result() for ClusterFuture ... done
[13:34:40.975] result() for ClusterFuture ...
[13:34:40.975] - result already collected: FutureResult
[13:34:40.975] result() for ClusterFuture ... done
[13:34:40.975] result() for ClusterFuture ...
[13:34:40.975] - result already collected: FutureResult
[13:34:40.975] result() for ClusterFuture ... done
[13:34:40.975] - relayed: [n=2] TRUE, TRUE
[13:34:40.975] - queued futures: [n=2] TRUE, TRUE
[13:34:40.976] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:40.976]  length: 0 (resolved future 2)
[13:34:40.976] Relaying remaining futures
[13:34:40.976] signalConditionsASAP(NULL, pos=0) ...
[13:34:40.976] - nx: 2
[13:34:40.976] - relay: TRUE
[13:34:40.976] - stdout: TRUE
[13:34:40.976] - signal: TRUE
[13:34:40.976] - resignal: FALSE
[13:34:40.976] - force: TRUE
[13:34:40.976] - relayed: [n=2] TRUE, TRUE
[13:34:40.976] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:40.977] - relayed: [n=2] TRUE, TRUE
[13:34:40.977] - queued futures: [n=2] TRUE, TRUE
[13:34:40.977] signalConditionsASAP(NULL, pos=0) ... done
[13:34:40.977] resolve() on list ... DONE
[13:34:40.977] result() for ClusterFuture ...
[13:34:40.977] - result already collected: FutureResult
[13:34:40.977] result() for ClusterFuture ... done
[13:34:40.977] result() for ClusterFuture ...
[13:34:40.977] - result already collected: FutureResult
[13:34:40.977] result() for ClusterFuture ... done
[13:34:40.977] result() for ClusterFuture ...
[13:34:40.978] - result already collected: FutureResult
[13:34:40.978] result() for ClusterFuture ... done
[13:34:40.978] result() for ClusterFuture ...
[13:34:40.978] - result already collected: FutureResult
[13:34:40.978] result() for ClusterFuture ... done
[13:34:40.978]  - Number of value chunks collected: 2
[13:34:40.978] Resolving 2 futures (chunks) ... DONE
[13:34:40.978] Reducing values from 2 chunks ...
[13:34:40.978]  - Number of values collected after concatenation: 3
[13:34:40.978]  - Number of values expected: 3
[13:34:40.978] Reducing values from 2 chunks ... DONE
[13:34:40.979] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[13:34:40.979] future_mapply() ...
[13:34:40.982] Number of chunks: 2
[13:34:40.982] getGlobalsAndPackagesXApply() ...
[13:34:40.983]  - future.globals: TRUE
[13:34:40.983] getGlobalsAndPackages() ...
[13:34:40.983] Searching for globals...
[13:34:40.984] - globals found: [1] ‘FUN’
[13:34:40.984] Searching for globals ... DONE
[13:34:40.984] Resolving globals: FALSE
[13:34:40.984] The total size of the 1 globals is 848 bytes (848 bytes)
[13:34:40.984] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:34:40.985] - globals: [1] ‘FUN’
[13:34:40.985] 
[13:34:40.985] getGlobalsAndPackages() ... DONE
[13:34:40.985]  - globals found/used: [n=1] ‘FUN’
[13:34:40.985]  - needed namespaces: [n=0] 
[13:34:40.985] Finding globals ... DONE
[13:34:40.985] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:34:40.985] List of 2
[13:34:40.985]  $ ...future.FUN:function (x)  
[13:34:40.985]  $ MoreArgs     : NULL
[13:34:40.985]  - attr(*, "where")=List of 2
[13:34:40.985]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:34:40.985]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:34:40.985]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:34:40.985]  - attr(*, "resolved")= logi FALSE
[13:34:40.985]  - attr(*, "total_size")= num NA
[13:34:40.988] Packages to be attached in all futures: [n=0] 
[13:34:40.988] getGlobalsAndPackagesXApply() ... DONE
[13:34:40.988] Number of futures (= number of chunks): 2
[13:34:40.988] Launching 2 futures (chunks) ...
[13:34:40.988] Chunk #1 of 2 ...
[13:34:40.989]  - Finding globals in '...' for chunk #1 ...
[13:34:40.989] getGlobalsAndPackages() ...
[13:34:40.989] Searching for globals...
[13:34:40.989] 
[13:34:40.989] Searching for globals ... DONE
[13:34:40.989] - globals: [0] <none>
[13:34:40.989] getGlobalsAndPackages() ... DONE
[13:34:40.989]    + additional globals found: [n=0] 
[13:34:40.989]    + additional namespaces needed: [n=0] 
[13:34:40.990]  - Finding globals in '...' for chunk #1 ... DONE
[13:34:40.990]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:40.990]  - seeds: <none>
[13:34:40.990]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.990] getGlobalsAndPackages() ...
[13:34:40.990] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.990] Resolving globals: FALSE
[13:34:40.991] The total size of the 5 globals is 904 bytes (904 bytes)
[13:34:40.991] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:40.991] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:40.991] 
[13:34:40.991] getGlobalsAndPackages() ... DONE
[13:34:40.992] run() for ‘Future’ ...
[13:34:40.992] - state: ‘created’
[13:34:40.992] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:41.005] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:41.005] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:41.005]   - Field: ‘node’
[13:34:41.005]   - Field: ‘label’
[13:34:41.006]   - Field: ‘local’
[13:34:41.006]   - Field: ‘owner’
[13:34:41.006]   - Field: ‘envir’
[13:34:41.006]   - Field: ‘workers’
[13:34:41.006]   - Field: ‘packages’
[13:34:41.006]   - Field: ‘gc’
[13:34:41.006]   - Field: ‘conditions’
[13:34:41.006]   - Field: ‘persistent’
[13:34:41.006]   - Field: ‘expr’
[13:34:41.006]   - Field: ‘uuid’
[13:34:41.007]   - Field: ‘seed’
[13:34:41.007]   - Field: ‘version’
[13:34:41.007]   - Field: ‘result’
[13:34:41.007]   - Field: ‘asynchronous’
[13:34:41.007]   - Field: ‘calls’
[13:34:41.007]   - Field: ‘globals’
[13:34:41.007]   - Field: ‘stdout’
[13:34:41.007]   - Field: ‘earlySignal’
[13:34:41.007]   - Field: ‘lazy’
[13:34:41.007]   - Field: ‘state’
[13:34:41.008] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:41.008] - Launch lazy future ...
[13:34:41.008] Packages needed by the future expression (n = 0): <none>
[13:34:41.008] Packages needed by future strategies (n = 0): <none>
[13:34:41.008] {
[13:34:41.008]     {
[13:34:41.008]         {
[13:34:41.008]             ...future.startTime <- base::Sys.time()
[13:34:41.008]             {
[13:34:41.008]                 {
[13:34:41.008]                   {
[13:34:41.008]                     {
[13:34:41.008]                       base::local({
[13:34:41.008]                         has_future <- base::requireNamespace("future", 
[13:34:41.008]                           quietly = TRUE)
[13:34:41.008]                         if (has_future) {
[13:34:41.008]                           ns <- base::getNamespace("future")
[13:34:41.008]                           version <- ns[[".package"]][["version"]]
[13:34:41.008]                           if (is.null(version)) 
[13:34:41.008]                             version <- utils::packageVersion("future")
[13:34:41.008]                         }
[13:34:41.008]                         else {
[13:34:41.008]                           version <- NULL
[13:34:41.008]                         }
[13:34:41.008]                         if (!has_future || version < "1.8.0") {
[13:34:41.008]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:41.008]                             "", base::R.version$version.string), 
[13:34:41.008]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:41.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:41.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:41.008]                               "release", "version")], collapse = " "), 
[13:34:41.008]                             hostname = base::Sys.info()[["nodename"]])
[13:34:41.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:41.008]                             info)
[13:34:41.008]                           info <- base::paste(info, collapse = "; ")
[13:34:41.008]                           if (!has_future) {
[13:34:41.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:41.008]                               info)
[13:34:41.008]                           }
[13:34:41.008]                           else {
[13:34:41.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:41.008]                               info, version)
[13:34:41.008]                           }
[13:34:41.008]                           base::stop(msg)
[13:34:41.008]                         }
[13:34:41.008]                       })
[13:34:41.008]                     }
[13:34:41.008]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:41.008]                     base::options(mc.cores = 1L)
[13:34:41.008]                   }
[13:34:41.008]                   ...future.strategy.old <- future::plan("list")
[13:34:41.008]                   options(future.plan = NULL)
[13:34:41.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:41.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:41.008]                 }
[13:34:41.008]                 ...future.workdir <- getwd()
[13:34:41.008]             }
[13:34:41.008]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:41.008]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:41.008]         }
[13:34:41.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:41.008]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:41.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:41.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:41.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:41.008]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:41.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:41.008]             base::names(...future.oldOptions))
[13:34:41.008]     }
[13:34:41.008]     if (FALSE) {
[13:34:41.008]     }
[13:34:41.008]     else {
[13:34:41.008]         if (TRUE) {
[13:34:41.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:41.008]                 open = "w")
[13:34:41.008]         }
[13:34:41.008]         else {
[13:34:41.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:41.008]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:41.008]         }
[13:34:41.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:41.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:41.008]             base::sink(type = "output", split = FALSE)
[13:34:41.008]             base::close(...future.stdout)
[13:34:41.008]         }, add = TRUE)
[13:34:41.008]     }
[13:34:41.008]     ...future.frame <- base::sys.nframe()
[13:34:41.008]     ...future.conditions <- base::list()
[13:34:41.008]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:41.008]     if (FALSE) {
[13:34:41.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:41.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:41.008]     }
[13:34:41.008]     ...future.result <- base::tryCatch({
[13:34:41.008]         base::withCallingHandlers({
[13:34:41.008]             ...future.value <- base::withVisible(base::local({
[13:34:41.008]                 ...future.makeSendCondition <- base::local({
[13:34:41.008]                   sendCondition <- NULL
[13:34:41.008]                   function(frame = 1L) {
[13:34:41.008]                     if (is.function(sendCondition)) 
[13:34:41.008]                       return(sendCondition)
[13:34:41.008]                     ns <- getNamespace("parallel")
[13:34:41.008]                     if (exists("sendData", mode = "function", 
[13:34:41.008]                       envir = ns)) {
[13:34:41.008]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:41.008]                         envir = ns)
[13:34:41.008]                       envir <- sys.frame(frame)
[13:34:41.008]                       master <- NULL
[13:34:41.008]                       while (!identical(envir, .GlobalEnv) && 
[13:34:41.008]                         !identical(envir, emptyenv())) {
[13:34:41.008]                         if (exists("master", mode = "list", envir = envir, 
[13:34:41.008]                           inherits = FALSE)) {
[13:34:41.008]                           master <- get("master", mode = "list", 
[13:34:41.008]                             envir = envir, inherits = FALSE)
[13:34:41.008]                           if (inherits(master, c("SOCKnode", 
[13:34:41.008]                             "SOCK0node"))) {
[13:34:41.008]                             sendCondition <<- function(cond) {
[13:34:41.008]                               data <- list(type = "VALUE", value = cond, 
[13:34:41.008]                                 success = TRUE)
[13:34:41.008]                               parallel_sendData(master, data)
[13:34:41.008]                             }
[13:34:41.008]                             return(sendCondition)
[13:34:41.008]                           }
[13:34:41.008]                         }
[13:34:41.008]                         frame <- frame + 1L
[13:34:41.008]                         envir <- sys.frame(frame)
[13:34:41.008]                       }
[13:34:41.008]                     }
[13:34:41.008]                     sendCondition <<- function(cond) NULL
[13:34:41.008]                   }
[13:34:41.008]                 })
[13:34:41.008]                 withCallingHandlers({
[13:34:41.008]                   {
[13:34:41.008]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:41.008]                     if (!identical(...future.globals.maxSize.org, 
[13:34:41.008]                       ...future.globals.maxSize)) {
[13:34:41.008]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:41.008]                       on.exit(options(oopts), add = TRUE)
[13:34:41.008]                     }
[13:34:41.008]                     {
[13:34:41.008]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:41.008]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:41.008]                         USE.NAMES = FALSE)
[13:34:41.008]                       do.call(mapply, args = args)
[13:34:41.008]                     }
[13:34:41.008]                   }
[13:34:41.008]                 }, immediateCondition = function(cond) {
[13:34:41.008]                   sendCondition <- ...future.makeSendCondition()
[13:34:41.008]                   sendCondition(cond)
[13:34:41.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:41.008]                   {
[13:34:41.008]                     inherits <- base::inherits
[13:34:41.008]                     invokeRestart <- base::invokeRestart
[13:34:41.008]                     is.null <- base::is.null
[13:34:41.008]                     muffled <- FALSE
[13:34:41.008]                     if (inherits(cond, "message")) {
[13:34:41.008]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:41.008]                       if (muffled) 
[13:34:41.008]                         invokeRestart("muffleMessage")
[13:34:41.008]                     }
[13:34:41.008]                     else if (inherits(cond, "warning")) {
[13:34:41.008]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:41.008]                       if (muffled) 
[13:34:41.008]                         invokeRestart("muffleWarning")
[13:34:41.008]                     }
[13:34:41.008]                     else if (inherits(cond, "condition")) {
[13:34:41.008]                       if (!is.null(pattern)) {
[13:34:41.008]                         computeRestarts <- base::computeRestarts
[13:34:41.008]                         grepl <- base::grepl
[13:34:41.008]                         restarts <- computeRestarts(cond)
[13:34:41.008]                         for (restart in restarts) {
[13:34:41.008]                           name <- restart$name
[13:34:41.008]                           if (is.null(name)) 
[13:34:41.008]                             next
[13:34:41.008]                           if (!grepl(pattern, name)) 
[13:34:41.008]                             next
[13:34:41.008]                           invokeRestart(restart)
[13:34:41.008]                           muffled <- TRUE
[13:34:41.008]                           break
[13:34:41.008]                         }
[13:34:41.008]                       }
[13:34:41.008]                     }
[13:34:41.008]                     invisible(muffled)
[13:34:41.008]                   }
[13:34:41.008]                   muffleCondition(cond)
[13:34:41.008]                 })
[13:34:41.008]             }))
[13:34:41.008]             future::FutureResult(value = ...future.value$value, 
[13:34:41.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:41.008]                   ...future.rng), globalenv = if (FALSE) 
[13:34:41.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:41.008]                     ...future.globalenv.names))
[13:34:41.008]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:41.008]         }, condition = base::local({
[13:34:41.008]             c <- base::c
[13:34:41.008]             inherits <- base::inherits
[13:34:41.008]             invokeRestart <- base::invokeRestart
[13:34:41.008]             length <- base::length
[13:34:41.008]             list <- base::list
[13:34:41.008]             seq.int <- base::seq.int
[13:34:41.008]             signalCondition <- base::signalCondition
[13:34:41.008]             sys.calls <- base::sys.calls
[13:34:41.008]             `[[` <- base::`[[`
[13:34:41.008]             `+` <- base::`+`
[13:34:41.008]             `<<-` <- base::`<<-`
[13:34:41.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:41.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:41.008]                   3L)]
[13:34:41.008]             }
[13:34:41.008]             function(cond) {
[13:34:41.008]                 is_error <- inherits(cond, "error")
[13:34:41.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:41.008]                   NULL)
[13:34:41.008]                 if (is_error) {
[13:34:41.008]                   sessionInformation <- function() {
[13:34:41.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:41.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:41.008]                       search = base::search(), system = base::Sys.info())
[13:34:41.008]                   }
[13:34:41.008]                   ...future.conditions[[length(...future.conditions) + 
[13:34:41.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:41.008]                     cond$call), session = sessionInformation(), 
[13:34:41.008]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:41.008]                   signalCondition(cond)
[13:34:41.008]                 }
[13:34:41.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:41.008]                 "immediateCondition"))) {
[13:34:41.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:41.008]                   ...future.conditions[[length(...future.conditions) + 
[13:34:41.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:41.008]                   if (TRUE && !signal) {
[13:34:41.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:41.008]                     {
[13:34:41.008]                       inherits <- base::inherits
[13:34:41.008]                       invokeRestart <- base::invokeRestart
[13:34:41.008]                       is.null <- base::is.null
[13:34:41.008]                       muffled <- FALSE
[13:34:41.008]                       if (inherits(cond, "message")) {
[13:34:41.008]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:41.008]                         if (muffled) 
[13:34:41.008]                           invokeRestart("muffleMessage")
[13:34:41.008]                       }
[13:34:41.008]                       else if (inherits(cond, "warning")) {
[13:34:41.008]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:41.008]                         if (muffled) 
[13:34:41.008]                           invokeRestart("muffleWarning")
[13:34:41.008]                       }
[13:34:41.008]                       else if (inherits(cond, "condition")) {
[13:34:41.008]                         if (!is.null(pattern)) {
[13:34:41.008]                           computeRestarts <- base::computeRestarts
[13:34:41.008]                           grepl <- base::grepl
[13:34:41.008]                           restarts <- computeRestarts(cond)
[13:34:41.008]                           for (restart in restarts) {
[13:34:41.008]                             name <- restart$name
[13:34:41.008]                             if (is.null(name)) 
[13:34:41.008]                               next
[13:34:41.008]                             if (!grepl(pattern, name)) 
[13:34:41.008]                               next
[13:34:41.008]                             invokeRestart(restart)
[13:34:41.008]                             muffled <- TRUE
[13:34:41.008]                             break
[13:34:41.008]                           }
[13:34:41.008]                         }
[13:34:41.008]                       }
[13:34:41.008]                       invisible(muffled)
[13:34:41.008]                     }
[13:34:41.008]                     muffleCondition(cond, pattern = "^muffle")
[13:34:41.008]                   }
[13:34:41.008]                 }
[13:34:41.008]                 else {
[13:34:41.008]                   if (TRUE) {
[13:34:41.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:41.008]                     {
[13:34:41.008]                       inherits <- base::inherits
[13:34:41.008]                       invokeRestart <- base::invokeRestart
[13:34:41.008]                       is.null <- base::is.null
[13:34:41.008]                       muffled <- FALSE
[13:34:41.008]                       if (inherits(cond, "message")) {
[13:34:41.008]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:41.008]                         if (muffled) 
[13:34:41.008]                           invokeRestart("muffleMessage")
[13:34:41.008]                       }
[13:34:41.008]                       else if (inherits(cond, "warning")) {
[13:34:41.008]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:41.008]                         if (muffled) 
[13:34:41.008]                           invokeRestart("muffleWarning")
[13:34:41.008]                       }
[13:34:41.008]                       else if (inherits(cond, "condition")) {
[13:34:41.008]                         if (!is.null(pattern)) {
[13:34:41.008]                           computeRestarts <- base::computeRestarts
[13:34:41.008]                           grepl <- base::grepl
[13:34:41.008]                           restarts <- computeRestarts(cond)
[13:34:41.008]                           for (restart in restarts) {
[13:34:41.008]                             name <- restart$name
[13:34:41.008]                             if (is.null(name)) 
[13:34:41.008]                               next
[13:34:41.008]                             if (!grepl(pattern, name)) 
[13:34:41.008]                               next
[13:34:41.008]                             invokeRestart(restart)
[13:34:41.008]                             muffled <- TRUE
[13:34:41.008]                             break
[13:34:41.008]                           }
[13:34:41.008]                         }
[13:34:41.008]                       }
[13:34:41.008]                       invisible(muffled)
[13:34:41.008]                     }
[13:34:41.008]                     muffleCondition(cond, pattern = "^muffle")
[13:34:41.008]                   }
[13:34:41.008]                 }
[13:34:41.008]             }
[13:34:41.008]         }))
[13:34:41.008]     }, error = function(ex) {
[13:34:41.008]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:41.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:41.008]                 ...future.rng), started = ...future.startTime, 
[13:34:41.008]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:41.008]             version = "1.8"), class = "FutureResult")
[13:34:41.008]     }, finally = {
[13:34:41.008]         if (!identical(...future.workdir, getwd())) 
[13:34:41.008]             setwd(...future.workdir)
[13:34:41.008]         {
[13:34:41.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:41.008]                 ...future.oldOptions$nwarnings <- NULL
[13:34:41.008]             }
[13:34:41.008]             base::options(...future.oldOptions)
[13:34:41.008]             if (.Platform$OS.type == "windows") {
[13:34:41.008]                 old_names <- names(...future.oldEnvVars)
[13:34:41.008]                 envs <- base::Sys.getenv()
[13:34:41.008]                 names <- names(envs)
[13:34:41.008]                 common <- intersect(names, old_names)
[13:34:41.008]                 added <- setdiff(names, old_names)
[13:34:41.008]                 removed <- setdiff(old_names, names)
[13:34:41.008]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:41.008]                   envs[common]]
[13:34:41.008]                 NAMES <- toupper(changed)
[13:34:41.008]                 args <- list()
[13:34:41.008]                 for (kk in seq_along(NAMES)) {
[13:34:41.008]                   name <- changed[[kk]]
[13:34:41.008]                   NAME <- NAMES[[kk]]
[13:34:41.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:41.008]                     next
[13:34:41.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:41.008]                 }
[13:34:41.008]                 NAMES <- toupper(added)
[13:34:41.008]                 for (kk in seq_along(NAMES)) {
[13:34:41.008]                   name <- added[[kk]]
[13:34:41.008]                   NAME <- NAMES[[kk]]
[13:34:41.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:41.008]                     next
[13:34:41.008]                   args[[name]] <- ""
[13:34:41.008]                 }
[13:34:41.008]                 NAMES <- toupper(removed)
[13:34:41.008]                 for (kk in seq_along(NAMES)) {
[13:34:41.008]                   name <- removed[[kk]]
[13:34:41.008]                   NAME <- NAMES[[kk]]
[13:34:41.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:41.008]                     next
[13:34:41.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:41.008]                 }
[13:34:41.008]                 if (length(args) > 0) 
[13:34:41.008]                   base::do.call(base::Sys.setenv, args = args)
[13:34:41.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:41.008]             }
[13:34:41.008]             else {
[13:34:41.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:41.008]             }
[13:34:41.008]             {
[13:34:41.008]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:41.008]                   0L) {
[13:34:41.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:41.008]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:41.008]                   base::options(opts)
[13:34:41.008]                 }
[13:34:41.008]                 {
[13:34:41.008]                   {
[13:34:41.008]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:41.008]                     NULL
[13:34:41.008]                   }
[13:34:41.008]                   options(future.plan = NULL)
[13:34:41.008]                   if (is.na(NA_character_)) 
[13:34:41.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:41.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:41.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:41.008]                     .init = FALSE)
[13:34:41.008]                 }
[13:34:41.008]             }
[13:34:41.008]         }
[13:34:41.008]     })
[13:34:41.008]     if (TRUE) {
[13:34:41.008]         base::sink(type = "output", split = FALSE)
[13:34:41.008]         if (TRUE) {
[13:34:41.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:41.008]         }
[13:34:41.008]         else {
[13:34:41.008]             ...future.result["stdout"] <- base::list(NULL)
[13:34:41.008]         }
[13:34:41.008]         base::close(...future.stdout)
[13:34:41.008]         ...future.stdout <- NULL
[13:34:41.008]     }
[13:34:41.008]     ...future.result$conditions <- ...future.conditions
[13:34:41.008]     ...future.result$finished <- base::Sys.time()
[13:34:41.008]     ...future.result
[13:34:41.008] }
[13:34:41.011] Exporting 5 global objects (904 bytes) to cluster node #1 ...
[13:34:41.011] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:34:41.011] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:34:41.012] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:34:41.012] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:34:41.012] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:34:41.012] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:34:41.012] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:34:41.013] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:34:41.013] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:34:41.013] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:34:41.013] Exporting 5 global objects (904 bytes) to cluster node #1 ... DONE
[13:34:41.014] MultisessionFuture started
[13:34:41.014] - Launch lazy future ... done
[13:34:41.014] run() for ‘MultisessionFuture’ ... done
[13:34:41.014] Created future:
[13:34:41.014] MultisessionFuture:
[13:34:41.014] Label: ‘future_mapply-1’
[13:34:41.014] Expression:
[13:34:41.014] {
[13:34:41.014]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:41.014]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:41.014]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:41.014]         on.exit(options(oopts), add = TRUE)
[13:34:41.014]     }
[13:34:41.014]     {
[13:34:41.014]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:41.014]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:41.014]         do.call(mapply, args = args)
[13:34:41.014]     }
[13:34:41.014] }
[13:34:41.014] Lazy evaluation: FALSE
[13:34:41.014] Asynchronous evaluation: TRUE
[13:34:41.014] Local evaluation: TRUE
[13:34:41.014] Environment: R_GlobalEnv
[13:34:41.014] Capture standard output: TRUE
[13:34:41.014] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:41.014] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:41.014] Packages: <none>
[13:34:41.014] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:41.014] Resolved: FALSE
[13:34:41.014] Value: <not collected>
[13:34:41.014] Conditions captured: <none>
[13:34:41.014] Early signaling: FALSE
[13:34:41.014] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:41.014] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:41.025] Chunk #1 of 2 ... DONE
[13:34:41.026] Chunk #2 of 2 ...
[13:34:41.026]  - Finding globals in '...' for chunk #2 ...
[13:34:41.026] getGlobalsAndPackages() ...
[13:34:41.026] Searching for globals...
[13:34:41.026] 
[13:34:41.026] Searching for globals ... DONE
[13:34:41.027] - globals: [0] <none>
[13:34:41.027] getGlobalsAndPackages() ... DONE
[13:34:41.027]    + additional globals found: [n=0] 
[13:34:41.027]    + additional namespaces needed: [n=0] 
[13:34:41.027]  - Finding globals in '...' for chunk #2 ... DONE
[13:34:41.027]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:34:41.027]  - seeds: <none>
[13:34:41.027]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:41.027] getGlobalsAndPackages() ...
[13:34:41.027] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:41.027] Resolving globals: FALSE
[13:34:41.028] The total size of the 5 globals is 904 bytes (904 bytes)
[13:34:41.031] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:34:41.031] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:34:41.032] 
[13:34:41.032] getGlobalsAndPackages() ... DONE
[13:34:41.032] run() for ‘Future’ ...
[13:34:41.032] - state: ‘created’
[13:34:41.032] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:34:41.045] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:41.046] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:34:41.046]   - Field: ‘node’
[13:34:41.046]   - Field: ‘label’
[13:34:41.046]   - Field: ‘local’
[13:34:41.046]   - Field: ‘owner’
[13:34:41.046]   - Field: ‘envir’
[13:34:41.046]   - Field: ‘workers’
[13:34:41.046]   - Field: ‘packages’
[13:34:41.046]   - Field: ‘gc’
[13:34:41.046]   - Field: ‘conditions’
[13:34:41.047]   - Field: ‘persistent’
[13:34:41.047]   - Field: ‘expr’
[13:34:41.047]   - Field: ‘uuid’
[13:34:41.047]   - Field: ‘seed’
[13:34:41.047]   - Field: ‘version’
[13:34:41.047]   - Field: ‘result’
[13:34:41.047]   - Field: ‘asynchronous’
[13:34:41.047]   - Field: ‘calls’
[13:34:41.047]   - Field: ‘globals’
[13:34:41.047]   - Field: ‘stdout’
[13:34:41.047]   - Field: ‘earlySignal’
[13:34:41.047]   - Field: ‘lazy’
[13:34:41.048]   - Field: ‘state’
[13:34:41.048] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:34:41.048] - Launch lazy future ...
[13:34:41.048] Packages needed by the future expression (n = 0): <none>
[13:34:41.048] Packages needed by future strategies (n = 0): <none>
[13:34:41.048] {
[13:34:41.048]     {
[13:34:41.048]         {
[13:34:41.048]             ...future.startTime <- base::Sys.time()
[13:34:41.048]             {
[13:34:41.048]                 {
[13:34:41.048]                   {
[13:34:41.048]                     {
[13:34:41.048]                       base::local({
[13:34:41.048]                         has_future <- base::requireNamespace("future", 
[13:34:41.048]                           quietly = TRUE)
[13:34:41.048]                         if (has_future) {
[13:34:41.048]                           ns <- base::getNamespace("future")
[13:34:41.048]                           version <- ns[[".package"]][["version"]]
[13:34:41.048]                           if (is.null(version)) 
[13:34:41.048]                             version <- utils::packageVersion("future")
[13:34:41.048]                         }
[13:34:41.048]                         else {
[13:34:41.048]                           version <- NULL
[13:34:41.048]                         }
[13:34:41.048]                         if (!has_future || version < "1.8.0") {
[13:34:41.048]                           info <- base::c(r_version = base::gsub("R version ", 
[13:34:41.048]                             "", base::R.version$version.string), 
[13:34:41.048]                             platform = base::sprintf("%s (%s-bit)", 
[13:34:41.048]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:34:41.048]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:34:41.048]                               "release", "version")], collapse = " "), 
[13:34:41.048]                             hostname = base::Sys.info()[["nodename"]])
[13:34:41.048]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:34:41.048]                             info)
[13:34:41.048]                           info <- base::paste(info, collapse = "; ")
[13:34:41.048]                           if (!has_future) {
[13:34:41.048]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:34:41.048]                               info)
[13:34:41.048]                           }
[13:34:41.048]                           else {
[13:34:41.048]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:34:41.048]                               info, version)
[13:34:41.048]                           }
[13:34:41.048]                           base::stop(msg)
[13:34:41.048]                         }
[13:34:41.048]                       })
[13:34:41.048]                     }
[13:34:41.048]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:34:41.048]                     base::options(mc.cores = 1L)
[13:34:41.048]                   }
[13:34:41.048]                   ...future.strategy.old <- future::plan("list")
[13:34:41.048]                   options(future.plan = NULL)
[13:34:41.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:34:41.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:34:41.048]                 }
[13:34:41.048]                 ...future.workdir <- getwd()
[13:34:41.048]             }
[13:34:41.048]             ...future.oldOptions <- base::as.list(base::.Options)
[13:34:41.048]             ...future.oldEnvVars <- base::Sys.getenv()
[13:34:41.048]         }
[13:34:41.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:34:41.048]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:34:41.048]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:34:41.048]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:34:41.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:34:41.048]             future.stdout.windows.reencode = NULL, width = 80L)
[13:34:41.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:34:41.048]             base::names(...future.oldOptions))
[13:34:41.048]     }
[13:34:41.048]     if (FALSE) {
[13:34:41.048]     }
[13:34:41.048]     else {
[13:34:41.048]         if (TRUE) {
[13:34:41.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:34:41.048]                 open = "w")
[13:34:41.048]         }
[13:34:41.048]         else {
[13:34:41.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:34:41.048]                 windows = "NUL", "/dev/null"), open = "w")
[13:34:41.048]         }
[13:34:41.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:34:41.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:34:41.048]             base::sink(type = "output", split = FALSE)
[13:34:41.048]             base::close(...future.stdout)
[13:34:41.048]         }, add = TRUE)
[13:34:41.048]     }
[13:34:41.048]     ...future.frame <- base::sys.nframe()
[13:34:41.048]     ...future.conditions <- base::list()
[13:34:41.048]     ...future.rng <- base::globalenv()$.Random.seed
[13:34:41.048]     if (FALSE) {
[13:34:41.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:34:41.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:34:41.048]     }
[13:34:41.048]     ...future.result <- base::tryCatch({
[13:34:41.048]         base::withCallingHandlers({
[13:34:41.048]             ...future.value <- base::withVisible(base::local({
[13:34:41.048]                 ...future.makeSendCondition <- base::local({
[13:34:41.048]                   sendCondition <- NULL
[13:34:41.048]                   function(frame = 1L) {
[13:34:41.048]                     if (is.function(sendCondition)) 
[13:34:41.048]                       return(sendCondition)
[13:34:41.048]                     ns <- getNamespace("parallel")
[13:34:41.048]                     if (exists("sendData", mode = "function", 
[13:34:41.048]                       envir = ns)) {
[13:34:41.048]                       parallel_sendData <- get("sendData", mode = "function", 
[13:34:41.048]                         envir = ns)
[13:34:41.048]                       envir <- sys.frame(frame)
[13:34:41.048]                       master <- NULL
[13:34:41.048]                       while (!identical(envir, .GlobalEnv) && 
[13:34:41.048]                         !identical(envir, emptyenv())) {
[13:34:41.048]                         if (exists("master", mode = "list", envir = envir, 
[13:34:41.048]                           inherits = FALSE)) {
[13:34:41.048]                           master <- get("master", mode = "list", 
[13:34:41.048]                             envir = envir, inherits = FALSE)
[13:34:41.048]                           if (inherits(master, c("SOCKnode", 
[13:34:41.048]                             "SOCK0node"))) {
[13:34:41.048]                             sendCondition <<- function(cond) {
[13:34:41.048]                               data <- list(type = "VALUE", value = cond, 
[13:34:41.048]                                 success = TRUE)
[13:34:41.048]                               parallel_sendData(master, data)
[13:34:41.048]                             }
[13:34:41.048]                             return(sendCondition)
[13:34:41.048]                           }
[13:34:41.048]                         }
[13:34:41.048]                         frame <- frame + 1L
[13:34:41.048]                         envir <- sys.frame(frame)
[13:34:41.048]                       }
[13:34:41.048]                     }
[13:34:41.048]                     sendCondition <<- function(cond) NULL
[13:34:41.048]                   }
[13:34:41.048]                 })
[13:34:41.048]                 withCallingHandlers({
[13:34:41.048]                   {
[13:34:41.048]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:41.048]                     if (!identical(...future.globals.maxSize.org, 
[13:34:41.048]                       ...future.globals.maxSize)) {
[13:34:41.048]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:41.048]                       on.exit(options(oopts), add = TRUE)
[13:34:41.048]                     }
[13:34:41.048]                     {
[13:34:41.048]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:41.048]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:34:41.048]                         USE.NAMES = FALSE)
[13:34:41.048]                       do.call(mapply, args = args)
[13:34:41.048]                     }
[13:34:41.048]                   }
[13:34:41.048]                 }, immediateCondition = function(cond) {
[13:34:41.048]                   sendCondition <- ...future.makeSendCondition()
[13:34:41.048]                   sendCondition(cond)
[13:34:41.048]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:41.048]                   {
[13:34:41.048]                     inherits <- base::inherits
[13:34:41.048]                     invokeRestart <- base::invokeRestart
[13:34:41.048]                     is.null <- base::is.null
[13:34:41.048]                     muffled <- FALSE
[13:34:41.048]                     if (inherits(cond, "message")) {
[13:34:41.048]                       muffled <- grepl(pattern, "muffleMessage")
[13:34:41.048]                       if (muffled) 
[13:34:41.048]                         invokeRestart("muffleMessage")
[13:34:41.048]                     }
[13:34:41.048]                     else if (inherits(cond, "warning")) {
[13:34:41.048]                       muffled <- grepl(pattern, "muffleWarning")
[13:34:41.048]                       if (muffled) 
[13:34:41.048]                         invokeRestart("muffleWarning")
[13:34:41.048]                     }
[13:34:41.048]                     else if (inherits(cond, "condition")) {
[13:34:41.048]                       if (!is.null(pattern)) {
[13:34:41.048]                         computeRestarts <- base::computeRestarts
[13:34:41.048]                         grepl <- base::grepl
[13:34:41.048]                         restarts <- computeRestarts(cond)
[13:34:41.048]                         for (restart in restarts) {
[13:34:41.048]                           name <- restart$name
[13:34:41.048]                           if (is.null(name)) 
[13:34:41.048]                             next
[13:34:41.048]                           if (!grepl(pattern, name)) 
[13:34:41.048]                             next
[13:34:41.048]                           invokeRestart(restart)
[13:34:41.048]                           muffled <- TRUE
[13:34:41.048]                           break
[13:34:41.048]                         }
[13:34:41.048]                       }
[13:34:41.048]                     }
[13:34:41.048]                     invisible(muffled)
[13:34:41.048]                   }
[13:34:41.048]                   muffleCondition(cond)
[13:34:41.048]                 })
[13:34:41.048]             }))
[13:34:41.048]             future::FutureResult(value = ...future.value$value, 
[13:34:41.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:41.048]                   ...future.rng), globalenv = if (FALSE) 
[13:34:41.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:34:41.048]                     ...future.globalenv.names))
[13:34:41.048]                 else NULL, started = ...future.startTime, version = "1.8")
[13:34:41.048]         }, condition = base::local({
[13:34:41.048]             c <- base::c
[13:34:41.048]             inherits <- base::inherits
[13:34:41.048]             invokeRestart <- base::invokeRestart
[13:34:41.048]             length <- base::length
[13:34:41.048]             list <- base::list
[13:34:41.048]             seq.int <- base::seq.int
[13:34:41.048]             signalCondition <- base::signalCondition
[13:34:41.048]             sys.calls <- base::sys.calls
[13:34:41.048]             `[[` <- base::`[[`
[13:34:41.048]             `+` <- base::`+`
[13:34:41.048]             `<<-` <- base::`<<-`
[13:34:41.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:34:41.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:34:41.048]                   3L)]
[13:34:41.048]             }
[13:34:41.048]             function(cond) {
[13:34:41.048]                 is_error <- inherits(cond, "error")
[13:34:41.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:34:41.048]                   NULL)
[13:34:41.048]                 if (is_error) {
[13:34:41.048]                   sessionInformation <- function() {
[13:34:41.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:34:41.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:34:41.048]                       search = base::search(), system = base::Sys.info())
[13:34:41.048]                   }
[13:34:41.048]                   ...future.conditions[[length(...future.conditions) + 
[13:34:41.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:34:41.048]                     cond$call), session = sessionInformation(), 
[13:34:41.048]                     timestamp = base::Sys.time(), signaled = 0L)
[13:34:41.048]                   signalCondition(cond)
[13:34:41.048]                 }
[13:34:41.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:34:41.048]                 "immediateCondition"))) {
[13:34:41.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:34:41.048]                   ...future.conditions[[length(...future.conditions) + 
[13:34:41.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:34:41.048]                   if (TRUE && !signal) {
[13:34:41.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:41.048]                     {
[13:34:41.048]                       inherits <- base::inherits
[13:34:41.048]                       invokeRestart <- base::invokeRestart
[13:34:41.048]                       is.null <- base::is.null
[13:34:41.048]                       muffled <- FALSE
[13:34:41.048]                       if (inherits(cond, "message")) {
[13:34:41.048]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:41.048]                         if (muffled) 
[13:34:41.048]                           invokeRestart("muffleMessage")
[13:34:41.048]                       }
[13:34:41.048]                       else if (inherits(cond, "warning")) {
[13:34:41.048]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:41.048]                         if (muffled) 
[13:34:41.048]                           invokeRestart("muffleWarning")
[13:34:41.048]                       }
[13:34:41.048]                       else if (inherits(cond, "condition")) {
[13:34:41.048]                         if (!is.null(pattern)) {
[13:34:41.048]                           computeRestarts <- base::computeRestarts
[13:34:41.048]                           grepl <- base::grepl
[13:34:41.048]                           restarts <- computeRestarts(cond)
[13:34:41.048]                           for (restart in restarts) {
[13:34:41.048]                             name <- restart$name
[13:34:41.048]                             if (is.null(name)) 
[13:34:41.048]                               next
[13:34:41.048]                             if (!grepl(pattern, name)) 
[13:34:41.048]                               next
[13:34:41.048]                             invokeRestart(restart)
[13:34:41.048]                             muffled <- TRUE
[13:34:41.048]                             break
[13:34:41.048]                           }
[13:34:41.048]                         }
[13:34:41.048]                       }
[13:34:41.048]                       invisible(muffled)
[13:34:41.048]                     }
[13:34:41.048]                     muffleCondition(cond, pattern = "^muffle")
[13:34:41.048]                   }
[13:34:41.048]                 }
[13:34:41.048]                 else {
[13:34:41.048]                   if (TRUE) {
[13:34:41.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:34:41.048]                     {
[13:34:41.048]                       inherits <- base::inherits
[13:34:41.048]                       invokeRestart <- base::invokeRestart
[13:34:41.048]                       is.null <- base::is.null
[13:34:41.048]                       muffled <- FALSE
[13:34:41.048]                       if (inherits(cond, "message")) {
[13:34:41.048]                         muffled <- grepl(pattern, "muffleMessage")
[13:34:41.048]                         if (muffled) 
[13:34:41.048]                           invokeRestart("muffleMessage")
[13:34:41.048]                       }
[13:34:41.048]                       else if (inherits(cond, "warning")) {
[13:34:41.048]                         muffled <- grepl(pattern, "muffleWarning")
[13:34:41.048]                         if (muffled) 
[13:34:41.048]                           invokeRestart("muffleWarning")
[13:34:41.048]                       }
[13:34:41.048]                       else if (inherits(cond, "condition")) {
[13:34:41.048]                         if (!is.null(pattern)) {
[13:34:41.048]                           computeRestarts <- base::computeRestarts
[13:34:41.048]                           grepl <- base::grepl
[13:34:41.048]                           restarts <- computeRestarts(cond)
[13:34:41.048]                           for (restart in restarts) {
[13:34:41.048]                             name <- restart$name
[13:34:41.048]                             if (is.null(name)) 
[13:34:41.048]                               next
[13:34:41.048]                             if (!grepl(pattern, name)) 
[13:34:41.048]                               next
[13:34:41.048]                             invokeRestart(restart)
[13:34:41.048]                             muffled <- TRUE
[13:34:41.048]                             break
[13:34:41.048]                           }
[13:34:41.048]                         }
[13:34:41.048]                       }
[13:34:41.048]                       invisible(muffled)
[13:34:41.048]                     }
[13:34:41.048]                     muffleCondition(cond, pattern = "^muffle")
[13:34:41.048]                   }
[13:34:41.048]                 }
[13:34:41.048]             }
[13:34:41.048]         }))
[13:34:41.048]     }, error = function(ex) {
[13:34:41.048]         base::structure(base::list(value = NULL, visible = NULL, 
[13:34:41.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:34:41.048]                 ...future.rng), started = ...future.startTime, 
[13:34:41.048]             finished = Sys.time(), session_uuid = NA_character_, 
[13:34:41.048]             version = "1.8"), class = "FutureResult")
[13:34:41.048]     }, finally = {
[13:34:41.048]         if (!identical(...future.workdir, getwd())) 
[13:34:41.048]             setwd(...future.workdir)
[13:34:41.048]         {
[13:34:41.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:34:41.048]                 ...future.oldOptions$nwarnings <- NULL
[13:34:41.048]             }
[13:34:41.048]             base::options(...future.oldOptions)
[13:34:41.048]             if (.Platform$OS.type == "windows") {
[13:34:41.048]                 old_names <- names(...future.oldEnvVars)
[13:34:41.048]                 envs <- base::Sys.getenv()
[13:34:41.048]                 names <- names(envs)
[13:34:41.048]                 common <- intersect(names, old_names)
[13:34:41.048]                 added <- setdiff(names, old_names)
[13:34:41.048]                 removed <- setdiff(old_names, names)
[13:34:41.048]                 changed <- common[...future.oldEnvVars[common] != 
[13:34:41.048]                   envs[common]]
[13:34:41.048]                 NAMES <- toupper(changed)
[13:34:41.048]                 args <- list()
[13:34:41.048]                 for (kk in seq_along(NAMES)) {
[13:34:41.048]                   name <- changed[[kk]]
[13:34:41.048]                   NAME <- NAMES[[kk]]
[13:34:41.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:41.048]                     next
[13:34:41.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:41.048]                 }
[13:34:41.048]                 NAMES <- toupper(added)
[13:34:41.048]                 for (kk in seq_along(NAMES)) {
[13:34:41.048]                   name <- added[[kk]]
[13:34:41.048]                   NAME <- NAMES[[kk]]
[13:34:41.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:41.048]                     next
[13:34:41.048]                   args[[name]] <- ""
[13:34:41.048]                 }
[13:34:41.048]                 NAMES <- toupper(removed)
[13:34:41.048]                 for (kk in seq_along(NAMES)) {
[13:34:41.048]                   name <- removed[[kk]]
[13:34:41.048]                   NAME <- NAMES[[kk]]
[13:34:41.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:34:41.048]                     next
[13:34:41.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:34:41.048]                 }
[13:34:41.048]                 if (length(args) > 0) 
[13:34:41.048]                   base::do.call(base::Sys.setenv, args = args)
[13:34:41.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:34:41.048]             }
[13:34:41.048]             else {
[13:34:41.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:34:41.048]             }
[13:34:41.048]             {
[13:34:41.048]                 if (base::length(...future.futureOptionsAdded) > 
[13:34:41.048]                   0L) {
[13:34:41.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:34:41.048]                   base::names(opts) <- ...future.futureOptionsAdded
[13:34:41.048]                   base::options(opts)
[13:34:41.048]                 }
[13:34:41.048]                 {
[13:34:41.048]                   {
[13:34:41.048]                     base::options(mc.cores = ...future.mc.cores.old)
[13:34:41.048]                     NULL
[13:34:41.048]                   }
[13:34:41.048]                   options(future.plan = NULL)
[13:34:41.048]                   if (is.na(NA_character_)) 
[13:34:41.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:34:41.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:34:41.048]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:34:41.048]                     .init = FALSE)
[13:34:41.048]                 }
[13:34:41.048]             }
[13:34:41.048]         }
[13:34:41.048]     })
[13:34:41.048]     if (TRUE) {
[13:34:41.048]         base::sink(type = "output", split = FALSE)
[13:34:41.048]         if (TRUE) {
[13:34:41.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:34:41.048]         }
[13:34:41.048]         else {
[13:34:41.048]             ...future.result["stdout"] <- base::list(NULL)
[13:34:41.048]         }
[13:34:41.048]         base::close(...future.stdout)
[13:34:41.048]         ...future.stdout <- NULL
[13:34:41.048]     }
[13:34:41.048]     ...future.result$conditions <- ...future.conditions
[13:34:41.048]     ...future.result$finished <- base::Sys.time()
[13:34:41.048]     ...future.result
[13:34:41.048] }
[13:34:41.051] Exporting 5 global objects (904 bytes) to cluster node #2 ...
[13:34:41.051] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:34:41.052] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:34:41.052] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:34:41.052] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:34:41.052] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:34:41.052] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:34:41.052] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:34:41.053] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:34:41.053] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:34:41.053] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:34:41.053] Exporting 5 global objects (904 bytes) to cluster node #2 ... DONE
[13:34:41.054] MultisessionFuture started
[13:34:41.054] - Launch lazy future ... done
[13:34:41.054] run() for ‘MultisessionFuture’ ... done
[13:34:41.054] Created future:
[13:34:41.054] MultisessionFuture:
[13:34:41.054] Label: ‘future_mapply-2’
[13:34:41.054] Expression:
[13:34:41.054] {
[13:34:41.054]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:34:41.054]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:34:41.054]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:34:41.054]         on.exit(options(oopts), add = TRUE)
[13:34:41.054]     }
[13:34:41.054]     {
[13:34:41.054]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:34:41.054]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:34:41.054]         do.call(mapply, args = args)
[13:34:41.054]     }
[13:34:41.054] }
[13:34:41.054] Lazy evaluation: FALSE
[13:34:41.054] Asynchronous evaluation: TRUE
[13:34:41.054] Local evaluation: TRUE
[13:34:41.054] Environment: R_GlobalEnv
[13:34:41.054] Capture standard output: TRUE
[13:34:41.054] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:34:41.054] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:34:41.054] Packages: <none>
[13:34:41.054] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:34:41.054] Resolved: FALSE
[13:34:41.054] Value: <not collected>
[13:34:41.054] Conditions captured: <none>
[13:34:41.054] Early signaling: FALSE
[13:34:41.054] Owner process: 26d7f9f8-fe17-f187-9632-fd2d2ec60adc
[13:34:41.054] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:34:41.066] Chunk #2 of 2 ... DONE
[13:34:41.066] Launching 2 futures (chunks) ... DONE
[13:34:41.066] Resolving 2 futures (chunks) ...
[13:34:41.066] resolve() on list ...
[13:34:41.066]  recursive: 0
[13:34:41.066]  length: 2
[13:34:41.066] 
[13:34:41.067] receiveMessageFromWorker() for ClusterFuture ...
[13:34:41.067] - Validating connection of MultisessionFuture
[13:34:41.067] - received message: FutureResult
[13:34:41.067] - Received FutureResult
[13:34:41.067] - Erased future from FutureRegistry
[13:34:41.067] result() for ClusterFuture ...
[13:34:41.067] - result already collected: FutureResult
[13:34:41.068] result() for ClusterFuture ... done
[13:34:41.068] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:41.068] Future #1
[13:34:41.068] result() for ClusterFuture ...
[13:34:41.068] - result already collected: FutureResult
[13:34:41.068] result() for ClusterFuture ... done
[13:34:41.068] result() for ClusterFuture ...
[13:34:41.068] - result already collected: FutureResult
[13:34:41.068] result() for ClusterFuture ... done
[13:34:41.068] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:34:41.068] - nx: 2
[13:34:41.068] - relay: TRUE
[13:34:41.069] - stdout: TRUE
[13:34:41.069] - signal: TRUE
[13:34:41.069] - resignal: FALSE
[13:34:41.069] - force: TRUE
[13:34:41.069] - relayed: [n=2] FALSE, FALSE
[13:34:41.069] - queued futures: [n=2] FALSE, FALSE
[13:34:41.069]  - until=1
[13:34:41.069]  - relaying element #1
[13:34:41.069] result() for ClusterFuture ...
[13:34:41.069] - result already collected: FutureResult
[13:34:41.069] result() for ClusterFuture ... done
[13:34:41.070] result() for ClusterFuture ...
[13:34:41.070] - result already collected: FutureResult
[13:34:41.070] result() for ClusterFuture ... done
[13:34:41.070] result() for ClusterFuture ...
[13:34:41.070] - result already collected: FutureResult
[13:34:41.070] result() for ClusterFuture ... done
[13:34:41.070] result() for ClusterFuture ...
[13:34:41.070] - result already collected: FutureResult
[13:34:41.070] result() for ClusterFuture ... done
[13:34:41.070] - relayed: [n=2] TRUE, FALSE
[13:34:41.070] - queued futures: [n=2] TRUE, FALSE
[13:34:41.071] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:34:41.071]  length: 1 (resolved future 1)
[13:34:41.096] receiveMessageFromWorker() for ClusterFuture ...
[13:34:41.096] - Validating connection of MultisessionFuture
[13:34:41.096] - received message: FutureResult
[13:34:41.096] - Received FutureResult
[13:34:41.096] - Erased future from FutureRegistry
[13:34:41.096] result() for ClusterFuture ...
[13:34:41.096] - result already collected: FutureResult
[13:34:41.096] result() for ClusterFuture ... done
[13:34:41.096] receiveMessageFromWorker() for ClusterFuture ... done
[13:34:41.097] Future #2
[13:34:41.097] result() for ClusterFuture ...
[13:34:41.097] - result already collected: FutureResult
[13:34:41.097] result() for ClusterFuture ... done
[13:34:41.097] result() for ClusterFuture ...
[13:34:41.097] - result already collected: FutureResult
[13:34:41.097] result() for ClusterFuture ... done
[13:34:41.097] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:34:41.097] - nx: 2
[13:34:41.097] - relay: TRUE
[13:34:41.097] - stdout: TRUE
[13:34:41.097] - signal: TRUE
[13:34:41.098] - resignal: FALSE
[13:34:41.098] - force: TRUE
[13:34:41.098] - relayed: [n=2] TRUE, FALSE
[13:34:41.098] - queued futures: [n=2] TRUE, FALSE
[13:34:41.098]  - until=2
[13:34:41.098]  - relaying element #2
[13:34:41.098] result() for ClusterFuture ...
[13:34:41.098] - result already collected: FutureResult
[13:34:41.098] result() for ClusterFuture ... done
[13:34:41.098] result() for ClusterFuture ...
[13:34:41.098] - result already collected: FutureResult
[13:34:41.099] result() for ClusterFuture ... done
[13:34:41.099] result() for ClusterFuture ...
[13:34:41.099] - result already collected: FutureResult
[13:34:41.099] result() for ClusterFuture ... done
[13:34:41.099] result() for ClusterFuture ...
[13:34:41.099] - result already collected: FutureResult
[13:34:41.099] result() for ClusterFuture ... done
[13:34:41.099] - relayed: [n=2] TRUE, TRUE
[13:34:41.099] - queued futures: [n=2] TRUE, TRUE
[13:34:41.099] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:34:41.099]  length: 0 (resolved future 2)
[13:34:41.100] Relaying remaining futures
[13:34:41.100] signalConditionsASAP(NULL, pos=0) ...
[13:34:41.100] - nx: 2
[13:34:41.100] - relay: TRUE
[13:34:41.100] - stdout: TRUE
[13:34:41.100] - signal: TRUE
[13:34:41.100] - resignal: FALSE
[13:34:41.100] - force: TRUE
[13:34:41.100] - relayed: [n=2] TRUE, TRUE
[13:34:41.100] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:34:41.100] - relayed: [n=2] TRUE, TRUE
[13:34:41.100] - queued futures: [n=2] TRUE, TRUE
[13:34:41.101] signalConditionsASAP(NULL, pos=0) ... done
[13:34:41.101] resolve() on list ... DONE
[13:34:41.101] result() for ClusterFuture ...
[13:34:41.101] - result already collected: FutureResult
[13:34:41.101] result() for ClusterFuture ... done
[13:34:41.101] result() for ClusterFuture ...
[13:34:41.101] - result already collected: FutureResult
[13:34:41.101] result() for ClusterFuture ... done
[13:34:41.101] result() for ClusterFuture ...
[13:34:41.101] - result already collected: FutureResult
[13:34:41.101] result() for ClusterFuture ... done
[13:34:41.102] result() for ClusterFuture ...
[13:34:41.102] - result already collected: FutureResult
[13:34:41.102] result() for ClusterFuture ... done
[13:34:41.102]  - Number of value chunks collected: 2
[13:34:41.102] Resolving 2 futures (chunks) ... DONE
[13:34:41.102] Reducing values from 2 chunks ...
[13:34:41.102]  - Number of values collected after concatenation: 2
[13:34:41.102]  - Number of values expected: 2
[13:34:41.102] Reducing values from 2 chunks ... DONE
[13:34:41.102] future_mapply() ... DONE
[13:34:41.103] plan(): Setting new future strategy stack:
[13:34:41.103] List of future strategies:
[13:34:41.103] 1. sequential:
[13:34:41.103]    - args: function (..., envir = parent.frame())
[13:34:41.103]    - tweaked: FALSE
[13:34:41.103]    - call: plan(sequential)
[13:34:41.103] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("- Empty input [non parallel] ...")
- Empty input [non parallel] ...
> y0 <- mapply(search)
> y1 <- future_mapply(search)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(list, integer(0L))
> y1 <- future_mapply(list, integer(0L))
> stopifnot(identical(y1, y0))
> 
> message("*** future_mapply() - special cases ...")
*** future_mapply() - special cases ...
> 
> X <- list()
> names(X) <- character(0L)
> 
> y <- future_mapply(FUN = identity, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> y <- future_mapply(FUN = identity, X, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> message("*** future_mapply() - special cases ... DONE")
*** future_mapply() - special cases ... DONE
> 
> message("*** future_mapply() ... DONE")
*** future_mapply() ... DONE
> 
> source("incl/end.R")
[13:34:41.105] plan(): Setting new future strategy stack:
[13:34:41.105] List of future strategies:
[13:34:41.105] 1. FutureStrategy:
[13:34:41.105]    - args: function (..., envir = parent.frame())
[13:34:41.105]    - tweaked: FALSE
[13:34:41.105]    - call: future::plan(oplan)
[13:34:41.106] plan(): nbrOfWorkers() = 1
> 
